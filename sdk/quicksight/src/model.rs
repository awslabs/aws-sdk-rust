// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `ExceptionResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let exceptionresourcetype = unimplemented!();
/// match exceptionresourcetype {
///     ExceptionResourceType::AccountSettings => { /* ... */ },
///     ExceptionResourceType::DataSet => { /* ... */ },
///     ExceptionResourceType::DataSource => { /* ... */ },
///     ExceptionResourceType::Group => { /* ... */ },
///     ExceptionResourceType::IampolicyAssignment => { /* ... */ },
///     ExceptionResourceType::Ingestion => { /* ... */ },
///     ExceptionResourceType::Namespace => { /* ... */ },
///     ExceptionResourceType::User => { /* ... */ },
///     ExceptionResourceType::VpcConnection => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `exceptionresourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ExceptionResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ExceptionResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ExceptionResourceType::NewFeature` is defined.
/// Specifically, when `exceptionresourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ExceptionResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExceptionResourceType {
    #[allow(missing_docs)] // documentation missing in model
    AccountSettings,
    #[allow(missing_docs)] // documentation missing in model
    DataSet,
    #[allow(missing_docs)] // documentation missing in model
    DataSource,
    #[allow(missing_docs)] // documentation missing in model
    Group,
    #[allow(missing_docs)] // documentation missing in model
    IampolicyAssignment,
    #[allow(missing_docs)] // documentation missing in model
    Ingestion,
    #[allow(missing_docs)] // documentation missing in model
    Namespace,
    #[allow(missing_docs)] // documentation missing in model
    User,
    #[allow(missing_docs)] // documentation missing in model
    VpcConnection,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ExceptionResourceType {
    fn from(s: &str) -> Self {
        match s {
            "ACCOUNT_SETTINGS" => ExceptionResourceType::AccountSettings,
            "DATA_SET" => ExceptionResourceType::DataSet,
            "DATA_SOURCE" => ExceptionResourceType::DataSource,
            "GROUP" => ExceptionResourceType::Group,
            "IAMPOLICY_ASSIGNMENT" => ExceptionResourceType::IampolicyAssignment,
            "INGESTION" => ExceptionResourceType::Ingestion,
            "NAMESPACE" => ExceptionResourceType::Namespace,
            "USER" => ExceptionResourceType::User,
            "VPC_CONNECTION" => ExceptionResourceType::VpcConnection,
            other => {
                ExceptionResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ExceptionResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ExceptionResourceType::from(s))
    }
}
impl ExceptionResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExceptionResourceType::AccountSettings => "ACCOUNT_SETTINGS",
            ExceptionResourceType::DataSet => "DATA_SET",
            ExceptionResourceType::DataSource => "DATA_SOURCE",
            ExceptionResourceType::Group => "GROUP",
            ExceptionResourceType::IampolicyAssignment => "IAMPOLICY_ASSIGNMENT",
            ExceptionResourceType::Ingestion => "INGESTION",
            ExceptionResourceType::Namespace => "NAMESPACE",
            ExceptionResourceType::User => "USER",
            ExceptionResourceType::VpcConnection => "VPC_CONNECTION",
            ExceptionResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACCOUNT_SETTINGS",
            "DATA_SET",
            "DATA_SOURCE",
            "GROUP",
            "IAMPOLICY_ASSIGNMENT",
            "INGESTION",
            "NAMESPACE",
            "USER",
            "VPC_CONNECTION",
        ]
    }
}
impl AsRef<str> for ExceptionResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A registered user of Amazon QuickSight. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct User {
    /// <p>The Amazon Resource Name (ARN) for the user.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The user's user name. This value is required if you are registering a user that will be managed in Amazon QuickSight. In the output, the value for <code>UserName</code> is <code>N/A</code> when the value for <code>IdentityType</code> is <code>IAM</code> and the corresponding IAM user is deleted.</p>
    #[doc(hidden)]
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The user's email address.</p>
    #[doc(hidden)]
    pub email: std::option::Option<std::string::String>,
    /// <p>The Amazon QuickSight role for the user. The user role can be one of the following:.</p>
    /// <ul>
    /// <li> <p> <code>READER</code>: A user who has read-only access to dashboards.</p> </li>
    /// <li> <p> <code>AUTHOR</code>: A user who can create data sources, datasets, analyses, and dashboards.</p> </li>
    /// <li> <p> <code>ADMIN</code>: A user who is an author, who can also manage Amazon Amazon QuickSight settings.</p> </li>
    /// <li> <p> <code>RESTRICTED_READER</code>: This role isn't currently available for use.</p> </li>
    /// <li> <p> <code>RESTRICTED_AUTHOR</code>: This role isn't currently available for use.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub role: std::option::Option<crate::model::UserRole>,
    /// <p>The type of identity authentication used by the user.</p>
    #[doc(hidden)]
    pub identity_type: std::option::Option<crate::model::IdentityType>,
    /// <p>The active status of user. When you create an Amazon QuickSight user thatâ€™s not an IAM user or an Active Directory user, that user is inactive until they sign in and provide a password.</p>
    #[doc(hidden)]
    pub active: bool,
    /// <p>The principal ID of the user.</p>
    #[doc(hidden)]
    pub principal_id: std::option::Option<std::string::String>,
    /// <p>The custom permissions profile associated with this user.</p>
    #[doc(hidden)]
    pub custom_permissions_name: std::option::Option<std::string::String>,
    /// <p>The type of supported external login provider that provides identity to let the user federate into Amazon QuickSight with an associated IAM role. The type can be one of the following.</p>
    /// <ul>
    /// <li> <p> <code>COGNITO</code>: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com.</p> </li>
    /// <li> <p> <code>CUSTOM_OIDC</code>: Custom OpenID Connect (OIDC) provider.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub external_login_federation_provider_type: std::option::Option<std::string::String>,
    /// <p>The URL of the external login provider.</p>
    #[doc(hidden)]
    pub external_login_federation_provider_url: std::option::Option<std::string::String>,
    /// <p>The identity ID for the user in the external login provider.</p>
    #[doc(hidden)]
    pub external_login_id: std::option::Option<std::string::String>,
}
impl User {
    /// <p>The Amazon Resource Name (ARN) for the user.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The user's user name. This value is required if you are registering a user that will be managed in Amazon QuickSight. In the output, the value for <code>UserName</code> is <code>N/A</code> when the value for <code>IdentityType</code> is <code>IAM</code> and the corresponding IAM user is deleted.</p>
    pub fn user_name(&self) -> std::option::Option<&str> {
        self.user_name.as_deref()
    }
    /// <p>The user's email address.</p>
    pub fn email(&self) -> std::option::Option<&str> {
        self.email.as_deref()
    }
    /// <p>The Amazon QuickSight role for the user. The user role can be one of the following:.</p>
    /// <ul>
    /// <li> <p> <code>READER</code>: A user who has read-only access to dashboards.</p> </li>
    /// <li> <p> <code>AUTHOR</code>: A user who can create data sources, datasets, analyses, and dashboards.</p> </li>
    /// <li> <p> <code>ADMIN</code>: A user who is an author, who can also manage Amazon Amazon QuickSight settings.</p> </li>
    /// <li> <p> <code>RESTRICTED_READER</code>: This role isn't currently available for use.</p> </li>
    /// <li> <p> <code>RESTRICTED_AUTHOR</code>: This role isn't currently available for use.</p> </li>
    /// </ul>
    pub fn role(&self) -> std::option::Option<&crate::model::UserRole> {
        self.role.as_ref()
    }
    /// <p>The type of identity authentication used by the user.</p>
    pub fn identity_type(&self) -> std::option::Option<&crate::model::IdentityType> {
        self.identity_type.as_ref()
    }
    /// <p>The active status of user. When you create an Amazon QuickSight user thatâ€™s not an IAM user or an Active Directory user, that user is inactive until they sign in and provide a password.</p>
    pub fn active(&self) -> bool {
        self.active
    }
    /// <p>The principal ID of the user.</p>
    pub fn principal_id(&self) -> std::option::Option<&str> {
        self.principal_id.as_deref()
    }
    /// <p>The custom permissions profile associated with this user.</p>
    pub fn custom_permissions_name(&self) -> std::option::Option<&str> {
        self.custom_permissions_name.as_deref()
    }
    /// <p>The type of supported external login provider that provides identity to let the user federate into Amazon QuickSight with an associated IAM role. The type can be one of the following.</p>
    /// <ul>
    /// <li> <p> <code>COGNITO</code>: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com.</p> </li>
    /// <li> <p> <code>CUSTOM_OIDC</code>: Custom OpenID Connect (OIDC) provider.</p> </li>
    /// </ul>
    pub fn external_login_federation_provider_type(&self) -> std::option::Option<&str> {
        self.external_login_federation_provider_type.as_deref()
    }
    /// <p>The URL of the external login provider.</p>
    pub fn external_login_federation_provider_url(&self) -> std::option::Option<&str> {
        self.external_login_federation_provider_url.as_deref()
    }
    /// <p>The identity ID for the user in the external login provider.</p>
    pub fn external_login_id(&self) -> std::option::Option<&str> {
        self.external_login_id.as_deref()
    }
}
/// See [`User`](crate::model::User).
pub mod user {

    /// A builder for [`User`](crate::model::User).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) email: std::option::Option<std::string::String>,
        pub(crate) role: std::option::Option<crate::model::UserRole>,
        pub(crate) identity_type: std::option::Option<crate::model::IdentityType>,
        pub(crate) active: std::option::Option<bool>,
        pub(crate) principal_id: std::option::Option<std::string::String>,
        pub(crate) custom_permissions_name: std::option::Option<std::string::String>,
        pub(crate) external_login_federation_provider_type:
            std::option::Option<std::string::String>,
        pub(crate) external_login_federation_provider_url: std::option::Option<std::string::String>,
        pub(crate) external_login_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for the user.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the user.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The user's user name. This value is required if you are registering a user that will be managed in Amazon QuickSight. In the output, the value for <code>UserName</code> is <code>N/A</code> when the value for <code>IdentityType</code> is <code>IAM</code> and the corresponding IAM user is deleted.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_name = Some(input.into());
            self
        }
        /// <p>The user's user name. This value is required if you are registering a user that will be managed in Amazon QuickSight. In the output, the value for <code>UserName</code> is <code>N/A</code> when the value for <code>IdentityType</code> is <code>IAM</code> and the corresponding IAM user is deleted.</p>
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_name = input;
            self
        }
        /// <p>The user's email address.</p>
        pub fn email(mut self, input: impl Into<std::string::String>) -> Self {
            self.email = Some(input.into());
            self
        }
        /// <p>The user's email address.</p>
        pub fn set_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.email = input;
            self
        }
        /// <p>The Amazon QuickSight role for the user. The user role can be one of the following:.</p>
        /// <ul>
        /// <li> <p> <code>READER</code>: A user who has read-only access to dashboards.</p> </li>
        /// <li> <p> <code>AUTHOR</code>: A user who can create data sources, datasets, analyses, and dashboards.</p> </li>
        /// <li> <p> <code>ADMIN</code>: A user who is an author, who can also manage Amazon Amazon QuickSight settings.</p> </li>
        /// <li> <p> <code>RESTRICTED_READER</code>: This role isn't currently available for use.</p> </li>
        /// <li> <p> <code>RESTRICTED_AUTHOR</code>: This role isn't currently available for use.</p> </li>
        /// </ul>
        pub fn role(mut self, input: crate::model::UserRole) -> Self {
            self.role = Some(input);
            self
        }
        /// <p>The Amazon QuickSight role for the user. The user role can be one of the following:.</p>
        /// <ul>
        /// <li> <p> <code>READER</code>: A user who has read-only access to dashboards.</p> </li>
        /// <li> <p> <code>AUTHOR</code>: A user who can create data sources, datasets, analyses, and dashboards.</p> </li>
        /// <li> <p> <code>ADMIN</code>: A user who is an author, who can also manage Amazon Amazon QuickSight settings.</p> </li>
        /// <li> <p> <code>RESTRICTED_READER</code>: This role isn't currently available for use.</p> </li>
        /// <li> <p> <code>RESTRICTED_AUTHOR</code>: This role isn't currently available for use.</p> </li>
        /// </ul>
        pub fn set_role(mut self, input: std::option::Option<crate::model::UserRole>) -> Self {
            self.role = input;
            self
        }
        /// <p>The type of identity authentication used by the user.</p>
        pub fn identity_type(mut self, input: crate::model::IdentityType) -> Self {
            self.identity_type = Some(input);
            self
        }
        /// <p>The type of identity authentication used by the user.</p>
        pub fn set_identity_type(
            mut self,
            input: std::option::Option<crate::model::IdentityType>,
        ) -> Self {
            self.identity_type = input;
            self
        }
        /// <p>The active status of user. When you create an Amazon QuickSight user thatâ€™s not an IAM user or an Active Directory user, that user is inactive until they sign in and provide a password.</p>
        pub fn active(mut self, input: bool) -> Self {
            self.active = Some(input);
            self
        }
        /// <p>The active status of user. When you create an Amazon QuickSight user thatâ€™s not an IAM user or an Active Directory user, that user is inactive until they sign in and provide a password.</p>
        pub fn set_active(mut self, input: std::option::Option<bool>) -> Self {
            self.active = input;
            self
        }
        /// <p>The principal ID of the user.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_id = Some(input.into());
            self
        }
        /// <p>The principal ID of the user.</p>
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal_id = input;
            self
        }
        /// <p>The custom permissions profile associated with this user.</p>
        pub fn custom_permissions_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_permissions_name = Some(input.into());
            self
        }
        /// <p>The custom permissions profile associated with this user.</p>
        pub fn set_custom_permissions_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.custom_permissions_name = input;
            self
        }
        /// <p>The type of supported external login provider that provides identity to let the user federate into Amazon QuickSight with an associated IAM role. The type can be one of the following.</p>
        /// <ul>
        /// <li> <p> <code>COGNITO</code>: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com.</p> </li>
        /// <li> <p> <code>CUSTOM_OIDC</code>: Custom OpenID Connect (OIDC) provider.</p> </li>
        /// </ul>
        pub fn external_login_federation_provider_type(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.external_login_federation_provider_type = Some(input.into());
            self
        }
        /// <p>The type of supported external login provider that provides identity to let the user federate into Amazon QuickSight with an associated IAM role. The type can be one of the following.</p>
        /// <ul>
        /// <li> <p> <code>COGNITO</code>: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com.</p> </li>
        /// <li> <p> <code>CUSTOM_OIDC</code>: Custom OpenID Connect (OIDC) provider.</p> </li>
        /// </ul>
        pub fn set_external_login_federation_provider_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.external_login_federation_provider_type = input;
            self
        }
        /// <p>The URL of the external login provider.</p>
        pub fn external_login_federation_provider_url(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.external_login_federation_provider_url = Some(input.into());
            self
        }
        /// <p>The URL of the external login provider.</p>
        pub fn set_external_login_federation_provider_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.external_login_federation_provider_url = input;
            self
        }
        /// <p>The identity ID for the user in the external login provider.</p>
        pub fn external_login_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.external_login_id = Some(input.into());
            self
        }
        /// <p>The identity ID for the user in the external login provider.</p>
        pub fn set_external_login_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.external_login_id = input;
            self
        }
        /// Consumes the builder and constructs a [`User`](crate::model::User).
        pub fn build(self) -> crate::model::User {
            crate::model::User {
                arn: self.arn,
                user_name: self.user_name,
                email: self.email,
                role: self.role,
                identity_type: self.identity_type,
                active: self.active.unwrap_or_default(),
                principal_id: self.principal_id,
                custom_permissions_name: self.custom_permissions_name,
                external_login_federation_provider_type: self
                    .external_login_federation_provider_type,
                external_login_federation_provider_url: self.external_login_federation_provider_url,
                external_login_id: self.external_login_id,
            }
        }
    }
}
impl User {
    /// Creates a new builder-style object to manufacture [`User`](crate::model::User).
    pub fn builder() -> crate::model::user::Builder {
        crate::model::user::Builder::default()
    }
}

/// When writing a match expression against `IdentityType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let identitytype = unimplemented!();
/// match identitytype {
///     IdentityType::Iam => { /* ... */ },
///     IdentityType::Quicksight => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `identitytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `IdentityType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `IdentityType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `IdentityType::NewFeature` is defined.
/// Specifically, when `identitytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `IdentityType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IdentityType {
    #[allow(missing_docs)] // documentation missing in model
    Iam,
    #[allow(missing_docs)] // documentation missing in model
    Quicksight,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for IdentityType {
    fn from(s: &str) -> Self {
        match s {
            "IAM" => IdentityType::Iam,
            "QUICKSIGHT" => IdentityType::Quicksight,
            other => IdentityType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for IdentityType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IdentityType::from(s))
    }
}
impl IdentityType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            IdentityType::Iam => "IAM",
            IdentityType::Quicksight => "QUICKSIGHT",
            IdentityType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["IAM", "QUICKSIGHT"]
    }
}
impl AsRef<str> for IdentityType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `UserRole`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let userrole = unimplemented!();
/// match userrole {
///     UserRole::Admin => { /* ... */ },
///     UserRole::Author => { /* ... */ },
///     UserRole::Reader => { /* ... */ },
///     UserRole::RestrictedAuthor => { /* ... */ },
///     UserRole::RestrictedReader => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `userrole` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UserRole::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UserRole::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UserRole::NewFeature` is defined.
/// Specifically, when `userrole` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UserRole::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UserRole {
    #[allow(missing_docs)] // documentation missing in model
    Admin,
    #[allow(missing_docs)] // documentation missing in model
    Author,
    #[allow(missing_docs)] // documentation missing in model
    Reader,
    #[allow(missing_docs)] // documentation missing in model
    RestrictedAuthor,
    #[allow(missing_docs)] // documentation missing in model
    RestrictedReader,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UserRole {
    fn from(s: &str) -> Self {
        match s {
            "ADMIN" => UserRole::Admin,
            "AUTHOR" => UserRole::Author,
            "READER" => UserRole::Reader,
            "RESTRICTED_AUTHOR" => UserRole::RestrictedAuthor,
            "RESTRICTED_READER" => UserRole::RestrictedReader,
            other => UserRole::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for UserRole {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UserRole::from(s))
    }
}
impl UserRole {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UserRole::Admin => "ADMIN",
            UserRole::Author => "AUTHOR",
            UserRole::Reader => "READER",
            UserRole::RestrictedAuthor => "RESTRICTED_AUTHOR",
            UserRole::RestrictedReader => "RESTRICTED_READER",
            UserRole::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ADMIN",
            "AUTHOR",
            "READER",
            "RESTRICTED_AUTHOR",
            "RESTRICTED_READER",
        ]
    }
}
impl AsRef<str> for UserRole {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Permission for the resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourcePermission {
    /// <p>The Amazon Resource Name (ARN) of the principal. This can be one of the following:</p>
    /// <ul>
    /// <li> <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p> </li>
    /// <li> <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p> </li>
    /// <li> <p>The ARN of an Amazon Web Services account root: This is an IAM ARN rather than a QuickSight ARN. Use this option only to share resources (templates) across Amazon Web Services accounts. (This is less common.) </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub principal: std::option::Option<std::string::String>,
    /// <p>The IAM action to grant or revoke permissions on.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ResourcePermission {
    /// <p>The Amazon Resource Name (ARN) of the principal. This can be one of the following:</p>
    /// <ul>
    /// <li> <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p> </li>
    /// <li> <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p> </li>
    /// <li> <p>The ARN of an Amazon Web Services account root: This is an IAM ARN rather than a QuickSight ARN. Use this option only to share resources (templates) across Amazon Web Services accounts. (This is less common.) </p> </li>
    /// </ul>
    pub fn principal(&self) -> std::option::Option<&str> {
        self.principal.as_deref()
    }
    /// <p>The IAM action to grant or revoke permissions on.</p>
    pub fn actions(&self) -> std::option::Option<&[std::string::String]> {
        self.actions.as_deref()
    }
}
/// See [`ResourcePermission`](crate::model::ResourcePermission).
pub mod resource_permission {

    /// A builder for [`ResourcePermission`](crate::model::ResourcePermission).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) principal: std::option::Option<std::string::String>,
        pub(crate) actions: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the principal. This can be one of the following:</p>
        /// <ul>
        /// <li> <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p> </li>
        /// <li> <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p> </li>
        /// <li> <p>The ARN of an Amazon Web Services account root: This is an IAM ARN rather than a QuickSight ARN. Use this option only to share resources (templates) across Amazon Web Services accounts. (This is less common.) </p> </li>
        /// </ul>
        pub fn principal(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the principal. This can be one of the following:</p>
        /// <ul>
        /// <li> <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p> </li>
        /// <li> <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p> </li>
        /// <li> <p>The ARN of an Amazon Web Services account root: This is an IAM ARN rather than a QuickSight ARN. Use this option only to share resources (templates) across Amazon Web Services accounts. (This is less common.) </p> </li>
        /// </ul>
        pub fn set_principal(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The IAM action to grant or revoke permissions on.</p>
        pub fn actions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input.into());
            self.actions = Some(v);
            self
        }
        /// <p>The IAM action to grant or revoke permissions on.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourcePermission`](crate::model::ResourcePermission).
        pub fn build(self) -> crate::model::ResourcePermission {
            crate::model::ResourcePermission {
                principal: self.principal,
                actions: self.actions,
            }
        }
    }
}
impl ResourcePermission {
    /// Creates a new builder-style object to manufacture [`ResourcePermission`](crate::model::ResourcePermission).
    pub fn builder() -> crate::model::resource_permission::Builder {
        crate::model::resource_permission::Builder::default()
    }
}

/// <p>An alias for a theme.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThemeAlias {
    /// <p>The Amazon Resource Name (ARN) of the theme alias.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The display name of the theme alias.</p>
    #[doc(hidden)]
    pub alias_name: std::option::Option<std::string::String>,
    /// <p>The version number of the theme alias.</p>
    #[doc(hidden)]
    pub theme_version_number: std::option::Option<i64>,
}
impl ThemeAlias {
    /// <p>The Amazon Resource Name (ARN) of the theme alias.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The display name of the theme alias.</p>
    pub fn alias_name(&self) -> std::option::Option<&str> {
        self.alias_name.as_deref()
    }
    /// <p>The version number of the theme alias.</p>
    pub fn theme_version_number(&self) -> std::option::Option<i64> {
        self.theme_version_number
    }
}
/// See [`ThemeAlias`](crate::model::ThemeAlias).
pub mod theme_alias {

    /// A builder for [`ThemeAlias`](crate::model::ThemeAlias).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) alias_name: std::option::Option<std::string::String>,
        pub(crate) theme_version_number: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the theme alias.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the theme alias.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The display name of the theme alias.</p>
        pub fn alias_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias_name = Some(input.into());
            self
        }
        /// <p>The display name of the theme alias.</p>
        pub fn set_alias_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias_name = input;
            self
        }
        /// <p>The version number of the theme alias.</p>
        pub fn theme_version_number(mut self, input: i64) -> Self {
            self.theme_version_number = Some(input);
            self
        }
        /// <p>The version number of the theme alias.</p>
        pub fn set_theme_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.theme_version_number = input;
            self
        }
        /// Consumes the builder and constructs a [`ThemeAlias`](crate::model::ThemeAlias).
        pub fn build(self) -> crate::model::ThemeAlias {
            crate::model::ThemeAlias {
                arn: self.arn,
                alias_name: self.alias_name,
                theme_version_number: self.theme_version_number,
            }
        }
    }
}
impl ThemeAlias {
    /// Creates a new builder-style object to manufacture [`ThemeAlias`](crate::model::ThemeAlias).
    pub fn builder() -> crate::model::theme_alias::Builder {
        crate::model::theme_alias::Builder::default()
    }
}

/// When writing a match expression against `ResourceStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcestatus = unimplemented!();
/// match resourcestatus {
///     ResourceStatus::CreationFailed => { /* ... */ },
///     ResourceStatus::CreationInProgress => { /* ... */ },
///     ResourceStatus::CreationSuccessful => { /* ... */ },
///     ResourceStatus::Deleted => { /* ... */ },
///     ResourceStatus::UpdateFailed => { /* ... */ },
///     ResourceStatus::UpdateInProgress => { /* ... */ },
///     ResourceStatus::UpdateSuccessful => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceStatus::NewFeature` is defined.
/// Specifically, when `resourcestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceStatus {
    #[allow(missing_docs)] // documentation missing in model
    CreationFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreationInProgress,
    #[allow(missing_docs)] // documentation missing in model
    CreationSuccessful,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    UpdateSuccessful,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATION_FAILED" => ResourceStatus::CreationFailed,
            "CREATION_IN_PROGRESS" => ResourceStatus::CreationInProgress,
            "CREATION_SUCCESSFUL" => ResourceStatus::CreationSuccessful,
            "DELETED" => ResourceStatus::Deleted,
            "UPDATE_FAILED" => ResourceStatus::UpdateFailed,
            "UPDATE_IN_PROGRESS" => ResourceStatus::UpdateInProgress,
            "UPDATE_SUCCESSFUL" => ResourceStatus::UpdateSuccessful,
            other => ResourceStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ResourceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceStatus::from(s))
    }
}
impl ResourceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceStatus::CreationFailed => "CREATION_FAILED",
            ResourceStatus::CreationInProgress => "CREATION_IN_PROGRESS",
            ResourceStatus::CreationSuccessful => "CREATION_SUCCESSFUL",
            ResourceStatus::Deleted => "DELETED",
            ResourceStatus::UpdateFailed => "UPDATE_FAILED",
            ResourceStatus::UpdateInProgress => "UPDATE_IN_PROGRESS",
            ResourceStatus::UpdateSuccessful => "UPDATE_SUCCESSFUL",
            ResourceStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATION_FAILED",
            "CREATION_IN_PROGRESS",
            "CREATION_SUCCESSFUL",
            "DELETED",
            "UPDATE_FAILED",
            "UPDATE_IN_PROGRESS",
            "UPDATE_SUCCESSFUL",
        ]
    }
}
impl AsRef<str> for ResourceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The theme configuration. This configuration contains all of the display properties for a theme.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThemeConfiguration {
    /// <p>Color properties that apply to chart data colors.</p>
    #[doc(hidden)]
    pub data_color_palette: std::option::Option<crate::model::DataColorPalette>,
    /// <p>Color properties that apply to the UI and to charts, excluding the colors that apply to data. </p>
    #[doc(hidden)]
    pub ui_color_palette: std::option::Option<crate::model::UiColorPalette>,
    /// <p>Display options related to sheets.</p>
    #[doc(hidden)]
    pub sheet: std::option::Option<crate::model::SheetStyle>,
    /// <p>Determines the typography options.</p>
    #[doc(hidden)]
    pub typography: std::option::Option<crate::model::Typography>,
}
impl ThemeConfiguration {
    /// <p>Color properties that apply to chart data colors.</p>
    pub fn data_color_palette(&self) -> std::option::Option<&crate::model::DataColorPalette> {
        self.data_color_palette.as_ref()
    }
    /// <p>Color properties that apply to the UI and to charts, excluding the colors that apply to data. </p>
    pub fn ui_color_palette(&self) -> std::option::Option<&crate::model::UiColorPalette> {
        self.ui_color_palette.as_ref()
    }
    /// <p>Display options related to sheets.</p>
    pub fn sheet(&self) -> std::option::Option<&crate::model::SheetStyle> {
        self.sheet.as_ref()
    }
    /// <p>Determines the typography options.</p>
    pub fn typography(&self) -> std::option::Option<&crate::model::Typography> {
        self.typography.as_ref()
    }
}
/// See [`ThemeConfiguration`](crate::model::ThemeConfiguration).
pub mod theme_configuration {

    /// A builder for [`ThemeConfiguration`](crate::model::ThemeConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_color_palette: std::option::Option<crate::model::DataColorPalette>,
        pub(crate) ui_color_palette: std::option::Option<crate::model::UiColorPalette>,
        pub(crate) sheet: std::option::Option<crate::model::SheetStyle>,
        pub(crate) typography: std::option::Option<crate::model::Typography>,
    }
    impl Builder {
        /// <p>Color properties that apply to chart data colors.</p>
        pub fn data_color_palette(mut self, input: crate::model::DataColorPalette) -> Self {
            self.data_color_palette = Some(input);
            self
        }
        /// <p>Color properties that apply to chart data colors.</p>
        pub fn set_data_color_palette(
            mut self,
            input: std::option::Option<crate::model::DataColorPalette>,
        ) -> Self {
            self.data_color_palette = input;
            self
        }
        /// <p>Color properties that apply to the UI and to charts, excluding the colors that apply to data. </p>
        pub fn ui_color_palette(mut self, input: crate::model::UiColorPalette) -> Self {
            self.ui_color_palette = Some(input);
            self
        }
        /// <p>Color properties that apply to the UI and to charts, excluding the colors that apply to data. </p>
        pub fn set_ui_color_palette(
            mut self,
            input: std::option::Option<crate::model::UiColorPalette>,
        ) -> Self {
            self.ui_color_palette = input;
            self
        }
        /// <p>Display options related to sheets.</p>
        pub fn sheet(mut self, input: crate::model::SheetStyle) -> Self {
            self.sheet = Some(input);
            self
        }
        /// <p>Display options related to sheets.</p>
        pub fn set_sheet(mut self, input: std::option::Option<crate::model::SheetStyle>) -> Self {
            self.sheet = input;
            self
        }
        /// <p>Determines the typography options.</p>
        pub fn typography(mut self, input: crate::model::Typography) -> Self {
            self.typography = Some(input);
            self
        }
        /// <p>Determines the typography options.</p>
        pub fn set_typography(
            mut self,
            input: std::option::Option<crate::model::Typography>,
        ) -> Self {
            self.typography = input;
            self
        }
        /// Consumes the builder and constructs a [`ThemeConfiguration`](crate::model::ThemeConfiguration).
        pub fn build(self) -> crate::model::ThemeConfiguration {
            crate::model::ThemeConfiguration {
                data_color_palette: self.data_color_palette,
                ui_color_palette: self.ui_color_palette,
                sheet: self.sheet,
                typography: self.typography,
            }
        }
    }
}
impl ThemeConfiguration {
    /// Creates a new builder-style object to manufacture [`ThemeConfiguration`](crate::model::ThemeConfiguration).
    pub fn builder() -> crate::model::theme_configuration::Builder {
        crate::model::theme_configuration::Builder::default()
    }
}

/// <p>Determines the typography options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Typography {
    /// <p>Determines the list of font families.</p>
    #[doc(hidden)]
    pub font_families: std::option::Option<std::vec::Vec<crate::model::Font>>,
}
impl Typography {
    /// <p>Determines the list of font families.</p>
    pub fn font_families(&self) -> std::option::Option<&[crate::model::Font]> {
        self.font_families.as_deref()
    }
}
/// See [`Typography`](crate::model::Typography).
pub mod typography {

    /// A builder for [`Typography`](crate::model::Typography).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) font_families: std::option::Option<std::vec::Vec<crate::model::Font>>,
    }
    impl Builder {
        /// Appends an item to `font_families`.
        ///
        /// To override the contents of this collection use [`set_font_families`](Self::set_font_families).
        ///
        /// <p>Determines the list of font families.</p>
        pub fn font_families(mut self, input: crate::model::Font) -> Self {
            let mut v = self.font_families.unwrap_or_default();
            v.push(input);
            self.font_families = Some(v);
            self
        }
        /// <p>Determines the list of font families.</p>
        pub fn set_font_families(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Font>>,
        ) -> Self {
            self.font_families = input;
            self
        }
        /// Consumes the builder and constructs a [`Typography`](crate::model::Typography).
        pub fn build(self) -> crate::model::Typography {
            crate::model::Typography {
                font_families: self.font_families,
            }
        }
    }
}
impl Typography {
    /// Creates a new builder-style object to manufacture [`Typography`](crate::model::Typography).
    pub fn builder() -> crate::model::typography::Builder {
        crate::model::typography::Builder::default()
    }
}

/// <p>Determines the font settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Font {
    /// <p>Determines the font family settings.</p>
    #[doc(hidden)]
    pub font_family: std::option::Option<std::string::String>,
}
impl Font {
    /// <p>Determines the font family settings.</p>
    pub fn font_family(&self) -> std::option::Option<&str> {
        self.font_family.as_deref()
    }
}
/// See [`Font`](crate::model::Font).
pub mod font {

    /// A builder for [`Font`](crate::model::Font).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) font_family: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Determines the font family settings.</p>
        pub fn font_family(mut self, input: impl Into<std::string::String>) -> Self {
            self.font_family = Some(input.into());
            self
        }
        /// <p>Determines the font family settings.</p>
        pub fn set_font_family(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.font_family = input;
            self
        }
        /// Consumes the builder and constructs a [`Font`](crate::model::Font).
        pub fn build(self) -> crate::model::Font {
            crate::model::Font {
                font_family: self.font_family,
            }
        }
    }
}
impl Font {
    /// Creates a new builder-style object to manufacture [`Font`](crate::model::Font).
    pub fn builder() -> crate::model::font::Builder {
        crate::model::font::Builder::default()
    }
}

/// <p>The theme display options for sheets. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SheetStyle {
    /// <p>The display options for tiles.</p>
    #[doc(hidden)]
    pub tile: std::option::Option<crate::model::TileStyle>,
    /// <p>The layout options for tiles.</p>
    #[doc(hidden)]
    pub tile_layout: std::option::Option<crate::model::TileLayoutStyle>,
}
impl SheetStyle {
    /// <p>The display options for tiles.</p>
    pub fn tile(&self) -> std::option::Option<&crate::model::TileStyle> {
        self.tile.as_ref()
    }
    /// <p>The layout options for tiles.</p>
    pub fn tile_layout(&self) -> std::option::Option<&crate::model::TileLayoutStyle> {
        self.tile_layout.as_ref()
    }
}
/// See [`SheetStyle`](crate::model::SheetStyle).
pub mod sheet_style {

    /// A builder for [`SheetStyle`](crate::model::SheetStyle).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tile: std::option::Option<crate::model::TileStyle>,
        pub(crate) tile_layout: std::option::Option<crate::model::TileLayoutStyle>,
    }
    impl Builder {
        /// <p>The display options for tiles.</p>
        pub fn tile(mut self, input: crate::model::TileStyle) -> Self {
            self.tile = Some(input);
            self
        }
        /// <p>The display options for tiles.</p>
        pub fn set_tile(mut self, input: std::option::Option<crate::model::TileStyle>) -> Self {
            self.tile = input;
            self
        }
        /// <p>The layout options for tiles.</p>
        pub fn tile_layout(mut self, input: crate::model::TileLayoutStyle) -> Self {
            self.tile_layout = Some(input);
            self
        }
        /// <p>The layout options for tiles.</p>
        pub fn set_tile_layout(
            mut self,
            input: std::option::Option<crate::model::TileLayoutStyle>,
        ) -> Self {
            self.tile_layout = input;
            self
        }
        /// Consumes the builder and constructs a [`SheetStyle`](crate::model::SheetStyle).
        pub fn build(self) -> crate::model::SheetStyle {
            crate::model::SheetStyle {
                tile: self.tile,
                tile_layout: self.tile_layout,
            }
        }
    }
}
impl SheetStyle {
    /// Creates a new builder-style object to manufacture [`SheetStyle`](crate::model::SheetStyle).
    pub fn builder() -> crate::model::sheet_style::Builder {
        crate::model::sheet_style::Builder::default()
    }
}

/// <p>The display options for the layout of tiles on a sheet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TileLayoutStyle {
    /// <p>The gutter settings that apply between tiles. </p>
    #[doc(hidden)]
    pub gutter: std::option::Option<crate::model::GutterStyle>,
    /// <p>The margin settings that apply around the outside edge of sheets.</p>
    #[doc(hidden)]
    pub margin: std::option::Option<crate::model::MarginStyle>,
}
impl TileLayoutStyle {
    /// <p>The gutter settings that apply between tiles. </p>
    pub fn gutter(&self) -> std::option::Option<&crate::model::GutterStyle> {
        self.gutter.as_ref()
    }
    /// <p>The margin settings that apply around the outside edge of sheets.</p>
    pub fn margin(&self) -> std::option::Option<&crate::model::MarginStyle> {
        self.margin.as_ref()
    }
}
/// See [`TileLayoutStyle`](crate::model::TileLayoutStyle).
pub mod tile_layout_style {

    /// A builder for [`TileLayoutStyle`](crate::model::TileLayoutStyle).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gutter: std::option::Option<crate::model::GutterStyle>,
        pub(crate) margin: std::option::Option<crate::model::MarginStyle>,
    }
    impl Builder {
        /// <p>The gutter settings that apply between tiles. </p>
        pub fn gutter(mut self, input: crate::model::GutterStyle) -> Self {
            self.gutter = Some(input);
            self
        }
        /// <p>The gutter settings that apply between tiles. </p>
        pub fn set_gutter(mut self, input: std::option::Option<crate::model::GutterStyle>) -> Self {
            self.gutter = input;
            self
        }
        /// <p>The margin settings that apply around the outside edge of sheets.</p>
        pub fn margin(mut self, input: crate::model::MarginStyle) -> Self {
            self.margin = Some(input);
            self
        }
        /// <p>The margin settings that apply around the outside edge of sheets.</p>
        pub fn set_margin(mut self, input: std::option::Option<crate::model::MarginStyle>) -> Self {
            self.margin = input;
            self
        }
        /// Consumes the builder and constructs a [`TileLayoutStyle`](crate::model::TileLayoutStyle).
        pub fn build(self) -> crate::model::TileLayoutStyle {
            crate::model::TileLayoutStyle {
                gutter: self.gutter,
                margin: self.margin,
            }
        }
    }
}
impl TileLayoutStyle {
    /// Creates a new builder-style object to manufacture [`TileLayoutStyle`](crate::model::TileLayoutStyle).
    pub fn builder() -> crate::model::tile_layout_style::Builder {
        crate::model::tile_layout_style::Builder::default()
    }
}

/// <p>The display options for margins around the outside edge of sheets.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MarginStyle {
    /// <p>This Boolean value controls whether to display sheet margins.</p>
    #[doc(hidden)]
    pub show: std::option::Option<bool>,
}
impl MarginStyle {
    /// <p>This Boolean value controls whether to display sheet margins.</p>
    pub fn show(&self) -> std::option::Option<bool> {
        self.show
    }
}
/// See [`MarginStyle`](crate::model::MarginStyle).
pub mod margin_style {

    /// A builder for [`MarginStyle`](crate::model::MarginStyle).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) show: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>This Boolean value controls whether to display sheet margins.</p>
        pub fn show(mut self, input: bool) -> Self {
            self.show = Some(input);
            self
        }
        /// <p>This Boolean value controls whether to display sheet margins.</p>
        pub fn set_show(mut self, input: std::option::Option<bool>) -> Self {
            self.show = input;
            self
        }
        /// Consumes the builder and constructs a [`MarginStyle`](crate::model::MarginStyle).
        pub fn build(self) -> crate::model::MarginStyle {
            crate::model::MarginStyle { show: self.show }
        }
    }
}
impl MarginStyle {
    /// Creates a new builder-style object to manufacture [`MarginStyle`](crate::model::MarginStyle).
    pub fn builder() -> crate::model::margin_style::Builder {
        crate::model::margin_style::Builder::default()
    }
}

/// <p>The display options for gutter spacing between tiles on a sheet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GutterStyle {
    /// <p>This Boolean value controls whether to display a gutter space between sheet tiles. </p>
    #[doc(hidden)]
    pub show: std::option::Option<bool>,
}
impl GutterStyle {
    /// <p>This Boolean value controls whether to display a gutter space between sheet tiles. </p>
    pub fn show(&self) -> std::option::Option<bool> {
        self.show
    }
}
/// See [`GutterStyle`](crate::model::GutterStyle).
pub mod gutter_style {

    /// A builder for [`GutterStyle`](crate::model::GutterStyle).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) show: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>This Boolean value controls whether to display a gutter space between sheet tiles. </p>
        pub fn show(mut self, input: bool) -> Self {
            self.show = Some(input);
            self
        }
        /// <p>This Boolean value controls whether to display a gutter space between sheet tiles. </p>
        pub fn set_show(mut self, input: std::option::Option<bool>) -> Self {
            self.show = input;
            self
        }
        /// Consumes the builder and constructs a [`GutterStyle`](crate::model::GutterStyle).
        pub fn build(self) -> crate::model::GutterStyle {
            crate::model::GutterStyle { show: self.show }
        }
    }
}
impl GutterStyle {
    /// Creates a new builder-style object to manufacture [`GutterStyle`](crate::model::GutterStyle).
    pub fn builder() -> crate::model::gutter_style::Builder {
        crate::model::gutter_style::Builder::default()
    }
}

/// <p>Display options related to tiles on a sheet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TileStyle {
    /// <p>The border around a tile.</p>
    #[doc(hidden)]
    pub border: std::option::Option<crate::model::BorderStyle>,
}
impl TileStyle {
    /// <p>The border around a tile.</p>
    pub fn border(&self) -> std::option::Option<&crate::model::BorderStyle> {
        self.border.as_ref()
    }
}
/// See [`TileStyle`](crate::model::TileStyle).
pub mod tile_style {

    /// A builder for [`TileStyle`](crate::model::TileStyle).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) border: std::option::Option<crate::model::BorderStyle>,
    }
    impl Builder {
        /// <p>The border around a tile.</p>
        pub fn border(mut self, input: crate::model::BorderStyle) -> Self {
            self.border = Some(input);
            self
        }
        /// <p>The border around a tile.</p>
        pub fn set_border(mut self, input: std::option::Option<crate::model::BorderStyle>) -> Self {
            self.border = input;
            self
        }
        /// Consumes the builder and constructs a [`TileStyle`](crate::model::TileStyle).
        pub fn build(self) -> crate::model::TileStyle {
            crate::model::TileStyle {
                border: self.border,
            }
        }
    }
}
impl TileStyle {
    /// Creates a new builder-style object to manufacture [`TileStyle`](crate::model::TileStyle).
    pub fn builder() -> crate::model::tile_style::Builder {
        crate::model::tile_style::Builder::default()
    }
}

/// <p>The display options for tile borders for visuals.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BorderStyle {
    /// <p>The option to enable display of borders for visuals.</p>
    #[doc(hidden)]
    pub show: std::option::Option<bool>,
}
impl BorderStyle {
    /// <p>The option to enable display of borders for visuals.</p>
    pub fn show(&self) -> std::option::Option<bool> {
        self.show
    }
}
/// See [`BorderStyle`](crate::model::BorderStyle).
pub mod border_style {

    /// A builder for [`BorderStyle`](crate::model::BorderStyle).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) show: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The option to enable display of borders for visuals.</p>
        pub fn show(mut self, input: bool) -> Self {
            self.show = Some(input);
            self
        }
        /// <p>The option to enable display of borders for visuals.</p>
        pub fn set_show(mut self, input: std::option::Option<bool>) -> Self {
            self.show = input;
            self
        }
        /// Consumes the builder and constructs a [`BorderStyle`](crate::model::BorderStyle).
        pub fn build(self) -> crate::model::BorderStyle {
            crate::model::BorderStyle { show: self.show }
        }
    }
}
impl BorderStyle {
    /// Creates a new builder-style object to manufacture [`BorderStyle`](crate::model::BorderStyle).
    pub fn builder() -> crate::model::border_style::Builder {
        crate::model::border_style::Builder::default()
    }
}

/// <p>The theme colors that apply to UI and to charts, excluding data colors. The colors description is a hexadecimal color code that consists of six alphanumerical characters, prefixed with <code>#</code>, for example #37BFF5. For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/themes-in-quicksight.html">Using Themes in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide.</i> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UiColorPalette {
    /// <p>The color of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.</p>
    #[doc(hidden)]
    pub primary_foreground: std::option::Option<std::string::String>,
    /// <p>The background color that applies to visuals and other high emphasis UI.</p>
    #[doc(hidden)]
    pub primary_background: std::option::Option<std::string::String>,
    /// <p>The foreground color that applies to any sheet title, sheet control text, or UI that appears over the secondary background.</p>
    #[doc(hidden)]
    pub secondary_foreground: std::option::Option<std::string::String>,
    /// <p>The background color that applies to the sheet background and sheet controls.</p>
    #[doc(hidden)]
    pub secondary_background: std::option::Option<std::string::String>,
    /// <p>This color is that applies to selected states and buttons.</p>
    #[doc(hidden)]
    pub accent: std::option::Option<std::string::String>,
    /// <p>The foreground color that applies to any text or other elements that appear over the accent color.</p>
    #[doc(hidden)]
    pub accent_foreground: std::option::Option<std::string::String>,
    /// <p>The color that applies to error messages.</p>
    #[doc(hidden)]
    pub danger: std::option::Option<std::string::String>,
    /// <p>The foreground color that applies to any text or other elements that appear over the error color.</p>
    #[doc(hidden)]
    pub danger_foreground: std::option::Option<std::string::String>,
    /// <p>This color that applies to warning and informational messages.</p>
    #[doc(hidden)]
    pub warning: std::option::Option<std::string::String>,
    /// <p>The foreground color that applies to any text or other elements that appear over the warning color.</p>
    #[doc(hidden)]
    pub warning_foreground: std::option::Option<std::string::String>,
    /// <p>The color that applies to success messages, for example the check mark for a successful download.</p>
    #[doc(hidden)]
    pub success: std::option::Option<std::string::String>,
    /// <p>The foreground color that applies to any text or other elements that appear over the success color.</p>
    #[doc(hidden)]
    pub success_foreground: std::option::Option<std::string::String>,
    /// <p>The color that applies to the names of fields that are identified as dimensions.</p>
    #[doc(hidden)]
    pub dimension: std::option::Option<std::string::String>,
    /// <p>The foreground color that applies to any text or other elements that appear over the dimension color.</p>
    #[doc(hidden)]
    pub dimension_foreground: std::option::Option<std::string::String>,
    /// <p>The color that applies to the names of fields that are identified as measures.</p>
    #[doc(hidden)]
    pub measure: std::option::Option<std::string::String>,
    /// <p>The foreground color that applies to any text or other elements that appear over the measure color.</p>
    #[doc(hidden)]
    pub measure_foreground: std::option::Option<std::string::String>,
}
impl UiColorPalette {
    /// <p>The color of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.</p>
    pub fn primary_foreground(&self) -> std::option::Option<&str> {
        self.primary_foreground.as_deref()
    }
    /// <p>The background color that applies to visuals and other high emphasis UI.</p>
    pub fn primary_background(&self) -> std::option::Option<&str> {
        self.primary_background.as_deref()
    }
    /// <p>The foreground color that applies to any sheet title, sheet control text, or UI that appears over the secondary background.</p>
    pub fn secondary_foreground(&self) -> std::option::Option<&str> {
        self.secondary_foreground.as_deref()
    }
    /// <p>The background color that applies to the sheet background and sheet controls.</p>
    pub fn secondary_background(&self) -> std::option::Option<&str> {
        self.secondary_background.as_deref()
    }
    /// <p>This color is that applies to selected states and buttons.</p>
    pub fn accent(&self) -> std::option::Option<&str> {
        self.accent.as_deref()
    }
    /// <p>The foreground color that applies to any text or other elements that appear over the accent color.</p>
    pub fn accent_foreground(&self) -> std::option::Option<&str> {
        self.accent_foreground.as_deref()
    }
    /// <p>The color that applies to error messages.</p>
    pub fn danger(&self) -> std::option::Option<&str> {
        self.danger.as_deref()
    }
    /// <p>The foreground color that applies to any text or other elements that appear over the error color.</p>
    pub fn danger_foreground(&self) -> std::option::Option<&str> {
        self.danger_foreground.as_deref()
    }
    /// <p>This color that applies to warning and informational messages.</p>
    pub fn warning(&self) -> std::option::Option<&str> {
        self.warning.as_deref()
    }
    /// <p>The foreground color that applies to any text or other elements that appear over the warning color.</p>
    pub fn warning_foreground(&self) -> std::option::Option<&str> {
        self.warning_foreground.as_deref()
    }
    /// <p>The color that applies to success messages, for example the check mark for a successful download.</p>
    pub fn success(&self) -> std::option::Option<&str> {
        self.success.as_deref()
    }
    /// <p>The foreground color that applies to any text or other elements that appear over the success color.</p>
    pub fn success_foreground(&self) -> std::option::Option<&str> {
        self.success_foreground.as_deref()
    }
    /// <p>The color that applies to the names of fields that are identified as dimensions.</p>
    pub fn dimension(&self) -> std::option::Option<&str> {
        self.dimension.as_deref()
    }
    /// <p>The foreground color that applies to any text or other elements that appear over the dimension color.</p>
    pub fn dimension_foreground(&self) -> std::option::Option<&str> {
        self.dimension_foreground.as_deref()
    }
    /// <p>The color that applies to the names of fields that are identified as measures.</p>
    pub fn measure(&self) -> std::option::Option<&str> {
        self.measure.as_deref()
    }
    /// <p>The foreground color that applies to any text or other elements that appear over the measure color.</p>
    pub fn measure_foreground(&self) -> std::option::Option<&str> {
        self.measure_foreground.as_deref()
    }
}
/// See [`UiColorPalette`](crate::model::UiColorPalette).
pub mod ui_color_palette {

    /// A builder for [`UiColorPalette`](crate::model::UiColorPalette).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) primary_foreground: std::option::Option<std::string::String>,
        pub(crate) primary_background: std::option::Option<std::string::String>,
        pub(crate) secondary_foreground: std::option::Option<std::string::String>,
        pub(crate) secondary_background: std::option::Option<std::string::String>,
        pub(crate) accent: std::option::Option<std::string::String>,
        pub(crate) accent_foreground: std::option::Option<std::string::String>,
        pub(crate) danger: std::option::Option<std::string::String>,
        pub(crate) danger_foreground: std::option::Option<std::string::String>,
        pub(crate) warning: std::option::Option<std::string::String>,
        pub(crate) warning_foreground: std::option::Option<std::string::String>,
        pub(crate) success: std::option::Option<std::string::String>,
        pub(crate) success_foreground: std::option::Option<std::string::String>,
        pub(crate) dimension: std::option::Option<std::string::String>,
        pub(crate) dimension_foreground: std::option::Option<std::string::String>,
        pub(crate) measure: std::option::Option<std::string::String>,
        pub(crate) measure_foreground: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The color of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.</p>
        pub fn primary_foreground(mut self, input: impl Into<std::string::String>) -> Self {
            self.primary_foreground = Some(input.into());
            self
        }
        /// <p>The color of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.</p>
        pub fn set_primary_foreground(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.primary_foreground = input;
            self
        }
        /// <p>The background color that applies to visuals and other high emphasis UI.</p>
        pub fn primary_background(mut self, input: impl Into<std::string::String>) -> Self {
            self.primary_background = Some(input.into());
            self
        }
        /// <p>The background color that applies to visuals and other high emphasis UI.</p>
        pub fn set_primary_background(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.primary_background = input;
            self
        }
        /// <p>The foreground color that applies to any sheet title, sheet control text, or UI that appears over the secondary background.</p>
        pub fn secondary_foreground(mut self, input: impl Into<std::string::String>) -> Self {
            self.secondary_foreground = Some(input.into());
            self
        }
        /// <p>The foreground color that applies to any sheet title, sheet control text, or UI that appears over the secondary background.</p>
        pub fn set_secondary_foreground(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.secondary_foreground = input;
            self
        }
        /// <p>The background color that applies to the sheet background and sheet controls.</p>
        pub fn secondary_background(mut self, input: impl Into<std::string::String>) -> Self {
            self.secondary_background = Some(input.into());
            self
        }
        /// <p>The background color that applies to the sheet background and sheet controls.</p>
        pub fn set_secondary_background(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.secondary_background = input;
            self
        }
        /// <p>This color is that applies to selected states and buttons.</p>
        pub fn accent(mut self, input: impl Into<std::string::String>) -> Self {
            self.accent = Some(input.into());
            self
        }
        /// <p>This color is that applies to selected states and buttons.</p>
        pub fn set_accent(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.accent = input;
            self
        }
        /// <p>The foreground color that applies to any text or other elements that appear over the accent color.</p>
        pub fn accent_foreground(mut self, input: impl Into<std::string::String>) -> Self {
            self.accent_foreground = Some(input.into());
            self
        }
        /// <p>The foreground color that applies to any text or other elements that appear over the accent color.</p>
        pub fn set_accent_foreground(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.accent_foreground = input;
            self
        }
        /// <p>The color that applies to error messages.</p>
        pub fn danger(mut self, input: impl Into<std::string::String>) -> Self {
            self.danger = Some(input.into());
            self
        }
        /// <p>The color that applies to error messages.</p>
        pub fn set_danger(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.danger = input;
            self
        }
        /// <p>The foreground color that applies to any text or other elements that appear over the error color.</p>
        pub fn danger_foreground(mut self, input: impl Into<std::string::String>) -> Self {
            self.danger_foreground = Some(input.into());
            self
        }
        /// <p>The foreground color that applies to any text or other elements that appear over the error color.</p>
        pub fn set_danger_foreground(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.danger_foreground = input;
            self
        }
        /// <p>This color that applies to warning and informational messages.</p>
        pub fn warning(mut self, input: impl Into<std::string::String>) -> Self {
            self.warning = Some(input.into());
            self
        }
        /// <p>This color that applies to warning and informational messages.</p>
        pub fn set_warning(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.warning = input;
            self
        }
        /// <p>The foreground color that applies to any text or other elements that appear over the warning color.</p>
        pub fn warning_foreground(mut self, input: impl Into<std::string::String>) -> Self {
            self.warning_foreground = Some(input.into());
            self
        }
        /// <p>The foreground color that applies to any text or other elements that appear over the warning color.</p>
        pub fn set_warning_foreground(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.warning_foreground = input;
            self
        }
        /// <p>The color that applies to success messages, for example the check mark for a successful download.</p>
        pub fn success(mut self, input: impl Into<std::string::String>) -> Self {
            self.success = Some(input.into());
            self
        }
        /// <p>The color that applies to success messages, for example the check mark for a successful download.</p>
        pub fn set_success(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.success = input;
            self
        }
        /// <p>The foreground color that applies to any text or other elements that appear over the success color.</p>
        pub fn success_foreground(mut self, input: impl Into<std::string::String>) -> Self {
            self.success_foreground = Some(input.into());
            self
        }
        /// <p>The foreground color that applies to any text or other elements that appear over the success color.</p>
        pub fn set_success_foreground(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.success_foreground = input;
            self
        }
        /// <p>The color that applies to the names of fields that are identified as dimensions.</p>
        pub fn dimension(mut self, input: impl Into<std::string::String>) -> Self {
            self.dimension = Some(input.into());
            self
        }
        /// <p>The color that applies to the names of fields that are identified as dimensions.</p>
        pub fn set_dimension(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dimension = input;
            self
        }
        /// <p>The foreground color that applies to any text or other elements that appear over the dimension color.</p>
        pub fn dimension_foreground(mut self, input: impl Into<std::string::String>) -> Self {
            self.dimension_foreground = Some(input.into());
            self
        }
        /// <p>The foreground color that applies to any text or other elements that appear over the dimension color.</p>
        pub fn set_dimension_foreground(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dimension_foreground = input;
            self
        }
        /// <p>The color that applies to the names of fields that are identified as measures.</p>
        pub fn measure(mut self, input: impl Into<std::string::String>) -> Self {
            self.measure = Some(input.into());
            self
        }
        /// <p>The color that applies to the names of fields that are identified as measures.</p>
        pub fn set_measure(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.measure = input;
            self
        }
        /// <p>The foreground color that applies to any text or other elements that appear over the measure color.</p>
        pub fn measure_foreground(mut self, input: impl Into<std::string::String>) -> Self {
            self.measure_foreground = Some(input.into());
            self
        }
        /// <p>The foreground color that applies to any text or other elements that appear over the measure color.</p>
        pub fn set_measure_foreground(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.measure_foreground = input;
            self
        }
        /// Consumes the builder and constructs a [`UiColorPalette`](crate::model::UiColorPalette).
        pub fn build(self) -> crate::model::UiColorPalette {
            crate::model::UiColorPalette {
                primary_foreground: self.primary_foreground,
                primary_background: self.primary_background,
                secondary_foreground: self.secondary_foreground,
                secondary_background: self.secondary_background,
                accent: self.accent,
                accent_foreground: self.accent_foreground,
                danger: self.danger,
                danger_foreground: self.danger_foreground,
                warning: self.warning,
                warning_foreground: self.warning_foreground,
                success: self.success,
                success_foreground: self.success_foreground,
                dimension: self.dimension,
                dimension_foreground: self.dimension_foreground,
                measure: self.measure,
                measure_foreground: self.measure_foreground,
            }
        }
    }
}
impl UiColorPalette {
    /// Creates a new builder-style object to manufacture [`UiColorPalette`](crate::model::UiColorPalette).
    pub fn builder() -> crate::model::ui_color_palette::Builder {
        crate::model::ui_color_palette::Builder::default()
    }
}

/// <p>The theme colors that are used for data colors in charts. The colors description is a hexadecimal color code that consists of six alphanumerical characters, prefixed with <code>#</code>, for example #37BFF5. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataColorPalette {
    /// <p>The hexadecimal codes for the colors.</p>
    #[doc(hidden)]
    pub colors: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The minimum and maximum hexadecimal codes that describe a color gradient. </p>
    #[doc(hidden)]
    pub min_max_gradient: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The hexadecimal code of a color that applies to charts where a lack of data is highlighted.</p>
    #[doc(hidden)]
    pub empty_fill_color: std::option::Option<std::string::String>,
}
impl DataColorPalette {
    /// <p>The hexadecimal codes for the colors.</p>
    pub fn colors(&self) -> std::option::Option<&[std::string::String]> {
        self.colors.as_deref()
    }
    /// <p>The minimum and maximum hexadecimal codes that describe a color gradient. </p>
    pub fn min_max_gradient(&self) -> std::option::Option<&[std::string::String]> {
        self.min_max_gradient.as_deref()
    }
    /// <p>The hexadecimal code of a color that applies to charts where a lack of data is highlighted.</p>
    pub fn empty_fill_color(&self) -> std::option::Option<&str> {
        self.empty_fill_color.as_deref()
    }
}
/// See [`DataColorPalette`](crate::model::DataColorPalette).
pub mod data_color_palette {

    /// A builder for [`DataColorPalette`](crate::model::DataColorPalette).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) colors: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) min_max_gradient: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) empty_fill_color: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `colors`.
        ///
        /// To override the contents of this collection use [`set_colors`](Self::set_colors).
        ///
        /// <p>The hexadecimal codes for the colors.</p>
        pub fn colors(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.colors.unwrap_or_default();
            v.push(input.into());
            self.colors = Some(v);
            self
        }
        /// <p>The hexadecimal codes for the colors.</p>
        pub fn set_colors(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.colors = input;
            self
        }
        /// Appends an item to `min_max_gradient`.
        ///
        /// To override the contents of this collection use [`set_min_max_gradient`](Self::set_min_max_gradient).
        ///
        /// <p>The minimum and maximum hexadecimal codes that describe a color gradient. </p>
        pub fn min_max_gradient(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.min_max_gradient.unwrap_or_default();
            v.push(input.into());
            self.min_max_gradient = Some(v);
            self
        }
        /// <p>The minimum and maximum hexadecimal codes that describe a color gradient. </p>
        pub fn set_min_max_gradient(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.min_max_gradient = input;
            self
        }
        /// <p>The hexadecimal code of a color that applies to charts where a lack of data is highlighted.</p>
        pub fn empty_fill_color(mut self, input: impl Into<std::string::String>) -> Self {
            self.empty_fill_color = Some(input.into());
            self
        }
        /// <p>The hexadecimal code of a color that applies to charts where a lack of data is highlighted.</p>
        pub fn set_empty_fill_color(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.empty_fill_color = input;
            self
        }
        /// Consumes the builder and constructs a [`DataColorPalette`](crate::model::DataColorPalette).
        pub fn build(self) -> crate::model::DataColorPalette {
            crate::model::DataColorPalette {
                colors: self.colors,
                min_max_gradient: self.min_max_gradient,
                empty_fill_color: self.empty_fill_color,
            }
        }
    }
}
impl DataColorPalette {
    /// Creates a new builder-style object to manufacture [`DataColorPalette`](crate::model::DataColorPalette).
    pub fn builder() -> crate::model::data_color_palette::Builder {
        crate::model::data_color_palette::Builder::default()
    }
}

/// <p>The template alias.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TemplateAlias {
    /// <p>The display name of the template alias.</p>
    #[doc(hidden)]
    pub alias_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the template alias.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The version number of the template alias.</p>
    #[doc(hidden)]
    pub template_version_number: std::option::Option<i64>,
}
impl TemplateAlias {
    /// <p>The display name of the template alias.</p>
    pub fn alias_name(&self) -> std::option::Option<&str> {
        self.alias_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the template alias.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The version number of the template alias.</p>
    pub fn template_version_number(&self) -> std::option::Option<i64> {
        self.template_version_number
    }
}
/// See [`TemplateAlias`](crate::model::TemplateAlias).
pub mod template_alias {

    /// A builder for [`TemplateAlias`](crate::model::TemplateAlias).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alias_name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) template_version_number: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The display name of the template alias.</p>
        pub fn alias_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias_name = Some(input.into());
            self
        }
        /// <p>The display name of the template alias.</p>
        pub fn set_alias_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the template alias.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the template alias.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The version number of the template alias.</p>
        pub fn template_version_number(mut self, input: i64) -> Self {
            self.template_version_number = Some(input);
            self
        }
        /// <p>The version number of the template alias.</p>
        pub fn set_template_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.template_version_number = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateAlias`](crate::model::TemplateAlias).
        pub fn build(self) -> crate::model::TemplateAlias {
            crate::model::TemplateAlias {
                alias_name: self.alias_name,
                arn: self.arn,
                template_version_number: self.template_version_number,
            }
        }
    }
}
impl TemplateAlias {
    /// Creates a new builder-style object to manufacture [`TemplateAlias`](crate::model::TemplateAlias).
    pub fn builder() -> crate::model::template_alias::Builder {
        crate::model::template_alias::Builder::default()
    }
}

/// <p>The detailed definition of a template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TemplateVersionDefinition {
    /// <p>An array of dataset configurations. These configurations define the required columns for each dataset used within a template.</p>
    #[doc(hidden)]
    pub data_set_configurations:
        std::option::Option<std::vec::Vec<crate::model::DataSetConfiguration>>,
    /// <p>An array of sheet definitions for a template.</p>
    #[doc(hidden)]
    pub sheets: std::option::Option<std::vec::Vec<crate::model::SheetDefinition>>,
    /// <p>An array of calculated field definitions for the template.</p>
    #[doc(hidden)]
    pub calculated_fields: std::option::Option<std::vec::Vec<crate::model::CalculatedField>>,
    /// <p>An array of parameter declarations for a template.</p>
    /// <p> <i>Parameters</i> are named variables that can transfer a value for use by an action or an object.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html">Parameters in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>. </p>
    #[doc(hidden)]
    pub parameter_declarations:
        std::option::Option<std::vec::Vec<crate::model::ParameterDeclaration>>,
    /// <p>Filter definitions for a template.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/filtering-visual-data.html">Filtering Data</a> in the <i>Amazon QuickSight User Guide</i>. </p>
    #[doc(hidden)]
    pub filter_groups: std::option::Option<std::vec::Vec<crate::model::FilterGroup>>,
    /// <p> An array of template-level column configurations. Column configurations are used to set default formatting for a column that's used throughout a template. </p>
    #[doc(hidden)]
    pub column_configurations:
        std::option::Option<std::vec::Vec<crate::model::ColumnConfiguration>>,
    /// <p>The configuration for default analysis settings.</p>
    #[doc(hidden)]
    pub analysis_defaults: std::option::Option<crate::model::AnalysisDefaults>,
}
impl TemplateVersionDefinition {
    /// <p>An array of dataset configurations. These configurations define the required columns for each dataset used within a template.</p>
    pub fn data_set_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::DataSetConfiguration]> {
        self.data_set_configurations.as_deref()
    }
    /// <p>An array of sheet definitions for a template.</p>
    pub fn sheets(&self) -> std::option::Option<&[crate::model::SheetDefinition]> {
        self.sheets.as_deref()
    }
    /// <p>An array of calculated field definitions for the template.</p>
    pub fn calculated_fields(&self) -> std::option::Option<&[crate::model::CalculatedField]> {
        self.calculated_fields.as_deref()
    }
    /// <p>An array of parameter declarations for a template.</p>
    /// <p> <i>Parameters</i> are named variables that can transfer a value for use by an action or an object.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html">Parameters in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>. </p>
    pub fn parameter_declarations(
        &self,
    ) -> std::option::Option<&[crate::model::ParameterDeclaration]> {
        self.parameter_declarations.as_deref()
    }
    /// <p>Filter definitions for a template.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/filtering-visual-data.html">Filtering Data</a> in the <i>Amazon QuickSight User Guide</i>. </p>
    pub fn filter_groups(&self) -> std::option::Option<&[crate::model::FilterGroup]> {
        self.filter_groups.as_deref()
    }
    /// <p> An array of template-level column configurations. Column configurations are used to set default formatting for a column that's used throughout a template. </p>
    pub fn column_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::ColumnConfiguration]> {
        self.column_configurations.as_deref()
    }
    /// <p>The configuration for default analysis settings.</p>
    pub fn analysis_defaults(&self) -> std::option::Option<&crate::model::AnalysisDefaults> {
        self.analysis_defaults.as_ref()
    }
}
/// See [`TemplateVersionDefinition`](crate::model::TemplateVersionDefinition).
pub mod template_version_definition {

    /// A builder for [`TemplateVersionDefinition`](crate::model::TemplateVersionDefinition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_set_configurations:
            std::option::Option<std::vec::Vec<crate::model::DataSetConfiguration>>,
        pub(crate) sheets: std::option::Option<std::vec::Vec<crate::model::SheetDefinition>>,
        pub(crate) calculated_fields:
            std::option::Option<std::vec::Vec<crate::model::CalculatedField>>,
        pub(crate) parameter_declarations:
            std::option::Option<std::vec::Vec<crate::model::ParameterDeclaration>>,
        pub(crate) filter_groups: std::option::Option<std::vec::Vec<crate::model::FilterGroup>>,
        pub(crate) column_configurations:
            std::option::Option<std::vec::Vec<crate::model::ColumnConfiguration>>,
        pub(crate) analysis_defaults: std::option::Option<crate::model::AnalysisDefaults>,
    }
    impl Builder {
        /// Appends an item to `data_set_configurations`.
        ///
        /// To override the contents of this collection use [`set_data_set_configurations`](Self::set_data_set_configurations).
        ///
        /// <p>An array of dataset configurations. These configurations define the required columns for each dataset used within a template.</p>
        pub fn data_set_configurations(
            mut self,
            input: crate::model::DataSetConfiguration,
        ) -> Self {
            let mut v = self.data_set_configurations.unwrap_or_default();
            v.push(input);
            self.data_set_configurations = Some(v);
            self
        }
        /// <p>An array of dataset configurations. These configurations define the required columns for each dataset used within a template.</p>
        pub fn set_data_set_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSetConfiguration>>,
        ) -> Self {
            self.data_set_configurations = input;
            self
        }
        /// Appends an item to `sheets`.
        ///
        /// To override the contents of this collection use [`set_sheets`](Self::set_sheets).
        ///
        /// <p>An array of sheet definitions for a template.</p>
        pub fn sheets(mut self, input: crate::model::SheetDefinition) -> Self {
            let mut v = self.sheets.unwrap_or_default();
            v.push(input);
            self.sheets = Some(v);
            self
        }
        /// <p>An array of sheet definitions for a template.</p>
        pub fn set_sheets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SheetDefinition>>,
        ) -> Self {
            self.sheets = input;
            self
        }
        /// Appends an item to `calculated_fields`.
        ///
        /// To override the contents of this collection use [`set_calculated_fields`](Self::set_calculated_fields).
        ///
        /// <p>An array of calculated field definitions for the template.</p>
        pub fn calculated_fields(mut self, input: crate::model::CalculatedField) -> Self {
            let mut v = self.calculated_fields.unwrap_or_default();
            v.push(input);
            self.calculated_fields = Some(v);
            self
        }
        /// <p>An array of calculated field definitions for the template.</p>
        pub fn set_calculated_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CalculatedField>>,
        ) -> Self {
            self.calculated_fields = input;
            self
        }
        /// Appends an item to `parameter_declarations`.
        ///
        /// To override the contents of this collection use [`set_parameter_declarations`](Self::set_parameter_declarations).
        ///
        /// <p>An array of parameter declarations for a template.</p>
        /// <p> <i>Parameters</i> are named variables that can transfer a value for use by an action or an object.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html">Parameters in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>. </p>
        pub fn parameter_declarations(mut self, input: crate::model::ParameterDeclaration) -> Self {
            let mut v = self.parameter_declarations.unwrap_or_default();
            v.push(input);
            self.parameter_declarations = Some(v);
            self
        }
        /// <p>An array of parameter declarations for a template.</p>
        /// <p> <i>Parameters</i> are named variables that can transfer a value for use by an action or an object.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html">Parameters in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>. </p>
        pub fn set_parameter_declarations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ParameterDeclaration>>,
        ) -> Self {
            self.parameter_declarations = input;
            self
        }
        /// Appends an item to `filter_groups`.
        ///
        /// To override the contents of this collection use [`set_filter_groups`](Self::set_filter_groups).
        ///
        /// <p>Filter definitions for a template.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/filtering-visual-data.html">Filtering Data</a> in the <i>Amazon QuickSight User Guide</i>. </p>
        pub fn filter_groups(mut self, input: crate::model::FilterGroup) -> Self {
            let mut v = self.filter_groups.unwrap_or_default();
            v.push(input);
            self.filter_groups = Some(v);
            self
        }
        /// <p>Filter definitions for a template.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/filtering-visual-data.html">Filtering Data</a> in the <i>Amazon QuickSight User Guide</i>. </p>
        pub fn set_filter_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FilterGroup>>,
        ) -> Self {
            self.filter_groups = input;
            self
        }
        /// Appends an item to `column_configurations`.
        ///
        /// To override the contents of this collection use [`set_column_configurations`](Self::set_column_configurations).
        ///
        /// <p> An array of template-level column configurations. Column configurations are used to set default formatting for a column that's used throughout a template. </p>
        pub fn column_configurations(mut self, input: crate::model::ColumnConfiguration) -> Self {
            let mut v = self.column_configurations.unwrap_or_default();
            v.push(input);
            self.column_configurations = Some(v);
            self
        }
        /// <p> An array of template-level column configurations. Column configurations are used to set default formatting for a column that's used throughout a template. </p>
        pub fn set_column_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnConfiguration>>,
        ) -> Self {
            self.column_configurations = input;
            self
        }
        /// <p>The configuration for default analysis settings.</p>
        pub fn analysis_defaults(mut self, input: crate::model::AnalysisDefaults) -> Self {
            self.analysis_defaults = Some(input);
            self
        }
        /// <p>The configuration for default analysis settings.</p>
        pub fn set_analysis_defaults(
            mut self,
            input: std::option::Option<crate::model::AnalysisDefaults>,
        ) -> Self {
            self.analysis_defaults = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateVersionDefinition`](crate::model::TemplateVersionDefinition).
        pub fn build(self) -> crate::model::TemplateVersionDefinition {
            crate::model::TemplateVersionDefinition {
                data_set_configurations: self.data_set_configurations,
                sheets: self.sheets,
                calculated_fields: self.calculated_fields,
                parameter_declarations: self.parameter_declarations,
                filter_groups: self.filter_groups,
                column_configurations: self.column_configurations,
                analysis_defaults: self.analysis_defaults,
            }
        }
    }
}
impl TemplateVersionDefinition {
    /// Creates a new builder-style object to manufacture [`TemplateVersionDefinition`](crate::model::TemplateVersionDefinition).
    pub fn builder() -> crate::model::template_version_definition::Builder {
        crate::model::template_version_definition::Builder::default()
    }
}

/// <p>The configuration for default analysis settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnalysisDefaults {
    /// <p>The configuration for default new sheet settings.</p>
    #[doc(hidden)]
    pub default_new_sheet_configuration:
        std::option::Option<crate::model::DefaultNewSheetConfiguration>,
}
impl AnalysisDefaults {
    /// <p>The configuration for default new sheet settings.</p>
    pub fn default_new_sheet_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DefaultNewSheetConfiguration> {
        self.default_new_sheet_configuration.as_ref()
    }
}
/// See [`AnalysisDefaults`](crate::model::AnalysisDefaults).
pub mod analysis_defaults {

    /// A builder for [`AnalysisDefaults`](crate::model::AnalysisDefaults).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) default_new_sheet_configuration:
            std::option::Option<crate::model::DefaultNewSheetConfiguration>,
    }
    impl Builder {
        /// <p>The configuration for default new sheet settings.</p>
        pub fn default_new_sheet_configuration(
            mut self,
            input: crate::model::DefaultNewSheetConfiguration,
        ) -> Self {
            self.default_new_sheet_configuration = Some(input);
            self
        }
        /// <p>The configuration for default new sheet settings.</p>
        pub fn set_default_new_sheet_configuration(
            mut self,
            input: std::option::Option<crate::model::DefaultNewSheetConfiguration>,
        ) -> Self {
            self.default_new_sheet_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`AnalysisDefaults`](crate::model::AnalysisDefaults).
        pub fn build(self) -> crate::model::AnalysisDefaults {
            crate::model::AnalysisDefaults {
                default_new_sheet_configuration: self.default_new_sheet_configuration,
            }
        }
    }
}
impl AnalysisDefaults {
    /// Creates a new builder-style object to manufacture [`AnalysisDefaults`](crate::model::AnalysisDefaults).
    pub fn builder() -> crate::model::analysis_defaults::Builder {
        crate::model::analysis_defaults::Builder::default()
    }
}

/// <p>The configuration for default new sheet settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DefaultNewSheetConfiguration {
    /// <p>The options that determine the default settings for interactive layout configuration.</p>
    #[doc(hidden)]
    pub interactive_layout_configuration:
        std::option::Option<crate::model::DefaultInteractiveLayoutConfiguration>,
    /// <p>The options that determine the default settings for a paginated layout configuration.</p>
    #[doc(hidden)]
    pub paginated_layout_configuration:
        std::option::Option<crate::model::DefaultPaginatedLayoutConfiguration>,
    /// <p>The option that determines the sheet content type.</p>
    #[doc(hidden)]
    pub sheet_content_type: std::option::Option<crate::model::SheetContentType>,
}
impl DefaultNewSheetConfiguration {
    /// <p>The options that determine the default settings for interactive layout configuration.</p>
    pub fn interactive_layout_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DefaultInteractiveLayoutConfiguration> {
        self.interactive_layout_configuration.as_ref()
    }
    /// <p>The options that determine the default settings for a paginated layout configuration.</p>
    pub fn paginated_layout_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DefaultPaginatedLayoutConfiguration> {
        self.paginated_layout_configuration.as_ref()
    }
    /// <p>The option that determines the sheet content type.</p>
    pub fn sheet_content_type(&self) -> std::option::Option<&crate::model::SheetContentType> {
        self.sheet_content_type.as_ref()
    }
}
/// See [`DefaultNewSheetConfiguration`](crate::model::DefaultNewSheetConfiguration).
pub mod default_new_sheet_configuration {

    /// A builder for [`DefaultNewSheetConfiguration`](crate::model::DefaultNewSheetConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) interactive_layout_configuration:
            std::option::Option<crate::model::DefaultInteractiveLayoutConfiguration>,
        pub(crate) paginated_layout_configuration:
            std::option::Option<crate::model::DefaultPaginatedLayoutConfiguration>,
        pub(crate) sheet_content_type: std::option::Option<crate::model::SheetContentType>,
    }
    impl Builder {
        /// <p>The options that determine the default settings for interactive layout configuration.</p>
        pub fn interactive_layout_configuration(
            mut self,
            input: crate::model::DefaultInteractiveLayoutConfiguration,
        ) -> Self {
            self.interactive_layout_configuration = Some(input);
            self
        }
        /// <p>The options that determine the default settings for interactive layout configuration.</p>
        pub fn set_interactive_layout_configuration(
            mut self,
            input: std::option::Option<crate::model::DefaultInteractiveLayoutConfiguration>,
        ) -> Self {
            self.interactive_layout_configuration = input;
            self
        }
        /// <p>The options that determine the default settings for a paginated layout configuration.</p>
        pub fn paginated_layout_configuration(
            mut self,
            input: crate::model::DefaultPaginatedLayoutConfiguration,
        ) -> Self {
            self.paginated_layout_configuration = Some(input);
            self
        }
        /// <p>The options that determine the default settings for a paginated layout configuration.</p>
        pub fn set_paginated_layout_configuration(
            mut self,
            input: std::option::Option<crate::model::DefaultPaginatedLayoutConfiguration>,
        ) -> Self {
            self.paginated_layout_configuration = input;
            self
        }
        /// <p>The option that determines the sheet content type.</p>
        pub fn sheet_content_type(mut self, input: crate::model::SheetContentType) -> Self {
            self.sheet_content_type = Some(input);
            self
        }
        /// <p>The option that determines the sheet content type.</p>
        pub fn set_sheet_content_type(
            mut self,
            input: std::option::Option<crate::model::SheetContentType>,
        ) -> Self {
            self.sheet_content_type = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultNewSheetConfiguration`](crate::model::DefaultNewSheetConfiguration).
        pub fn build(self) -> crate::model::DefaultNewSheetConfiguration {
            crate::model::DefaultNewSheetConfiguration {
                interactive_layout_configuration: self.interactive_layout_configuration,
                paginated_layout_configuration: self.paginated_layout_configuration,
                sheet_content_type: self.sheet_content_type,
            }
        }
    }
}
impl DefaultNewSheetConfiguration {
    /// Creates a new builder-style object to manufacture [`DefaultNewSheetConfiguration`](crate::model::DefaultNewSheetConfiguration).
    pub fn builder() -> crate::model::default_new_sheet_configuration::Builder {
        crate::model::default_new_sheet_configuration::Builder::default()
    }
}

/// When writing a match expression against `SheetContentType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sheetcontenttype = unimplemented!();
/// match sheetcontenttype {
///     SheetContentType::Interactive => { /* ... */ },
///     SheetContentType::Paginated => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sheetcontenttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SheetContentType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SheetContentType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SheetContentType::NewFeature` is defined.
/// Specifically, when `sheetcontenttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SheetContentType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SheetContentType {
    #[allow(missing_docs)] // documentation missing in model
    Interactive,
    #[allow(missing_docs)] // documentation missing in model
    Paginated,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SheetContentType {
    fn from(s: &str) -> Self {
        match s {
            "INTERACTIVE" => SheetContentType::Interactive,
            "PAGINATED" => SheetContentType::Paginated,
            other => SheetContentType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SheetContentType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SheetContentType::from(s))
    }
}
impl SheetContentType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SheetContentType::Interactive => "INTERACTIVE",
            SheetContentType::Paginated => "PAGINATED",
            SheetContentType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INTERACTIVE", "PAGINATED"]
    }
}
impl AsRef<str> for SheetContentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The options that determine the default settings for a paginated layout configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DefaultPaginatedLayoutConfiguration {
    /// <p>The options that determine the default settings for a section-based layout configuration.</p>
    #[doc(hidden)]
    pub section_based: std::option::Option<crate::model::DefaultSectionBasedLayoutConfiguration>,
}
impl DefaultPaginatedLayoutConfiguration {
    /// <p>The options that determine the default settings for a section-based layout configuration.</p>
    pub fn section_based(
        &self,
    ) -> std::option::Option<&crate::model::DefaultSectionBasedLayoutConfiguration> {
        self.section_based.as_ref()
    }
}
/// See [`DefaultPaginatedLayoutConfiguration`](crate::model::DefaultPaginatedLayoutConfiguration).
pub mod default_paginated_layout_configuration {

    /// A builder for [`DefaultPaginatedLayoutConfiguration`](crate::model::DefaultPaginatedLayoutConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) section_based:
            std::option::Option<crate::model::DefaultSectionBasedLayoutConfiguration>,
    }
    impl Builder {
        /// <p>The options that determine the default settings for a section-based layout configuration.</p>
        pub fn section_based(
            mut self,
            input: crate::model::DefaultSectionBasedLayoutConfiguration,
        ) -> Self {
            self.section_based = Some(input);
            self
        }
        /// <p>The options that determine the default settings for a section-based layout configuration.</p>
        pub fn set_section_based(
            mut self,
            input: std::option::Option<crate::model::DefaultSectionBasedLayoutConfiguration>,
        ) -> Self {
            self.section_based = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultPaginatedLayoutConfiguration`](crate::model::DefaultPaginatedLayoutConfiguration).
        pub fn build(self) -> crate::model::DefaultPaginatedLayoutConfiguration {
            crate::model::DefaultPaginatedLayoutConfiguration {
                section_based: self.section_based,
            }
        }
    }
}
impl DefaultPaginatedLayoutConfiguration {
    /// Creates a new builder-style object to manufacture [`DefaultPaginatedLayoutConfiguration`](crate::model::DefaultPaginatedLayoutConfiguration).
    pub fn builder() -> crate::model::default_paginated_layout_configuration::Builder {
        crate::model::default_paginated_layout_configuration::Builder::default()
    }
}

/// <p>The options that determine the default settings for a section-based layout configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DefaultSectionBasedLayoutConfiguration {
    /// <p>Determines the screen canvas size options for a section-based layout.</p>
    #[doc(hidden)]
    pub canvas_size_options: std::option::Option<crate::model::SectionBasedLayoutCanvasSizeOptions>,
}
impl DefaultSectionBasedLayoutConfiguration {
    /// <p>Determines the screen canvas size options for a section-based layout.</p>
    pub fn canvas_size_options(
        &self,
    ) -> std::option::Option<&crate::model::SectionBasedLayoutCanvasSizeOptions> {
        self.canvas_size_options.as_ref()
    }
}
/// See [`DefaultSectionBasedLayoutConfiguration`](crate::model::DefaultSectionBasedLayoutConfiguration).
pub mod default_section_based_layout_configuration {

    /// A builder for [`DefaultSectionBasedLayoutConfiguration`](crate::model::DefaultSectionBasedLayoutConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) canvas_size_options:
            std::option::Option<crate::model::SectionBasedLayoutCanvasSizeOptions>,
    }
    impl Builder {
        /// <p>Determines the screen canvas size options for a section-based layout.</p>
        pub fn canvas_size_options(
            mut self,
            input: crate::model::SectionBasedLayoutCanvasSizeOptions,
        ) -> Self {
            self.canvas_size_options = Some(input);
            self
        }
        /// <p>Determines the screen canvas size options for a section-based layout.</p>
        pub fn set_canvas_size_options(
            mut self,
            input: std::option::Option<crate::model::SectionBasedLayoutCanvasSizeOptions>,
        ) -> Self {
            self.canvas_size_options = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultSectionBasedLayoutConfiguration`](crate::model::DefaultSectionBasedLayoutConfiguration).
        pub fn build(self) -> crate::model::DefaultSectionBasedLayoutConfiguration {
            crate::model::DefaultSectionBasedLayoutConfiguration {
                canvas_size_options: self.canvas_size_options,
            }
        }
    }
}
impl DefaultSectionBasedLayoutConfiguration {
    /// Creates a new builder-style object to manufacture [`DefaultSectionBasedLayoutConfiguration`](crate::model::DefaultSectionBasedLayoutConfiguration).
    pub fn builder() -> crate::model::default_section_based_layout_configuration::Builder {
        crate::model::default_section_based_layout_configuration::Builder::default()
    }
}

/// <p>The options for the canvas of a section-based layout.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SectionBasedLayoutCanvasSizeOptions {
    /// <p>The options for a paper canvas of a section-based layout.</p>
    #[doc(hidden)]
    pub paper_canvas_size_options:
        std::option::Option<crate::model::SectionBasedLayoutPaperCanvasSizeOptions>,
}
impl SectionBasedLayoutCanvasSizeOptions {
    /// <p>The options for a paper canvas of a section-based layout.</p>
    pub fn paper_canvas_size_options(
        &self,
    ) -> std::option::Option<&crate::model::SectionBasedLayoutPaperCanvasSizeOptions> {
        self.paper_canvas_size_options.as_ref()
    }
}
/// See [`SectionBasedLayoutCanvasSizeOptions`](crate::model::SectionBasedLayoutCanvasSizeOptions).
pub mod section_based_layout_canvas_size_options {

    /// A builder for [`SectionBasedLayoutCanvasSizeOptions`](crate::model::SectionBasedLayoutCanvasSizeOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) paper_canvas_size_options:
            std::option::Option<crate::model::SectionBasedLayoutPaperCanvasSizeOptions>,
    }
    impl Builder {
        /// <p>The options for a paper canvas of a section-based layout.</p>
        pub fn paper_canvas_size_options(
            mut self,
            input: crate::model::SectionBasedLayoutPaperCanvasSizeOptions,
        ) -> Self {
            self.paper_canvas_size_options = Some(input);
            self
        }
        /// <p>The options for a paper canvas of a section-based layout.</p>
        pub fn set_paper_canvas_size_options(
            mut self,
            input: std::option::Option<crate::model::SectionBasedLayoutPaperCanvasSizeOptions>,
        ) -> Self {
            self.paper_canvas_size_options = input;
            self
        }
        /// Consumes the builder and constructs a [`SectionBasedLayoutCanvasSizeOptions`](crate::model::SectionBasedLayoutCanvasSizeOptions).
        pub fn build(self) -> crate::model::SectionBasedLayoutCanvasSizeOptions {
            crate::model::SectionBasedLayoutCanvasSizeOptions {
                paper_canvas_size_options: self.paper_canvas_size_options,
            }
        }
    }
}
impl SectionBasedLayoutCanvasSizeOptions {
    /// Creates a new builder-style object to manufacture [`SectionBasedLayoutCanvasSizeOptions`](crate::model::SectionBasedLayoutCanvasSizeOptions).
    pub fn builder() -> crate::model::section_based_layout_canvas_size_options::Builder {
        crate::model::section_based_layout_canvas_size_options::Builder::default()
    }
}

/// <p>The options for a paper canvas of a section-based layout.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SectionBasedLayoutPaperCanvasSizeOptions {
    /// <p>The paper size that is used to define canvas dimensions.</p>
    #[doc(hidden)]
    pub paper_size: std::option::Option<crate::model::PaperSize>,
    /// <p>The paper orientation that is used to define canvas dimensions. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p>PORTRAIT</p> </li>
    /// <li> <p>LANDSCAPE</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub paper_orientation: std::option::Option<crate::model::PaperOrientation>,
    /// <p>Defines the spacing between the canvas content and the top, bottom, left, and right edges.</p>
    #[doc(hidden)]
    pub paper_margin: std::option::Option<crate::model::Spacing>,
}
impl SectionBasedLayoutPaperCanvasSizeOptions {
    /// <p>The paper size that is used to define canvas dimensions.</p>
    pub fn paper_size(&self) -> std::option::Option<&crate::model::PaperSize> {
        self.paper_size.as_ref()
    }
    /// <p>The paper orientation that is used to define canvas dimensions. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p>PORTRAIT</p> </li>
    /// <li> <p>LANDSCAPE</p> </li>
    /// </ul>
    pub fn paper_orientation(&self) -> std::option::Option<&crate::model::PaperOrientation> {
        self.paper_orientation.as_ref()
    }
    /// <p>Defines the spacing between the canvas content and the top, bottom, left, and right edges.</p>
    pub fn paper_margin(&self) -> std::option::Option<&crate::model::Spacing> {
        self.paper_margin.as_ref()
    }
}
/// See [`SectionBasedLayoutPaperCanvasSizeOptions`](crate::model::SectionBasedLayoutPaperCanvasSizeOptions).
pub mod section_based_layout_paper_canvas_size_options {

    /// A builder for [`SectionBasedLayoutPaperCanvasSizeOptions`](crate::model::SectionBasedLayoutPaperCanvasSizeOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) paper_size: std::option::Option<crate::model::PaperSize>,
        pub(crate) paper_orientation: std::option::Option<crate::model::PaperOrientation>,
        pub(crate) paper_margin: std::option::Option<crate::model::Spacing>,
    }
    impl Builder {
        /// <p>The paper size that is used to define canvas dimensions.</p>
        pub fn paper_size(mut self, input: crate::model::PaperSize) -> Self {
            self.paper_size = Some(input);
            self
        }
        /// <p>The paper size that is used to define canvas dimensions.</p>
        pub fn set_paper_size(
            mut self,
            input: std::option::Option<crate::model::PaperSize>,
        ) -> Self {
            self.paper_size = input;
            self
        }
        /// <p>The paper orientation that is used to define canvas dimensions. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p>PORTRAIT</p> </li>
        /// <li> <p>LANDSCAPE</p> </li>
        /// </ul>
        pub fn paper_orientation(mut self, input: crate::model::PaperOrientation) -> Self {
            self.paper_orientation = Some(input);
            self
        }
        /// <p>The paper orientation that is used to define canvas dimensions. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p>PORTRAIT</p> </li>
        /// <li> <p>LANDSCAPE</p> </li>
        /// </ul>
        pub fn set_paper_orientation(
            mut self,
            input: std::option::Option<crate::model::PaperOrientation>,
        ) -> Self {
            self.paper_orientation = input;
            self
        }
        /// <p>Defines the spacing between the canvas content and the top, bottom, left, and right edges.</p>
        pub fn paper_margin(mut self, input: crate::model::Spacing) -> Self {
            self.paper_margin = Some(input);
            self
        }
        /// <p>Defines the spacing between the canvas content and the top, bottom, left, and right edges.</p>
        pub fn set_paper_margin(
            mut self,
            input: std::option::Option<crate::model::Spacing>,
        ) -> Self {
            self.paper_margin = input;
            self
        }
        /// Consumes the builder and constructs a [`SectionBasedLayoutPaperCanvasSizeOptions`](crate::model::SectionBasedLayoutPaperCanvasSizeOptions).
        pub fn build(self) -> crate::model::SectionBasedLayoutPaperCanvasSizeOptions {
            crate::model::SectionBasedLayoutPaperCanvasSizeOptions {
                paper_size: self.paper_size,
                paper_orientation: self.paper_orientation,
                paper_margin: self.paper_margin,
            }
        }
    }
}
impl SectionBasedLayoutPaperCanvasSizeOptions {
    /// Creates a new builder-style object to manufacture [`SectionBasedLayoutPaperCanvasSizeOptions`](crate::model::SectionBasedLayoutPaperCanvasSizeOptions).
    pub fn builder() -> crate::model::section_based_layout_paper_canvas_size_options::Builder {
        crate::model::section_based_layout_paper_canvas_size_options::Builder::default()
    }
}

/// <p>The configuration of spacing (often a margin or padding).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Spacing {
    /// <p>Define the top spacing.</p>
    #[doc(hidden)]
    pub top: std::option::Option<std::string::String>,
    /// <p>Define the bottom spacing.</p>
    #[doc(hidden)]
    pub bottom: std::option::Option<std::string::String>,
    /// <p>Define the left spacing.</p>
    #[doc(hidden)]
    pub left: std::option::Option<std::string::String>,
    /// <p>Define the right spacing.</p>
    #[doc(hidden)]
    pub right: std::option::Option<std::string::String>,
}
impl Spacing {
    /// <p>Define the top spacing.</p>
    pub fn top(&self) -> std::option::Option<&str> {
        self.top.as_deref()
    }
    /// <p>Define the bottom spacing.</p>
    pub fn bottom(&self) -> std::option::Option<&str> {
        self.bottom.as_deref()
    }
    /// <p>Define the left spacing.</p>
    pub fn left(&self) -> std::option::Option<&str> {
        self.left.as_deref()
    }
    /// <p>Define the right spacing.</p>
    pub fn right(&self) -> std::option::Option<&str> {
        self.right.as_deref()
    }
}
/// See [`Spacing`](crate::model::Spacing).
pub mod spacing {

    /// A builder for [`Spacing`](crate::model::Spacing).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) top: std::option::Option<std::string::String>,
        pub(crate) bottom: std::option::Option<std::string::String>,
        pub(crate) left: std::option::Option<std::string::String>,
        pub(crate) right: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Define the top spacing.</p>
        pub fn top(mut self, input: impl Into<std::string::String>) -> Self {
            self.top = Some(input.into());
            self
        }
        /// <p>Define the top spacing.</p>
        pub fn set_top(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.top = input;
            self
        }
        /// <p>Define the bottom spacing.</p>
        pub fn bottom(mut self, input: impl Into<std::string::String>) -> Self {
            self.bottom = Some(input.into());
            self
        }
        /// <p>Define the bottom spacing.</p>
        pub fn set_bottom(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bottom = input;
            self
        }
        /// <p>Define the left spacing.</p>
        pub fn left(mut self, input: impl Into<std::string::String>) -> Self {
            self.left = Some(input.into());
            self
        }
        /// <p>Define the left spacing.</p>
        pub fn set_left(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.left = input;
            self
        }
        /// <p>Define the right spacing.</p>
        pub fn right(mut self, input: impl Into<std::string::String>) -> Self {
            self.right = Some(input.into());
            self
        }
        /// <p>Define the right spacing.</p>
        pub fn set_right(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.right = input;
            self
        }
        /// Consumes the builder and constructs a [`Spacing`](crate::model::Spacing).
        pub fn build(self) -> crate::model::Spacing {
            crate::model::Spacing {
                top: self.top,
                bottom: self.bottom,
                left: self.left,
                right: self.right,
            }
        }
    }
}
impl Spacing {
    /// Creates a new builder-style object to manufacture [`Spacing`](crate::model::Spacing).
    pub fn builder() -> crate::model::spacing::Builder {
        crate::model::spacing::Builder::default()
    }
}

/// When writing a match expression against `PaperOrientation`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let paperorientation = unimplemented!();
/// match paperorientation {
///     PaperOrientation::Landscape => { /* ... */ },
///     PaperOrientation::Portrait => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `paperorientation` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PaperOrientation::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PaperOrientation::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PaperOrientation::NewFeature` is defined.
/// Specifically, when `paperorientation` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PaperOrientation::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PaperOrientation {
    #[allow(missing_docs)] // documentation missing in model
    Landscape,
    #[allow(missing_docs)] // documentation missing in model
    Portrait,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PaperOrientation {
    fn from(s: &str) -> Self {
        match s {
            "LANDSCAPE" => PaperOrientation::Landscape,
            "PORTRAIT" => PaperOrientation::Portrait,
            other => PaperOrientation::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PaperOrientation {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PaperOrientation::from(s))
    }
}
impl PaperOrientation {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PaperOrientation::Landscape => "LANDSCAPE",
            PaperOrientation::Portrait => "PORTRAIT",
            PaperOrientation::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LANDSCAPE", "PORTRAIT"]
    }
}
impl AsRef<str> for PaperOrientation {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PaperSize`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let papersize = unimplemented!();
/// match papersize {
///     PaperSize::A0 => { /* ... */ },
///     PaperSize::A1 => { /* ... */ },
///     PaperSize::A2 => { /* ... */ },
///     PaperSize::A3 => { /* ... */ },
///     PaperSize::A4 => { /* ... */ },
///     PaperSize::A5 => { /* ... */ },
///     PaperSize::JisB4 => { /* ... */ },
///     PaperSize::JisB5 => { /* ... */ },
///     PaperSize::UsLegal => { /* ... */ },
///     PaperSize::UsLetter => { /* ... */ },
///     PaperSize::UsTabloidLedger => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `papersize` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PaperSize::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PaperSize::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PaperSize::NewFeature` is defined.
/// Specifically, when `papersize` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PaperSize::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PaperSize {
    #[allow(missing_docs)] // documentation missing in model
    A0,
    #[allow(missing_docs)] // documentation missing in model
    A1,
    #[allow(missing_docs)] // documentation missing in model
    A2,
    #[allow(missing_docs)] // documentation missing in model
    A3,
    #[allow(missing_docs)] // documentation missing in model
    A4,
    #[allow(missing_docs)] // documentation missing in model
    A5,
    #[allow(missing_docs)] // documentation missing in model
    JisB4,
    #[allow(missing_docs)] // documentation missing in model
    JisB5,
    #[allow(missing_docs)] // documentation missing in model
    UsLegal,
    #[allow(missing_docs)] // documentation missing in model
    UsLetter,
    #[allow(missing_docs)] // documentation missing in model
    UsTabloidLedger,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PaperSize {
    fn from(s: &str) -> Self {
        match s {
            "A0" => PaperSize::A0,
            "A1" => PaperSize::A1,
            "A2" => PaperSize::A2,
            "A3" => PaperSize::A3,
            "A4" => PaperSize::A4,
            "A5" => PaperSize::A5,
            "JIS_B4" => PaperSize::JisB4,
            "JIS_B5" => PaperSize::JisB5,
            "US_LEGAL" => PaperSize::UsLegal,
            "US_LETTER" => PaperSize::UsLetter,
            "US_TABLOID_LEDGER" => PaperSize::UsTabloidLedger,
            other => PaperSize::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PaperSize {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PaperSize::from(s))
    }
}
impl PaperSize {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PaperSize::A0 => "A0",
            PaperSize::A1 => "A1",
            PaperSize::A2 => "A2",
            PaperSize::A3 => "A3",
            PaperSize::A4 => "A4",
            PaperSize::A5 => "A5",
            PaperSize::JisB4 => "JIS_B4",
            PaperSize::JisB5 => "JIS_B5",
            PaperSize::UsLegal => "US_LEGAL",
            PaperSize::UsLetter => "US_LETTER",
            PaperSize::UsTabloidLedger => "US_TABLOID_LEDGER",
            PaperSize::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "A0",
            "A1",
            "A2",
            "A3",
            "A4",
            "A5",
            "JIS_B4",
            "JIS_B5",
            "US_LEGAL",
            "US_LETTER",
            "US_TABLOID_LEDGER",
        ]
    }
}
impl AsRef<str> for PaperSize {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The options that determine the default settings for interactive layout configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DefaultInteractiveLayoutConfiguration {
    /// <p>The options that determine the default settings for a grid layout configuration.</p>
    #[doc(hidden)]
    pub grid: std::option::Option<crate::model::DefaultGridLayoutConfiguration>,
    /// <p>The options that determine the default settings of a free-form layout configuration.</p>
    #[doc(hidden)]
    pub free_form: std::option::Option<crate::model::DefaultFreeFormLayoutConfiguration>,
}
impl DefaultInteractiveLayoutConfiguration {
    /// <p>The options that determine the default settings for a grid layout configuration.</p>
    pub fn grid(&self) -> std::option::Option<&crate::model::DefaultGridLayoutConfiguration> {
        self.grid.as_ref()
    }
    /// <p>The options that determine the default settings of a free-form layout configuration.</p>
    pub fn free_form(
        &self,
    ) -> std::option::Option<&crate::model::DefaultFreeFormLayoutConfiguration> {
        self.free_form.as_ref()
    }
}
/// See [`DefaultInteractiveLayoutConfiguration`](crate::model::DefaultInteractiveLayoutConfiguration).
pub mod default_interactive_layout_configuration {

    /// A builder for [`DefaultInteractiveLayoutConfiguration`](crate::model::DefaultInteractiveLayoutConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) grid: std::option::Option<crate::model::DefaultGridLayoutConfiguration>,
        pub(crate) free_form: std::option::Option<crate::model::DefaultFreeFormLayoutConfiguration>,
    }
    impl Builder {
        /// <p>The options that determine the default settings for a grid layout configuration.</p>
        pub fn grid(mut self, input: crate::model::DefaultGridLayoutConfiguration) -> Self {
            self.grid = Some(input);
            self
        }
        /// <p>The options that determine the default settings for a grid layout configuration.</p>
        pub fn set_grid(
            mut self,
            input: std::option::Option<crate::model::DefaultGridLayoutConfiguration>,
        ) -> Self {
            self.grid = input;
            self
        }
        /// <p>The options that determine the default settings of a free-form layout configuration.</p>
        pub fn free_form(
            mut self,
            input: crate::model::DefaultFreeFormLayoutConfiguration,
        ) -> Self {
            self.free_form = Some(input);
            self
        }
        /// <p>The options that determine the default settings of a free-form layout configuration.</p>
        pub fn set_free_form(
            mut self,
            input: std::option::Option<crate::model::DefaultFreeFormLayoutConfiguration>,
        ) -> Self {
            self.free_form = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultInteractiveLayoutConfiguration`](crate::model::DefaultInteractiveLayoutConfiguration).
        pub fn build(self) -> crate::model::DefaultInteractiveLayoutConfiguration {
            crate::model::DefaultInteractiveLayoutConfiguration {
                grid: self.grid,
                free_form: self.free_form,
            }
        }
    }
}
impl DefaultInteractiveLayoutConfiguration {
    /// Creates a new builder-style object to manufacture [`DefaultInteractiveLayoutConfiguration`](crate::model::DefaultInteractiveLayoutConfiguration).
    pub fn builder() -> crate::model::default_interactive_layout_configuration::Builder {
        crate::model::default_interactive_layout_configuration::Builder::default()
    }
}

/// <p>The options that determine the default settings of a free-form layout configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DefaultFreeFormLayoutConfiguration {
    /// <p>Determines the screen canvas size options for a free-form layout.</p>
    #[doc(hidden)]
    pub canvas_size_options: std::option::Option<crate::model::FreeFormLayoutCanvasSizeOptions>,
}
impl DefaultFreeFormLayoutConfiguration {
    /// <p>Determines the screen canvas size options for a free-form layout.</p>
    pub fn canvas_size_options(
        &self,
    ) -> std::option::Option<&crate::model::FreeFormLayoutCanvasSizeOptions> {
        self.canvas_size_options.as_ref()
    }
}
/// See [`DefaultFreeFormLayoutConfiguration`](crate::model::DefaultFreeFormLayoutConfiguration).
pub mod default_free_form_layout_configuration {

    /// A builder for [`DefaultFreeFormLayoutConfiguration`](crate::model::DefaultFreeFormLayoutConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) canvas_size_options:
            std::option::Option<crate::model::FreeFormLayoutCanvasSizeOptions>,
    }
    impl Builder {
        /// <p>Determines the screen canvas size options for a free-form layout.</p>
        pub fn canvas_size_options(
            mut self,
            input: crate::model::FreeFormLayoutCanvasSizeOptions,
        ) -> Self {
            self.canvas_size_options = Some(input);
            self
        }
        /// <p>Determines the screen canvas size options for a free-form layout.</p>
        pub fn set_canvas_size_options(
            mut self,
            input: std::option::Option<crate::model::FreeFormLayoutCanvasSizeOptions>,
        ) -> Self {
            self.canvas_size_options = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultFreeFormLayoutConfiguration`](crate::model::DefaultFreeFormLayoutConfiguration).
        pub fn build(self) -> crate::model::DefaultFreeFormLayoutConfiguration {
            crate::model::DefaultFreeFormLayoutConfiguration {
                canvas_size_options: self.canvas_size_options,
            }
        }
    }
}
impl DefaultFreeFormLayoutConfiguration {
    /// Creates a new builder-style object to manufacture [`DefaultFreeFormLayoutConfiguration`](crate::model::DefaultFreeFormLayoutConfiguration).
    pub fn builder() -> crate::model::default_free_form_layout_configuration::Builder {
        crate::model::default_free_form_layout_configuration::Builder::default()
    }
}

/// <p>Configuration options for the canvas of a free-form layout.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FreeFormLayoutCanvasSizeOptions {
    /// <p>The options that determine the sizing of the canvas used in a free-form layout.</p>
    #[doc(hidden)]
    pub screen_canvas_size_options:
        std::option::Option<crate::model::FreeFormLayoutScreenCanvasSizeOptions>,
}
impl FreeFormLayoutCanvasSizeOptions {
    /// <p>The options that determine the sizing of the canvas used in a free-form layout.</p>
    pub fn screen_canvas_size_options(
        &self,
    ) -> std::option::Option<&crate::model::FreeFormLayoutScreenCanvasSizeOptions> {
        self.screen_canvas_size_options.as_ref()
    }
}
/// See [`FreeFormLayoutCanvasSizeOptions`](crate::model::FreeFormLayoutCanvasSizeOptions).
pub mod free_form_layout_canvas_size_options {

    /// A builder for [`FreeFormLayoutCanvasSizeOptions`](crate::model::FreeFormLayoutCanvasSizeOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) screen_canvas_size_options:
            std::option::Option<crate::model::FreeFormLayoutScreenCanvasSizeOptions>,
    }
    impl Builder {
        /// <p>The options that determine the sizing of the canvas used in a free-form layout.</p>
        pub fn screen_canvas_size_options(
            mut self,
            input: crate::model::FreeFormLayoutScreenCanvasSizeOptions,
        ) -> Self {
            self.screen_canvas_size_options = Some(input);
            self
        }
        /// <p>The options that determine the sizing of the canvas used in a free-form layout.</p>
        pub fn set_screen_canvas_size_options(
            mut self,
            input: std::option::Option<crate::model::FreeFormLayoutScreenCanvasSizeOptions>,
        ) -> Self {
            self.screen_canvas_size_options = input;
            self
        }
        /// Consumes the builder and constructs a [`FreeFormLayoutCanvasSizeOptions`](crate::model::FreeFormLayoutCanvasSizeOptions).
        pub fn build(self) -> crate::model::FreeFormLayoutCanvasSizeOptions {
            crate::model::FreeFormLayoutCanvasSizeOptions {
                screen_canvas_size_options: self.screen_canvas_size_options,
            }
        }
    }
}
impl FreeFormLayoutCanvasSizeOptions {
    /// Creates a new builder-style object to manufacture [`FreeFormLayoutCanvasSizeOptions`](crate::model::FreeFormLayoutCanvasSizeOptions).
    pub fn builder() -> crate::model::free_form_layout_canvas_size_options::Builder {
        crate::model::free_form_layout_canvas_size_options::Builder::default()
    }
}

/// <p>The options that determine the sizing of the canvas used in a free-form layout.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FreeFormLayoutScreenCanvasSizeOptions {
    /// <p>The width that the view port will be optimized for when the layout renders.</p>
    #[doc(hidden)]
    pub optimized_view_port_width: std::option::Option<std::string::String>,
}
impl FreeFormLayoutScreenCanvasSizeOptions {
    /// <p>The width that the view port will be optimized for when the layout renders.</p>
    pub fn optimized_view_port_width(&self) -> std::option::Option<&str> {
        self.optimized_view_port_width.as_deref()
    }
}
/// See [`FreeFormLayoutScreenCanvasSizeOptions`](crate::model::FreeFormLayoutScreenCanvasSizeOptions).
pub mod free_form_layout_screen_canvas_size_options {

    /// A builder for [`FreeFormLayoutScreenCanvasSizeOptions`](crate::model::FreeFormLayoutScreenCanvasSizeOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) optimized_view_port_width: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The width that the view port will be optimized for when the layout renders.</p>
        pub fn optimized_view_port_width(mut self, input: impl Into<std::string::String>) -> Self {
            self.optimized_view_port_width = Some(input.into());
            self
        }
        /// <p>The width that the view port will be optimized for when the layout renders.</p>
        pub fn set_optimized_view_port_width(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.optimized_view_port_width = input;
            self
        }
        /// Consumes the builder and constructs a [`FreeFormLayoutScreenCanvasSizeOptions`](crate::model::FreeFormLayoutScreenCanvasSizeOptions).
        pub fn build(self) -> crate::model::FreeFormLayoutScreenCanvasSizeOptions {
            crate::model::FreeFormLayoutScreenCanvasSizeOptions {
                optimized_view_port_width: self.optimized_view_port_width,
            }
        }
    }
}
impl FreeFormLayoutScreenCanvasSizeOptions {
    /// Creates a new builder-style object to manufacture [`FreeFormLayoutScreenCanvasSizeOptions`](crate::model::FreeFormLayoutScreenCanvasSizeOptions).
    pub fn builder() -> crate::model::free_form_layout_screen_canvas_size_options::Builder {
        crate::model::free_form_layout_screen_canvas_size_options::Builder::default()
    }
}

/// <p>The options that determine the default settings for a grid layout configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DefaultGridLayoutConfiguration {
    /// <p>Determines the screen canvas size options for a grid layout.</p>
    #[doc(hidden)]
    pub canvas_size_options: std::option::Option<crate::model::GridLayoutCanvasSizeOptions>,
}
impl DefaultGridLayoutConfiguration {
    /// <p>Determines the screen canvas size options for a grid layout.</p>
    pub fn canvas_size_options(
        &self,
    ) -> std::option::Option<&crate::model::GridLayoutCanvasSizeOptions> {
        self.canvas_size_options.as_ref()
    }
}
/// See [`DefaultGridLayoutConfiguration`](crate::model::DefaultGridLayoutConfiguration).
pub mod default_grid_layout_configuration {

    /// A builder for [`DefaultGridLayoutConfiguration`](crate::model::DefaultGridLayoutConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) canvas_size_options:
            std::option::Option<crate::model::GridLayoutCanvasSizeOptions>,
    }
    impl Builder {
        /// <p>Determines the screen canvas size options for a grid layout.</p>
        pub fn canvas_size_options(
            mut self,
            input: crate::model::GridLayoutCanvasSizeOptions,
        ) -> Self {
            self.canvas_size_options = Some(input);
            self
        }
        /// <p>Determines the screen canvas size options for a grid layout.</p>
        pub fn set_canvas_size_options(
            mut self,
            input: std::option::Option<crate::model::GridLayoutCanvasSizeOptions>,
        ) -> Self {
            self.canvas_size_options = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultGridLayoutConfiguration`](crate::model::DefaultGridLayoutConfiguration).
        pub fn build(self) -> crate::model::DefaultGridLayoutConfiguration {
            crate::model::DefaultGridLayoutConfiguration {
                canvas_size_options: self.canvas_size_options,
            }
        }
    }
}
impl DefaultGridLayoutConfiguration {
    /// Creates a new builder-style object to manufacture [`DefaultGridLayoutConfiguration`](crate::model::DefaultGridLayoutConfiguration).
    pub fn builder() -> crate::model::default_grid_layout_configuration::Builder {
        crate::model::default_grid_layout_configuration::Builder::default()
    }
}

/// <p>Configuration options for the canvas of a grid layout.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GridLayoutCanvasSizeOptions {
    /// <p>The options that determine the sizing of the canvas used in a grid layout.</p>
    #[doc(hidden)]
    pub screen_canvas_size_options:
        std::option::Option<crate::model::GridLayoutScreenCanvasSizeOptions>,
}
impl GridLayoutCanvasSizeOptions {
    /// <p>The options that determine the sizing of the canvas used in a grid layout.</p>
    pub fn screen_canvas_size_options(
        &self,
    ) -> std::option::Option<&crate::model::GridLayoutScreenCanvasSizeOptions> {
        self.screen_canvas_size_options.as_ref()
    }
}
/// See [`GridLayoutCanvasSizeOptions`](crate::model::GridLayoutCanvasSizeOptions).
pub mod grid_layout_canvas_size_options {

    /// A builder for [`GridLayoutCanvasSizeOptions`](crate::model::GridLayoutCanvasSizeOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) screen_canvas_size_options:
            std::option::Option<crate::model::GridLayoutScreenCanvasSizeOptions>,
    }
    impl Builder {
        /// <p>The options that determine the sizing of the canvas used in a grid layout.</p>
        pub fn screen_canvas_size_options(
            mut self,
            input: crate::model::GridLayoutScreenCanvasSizeOptions,
        ) -> Self {
            self.screen_canvas_size_options = Some(input);
            self
        }
        /// <p>The options that determine the sizing of the canvas used in a grid layout.</p>
        pub fn set_screen_canvas_size_options(
            mut self,
            input: std::option::Option<crate::model::GridLayoutScreenCanvasSizeOptions>,
        ) -> Self {
            self.screen_canvas_size_options = input;
            self
        }
        /// Consumes the builder and constructs a [`GridLayoutCanvasSizeOptions`](crate::model::GridLayoutCanvasSizeOptions).
        pub fn build(self) -> crate::model::GridLayoutCanvasSizeOptions {
            crate::model::GridLayoutCanvasSizeOptions {
                screen_canvas_size_options: self.screen_canvas_size_options,
            }
        }
    }
}
impl GridLayoutCanvasSizeOptions {
    /// Creates a new builder-style object to manufacture [`GridLayoutCanvasSizeOptions`](crate::model::GridLayoutCanvasSizeOptions).
    pub fn builder() -> crate::model::grid_layout_canvas_size_options::Builder {
        crate::model::grid_layout_canvas_size_options::Builder::default()
    }
}

/// <p>The options that determine the sizing of the canvas used in a grid layout.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GridLayoutScreenCanvasSizeOptions {
    /// <p>This value determines the layout behavior when the viewport is resized.</p>
    /// <ul>
    /// <li> <p> <code>FIXED</code>: A fixed width will be used when optimizing the layout. In the Amazon QuickSight console, this option is called <code>Classic</code>.</p> </li>
    /// <li> <p> <code>RESPONSIVE</code>: The width of the canvas will be responsive and optimized to the view port. In the Amazon QuickSight console, this option is called <code>Tiled</code>.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub resize_option: std::option::Option<crate::model::ResizeOption>,
    /// <p>The width that the view port will be optimized for when the layout renders.</p>
    #[doc(hidden)]
    pub optimized_view_port_width: std::option::Option<std::string::String>,
}
impl GridLayoutScreenCanvasSizeOptions {
    /// <p>This value determines the layout behavior when the viewport is resized.</p>
    /// <ul>
    /// <li> <p> <code>FIXED</code>: A fixed width will be used when optimizing the layout. In the Amazon QuickSight console, this option is called <code>Classic</code>.</p> </li>
    /// <li> <p> <code>RESPONSIVE</code>: The width of the canvas will be responsive and optimized to the view port. In the Amazon QuickSight console, this option is called <code>Tiled</code>.</p> </li>
    /// </ul>
    pub fn resize_option(&self) -> std::option::Option<&crate::model::ResizeOption> {
        self.resize_option.as_ref()
    }
    /// <p>The width that the view port will be optimized for when the layout renders.</p>
    pub fn optimized_view_port_width(&self) -> std::option::Option<&str> {
        self.optimized_view_port_width.as_deref()
    }
}
/// See [`GridLayoutScreenCanvasSizeOptions`](crate::model::GridLayoutScreenCanvasSizeOptions).
pub mod grid_layout_screen_canvas_size_options {

    /// A builder for [`GridLayoutScreenCanvasSizeOptions`](crate::model::GridLayoutScreenCanvasSizeOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resize_option: std::option::Option<crate::model::ResizeOption>,
        pub(crate) optimized_view_port_width: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>This value determines the layout behavior when the viewport is resized.</p>
        /// <ul>
        /// <li> <p> <code>FIXED</code>: A fixed width will be used when optimizing the layout. In the Amazon QuickSight console, this option is called <code>Classic</code>.</p> </li>
        /// <li> <p> <code>RESPONSIVE</code>: The width of the canvas will be responsive and optimized to the view port. In the Amazon QuickSight console, this option is called <code>Tiled</code>.</p> </li>
        /// </ul>
        pub fn resize_option(mut self, input: crate::model::ResizeOption) -> Self {
            self.resize_option = Some(input);
            self
        }
        /// <p>This value determines the layout behavior when the viewport is resized.</p>
        /// <ul>
        /// <li> <p> <code>FIXED</code>: A fixed width will be used when optimizing the layout. In the Amazon QuickSight console, this option is called <code>Classic</code>.</p> </li>
        /// <li> <p> <code>RESPONSIVE</code>: The width of the canvas will be responsive and optimized to the view port. In the Amazon QuickSight console, this option is called <code>Tiled</code>.</p> </li>
        /// </ul>
        pub fn set_resize_option(
            mut self,
            input: std::option::Option<crate::model::ResizeOption>,
        ) -> Self {
            self.resize_option = input;
            self
        }
        /// <p>The width that the view port will be optimized for when the layout renders.</p>
        pub fn optimized_view_port_width(mut self, input: impl Into<std::string::String>) -> Self {
            self.optimized_view_port_width = Some(input.into());
            self
        }
        /// <p>The width that the view port will be optimized for when the layout renders.</p>
        pub fn set_optimized_view_port_width(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.optimized_view_port_width = input;
            self
        }
        /// Consumes the builder and constructs a [`GridLayoutScreenCanvasSizeOptions`](crate::model::GridLayoutScreenCanvasSizeOptions).
        pub fn build(self) -> crate::model::GridLayoutScreenCanvasSizeOptions {
            crate::model::GridLayoutScreenCanvasSizeOptions {
                resize_option: self.resize_option,
                optimized_view_port_width: self.optimized_view_port_width,
            }
        }
    }
}
impl GridLayoutScreenCanvasSizeOptions {
    /// Creates a new builder-style object to manufacture [`GridLayoutScreenCanvasSizeOptions`](crate::model::GridLayoutScreenCanvasSizeOptions).
    pub fn builder() -> crate::model::grid_layout_screen_canvas_size_options::Builder {
        crate::model::grid_layout_screen_canvas_size_options::Builder::default()
    }
}

/// When writing a match expression against `ResizeOption`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resizeoption = unimplemented!();
/// match resizeoption {
///     ResizeOption::Fixed => { /* ... */ },
///     ResizeOption::Responsive => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resizeoption` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResizeOption::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResizeOption::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResizeOption::NewFeature` is defined.
/// Specifically, when `resizeoption` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResizeOption::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResizeOption {
    #[allow(missing_docs)] // documentation missing in model
    Fixed,
    #[allow(missing_docs)] // documentation missing in model
    Responsive,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResizeOption {
    fn from(s: &str) -> Self {
        match s {
            "FIXED" => ResizeOption::Fixed,
            "RESPONSIVE" => ResizeOption::Responsive,
            other => ResizeOption::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ResizeOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResizeOption::from(s))
    }
}
impl ResizeOption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResizeOption::Fixed => "FIXED",
            ResizeOption::Responsive => "RESPONSIVE",
            ResizeOption::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FIXED", "RESPONSIVE"]
    }
}
impl AsRef<str> for ResizeOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The general configuration of a column.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnConfiguration {
    /// <p>The column.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The format configuration of a column.</p>
    #[doc(hidden)]
    pub format_configuration: std::option::Option<crate::model::FormatConfiguration>,
    /// <p>The role of the column.</p>
    #[doc(hidden)]
    pub role: std::option::Option<crate::model::ColumnRole>,
}
impl ColumnConfiguration {
    /// <p>The column.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>The format configuration of a column.</p>
    pub fn format_configuration(&self) -> std::option::Option<&crate::model::FormatConfiguration> {
        self.format_configuration.as_ref()
    }
    /// <p>The role of the column.</p>
    pub fn role(&self) -> std::option::Option<&crate::model::ColumnRole> {
        self.role.as_ref()
    }
}
/// See [`ColumnConfiguration`](crate::model::ColumnConfiguration).
pub mod column_configuration {

    /// A builder for [`ColumnConfiguration`](crate::model::ColumnConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) format_configuration: std::option::Option<crate::model::FormatConfiguration>,
        pub(crate) role: std::option::Option<crate::model::ColumnRole>,
    }
    impl Builder {
        /// <p>The column.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The format configuration of a column.</p>
        pub fn format_configuration(mut self, input: crate::model::FormatConfiguration) -> Self {
            self.format_configuration = Some(input);
            self
        }
        /// <p>The format configuration of a column.</p>
        pub fn set_format_configuration(
            mut self,
            input: std::option::Option<crate::model::FormatConfiguration>,
        ) -> Self {
            self.format_configuration = input;
            self
        }
        /// <p>The role of the column.</p>
        pub fn role(mut self, input: crate::model::ColumnRole) -> Self {
            self.role = Some(input);
            self
        }
        /// <p>The role of the column.</p>
        pub fn set_role(mut self, input: std::option::Option<crate::model::ColumnRole>) -> Self {
            self.role = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnConfiguration`](crate::model::ColumnConfiguration).
        pub fn build(self) -> crate::model::ColumnConfiguration {
            crate::model::ColumnConfiguration {
                column: self.column,
                format_configuration: self.format_configuration,
                role: self.role,
            }
        }
    }
}
impl ColumnConfiguration {
    /// Creates a new builder-style object to manufacture [`ColumnConfiguration`](crate::model::ColumnConfiguration).
    pub fn builder() -> crate::model::column_configuration::Builder {
        crate::model::column_configuration::Builder::default()
    }
}

/// When writing a match expression against `ColumnRole`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let columnrole = unimplemented!();
/// match columnrole {
///     ColumnRole::Dimension => { /* ... */ },
///     ColumnRole::Measure => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `columnrole` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ColumnRole::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ColumnRole::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ColumnRole::NewFeature` is defined.
/// Specifically, when `columnrole` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ColumnRole::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ColumnRole {
    #[allow(missing_docs)] // documentation missing in model
    Dimension,
    #[allow(missing_docs)] // documentation missing in model
    Measure,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ColumnRole {
    fn from(s: &str) -> Self {
        match s {
            "DIMENSION" => ColumnRole::Dimension,
            "MEASURE" => ColumnRole::Measure,
            other => ColumnRole::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ColumnRole {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ColumnRole::from(s))
    }
}
impl ColumnRole {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ColumnRole::Dimension => "DIMENSION",
            ColumnRole::Measure => "MEASURE",
            ColumnRole::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DIMENSION", "MEASURE"]
    }
}
impl AsRef<str> for ColumnRole {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The formatting configuration for all types of field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FormatConfiguration {
    /// <p>Formatting configuration for string fields.</p>
    #[doc(hidden)]
    pub string_format_configuration: std::option::Option<crate::model::StringFormatConfiguration>,
    /// <p>Formatting configuration for number fields.</p>
    #[doc(hidden)]
    pub number_format_configuration: std::option::Option<crate::model::NumberFormatConfiguration>,
    /// <p>Formatting configuration for <code>DateTime</code> fields.</p>
    #[doc(hidden)]
    pub date_time_format_configuration:
        std::option::Option<crate::model::DateTimeFormatConfiguration>,
}
impl FormatConfiguration {
    /// <p>Formatting configuration for string fields.</p>
    pub fn string_format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::StringFormatConfiguration> {
        self.string_format_configuration.as_ref()
    }
    /// <p>Formatting configuration for number fields.</p>
    pub fn number_format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NumberFormatConfiguration> {
        self.number_format_configuration.as_ref()
    }
    /// <p>Formatting configuration for <code>DateTime</code> fields.</p>
    pub fn date_time_format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DateTimeFormatConfiguration> {
        self.date_time_format_configuration.as_ref()
    }
}
/// See [`FormatConfiguration`](crate::model::FormatConfiguration).
pub mod format_configuration {

    /// A builder for [`FormatConfiguration`](crate::model::FormatConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) string_format_configuration:
            std::option::Option<crate::model::StringFormatConfiguration>,
        pub(crate) number_format_configuration:
            std::option::Option<crate::model::NumberFormatConfiguration>,
        pub(crate) date_time_format_configuration:
            std::option::Option<crate::model::DateTimeFormatConfiguration>,
    }
    impl Builder {
        /// <p>Formatting configuration for string fields.</p>
        pub fn string_format_configuration(
            mut self,
            input: crate::model::StringFormatConfiguration,
        ) -> Self {
            self.string_format_configuration = Some(input);
            self
        }
        /// <p>Formatting configuration for string fields.</p>
        pub fn set_string_format_configuration(
            mut self,
            input: std::option::Option<crate::model::StringFormatConfiguration>,
        ) -> Self {
            self.string_format_configuration = input;
            self
        }
        /// <p>Formatting configuration for number fields.</p>
        pub fn number_format_configuration(
            mut self,
            input: crate::model::NumberFormatConfiguration,
        ) -> Self {
            self.number_format_configuration = Some(input);
            self
        }
        /// <p>Formatting configuration for number fields.</p>
        pub fn set_number_format_configuration(
            mut self,
            input: std::option::Option<crate::model::NumberFormatConfiguration>,
        ) -> Self {
            self.number_format_configuration = input;
            self
        }
        /// <p>Formatting configuration for <code>DateTime</code> fields.</p>
        pub fn date_time_format_configuration(
            mut self,
            input: crate::model::DateTimeFormatConfiguration,
        ) -> Self {
            self.date_time_format_configuration = Some(input);
            self
        }
        /// <p>Formatting configuration for <code>DateTime</code> fields.</p>
        pub fn set_date_time_format_configuration(
            mut self,
            input: std::option::Option<crate::model::DateTimeFormatConfiguration>,
        ) -> Self {
            self.date_time_format_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`FormatConfiguration`](crate::model::FormatConfiguration).
        pub fn build(self) -> crate::model::FormatConfiguration {
            crate::model::FormatConfiguration {
                string_format_configuration: self.string_format_configuration,
                number_format_configuration: self.number_format_configuration,
                date_time_format_configuration: self.date_time_format_configuration,
            }
        }
    }
}
impl FormatConfiguration {
    /// Creates a new builder-style object to manufacture [`FormatConfiguration`](crate::model::FormatConfiguration).
    pub fn builder() -> crate::model::format_configuration::Builder {
        crate::model::format_configuration::Builder::default()
    }
}

/// <p>Formatting configuration for <code>DateTime</code> fields.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DateTimeFormatConfiguration {
    /// <p>Determines the <code>DateTime</code> format.</p>
    #[doc(hidden)]
    pub date_time_format: std::option::Option<std::string::String>,
    /// <p>The options that determine the null value format configuration.</p>
    #[doc(hidden)]
    pub null_value_format_configuration:
        std::option::Option<crate::model::NullValueFormatConfiguration>,
    /// <p>The formatting configuration for numeric <code>DateTime</code> fields.</p>
    #[doc(hidden)]
    pub numeric_format_configuration: std::option::Option<crate::model::NumericFormatConfiguration>,
}
impl DateTimeFormatConfiguration {
    /// <p>Determines the <code>DateTime</code> format.</p>
    pub fn date_time_format(&self) -> std::option::Option<&str> {
        self.date_time_format.as_deref()
    }
    /// <p>The options that determine the null value format configuration.</p>
    pub fn null_value_format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NullValueFormatConfiguration> {
        self.null_value_format_configuration.as_ref()
    }
    /// <p>The formatting configuration for numeric <code>DateTime</code> fields.</p>
    pub fn numeric_format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NumericFormatConfiguration> {
        self.numeric_format_configuration.as_ref()
    }
}
/// See [`DateTimeFormatConfiguration`](crate::model::DateTimeFormatConfiguration).
pub mod date_time_format_configuration {

    /// A builder for [`DateTimeFormatConfiguration`](crate::model::DateTimeFormatConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) date_time_format: std::option::Option<std::string::String>,
        pub(crate) null_value_format_configuration:
            std::option::Option<crate::model::NullValueFormatConfiguration>,
        pub(crate) numeric_format_configuration:
            std::option::Option<crate::model::NumericFormatConfiguration>,
    }
    impl Builder {
        /// <p>Determines the <code>DateTime</code> format.</p>
        pub fn date_time_format(mut self, input: impl Into<std::string::String>) -> Self {
            self.date_time_format = Some(input.into());
            self
        }
        /// <p>Determines the <code>DateTime</code> format.</p>
        pub fn set_date_time_format(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.date_time_format = input;
            self
        }
        /// <p>The options that determine the null value format configuration.</p>
        pub fn null_value_format_configuration(
            mut self,
            input: crate::model::NullValueFormatConfiguration,
        ) -> Self {
            self.null_value_format_configuration = Some(input);
            self
        }
        /// <p>The options that determine the null value format configuration.</p>
        pub fn set_null_value_format_configuration(
            mut self,
            input: std::option::Option<crate::model::NullValueFormatConfiguration>,
        ) -> Self {
            self.null_value_format_configuration = input;
            self
        }
        /// <p>The formatting configuration for numeric <code>DateTime</code> fields.</p>
        pub fn numeric_format_configuration(
            mut self,
            input: crate::model::NumericFormatConfiguration,
        ) -> Self {
            self.numeric_format_configuration = Some(input);
            self
        }
        /// <p>The formatting configuration for numeric <code>DateTime</code> fields.</p>
        pub fn set_numeric_format_configuration(
            mut self,
            input: std::option::Option<crate::model::NumericFormatConfiguration>,
        ) -> Self {
            self.numeric_format_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`DateTimeFormatConfiguration`](crate::model::DateTimeFormatConfiguration).
        pub fn build(self) -> crate::model::DateTimeFormatConfiguration {
            crate::model::DateTimeFormatConfiguration {
                date_time_format: self.date_time_format,
                null_value_format_configuration: self.null_value_format_configuration,
                numeric_format_configuration: self.numeric_format_configuration,
            }
        }
    }
}
impl DateTimeFormatConfiguration {
    /// Creates a new builder-style object to manufacture [`DateTimeFormatConfiguration`](crate::model::DateTimeFormatConfiguration).
    pub fn builder() -> crate::model::date_time_format_configuration::Builder {
        crate::model::date_time_format_configuration::Builder::default()
    }
}

/// <p>The options that determine the numeric format configuration.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NumericFormatConfiguration {
    /// <p>The options that determine the number display format configuration.</p>
    #[doc(hidden)]
    pub number_display_format_configuration:
        std::option::Option<crate::model::NumberDisplayFormatConfiguration>,
    /// <p>The options that determine the currency display format configuration.</p>
    #[doc(hidden)]
    pub currency_display_format_configuration:
        std::option::Option<crate::model::CurrencyDisplayFormatConfiguration>,
    /// <p>The options that determine the percentage display format configuration.</p>
    #[doc(hidden)]
    pub percentage_display_format_configuration:
        std::option::Option<crate::model::PercentageDisplayFormatConfiguration>,
}
impl NumericFormatConfiguration {
    /// <p>The options that determine the number display format configuration.</p>
    pub fn number_display_format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NumberDisplayFormatConfiguration> {
        self.number_display_format_configuration.as_ref()
    }
    /// <p>The options that determine the currency display format configuration.</p>
    pub fn currency_display_format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::CurrencyDisplayFormatConfiguration> {
        self.currency_display_format_configuration.as_ref()
    }
    /// <p>The options that determine the percentage display format configuration.</p>
    pub fn percentage_display_format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::PercentageDisplayFormatConfiguration> {
        self.percentage_display_format_configuration.as_ref()
    }
}
/// See [`NumericFormatConfiguration`](crate::model::NumericFormatConfiguration).
pub mod numeric_format_configuration {

    /// A builder for [`NumericFormatConfiguration`](crate::model::NumericFormatConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) number_display_format_configuration:
            std::option::Option<crate::model::NumberDisplayFormatConfiguration>,
        pub(crate) currency_display_format_configuration:
            std::option::Option<crate::model::CurrencyDisplayFormatConfiguration>,
        pub(crate) percentage_display_format_configuration:
            std::option::Option<crate::model::PercentageDisplayFormatConfiguration>,
    }
    impl Builder {
        /// <p>The options that determine the number display format configuration.</p>
        pub fn number_display_format_configuration(
            mut self,
            input: crate::model::NumberDisplayFormatConfiguration,
        ) -> Self {
            self.number_display_format_configuration = Some(input);
            self
        }
        /// <p>The options that determine the number display format configuration.</p>
        pub fn set_number_display_format_configuration(
            mut self,
            input: std::option::Option<crate::model::NumberDisplayFormatConfiguration>,
        ) -> Self {
            self.number_display_format_configuration = input;
            self
        }
        /// <p>The options that determine the currency display format configuration.</p>
        pub fn currency_display_format_configuration(
            mut self,
            input: crate::model::CurrencyDisplayFormatConfiguration,
        ) -> Self {
            self.currency_display_format_configuration = Some(input);
            self
        }
        /// <p>The options that determine the currency display format configuration.</p>
        pub fn set_currency_display_format_configuration(
            mut self,
            input: std::option::Option<crate::model::CurrencyDisplayFormatConfiguration>,
        ) -> Self {
            self.currency_display_format_configuration = input;
            self
        }
        /// <p>The options that determine the percentage display format configuration.</p>
        pub fn percentage_display_format_configuration(
            mut self,
            input: crate::model::PercentageDisplayFormatConfiguration,
        ) -> Self {
            self.percentage_display_format_configuration = Some(input);
            self
        }
        /// <p>The options that determine the percentage display format configuration.</p>
        pub fn set_percentage_display_format_configuration(
            mut self,
            input: std::option::Option<crate::model::PercentageDisplayFormatConfiguration>,
        ) -> Self {
            self.percentage_display_format_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`NumericFormatConfiguration`](crate::model::NumericFormatConfiguration).
        pub fn build(self) -> crate::model::NumericFormatConfiguration {
            crate::model::NumericFormatConfiguration {
                number_display_format_configuration: self.number_display_format_configuration,
                currency_display_format_configuration: self.currency_display_format_configuration,
                percentage_display_format_configuration: self
                    .percentage_display_format_configuration,
            }
        }
    }
}
impl NumericFormatConfiguration {
    /// Creates a new builder-style object to manufacture [`NumericFormatConfiguration`](crate::model::NumericFormatConfiguration).
    pub fn builder() -> crate::model::numeric_format_configuration::Builder {
        crate::model::numeric_format_configuration::Builder::default()
    }
}

/// <p>The options that determine the percentage display format configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PercentageDisplayFormatConfiguration {
    /// <p>Determines the prefix value of the percentage format.</p>
    #[doc(hidden)]
    pub prefix: std::option::Option<std::string::String>,
    /// <p>Determines the suffix value of the percentage format.</p>
    #[doc(hidden)]
    pub suffix: std::option::Option<std::string::String>,
    /// <p>The options that determine the numeric separator configuration.</p>
    #[doc(hidden)]
    pub separator_configuration: std::option::Option<crate::model::NumericSeparatorConfiguration>,
    /// <p>The option that determines the decimal places configuration.</p>
    #[doc(hidden)]
    pub decimal_places_configuration: std::option::Option<crate::model::DecimalPlacesConfiguration>,
    /// <p>The options that determine the negative value configuration.</p>
    #[doc(hidden)]
    pub negative_value_configuration: std::option::Option<crate::model::NegativeValueConfiguration>,
    /// <p>The options that determine the null value format configuration.</p>
    #[doc(hidden)]
    pub null_value_format_configuration:
        std::option::Option<crate::model::NullValueFormatConfiguration>,
}
impl PercentageDisplayFormatConfiguration {
    /// <p>Determines the prefix value of the percentage format.</p>
    pub fn prefix(&self) -> std::option::Option<&str> {
        self.prefix.as_deref()
    }
    /// <p>Determines the suffix value of the percentage format.</p>
    pub fn suffix(&self) -> std::option::Option<&str> {
        self.suffix.as_deref()
    }
    /// <p>The options that determine the numeric separator configuration.</p>
    pub fn separator_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NumericSeparatorConfiguration> {
        self.separator_configuration.as_ref()
    }
    /// <p>The option that determines the decimal places configuration.</p>
    pub fn decimal_places_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DecimalPlacesConfiguration> {
        self.decimal_places_configuration.as_ref()
    }
    /// <p>The options that determine the negative value configuration.</p>
    pub fn negative_value_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NegativeValueConfiguration> {
        self.negative_value_configuration.as_ref()
    }
    /// <p>The options that determine the null value format configuration.</p>
    pub fn null_value_format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NullValueFormatConfiguration> {
        self.null_value_format_configuration.as_ref()
    }
}
impl std::fmt::Debug for PercentageDisplayFormatConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PercentageDisplayFormatConfiguration");
        formatter.field("prefix", &"*** Sensitive Data Redacted ***");
        formatter.field("suffix", &"*** Sensitive Data Redacted ***");
        formatter.field("separator_configuration", &self.separator_configuration);
        formatter.field(
            "decimal_places_configuration",
            &self.decimal_places_configuration,
        );
        formatter.field(
            "negative_value_configuration",
            &self.negative_value_configuration,
        );
        formatter.field(
            "null_value_format_configuration",
            &self.null_value_format_configuration,
        );
        formatter.finish()
    }
}
/// See [`PercentageDisplayFormatConfiguration`](crate::model::PercentageDisplayFormatConfiguration).
pub mod percentage_display_format_configuration {

    /// A builder for [`PercentageDisplayFormatConfiguration`](crate::model::PercentageDisplayFormatConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) prefix: std::option::Option<std::string::String>,
        pub(crate) suffix: std::option::Option<std::string::String>,
        pub(crate) separator_configuration:
            std::option::Option<crate::model::NumericSeparatorConfiguration>,
        pub(crate) decimal_places_configuration:
            std::option::Option<crate::model::DecimalPlacesConfiguration>,
        pub(crate) negative_value_configuration:
            std::option::Option<crate::model::NegativeValueConfiguration>,
        pub(crate) null_value_format_configuration:
            std::option::Option<crate::model::NullValueFormatConfiguration>,
    }
    impl Builder {
        /// <p>Determines the prefix value of the percentage format.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        /// <p>Determines the prefix value of the percentage format.</p>
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// <p>Determines the suffix value of the percentage format.</p>
        pub fn suffix(mut self, input: impl Into<std::string::String>) -> Self {
            self.suffix = Some(input.into());
            self
        }
        /// <p>Determines the suffix value of the percentage format.</p>
        pub fn set_suffix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.suffix = input;
            self
        }
        /// <p>The options that determine the numeric separator configuration.</p>
        pub fn separator_configuration(
            mut self,
            input: crate::model::NumericSeparatorConfiguration,
        ) -> Self {
            self.separator_configuration = Some(input);
            self
        }
        /// <p>The options that determine the numeric separator configuration.</p>
        pub fn set_separator_configuration(
            mut self,
            input: std::option::Option<crate::model::NumericSeparatorConfiguration>,
        ) -> Self {
            self.separator_configuration = input;
            self
        }
        /// <p>The option that determines the decimal places configuration.</p>
        pub fn decimal_places_configuration(
            mut self,
            input: crate::model::DecimalPlacesConfiguration,
        ) -> Self {
            self.decimal_places_configuration = Some(input);
            self
        }
        /// <p>The option that determines the decimal places configuration.</p>
        pub fn set_decimal_places_configuration(
            mut self,
            input: std::option::Option<crate::model::DecimalPlacesConfiguration>,
        ) -> Self {
            self.decimal_places_configuration = input;
            self
        }
        /// <p>The options that determine the negative value configuration.</p>
        pub fn negative_value_configuration(
            mut self,
            input: crate::model::NegativeValueConfiguration,
        ) -> Self {
            self.negative_value_configuration = Some(input);
            self
        }
        /// <p>The options that determine the negative value configuration.</p>
        pub fn set_negative_value_configuration(
            mut self,
            input: std::option::Option<crate::model::NegativeValueConfiguration>,
        ) -> Self {
            self.negative_value_configuration = input;
            self
        }
        /// <p>The options that determine the null value format configuration.</p>
        pub fn null_value_format_configuration(
            mut self,
            input: crate::model::NullValueFormatConfiguration,
        ) -> Self {
            self.null_value_format_configuration = Some(input);
            self
        }
        /// <p>The options that determine the null value format configuration.</p>
        pub fn set_null_value_format_configuration(
            mut self,
            input: std::option::Option<crate::model::NullValueFormatConfiguration>,
        ) -> Self {
            self.null_value_format_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PercentageDisplayFormatConfiguration`](crate::model::PercentageDisplayFormatConfiguration).
        pub fn build(self) -> crate::model::PercentageDisplayFormatConfiguration {
            crate::model::PercentageDisplayFormatConfiguration {
                prefix: self.prefix,
                suffix: self.suffix,
                separator_configuration: self.separator_configuration,
                decimal_places_configuration: self.decimal_places_configuration,
                negative_value_configuration: self.negative_value_configuration,
                null_value_format_configuration: self.null_value_format_configuration,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("prefix", &"*** Sensitive Data Redacted ***");
            formatter.field("suffix", &"*** Sensitive Data Redacted ***");
            formatter.field("separator_configuration", &self.separator_configuration);
            formatter.field(
                "decimal_places_configuration",
                &self.decimal_places_configuration,
            );
            formatter.field(
                "negative_value_configuration",
                &self.negative_value_configuration,
            );
            formatter.field(
                "null_value_format_configuration",
                &self.null_value_format_configuration,
            );
            formatter.finish()
        }
    }
}
impl PercentageDisplayFormatConfiguration {
    /// Creates a new builder-style object to manufacture [`PercentageDisplayFormatConfiguration`](crate::model::PercentageDisplayFormatConfiguration).
    pub fn builder() -> crate::model::percentage_display_format_configuration::Builder {
        crate::model::percentage_display_format_configuration::Builder::default()
    }
}

/// <p>The options that determine the null value format configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NullValueFormatConfiguration {
    /// <p>Determines the null string of null values.</p>
    #[doc(hidden)]
    pub null_string: std::option::Option<std::string::String>,
}
impl NullValueFormatConfiguration {
    /// <p>Determines the null string of null values.</p>
    pub fn null_string(&self) -> std::option::Option<&str> {
        self.null_string.as_deref()
    }
}
impl std::fmt::Debug for NullValueFormatConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NullValueFormatConfiguration");
        formatter.field("null_string", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`NullValueFormatConfiguration`](crate::model::NullValueFormatConfiguration).
pub mod null_value_format_configuration {

    /// A builder for [`NullValueFormatConfiguration`](crate::model::NullValueFormatConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) null_string: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Determines the null string of null values.</p>
        pub fn null_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.null_string = Some(input.into());
            self
        }
        /// <p>Determines the null string of null values.</p>
        pub fn set_null_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.null_string = input;
            self
        }
        /// Consumes the builder and constructs a [`NullValueFormatConfiguration`](crate::model::NullValueFormatConfiguration).
        pub fn build(self) -> crate::model::NullValueFormatConfiguration {
            crate::model::NullValueFormatConfiguration {
                null_string: self.null_string,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("null_string", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl NullValueFormatConfiguration {
    /// Creates a new builder-style object to manufacture [`NullValueFormatConfiguration`](crate::model::NullValueFormatConfiguration).
    pub fn builder() -> crate::model::null_value_format_configuration::Builder {
        crate::model::null_value_format_configuration::Builder::default()
    }
}

/// <p>The options that determine the negative value configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NegativeValueConfiguration {
    /// <p>Determines the display mode of the negative value configuration.</p>
    #[doc(hidden)]
    pub display_mode: std::option::Option<crate::model::NegativeValueDisplayMode>,
}
impl NegativeValueConfiguration {
    /// <p>Determines the display mode of the negative value configuration.</p>
    pub fn display_mode(&self) -> std::option::Option<&crate::model::NegativeValueDisplayMode> {
        self.display_mode.as_ref()
    }
}
/// See [`NegativeValueConfiguration`](crate::model::NegativeValueConfiguration).
pub mod negative_value_configuration {

    /// A builder for [`NegativeValueConfiguration`](crate::model::NegativeValueConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) display_mode: std::option::Option<crate::model::NegativeValueDisplayMode>,
    }
    impl Builder {
        /// <p>Determines the display mode of the negative value configuration.</p>
        pub fn display_mode(mut self, input: crate::model::NegativeValueDisplayMode) -> Self {
            self.display_mode = Some(input);
            self
        }
        /// <p>Determines the display mode of the negative value configuration.</p>
        pub fn set_display_mode(
            mut self,
            input: std::option::Option<crate::model::NegativeValueDisplayMode>,
        ) -> Self {
            self.display_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`NegativeValueConfiguration`](crate::model::NegativeValueConfiguration).
        pub fn build(self) -> crate::model::NegativeValueConfiguration {
            crate::model::NegativeValueConfiguration {
                display_mode: self.display_mode,
            }
        }
    }
}
impl NegativeValueConfiguration {
    /// Creates a new builder-style object to manufacture [`NegativeValueConfiguration`](crate::model::NegativeValueConfiguration).
    pub fn builder() -> crate::model::negative_value_configuration::Builder {
        crate::model::negative_value_configuration::Builder::default()
    }
}

/// When writing a match expression against `NegativeValueDisplayMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let negativevaluedisplaymode = unimplemented!();
/// match negativevaluedisplaymode {
///     NegativeValueDisplayMode::Negative => { /* ... */ },
///     NegativeValueDisplayMode::Positive => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `negativevaluedisplaymode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NegativeValueDisplayMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NegativeValueDisplayMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NegativeValueDisplayMode::NewFeature` is defined.
/// Specifically, when `negativevaluedisplaymode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NegativeValueDisplayMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NegativeValueDisplayMode {
    #[allow(missing_docs)] // documentation missing in model
    Negative,
    #[allow(missing_docs)] // documentation missing in model
    Positive,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NegativeValueDisplayMode {
    fn from(s: &str) -> Self {
        match s {
            "NEGATIVE" => NegativeValueDisplayMode::Negative,
            "POSITIVE" => NegativeValueDisplayMode::Positive,
            other => NegativeValueDisplayMode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for NegativeValueDisplayMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NegativeValueDisplayMode::from(s))
    }
}
impl NegativeValueDisplayMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NegativeValueDisplayMode::Negative => "NEGATIVE",
            NegativeValueDisplayMode::Positive => "POSITIVE",
            NegativeValueDisplayMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NEGATIVE", "POSITIVE"]
    }
}
impl AsRef<str> for NegativeValueDisplayMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The option that determines the decimal places configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DecimalPlacesConfiguration {
    /// <p>The values of the decimal places.</p>
    #[doc(hidden)]
    pub decimal_places: std::option::Option<i64>,
}
impl DecimalPlacesConfiguration {
    /// <p>The values of the decimal places.</p>
    pub fn decimal_places(&self) -> std::option::Option<i64> {
        self.decimal_places
    }
}
/// See [`DecimalPlacesConfiguration`](crate::model::DecimalPlacesConfiguration).
pub mod decimal_places_configuration {

    /// A builder for [`DecimalPlacesConfiguration`](crate::model::DecimalPlacesConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) decimal_places: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The values of the decimal places.</p>
        pub fn decimal_places(mut self, input: i64) -> Self {
            self.decimal_places = Some(input);
            self
        }
        /// <p>The values of the decimal places.</p>
        pub fn set_decimal_places(mut self, input: std::option::Option<i64>) -> Self {
            self.decimal_places = input;
            self
        }
        /// Consumes the builder and constructs a [`DecimalPlacesConfiguration`](crate::model::DecimalPlacesConfiguration).
        pub fn build(self) -> crate::model::DecimalPlacesConfiguration {
            crate::model::DecimalPlacesConfiguration {
                decimal_places: self.decimal_places,
            }
        }
    }
}
impl DecimalPlacesConfiguration {
    /// Creates a new builder-style object to manufacture [`DecimalPlacesConfiguration`](crate::model::DecimalPlacesConfiguration).
    pub fn builder() -> crate::model::decimal_places_configuration::Builder {
        crate::model::decimal_places_configuration::Builder::default()
    }
}

/// <p>The options that determine the numeric separator configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NumericSeparatorConfiguration {
    /// <p>Determines the decimal separator.</p>
    #[doc(hidden)]
    pub decimal_separator: std::option::Option<crate::model::NumericSeparatorSymbol>,
    /// <p>The options that determine the thousands separator configuration.</p>
    #[doc(hidden)]
    pub thousands_separator: std::option::Option<crate::model::ThousandSeparatorOptions>,
}
impl NumericSeparatorConfiguration {
    /// <p>Determines the decimal separator.</p>
    pub fn decimal_separator(&self) -> std::option::Option<&crate::model::NumericSeparatorSymbol> {
        self.decimal_separator.as_ref()
    }
    /// <p>The options that determine the thousands separator configuration.</p>
    pub fn thousands_separator(
        &self,
    ) -> std::option::Option<&crate::model::ThousandSeparatorOptions> {
        self.thousands_separator.as_ref()
    }
}
/// See [`NumericSeparatorConfiguration`](crate::model::NumericSeparatorConfiguration).
pub mod numeric_separator_configuration {

    /// A builder for [`NumericSeparatorConfiguration`](crate::model::NumericSeparatorConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) decimal_separator: std::option::Option<crate::model::NumericSeparatorSymbol>,
        pub(crate) thousands_separator: std::option::Option<crate::model::ThousandSeparatorOptions>,
    }
    impl Builder {
        /// <p>Determines the decimal separator.</p>
        pub fn decimal_separator(mut self, input: crate::model::NumericSeparatorSymbol) -> Self {
            self.decimal_separator = Some(input);
            self
        }
        /// <p>Determines the decimal separator.</p>
        pub fn set_decimal_separator(
            mut self,
            input: std::option::Option<crate::model::NumericSeparatorSymbol>,
        ) -> Self {
            self.decimal_separator = input;
            self
        }
        /// <p>The options that determine the thousands separator configuration.</p>
        pub fn thousands_separator(
            mut self,
            input: crate::model::ThousandSeparatorOptions,
        ) -> Self {
            self.thousands_separator = Some(input);
            self
        }
        /// <p>The options that determine the thousands separator configuration.</p>
        pub fn set_thousands_separator(
            mut self,
            input: std::option::Option<crate::model::ThousandSeparatorOptions>,
        ) -> Self {
            self.thousands_separator = input;
            self
        }
        /// Consumes the builder and constructs a [`NumericSeparatorConfiguration`](crate::model::NumericSeparatorConfiguration).
        pub fn build(self) -> crate::model::NumericSeparatorConfiguration {
            crate::model::NumericSeparatorConfiguration {
                decimal_separator: self.decimal_separator,
                thousands_separator: self.thousands_separator,
            }
        }
    }
}
impl NumericSeparatorConfiguration {
    /// Creates a new builder-style object to manufacture [`NumericSeparatorConfiguration`](crate::model::NumericSeparatorConfiguration).
    pub fn builder() -> crate::model::numeric_separator_configuration::Builder {
        crate::model::numeric_separator_configuration::Builder::default()
    }
}

/// <p>The options that determine the thousands separator configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThousandSeparatorOptions {
    /// <p>Determines the thousands separator symbol.</p>
    #[doc(hidden)]
    pub symbol: std::option::Option<crate::model::NumericSeparatorSymbol>,
    /// <p>Determines the visibility of the thousands separator.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
}
impl ThousandSeparatorOptions {
    /// <p>Determines the thousands separator symbol.</p>
    pub fn symbol(&self) -> std::option::Option<&crate::model::NumericSeparatorSymbol> {
        self.symbol.as_ref()
    }
    /// <p>Determines the visibility of the thousands separator.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
}
/// See [`ThousandSeparatorOptions`](crate::model::ThousandSeparatorOptions).
pub mod thousand_separator_options {

    /// A builder for [`ThousandSeparatorOptions`](crate::model::ThousandSeparatorOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) symbol: std::option::Option<crate::model::NumericSeparatorSymbol>,
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>Determines the thousands separator symbol.</p>
        pub fn symbol(mut self, input: crate::model::NumericSeparatorSymbol) -> Self {
            self.symbol = Some(input);
            self
        }
        /// <p>Determines the thousands separator symbol.</p>
        pub fn set_symbol(
            mut self,
            input: std::option::Option<crate::model::NumericSeparatorSymbol>,
        ) -> Self {
            self.symbol = input;
            self
        }
        /// <p>Determines the visibility of the thousands separator.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>Determines the visibility of the thousands separator.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`ThousandSeparatorOptions`](crate::model::ThousandSeparatorOptions).
        pub fn build(self) -> crate::model::ThousandSeparatorOptions {
            crate::model::ThousandSeparatorOptions {
                symbol: self.symbol,
                visibility: self.visibility,
            }
        }
    }
}
impl ThousandSeparatorOptions {
    /// Creates a new builder-style object to manufacture [`ThousandSeparatorOptions`](crate::model::ThousandSeparatorOptions).
    pub fn builder() -> crate::model::thousand_separator_options::Builder {
        crate::model::thousand_separator_options::Builder::default()
    }
}

/// When writing a match expression against `Visibility`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let visibility = unimplemented!();
/// match visibility {
///     Visibility::Hidden => { /* ... */ },
///     Visibility::Visible => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `visibility` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Visibility::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Visibility::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Visibility::NewFeature` is defined.
/// Specifically, when `visibility` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Visibility::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Visibility {
    #[allow(missing_docs)] // documentation missing in model
    Hidden,
    #[allow(missing_docs)] // documentation missing in model
    Visible,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Visibility {
    fn from(s: &str) -> Self {
        match s {
            "HIDDEN" => Visibility::Hidden,
            "VISIBLE" => Visibility::Visible,
            other => Visibility::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Visibility {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Visibility::from(s))
    }
}
impl Visibility {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Visibility::Hidden => "HIDDEN",
            Visibility::Visible => "VISIBLE",
            Visibility::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HIDDEN", "VISIBLE"]
    }
}
impl AsRef<str> for Visibility {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `NumericSeparatorSymbol`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let numericseparatorsymbol = unimplemented!();
/// match numericseparatorsymbol {
///     NumericSeparatorSymbol::Comma => { /* ... */ },
///     NumericSeparatorSymbol::Dot => { /* ... */ },
///     NumericSeparatorSymbol::Space => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `numericseparatorsymbol` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NumericSeparatorSymbol::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NumericSeparatorSymbol::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NumericSeparatorSymbol::NewFeature` is defined.
/// Specifically, when `numericseparatorsymbol` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NumericSeparatorSymbol::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NumericSeparatorSymbol {
    #[allow(missing_docs)] // documentation missing in model
    Comma,
    #[allow(missing_docs)] // documentation missing in model
    Dot,
    #[allow(missing_docs)] // documentation missing in model
    Space,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NumericSeparatorSymbol {
    fn from(s: &str) -> Self {
        match s {
            "COMMA" => NumericSeparatorSymbol::Comma,
            "DOT" => NumericSeparatorSymbol::Dot,
            "SPACE" => NumericSeparatorSymbol::Space,
            other => {
                NumericSeparatorSymbol::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for NumericSeparatorSymbol {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NumericSeparatorSymbol::from(s))
    }
}
impl NumericSeparatorSymbol {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NumericSeparatorSymbol::Comma => "COMMA",
            NumericSeparatorSymbol::Dot => "DOT",
            NumericSeparatorSymbol::Space => "SPACE",
            NumericSeparatorSymbol::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COMMA", "DOT", "SPACE"]
    }
}
impl AsRef<str> for NumericSeparatorSymbol {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The options that determine the currency display format configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CurrencyDisplayFormatConfiguration {
    /// <p>Determines the prefix value of the currency format.</p>
    #[doc(hidden)]
    pub prefix: std::option::Option<std::string::String>,
    /// <p>Determines the suffix value of the currency format.</p>
    #[doc(hidden)]
    pub suffix: std::option::Option<std::string::String>,
    /// <p>The options that determine the numeric separator configuration.</p>
    #[doc(hidden)]
    pub separator_configuration: std::option::Option<crate::model::NumericSeparatorConfiguration>,
    /// <p>Determines the symbol for the currency format.</p>
    #[doc(hidden)]
    pub symbol: std::option::Option<std::string::String>,
    /// <p>The option that determines the decimal places configuration.</p>
    #[doc(hidden)]
    pub decimal_places_configuration: std::option::Option<crate::model::DecimalPlacesConfiguration>,
    /// <p>Determines the number scale value for the currency format.</p>
    #[doc(hidden)]
    pub number_scale: std::option::Option<crate::model::NumberScale>,
    /// <p>The options that determine the negative value configuration.</p>
    #[doc(hidden)]
    pub negative_value_configuration: std::option::Option<crate::model::NegativeValueConfiguration>,
    /// <p>The options that determine the null value format configuration.</p>
    #[doc(hidden)]
    pub null_value_format_configuration:
        std::option::Option<crate::model::NullValueFormatConfiguration>,
}
impl CurrencyDisplayFormatConfiguration {
    /// <p>Determines the prefix value of the currency format.</p>
    pub fn prefix(&self) -> std::option::Option<&str> {
        self.prefix.as_deref()
    }
    /// <p>Determines the suffix value of the currency format.</p>
    pub fn suffix(&self) -> std::option::Option<&str> {
        self.suffix.as_deref()
    }
    /// <p>The options that determine the numeric separator configuration.</p>
    pub fn separator_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NumericSeparatorConfiguration> {
        self.separator_configuration.as_ref()
    }
    /// <p>Determines the symbol for the currency format.</p>
    pub fn symbol(&self) -> std::option::Option<&str> {
        self.symbol.as_deref()
    }
    /// <p>The option that determines the decimal places configuration.</p>
    pub fn decimal_places_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DecimalPlacesConfiguration> {
        self.decimal_places_configuration.as_ref()
    }
    /// <p>Determines the number scale value for the currency format.</p>
    pub fn number_scale(&self) -> std::option::Option<&crate::model::NumberScale> {
        self.number_scale.as_ref()
    }
    /// <p>The options that determine the negative value configuration.</p>
    pub fn negative_value_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NegativeValueConfiguration> {
        self.negative_value_configuration.as_ref()
    }
    /// <p>The options that determine the null value format configuration.</p>
    pub fn null_value_format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NullValueFormatConfiguration> {
        self.null_value_format_configuration.as_ref()
    }
}
impl std::fmt::Debug for CurrencyDisplayFormatConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CurrencyDisplayFormatConfiguration");
        formatter.field("prefix", &"*** Sensitive Data Redacted ***");
        formatter.field("suffix", &"*** Sensitive Data Redacted ***");
        formatter.field("separator_configuration", &self.separator_configuration);
        formatter.field("symbol", &self.symbol);
        formatter.field(
            "decimal_places_configuration",
            &self.decimal_places_configuration,
        );
        formatter.field("number_scale", &self.number_scale);
        formatter.field(
            "negative_value_configuration",
            &self.negative_value_configuration,
        );
        formatter.field(
            "null_value_format_configuration",
            &self.null_value_format_configuration,
        );
        formatter.finish()
    }
}
/// See [`CurrencyDisplayFormatConfiguration`](crate::model::CurrencyDisplayFormatConfiguration).
pub mod currency_display_format_configuration {

    /// A builder for [`CurrencyDisplayFormatConfiguration`](crate::model::CurrencyDisplayFormatConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) prefix: std::option::Option<std::string::String>,
        pub(crate) suffix: std::option::Option<std::string::String>,
        pub(crate) separator_configuration:
            std::option::Option<crate::model::NumericSeparatorConfiguration>,
        pub(crate) symbol: std::option::Option<std::string::String>,
        pub(crate) decimal_places_configuration:
            std::option::Option<crate::model::DecimalPlacesConfiguration>,
        pub(crate) number_scale: std::option::Option<crate::model::NumberScale>,
        pub(crate) negative_value_configuration:
            std::option::Option<crate::model::NegativeValueConfiguration>,
        pub(crate) null_value_format_configuration:
            std::option::Option<crate::model::NullValueFormatConfiguration>,
    }
    impl Builder {
        /// <p>Determines the prefix value of the currency format.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        /// <p>Determines the prefix value of the currency format.</p>
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// <p>Determines the suffix value of the currency format.</p>
        pub fn suffix(mut self, input: impl Into<std::string::String>) -> Self {
            self.suffix = Some(input.into());
            self
        }
        /// <p>Determines the suffix value of the currency format.</p>
        pub fn set_suffix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.suffix = input;
            self
        }
        /// <p>The options that determine the numeric separator configuration.</p>
        pub fn separator_configuration(
            mut self,
            input: crate::model::NumericSeparatorConfiguration,
        ) -> Self {
            self.separator_configuration = Some(input);
            self
        }
        /// <p>The options that determine the numeric separator configuration.</p>
        pub fn set_separator_configuration(
            mut self,
            input: std::option::Option<crate::model::NumericSeparatorConfiguration>,
        ) -> Self {
            self.separator_configuration = input;
            self
        }
        /// <p>Determines the symbol for the currency format.</p>
        pub fn symbol(mut self, input: impl Into<std::string::String>) -> Self {
            self.symbol = Some(input.into());
            self
        }
        /// <p>Determines the symbol for the currency format.</p>
        pub fn set_symbol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.symbol = input;
            self
        }
        /// <p>The option that determines the decimal places configuration.</p>
        pub fn decimal_places_configuration(
            mut self,
            input: crate::model::DecimalPlacesConfiguration,
        ) -> Self {
            self.decimal_places_configuration = Some(input);
            self
        }
        /// <p>The option that determines the decimal places configuration.</p>
        pub fn set_decimal_places_configuration(
            mut self,
            input: std::option::Option<crate::model::DecimalPlacesConfiguration>,
        ) -> Self {
            self.decimal_places_configuration = input;
            self
        }
        /// <p>Determines the number scale value for the currency format.</p>
        pub fn number_scale(mut self, input: crate::model::NumberScale) -> Self {
            self.number_scale = Some(input);
            self
        }
        /// <p>Determines the number scale value for the currency format.</p>
        pub fn set_number_scale(
            mut self,
            input: std::option::Option<crate::model::NumberScale>,
        ) -> Self {
            self.number_scale = input;
            self
        }
        /// <p>The options that determine the negative value configuration.</p>
        pub fn negative_value_configuration(
            mut self,
            input: crate::model::NegativeValueConfiguration,
        ) -> Self {
            self.negative_value_configuration = Some(input);
            self
        }
        /// <p>The options that determine the negative value configuration.</p>
        pub fn set_negative_value_configuration(
            mut self,
            input: std::option::Option<crate::model::NegativeValueConfiguration>,
        ) -> Self {
            self.negative_value_configuration = input;
            self
        }
        /// <p>The options that determine the null value format configuration.</p>
        pub fn null_value_format_configuration(
            mut self,
            input: crate::model::NullValueFormatConfiguration,
        ) -> Self {
            self.null_value_format_configuration = Some(input);
            self
        }
        /// <p>The options that determine the null value format configuration.</p>
        pub fn set_null_value_format_configuration(
            mut self,
            input: std::option::Option<crate::model::NullValueFormatConfiguration>,
        ) -> Self {
            self.null_value_format_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`CurrencyDisplayFormatConfiguration`](crate::model::CurrencyDisplayFormatConfiguration).
        pub fn build(self) -> crate::model::CurrencyDisplayFormatConfiguration {
            crate::model::CurrencyDisplayFormatConfiguration {
                prefix: self.prefix,
                suffix: self.suffix,
                separator_configuration: self.separator_configuration,
                symbol: self.symbol,
                decimal_places_configuration: self.decimal_places_configuration,
                number_scale: self.number_scale,
                negative_value_configuration: self.negative_value_configuration,
                null_value_format_configuration: self.null_value_format_configuration,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("prefix", &"*** Sensitive Data Redacted ***");
            formatter.field("suffix", &"*** Sensitive Data Redacted ***");
            formatter.field("separator_configuration", &self.separator_configuration);
            formatter.field("symbol", &self.symbol);
            formatter.field(
                "decimal_places_configuration",
                &self.decimal_places_configuration,
            );
            formatter.field("number_scale", &self.number_scale);
            formatter.field(
                "negative_value_configuration",
                &self.negative_value_configuration,
            );
            formatter.field(
                "null_value_format_configuration",
                &self.null_value_format_configuration,
            );
            formatter.finish()
        }
    }
}
impl CurrencyDisplayFormatConfiguration {
    /// Creates a new builder-style object to manufacture [`CurrencyDisplayFormatConfiguration`](crate::model::CurrencyDisplayFormatConfiguration).
    pub fn builder() -> crate::model::currency_display_format_configuration::Builder {
        crate::model::currency_display_format_configuration::Builder::default()
    }
}

/// When writing a match expression against `NumberScale`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let numberscale = unimplemented!();
/// match numberscale {
///     NumberScale::Auto => { /* ... */ },
///     NumberScale::Billions => { /* ... */ },
///     NumberScale::Millions => { /* ... */ },
///     NumberScale::None => { /* ... */ },
///     NumberScale::Thousands => { /* ... */ },
///     NumberScale::Trillions => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `numberscale` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NumberScale::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NumberScale::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NumberScale::NewFeature` is defined.
/// Specifically, when `numberscale` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NumberScale::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NumberScale {
    #[allow(missing_docs)] // documentation missing in model
    Auto,
    #[allow(missing_docs)] // documentation missing in model
    Billions,
    #[allow(missing_docs)] // documentation missing in model
    Millions,
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Thousands,
    #[allow(missing_docs)] // documentation missing in model
    Trillions,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NumberScale {
    fn from(s: &str) -> Self {
        match s {
            "AUTO" => NumberScale::Auto,
            "BILLIONS" => NumberScale::Billions,
            "MILLIONS" => NumberScale::Millions,
            "NONE" => NumberScale::None,
            "THOUSANDS" => NumberScale::Thousands,
            "TRILLIONS" => NumberScale::Trillions,
            other => NumberScale::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for NumberScale {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NumberScale::from(s))
    }
}
impl NumberScale {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NumberScale::Auto => "AUTO",
            NumberScale::Billions => "BILLIONS",
            NumberScale::Millions => "MILLIONS",
            NumberScale::None => "NONE",
            NumberScale::Thousands => "THOUSANDS",
            NumberScale::Trillions => "TRILLIONS",
            NumberScale::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AUTO",
            "BILLIONS",
            "MILLIONS",
            "NONE",
            "THOUSANDS",
            "TRILLIONS",
        ]
    }
}
impl AsRef<str> for NumberScale {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The options that determine the number display format configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NumberDisplayFormatConfiguration {
    /// <p>Determines the prefix value of the number format.</p>
    #[doc(hidden)]
    pub prefix: std::option::Option<std::string::String>,
    /// <p>Determines the suffix value of the number format.</p>
    #[doc(hidden)]
    pub suffix: std::option::Option<std::string::String>,
    /// <p>The options that determine the numeric separator configuration.</p>
    #[doc(hidden)]
    pub separator_configuration: std::option::Option<crate::model::NumericSeparatorConfiguration>,
    /// <p>The option that determines the decimal places configuration.</p>
    #[doc(hidden)]
    pub decimal_places_configuration: std::option::Option<crate::model::DecimalPlacesConfiguration>,
    /// <p>Determines the number scale value of the number format.</p>
    #[doc(hidden)]
    pub number_scale: std::option::Option<crate::model::NumberScale>,
    /// <p>The options that determine the negative value configuration.</p>
    #[doc(hidden)]
    pub negative_value_configuration: std::option::Option<crate::model::NegativeValueConfiguration>,
    /// <p>The options that determine the null value format configuration.</p>
    #[doc(hidden)]
    pub null_value_format_configuration:
        std::option::Option<crate::model::NullValueFormatConfiguration>,
}
impl NumberDisplayFormatConfiguration {
    /// <p>Determines the prefix value of the number format.</p>
    pub fn prefix(&self) -> std::option::Option<&str> {
        self.prefix.as_deref()
    }
    /// <p>Determines the suffix value of the number format.</p>
    pub fn suffix(&self) -> std::option::Option<&str> {
        self.suffix.as_deref()
    }
    /// <p>The options that determine the numeric separator configuration.</p>
    pub fn separator_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NumericSeparatorConfiguration> {
        self.separator_configuration.as_ref()
    }
    /// <p>The option that determines the decimal places configuration.</p>
    pub fn decimal_places_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DecimalPlacesConfiguration> {
        self.decimal_places_configuration.as_ref()
    }
    /// <p>Determines the number scale value of the number format.</p>
    pub fn number_scale(&self) -> std::option::Option<&crate::model::NumberScale> {
        self.number_scale.as_ref()
    }
    /// <p>The options that determine the negative value configuration.</p>
    pub fn negative_value_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NegativeValueConfiguration> {
        self.negative_value_configuration.as_ref()
    }
    /// <p>The options that determine the null value format configuration.</p>
    pub fn null_value_format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NullValueFormatConfiguration> {
        self.null_value_format_configuration.as_ref()
    }
}
impl std::fmt::Debug for NumberDisplayFormatConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NumberDisplayFormatConfiguration");
        formatter.field("prefix", &"*** Sensitive Data Redacted ***");
        formatter.field("suffix", &"*** Sensitive Data Redacted ***");
        formatter.field("separator_configuration", &self.separator_configuration);
        formatter.field(
            "decimal_places_configuration",
            &self.decimal_places_configuration,
        );
        formatter.field("number_scale", &self.number_scale);
        formatter.field(
            "negative_value_configuration",
            &self.negative_value_configuration,
        );
        formatter.field(
            "null_value_format_configuration",
            &self.null_value_format_configuration,
        );
        formatter.finish()
    }
}
/// See [`NumberDisplayFormatConfiguration`](crate::model::NumberDisplayFormatConfiguration).
pub mod number_display_format_configuration {

    /// A builder for [`NumberDisplayFormatConfiguration`](crate::model::NumberDisplayFormatConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) prefix: std::option::Option<std::string::String>,
        pub(crate) suffix: std::option::Option<std::string::String>,
        pub(crate) separator_configuration:
            std::option::Option<crate::model::NumericSeparatorConfiguration>,
        pub(crate) decimal_places_configuration:
            std::option::Option<crate::model::DecimalPlacesConfiguration>,
        pub(crate) number_scale: std::option::Option<crate::model::NumberScale>,
        pub(crate) negative_value_configuration:
            std::option::Option<crate::model::NegativeValueConfiguration>,
        pub(crate) null_value_format_configuration:
            std::option::Option<crate::model::NullValueFormatConfiguration>,
    }
    impl Builder {
        /// <p>Determines the prefix value of the number format.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        /// <p>Determines the prefix value of the number format.</p>
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// <p>Determines the suffix value of the number format.</p>
        pub fn suffix(mut self, input: impl Into<std::string::String>) -> Self {
            self.suffix = Some(input.into());
            self
        }
        /// <p>Determines the suffix value of the number format.</p>
        pub fn set_suffix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.suffix = input;
            self
        }
        /// <p>The options that determine the numeric separator configuration.</p>
        pub fn separator_configuration(
            mut self,
            input: crate::model::NumericSeparatorConfiguration,
        ) -> Self {
            self.separator_configuration = Some(input);
            self
        }
        /// <p>The options that determine the numeric separator configuration.</p>
        pub fn set_separator_configuration(
            mut self,
            input: std::option::Option<crate::model::NumericSeparatorConfiguration>,
        ) -> Self {
            self.separator_configuration = input;
            self
        }
        /// <p>The option that determines the decimal places configuration.</p>
        pub fn decimal_places_configuration(
            mut self,
            input: crate::model::DecimalPlacesConfiguration,
        ) -> Self {
            self.decimal_places_configuration = Some(input);
            self
        }
        /// <p>The option that determines the decimal places configuration.</p>
        pub fn set_decimal_places_configuration(
            mut self,
            input: std::option::Option<crate::model::DecimalPlacesConfiguration>,
        ) -> Self {
            self.decimal_places_configuration = input;
            self
        }
        /// <p>Determines the number scale value of the number format.</p>
        pub fn number_scale(mut self, input: crate::model::NumberScale) -> Self {
            self.number_scale = Some(input);
            self
        }
        /// <p>Determines the number scale value of the number format.</p>
        pub fn set_number_scale(
            mut self,
            input: std::option::Option<crate::model::NumberScale>,
        ) -> Self {
            self.number_scale = input;
            self
        }
        /// <p>The options that determine the negative value configuration.</p>
        pub fn negative_value_configuration(
            mut self,
            input: crate::model::NegativeValueConfiguration,
        ) -> Self {
            self.negative_value_configuration = Some(input);
            self
        }
        /// <p>The options that determine the negative value configuration.</p>
        pub fn set_negative_value_configuration(
            mut self,
            input: std::option::Option<crate::model::NegativeValueConfiguration>,
        ) -> Self {
            self.negative_value_configuration = input;
            self
        }
        /// <p>The options that determine the null value format configuration.</p>
        pub fn null_value_format_configuration(
            mut self,
            input: crate::model::NullValueFormatConfiguration,
        ) -> Self {
            self.null_value_format_configuration = Some(input);
            self
        }
        /// <p>The options that determine the null value format configuration.</p>
        pub fn set_null_value_format_configuration(
            mut self,
            input: std::option::Option<crate::model::NullValueFormatConfiguration>,
        ) -> Self {
            self.null_value_format_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`NumberDisplayFormatConfiguration`](crate::model::NumberDisplayFormatConfiguration).
        pub fn build(self) -> crate::model::NumberDisplayFormatConfiguration {
            crate::model::NumberDisplayFormatConfiguration {
                prefix: self.prefix,
                suffix: self.suffix,
                separator_configuration: self.separator_configuration,
                decimal_places_configuration: self.decimal_places_configuration,
                number_scale: self.number_scale,
                negative_value_configuration: self.negative_value_configuration,
                null_value_format_configuration: self.null_value_format_configuration,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("prefix", &"*** Sensitive Data Redacted ***");
            formatter.field("suffix", &"*** Sensitive Data Redacted ***");
            formatter.field("separator_configuration", &self.separator_configuration);
            formatter.field(
                "decimal_places_configuration",
                &self.decimal_places_configuration,
            );
            formatter.field("number_scale", &self.number_scale);
            formatter.field(
                "negative_value_configuration",
                &self.negative_value_configuration,
            );
            formatter.field(
                "null_value_format_configuration",
                &self.null_value_format_configuration,
            );
            formatter.finish()
        }
    }
}
impl NumberDisplayFormatConfiguration {
    /// Creates a new builder-style object to manufacture [`NumberDisplayFormatConfiguration`](crate::model::NumberDisplayFormatConfiguration).
    pub fn builder() -> crate::model::number_display_format_configuration::Builder {
        crate::model::number_display_format_configuration::Builder::default()
    }
}

/// <p>Formatting configuration for number fields.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NumberFormatConfiguration {
    /// <p>The options that determine the numeric format configuration.</p>
    #[doc(hidden)]
    pub format_configuration: std::option::Option<crate::model::NumericFormatConfiguration>,
}
impl NumberFormatConfiguration {
    /// <p>The options that determine the numeric format configuration.</p>
    pub fn format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NumericFormatConfiguration> {
        self.format_configuration.as_ref()
    }
}
/// See [`NumberFormatConfiguration`](crate::model::NumberFormatConfiguration).
pub mod number_format_configuration {

    /// A builder for [`NumberFormatConfiguration`](crate::model::NumberFormatConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) format_configuration:
            std::option::Option<crate::model::NumericFormatConfiguration>,
    }
    impl Builder {
        /// <p>The options that determine the numeric format configuration.</p>
        pub fn format_configuration(
            mut self,
            input: crate::model::NumericFormatConfiguration,
        ) -> Self {
            self.format_configuration = Some(input);
            self
        }
        /// <p>The options that determine the numeric format configuration.</p>
        pub fn set_format_configuration(
            mut self,
            input: std::option::Option<crate::model::NumericFormatConfiguration>,
        ) -> Self {
            self.format_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`NumberFormatConfiguration`](crate::model::NumberFormatConfiguration).
        pub fn build(self) -> crate::model::NumberFormatConfiguration {
            crate::model::NumberFormatConfiguration {
                format_configuration: self.format_configuration,
            }
        }
    }
}
impl NumberFormatConfiguration {
    /// Creates a new builder-style object to manufacture [`NumberFormatConfiguration`](crate::model::NumberFormatConfiguration).
    pub fn builder() -> crate::model::number_format_configuration::Builder {
        crate::model::number_format_configuration::Builder::default()
    }
}

/// <p>Formatting configuration for string fields.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StringFormatConfiguration {
    /// <p>The options that determine the null value format configuration.</p>
    #[doc(hidden)]
    pub null_value_format_configuration:
        std::option::Option<crate::model::NullValueFormatConfiguration>,
    /// <p>The formatting configuration for numeric strings.</p>
    #[doc(hidden)]
    pub numeric_format_configuration: std::option::Option<crate::model::NumericFormatConfiguration>,
}
impl StringFormatConfiguration {
    /// <p>The options that determine the null value format configuration.</p>
    pub fn null_value_format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NullValueFormatConfiguration> {
        self.null_value_format_configuration.as_ref()
    }
    /// <p>The formatting configuration for numeric strings.</p>
    pub fn numeric_format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NumericFormatConfiguration> {
        self.numeric_format_configuration.as_ref()
    }
}
/// See [`StringFormatConfiguration`](crate::model::StringFormatConfiguration).
pub mod string_format_configuration {

    /// A builder for [`StringFormatConfiguration`](crate::model::StringFormatConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) null_value_format_configuration:
            std::option::Option<crate::model::NullValueFormatConfiguration>,
        pub(crate) numeric_format_configuration:
            std::option::Option<crate::model::NumericFormatConfiguration>,
    }
    impl Builder {
        /// <p>The options that determine the null value format configuration.</p>
        pub fn null_value_format_configuration(
            mut self,
            input: crate::model::NullValueFormatConfiguration,
        ) -> Self {
            self.null_value_format_configuration = Some(input);
            self
        }
        /// <p>The options that determine the null value format configuration.</p>
        pub fn set_null_value_format_configuration(
            mut self,
            input: std::option::Option<crate::model::NullValueFormatConfiguration>,
        ) -> Self {
            self.null_value_format_configuration = input;
            self
        }
        /// <p>The formatting configuration for numeric strings.</p>
        pub fn numeric_format_configuration(
            mut self,
            input: crate::model::NumericFormatConfiguration,
        ) -> Self {
            self.numeric_format_configuration = Some(input);
            self
        }
        /// <p>The formatting configuration for numeric strings.</p>
        pub fn set_numeric_format_configuration(
            mut self,
            input: std::option::Option<crate::model::NumericFormatConfiguration>,
        ) -> Self {
            self.numeric_format_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`StringFormatConfiguration`](crate::model::StringFormatConfiguration).
        pub fn build(self) -> crate::model::StringFormatConfiguration {
            crate::model::StringFormatConfiguration {
                null_value_format_configuration: self.null_value_format_configuration,
                numeric_format_configuration: self.numeric_format_configuration,
            }
        }
    }
}
impl StringFormatConfiguration {
    /// Creates a new builder-style object to manufacture [`StringFormatConfiguration`](crate::model::StringFormatConfiguration).
    pub fn builder() -> crate::model::string_format_configuration::Builder {
        crate::model::string_format_configuration::Builder::default()
    }
}

/// <p>A column of a data set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnIdentifier {
    /// <p>The data set that the column belongs to.</p>
    #[doc(hidden)]
    pub data_set_identifier: std::option::Option<std::string::String>,
    /// <p>The name of the column.</p>
    #[doc(hidden)]
    pub column_name: std::option::Option<std::string::String>,
}
impl ColumnIdentifier {
    /// <p>The data set that the column belongs to.</p>
    pub fn data_set_identifier(&self) -> std::option::Option<&str> {
        self.data_set_identifier.as_deref()
    }
    /// <p>The name of the column.</p>
    pub fn column_name(&self) -> std::option::Option<&str> {
        self.column_name.as_deref()
    }
}
/// See [`ColumnIdentifier`](crate::model::ColumnIdentifier).
pub mod column_identifier {

    /// A builder for [`ColumnIdentifier`](crate::model::ColumnIdentifier).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_set_identifier: std::option::Option<std::string::String>,
        pub(crate) column_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The data set that the column belongs to.</p>
        pub fn data_set_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_set_identifier = Some(input.into());
            self
        }
        /// <p>The data set that the column belongs to.</p>
        pub fn set_data_set_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_set_identifier = input;
            self
        }
        /// <p>The name of the column.</p>
        pub fn column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.column_name = Some(input.into());
            self
        }
        /// <p>The name of the column.</p>
        pub fn set_column_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.column_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnIdentifier`](crate::model::ColumnIdentifier).
        pub fn build(self) -> crate::model::ColumnIdentifier {
            crate::model::ColumnIdentifier {
                data_set_identifier: self.data_set_identifier,
                column_name: self.column_name,
            }
        }
    }
}
impl ColumnIdentifier {
    /// Creates a new builder-style object to manufacture [`ColumnIdentifier`](crate::model::ColumnIdentifier).
    pub fn builder() -> crate::model::column_identifier::Builder {
        crate::model::column_identifier::Builder::default()
    }
}

/// <p>A grouping of individual filters. Filter groups are applied to the same group of visuals.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/add-a-compound-filter.html">Adding filter conditions (group filters) with AND and OR operators</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterGroup {
    /// <p>The value that uniquely identifies a <code>FilterGroup</code> within a dashboard, template, or analysis.</p>
    #[doc(hidden)]
    pub filter_group_id: std::option::Option<std::string::String>,
    /// <p>The list of filters that are present in a <code>FilterGroup</code>.</p>
    #[doc(hidden)]
    pub filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
    /// <p>The configuration that specifies what scope to apply to a <code>FilterGroup</code>.</p>
    /// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
    #[doc(hidden)]
    pub scope_configuration: std::option::Option<crate::model::FilterScopeConfiguration>,
    /// <p>The status of the <code>FilterGroup</code>.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::WidgetStatus>,
    /// <p>The filter new feature which can apply filter group to all data sets. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>ALL_DATASETS</code> </p> </li>
    /// <li> <p> <code>SINGLE_DATASET</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub cross_dataset: std::option::Option<crate::model::CrossDatasetTypes>,
}
impl FilterGroup {
    /// <p>The value that uniquely identifies a <code>FilterGroup</code> within a dashboard, template, or analysis.</p>
    pub fn filter_group_id(&self) -> std::option::Option<&str> {
        self.filter_group_id.as_deref()
    }
    /// <p>The list of filters that are present in a <code>FilterGroup</code>.</p>
    pub fn filters(&self) -> std::option::Option<&[crate::model::Filter]> {
        self.filters.as_deref()
    }
    /// <p>The configuration that specifies what scope to apply to a <code>FilterGroup</code>.</p>
    /// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
    pub fn scope_configuration(
        &self,
    ) -> std::option::Option<&crate::model::FilterScopeConfiguration> {
        self.scope_configuration.as_ref()
    }
    /// <p>The status of the <code>FilterGroup</code>.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::WidgetStatus> {
        self.status.as_ref()
    }
    /// <p>The filter new feature which can apply filter group to all data sets. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>ALL_DATASETS</code> </p> </li>
    /// <li> <p> <code>SINGLE_DATASET</code> </p> </li>
    /// </ul>
    pub fn cross_dataset(&self) -> std::option::Option<&crate::model::CrossDatasetTypes> {
        self.cross_dataset.as_ref()
    }
}
/// See [`FilterGroup`](crate::model::FilterGroup).
pub mod filter_group {

    /// A builder for [`FilterGroup`](crate::model::FilterGroup).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_group_id: std::option::Option<std::string::String>,
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        pub(crate) scope_configuration: std::option::Option<crate::model::FilterScopeConfiguration>,
        pub(crate) status: std::option::Option<crate::model::WidgetStatus>,
        pub(crate) cross_dataset: std::option::Option<crate::model::CrossDatasetTypes>,
    }
    impl Builder {
        /// <p>The value that uniquely identifies a <code>FilterGroup</code> within a dashboard, template, or analysis.</p>
        pub fn filter_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_group_id = Some(input.into());
            self
        }
        /// <p>The value that uniquely identifies a <code>FilterGroup</code> within a dashboard, template, or analysis.</p>
        pub fn set_filter_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filter_group_id = input;
            self
        }
        /// Appends an item to `filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        ///
        /// <p>The list of filters that are present in a <code>FilterGroup</code>.</p>
        pub fn filters(mut self, input: crate::model::Filter) -> Self {
            let mut v = self.filters.unwrap_or_default();
            v.push(input);
            self.filters = Some(v);
            self
        }
        /// <p>The list of filters that are present in a <code>FilterGroup</code>.</p>
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// <p>The configuration that specifies what scope to apply to a <code>FilterGroup</code>.</p>
        /// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
        pub fn scope_configuration(
            mut self,
            input: crate::model::FilterScopeConfiguration,
        ) -> Self {
            self.scope_configuration = Some(input);
            self
        }
        /// <p>The configuration that specifies what scope to apply to a <code>FilterGroup</code>.</p>
        /// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
        pub fn set_scope_configuration(
            mut self,
            input: std::option::Option<crate::model::FilterScopeConfiguration>,
        ) -> Self {
            self.scope_configuration = input;
            self
        }
        /// <p>The status of the <code>FilterGroup</code>.</p>
        pub fn status(mut self, input: crate::model::WidgetStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the <code>FilterGroup</code>.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::WidgetStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The filter new feature which can apply filter group to all data sets. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>ALL_DATASETS</code> </p> </li>
        /// <li> <p> <code>SINGLE_DATASET</code> </p> </li>
        /// </ul>
        pub fn cross_dataset(mut self, input: crate::model::CrossDatasetTypes) -> Self {
            self.cross_dataset = Some(input);
            self
        }
        /// <p>The filter new feature which can apply filter group to all data sets. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>ALL_DATASETS</code> </p> </li>
        /// <li> <p> <code>SINGLE_DATASET</code> </p> </li>
        /// </ul>
        pub fn set_cross_dataset(
            mut self,
            input: std::option::Option<crate::model::CrossDatasetTypes>,
        ) -> Self {
            self.cross_dataset = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterGroup`](crate::model::FilterGroup).
        pub fn build(self) -> crate::model::FilterGroup {
            crate::model::FilterGroup {
                filter_group_id: self.filter_group_id,
                filters: self.filters,
                scope_configuration: self.scope_configuration,
                status: self.status,
                cross_dataset: self.cross_dataset,
            }
        }
    }
}
impl FilterGroup {
    /// Creates a new builder-style object to manufacture [`FilterGroup`](crate::model::FilterGroup).
    pub fn builder() -> crate::model::filter_group::Builder {
        crate::model::filter_group::Builder::default()
    }
}

/// When writing a match expression against `CrossDatasetTypes`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let crossdatasettypes = unimplemented!();
/// match crossdatasettypes {
///     CrossDatasetTypes::AllDatasets => { /* ... */ },
///     CrossDatasetTypes::SingleDataset => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `crossdatasettypes` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CrossDatasetTypes::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CrossDatasetTypes::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CrossDatasetTypes::NewFeature` is defined.
/// Specifically, when `crossdatasettypes` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CrossDatasetTypes::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CrossDatasetTypes {
    #[allow(missing_docs)] // documentation missing in model
    AllDatasets,
    #[allow(missing_docs)] // documentation missing in model
    SingleDataset,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CrossDatasetTypes {
    fn from(s: &str) -> Self {
        match s {
            "ALL_DATASETS" => CrossDatasetTypes::AllDatasets,
            "SINGLE_DATASET" => CrossDatasetTypes::SingleDataset,
            other => {
                CrossDatasetTypes::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for CrossDatasetTypes {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CrossDatasetTypes::from(s))
    }
}
impl CrossDatasetTypes {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CrossDatasetTypes::AllDatasets => "ALL_DATASETS",
            CrossDatasetTypes::SingleDataset => "SINGLE_DATASET",
            CrossDatasetTypes::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL_DATASETS", "SINGLE_DATASET"]
    }
}
impl AsRef<str> for CrossDatasetTypes {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `WidgetStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let widgetstatus = unimplemented!();
/// match widgetstatus {
///     WidgetStatus::Disabled => { /* ... */ },
///     WidgetStatus::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `widgetstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WidgetStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WidgetStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WidgetStatus::NewFeature` is defined.
/// Specifically, when `widgetstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WidgetStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WidgetStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WidgetStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => WidgetStatus::Disabled,
            "ENABLED" => WidgetStatus::Enabled,
            other => WidgetStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for WidgetStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WidgetStatus::from(s))
    }
}
impl WidgetStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WidgetStatus::Disabled => "DISABLED",
            WidgetStatus::Enabled => "ENABLED",
            WidgetStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for WidgetStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The scope configuration for a <code>FilterGroup</code>.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterScopeConfiguration {
    /// <p>The configuration for applying a filter to specific sheets.</p>
    #[doc(hidden)]
    pub selected_sheets: std::option::Option<crate::model::SelectedSheetsFilterScopeConfiguration>,
}
impl FilterScopeConfiguration {
    /// <p>The configuration for applying a filter to specific sheets.</p>
    pub fn selected_sheets(
        &self,
    ) -> std::option::Option<&crate::model::SelectedSheetsFilterScopeConfiguration> {
        self.selected_sheets.as_ref()
    }
}
/// See [`FilterScopeConfiguration`](crate::model::FilterScopeConfiguration).
pub mod filter_scope_configuration {

    /// A builder for [`FilterScopeConfiguration`](crate::model::FilterScopeConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) selected_sheets:
            std::option::Option<crate::model::SelectedSheetsFilterScopeConfiguration>,
    }
    impl Builder {
        /// <p>The configuration for applying a filter to specific sheets.</p>
        pub fn selected_sheets(
            mut self,
            input: crate::model::SelectedSheetsFilterScopeConfiguration,
        ) -> Self {
            self.selected_sheets = Some(input);
            self
        }
        /// <p>The configuration for applying a filter to specific sheets.</p>
        pub fn set_selected_sheets(
            mut self,
            input: std::option::Option<crate::model::SelectedSheetsFilterScopeConfiguration>,
        ) -> Self {
            self.selected_sheets = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterScopeConfiguration`](crate::model::FilterScopeConfiguration).
        pub fn build(self) -> crate::model::FilterScopeConfiguration {
            crate::model::FilterScopeConfiguration {
                selected_sheets: self.selected_sheets,
            }
        }
    }
}
impl FilterScopeConfiguration {
    /// Creates a new builder-style object to manufacture [`FilterScopeConfiguration`](crate::model::FilterScopeConfiguration).
    pub fn builder() -> crate::model::filter_scope_configuration::Builder {
        crate::model::filter_scope_configuration::Builder::default()
    }
}

/// <p>The configuration for applying a filter to specific sheets or visuals. You can apply this filter to multiple visuals that are on one sheet or to all visuals on a sheet.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SelectedSheetsFilterScopeConfiguration {
    /// <p>The sheet ID and visual IDs of the sheet and visuals that the filter is applied to.</p>
    #[doc(hidden)]
    pub sheet_visual_scoping_configurations:
        std::option::Option<std::vec::Vec<crate::model::SheetVisualScopingConfiguration>>,
}
impl SelectedSheetsFilterScopeConfiguration {
    /// <p>The sheet ID and visual IDs of the sheet and visuals that the filter is applied to.</p>
    pub fn sheet_visual_scoping_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::SheetVisualScopingConfiguration]> {
        self.sheet_visual_scoping_configurations.as_deref()
    }
}
/// See [`SelectedSheetsFilterScopeConfiguration`](crate::model::SelectedSheetsFilterScopeConfiguration).
pub mod selected_sheets_filter_scope_configuration {

    /// A builder for [`SelectedSheetsFilterScopeConfiguration`](crate::model::SelectedSheetsFilterScopeConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sheet_visual_scoping_configurations:
            std::option::Option<std::vec::Vec<crate::model::SheetVisualScopingConfiguration>>,
    }
    impl Builder {
        /// Appends an item to `sheet_visual_scoping_configurations`.
        ///
        /// To override the contents of this collection use [`set_sheet_visual_scoping_configurations`](Self::set_sheet_visual_scoping_configurations).
        ///
        /// <p>The sheet ID and visual IDs of the sheet and visuals that the filter is applied to.</p>
        pub fn sheet_visual_scoping_configurations(
            mut self,
            input: crate::model::SheetVisualScopingConfiguration,
        ) -> Self {
            let mut v = self.sheet_visual_scoping_configurations.unwrap_or_default();
            v.push(input);
            self.sheet_visual_scoping_configurations = Some(v);
            self
        }
        /// <p>The sheet ID and visual IDs of the sheet and visuals that the filter is applied to.</p>
        pub fn set_sheet_visual_scoping_configurations(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::SheetVisualScopingConfiguration>,
            >,
        ) -> Self {
            self.sheet_visual_scoping_configurations = input;
            self
        }
        /// Consumes the builder and constructs a [`SelectedSheetsFilterScopeConfiguration`](crate::model::SelectedSheetsFilterScopeConfiguration).
        pub fn build(self) -> crate::model::SelectedSheetsFilterScopeConfiguration {
            crate::model::SelectedSheetsFilterScopeConfiguration {
                sheet_visual_scoping_configurations: self.sheet_visual_scoping_configurations,
            }
        }
    }
}
impl SelectedSheetsFilterScopeConfiguration {
    /// Creates a new builder-style object to manufacture [`SelectedSheetsFilterScopeConfiguration`](crate::model::SelectedSheetsFilterScopeConfiguration).
    pub fn builder() -> crate::model::selected_sheets_filter_scope_configuration::Builder {
        crate::model::selected_sheets_filter_scope_configuration::Builder::default()
    }
}

/// <p>The filter that is applied to the options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SheetVisualScopingConfiguration {
    /// <p>The selected sheet that the filter is applied to.</p>
    #[doc(hidden)]
    pub sheet_id: std::option::Option<std::string::String>,
    /// <p>The scope of the applied entities. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>ALL_VISUALS</code> </p> </li>
    /// <li> <p> <code>SELECTED_VISUALS</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub scope: std::option::Option<crate::model::FilterVisualScope>,
    /// <p>The selected visuals that the filter is applied to.</p>
    #[doc(hidden)]
    pub visual_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl SheetVisualScopingConfiguration {
    /// <p>The selected sheet that the filter is applied to.</p>
    pub fn sheet_id(&self) -> std::option::Option<&str> {
        self.sheet_id.as_deref()
    }
    /// <p>The scope of the applied entities. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>ALL_VISUALS</code> </p> </li>
    /// <li> <p> <code>SELECTED_VISUALS</code> </p> </li>
    /// </ul>
    pub fn scope(&self) -> std::option::Option<&crate::model::FilterVisualScope> {
        self.scope.as_ref()
    }
    /// <p>The selected visuals that the filter is applied to.</p>
    pub fn visual_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.visual_ids.as_deref()
    }
}
/// See [`SheetVisualScopingConfiguration`](crate::model::SheetVisualScopingConfiguration).
pub mod sheet_visual_scoping_configuration {

    /// A builder for [`SheetVisualScopingConfiguration`](crate::model::SheetVisualScopingConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sheet_id: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::FilterVisualScope>,
        pub(crate) visual_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The selected sheet that the filter is applied to.</p>
        pub fn sheet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sheet_id = Some(input.into());
            self
        }
        /// <p>The selected sheet that the filter is applied to.</p>
        pub fn set_sheet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sheet_id = input;
            self
        }
        /// <p>The scope of the applied entities. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>ALL_VISUALS</code> </p> </li>
        /// <li> <p> <code>SELECTED_VISUALS</code> </p> </li>
        /// </ul>
        pub fn scope(mut self, input: crate::model::FilterVisualScope) -> Self {
            self.scope = Some(input);
            self
        }
        /// <p>The scope of the applied entities. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>ALL_VISUALS</code> </p> </li>
        /// <li> <p> <code>SELECTED_VISUALS</code> </p> </li>
        /// </ul>
        pub fn set_scope(
            mut self,
            input: std::option::Option<crate::model::FilterVisualScope>,
        ) -> Self {
            self.scope = input;
            self
        }
        /// Appends an item to `visual_ids`.
        ///
        /// To override the contents of this collection use [`set_visual_ids`](Self::set_visual_ids).
        ///
        /// <p>The selected visuals that the filter is applied to.</p>
        pub fn visual_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.visual_ids.unwrap_or_default();
            v.push(input.into());
            self.visual_ids = Some(v);
            self
        }
        /// <p>The selected visuals that the filter is applied to.</p>
        pub fn set_visual_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.visual_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`SheetVisualScopingConfiguration`](crate::model::SheetVisualScopingConfiguration).
        pub fn build(self) -> crate::model::SheetVisualScopingConfiguration {
            crate::model::SheetVisualScopingConfiguration {
                sheet_id: self.sheet_id,
                scope: self.scope,
                visual_ids: self.visual_ids,
            }
        }
    }
}
impl SheetVisualScopingConfiguration {
    /// Creates a new builder-style object to manufacture [`SheetVisualScopingConfiguration`](crate::model::SheetVisualScopingConfiguration).
    pub fn builder() -> crate::model::sheet_visual_scoping_configuration::Builder {
        crate::model::sheet_visual_scoping_configuration::Builder::default()
    }
}

/// When writing a match expression against `FilterVisualScope`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let filtervisualscope = unimplemented!();
/// match filtervisualscope {
///     FilterVisualScope::AllVisuals => { /* ... */ },
///     FilterVisualScope::SelectedVisuals => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `filtervisualscope` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FilterVisualScope::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FilterVisualScope::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FilterVisualScope::NewFeature` is defined.
/// Specifically, when `filtervisualscope` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FilterVisualScope::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FilterVisualScope {
    #[allow(missing_docs)] // documentation missing in model
    AllVisuals,
    #[allow(missing_docs)] // documentation missing in model
    SelectedVisuals,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FilterVisualScope {
    fn from(s: &str) -> Self {
        match s {
            "ALL_VISUALS" => FilterVisualScope::AllVisuals,
            "SELECTED_VISUALS" => FilterVisualScope::SelectedVisuals,
            other => {
                FilterVisualScope::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for FilterVisualScope {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FilterVisualScope::from(s))
    }
}
impl FilterVisualScope {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FilterVisualScope::AllVisuals => "ALL_VISUALS",
            FilterVisualScope::SelectedVisuals => "SELECTED_VISUALS",
            FilterVisualScope::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL_VISUALS", "SELECTED_VISUALS"]
    }
}
impl AsRef<str> for FilterVisualScope {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>With a <code>Filter</code>, you can remove portions of data from a particular visual or view.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Filter {
    /// <p>A <code>CategoryFilter</code> filters text values.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/add-a-text-filter-data-prep.html">Adding text filters</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub category_filter: std::option::Option<crate::model::CategoryFilter>,
    /// <p>A <code>NumericRangeFilter</code> filters numeric values that are either inside or outside a given numeric range.</p>
    #[doc(hidden)]
    pub numeric_range_filter: std::option::Option<crate::model::NumericRangeFilter>,
    /// <p>A <code>NumericEqualityFilter</code> filters numeric values that equal or do not equal a given numeric value.</p>
    #[doc(hidden)]
    pub numeric_equality_filter: std::option::Option<crate::model::NumericEqualityFilter>,
    /// <p>A <code>TimeEqualityFilter</code> filters date-time values that equal or do not equal a given date/time value.</p>
    #[doc(hidden)]
    pub time_equality_filter: std::option::Option<crate::model::TimeEqualityFilter>,
    /// <p>A <code>TimeRangeFilter</code> filters date-time values that are either inside or outside a given date/time range.</p>
    #[doc(hidden)]
    pub time_range_filter: std::option::Option<crate::model::TimeRangeFilter>,
    /// <p>A <code>RelativeDatesFilter</code> filters date values that are relative to a given date.</p>
    #[doc(hidden)]
    pub relative_dates_filter: std::option::Option<crate::model::RelativeDatesFilter>,
    /// <p>A <code>TopBottomFilter</code> filters data to the top or bottom values for a given column.</p>
    #[doc(hidden)]
    pub top_bottom_filter: std::option::Option<crate::model::TopBottomFilter>,
}
impl Filter {
    /// <p>A <code>CategoryFilter</code> filters text values.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/add-a-text-filter-data-prep.html">Adding text filters</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn category_filter(&self) -> std::option::Option<&crate::model::CategoryFilter> {
        self.category_filter.as_ref()
    }
    /// <p>A <code>NumericRangeFilter</code> filters numeric values that are either inside or outside a given numeric range.</p>
    pub fn numeric_range_filter(&self) -> std::option::Option<&crate::model::NumericRangeFilter> {
        self.numeric_range_filter.as_ref()
    }
    /// <p>A <code>NumericEqualityFilter</code> filters numeric values that equal or do not equal a given numeric value.</p>
    pub fn numeric_equality_filter(
        &self,
    ) -> std::option::Option<&crate::model::NumericEqualityFilter> {
        self.numeric_equality_filter.as_ref()
    }
    /// <p>A <code>TimeEqualityFilter</code> filters date-time values that equal or do not equal a given date/time value.</p>
    pub fn time_equality_filter(&self) -> std::option::Option<&crate::model::TimeEqualityFilter> {
        self.time_equality_filter.as_ref()
    }
    /// <p>A <code>TimeRangeFilter</code> filters date-time values that are either inside or outside a given date/time range.</p>
    pub fn time_range_filter(&self) -> std::option::Option<&crate::model::TimeRangeFilter> {
        self.time_range_filter.as_ref()
    }
    /// <p>A <code>RelativeDatesFilter</code> filters date values that are relative to a given date.</p>
    pub fn relative_dates_filter(&self) -> std::option::Option<&crate::model::RelativeDatesFilter> {
        self.relative_dates_filter.as_ref()
    }
    /// <p>A <code>TopBottomFilter</code> filters data to the top or bottom values for a given column.</p>
    pub fn top_bottom_filter(&self) -> std::option::Option<&crate::model::TopBottomFilter> {
        self.top_bottom_filter.as_ref()
    }
}
/// See [`Filter`](crate::model::Filter).
pub mod filter {

    /// A builder for [`Filter`](crate::model::Filter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category_filter: std::option::Option<crate::model::CategoryFilter>,
        pub(crate) numeric_range_filter: std::option::Option<crate::model::NumericRangeFilter>,
        pub(crate) numeric_equality_filter:
            std::option::Option<crate::model::NumericEqualityFilter>,
        pub(crate) time_equality_filter: std::option::Option<crate::model::TimeEqualityFilter>,
        pub(crate) time_range_filter: std::option::Option<crate::model::TimeRangeFilter>,
        pub(crate) relative_dates_filter: std::option::Option<crate::model::RelativeDatesFilter>,
        pub(crate) top_bottom_filter: std::option::Option<crate::model::TopBottomFilter>,
    }
    impl Builder {
        /// <p>A <code>CategoryFilter</code> filters text values.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/add-a-text-filter-data-prep.html">Adding text filters</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn category_filter(mut self, input: crate::model::CategoryFilter) -> Self {
            self.category_filter = Some(input);
            self
        }
        /// <p>A <code>CategoryFilter</code> filters text values.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/add-a-text-filter-data-prep.html">Adding text filters</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_category_filter(
            mut self,
            input: std::option::Option<crate::model::CategoryFilter>,
        ) -> Self {
            self.category_filter = input;
            self
        }
        /// <p>A <code>NumericRangeFilter</code> filters numeric values that are either inside or outside a given numeric range.</p>
        pub fn numeric_range_filter(mut self, input: crate::model::NumericRangeFilter) -> Self {
            self.numeric_range_filter = Some(input);
            self
        }
        /// <p>A <code>NumericRangeFilter</code> filters numeric values that are either inside or outside a given numeric range.</p>
        pub fn set_numeric_range_filter(
            mut self,
            input: std::option::Option<crate::model::NumericRangeFilter>,
        ) -> Self {
            self.numeric_range_filter = input;
            self
        }
        /// <p>A <code>NumericEqualityFilter</code> filters numeric values that equal or do not equal a given numeric value.</p>
        pub fn numeric_equality_filter(
            mut self,
            input: crate::model::NumericEqualityFilter,
        ) -> Self {
            self.numeric_equality_filter = Some(input);
            self
        }
        /// <p>A <code>NumericEqualityFilter</code> filters numeric values that equal or do not equal a given numeric value.</p>
        pub fn set_numeric_equality_filter(
            mut self,
            input: std::option::Option<crate::model::NumericEqualityFilter>,
        ) -> Self {
            self.numeric_equality_filter = input;
            self
        }
        /// <p>A <code>TimeEqualityFilter</code> filters date-time values that equal or do not equal a given date/time value.</p>
        pub fn time_equality_filter(mut self, input: crate::model::TimeEqualityFilter) -> Self {
            self.time_equality_filter = Some(input);
            self
        }
        /// <p>A <code>TimeEqualityFilter</code> filters date-time values that equal or do not equal a given date/time value.</p>
        pub fn set_time_equality_filter(
            mut self,
            input: std::option::Option<crate::model::TimeEqualityFilter>,
        ) -> Self {
            self.time_equality_filter = input;
            self
        }
        /// <p>A <code>TimeRangeFilter</code> filters date-time values that are either inside or outside a given date/time range.</p>
        pub fn time_range_filter(mut self, input: crate::model::TimeRangeFilter) -> Self {
            self.time_range_filter = Some(input);
            self
        }
        /// <p>A <code>TimeRangeFilter</code> filters date-time values that are either inside or outside a given date/time range.</p>
        pub fn set_time_range_filter(
            mut self,
            input: std::option::Option<crate::model::TimeRangeFilter>,
        ) -> Self {
            self.time_range_filter = input;
            self
        }
        /// <p>A <code>RelativeDatesFilter</code> filters date values that are relative to a given date.</p>
        pub fn relative_dates_filter(mut self, input: crate::model::RelativeDatesFilter) -> Self {
            self.relative_dates_filter = Some(input);
            self
        }
        /// <p>A <code>RelativeDatesFilter</code> filters date values that are relative to a given date.</p>
        pub fn set_relative_dates_filter(
            mut self,
            input: std::option::Option<crate::model::RelativeDatesFilter>,
        ) -> Self {
            self.relative_dates_filter = input;
            self
        }
        /// <p>A <code>TopBottomFilter</code> filters data to the top or bottom values for a given column.</p>
        pub fn top_bottom_filter(mut self, input: crate::model::TopBottomFilter) -> Self {
            self.top_bottom_filter = Some(input);
            self
        }
        /// <p>A <code>TopBottomFilter</code> filters data to the top or bottom values for a given column.</p>
        pub fn set_top_bottom_filter(
            mut self,
            input: std::option::Option<crate::model::TopBottomFilter>,
        ) -> Self {
            self.top_bottom_filter = input;
            self
        }
        /// Consumes the builder and constructs a [`Filter`](crate::model::Filter).
        pub fn build(self) -> crate::model::Filter {
            crate::model::Filter {
                category_filter: self.category_filter,
                numeric_range_filter: self.numeric_range_filter,
                numeric_equality_filter: self.numeric_equality_filter,
                time_equality_filter: self.time_equality_filter,
                time_range_filter: self.time_range_filter,
                relative_dates_filter: self.relative_dates_filter,
                top_bottom_filter: self.top_bottom_filter,
            }
        }
    }
}
impl Filter {
    /// Creates a new builder-style object to manufacture [`Filter`](crate::model::Filter).
    pub fn builder() -> crate::model::filter::Builder {
        crate::model::filter::Builder::default()
    }
}

/// <p>A <code>TopBottomFilter</code> filters values that are at the top or the bottom.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TopBottomFilter {
    /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
    #[doc(hidden)]
    pub filter_id: std::option::Option<std::string::String>,
    /// <p>The column that the filter is applied to.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The number of items to include in the top bottom filter results.</p>
    #[doc(hidden)]
    pub limit: std::option::Option<i32>,
    /// <p>The aggregation and sort configuration of the top bottom filter.</p>
    #[doc(hidden)]
    pub aggregation_sort_configurations:
        std::option::Option<std::vec::Vec<crate::model::AggregationSortConfiguration>>,
    /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
    #[doc(hidden)]
    pub time_granularity: std::option::Option<crate::model::TimeGranularity>,
    /// <p>The parameter whose value should be used for the filter value.</p>
    #[doc(hidden)]
    pub parameter_name: std::option::Option<std::string::String>,
}
impl TopBottomFilter {
    /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
    pub fn filter_id(&self) -> std::option::Option<&str> {
        self.filter_id.as_deref()
    }
    /// <p>The column that the filter is applied to.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>The number of items to include in the top bottom filter results.</p>
    pub fn limit(&self) -> std::option::Option<i32> {
        self.limit
    }
    /// <p>The aggregation and sort configuration of the top bottom filter.</p>
    pub fn aggregation_sort_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::AggregationSortConfiguration]> {
        self.aggregation_sort_configurations.as_deref()
    }
    /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
    pub fn time_granularity(&self) -> std::option::Option<&crate::model::TimeGranularity> {
        self.time_granularity.as_ref()
    }
    /// <p>The parameter whose value should be used for the filter value.</p>
    pub fn parameter_name(&self) -> std::option::Option<&str> {
        self.parameter_name.as_deref()
    }
}
/// See [`TopBottomFilter`](crate::model::TopBottomFilter).
pub mod top_bottom_filter {

    /// A builder for [`TopBottomFilter`](crate::model::TopBottomFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_id: std::option::Option<std::string::String>,
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) limit: std::option::Option<i32>,
        pub(crate) aggregation_sort_configurations:
            std::option::Option<std::vec::Vec<crate::model::AggregationSortConfiguration>>,
        pub(crate) time_granularity: std::option::Option<crate::model::TimeGranularity>,
        pub(crate) parameter_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
        pub fn filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_id = Some(input.into());
            self
        }
        /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
        pub fn set_filter_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.filter_id = input;
            self
        }
        /// <p>The column that the filter is applied to.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that the filter is applied to.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The number of items to include in the top bottom filter results.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        /// <p>The number of items to include in the top bottom filter results.</p>
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// Appends an item to `aggregation_sort_configurations`.
        ///
        /// To override the contents of this collection use [`set_aggregation_sort_configurations`](Self::set_aggregation_sort_configurations).
        ///
        /// <p>The aggregation and sort configuration of the top bottom filter.</p>
        pub fn aggregation_sort_configurations(
            mut self,
            input: crate::model::AggregationSortConfiguration,
        ) -> Self {
            let mut v = self.aggregation_sort_configurations.unwrap_or_default();
            v.push(input);
            self.aggregation_sort_configurations = Some(v);
            self
        }
        /// <p>The aggregation and sort configuration of the top bottom filter.</p>
        pub fn set_aggregation_sort_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AggregationSortConfiguration>>,
        ) -> Self {
            self.aggregation_sort_configurations = input;
            self
        }
        /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
        pub fn time_granularity(mut self, input: crate::model::TimeGranularity) -> Self {
            self.time_granularity = Some(input);
            self
        }
        /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
        pub fn set_time_granularity(
            mut self,
            input: std::option::Option<crate::model::TimeGranularity>,
        ) -> Self {
            self.time_granularity = input;
            self
        }
        /// <p>The parameter whose value should be used for the filter value.</p>
        pub fn parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_name = Some(input.into());
            self
        }
        /// <p>The parameter whose value should be used for the filter value.</p>
        pub fn set_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_name = input;
            self
        }
        /// Consumes the builder and constructs a [`TopBottomFilter`](crate::model::TopBottomFilter).
        pub fn build(self) -> crate::model::TopBottomFilter {
            crate::model::TopBottomFilter {
                filter_id: self.filter_id,
                column: self.column,
                limit: self.limit,
                aggregation_sort_configurations: self.aggregation_sort_configurations,
                time_granularity: self.time_granularity,
                parameter_name: self.parameter_name,
            }
        }
    }
}
impl TopBottomFilter {
    /// Creates a new builder-style object to manufacture [`TopBottomFilter`](crate::model::TopBottomFilter).
    pub fn builder() -> crate::model::top_bottom_filter::Builder {
        crate::model::top_bottom_filter::Builder::default()
    }
}

/// When writing a match expression against `TimeGranularity`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let timegranularity = unimplemented!();
/// match timegranularity {
///     TimeGranularity::Day => { /* ... */ },
///     TimeGranularity::Hour => { /* ... */ },
///     TimeGranularity::Millisecond => { /* ... */ },
///     TimeGranularity::Minute => { /* ... */ },
///     TimeGranularity::Month => { /* ... */ },
///     TimeGranularity::Quarter => { /* ... */ },
///     TimeGranularity::Second => { /* ... */ },
///     TimeGranularity::Week => { /* ... */ },
///     TimeGranularity::Year => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `timegranularity` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TimeGranularity::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TimeGranularity::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TimeGranularity::NewFeature` is defined.
/// Specifically, when `timegranularity` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TimeGranularity::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TimeGranularity {
    #[allow(missing_docs)] // documentation missing in model
    Day,
    #[allow(missing_docs)] // documentation missing in model
    Hour,
    #[allow(missing_docs)] // documentation missing in model
    Millisecond,
    #[allow(missing_docs)] // documentation missing in model
    Minute,
    #[allow(missing_docs)] // documentation missing in model
    Month,
    #[allow(missing_docs)] // documentation missing in model
    Quarter,
    #[allow(missing_docs)] // documentation missing in model
    Second,
    #[allow(missing_docs)] // documentation missing in model
    Week,
    #[allow(missing_docs)] // documentation missing in model
    Year,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TimeGranularity {
    fn from(s: &str) -> Self {
        match s {
            "DAY" => TimeGranularity::Day,
            "HOUR" => TimeGranularity::Hour,
            "MILLISECOND" => TimeGranularity::Millisecond,
            "MINUTE" => TimeGranularity::Minute,
            "MONTH" => TimeGranularity::Month,
            "QUARTER" => TimeGranularity::Quarter,
            "SECOND" => TimeGranularity::Second,
            "WEEK" => TimeGranularity::Week,
            "YEAR" => TimeGranularity::Year,
            other => TimeGranularity::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TimeGranularity {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TimeGranularity::from(s))
    }
}
impl TimeGranularity {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TimeGranularity::Day => "DAY",
            TimeGranularity::Hour => "HOUR",
            TimeGranularity::Millisecond => "MILLISECOND",
            TimeGranularity::Minute => "MINUTE",
            TimeGranularity::Month => "MONTH",
            TimeGranularity::Quarter => "QUARTER",
            TimeGranularity::Second => "SECOND",
            TimeGranularity::Week => "WEEK",
            TimeGranularity::Year => "YEAR",
            TimeGranularity::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DAY",
            "HOUR",
            "MILLISECOND",
            "MINUTE",
            "MONTH",
            "QUARTER",
            "SECOND",
            "WEEK",
            "YEAR",
        ]
    }
}
impl AsRef<str> for TimeGranularity {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration options to sort aggregated values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregationSortConfiguration {
    /// <p>The column that determines the sort order of aggregated values.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The sort direction of values.</p>
    /// <ul>
    /// <li> <p> <code>ASC</code>: Sort in ascending order.</p> </li>
    /// <li> <p> <code>DESC</code>: Sort in descending order.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub sort_direction: std::option::Option<crate::model::SortDirection>,
    /// <p>The function that aggregates the values in <code>Column</code>.</p>
    #[doc(hidden)]
    pub aggregation_function: std::option::Option<crate::model::AggregationFunction>,
}
impl AggregationSortConfiguration {
    /// <p>The column that determines the sort order of aggregated values.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>The sort direction of values.</p>
    /// <ul>
    /// <li> <p> <code>ASC</code>: Sort in ascending order.</p> </li>
    /// <li> <p> <code>DESC</code>: Sort in descending order.</p> </li>
    /// </ul>
    pub fn sort_direction(&self) -> std::option::Option<&crate::model::SortDirection> {
        self.sort_direction.as_ref()
    }
    /// <p>The function that aggregates the values in <code>Column</code>.</p>
    pub fn aggregation_function(&self) -> std::option::Option<&crate::model::AggregationFunction> {
        self.aggregation_function.as_ref()
    }
}
/// See [`AggregationSortConfiguration`](crate::model::AggregationSortConfiguration).
pub mod aggregation_sort_configuration {

    /// A builder for [`AggregationSortConfiguration`](crate::model::AggregationSortConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) sort_direction: std::option::Option<crate::model::SortDirection>,
        pub(crate) aggregation_function: std::option::Option<crate::model::AggregationFunction>,
    }
    impl Builder {
        /// <p>The column that determines the sort order of aggregated values.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that determines the sort order of aggregated values.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The sort direction of values.</p>
        /// <ul>
        /// <li> <p> <code>ASC</code>: Sort in ascending order.</p> </li>
        /// <li> <p> <code>DESC</code>: Sort in descending order.</p> </li>
        /// </ul>
        pub fn sort_direction(mut self, input: crate::model::SortDirection) -> Self {
            self.sort_direction = Some(input);
            self
        }
        /// <p>The sort direction of values.</p>
        /// <ul>
        /// <li> <p> <code>ASC</code>: Sort in ascending order.</p> </li>
        /// <li> <p> <code>DESC</code>: Sort in descending order.</p> </li>
        /// </ul>
        pub fn set_sort_direction(
            mut self,
            input: std::option::Option<crate::model::SortDirection>,
        ) -> Self {
            self.sort_direction = input;
            self
        }
        /// <p>The function that aggregates the values in <code>Column</code>.</p>
        pub fn aggregation_function(mut self, input: crate::model::AggregationFunction) -> Self {
            self.aggregation_function = Some(input);
            self
        }
        /// <p>The function that aggregates the values in <code>Column</code>.</p>
        pub fn set_aggregation_function(
            mut self,
            input: std::option::Option<crate::model::AggregationFunction>,
        ) -> Self {
            self.aggregation_function = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregationSortConfiguration`](crate::model::AggregationSortConfiguration).
        pub fn build(self) -> crate::model::AggregationSortConfiguration {
            crate::model::AggregationSortConfiguration {
                column: self.column,
                sort_direction: self.sort_direction,
                aggregation_function: self.aggregation_function,
            }
        }
    }
}
impl AggregationSortConfiguration {
    /// Creates a new builder-style object to manufacture [`AggregationSortConfiguration`](crate::model::AggregationSortConfiguration).
    pub fn builder() -> crate::model::aggregation_sort_configuration::Builder {
        crate::model::aggregation_sort_configuration::Builder::default()
    }
}

/// <p>An aggregation function aggregates values from a dimension or measure.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregationFunction {
    /// <p>Aggregation for numerical values.</p>
    #[doc(hidden)]
    pub numerical_aggregation_function:
        std::option::Option<crate::model::NumericalAggregationFunction>,
    /// <p>Aggregation for categorical values.</p>
    /// <ul>
    /// <li> <p> <code>COUNT</code>: Aggregate by the total number of values, including duplicates.</p> </li>
    /// <li> <p> <code>DISTINCT_COUNT</code>: Aggregate by the total number of distinct values.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub categorical_aggregation_function:
        std::option::Option<crate::model::CategoricalAggregationFunction>,
    /// <p>Aggregation for date values.</p>
    /// <ul>
    /// <li> <p> <code>COUNT</code>: Aggregate by the total number of values, including duplicates.</p> </li>
    /// <li> <p> <code>DISTINCT_COUNT</code>: Aggregate by the total number of distinct values.</p> </li>
    /// <li> <p> <code>MIN</code>: Select the smallest date value.</p> </li>
    /// <li> <p> <code>MAX</code>: Select the largest date value.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub date_aggregation_function: std::option::Option<crate::model::DateAggregationFunction>,
}
impl AggregationFunction {
    /// <p>Aggregation for numerical values.</p>
    pub fn numerical_aggregation_function(
        &self,
    ) -> std::option::Option<&crate::model::NumericalAggregationFunction> {
        self.numerical_aggregation_function.as_ref()
    }
    /// <p>Aggregation for categorical values.</p>
    /// <ul>
    /// <li> <p> <code>COUNT</code>: Aggregate by the total number of values, including duplicates.</p> </li>
    /// <li> <p> <code>DISTINCT_COUNT</code>: Aggregate by the total number of distinct values.</p> </li>
    /// </ul>
    pub fn categorical_aggregation_function(
        &self,
    ) -> std::option::Option<&crate::model::CategoricalAggregationFunction> {
        self.categorical_aggregation_function.as_ref()
    }
    /// <p>Aggregation for date values.</p>
    /// <ul>
    /// <li> <p> <code>COUNT</code>: Aggregate by the total number of values, including duplicates.</p> </li>
    /// <li> <p> <code>DISTINCT_COUNT</code>: Aggregate by the total number of distinct values.</p> </li>
    /// <li> <p> <code>MIN</code>: Select the smallest date value.</p> </li>
    /// <li> <p> <code>MAX</code>: Select the largest date value.</p> </li>
    /// </ul>
    pub fn date_aggregation_function(
        &self,
    ) -> std::option::Option<&crate::model::DateAggregationFunction> {
        self.date_aggregation_function.as_ref()
    }
}
/// See [`AggregationFunction`](crate::model::AggregationFunction).
pub mod aggregation_function {

    /// A builder for [`AggregationFunction`](crate::model::AggregationFunction).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) numerical_aggregation_function:
            std::option::Option<crate::model::NumericalAggregationFunction>,
        pub(crate) categorical_aggregation_function:
            std::option::Option<crate::model::CategoricalAggregationFunction>,
        pub(crate) date_aggregation_function:
            std::option::Option<crate::model::DateAggregationFunction>,
    }
    impl Builder {
        /// <p>Aggregation for numerical values.</p>
        pub fn numerical_aggregation_function(
            mut self,
            input: crate::model::NumericalAggregationFunction,
        ) -> Self {
            self.numerical_aggregation_function = Some(input);
            self
        }
        /// <p>Aggregation for numerical values.</p>
        pub fn set_numerical_aggregation_function(
            mut self,
            input: std::option::Option<crate::model::NumericalAggregationFunction>,
        ) -> Self {
            self.numerical_aggregation_function = input;
            self
        }
        /// <p>Aggregation for categorical values.</p>
        /// <ul>
        /// <li> <p> <code>COUNT</code>: Aggregate by the total number of values, including duplicates.</p> </li>
        /// <li> <p> <code>DISTINCT_COUNT</code>: Aggregate by the total number of distinct values.</p> </li>
        /// </ul>
        pub fn categorical_aggregation_function(
            mut self,
            input: crate::model::CategoricalAggregationFunction,
        ) -> Self {
            self.categorical_aggregation_function = Some(input);
            self
        }
        /// <p>Aggregation for categorical values.</p>
        /// <ul>
        /// <li> <p> <code>COUNT</code>: Aggregate by the total number of values, including duplicates.</p> </li>
        /// <li> <p> <code>DISTINCT_COUNT</code>: Aggregate by the total number of distinct values.</p> </li>
        /// </ul>
        pub fn set_categorical_aggregation_function(
            mut self,
            input: std::option::Option<crate::model::CategoricalAggregationFunction>,
        ) -> Self {
            self.categorical_aggregation_function = input;
            self
        }
        /// <p>Aggregation for date values.</p>
        /// <ul>
        /// <li> <p> <code>COUNT</code>: Aggregate by the total number of values, including duplicates.</p> </li>
        /// <li> <p> <code>DISTINCT_COUNT</code>: Aggregate by the total number of distinct values.</p> </li>
        /// <li> <p> <code>MIN</code>: Select the smallest date value.</p> </li>
        /// <li> <p> <code>MAX</code>: Select the largest date value.</p> </li>
        /// </ul>
        pub fn date_aggregation_function(
            mut self,
            input: crate::model::DateAggregationFunction,
        ) -> Self {
            self.date_aggregation_function = Some(input);
            self
        }
        /// <p>Aggregation for date values.</p>
        /// <ul>
        /// <li> <p> <code>COUNT</code>: Aggregate by the total number of values, including duplicates.</p> </li>
        /// <li> <p> <code>DISTINCT_COUNT</code>: Aggregate by the total number of distinct values.</p> </li>
        /// <li> <p> <code>MIN</code>: Select the smallest date value.</p> </li>
        /// <li> <p> <code>MAX</code>: Select the largest date value.</p> </li>
        /// </ul>
        pub fn set_date_aggregation_function(
            mut self,
            input: std::option::Option<crate::model::DateAggregationFunction>,
        ) -> Self {
            self.date_aggregation_function = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregationFunction`](crate::model::AggregationFunction).
        pub fn build(self) -> crate::model::AggregationFunction {
            crate::model::AggregationFunction {
                numerical_aggregation_function: self.numerical_aggregation_function,
                categorical_aggregation_function: self.categorical_aggregation_function,
                date_aggregation_function: self.date_aggregation_function,
            }
        }
    }
}
impl AggregationFunction {
    /// Creates a new builder-style object to manufacture [`AggregationFunction`](crate::model::AggregationFunction).
    pub fn builder() -> crate::model::aggregation_function::Builder {
        crate::model::aggregation_function::Builder::default()
    }
}

/// When writing a match expression against `DateAggregationFunction`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let dateaggregationfunction = unimplemented!();
/// match dateaggregationfunction {
///     DateAggregationFunction::Count => { /* ... */ },
///     DateAggregationFunction::DistinctCount => { /* ... */ },
///     DateAggregationFunction::Max => { /* ... */ },
///     DateAggregationFunction::Min => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `dateaggregationfunction` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DateAggregationFunction::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DateAggregationFunction::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DateAggregationFunction::NewFeature` is defined.
/// Specifically, when `dateaggregationfunction` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DateAggregationFunction::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DateAggregationFunction {
    #[allow(missing_docs)] // documentation missing in model
    Count,
    #[allow(missing_docs)] // documentation missing in model
    DistinctCount,
    #[allow(missing_docs)] // documentation missing in model
    Max,
    #[allow(missing_docs)] // documentation missing in model
    Min,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DateAggregationFunction {
    fn from(s: &str) -> Self {
        match s {
            "COUNT" => DateAggregationFunction::Count,
            "DISTINCT_COUNT" => DateAggregationFunction::DistinctCount,
            "MAX" => DateAggregationFunction::Max,
            "MIN" => DateAggregationFunction::Min,
            other => DateAggregationFunction::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DateAggregationFunction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DateAggregationFunction::from(s))
    }
}
impl DateAggregationFunction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DateAggregationFunction::Count => "COUNT",
            DateAggregationFunction::DistinctCount => "DISTINCT_COUNT",
            DateAggregationFunction::Max => "MAX",
            DateAggregationFunction::Min => "MIN",
            DateAggregationFunction::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COUNT", "DISTINCT_COUNT", "MAX", "MIN"]
    }
}
impl AsRef<str> for DateAggregationFunction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `CategoricalAggregationFunction`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let categoricalaggregationfunction = unimplemented!();
/// match categoricalaggregationfunction {
///     CategoricalAggregationFunction::Count => { /* ... */ },
///     CategoricalAggregationFunction::DistinctCount => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `categoricalaggregationfunction` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CategoricalAggregationFunction::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CategoricalAggregationFunction::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CategoricalAggregationFunction::NewFeature` is defined.
/// Specifically, when `categoricalaggregationfunction` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CategoricalAggregationFunction::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CategoricalAggregationFunction {
    #[allow(missing_docs)] // documentation missing in model
    Count,
    #[allow(missing_docs)] // documentation missing in model
    DistinctCount,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CategoricalAggregationFunction {
    fn from(s: &str) -> Self {
        match s {
            "COUNT" => CategoricalAggregationFunction::Count,
            "DISTINCT_COUNT" => CategoricalAggregationFunction::DistinctCount,
            other => CategoricalAggregationFunction::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for CategoricalAggregationFunction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CategoricalAggregationFunction::from(s))
    }
}
impl CategoricalAggregationFunction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CategoricalAggregationFunction::Count => "COUNT",
            CategoricalAggregationFunction::DistinctCount => "DISTINCT_COUNT",
            CategoricalAggregationFunction::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COUNT", "DISTINCT_COUNT"]
    }
}
impl AsRef<str> for CategoricalAggregationFunction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Aggregation for numerical values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NumericalAggregationFunction {
    /// <p>Built-in aggregation functions for numerical values.</p>
    /// <ul>
    /// <li> <p> <code>SUM</code>: The sum of a dimension or measure. </p> </li>
    /// <li> <p> <code>AVERAGE</code>: The average of a dimension or measure.</p> </li>
    /// <li> <p> <code>MIN</code>: The minimum value of a dimension or measure.</p> </li>
    /// <li> <p> <code>MAX</code>: The maximum value of a dimension or measure.</p> </li>
    /// <li> <p> <code>COUNT</code>: The count of a dimension or measure.</p> </li>
    /// <li> <p> <code>DISTINCT_COUNT</code>: The count of distinct values in a dimension or measure.</p> </li>
    /// <li> <p> <code>VAR</code>: The variance of a dimension or measure.</p> </li>
    /// <li> <p> <code>VARP</code>: The partitioned variance of a dimension or measure.</p> </li>
    /// <li> <p> <code>STDEV</code>: The standard deviation of a dimension or measure.</p> </li>
    /// <li> <p> <code>STDEVP</code>: The partitioned standard deviation of a dimension or measure.</p> </li>
    /// <li> <p> <code>MEDIAN</code>: The median value of a dimension or measure.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub simple_numerical_aggregation:
        std::option::Option<crate::model::SimpleNumericalAggregationFunction>,
    /// <p>An aggregation based on the percentile of values in a dimension or measure.</p>
    #[doc(hidden)]
    pub percentile_aggregation: std::option::Option<crate::model::PercentileAggregation>,
}
impl NumericalAggregationFunction {
    /// <p>Built-in aggregation functions for numerical values.</p>
    /// <ul>
    /// <li> <p> <code>SUM</code>: The sum of a dimension or measure. </p> </li>
    /// <li> <p> <code>AVERAGE</code>: The average of a dimension or measure.</p> </li>
    /// <li> <p> <code>MIN</code>: The minimum value of a dimension or measure.</p> </li>
    /// <li> <p> <code>MAX</code>: The maximum value of a dimension or measure.</p> </li>
    /// <li> <p> <code>COUNT</code>: The count of a dimension or measure.</p> </li>
    /// <li> <p> <code>DISTINCT_COUNT</code>: The count of distinct values in a dimension or measure.</p> </li>
    /// <li> <p> <code>VAR</code>: The variance of a dimension or measure.</p> </li>
    /// <li> <p> <code>VARP</code>: The partitioned variance of a dimension or measure.</p> </li>
    /// <li> <p> <code>STDEV</code>: The standard deviation of a dimension or measure.</p> </li>
    /// <li> <p> <code>STDEVP</code>: The partitioned standard deviation of a dimension or measure.</p> </li>
    /// <li> <p> <code>MEDIAN</code>: The median value of a dimension or measure.</p> </li>
    /// </ul>
    pub fn simple_numerical_aggregation(
        &self,
    ) -> std::option::Option<&crate::model::SimpleNumericalAggregationFunction> {
        self.simple_numerical_aggregation.as_ref()
    }
    /// <p>An aggregation based on the percentile of values in a dimension or measure.</p>
    pub fn percentile_aggregation(
        &self,
    ) -> std::option::Option<&crate::model::PercentileAggregation> {
        self.percentile_aggregation.as_ref()
    }
}
/// See [`NumericalAggregationFunction`](crate::model::NumericalAggregationFunction).
pub mod numerical_aggregation_function {

    /// A builder for [`NumericalAggregationFunction`](crate::model::NumericalAggregationFunction).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) simple_numerical_aggregation:
            std::option::Option<crate::model::SimpleNumericalAggregationFunction>,
        pub(crate) percentile_aggregation: std::option::Option<crate::model::PercentileAggregation>,
    }
    impl Builder {
        /// <p>Built-in aggregation functions for numerical values.</p>
        /// <ul>
        /// <li> <p> <code>SUM</code>: The sum of a dimension or measure. </p> </li>
        /// <li> <p> <code>AVERAGE</code>: The average of a dimension or measure.</p> </li>
        /// <li> <p> <code>MIN</code>: The minimum value of a dimension or measure.</p> </li>
        /// <li> <p> <code>MAX</code>: The maximum value of a dimension or measure.</p> </li>
        /// <li> <p> <code>COUNT</code>: The count of a dimension or measure.</p> </li>
        /// <li> <p> <code>DISTINCT_COUNT</code>: The count of distinct values in a dimension or measure.</p> </li>
        /// <li> <p> <code>VAR</code>: The variance of a dimension or measure.</p> </li>
        /// <li> <p> <code>VARP</code>: The partitioned variance of a dimension or measure.</p> </li>
        /// <li> <p> <code>STDEV</code>: The standard deviation of a dimension or measure.</p> </li>
        /// <li> <p> <code>STDEVP</code>: The partitioned standard deviation of a dimension or measure.</p> </li>
        /// <li> <p> <code>MEDIAN</code>: The median value of a dimension or measure.</p> </li>
        /// </ul>
        pub fn simple_numerical_aggregation(
            mut self,
            input: crate::model::SimpleNumericalAggregationFunction,
        ) -> Self {
            self.simple_numerical_aggregation = Some(input);
            self
        }
        /// <p>Built-in aggregation functions for numerical values.</p>
        /// <ul>
        /// <li> <p> <code>SUM</code>: The sum of a dimension or measure. </p> </li>
        /// <li> <p> <code>AVERAGE</code>: The average of a dimension or measure.</p> </li>
        /// <li> <p> <code>MIN</code>: The minimum value of a dimension or measure.</p> </li>
        /// <li> <p> <code>MAX</code>: The maximum value of a dimension or measure.</p> </li>
        /// <li> <p> <code>COUNT</code>: The count of a dimension or measure.</p> </li>
        /// <li> <p> <code>DISTINCT_COUNT</code>: The count of distinct values in a dimension or measure.</p> </li>
        /// <li> <p> <code>VAR</code>: The variance of a dimension or measure.</p> </li>
        /// <li> <p> <code>VARP</code>: The partitioned variance of a dimension or measure.</p> </li>
        /// <li> <p> <code>STDEV</code>: The standard deviation of a dimension or measure.</p> </li>
        /// <li> <p> <code>STDEVP</code>: The partitioned standard deviation of a dimension or measure.</p> </li>
        /// <li> <p> <code>MEDIAN</code>: The median value of a dimension or measure.</p> </li>
        /// </ul>
        pub fn set_simple_numerical_aggregation(
            mut self,
            input: std::option::Option<crate::model::SimpleNumericalAggregationFunction>,
        ) -> Self {
            self.simple_numerical_aggregation = input;
            self
        }
        /// <p>An aggregation based on the percentile of values in a dimension or measure.</p>
        pub fn percentile_aggregation(
            mut self,
            input: crate::model::PercentileAggregation,
        ) -> Self {
            self.percentile_aggregation = Some(input);
            self
        }
        /// <p>An aggregation based on the percentile of values in a dimension or measure.</p>
        pub fn set_percentile_aggregation(
            mut self,
            input: std::option::Option<crate::model::PercentileAggregation>,
        ) -> Self {
            self.percentile_aggregation = input;
            self
        }
        /// Consumes the builder and constructs a [`NumericalAggregationFunction`](crate::model::NumericalAggregationFunction).
        pub fn build(self) -> crate::model::NumericalAggregationFunction {
            crate::model::NumericalAggregationFunction {
                simple_numerical_aggregation: self.simple_numerical_aggregation,
                percentile_aggregation: self.percentile_aggregation,
            }
        }
    }
}
impl NumericalAggregationFunction {
    /// Creates a new builder-style object to manufacture [`NumericalAggregationFunction`](crate::model::NumericalAggregationFunction).
    pub fn builder() -> crate::model::numerical_aggregation_function::Builder {
        crate::model::numerical_aggregation_function::Builder::default()
    }
}

/// <p>An aggregation based on the percentile of values in a dimension or measure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PercentileAggregation {
    /// <p>The percentile value. This value can be any numeric constant 0â€“100. A percentile value of 50 computes the median value of the measure.</p>
    #[doc(hidden)]
    pub percentile_value: std::option::Option<f64>,
}
impl PercentileAggregation {
    /// <p>The percentile value. This value can be any numeric constant 0â€“100. A percentile value of 50 computes the median value of the measure.</p>
    pub fn percentile_value(&self) -> std::option::Option<f64> {
        self.percentile_value
    }
}
/// See [`PercentileAggregation`](crate::model::PercentileAggregation).
pub mod percentile_aggregation {

    /// A builder for [`PercentileAggregation`](crate::model::PercentileAggregation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) percentile_value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The percentile value. This value can be any numeric constant 0â€“100. A percentile value of 50 computes the median value of the measure.</p>
        pub fn percentile_value(mut self, input: f64) -> Self {
            self.percentile_value = Some(input);
            self
        }
        /// <p>The percentile value. This value can be any numeric constant 0â€“100. A percentile value of 50 computes the median value of the measure.</p>
        pub fn set_percentile_value(mut self, input: std::option::Option<f64>) -> Self {
            self.percentile_value = input;
            self
        }
        /// Consumes the builder and constructs a [`PercentileAggregation`](crate::model::PercentileAggregation).
        pub fn build(self) -> crate::model::PercentileAggregation {
            crate::model::PercentileAggregation {
                percentile_value: self.percentile_value,
            }
        }
    }
}
impl PercentileAggregation {
    /// Creates a new builder-style object to manufacture [`PercentileAggregation`](crate::model::PercentileAggregation).
    pub fn builder() -> crate::model::percentile_aggregation::Builder {
        crate::model::percentile_aggregation::Builder::default()
    }
}

/// When writing a match expression against `SimpleNumericalAggregationFunction`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let simplenumericalaggregationfunction = unimplemented!();
/// match simplenumericalaggregationfunction {
///     SimpleNumericalAggregationFunction::Average => { /* ... */ },
///     SimpleNumericalAggregationFunction::Count => { /* ... */ },
///     SimpleNumericalAggregationFunction::DistinctCount => { /* ... */ },
///     SimpleNumericalAggregationFunction::Max => { /* ... */ },
///     SimpleNumericalAggregationFunction::Median => { /* ... */ },
///     SimpleNumericalAggregationFunction::Min => { /* ... */ },
///     SimpleNumericalAggregationFunction::Stdev => { /* ... */ },
///     SimpleNumericalAggregationFunction::Stdevp => { /* ... */ },
///     SimpleNumericalAggregationFunction::Sum => { /* ... */ },
///     SimpleNumericalAggregationFunction::Var => { /* ... */ },
///     SimpleNumericalAggregationFunction::Varp => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `simplenumericalaggregationfunction` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SimpleNumericalAggregationFunction::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SimpleNumericalAggregationFunction::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SimpleNumericalAggregationFunction::NewFeature` is defined.
/// Specifically, when `simplenumericalaggregationfunction` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SimpleNumericalAggregationFunction::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SimpleNumericalAggregationFunction {
    #[allow(missing_docs)] // documentation missing in model
    Average,
    #[allow(missing_docs)] // documentation missing in model
    Count,
    #[allow(missing_docs)] // documentation missing in model
    DistinctCount,
    #[allow(missing_docs)] // documentation missing in model
    Max,
    #[allow(missing_docs)] // documentation missing in model
    Median,
    #[allow(missing_docs)] // documentation missing in model
    Min,
    #[allow(missing_docs)] // documentation missing in model
    Stdev,
    #[allow(missing_docs)] // documentation missing in model
    Stdevp,
    #[allow(missing_docs)] // documentation missing in model
    Sum,
    #[allow(missing_docs)] // documentation missing in model
    Var,
    #[allow(missing_docs)] // documentation missing in model
    Varp,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SimpleNumericalAggregationFunction {
    fn from(s: &str) -> Self {
        match s {
            "AVERAGE" => SimpleNumericalAggregationFunction::Average,
            "COUNT" => SimpleNumericalAggregationFunction::Count,
            "DISTINCT_COUNT" => SimpleNumericalAggregationFunction::DistinctCount,
            "MAX" => SimpleNumericalAggregationFunction::Max,
            "MEDIAN" => SimpleNumericalAggregationFunction::Median,
            "MIN" => SimpleNumericalAggregationFunction::Min,
            "STDEV" => SimpleNumericalAggregationFunction::Stdev,
            "STDEVP" => SimpleNumericalAggregationFunction::Stdevp,
            "SUM" => SimpleNumericalAggregationFunction::Sum,
            "VAR" => SimpleNumericalAggregationFunction::Var,
            "VARP" => SimpleNumericalAggregationFunction::Varp,
            other => SimpleNumericalAggregationFunction::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for SimpleNumericalAggregationFunction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SimpleNumericalAggregationFunction::from(s))
    }
}
impl SimpleNumericalAggregationFunction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SimpleNumericalAggregationFunction::Average => "AVERAGE",
            SimpleNumericalAggregationFunction::Count => "COUNT",
            SimpleNumericalAggregationFunction::DistinctCount => "DISTINCT_COUNT",
            SimpleNumericalAggregationFunction::Max => "MAX",
            SimpleNumericalAggregationFunction::Median => "MEDIAN",
            SimpleNumericalAggregationFunction::Min => "MIN",
            SimpleNumericalAggregationFunction::Stdev => "STDEV",
            SimpleNumericalAggregationFunction::Stdevp => "STDEVP",
            SimpleNumericalAggregationFunction::Sum => "SUM",
            SimpleNumericalAggregationFunction::Var => "VAR",
            SimpleNumericalAggregationFunction::Varp => "VARP",
            SimpleNumericalAggregationFunction::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVERAGE",
            "COUNT",
            "DISTINCT_COUNT",
            "MAX",
            "MEDIAN",
            "MIN",
            "STDEV",
            "STDEVP",
            "SUM",
            "VAR",
            "VARP",
        ]
    }
}
impl AsRef<str> for SimpleNumericalAggregationFunction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SortDirection`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sortdirection = unimplemented!();
/// match sortdirection {
///     SortDirection::Asc => { /* ... */ },
///     SortDirection::Desc => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sortdirection` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SortDirection::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SortDirection::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SortDirection::NewFeature` is defined.
/// Specifically, when `sortdirection` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SortDirection::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortDirection {
    #[allow(missing_docs)] // documentation missing in model
    Asc,
    #[allow(missing_docs)] // documentation missing in model
    Desc,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SortDirection {
    fn from(s: &str) -> Self {
        match s {
            "ASC" => SortDirection::Asc,
            "DESC" => SortDirection::Desc,
            other => SortDirection::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SortDirection {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortDirection::from(s))
    }
}
impl SortDirection {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortDirection::Asc => "ASC",
            SortDirection::Desc => "DESC",
            SortDirection::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ASC", "DESC"]
    }
}
impl AsRef<str> for SortDirection {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A <code>RelativeDatesFilter</code> filters relative dates values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RelativeDatesFilter {
    /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
    #[doc(hidden)]
    pub filter_id: std::option::Option<std::string::String>,
    /// <p>The column that the filter is applied to.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The date configuration of the filter.</p>
    #[doc(hidden)]
    pub anchor_date_configuration: std::option::Option<crate::model::AnchorDateConfiguration>,
    /// <p>The minimum granularity (period granularity) of the relative dates filter.</p>
    #[doc(hidden)]
    pub minimum_granularity: std::option::Option<crate::model::TimeGranularity>,
    /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
    #[doc(hidden)]
    pub time_granularity: std::option::Option<crate::model::TimeGranularity>,
    /// <p>The range date type of the filter. Choose one of the options below:</p>
    /// <ul>
    /// <li> <p> <code>PREVIOUS</code> </p> </li>
    /// <li> <p> <code>THIS</code> </p> </li>
    /// <li> <p> <code>LAST</code> </p> </li>
    /// <li> <p> <code>NOW</code> </p> </li>
    /// <li> <p> <code>NEXT</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub relative_date_type: std::option::Option<crate::model::RelativeDateType>,
    /// <p>The date value of the filter.</p>
    #[doc(hidden)]
    pub relative_date_value: std::option::Option<i32>,
    /// <p>The parameter whose value should be used for the filter value.</p>
    #[doc(hidden)]
    pub parameter_name: std::option::Option<std::string::String>,
    /// <p>This option determines how null values should be treated when filtering data.</p>
    /// <ul>
    /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
    /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
    /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub null_option: std::option::Option<crate::model::FilterNullOption>,
    /// <p>The configuration for the exclude period of the filter.</p>
    #[doc(hidden)]
    pub exclude_period_configuration: std::option::Option<crate::model::ExcludePeriodConfiguration>,
}
impl RelativeDatesFilter {
    /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
    pub fn filter_id(&self) -> std::option::Option<&str> {
        self.filter_id.as_deref()
    }
    /// <p>The column that the filter is applied to.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>The date configuration of the filter.</p>
    pub fn anchor_date_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AnchorDateConfiguration> {
        self.anchor_date_configuration.as_ref()
    }
    /// <p>The minimum granularity (period granularity) of the relative dates filter.</p>
    pub fn minimum_granularity(&self) -> std::option::Option<&crate::model::TimeGranularity> {
        self.minimum_granularity.as_ref()
    }
    /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
    pub fn time_granularity(&self) -> std::option::Option<&crate::model::TimeGranularity> {
        self.time_granularity.as_ref()
    }
    /// <p>The range date type of the filter. Choose one of the options below:</p>
    /// <ul>
    /// <li> <p> <code>PREVIOUS</code> </p> </li>
    /// <li> <p> <code>THIS</code> </p> </li>
    /// <li> <p> <code>LAST</code> </p> </li>
    /// <li> <p> <code>NOW</code> </p> </li>
    /// <li> <p> <code>NEXT</code> </p> </li>
    /// </ul>
    pub fn relative_date_type(&self) -> std::option::Option<&crate::model::RelativeDateType> {
        self.relative_date_type.as_ref()
    }
    /// <p>The date value of the filter.</p>
    pub fn relative_date_value(&self) -> std::option::Option<i32> {
        self.relative_date_value
    }
    /// <p>The parameter whose value should be used for the filter value.</p>
    pub fn parameter_name(&self) -> std::option::Option<&str> {
        self.parameter_name.as_deref()
    }
    /// <p>This option determines how null values should be treated when filtering data.</p>
    /// <ul>
    /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
    /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
    /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
    /// </ul>
    pub fn null_option(&self) -> std::option::Option<&crate::model::FilterNullOption> {
        self.null_option.as_ref()
    }
    /// <p>The configuration for the exclude period of the filter.</p>
    pub fn exclude_period_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ExcludePeriodConfiguration> {
        self.exclude_period_configuration.as_ref()
    }
}
/// See [`RelativeDatesFilter`](crate::model::RelativeDatesFilter).
pub mod relative_dates_filter {

    /// A builder for [`RelativeDatesFilter`](crate::model::RelativeDatesFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_id: std::option::Option<std::string::String>,
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) anchor_date_configuration:
            std::option::Option<crate::model::AnchorDateConfiguration>,
        pub(crate) minimum_granularity: std::option::Option<crate::model::TimeGranularity>,
        pub(crate) time_granularity: std::option::Option<crate::model::TimeGranularity>,
        pub(crate) relative_date_type: std::option::Option<crate::model::RelativeDateType>,
        pub(crate) relative_date_value: std::option::Option<i32>,
        pub(crate) parameter_name: std::option::Option<std::string::String>,
        pub(crate) null_option: std::option::Option<crate::model::FilterNullOption>,
        pub(crate) exclude_period_configuration:
            std::option::Option<crate::model::ExcludePeriodConfiguration>,
    }
    impl Builder {
        /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
        pub fn filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_id = Some(input.into());
            self
        }
        /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
        pub fn set_filter_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.filter_id = input;
            self
        }
        /// <p>The column that the filter is applied to.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that the filter is applied to.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The date configuration of the filter.</p>
        pub fn anchor_date_configuration(
            mut self,
            input: crate::model::AnchorDateConfiguration,
        ) -> Self {
            self.anchor_date_configuration = Some(input);
            self
        }
        /// <p>The date configuration of the filter.</p>
        pub fn set_anchor_date_configuration(
            mut self,
            input: std::option::Option<crate::model::AnchorDateConfiguration>,
        ) -> Self {
            self.anchor_date_configuration = input;
            self
        }
        /// <p>The minimum granularity (period granularity) of the relative dates filter.</p>
        pub fn minimum_granularity(mut self, input: crate::model::TimeGranularity) -> Self {
            self.minimum_granularity = Some(input);
            self
        }
        /// <p>The minimum granularity (period granularity) of the relative dates filter.</p>
        pub fn set_minimum_granularity(
            mut self,
            input: std::option::Option<crate::model::TimeGranularity>,
        ) -> Self {
            self.minimum_granularity = input;
            self
        }
        /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
        pub fn time_granularity(mut self, input: crate::model::TimeGranularity) -> Self {
            self.time_granularity = Some(input);
            self
        }
        /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
        pub fn set_time_granularity(
            mut self,
            input: std::option::Option<crate::model::TimeGranularity>,
        ) -> Self {
            self.time_granularity = input;
            self
        }
        /// <p>The range date type of the filter. Choose one of the options below:</p>
        /// <ul>
        /// <li> <p> <code>PREVIOUS</code> </p> </li>
        /// <li> <p> <code>THIS</code> </p> </li>
        /// <li> <p> <code>LAST</code> </p> </li>
        /// <li> <p> <code>NOW</code> </p> </li>
        /// <li> <p> <code>NEXT</code> </p> </li>
        /// </ul>
        pub fn relative_date_type(mut self, input: crate::model::RelativeDateType) -> Self {
            self.relative_date_type = Some(input);
            self
        }
        /// <p>The range date type of the filter. Choose one of the options below:</p>
        /// <ul>
        /// <li> <p> <code>PREVIOUS</code> </p> </li>
        /// <li> <p> <code>THIS</code> </p> </li>
        /// <li> <p> <code>LAST</code> </p> </li>
        /// <li> <p> <code>NOW</code> </p> </li>
        /// <li> <p> <code>NEXT</code> </p> </li>
        /// </ul>
        pub fn set_relative_date_type(
            mut self,
            input: std::option::Option<crate::model::RelativeDateType>,
        ) -> Self {
            self.relative_date_type = input;
            self
        }
        /// <p>The date value of the filter.</p>
        pub fn relative_date_value(mut self, input: i32) -> Self {
            self.relative_date_value = Some(input);
            self
        }
        /// <p>The date value of the filter.</p>
        pub fn set_relative_date_value(mut self, input: std::option::Option<i32>) -> Self {
            self.relative_date_value = input;
            self
        }
        /// <p>The parameter whose value should be used for the filter value.</p>
        pub fn parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_name = Some(input.into());
            self
        }
        /// <p>The parameter whose value should be used for the filter value.</p>
        pub fn set_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_name = input;
            self
        }
        /// <p>This option determines how null values should be treated when filtering data.</p>
        /// <ul>
        /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
        /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
        /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
        /// </ul>
        pub fn null_option(mut self, input: crate::model::FilterNullOption) -> Self {
            self.null_option = Some(input);
            self
        }
        /// <p>This option determines how null values should be treated when filtering data.</p>
        /// <ul>
        /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
        /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
        /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
        /// </ul>
        pub fn set_null_option(
            mut self,
            input: std::option::Option<crate::model::FilterNullOption>,
        ) -> Self {
            self.null_option = input;
            self
        }
        /// <p>The configuration for the exclude period of the filter.</p>
        pub fn exclude_period_configuration(
            mut self,
            input: crate::model::ExcludePeriodConfiguration,
        ) -> Self {
            self.exclude_period_configuration = Some(input);
            self
        }
        /// <p>The configuration for the exclude period of the filter.</p>
        pub fn set_exclude_period_configuration(
            mut self,
            input: std::option::Option<crate::model::ExcludePeriodConfiguration>,
        ) -> Self {
            self.exclude_period_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`RelativeDatesFilter`](crate::model::RelativeDatesFilter).
        pub fn build(self) -> crate::model::RelativeDatesFilter {
            crate::model::RelativeDatesFilter {
                filter_id: self.filter_id,
                column: self.column,
                anchor_date_configuration: self.anchor_date_configuration,
                minimum_granularity: self.minimum_granularity,
                time_granularity: self.time_granularity,
                relative_date_type: self.relative_date_type,
                relative_date_value: self.relative_date_value,
                parameter_name: self.parameter_name,
                null_option: self.null_option,
                exclude_period_configuration: self.exclude_period_configuration,
            }
        }
    }
}
impl RelativeDatesFilter {
    /// Creates a new builder-style object to manufacture [`RelativeDatesFilter`](crate::model::RelativeDatesFilter).
    pub fn builder() -> crate::model::relative_dates_filter::Builder {
        crate::model::relative_dates_filter::Builder::default()
    }
}

/// <p>The exclude period of <code>TimeRangeFilter</code> or <code>RelativeDatesFilter</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExcludePeriodConfiguration {
    /// <p>The amount or number of the exclude period.</p>
    #[doc(hidden)]
    pub amount: std::option::Option<i32>,
    /// <p>The granularity or unit (day, month, year) of the exclude period.</p>
    #[doc(hidden)]
    pub granularity: std::option::Option<crate::model::TimeGranularity>,
    /// <p>The status of the exclude period. Choose from the following options:</p>
    /// <ul>
    /// <li> <p> <code>ENABLED</code> </p> </li>
    /// <li> <p> <code>DISABLED</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::WidgetStatus>,
}
impl ExcludePeriodConfiguration {
    /// <p>The amount or number of the exclude period.</p>
    pub fn amount(&self) -> std::option::Option<i32> {
        self.amount
    }
    /// <p>The granularity or unit (day, month, year) of the exclude period.</p>
    pub fn granularity(&self) -> std::option::Option<&crate::model::TimeGranularity> {
        self.granularity.as_ref()
    }
    /// <p>The status of the exclude period. Choose from the following options:</p>
    /// <ul>
    /// <li> <p> <code>ENABLED</code> </p> </li>
    /// <li> <p> <code>DISABLED</code> </p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::WidgetStatus> {
        self.status.as_ref()
    }
}
/// See [`ExcludePeriodConfiguration`](crate::model::ExcludePeriodConfiguration).
pub mod exclude_period_configuration {

    /// A builder for [`ExcludePeriodConfiguration`](crate::model::ExcludePeriodConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amount: std::option::Option<i32>,
        pub(crate) granularity: std::option::Option<crate::model::TimeGranularity>,
        pub(crate) status: std::option::Option<crate::model::WidgetStatus>,
    }
    impl Builder {
        /// <p>The amount or number of the exclude period.</p>
        pub fn amount(mut self, input: i32) -> Self {
            self.amount = Some(input);
            self
        }
        /// <p>The amount or number of the exclude period.</p>
        pub fn set_amount(mut self, input: std::option::Option<i32>) -> Self {
            self.amount = input;
            self
        }
        /// <p>The granularity or unit (day, month, year) of the exclude period.</p>
        pub fn granularity(mut self, input: crate::model::TimeGranularity) -> Self {
            self.granularity = Some(input);
            self
        }
        /// <p>The granularity or unit (day, month, year) of the exclude period.</p>
        pub fn set_granularity(
            mut self,
            input: std::option::Option<crate::model::TimeGranularity>,
        ) -> Self {
            self.granularity = input;
            self
        }
        /// <p>The status of the exclude period. Choose from the following options:</p>
        /// <ul>
        /// <li> <p> <code>ENABLED</code> </p> </li>
        /// <li> <p> <code>DISABLED</code> </p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::WidgetStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the exclude period. Choose from the following options:</p>
        /// <ul>
        /// <li> <p> <code>ENABLED</code> </p> </li>
        /// <li> <p> <code>DISABLED</code> </p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::WidgetStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ExcludePeriodConfiguration`](crate::model::ExcludePeriodConfiguration).
        pub fn build(self) -> crate::model::ExcludePeriodConfiguration {
            crate::model::ExcludePeriodConfiguration {
                amount: self.amount,
                granularity: self.granularity,
                status: self.status,
            }
        }
    }
}
impl ExcludePeriodConfiguration {
    /// Creates a new builder-style object to manufacture [`ExcludePeriodConfiguration`](crate::model::ExcludePeriodConfiguration).
    pub fn builder() -> crate::model::exclude_period_configuration::Builder {
        crate::model::exclude_period_configuration::Builder::default()
    }
}

/// When writing a match expression against `FilterNullOption`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let filternulloption = unimplemented!();
/// match filternulloption {
///     FilterNullOption::AllValues => { /* ... */ },
///     FilterNullOption::NonNullsOnly => { /* ... */ },
///     FilterNullOption::NullsOnly => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `filternulloption` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FilterNullOption::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FilterNullOption::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FilterNullOption::NewFeature` is defined.
/// Specifically, when `filternulloption` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FilterNullOption::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FilterNullOption {
    #[allow(missing_docs)] // documentation missing in model
    AllValues,
    #[allow(missing_docs)] // documentation missing in model
    NonNullsOnly,
    #[allow(missing_docs)] // documentation missing in model
    NullsOnly,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FilterNullOption {
    fn from(s: &str) -> Self {
        match s {
            "ALL_VALUES" => FilterNullOption::AllValues,
            "NON_NULLS_ONLY" => FilterNullOption::NonNullsOnly,
            "NULLS_ONLY" => FilterNullOption::NullsOnly,
            other => FilterNullOption::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FilterNullOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FilterNullOption::from(s))
    }
}
impl FilterNullOption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FilterNullOption::AllValues => "ALL_VALUES",
            FilterNullOption::NonNullsOnly => "NON_NULLS_ONLY",
            FilterNullOption::NullsOnly => "NULLS_ONLY",
            FilterNullOption::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL_VALUES", "NON_NULLS_ONLY", "NULLS_ONLY"]
    }
}
impl AsRef<str> for FilterNullOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RelativeDateType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let relativedatetype = unimplemented!();
/// match relativedatetype {
///     RelativeDateType::Last => { /* ... */ },
///     RelativeDateType::Next => { /* ... */ },
///     RelativeDateType::Now => { /* ... */ },
///     RelativeDateType::Previous => { /* ... */ },
///     RelativeDateType::This => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `relativedatetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RelativeDateType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RelativeDateType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RelativeDateType::NewFeature` is defined.
/// Specifically, when `relativedatetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RelativeDateType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RelativeDateType {
    #[allow(missing_docs)] // documentation missing in model
    Last,
    #[allow(missing_docs)] // documentation missing in model
    Next,
    #[allow(missing_docs)] // documentation missing in model
    Now,
    #[allow(missing_docs)] // documentation missing in model
    Previous,
    #[allow(missing_docs)] // documentation missing in model
    This,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RelativeDateType {
    fn from(s: &str) -> Self {
        match s {
            "LAST" => RelativeDateType::Last,
            "NEXT" => RelativeDateType::Next,
            "NOW" => RelativeDateType::Now,
            "PREVIOUS" => RelativeDateType::Previous,
            "THIS" => RelativeDateType::This,
            other => RelativeDateType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for RelativeDateType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RelativeDateType::from(s))
    }
}
impl RelativeDateType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RelativeDateType::Last => "LAST",
            RelativeDateType::Next => "NEXT",
            RelativeDateType::Now => "NOW",
            RelativeDateType::Previous => "PREVIOUS",
            RelativeDateType::This => "THIS",
            RelativeDateType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LAST", "NEXT", "NOW", "PREVIOUS", "THIS"]
    }
}
impl AsRef<str> for RelativeDateType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The date configuration of the filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnchorDateConfiguration {
    /// <p>The options for the date configuration. Choose one of the options below:</p>
    /// <ul>
    /// <li> <p> <code>NOW</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub anchor_option: std::option::Option<crate::model::AnchorOption>,
    /// <p>The name of the parameter that is used for the anchor date configuration.</p>
    #[doc(hidden)]
    pub parameter_name: std::option::Option<std::string::String>,
}
impl AnchorDateConfiguration {
    /// <p>The options for the date configuration. Choose one of the options below:</p>
    /// <ul>
    /// <li> <p> <code>NOW</code> </p> </li>
    /// </ul>
    pub fn anchor_option(&self) -> std::option::Option<&crate::model::AnchorOption> {
        self.anchor_option.as_ref()
    }
    /// <p>The name of the parameter that is used for the anchor date configuration.</p>
    pub fn parameter_name(&self) -> std::option::Option<&str> {
        self.parameter_name.as_deref()
    }
}
/// See [`AnchorDateConfiguration`](crate::model::AnchorDateConfiguration).
pub mod anchor_date_configuration {

    /// A builder for [`AnchorDateConfiguration`](crate::model::AnchorDateConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) anchor_option: std::option::Option<crate::model::AnchorOption>,
        pub(crate) parameter_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The options for the date configuration. Choose one of the options below:</p>
        /// <ul>
        /// <li> <p> <code>NOW</code> </p> </li>
        /// </ul>
        pub fn anchor_option(mut self, input: crate::model::AnchorOption) -> Self {
            self.anchor_option = Some(input);
            self
        }
        /// <p>The options for the date configuration. Choose one of the options below:</p>
        /// <ul>
        /// <li> <p> <code>NOW</code> </p> </li>
        /// </ul>
        pub fn set_anchor_option(
            mut self,
            input: std::option::Option<crate::model::AnchorOption>,
        ) -> Self {
            self.anchor_option = input;
            self
        }
        /// <p>The name of the parameter that is used for the anchor date configuration.</p>
        pub fn parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_name = Some(input.into());
            self
        }
        /// <p>The name of the parameter that is used for the anchor date configuration.</p>
        pub fn set_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AnchorDateConfiguration`](crate::model::AnchorDateConfiguration).
        pub fn build(self) -> crate::model::AnchorDateConfiguration {
            crate::model::AnchorDateConfiguration {
                anchor_option: self.anchor_option,
                parameter_name: self.parameter_name,
            }
        }
    }
}
impl AnchorDateConfiguration {
    /// Creates a new builder-style object to manufacture [`AnchorDateConfiguration`](crate::model::AnchorDateConfiguration).
    pub fn builder() -> crate::model::anchor_date_configuration::Builder {
        crate::model::anchor_date_configuration::Builder::default()
    }
}

/// When writing a match expression against `AnchorOption`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let anchoroption = unimplemented!();
/// match anchoroption {
///     AnchorOption::Now => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `anchoroption` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AnchorOption::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AnchorOption::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AnchorOption::NewFeature` is defined.
/// Specifically, when `anchoroption` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AnchorOption::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AnchorOption {
    #[allow(missing_docs)] // documentation missing in model
    Now,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AnchorOption {
    fn from(s: &str) -> Self {
        match s {
            "NOW" => AnchorOption::Now,
            other => AnchorOption::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AnchorOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AnchorOption::from(s))
    }
}
impl AnchorOption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AnchorOption::Now => "NOW",
            AnchorOption::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NOW"]
    }
}
impl AsRef<str> for AnchorOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A <code>TimeRangeFilter</code> filters values that are between two specified values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimeRangeFilter {
    /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
    #[doc(hidden)]
    pub filter_id: std::option::Option<std::string::String>,
    /// <p>The column that the filter is applied to.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>Determines whether the minimum value in the filter value range should be included in the filtered results.</p>
    #[doc(hidden)]
    pub include_minimum: std::option::Option<bool>,
    /// <p>Determines whether the maximum value in the filter value range should be included in the filtered results.</p>
    #[doc(hidden)]
    pub include_maximum: std::option::Option<bool>,
    /// <p>The minimum value for the filter value range.</p>
    #[doc(hidden)]
    pub range_minimum_value: std::option::Option<crate::model::TimeRangeFilterValue>,
    /// <p>The maximum value for the filter value range.</p>
    #[doc(hidden)]
    pub range_maximum_value: std::option::Option<crate::model::TimeRangeFilterValue>,
    /// <p>This option determines how null values should be treated when filtering data.</p>
    /// <ul>
    /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
    /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
    /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub null_option: std::option::Option<crate::model::FilterNullOption>,
    /// <p>The exclude period of the time range filter.</p>
    #[doc(hidden)]
    pub exclude_period_configuration: std::option::Option<crate::model::ExcludePeriodConfiguration>,
    /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
    #[doc(hidden)]
    pub time_granularity: std::option::Option<crate::model::TimeGranularity>,
}
impl TimeRangeFilter {
    /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
    pub fn filter_id(&self) -> std::option::Option<&str> {
        self.filter_id.as_deref()
    }
    /// <p>The column that the filter is applied to.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>Determines whether the minimum value in the filter value range should be included in the filtered results.</p>
    pub fn include_minimum(&self) -> std::option::Option<bool> {
        self.include_minimum
    }
    /// <p>Determines whether the maximum value in the filter value range should be included in the filtered results.</p>
    pub fn include_maximum(&self) -> std::option::Option<bool> {
        self.include_maximum
    }
    /// <p>The minimum value for the filter value range.</p>
    pub fn range_minimum_value(&self) -> std::option::Option<&crate::model::TimeRangeFilterValue> {
        self.range_minimum_value.as_ref()
    }
    /// <p>The maximum value for the filter value range.</p>
    pub fn range_maximum_value(&self) -> std::option::Option<&crate::model::TimeRangeFilterValue> {
        self.range_maximum_value.as_ref()
    }
    /// <p>This option determines how null values should be treated when filtering data.</p>
    /// <ul>
    /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
    /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
    /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
    /// </ul>
    pub fn null_option(&self) -> std::option::Option<&crate::model::FilterNullOption> {
        self.null_option.as_ref()
    }
    /// <p>The exclude period of the time range filter.</p>
    pub fn exclude_period_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ExcludePeriodConfiguration> {
        self.exclude_period_configuration.as_ref()
    }
    /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
    pub fn time_granularity(&self) -> std::option::Option<&crate::model::TimeGranularity> {
        self.time_granularity.as_ref()
    }
}
/// See [`TimeRangeFilter`](crate::model::TimeRangeFilter).
pub mod time_range_filter {

    /// A builder for [`TimeRangeFilter`](crate::model::TimeRangeFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_id: std::option::Option<std::string::String>,
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) include_minimum: std::option::Option<bool>,
        pub(crate) include_maximum: std::option::Option<bool>,
        pub(crate) range_minimum_value: std::option::Option<crate::model::TimeRangeFilterValue>,
        pub(crate) range_maximum_value: std::option::Option<crate::model::TimeRangeFilterValue>,
        pub(crate) null_option: std::option::Option<crate::model::FilterNullOption>,
        pub(crate) exclude_period_configuration:
            std::option::Option<crate::model::ExcludePeriodConfiguration>,
        pub(crate) time_granularity: std::option::Option<crate::model::TimeGranularity>,
    }
    impl Builder {
        /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
        pub fn filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_id = Some(input.into());
            self
        }
        /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
        pub fn set_filter_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.filter_id = input;
            self
        }
        /// <p>The column that the filter is applied to.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that the filter is applied to.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>Determines whether the minimum value in the filter value range should be included in the filtered results.</p>
        pub fn include_minimum(mut self, input: bool) -> Self {
            self.include_minimum = Some(input);
            self
        }
        /// <p>Determines whether the minimum value in the filter value range should be included in the filtered results.</p>
        pub fn set_include_minimum(mut self, input: std::option::Option<bool>) -> Self {
            self.include_minimum = input;
            self
        }
        /// <p>Determines whether the maximum value in the filter value range should be included in the filtered results.</p>
        pub fn include_maximum(mut self, input: bool) -> Self {
            self.include_maximum = Some(input);
            self
        }
        /// <p>Determines whether the maximum value in the filter value range should be included in the filtered results.</p>
        pub fn set_include_maximum(mut self, input: std::option::Option<bool>) -> Self {
            self.include_maximum = input;
            self
        }
        /// <p>The minimum value for the filter value range.</p>
        pub fn range_minimum_value(mut self, input: crate::model::TimeRangeFilterValue) -> Self {
            self.range_minimum_value = Some(input);
            self
        }
        /// <p>The minimum value for the filter value range.</p>
        pub fn set_range_minimum_value(
            mut self,
            input: std::option::Option<crate::model::TimeRangeFilterValue>,
        ) -> Self {
            self.range_minimum_value = input;
            self
        }
        /// <p>The maximum value for the filter value range.</p>
        pub fn range_maximum_value(mut self, input: crate::model::TimeRangeFilterValue) -> Self {
            self.range_maximum_value = Some(input);
            self
        }
        /// <p>The maximum value for the filter value range.</p>
        pub fn set_range_maximum_value(
            mut self,
            input: std::option::Option<crate::model::TimeRangeFilterValue>,
        ) -> Self {
            self.range_maximum_value = input;
            self
        }
        /// <p>This option determines how null values should be treated when filtering data.</p>
        /// <ul>
        /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
        /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
        /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
        /// </ul>
        pub fn null_option(mut self, input: crate::model::FilterNullOption) -> Self {
            self.null_option = Some(input);
            self
        }
        /// <p>This option determines how null values should be treated when filtering data.</p>
        /// <ul>
        /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
        /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
        /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
        /// </ul>
        pub fn set_null_option(
            mut self,
            input: std::option::Option<crate::model::FilterNullOption>,
        ) -> Self {
            self.null_option = input;
            self
        }
        /// <p>The exclude period of the time range filter.</p>
        pub fn exclude_period_configuration(
            mut self,
            input: crate::model::ExcludePeriodConfiguration,
        ) -> Self {
            self.exclude_period_configuration = Some(input);
            self
        }
        /// <p>The exclude period of the time range filter.</p>
        pub fn set_exclude_period_configuration(
            mut self,
            input: std::option::Option<crate::model::ExcludePeriodConfiguration>,
        ) -> Self {
            self.exclude_period_configuration = input;
            self
        }
        /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
        pub fn time_granularity(mut self, input: crate::model::TimeGranularity) -> Self {
            self.time_granularity = Some(input);
            self
        }
        /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
        pub fn set_time_granularity(
            mut self,
            input: std::option::Option<crate::model::TimeGranularity>,
        ) -> Self {
            self.time_granularity = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeRangeFilter`](crate::model::TimeRangeFilter).
        pub fn build(self) -> crate::model::TimeRangeFilter {
            crate::model::TimeRangeFilter {
                filter_id: self.filter_id,
                column: self.column,
                include_minimum: self.include_minimum,
                include_maximum: self.include_maximum,
                range_minimum_value: self.range_minimum_value,
                range_maximum_value: self.range_maximum_value,
                null_option: self.null_option,
                exclude_period_configuration: self.exclude_period_configuration,
                time_granularity: self.time_granularity,
            }
        }
    }
}
impl TimeRangeFilter {
    /// Creates a new builder-style object to manufacture [`TimeRangeFilter`](crate::model::TimeRangeFilter).
    pub fn builder() -> crate::model::time_range_filter::Builder {
        crate::model::time_range_filter::Builder::default()
    }
}

/// <p>The value of a time range filter.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimeRangeFilterValue {
    /// <p>The static input value.</p>
    #[doc(hidden)]
    pub static_value: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The rolling date input value.</p>
    #[doc(hidden)]
    pub rolling_date: std::option::Option<crate::model::RollingDateConfiguration>,
    /// <p>The parameter type input value.</p>
    #[doc(hidden)]
    pub parameter: std::option::Option<std::string::String>,
}
impl TimeRangeFilterValue {
    /// <p>The static input value.</p>
    pub fn static_value(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.static_value.as_ref()
    }
    /// <p>The rolling date input value.</p>
    pub fn rolling_date(&self) -> std::option::Option<&crate::model::RollingDateConfiguration> {
        self.rolling_date.as_ref()
    }
    /// <p>The parameter type input value.</p>
    pub fn parameter(&self) -> std::option::Option<&str> {
        self.parameter.as_deref()
    }
}
/// See [`TimeRangeFilterValue`](crate::model::TimeRangeFilterValue).
pub mod time_range_filter_value {

    /// A builder for [`TimeRangeFilterValue`](crate::model::TimeRangeFilterValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) static_value: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) rolling_date: std::option::Option<crate::model::RollingDateConfiguration>,
        pub(crate) parameter: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The static input value.</p>
        pub fn static_value(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.static_value = Some(input);
            self
        }
        /// <p>The static input value.</p>
        pub fn set_static_value(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.static_value = input;
            self
        }
        /// <p>The rolling date input value.</p>
        pub fn rolling_date(mut self, input: crate::model::RollingDateConfiguration) -> Self {
            self.rolling_date = Some(input);
            self
        }
        /// <p>The rolling date input value.</p>
        pub fn set_rolling_date(
            mut self,
            input: std::option::Option<crate::model::RollingDateConfiguration>,
        ) -> Self {
            self.rolling_date = input;
            self
        }
        /// <p>The parameter type input value.</p>
        pub fn parameter(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter = Some(input.into());
            self
        }
        /// <p>The parameter type input value.</p>
        pub fn set_parameter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.parameter = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeRangeFilterValue`](crate::model::TimeRangeFilterValue).
        pub fn build(self) -> crate::model::TimeRangeFilterValue {
            crate::model::TimeRangeFilterValue {
                static_value: self.static_value,
                rolling_date: self.rolling_date,
                parameter: self.parameter,
            }
        }
    }
}
impl TimeRangeFilterValue {
    /// Creates a new builder-style object to manufacture [`TimeRangeFilterValue`](crate::model::TimeRangeFilterValue).
    pub fn builder() -> crate::model::time_range_filter_value::Builder {
        crate::model::time_range_filter_value::Builder::default()
    }
}

/// <p>The rolling date configuration of a date time filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RollingDateConfiguration {
    /// <p>The data set that is used in the rolling date configuration.</p>
    #[doc(hidden)]
    pub data_set_identifier: std::option::Option<std::string::String>,
    /// <p>The expression of the rolling date configuration.</p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::string::String>,
}
impl RollingDateConfiguration {
    /// <p>The data set that is used in the rolling date configuration.</p>
    pub fn data_set_identifier(&self) -> std::option::Option<&str> {
        self.data_set_identifier.as_deref()
    }
    /// <p>The expression of the rolling date configuration.</p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
}
impl std::fmt::Debug for RollingDateConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RollingDateConfiguration");
        formatter.field("data_set_identifier", &self.data_set_identifier);
        formatter.field("expression", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`RollingDateConfiguration`](crate::model::RollingDateConfiguration).
pub mod rolling_date_configuration {

    /// A builder for [`RollingDateConfiguration`](crate::model::RollingDateConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) data_set_identifier: std::option::Option<std::string::String>,
        pub(crate) expression: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The data set that is used in the rolling date configuration.</p>
        pub fn data_set_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_set_identifier = Some(input.into());
            self
        }
        /// <p>The data set that is used in the rolling date configuration.</p>
        pub fn set_data_set_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_set_identifier = input;
            self
        }
        /// <p>The expression of the rolling date configuration.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>The expression of the rolling date configuration.</p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// Consumes the builder and constructs a [`RollingDateConfiguration`](crate::model::RollingDateConfiguration).
        pub fn build(self) -> crate::model::RollingDateConfiguration {
            crate::model::RollingDateConfiguration {
                data_set_identifier: self.data_set_identifier,
                expression: self.expression,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("data_set_identifier", &self.data_set_identifier);
            formatter.field("expression", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl RollingDateConfiguration {
    /// Creates a new builder-style object to manufacture [`RollingDateConfiguration`](crate::model::RollingDateConfiguration).
    pub fn builder() -> crate::model::rolling_date_configuration::Builder {
        crate::model::rolling_date_configuration::Builder::default()
    }
}

/// <p>A <code>TimeEqualityFilter</code> filters values that are equal to a given value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimeEqualityFilter {
    /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
    #[doc(hidden)]
    pub filter_id: std::option::Option<std::string::String>,
    /// <p>The column that the filter is applied to.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The value of a <code>TimeEquality</code> filter.</p>
    /// <p>This field is mutually exclusive to <code>ParameterName</code>.</p>
    #[doc(hidden)]
    pub value: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The parameter whose value should be used for the filter value.</p>
    /// <p>This field is mutually exclusive to <code>Value</code>.</p>
    #[doc(hidden)]
    pub parameter_name: std::option::Option<std::string::String>,
    /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
    #[doc(hidden)]
    pub time_granularity: std::option::Option<crate::model::TimeGranularity>,
}
impl TimeEqualityFilter {
    /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
    pub fn filter_id(&self) -> std::option::Option<&str> {
        self.filter_id.as_deref()
    }
    /// <p>The column that the filter is applied to.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>The value of a <code>TimeEquality</code> filter.</p>
    /// <p>This field is mutually exclusive to <code>ParameterName</code>.</p>
    pub fn value(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.value.as_ref()
    }
    /// <p>The parameter whose value should be used for the filter value.</p>
    /// <p>This field is mutually exclusive to <code>Value</code>.</p>
    pub fn parameter_name(&self) -> std::option::Option<&str> {
        self.parameter_name.as_deref()
    }
    /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
    pub fn time_granularity(&self) -> std::option::Option<&crate::model::TimeGranularity> {
        self.time_granularity.as_ref()
    }
}
/// See [`TimeEqualityFilter`](crate::model::TimeEqualityFilter).
pub mod time_equality_filter {

    /// A builder for [`TimeEqualityFilter`](crate::model::TimeEqualityFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_id: std::option::Option<std::string::String>,
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) value: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) parameter_name: std::option::Option<std::string::String>,
        pub(crate) time_granularity: std::option::Option<crate::model::TimeGranularity>,
    }
    impl Builder {
        /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
        pub fn filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_id = Some(input.into());
            self
        }
        /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
        pub fn set_filter_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.filter_id = input;
            self
        }
        /// <p>The column that the filter is applied to.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that the filter is applied to.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The value of a <code>TimeEquality</code> filter.</p>
        /// <p>This field is mutually exclusive to <code>ParameterName</code>.</p>
        pub fn value(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of a <code>TimeEquality</code> filter.</p>
        /// <p>This field is mutually exclusive to <code>ParameterName</code>.</p>
        pub fn set_value(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.value = input;
            self
        }
        /// <p>The parameter whose value should be used for the filter value.</p>
        /// <p>This field is mutually exclusive to <code>Value</code>.</p>
        pub fn parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_name = Some(input.into());
            self
        }
        /// <p>The parameter whose value should be used for the filter value.</p>
        /// <p>This field is mutually exclusive to <code>Value</code>.</p>
        pub fn set_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_name = input;
            self
        }
        /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
        pub fn time_granularity(mut self, input: crate::model::TimeGranularity) -> Self {
            self.time_granularity = Some(input);
            self
        }
        /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
        pub fn set_time_granularity(
            mut self,
            input: std::option::Option<crate::model::TimeGranularity>,
        ) -> Self {
            self.time_granularity = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeEqualityFilter`](crate::model::TimeEqualityFilter).
        pub fn build(self) -> crate::model::TimeEqualityFilter {
            crate::model::TimeEqualityFilter {
                filter_id: self.filter_id,
                column: self.column,
                value: self.value,
                parameter_name: self.parameter_name,
                time_granularity: self.time_granularity,
            }
        }
    }
}
impl TimeEqualityFilter {
    /// Creates a new builder-style object to manufacture [`TimeEqualityFilter`](crate::model::TimeEqualityFilter).
    pub fn builder() -> crate::model::time_equality_filter::Builder {
        crate::model::time_equality_filter::Builder::default()
    }
}

/// <p>A <code>NumericEqualityFilter</code> filters values that are equal to the specified value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NumericEqualityFilter {
    /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
    #[doc(hidden)]
    pub filter_id: std::option::Option<std::string::String>,
    /// <p>The column that the filter is applied to.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The input value.</p>
    #[doc(hidden)]
    pub value: std::option::Option<f64>,
    /// <p>Select all of the values. Null is not the assigned value of select all.</p>
    /// <ul>
    /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub select_all_options: std::option::Option<crate::model::NumericFilterSelectAllOptions>,
    /// <p>The match operator that is used to determine if a filter should be applied.</p>
    #[doc(hidden)]
    pub match_operator: std::option::Option<crate::model::NumericEqualityMatchOperator>,
    /// <p>The aggregation function of the filter.</p>
    #[doc(hidden)]
    pub aggregation_function: std::option::Option<crate::model::AggregationFunction>,
    /// <p>The parameter whose value should be used for the filter value.</p>
    #[doc(hidden)]
    pub parameter_name: std::option::Option<std::string::String>,
    /// <p>This option determines how null values should be treated when filtering data.</p>
    /// <ul>
    /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
    /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
    /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub null_option: std::option::Option<crate::model::FilterNullOption>,
}
impl NumericEqualityFilter {
    /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
    pub fn filter_id(&self) -> std::option::Option<&str> {
        self.filter_id.as_deref()
    }
    /// <p>The column that the filter is applied to.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>The input value.</p>
    pub fn value(&self) -> std::option::Option<f64> {
        self.value
    }
    /// <p>Select all of the values. Null is not the assigned value of select all.</p>
    /// <ul>
    /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
    /// </ul>
    pub fn select_all_options(
        &self,
    ) -> std::option::Option<&crate::model::NumericFilterSelectAllOptions> {
        self.select_all_options.as_ref()
    }
    /// <p>The match operator that is used to determine if a filter should be applied.</p>
    pub fn match_operator(
        &self,
    ) -> std::option::Option<&crate::model::NumericEqualityMatchOperator> {
        self.match_operator.as_ref()
    }
    /// <p>The aggregation function of the filter.</p>
    pub fn aggregation_function(&self) -> std::option::Option<&crate::model::AggregationFunction> {
        self.aggregation_function.as_ref()
    }
    /// <p>The parameter whose value should be used for the filter value.</p>
    pub fn parameter_name(&self) -> std::option::Option<&str> {
        self.parameter_name.as_deref()
    }
    /// <p>This option determines how null values should be treated when filtering data.</p>
    /// <ul>
    /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
    /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
    /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
    /// </ul>
    pub fn null_option(&self) -> std::option::Option<&crate::model::FilterNullOption> {
        self.null_option.as_ref()
    }
}
/// See [`NumericEqualityFilter`](crate::model::NumericEqualityFilter).
pub mod numeric_equality_filter {

    /// A builder for [`NumericEqualityFilter`](crate::model::NumericEqualityFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_id: std::option::Option<std::string::String>,
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) value: std::option::Option<f64>,
        pub(crate) select_all_options:
            std::option::Option<crate::model::NumericFilterSelectAllOptions>,
        pub(crate) match_operator: std::option::Option<crate::model::NumericEqualityMatchOperator>,
        pub(crate) aggregation_function: std::option::Option<crate::model::AggregationFunction>,
        pub(crate) parameter_name: std::option::Option<std::string::String>,
        pub(crate) null_option: std::option::Option<crate::model::FilterNullOption>,
    }
    impl Builder {
        /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
        pub fn filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_id = Some(input.into());
            self
        }
        /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
        pub fn set_filter_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.filter_id = input;
            self
        }
        /// <p>The column that the filter is applied to.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that the filter is applied to.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The input value.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The input value.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input;
            self
        }
        /// <p>Select all of the values. Null is not the assigned value of select all.</p>
        /// <ul>
        /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
        /// </ul>
        pub fn select_all_options(
            mut self,
            input: crate::model::NumericFilterSelectAllOptions,
        ) -> Self {
            self.select_all_options = Some(input);
            self
        }
        /// <p>Select all of the values. Null is not the assigned value of select all.</p>
        /// <ul>
        /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
        /// </ul>
        pub fn set_select_all_options(
            mut self,
            input: std::option::Option<crate::model::NumericFilterSelectAllOptions>,
        ) -> Self {
            self.select_all_options = input;
            self
        }
        /// <p>The match operator that is used to determine if a filter should be applied.</p>
        pub fn match_operator(mut self, input: crate::model::NumericEqualityMatchOperator) -> Self {
            self.match_operator = Some(input);
            self
        }
        /// <p>The match operator that is used to determine if a filter should be applied.</p>
        pub fn set_match_operator(
            mut self,
            input: std::option::Option<crate::model::NumericEqualityMatchOperator>,
        ) -> Self {
            self.match_operator = input;
            self
        }
        /// <p>The aggregation function of the filter.</p>
        pub fn aggregation_function(mut self, input: crate::model::AggregationFunction) -> Self {
            self.aggregation_function = Some(input);
            self
        }
        /// <p>The aggregation function of the filter.</p>
        pub fn set_aggregation_function(
            mut self,
            input: std::option::Option<crate::model::AggregationFunction>,
        ) -> Self {
            self.aggregation_function = input;
            self
        }
        /// <p>The parameter whose value should be used for the filter value.</p>
        pub fn parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_name = Some(input.into());
            self
        }
        /// <p>The parameter whose value should be used for the filter value.</p>
        pub fn set_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_name = input;
            self
        }
        /// <p>This option determines how null values should be treated when filtering data.</p>
        /// <ul>
        /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
        /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
        /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
        /// </ul>
        pub fn null_option(mut self, input: crate::model::FilterNullOption) -> Self {
            self.null_option = Some(input);
            self
        }
        /// <p>This option determines how null values should be treated when filtering data.</p>
        /// <ul>
        /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
        /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
        /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
        /// </ul>
        pub fn set_null_option(
            mut self,
            input: std::option::Option<crate::model::FilterNullOption>,
        ) -> Self {
            self.null_option = input;
            self
        }
        /// Consumes the builder and constructs a [`NumericEqualityFilter`](crate::model::NumericEqualityFilter).
        pub fn build(self) -> crate::model::NumericEqualityFilter {
            crate::model::NumericEqualityFilter {
                filter_id: self.filter_id,
                column: self.column,
                value: self.value,
                select_all_options: self.select_all_options,
                match_operator: self.match_operator,
                aggregation_function: self.aggregation_function,
                parameter_name: self.parameter_name,
                null_option: self.null_option,
            }
        }
    }
}
impl NumericEqualityFilter {
    /// Creates a new builder-style object to manufacture [`NumericEqualityFilter`](crate::model::NumericEqualityFilter).
    pub fn builder() -> crate::model::numeric_equality_filter::Builder {
        crate::model::numeric_equality_filter::Builder::default()
    }
}

/// When writing a match expression against `NumericEqualityMatchOperator`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let numericequalitymatchoperator = unimplemented!();
/// match numericequalitymatchoperator {
///     NumericEqualityMatchOperator::DoesNotEqual => { /* ... */ },
///     NumericEqualityMatchOperator::Equals => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `numericequalitymatchoperator` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NumericEqualityMatchOperator::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NumericEqualityMatchOperator::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NumericEqualityMatchOperator::NewFeature` is defined.
/// Specifically, when `numericequalitymatchoperator` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NumericEqualityMatchOperator::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NumericEqualityMatchOperator {
    #[allow(missing_docs)] // documentation missing in model
    DoesNotEqual,
    #[allow(missing_docs)] // documentation missing in model
    Equals,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NumericEqualityMatchOperator {
    fn from(s: &str) -> Self {
        match s {
            "DOES_NOT_EQUAL" => NumericEqualityMatchOperator::DoesNotEqual,
            "EQUALS" => NumericEqualityMatchOperator::Equals,
            other => NumericEqualityMatchOperator::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for NumericEqualityMatchOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NumericEqualityMatchOperator::from(s))
    }
}
impl NumericEqualityMatchOperator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NumericEqualityMatchOperator::DoesNotEqual => "DOES_NOT_EQUAL",
            NumericEqualityMatchOperator::Equals => "EQUALS",
            NumericEqualityMatchOperator::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DOES_NOT_EQUAL", "EQUALS"]
    }
}
impl AsRef<str> for NumericEqualityMatchOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `NumericFilterSelectAllOptions`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let numericfilterselectalloptions = unimplemented!();
/// match numericfilterselectalloptions {
///     NumericFilterSelectAllOptions::FilterAllValues => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `numericfilterselectalloptions` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NumericFilterSelectAllOptions::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NumericFilterSelectAllOptions::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NumericFilterSelectAllOptions::NewFeature` is defined.
/// Specifically, when `numericfilterselectalloptions` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NumericFilterSelectAllOptions::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NumericFilterSelectAllOptions {
    #[allow(missing_docs)] // documentation missing in model
    FilterAllValues,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NumericFilterSelectAllOptions {
    fn from(s: &str) -> Self {
        match s {
            "FILTER_ALL_VALUES" => NumericFilterSelectAllOptions::FilterAllValues,
            other => NumericFilterSelectAllOptions::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for NumericFilterSelectAllOptions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NumericFilterSelectAllOptions::from(s))
    }
}
impl NumericFilterSelectAllOptions {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NumericFilterSelectAllOptions::FilterAllValues => "FILTER_ALL_VALUES",
            NumericFilterSelectAllOptions::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FILTER_ALL_VALUES"]
    }
}
impl AsRef<str> for NumericFilterSelectAllOptions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A <code>NumericRangeFilter</code> filters values that are within the value range.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NumericRangeFilter {
    /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
    #[doc(hidden)]
    pub filter_id: std::option::Option<std::string::String>,
    /// <p>The column that the filter is applied to.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>Determines whether the minimum value in the filter value range should be included in the filtered results.</p>
    #[doc(hidden)]
    pub include_minimum: std::option::Option<bool>,
    /// <p>Determines whether the maximum value in the filter value range should be included in the filtered results.</p>
    #[doc(hidden)]
    pub include_maximum: std::option::Option<bool>,
    /// <p>The minimum value for the filter value range.</p>
    #[doc(hidden)]
    pub range_minimum: std::option::Option<crate::model::NumericRangeFilterValue>,
    /// <p>The maximum value for the filter value range.</p>
    #[doc(hidden)]
    pub range_maximum: std::option::Option<crate::model::NumericRangeFilterValue>,
    /// <p>Select all of the values. Null is not the assigned value of select all.</p>
    /// <ul>
    /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub select_all_options: std::option::Option<crate::model::NumericFilterSelectAllOptions>,
    /// <p>The aggregation function of the filter.</p>
    #[doc(hidden)]
    pub aggregation_function: std::option::Option<crate::model::AggregationFunction>,
    /// <p>This option determines how null values should be treated when filtering data.</p>
    /// <ul>
    /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
    /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
    /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub null_option: std::option::Option<crate::model::FilterNullOption>,
}
impl NumericRangeFilter {
    /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
    pub fn filter_id(&self) -> std::option::Option<&str> {
        self.filter_id.as_deref()
    }
    /// <p>The column that the filter is applied to.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>Determines whether the minimum value in the filter value range should be included in the filtered results.</p>
    pub fn include_minimum(&self) -> std::option::Option<bool> {
        self.include_minimum
    }
    /// <p>Determines whether the maximum value in the filter value range should be included in the filtered results.</p>
    pub fn include_maximum(&self) -> std::option::Option<bool> {
        self.include_maximum
    }
    /// <p>The minimum value for the filter value range.</p>
    pub fn range_minimum(&self) -> std::option::Option<&crate::model::NumericRangeFilterValue> {
        self.range_minimum.as_ref()
    }
    /// <p>The maximum value for the filter value range.</p>
    pub fn range_maximum(&self) -> std::option::Option<&crate::model::NumericRangeFilterValue> {
        self.range_maximum.as_ref()
    }
    /// <p>Select all of the values. Null is not the assigned value of select all.</p>
    /// <ul>
    /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
    /// </ul>
    pub fn select_all_options(
        &self,
    ) -> std::option::Option<&crate::model::NumericFilterSelectAllOptions> {
        self.select_all_options.as_ref()
    }
    /// <p>The aggregation function of the filter.</p>
    pub fn aggregation_function(&self) -> std::option::Option<&crate::model::AggregationFunction> {
        self.aggregation_function.as_ref()
    }
    /// <p>This option determines how null values should be treated when filtering data.</p>
    /// <ul>
    /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
    /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
    /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
    /// </ul>
    pub fn null_option(&self) -> std::option::Option<&crate::model::FilterNullOption> {
        self.null_option.as_ref()
    }
}
/// See [`NumericRangeFilter`](crate::model::NumericRangeFilter).
pub mod numeric_range_filter {

    /// A builder for [`NumericRangeFilter`](crate::model::NumericRangeFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_id: std::option::Option<std::string::String>,
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) include_minimum: std::option::Option<bool>,
        pub(crate) include_maximum: std::option::Option<bool>,
        pub(crate) range_minimum: std::option::Option<crate::model::NumericRangeFilterValue>,
        pub(crate) range_maximum: std::option::Option<crate::model::NumericRangeFilterValue>,
        pub(crate) select_all_options:
            std::option::Option<crate::model::NumericFilterSelectAllOptions>,
        pub(crate) aggregation_function: std::option::Option<crate::model::AggregationFunction>,
        pub(crate) null_option: std::option::Option<crate::model::FilterNullOption>,
    }
    impl Builder {
        /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
        pub fn filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_id = Some(input.into());
            self
        }
        /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
        pub fn set_filter_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.filter_id = input;
            self
        }
        /// <p>The column that the filter is applied to.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that the filter is applied to.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>Determines whether the minimum value in the filter value range should be included in the filtered results.</p>
        pub fn include_minimum(mut self, input: bool) -> Self {
            self.include_minimum = Some(input);
            self
        }
        /// <p>Determines whether the minimum value in the filter value range should be included in the filtered results.</p>
        pub fn set_include_minimum(mut self, input: std::option::Option<bool>) -> Self {
            self.include_minimum = input;
            self
        }
        /// <p>Determines whether the maximum value in the filter value range should be included in the filtered results.</p>
        pub fn include_maximum(mut self, input: bool) -> Self {
            self.include_maximum = Some(input);
            self
        }
        /// <p>Determines whether the maximum value in the filter value range should be included in the filtered results.</p>
        pub fn set_include_maximum(mut self, input: std::option::Option<bool>) -> Self {
            self.include_maximum = input;
            self
        }
        /// <p>The minimum value for the filter value range.</p>
        pub fn range_minimum(mut self, input: crate::model::NumericRangeFilterValue) -> Self {
            self.range_minimum = Some(input);
            self
        }
        /// <p>The minimum value for the filter value range.</p>
        pub fn set_range_minimum(
            mut self,
            input: std::option::Option<crate::model::NumericRangeFilterValue>,
        ) -> Self {
            self.range_minimum = input;
            self
        }
        /// <p>The maximum value for the filter value range.</p>
        pub fn range_maximum(mut self, input: crate::model::NumericRangeFilterValue) -> Self {
            self.range_maximum = Some(input);
            self
        }
        /// <p>The maximum value for the filter value range.</p>
        pub fn set_range_maximum(
            mut self,
            input: std::option::Option<crate::model::NumericRangeFilterValue>,
        ) -> Self {
            self.range_maximum = input;
            self
        }
        /// <p>Select all of the values. Null is not the assigned value of select all.</p>
        /// <ul>
        /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
        /// </ul>
        pub fn select_all_options(
            mut self,
            input: crate::model::NumericFilterSelectAllOptions,
        ) -> Self {
            self.select_all_options = Some(input);
            self
        }
        /// <p>Select all of the values. Null is not the assigned value of select all.</p>
        /// <ul>
        /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
        /// </ul>
        pub fn set_select_all_options(
            mut self,
            input: std::option::Option<crate::model::NumericFilterSelectAllOptions>,
        ) -> Self {
            self.select_all_options = input;
            self
        }
        /// <p>The aggregation function of the filter.</p>
        pub fn aggregation_function(mut self, input: crate::model::AggregationFunction) -> Self {
            self.aggregation_function = Some(input);
            self
        }
        /// <p>The aggregation function of the filter.</p>
        pub fn set_aggregation_function(
            mut self,
            input: std::option::Option<crate::model::AggregationFunction>,
        ) -> Self {
            self.aggregation_function = input;
            self
        }
        /// <p>This option determines how null values should be treated when filtering data.</p>
        /// <ul>
        /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
        /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
        /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
        /// </ul>
        pub fn null_option(mut self, input: crate::model::FilterNullOption) -> Self {
            self.null_option = Some(input);
            self
        }
        /// <p>This option determines how null values should be treated when filtering data.</p>
        /// <ul>
        /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
        /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
        /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
        /// </ul>
        pub fn set_null_option(
            mut self,
            input: std::option::Option<crate::model::FilterNullOption>,
        ) -> Self {
            self.null_option = input;
            self
        }
        /// Consumes the builder and constructs a [`NumericRangeFilter`](crate::model::NumericRangeFilter).
        pub fn build(self) -> crate::model::NumericRangeFilter {
            crate::model::NumericRangeFilter {
                filter_id: self.filter_id,
                column: self.column,
                include_minimum: self.include_minimum,
                include_maximum: self.include_maximum,
                range_minimum: self.range_minimum,
                range_maximum: self.range_maximum,
                select_all_options: self.select_all_options,
                aggregation_function: self.aggregation_function,
                null_option: self.null_option,
            }
        }
    }
}
impl NumericRangeFilter {
    /// Creates a new builder-style object to manufacture [`NumericRangeFilter`](crate::model::NumericRangeFilter).
    pub fn builder() -> crate::model::numeric_range_filter::Builder {
        crate::model::numeric_range_filter::Builder::default()
    }
}

/// <p>The value input pf the numeric range filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NumericRangeFilterValue {
    /// <p>The static value of the numeric range filter.</p>
    #[doc(hidden)]
    pub static_value: std::option::Option<f64>,
    /// <p>The parameter that is used in the numeric range.</p>
    #[doc(hidden)]
    pub parameter: std::option::Option<std::string::String>,
}
impl NumericRangeFilterValue {
    /// <p>The static value of the numeric range filter.</p>
    pub fn static_value(&self) -> std::option::Option<f64> {
        self.static_value
    }
    /// <p>The parameter that is used in the numeric range.</p>
    pub fn parameter(&self) -> std::option::Option<&str> {
        self.parameter.as_deref()
    }
}
/// See [`NumericRangeFilterValue`](crate::model::NumericRangeFilterValue).
pub mod numeric_range_filter_value {

    /// A builder for [`NumericRangeFilterValue`](crate::model::NumericRangeFilterValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) static_value: std::option::Option<f64>,
        pub(crate) parameter: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The static value of the numeric range filter.</p>
        pub fn static_value(mut self, input: f64) -> Self {
            self.static_value = Some(input);
            self
        }
        /// <p>The static value of the numeric range filter.</p>
        pub fn set_static_value(mut self, input: std::option::Option<f64>) -> Self {
            self.static_value = input;
            self
        }
        /// <p>The parameter that is used in the numeric range.</p>
        pub fn parameter(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter = Some(input.into());
            self
        }
        /// <p>The parameter that is used in the numeric range.</p>
        pub fn set_parameter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.parameter = input;
            self
        }
        /// Consumes the builder and constructs a [`NumericRangeFilterValue`](crate::model::NumericRangeFilterValue).
        pub fn build(self) -> crate::model::NumericRangeFilterValue {
            crate::model::NumericRangeFilterValue {
                static_value: self.static_value,
                parameter: self.parameter,
            }
        }
    }
}
impl NumericRangeFilterValue {
    /// Creates a new builder-style object to manufacture [`NumericRangeFilterValue`](crate::model::NumericRangeFilterValue).
    pub fn builder() -> crate::model::numeric_range_filter_value::Builder {
        crate::model::numeric_range_filter_value::Builder::default()
    }
}

/// <p>A <code>CategoryFilter</code> filters text values.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/add-a-text-filter-data-prep.html">Adding text filters</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CategoryFilter {
    /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
    #[doc(hidden)]
    pub filter_id: std::option::Option<std::string::String>,
    /// <p>The column that the filter is applied to.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The configuration for a <code>CategoryFilter</code>.</p>
    #[doc(hidden)]
    pub configuration: std::option::Option<crate::model::CategoryFilterConfiguration>,
}
impl CategoryFilter {
    /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
    pub fn filter_id(&self) -> std::option::Option<&str> {
        self.filter_id.as_deref()
    }
    /// <p>The column that the filter is applied to.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>The configuration for a <code>CategoryFilter</code>.</p>
    pub fn configuration(&self) -> std::option::Option<&crate::model::CategoryFilterConfiguration> {
        self.configuration.as_ref()
    }
}
/// See [`CategoryFilter`](crate::model::CategoryFilter).
pub mod category_filter {

    /// A builder for [`CategoryFilter`](crate::model::CategoryFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_id: std::option::Option<std::string::String>,
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) configuration: std::option::Option<crate::model::CategoryFilterConfiguration>,
    }
    impl Builder {
        /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
        pub fn filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_id = Some(input.into());
            self
        }
        /// <p>An identifier that uniquely identifies a filter within a dashboard, analysis, or template.</p>
        pub fn set_filter_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.filter_id = input;
            self
        }
        /// <p>The column that the filter is applied to.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that the filter is applied to.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The configuration for a <code>CategoryFilter</code>.</p>
        pub fn configuration(mut self, input: crate::model::CategoryFilterConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>The configuration for a <code>CategoryFilter</code>.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::CategoryFilterConfiguration>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`CategoryFilter`](crate::model::CategoryFilter).
        pub fn build(self) -> crate::model::CategoryFilter {
            crate::model::CategoryFilter {
                filter_id: self.filter_id,
                column: self.column,
                configuration: self.configuration,
            }
        }
    }
}
impl CategoryFilter {
    /// Creates a new builder-style object to manufacture [`CategoryFilter`](crate::model::CategoryFilter).
    pub fn builder() -> crate::model::category_filter::Builder {
        crate::model::category_filter::Builder::default()
    }
}

/// <p>The configuration for a <code>CategoryFilter</code>.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CategoryFilterConfiguration {
    /// <p>A list of filter configurations. In the Amazon QuickSight console, this filter type is called a filter list.</p>
    #[doc(hidden)]
    pub filter_list_configuration: std::option::Option<crate::model::FilterListConfiguration>,
    /// <p>A list of custom filter values. In the Amazon QuickSight console, this filter type is called a custom filter list.</p>
    #[doc(hidden)]
    pub custom_filter_list_configuration:
        std::option::Option<crate::model::CustomFilterListConfiguration>,
    /// <p>A custom filter that filters based on a single value. This filter can be partially matched.</p>
    #[doc(hidden)]
    pub custom_filter_configuration: std::option::Option<crate::model::CustomFilterConfiguration>,
}
impl CategoryFilterConfiguration {
    /// <p>A list of filter configurations. In the Amazon QuickSight console, this filter type is called a filter list.</p>
    pub fn filter_list_configuration(
        &self,
    ) -> std::option::Option<&crate::model::FilterListConfiguration> {
        self.filter_list_configuration.as_ref()
    }
    /// <p>A list of custom filter values. In the Amazon QuickSight console, this filter type is called a custom filter list.</p>
    pub fn custom_filter_list_configuration(
        &self,
    ) -> std::option::Option<&crate::model::CustomFilterListConfiguration> {
        self.custom_filter_list_configuration.as_ref()
    }
    /// <p>A custom filter that filters based on a single value. This filter can be partially matched.</p>
    pub fn custom_filter_configuration(
        &self,
    ) -> std::option::Option<&crate::model::CustomFilterConfiguration> {
        self.custom_filter_configuration.as_ref()
    }
}
/// See [`CategoryFilterConfiguration`](crate::model::CategoryFilterConfiguration).
pub mod category_filter_configuration {

    /// A builder for [`CategoryFilterConfiguration`](crate::model::CategoryFilterConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_list_configuration:
            std::option::Option<crate::model::FilterListConfiguration>,
        pub(crate) custom_filter_list_configuration:
            std::option::Option<crate::model::CustomFilterListConfiguration>,
        pub(crate) custom_filter_configuration:
            std::option::Option<crate::model::CustomFilterConfiguration>,
    }
    impl Builder {
        /// <p>A list of filter configurations. In the Amazon QuickSight console, this filter type is called a filter list.</p>
        pub fn filter_list_configuration(
            mut self,
            input: crate::model::FilterListConfiguration,
        ) -> Self {
            self.filter_list_configuration = Some(input);
            self
        }
        /// <p>A list of filter configurations. In the Amazon QuickSight console, this filter type is called a filter list.</p>
        pub fn set_filter_list_configuration(
            mut self,
            input: std::option::Option<crate::model::FilterListConfiguration>,
        ) -> Self {
            self.filter_list_configuration = input;
            self
        }
        /// <p>A list of custom filter values. In the Amazon QuickSight console, this filter type is called a custom filter list.</p>
        pub fn custom_filter_list_configuration(
            mut self,
            input: crate::model::CustomFilterListConfiguration,
        ) -> Self {
            self.custom_filter_list_configuration = Some(input);
            self
        }
        /// <p>A list of custom filter values. In the Amazon QuickSight console, this filter type is called a custom filter list.</p>
        pub fn set_custom_filter_list_configuration(
            mut self,
            input: std::option::Option<crate::model::CustomFilterListConfiguration>,
        ) -> Self {
            self.custom_filter_list_configuration = input;
            self
        }
        /// <p>A custom filter that filters based on a single value. This filter can be partially matched.</p>
        pub fn custom_filter_configuration(
            mut self,
            input: crate::model::CustomFilterConfiguration,
        ) -> Self {
            self.custom_filter_configuration = Some(input);
            self
        }
        /// <p>A custom filter that filters based on a single value. This filter can be partially matched.</p>
        pub fn set_custom_filter_configuration(
            mut self,
            input: std::option::Option<crate::model::CustomFilterConfiguration>,
        ) -> Self {
            self.custom_filter_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`CategoryFilterConfiguration`](crate::model::CategoryFilterConfiguration).
        pub fn build(self) -> crate::model::CategoryFilterConfiguration {
            crate::model::CategoryFilterConfiguration {
                filter_list_configuration: self.filter_list_configuration,
                custom_filter_list_configuration: self.custom_filter_list_configuration,
                custom_filter_configuration: self.custom_filter_configuration,
            }
        }
    }
}
impl CategoryFilterConfiguration {
    /// Creates a new builder-style object to manufacture [`CategoryFilterConfiguration`](crate::model::CategoryFilterConfiguration).
    pub fn builder() -> crate::model::category_filter_configuration::Builder {
        crate::model::category_filter_configuration::Builder::default()
    }
}

/// <p>A custom filter that filters based on a single value. This filter can be partially matched.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomFilterConfiguration {
    /// <p>The match operator that is used to determine if a filter should be applied.</p>
    #[doc(hidden)]
    pub match_operator: std::option::Option<crate::model::CategoryFilterMatchOperator>,
    /// <p>The category value for the filter.</p>
    /// <p>This field is mutually exclusive to <code>ParameterName</code>.</p>
    #[doc(hidden)]
    pub category_value: std::option::Option<std::string::String>,
    /// <p>Select all of the values. Null is not the assigned value of select all.</p>
    /// <ul>
    /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub select_all_options: std::option::Option<crate::model::CategoryFilterSelectAllOptions>,
    /// <p>The parameter whose value should be used for the filter value.</p>
    /// <p>This field is mutually exclusive to <code>CategoryValue</code>.</p>
    #[doc(hidden)]
    pub parameter_name: std::option::Option<std::string::String>,
    /// <p>This option determines how null values should be treated when filtering data.</p>
    /// <ul>
    /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
    /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
    /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub null_option: std::option::Option<crate::model::FilterNullOption>,
}
impl CustomFilterConfiguration {
    /// <p>The match operator that is used to determine if a filter should be applied.</p>
    pub fn match_operator(
        &self,
    ) -> std::option::Option<&crate::model::CategoryFilterMatchOperator> {
        self.match_operator.as_ref()
    }
    /// <p>The category value for the filter.</p>
    /// <p>This field is mutually exclusive to <code>ParameterName</code>.</p>
    pub fn category_value(&self) -> std::option::Option<&str> {
        self.category_value.as_deref()
    }
    /// <p>Select all of the values. Null is not the assigned value of select all.</p>
    /// <ul>
    /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
    /// </ul>
    pub fn select_all_options(
        &self,
    ) -> std::option::Option<&crate::model::CategoryFilterSelectAllOptions> {
        self.select_all_options.as_ref()
    }
    /// <p>The parameter whose value should be used for the filter value.</p>
    /// <p>This field is mutually exclusive to <code>CategoryValue</code>.</p>
    pub fn parameter_name(&self) -> std::option::Option<&str> {
        self.parameter_name.as_deref()
    }
    /// <p>This option determines how null values should be treated when filtering data.</p>
    /// <ul>
    /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
    /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
    /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
    /// </ul>
    pub fn null_option(&self) -> std::option::Option<&crate::model::FilterNullOption> {
        self.null_option.as_ref()
    }
}
/// See [`CustomFilterConfiguration`](crate::model::CustomFilterConfiguration).
pub mod custom_filter_configuration {

    /// A builder for [`CustomFilterConfiguration`](crate::model::CustomFilterConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) match_operator: std::option::Option<crate::model::CategoryFilterMatchOperator>,
        pub(crate) category_value: std::option::Option<std::string::String>,
        pub(crate) select_all_options:
            std::option::Option<crate::model::CategoryFilterSelectAllOptions>,
        pub(crate) parameter_name: std::option::Option<std::string::String>,
        pub(crate) null_option: std::option::Option<crate::model::FilterNullOption>,
    }
    impl Builder {
        /// <p>The match operator that is used to determine if a filter should be applied.</p>
        pub fn match_operator(mut self, input: crate::model::CategoryFilterMatchOperator) -> Self {
            self.match_operator = Some(input);
            self
        }
        /// <p>The match operator that is used to determine if a filter should be applied.</p>
        pub fn set_match_operator(
            mut self,
            input: std::option::Option<crate::model::CategoryFilterMatchOperator>,
        ) -> Self {
            self.match_operator = input;
            self
        }
        /// <p>The category value for the filter.</p>
        /// <p>This field is mutually exclusive to <code>ParameterName</code>.</p>
        pub fn category_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.category_value = Some(input.into());
            self
        }
        /// <p>The category value for the filter.</p>
        /// <p>This field is mutually exclusive to <code>ParameterName</code>.</p>
        pub fn set_category_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.category_value = input;
            self
        }
        /// <p>Select all of the values. Null is not the assigned value of select all.</p>
        /// <ul>
        /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
        /// </ul>
        pub fn select_all_options(
            mut self,
            input: crate::model::CategoryFilterSelectAllOptions,
        ) -> Self {
            self.select_all_options = Some(input);
            self
        }
        /// <p>Select all of the values. Null is not the assigned value of select all.</p>
        /// <ul>
        /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
        /// </ul>
        pub fn set_select_all_options(
            mut self,
            input: std::option::Option<crate::model::CategoryFilterSelectAllOptions>,
        ) -> Self {
            self.select_all_options = input;
            self
        }
        /// <p>The parameter whose value should be used for the filter value.</p>
        /// <p>This field is mutually exclusive to <code>CategoryValue</code>.</p>
        pub fn parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_name = Some(input.into());
            self
        }
        /// <p>The parameter whose value should be used for the filter value.</p>
        /// <p>This field is mutually exclusive to <code>CategoryValue</code>.</p>
        pub fn set_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_name = input;
            self
        }
        /// <p>This option determines how null values should be treated when filtering data.</p>
        /// <ul>
        /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
        /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
        /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
        /// </ul>
        pub fn null_option(mut self, input: crate::model::FilterNullOption) -> Self {
            self.null_option = Some(input);
            self
        }
        /// <p>This option determines how null values should be treated when filtering data.</p>
        /// <ul>
        /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
        /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
        /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
        /// </ul>
        pub fn set_null_option(
            mut self,
            input: std::option::Option<crate::model::FilterNullOption>,
        ) -> Self {
            self.null_option = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomFilterConfiguration`](crate::model::CustomFilterConfiguration).
        pub fn build(self) -> crate::model::CustomFilterConfiguration {
            crate::model::CustomFilterConfiguration {
                match_operator: self.match_operator,
                category_value: self.category_value,
                select_all_options: self.select_all_options,
                parameter_name: self.parameter_name,
                null_option: self.null_option,
            }
        }
    }
}
impl CustomFilterConfiguration {
    /// Creates a new builder-style object to manufacture [`CustomFilterConfiguration`](crate::model::CustomFilterConfiguration).
    pub fn builder() -> crate::model::custom_filter_configuration::Builder {
        crate::model::custom_filter_configuration::Builder::default()
    }
}

/// When writing a match expression against `CategoryFilterSelectAllOptions`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let categoryfilterselectalloptions = unimplemented!();
/// match categoryfilterselectalloptions {
///     CategoryFilterSelectAllOptions::FilterAllValues => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `categoryfilterselectalloptions` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CategoryFilterSelectAllOptions::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CategoryFilterSelectAllOptions::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CategoryFilterSelectAllOptions::NewFeature` is defined.
/// Specifically, when `categoryfilterselectalloptions` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CategoryFilterSelectAllOptions::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CategoryFilterSelectAllOptions {
    #[allow(missing_docs)] // documentation missing in model
    FilterAllValues,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CategoryFilterSelectAllOptions {
    fn from(s: &str) -> Self {
        match s {
            "FILTER_ALL_VALUES" => CategoryFilterSelectAllOptions::FilterAllValues,
            other => CategoryFilterSelectAllOptions::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for CategoryFilterSelectAllOptions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CategoryFilterSelectAllOptions::from(s))
    }
}
impl CategoryFilterSelectAllOptions {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CategoryFilterSelectAllOptions::FilterAllValues => "FILTER_ALL_VALUES",
            CategoryFilterSelectAllOptions::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FILTER_ALL_VALUES"]
    }
}
impl AsRef<str> for CategoryFilterSelectAllOptions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `CategoryFilterMatchOperator`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let categoryfiltermatchoperator = unimplemented!();
/// match categoryfiltermatchoperator {
///     CategoryFilterMatchOperator::Contains => { /* ... */ },
///     CategoryFilterMatchOperator::DoesNotContain => { /* ... */ },
///     CategoryFilterMatchOperator::DoesNotEqual => { /* ... */ },
///     CategoryFilterMatchOperator::EndsWith => { /* ... */ },
///     CategoryFilterMatchOperator::Equals => { /* ... */ },
///     CategoryFilterMatchOperator::StartsWith => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `categoryfiltermatchoperator` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CategoryFilterMatchOperator::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CategoryFilterMatchOperator::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CategoryFilterMatchOperator::NewFeature` is defined.
/// Specifically, when `categoryfiltermatchoperator` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CategoryFilterMatchOperator::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CategoryFilterMatchOperator {
    #[allow(missing_docs)] // documentation missing in model
    Contains,
    #[allow(missing_docs)] // documentation missing in model
    DoesNotContain,
    #[allow(missing_docs)] // documentation missing in model
    DoesNotEqual,
    #[allow(missing_docs)] // documentation missing in model
    EndsWith,
    #[allow(missing_docs)] // documentation missing in model
    Equals,
    #[allow(missing_docs)] // documentation missing in model
    StartsWith,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CategoryFilterMatchOperator {
    fn from(s: &str) -> Self {
        match s {
            "CONTAINS" => CategoryFilterMatchOperator::Contains,
            "DOES_NOT_CONTAIN" => CategoryFilterMatchOperator::DoesNotContain,
            "DOES_NOT_EQUAL" => CategoryFilterMatchOperator::DoesNotEqual,
            "ENDS_WITH" => CategoryFilterMatchOperator::EndsWith,
            "EQUALS" => CategoryFilterMatchOperator::Equals,
            "STARTS_WITH" => CategoryFilterMatchOperator::StartsWith,
            other => CategoryFilterMatchOperator::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for CategoryFilterMatchOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CategoryFilterMatchOperator::from(s))
    }
}
impl CategoryFilterMatchOperator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CategoryFilterMatchOperator::Contains => "CONTAINS",
            CategoryFilterMatchOperator::DoesNotContain => "DOES_NOT_CONTAIN",
            CategoryFilterMatchOperator::DoesNotEqual => "DOES_NOT_EQUAL",
            CategoryFilterMatchOperator::EndsWith => "ENDS_WITH",
            CategoryFilterMatchOperator::Equals => "EQUALS",
            CategoryFilterMatchOperator::StartsWith => "STARTS_WITH",
            CategoryFilterMatchOperator::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CONTAINS",
            "DOES_NOT_CONTAIN",
            "DOES_NOT_EQUAL",
            "ENDS_WITH",
            "EQUALS",
            "STARTS_WITH",
        ]
    }
}
impl AsRef<str> for CategoryFilterMatchOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A list of custom filter values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomFilterListConfiguration {
    /// <p>The match operator that is used to determine if a filter should be applied.</p>
    #[doc(hidden)]
    pub match_operator: std::option::Option<crate::model::CategoryFilterMatchOperator>,
    /// <p>The list of category values for the filter.</p>
    #[doc(hidden)]
    pub category_values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Select all of the values. Null is not the assigned value of select all.</p>
    /// <ul>
    /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub select_all_options: std::option::Option<crate::model::CategoryFilterSelectAllOptions>,
    /// <p>This option determines how null values should be treated when filtering data.</p>
    /// <ul>
    /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
    /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
    /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub null_option: std::option::Option<crate::model::FilterNullOption>,
}
impl CustomFilterListConfiguration {
    /// <p>The match operator that is used to determine if a filter should be applied.</p>
    pub fn match_operator(
        &self,
    ) -> std::option::Option<&crate::model::CategoryFilterMatchOperator> {
        self.match_operator.as_ref()
    }
    /// <p>The list of category values for the filter.</p>
    pub fn category_values(&self) -> std::option::Option<&[std::string::String]> {
        self.category_values.as_deref()
    }
    /// <p>Select all of the values. Null is not the assigned value of select all.</p>
    /// <ul>
    /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
    /// </ul>
    pub fn select_all_options(
        &self,
    ) -> std::option::Option<&crate::model::CategoryFilterSelectAllOptions> {
        self.select_all_options.as_ref()
    }
    /// <p>This option determines how null values should be treated when filtering data.</p>
    /// <ul>
    /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
    /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
    /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
    /// </ul>
    pub fn null_option(&self) -> std::option::Option<&crate::model::FilterNullOption> {
        self.null_option.as_ref()
    }
}
/// See [`CustomFilterListConfiguration`](crate::model::CustomFilterListConfiguration).
pub mod custom_filter_list_configuration {

    /// A builder for [`CustomFilterListConfiguration`](crate::model::CustomFilterListConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) match_operator: std::option::Option<crate::model::CategoryFilterMatchOperator>,
        pub(crate) category_values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) select_all_options:
            std::option::Option<crate::model::CategoryFilterSelectAllOptions>,
        pub(crate) null_option: std::option::Option<crate::model::FilterNullOption>,
    }
    impl Builder {
        /// <p>The match operator that is used to determine if a filter should be applied.</p>
        pub fn match_operator(mut self, input: crate::model::CategoryFilterMatchOperator) -> Self {
            self.match_operator = Some(input);
            self
        }
        /// <p>The match operator that is used to determine if a filter should be applied.</p>
        pub fn set_match_operator(
            mut self,
            input: std::option::Option<crate::model::CategoryFilterMatchOperator>,
        ) -> Self {
            self.match_operator = input;
            self
        }
        /// Appends an item to `category_values`.
        ///
        /// To override the contents of this collection use [`set_category_values`](Self::set_category_values).
        ///
        /// <p>The list of category values for the filter.</p>
        pub fn category_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.category_values.unwrap_or_default();
            v.push(input.into());
            self.category_values = Some(v);
            self
        }
        /// <p>The list of category values for the filter.</p>
        pub fn set_category_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.category_values = input;
            self
        }
        /// <p>Select all of the values. Null is not the assigned value of select all.</p>
        /// <ul>
        /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
        /// </ul>
        pub fn select_all_options(
            mut self,
            input: crate::model::CategoryFilterSelectAllOptions,
        ) -> Self {
            self.select_all_options = Some(input);
            self
        }
        /// <p>Select all of the values. Null is not the assigned value of select all.</p>
        /// <ul>
        /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
        /// </ul>
        pub fn set_select_all_options(
            mut self,
            input: std::option::Option<crate::model::CategoryFilterSelectAllOptions>,
        ) -> Self {
            self.select_all_options = input;
            self
        }
        /// <p>This option determines how null values should be treated when filtering data.</p>
        /// <ul>
        /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
        /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
        /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
        /// </ul>
        pub fn null_option(mut self, input: crate::model::FilterNullOption) -> Self {
            self.null_option = Some(input);
            self
        }
        /// <p>This option determines how null values should be treated when filtering data.</p>
        /// <ul>
        /// <li> <p> <code>ALL_VALUES</code>: Include null values in filtered results.</p> </li>
        /// <li> <p> <code>NULLS_ONLY</code>: Only include null values in filtered results.</p> </li>
        /// <li> <p> <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.</p> </li>
        /// </ul>
        pub fn set_null_option(
            mut self,
            input: std::option::Option<crate::model::FilterNullOption>,
        ) -> Self {
            self.null_option = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomFilterListConfiguration`](crate::model::CustomFilterListConfiguration).
        pub fn build(self) -> crate::model::CustomFilterListConfiguration {
            crate::model::CustomFilterListConfiguration {
                match_operator: self.match_operator,
                category_values: self.category_values,
                select_all_options: self.select_all_options,
                null_option: self.null_option,
            }
        }
    }
}
impl CustomFilterListConfiguration {
    /// Creates a new builder-style object to manufacture [`CustomFilterListConfiguration`](crate::model::CustomFilterListConfiguration).
    pub fn builder() -> crate::model::custom_filter_list_configuration::Builder {
        crate::model::custom_filter_list_configuration::Builder::default()
    }
}

/// <p>A list of filter configurations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterListConfiguration {
    /// <p>The match operator that is used to determine if a filter should be applied.</p>
    #[doc(hidden)]
    pub match_operator: std::option::Option<crate::model::CategoryFilterMatchOperator>,
    /// <p>The list of category values for the filter.</p>
    #[doc(hidden)]
    pub category_values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Select all of the values. Null is not the assigned value of select all.</p>
    /// <ul>
    /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub select_all_options: std::option::Option<crate::model::CategoryFilterSelectAllOptions>,
}
impl FilterListConfiguration {
    /// <p>The match operator that is used to determine if a filter should be applied.</p>
    pub fn match_operator(
        &self,
    ) -> std::option::Option<&crate::model::CategoryFilterMatchOperator> {
        self.match_operator.as_ref()
    }
    /// <p>The list of category values for the filter.</p>
    pub fn category_values(&self) -> std::option::Option<&[std::string::String]> {
        self.category_values.as_deref()
    }
    /// <p>Select all of the values. Null is not the assigned value of select all.</p>
    /// <ul>
    /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
    /// </ul>
    pub fn select_all_options(
        &self,
    ) -> std::option::Option<&crate::model::CategoryFilterSelectAllOptions> {
        self.select_all_options.as_ref()
    }
}
/// See [`FilterListConfiguration`](crate::model::FilterListConfiguration).
pub mod filter_list_configuration {

    /// A builder for [`FilterListConfiguration`](crate::model::FilterListConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) match_operator: std::option::Option<crate::model::CategoryFilterMatchOperator>,
        pub(crate) category_values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) select_all_options:
            std::option::Option<crate::model::CategoryFilterSelectAllOptions>,
    }
    impl Builder {
        /// <p>The match operator that is used to determine if a filter should be applied.</p>
        pub fn match_operator(mut self, input: crate::model::CategoryFilterMatchOperator) -> Self {
            self.match_operator = Some(input);
            self
        }
        /// <p>The match operator that is used to determine if a filter should be applied.</p>
        pub fn set_match_operator(
            mut self,
            input: std::option::Option<crate::model::CategoryFilterMatchOperator>,
        ) -> Self {
            self.match_operator = input;
            self
        }
        /// Appends an item to `category_values`.
        ///
        /// To override the contents of this collection use [`set_category_values`](Self::set_category_values).
        ///
        /// <p>The list of category values for the filter.</p>
        pub fn category_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.category_values.unwrap_or_default();
            v.push(input.into());
            self.category_values = Some(v);
            self
        }
        /// <p>The list of category values for the filter.</p>
        pub fn set_category_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.category_values = input;
            self
        }
        /// <p>Select all of the values. Null is not the assigned value of select all.</p>
        /// <ul>
        /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
        /// </ul>
        pub fn select_all_options(
            mut self,
            input: crate::model::CategoryFilterSelectAllOptions,
        ) -> Self {
            self.select_all_options = Some(input);
            self
        }
        /// <p>Select all of the values. Null is not the assigned value of select all.</p>
        /// <ul>
        /// <li> <p> <code>FILTER_ALL_VALUES</code> </p> </li>
        /// </ul>
        pub fn set_select_all_options(
            mut self,
            input: std::option::Option<crate::model::CategoryFilterSelectAllOptions>,
        ) -> Self {
            self.select_all_options = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterListConfiguration`](crate::model::FilterListConfiguration).
        pub fn build(self) -> crate::model::FilterListConfiguration {
            crate::model::FilterListConfiguration {
                match_operator: self.match_operator,
                category_values: self.category_values,
                select_all_options: self.select_all_options,
            }
        }
    }
}
impl FilterListConfiguration {
    /// Creates a new builder-style object to manufacture [`FilterListConfiguration`](crate::model::FilterListConfiguration).
    pub fn builder() -> crate::model::filter_list_configuration::Builder {
        crate::model::filter_list_configuration::Builder::default()
    }
}

/// <p>The declaration definition of a parameter.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html">Parameters in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParameterDeclaration {
    /// <p>A parameter declaration for the <code>String</code> data type.</p>
    #[doc(hidden)]
    pub string_parameter_declaration: std::option::Option<crate::model::StringParameterDeclaration>,
    /// <p>A parameter declaration for the <code>Decimal</code> data type.</p>
    #[doc(hidden)]
    pub decimal_parameter_declaration:
        std::option::Option<crate::model::DecimalParameterDeclaration>,
    /// <p>A parameter declaration for the <code>Integer</code> data type.</p>
    #[doc(hidden)]
    pub integer_parameter_declaration:
        std::option::Option<crate::model::IntegerParameterDeclaration>,
    /// <p>A parameter declaration for the <code>DateTime</code> data type.</p>
    #[doc(hidden)]
    pub date_time_parameter_declaration:
        std::option::Option<crate::model::DateTimeParameterDeclaration>,
}
impl ParameterDeclaration {
    /// <p>A parameter declaration for the <code>String</code> data type.</p>
    pub fn string_parameter_declaration(
        &self,
    ) -> std::option::Option<&crate::model::StringParameterDeclaration> {
        self.string_parameter_declaration.as_ref()
    }
    /// <p>A parameter declaration for the <code>Decimal</code> data type.</p>
    pub fn decimal_parameter_declaration(
        &self,
    ) -> std::option::Option<&crate::model::DecimalParameterDeclaration> {
        self.decimal_parameter_declaration.as_ref()
    }
    /// <p>A parameter declaration for the <code>Integer</code> data type.</p>
    pub fn integer_parameter_declaration(
        &self,
    ) -> std::option::Option<&crate::model::IntegerParameterDeclaration> {
        self.integer_parameter_declaration.as_ref()
    }
    /// <p>A parameter declaration for the <code>DateTime</code> data type.</p>
    pub fn date_time_parameter_declaration(
        &self,
    ) -> std::option::Option<&crate::model::DateTimeParameterDeclaration> {
        self.date_time_parameter_declaration.as_ref()
    }
}
/// See [`ParameterDeclaration`](crate::model::ParameterDeclaration).
pub mod parameter_declaration {

    /// A builder for [`ParameterDeclaration`](crate::model::ParameterDeclaration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) string_parameter_declaration:
            std::option::Option<crate::model::StringParameterDeclaration>,
        pub(crate) decimal_parameter_declaration:
            std::option::Option<crate::model::DecimalParameterDeclaration>,
        pub(crate) integer_parameter_declaration:
            std::option::Option<crate::model::IntegerParameterDeclaration>,
        pub(crate) date_time_parameter_declaration:
            std::option::Option<crate::model::DateTimeParameterDeclaration>,
    }
    impl Builder {
        /// <p>A parameter declaration for the <code>String</code> data type.</p>
        pub fn string_parameter_declaration(
            mut self,
            input: crate::model::StringParameterDeclaration,
        ) -> Self {
            self.string_parameter_declaration = Some(input);
            self
        }
        /// <p>A parameter declaration for the <code>String</code> data type.</p>
        pub fn set_string_parameter_declaration(
            mut self,
            input: std::option::Option<crate::model::StringParameterDeclaration>,
        ) -> Self {
            self.string_parameter_declaration = input;
            self
        }
        /// <p>A parameter declaration for the <code>Decimal</code> data type.</p>
        pub fn decimal_parameter_declaration(
            mut self,
            input: crate::model::DecimalParameterDeclaration,
        ) -> Self {
            self.decimal_parameter_declaration = Some(input);
            self
        }
        /// <p>A parameter declaration for the <code>Decimal</code> data type.</p>
        pub fn set_decimal_parameter_declaration(
            mut self,
            input: std::option::Option<crate::model::DecimalParameterDeclaration>,
        ) -> Self {
            self.decimal_parameter_declaration = input;
            self
        }
        /// <p>A parameter declaration for the <code>Integer</code> data type.</p>
        pub fn integer_parameter_declaration(
            mut self,
            input: crate::model::IntegerParameterDeclaration,
        ) -> Self {
            self.integer_parameter_declaration = Some(input);
            self
        }
        /// <p>A parameter declaration for the <code>Integer</code> data type.</p>
        pub fn set_integer_parameter_declaration(
            mut self,
            input: std::option::Option<crate::model::IntegerParameterDeclaration>,
        ) -> Self {
            self.integer_parameter_declaration = input;
            self
        }
        /// <p>A parameter declaration for the <code>DateTime</code> data type.</p>
        pub fn date_time_parameter_declaration(
            mut self,
            input: crate::model::DateTimeParameterDeclaration,
        ) -> Self {
            self.date_time_parameter_declaration = Some(input);
            self
        }
        /// <p>A parameter declaration for the <code>DateTime</code> data type.</p>
        pub fn set_date_time_parameter_declaration(
            mut self,
            input: std::option::Option<crate::model::DateTimeParameterDeclaration>,
        ) -> Self {
            self.date_time_parameter_declaration = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterDeclaration`](crate::model::ParameterDeclaration).
        pub fn build(self) -> crate::model::ParameterDeclaration {
            crate::model::ParameterDeclaration {
                string_parameter_declaration: self.string_parameter_declaration,
                decimal_parameter_declaration: self.decimal_parameter_declaration,
                integer_parameter_declaration: self.integer_parameter_declaration,
                date_time_parameter_declaration: self.date_time_parameter_declaration,
            }
        }
    }
}
impl ParameterDeclaration {
    /// Creates a new builder-style object to manufacture [`ParameterDeclaration`](crate::model::ParameterDeclaration).
    pub fn builder() -> crate::model::parameter_declaration::Builder {
        crate::model::parameter_declaration::Builder::default()
    }
}

/// <p>A parameter declaration for the <code>DateTime</code> data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DateTimeParameterDeclaration {
    /// <p>The name of the parameter that is being declared.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.</p>
    #[doc(hidden)]
    pub default_values: std::option::Option<crate::model::DateTimeDefaultValues>,
    /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
    #[doc(hidden)]
    pub time_granularity: std::option::Option<crate::model::TimeGranularity>,
    /// <p>The configuration that defines the default value of a <code>DateTime</code> parameter when a value has not been set.</p>
    #[doc(hidden)]
    pub value_when_unset: std::option::Option<crate::model::DateTimeValueWhenUnsetConfiguration>,
}
impl DateTimeParameterDeclaration {
    /// <p>The name of the parameter that is being declared.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.</p>
    pub fn default_values(&self) -> std::option::Option<&crate::model::DateTimeDefaultValues> {
        self.default_values.as_ref()
    }
    /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
    pub fn time_granularity(&self) -> std::option::Option<&crate::model::TimeGranularity> {
        self.time_granularity.as_ref()
    }
    /// <p>The configuration that defines the default value of a <code>DateTime</code> parameter when a value has not been set.</p>
    pub fn value_when_unset(
        &self,
    ) -> std::option::Option<&crate::model::DateTimeValueWhenUnsetConfiguration> {
        self.value_when_unset.as_ref()
    }
}
/// See [`DateTimeParameterDeclaration`](crate::model::DateTimeParameterDeclaration).
pub mod date_time_parameter_declaration {

    /// A builder for [`DateTimeParameterDeclaration`](crate::model::DateTimeParameterDeclaration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) default_values: std::option::Option<crate::model::DateTimeDefaultValues>,
        pub(crate) time_granularity: std::option::Option<crate::model::TimeGranularity>,
        pub(crate) value_when_unset:
            std::option::Option<crate::model::DateTimeValueWhenUnsetConfiguration>,
    }
    impl Builder {
        /// <p>The name of the parameter that is being declared.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the parameter that is being declared.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.</p>
        pub fn default_values(mut self, input: crate::model::DateTimeDefaultValues) -> Self {
            self.default_values = Some(input);
            self
        }
        /// <p>The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.</p>
        pub fn set_default_values(
            mut self,
            input: std::option::Option<crate::model::DateTimeDefaultValues>,
        ) -> Self {
            self.default_values = input;
            self
        }
        /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
        pub fn time_granularity(mut self, input: crate::model::TimeGranularity) -> Self {
            self.time_granularity = Some(input);
            self
        }
        /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
        pub fn set_time_granularity(
            mut self,
            input: std::option::Option<crate::model::TimeGranularity>,
        ) -> Self {
            self.time_granularity = input;
            self
        }
        /// <p>The configuration that defines the default value of a <code>DateTime</code> parameter when a value has not been set.</p>
        pub fn value_when_unset(
            mut self,
            input: crate::model::DateTimeValueWhenUnsetConfiguration,
        ) -> Self {
            self.value_when_unset = Some(input);
            self
        }
        /// <p>The configuration that defines the default value of a <code>DateTime</code> parameter when a value has not been set.</p>
        pub fn set_value_when_unset(
            mut self,
            input: std::option::Option<crate::model::DateTimeValueWhenUnsetConfiguration>,
        ) -> Self {
            self.value_when_unset = input;
            self
        }
        /// Consumes the builder and constructs a [`DateTimeParameterDeclaration`](crate::model::DateTimeParameterDeclaration).
        pub fn build(self) -> crate::model::DateTimeParameterDeclaration {
            crate::model::DateTimeParameterDeclaration {
                name: self.name,
                default_values: self.default_values,
                time_granularity: self.time_granularity,
                value_when_unset: self.value_when_unset,
            }
        }
    }
}
impl DateTimeParameterDeclaration {
    /// Creates a new builder-style object to manufacture [`DateTimeParameterDeclaration`](crate::model::DateTimeParameterDeclaration).
    pub fn builder() -> crate::model::date_time_parameter_declaration::Builder {
        crate::model::date_time_parameter_declaration::Builder::default()
    }
}

/// <p>The configuration that defines the default value of a <code>DateTime</code> parameter when a value has not been set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DateTimeValueWhenUnsetConfiguration {
    /// <p>The built-in options for default values. The value can be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>RECOMMENDED</code>: The recommended value.</p> </li>
    /// <li> <p> <code>NULL</code>: The <code>NULL</code> value.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub value_when_unset_option: std::option::Option<crate::model::ValueWhenUnsetOption>,
    /// <p>A custom value that's used when the value of a parameter isn't set.</p>
    #[doc(hidden)]
    pub custom_value: std::option::Option<aws_smithy_types::DateTime>,
}
impl DateTimeValueWhenUnsetConfiguration {
    /// <p>The built-in options for default values. The value can be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>RECOMMENDED</code>: The recommended value.</p> </li>
    /// <li> <p> <code>NULL</code>: The <code>NULL</code> value.</p> </li>
    /// </ul>
    pub fn value_when_unset_option(
        &self,
    ) -> std::option::Option<&crate::model::ValueWhenUnsetOption> {
        self.value_when_unset_option.as_ref()
    }
    /// <p>A custom value that's used when the value of a parameter isn't set.</p>
    pub fn custom_value(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.custom_value.as_ref()
    }
}
impl std::fmt::Debug for DateTimeValueWhenUnsetConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DateTimeValueWhenUnsetConfiguration");
        formatter.field("value_when_unset_option", &self.value_when_unset_option);
        formatter.field("custom_value", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`DateTimeValueWhenUnsetConfiguration`](crate::model::DateTimeValueWhenUnsetConfiguration).
pub mod date_time_value_when_unset_configuration {

    /// A builder for [`DateTimeValueWhenUnsetConfiguration`](crate::model::DateTimeValueWhenUnsetConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) value_when_unset_option: std::option::Option<crate::model::ValueWhenUnsetOption>,
        pub(crate) custom_value: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The built-in options for default values. The value can be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>RECOMMENDED</code>: The recommended value.</p> </li>
        /// <li> <p> <code>NULL</code>: The <code>NULL</code> value.</p> </li>
        /// </ul>
        pub fn value_when_unset_option(
            mut self,
            input: crate::model::ValueWhenUnsetOption,
        ) -> Self {
            self.value_when_unset_option = Some(input);
            self
        }
        /// <p>The built-in options for default values. The value can be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>RECOMMENDED</code>: The recommended value.</p> </li>
        /// <li> <p> <code>NULL</code>: The <code>NULL</code> value.</p> </li>
        /// </ul>
        pub fn set_value_when_unset_option(
            mut self,
            input: std::option::Option<crate::model::ValueWhenUnsetOption>,
        ) -> Self {
            self.value_when_unset_option = input;
            self
        }
        /// <p>A custom value that's used when the value of a parameter isn't set.</p>
        pub fn custom_value(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.custom_value = Some(input);
            self
        }
        /// <p>A custom value that's used when the value of a parameter isn't set.</p>
        pub fn set_custom_value(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.custom_value = input;
            self
        }
        /// Consumes the builder and constructs a [`DateTimeValueWhenUnsetConfiguration`](crate::model::DateTimeValueWhenUnsetConfiguration).
        pub fn build(self) -> crate::model::DateTimeValueWhenUnsetConfiguration {
            crate::model::DateTimeValueWhenUnsetConfiguration {
                value_when_unset_option: self.value_when_unset_option,
                custom_value: self.custom_value,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("value_when_unset_option", &self.value_when_unset_option);
            formatter.field("custom_value", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl DateTimeValueWhenUnsetConfiguration {
    /// Creates a new builder-style object to manufacture [`DateTimeValueWhenUnsetConfiguration`](crate::model::DateTimeValueWhenUnsetConfiguration).
    pub fn builder() -> crate::model::date_time_value_when_unset_configuration::Builder {
        crate::model::date_time_value_when_unset_configuration::Builder::default()
    }
}

/// When writing a match expression against `ValueWhenUnsetOption`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let valuewhenunsetoption = unimplemented!();
/// match valuewhenunsetoption {
///     ValueWhenUnsetOption::Null => { /* ... */ },
///     ValueWhenUnsetOption::RecommendedValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `valuewhenunsetoption` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ValueWhenUnsetOption::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ValueWhenUnsetOption::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ValueWhenUnsetOption::NewFeature` is defined.
/// Specifically, when `valuewhenunsetoption` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ValueWhenUnsetOption::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ValueWhenUnsetOption {
    #[allow(missing_docs)] // documentation missing in model
    Null,
    #[allow(missing_docs)] // documentation missing in model
    RecommendedValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ValueWhenUnsetOption {
    fn from(s: &str) -> Self {
        match s {
            "NULL" => ValueWhenUnsetOption::Null,
            "RECOMMENDED_VALUE" => ValueWhenUnsetOption::RecommendedValue,
            other => {
                ValueWhenUnsetOption::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ValueWhenUnsetOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ValueWhenUnsetOption::from(s))
    }
}
impl ValueWhenUnsetOption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ValueWhenUnsetOption::Null => "NULL",
            ValueWhenUnsetOption::RecommendedValue => "RECOMMENDED_VALUE",
            ValueWhenUnsetOption::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NULL", "RECOMMENDED_VALUE"]
    }
}
impl AsRef<str> for ValueWhenUnsetOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The default values of the <code>DateTimeParameterDeclaration</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DateTimeDefaultValues {
    /// <p>The dynamic value of the <code>DataTimeDefaultValues</code>. Different defaults are displayed according to users, groups, and values mapping.</p>
    #[doc(hidden)]
    pub dynamic_value: std::option::Option<crate::model::DynamicDefaultValue>,
    /// <p>The static values of the <code>DataTimeDefaultValues</code>.</p>
    #[doc(hidden)]
    pub static_values: std::option::Option<std::vec::Vec<aws_smithy_types::DateTime>>,
    /// <p>The rolling date of the <code>DataTimeDefaultValues</code>. The date is determined from the dataset based on input expression.</p>
    #[doc(hidden)]
    pub rolling_date: std::option::Option<crate::model::RollingDateConfiguration>,
}
impl DateTimeDefaultValues {
    /// <p>The dynamic value of the <code>DataTimeDefaultValues</code>. Different defaults are displayed according to users, groups, and values mapping.</p>
    pub fn dynamic_value(&self) -> std::option::Option<&crate::model::DynamicDefaultValue> {
        self.dynamic_value.as_ref()
    }
    /// <p>The static values of the <code>DataTimeDefaultValues</code>.</p>
    pub fn static_values(&self) -> std::option::Option<&[aws_smithy_types::DateTime]> {
        self.static_values.as_deref()
    }
    /// <p>The rolling date of the <code>DataTimeDefaultValues</code>. The date is determined from the dataset based on input expression.</p>
    pub fn rolling_date(&self) -> std::option::Option<&crate::model::RollingDateConfiguration> {
        self.rolling_date.as_ref()
    }
}
/// See [`DateTimeDefaultValues`](crate::model::DateTimeDefaultValues).
pub mod date_time_default_values {

    /// A builder for [`DateTimeDefaultValues`](crate::model::DateTimeDefaultValues).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dynamic_value: std::option::Option<crate::model::DynamicDefaultValue>,
        pub(crate) static_values: std::option::Option<std::vec::Vec<aws_smithy_types::DateTime>>,
        pub(crate) rolling_date: std::option::Option<crate::model::RollingDateConfiguration>,
    }
    impl Builder {
        /// <p>The dynamic value of the <code>DataTimeDefaultValues</code>. Different defaults are displayed according to users, groups, and values mapping.</p>
        pub fn dynamic_value(mut self, input: crate::model::DynamicDefaultValue) -> Self {
            self.dynamic_value = Some(input);
            self
        }
        /// <p>The dynamic value of the <code>DataTimeDefaultValues</code>. Different defaults are displayed according to users, groups, and values mapping.</p>
        pub fn set_dynamic_value(
            mut self,
            input: std::option::Option<crate::model::DynamicDefaultValue>,
        ) -> Self {
            self.dynamic_value = input;
            self
        }
        /// Appends an item to `static_values`.
        ///
        /// To override the contents of this collection use [`set_static_values`](Self::set_static_values).
        ///
        /// <p>The static values of the <code>DataTimeDefaultValues</code>.</p>
        pub fn static_values(mut self, input: aws_smithy_types::DateTime) -> Self {
            let mut v = self.static_values.unwrap_or_default();
            v.push(input);
            self.static_values = Some(v);
            self
        }
        /// <p>The static values of the <code>DataTimeDefaultValues</code>.</p>
        pub fn set_static_values(
            mut self,
            input: std::option::Option<std::vec::Vec<aws_smithy_types::DateTime>>,
        ) -> Self {
            self.static_values = input;
            self
        }
        /// <p>The rolling date of the <code>DataTimeDefaultValues</code>. The date is determined from the dataset based on input expression.</p>
        pub fn rolling_date(mut self, input: crate::model::RollingDateConfiguration) -> Self {
            self.rolling_date = Some(input);
            self
        }
        /// <p>The rolling date of the <code>DataTimeDefaultValues</code>. The date is determined from the dataset based on input expression.</p>
        pub fn set_rolling_date(
            mut self,
            input: std::option::Option<crate::model::RollingDateConfiguration>,
        ) -> Self {
            self.rolling_date = input;
            self
        }
        /// Consumes the builder and constructs a [`DateTimeDefaultValues`](crate::model::DateTimeDefaultValues).
        pub fn build(self) -> crate::model::DateTimeDefaultValues {
            crate::model::DateTimeDefaultValues {
                dynamic_value: self.dynamic_value,
                static_values: self.static_values,
                rolling_date: self.rolling_date,
            }
        }
    }
}
impl DateTimeDefaultValues {
    /// Creates a new builder-style object to manufacture [`DateTimeDefaultValues`](crate::model::DateTimeDefaultValues).
    pub fn builder() -> crate::model::date_time_default_values::Builder {
        crate::model::date_time_default_values::Builder::default()
    }
}

/// <p>Defines different defaults to the users or groups based on mapping.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DynamicDefaultValue {
    /// <p>The column that contains the username.</p>
    #[doc(hidden)]
    pub user_name_column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The column that contains the group name.</p>
    #[doc(hidden)]
    pub group_name_column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The column that contains the default value of each user or group.</p>
    #[doc(hidden)]
    pub default_value_column: std::option::Option<crate::model::ColumnIdentifier>,
}
impl DynamicDefaultValue {
    /// <p>The column that contains the username.</p>
    pub fn user_name_column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.user_name_column.as_ref()
    }
    /// <p>The column that contains the group name.</p>
    pub fn group_name_column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.group_name_column.as_ref()
    }
    /// <p>The column that contains the default value of each user or group.</p>
    pub fn default_value_column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.default_value_column.as_ref()
    }
}
/// See [`DynamicDefaultValue`](crate::model::DynamicDefaultValue).
pub mod dynamic_default_value {

    /// A builder for [`DynamicDefaultValue`](crate::model::DynamicDefaultValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name_column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) group_name_column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) default_value_column: std::option::Option<crate::model::ColumnIdentifier>,
    }
    impl Builder {
        /// <p>The column that contains the username.</p>
        pub fn user_name_column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.user_name_column = Some(input);
            self
        }
        /// <p>The column that contains the username.</p>
        pub fn set_user_name_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.user_name_column = input;
            self
        }
        /// <p>The column that contains the group name.</p>
        pub fn group_name_column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.group_name_column = Some(input);
            self
        }
        /// <p>The column that contains the group name.</p>
        pub fn set_group_name_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.group_name_column = input;
            self
        }
        /// <p>The column that contains the default value of each user or group.</p>
        pub fn default_value_column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.default_value_column = Some(input);
            self
        }
        /// <p>The column that contains the default value of each user or group.</p>
        pub fn set_default_value_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.default_value_column = input;
            self
        }
        /// Consumes the builder and constructs a [`DynamicDefaultValue`](crate::model::DynamicDefaultValue).
        pub fn build(self) -> crate::model::DynamicDefaultValue {
            crate::model::DynamicDefaultValue {
                user_name_column: self.user_name_column,
                group_name_column: self.group_name_column,
                default_value_column: self.default_value_column,
            }
        }
    }
}
impl DynamicDefaultValue {
    /// Creates a new builder-style object to manufacture [`DynamicDefaultValue`](crate::model::DynamicDefaultValue).
    pub fn builder() -> crate::model::dynamic_default_value::Builder {
        crate::model::dynamic_default_value::Builder::default()
    }
}

/// <p>A parameter declaration for the <code>Integer</code> data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IntegerParameterDeclaration {
    /// <p>The value type determines whether the parameter is a single-value or multi-value parameter.</p>
    #[doc(hidden)]
    pub parameter_value_type: std::option::Option<crate::model::ParameterValueType>,
    /// <p>The name of the parameter that is being declared.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.</p>
    #[doc(hidden)]
    pub default_values: std::option::Option<crate::model::IntegerDefaultValues>,
    /// <p>A parameter declaration for the <code>Integer</code> data type.</p>
    #[doc(hidden)]
    pub value_when_unset: std::option::Option<crate::model::IntegerValueWhenUnsetConfiguration>,
}
impl IntegerParameterDeclaration {
    /// <p>The value type determines whether the parameter is a single-value or multi-value parameter.</p>
    pub fn parameter_value_type(&self) -> std::option::Option<&crate::model::ParameterValueType> {
        self.parameter_value_type.as_ref()
    }
    /// <p>The name of the parameter that is being declared.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.</p>
    pub fn default_values(&self) -> std::option::Option<&crate::model::IntegerDefaultValues> {
        self.default_values.as_ref()
    }
    /// <p>A parameter declaration for the <code>Integer</code> data type.</p>
    pub fn value_when_unset(
        &self,
    ) -> std::option::Option<&crate::model::IntegerValueWhenUnsetConfiguration> {
        self.value_when_unset.as_ref()
    }
}
/// See [`IntegerParameterDeclaration`](crate::model::IntegerParameterDeclaration).
pub mod integer_parameter_declaration {

    /// A builder for [`IntegerParameterDeclaration`](crate::model::IntegerParameterDeclaration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_value_type: std::option::Option<crate::model::ParameterValueType>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) default_values: std::option::Option<crate::model::IntegerDefaultValues>,
        pub(crate) value_when_unset:
            std::option::Option<crate::model::IntegerValueWhenUnsetConfiguration>,
    }
    impl Builder {
        /// <p>The value type determines whether the parameter is a single-value or multi-value parameter.</p>
        pub fn parameter_value_type(mut self, input: crate::model::ParameterValueType) -> Self {
            self.parameter_value_type = Some(input);
            self
        }
        /// <p>The value type determines whether the parameter is a single-value or multi-value parameter.</p>
        pub fn set_parameter_value_type(
            mut self,
            input: std::option::Option<crate::model::ParameterValueType>,
        ) -> Self {
            self.parameter_value_type = input;
            self
        }
        /// <p>The name of the parameter that is being declared.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the parameter that is being declared.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.</p>
        pub fn default_values(mut self, input: crate::model::IntegerDefaultValues) -> Self {
            self.default_values = Some(input);
            self
        }
        /// <p>The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.</p>
        pub fn set_default_values(
            mut self,
            input: std::option::Option<crate::model::IntegerDefaultValues>,
        ) -> Self {
            self.default_values = input;
            self
        }
        /// <p>A parameter declaration for the <code>Integer</code> data type.</p>
        pub fn value_when_unset(
            mut self,
            input: crate::model::IntegerValueWhenUnsetConfiguration,
        ) -> Self {
            self.value_when_unset = Some(input);
            self
        }
        /// <p>A parameter declaration for the <code>Integer</code> data type.</p>
        pub fn set_value_when_unset(
            mut self,
            input: std::option::Option<crate::model::IntegerValueWhenUnsetConfiguration>,
        ) -> Self {
            self.value_when_unset = input;
            self
        }
        /// Consumes the builder and constructs a [`IntegerParameterDeclaration`](crate::model::IntegerParameterDeclaration).
        pub fn build(self) -> crate::model::IntegerParameterDeclaration {
            crate::model::IntegerParameterDeclaration {
                parameter_value_type: self.parameter_value_type,
                name: self.name,
                default_values: self.default_values,
                value_when_unset: self.value_when_unset,
            }
        }
    }
}
impl IntegerParameterDeclaration {
    /// Creates a new builder-style object to manufacture [`IntegerParameterDeclaration`](crate::model::IntegerParameterDeclaration).
    pub fn builder() -> crate::model::integer_parameter_declaration::Builder {
        crate::model::integer_parameter_declaration::Builder::default()
    }
}

/// <p>A parameter declaration for the <code>Integer</code> data type.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IntegerValueWhenUnsetConfiguration {
    /// <p>The built-in options for default values. The value can be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>RECOMMENDED</code>: The recommended value.</p> </li>
    /// <li> <p> <code>NULL</code>: The <code>NULL</code> value.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub value_when_unset_option: std::option::Option<crate::model::ValueWhenUnsetOption>,
    /// <p>A custom value that's used when the value of a parameter isn't set.</p>
    #[doc(hidden)]
    pub custom_value: std::option::Option<i64>,
}
impl IntegerValueWhenUnsetConfiguration {
    /// <p>The built-in options for default values. The value can be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>RECOMMENDED</code>: The recommended value.</p> </li>
    /// <li> <p> <code>NULL</code>: The <code>NULL</code> value.</p> </li>
    /// </ul>
    pub fn value_when_unset_option(
        &self,
    ) -> std::option::Option<&crate::model::ValueWhenUnsetOption> {
        self.value_when_unset_option.as_ref()
    }
    /// <p>A custom value that's used when the value of a parameter isn't set.</p>
    pub fn custom_value(&self) -> std::option::Option<i64> {
        self.custom_value
    }
}
impl std::fmt::Debug for IntegerValueWhenUnsetConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IntegerValueWhenUnsetConfiguration");
        formatter.field("value_when_unset_option", &self.value_when_unset_option);
        formatter.field("custom_value", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`IntegerValueWhenUnsetConfiguration`](crate::model::IntegerValueWhenUnsetConfiguration).
pub mod integer_value_when_unset_configuration {

    /// A builder for [`IntegerValueWhenUnsetConfiguration`](crate::model::IntegerValueWhenUnsetConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) value_when_unset_option: std::option::Option<crate::model::ValueWhenUnsetOption>,
        pub(crate) custom_value: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The built-in options for default values. The value can be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>RECOMMENDED</code>: The recommended value.</p> </li>
        /// <li> <p> <code>NULL</code>: The <code>NULL</code> value.</p> </li>
        /// </ul>
        pub fn value_when_unset_option(
            mut self,
            input: crate::model::ValueWhenUnsetOption,
        ) -> Self {
            self.value_when_unset_option = Some(input);
            self
        }
        /// <p>The built-in options for default values. The value can be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>RECOMMENDED</code>: The recommended value.</p> </li>
        /// <li> <p> <code>NULL</code>: The <code>NULL</code> value.</p> </li>
        /// </ul>
        pub fn set_value_when_unset_option(
            mut self,
            input: std::option::Option<crate::model::ValueWhenUnsetOption>,
        ) -> Self {
            self.value_when_unset_option = input;
            self
        }
        /// <p>A custom value that's used when the value of a parameter isn't set.</p>
        pub fn custom_value(mut self, input: i64) -> Self {
            self.custom_value = Some(input);
            self
        }
        /// <p>A custom value that's used when the value of a parameter isn't set.</p>
        pub fn set_custom_value(mut self, input: std::option::Option<i64>) -> Self {
            self.custom_value = input;
            self
        }
        /// Consumes the builder and constructs a [`IntegerValueWhenUnsetConfiguration`](crate::model::IntegerValueWhenUnsetConfiguration).
        pub fn build(self) -> crate::model::IntegerValueWhenUnsetConfiguration {
            crate::model::IntegerValueWhenUnsetConfiguration {
                value_when_unset_option: self.value_when_unset_option,
                custom_value: self.custom_value,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("value_when_unset_option", &self.value_when_unset_option);
            formatter.field("custom_value", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl IntegerValueWhenUnsetConfiguration {
    /// Creates a new builder-style object to manufacture [`IntegerValueWhenUnsetConfiguration`](crate::model::IntegerValueWhenUnsetConfiguration).
    pub fn builder() -> crate::model::integer_value_when_unset_configuration::Builder {
        crate::model::integer_value_when_unset_configuration::Builder::default()
    }
}

/// <p>The default values of the <code>IntegerParameterDeclaration</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IntegerDefaultValues {
    /// <p>The dynamic value of the <code>IntegerDefaultValues</code>. Different defaults are displayed according to users, groups, and values mapping.</p>
    #[doc(hidden)]
    pub dynamic_value: std::option::Option<crate::model::DynamicDefaultValue>,
    /// <p>The static values of the <code>IntegerDefaultValues</code>.</p>
    #[doc(hidden)]
    pub static_values: std::option::Option<std::vec::Vec<i64>>,
}
impl IntegerDefaultValues {
    /// <p>The dynamic value of the <code>IntegerDefaultValues</code>. Different defaults are displayed according to users, groups, and values mapping.</p>
    pub fn dynamic_value(&self) -> std::option::Option<&crate::model::DynamicDefaultValue> {
        self.dynamic_value.as_ref()
    }
    /// <p>The static values of the <code>IntegerDefaultValues</code>.</p>
    pub fn static_values(&self) -> std::option::Option<&[i64]> {
        self.static_values.as_deref()
    }
}
/// See [`IntegerDefaultValues`](crate::model::IntegerDefaultValues).
pub mod integer_default_values {

    /// A builder for [`IntegerDefaultValues`](crate::model::IntegerDefaultValues).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dynamic_value: std::option::Option<crate::model::DynamicDefaultValue>,
        pub(crate) static_values: std::option::Option<std::vec::Vec<i64>>,
    }
    impl Builder {
        /// <p>The dynamic value of the <code>IntegerDefaultValues</code>. Different defaults are displayed according to users, groups, and values mapping.</p>
        pub fn dynamic_value(mut self, input: crate::model::DynamicDefaultValue) -> Self {
            self.dynamic_value = Some(input);
            self
        }
        /// <p>The dynamic value of the <code>IntegerDefaultValues</code>. Different defaults are displayed according to users, groups, and values mapping.</p>
        pub fn set_dynamic_value(
            mut self,
            input: std::option::Option<crate::model::DynamicDefaultValue>,
        ) -> Self {
            self.dynamic_value = input;
            self
        }
        /// Appends an item to `static_values`.
        ///
        /// To override the contents of this collection use [`set_static_values`](Self::set_static_values).
        ///
        /// <p>The static values of the <code>IntegerDefaultValues</code>.</p>
        pub fn static_values(mut self, input: i64) -> Self {
            let mut v = self.static_values.unwrap_or_default();
            v.push(input);
            self.static_values = Some(v);
            self
        }
        /// <p>The static values of the <code>IntegerDefaultValues</code>.</p>
        pub fn set_static_values(mut self, input: std::option::Option<std::vec::Vec<i64>>) -> Self {
            self.static_values = input;
            self
        }
        /// Consumes the builder and constructs a [`IntegerDefaultValues`](crate::model::IntegerDefaultValues).
        pub fn build(self) -> crate::model::IntegerDefaultValues {
            crate::model::IntegerDefaultValues {
                dynamic_value: self.dynamic_value,
                static_values: self.static_values,
            }
        }
    }
}
impl IntegerDefaultValues {
    /// Creates a new builder-style object to manufacture [`IntegerDefaultValues`](crate::model::IntegerDefaultValues).
    pub fn builder() -> crate::model::integer_default_values::Builder {
        crate::model::integer_default_values::Builder::default()
    }
}

/// When writing a match expression against `ParameterValueType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let parametervaluetype = unimplemented!();
/// match parametervaluetype {
///     ParameterValueType::MultiValued => { /* ... */ },
///     ParameterValueType::SingleValued => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `parametervaluetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ParameterValueType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ParameterValueType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ParameterValueType::NewFeature` is defined.
/// Specifically, when `parametervaluetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ParameterValueType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ParameterValueType {
    #[allow(missing_docs)] // documentation missing in model
    MultiValued,
    #[allow(missing_docs)] // documentation missing in model
    SingleValued,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ParameterValueType {
    fn from(s: &str) -> Self {
        match s {
            "MULTI_VALUED" => ParameterValueType::MultiValued,
            "SINGLE_VALUED" => ParameterValueType::SingleValued,
            other => {
                ParameterValueType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ParameterValueType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ParameterValueType::from(s))
    }
}
impl ParameterValueType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ParameterValueType::MultiValued => "MULTI_VALUED",
            ParameterValueType::SingleValued => "SINGLE_VALUED",
            ParameterValueType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["MULTI_VALUED", "SINGLE_VALUED"]
    }
}
impl AsRef<str> for ParameterValueType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A parameter declaration for the <code>Decimal</code> data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DecimalParameterDeclaration {
    /// <p>The value type determines whether the parameter is a single-value or multi-value parameter.</p>
    #[doc(hidden)]
    pub parameter_value_type: std::option::Option<crate::model::ParameterValueType>,
    /// <p>The name of the parameter that is being declared.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.</p>
    #[doc(hidden)]
    pub default_values: std::option::Option<crate::model::DecimalDefaultValues>,
    /// <p>The configuration that defines the default value of a <code>Decimal</code> parameter when a value has not been set.</p>
    #[doc(hidden)]
    pub value_when_unset: std::option::Option<crate::model::DecimalValueWhenUnsetConfiguration>,
}
impl DecimalParameterDeclaration {
    /// <p>The value type determines whether the parameter is a single-value or multi-value parameter.</p>
    pub fn parameter_value_type(&self) -> std::option::Option<&crate::model::ParameterValueType> {
        self.parameter_value_type.as_ref()
    }
    /// <p>The name of the parameter that is being declared.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.</p>
    pub fn default_values(&self) -> std::option::Option<&crate::model::DecimalDefaultValues> {
        self.default_values.as_ref()
    }
    /// <p>The configuration that defines the default value of a <code>Decimal</code> parameter when a value has not been set.</p>
    pub fn value_when_unset(
        &self,
    ) -> std::option::Option<&crate::model::DecimalValueWhenUnsetConfiguration> {
        self.value_when_unset.as_ref()
    }
}
/// See [`DecimalParameterDeclaration`](crate::model::DecimalParameterDeclaration).
pub mod decimal_parameter_declaration {

    /// A builder for [`DecimalParameterDeclaration`](crate::model::DecimalParameterDeclaration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_value_type: std::option::Option<crate::model::ParameterValueType>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) default_values: std::option::Option<crate::model::DecimalDefaultValues>,
        pub(crate) value_when_unset:
            std::option::Option<crate::model::DecimalValueWhenUnsetConfiguration>,
    }
    impl Builder {
        /// <p>The value type determines whether the parameter is a single-value or multi-value parameter.</p>
        pub fn parameter_value_type(mut self, input: crate::model::ParameterValueType) -> Self {
            self.parameter_value_type = Some(input);
            self
        }
        /// <p>The value type determines whether the parameter is a single-value or multi-value parameter.</p>
        pub fn set_parameter_value_type(
            mut self,
            input: std::option::Option<crate::model::ParameterValueType>,
        ) -> Self {
            self.parameter_value_type = input;
            self
        }
        /// <p>The name of the parameter that is being declared.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the parameter that is being declared.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.</p>
        pub fn default_values(mut self, input: crate::model::DecimalDefaultValues) -> Self {
            self.default_values = Some(input);
            self
        }
        /// <p>The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.</p>
        pub fn set_default_values(
            mut self,
            input: std::option::Option<crate::model::DecimalDefaultValues>,
        ) -> Self {
            self.default_values = input;
            self
        }
        /// <p>The configuration that defines the default value of a <code>Decimal</code> parameter when a value has not been set.</p>
        pub fn value_when_unset(
            mut self,
            input: crate::model::DecimalValueWhenUnsetConfiguration,
        ) -> Self {
            self.value_when_unset = Some(input);
            self
        }
        /// <p>The configuration that defines the default value of a <code>Decimal</code> parameter when a value has not been set.</p>
        pub fn set_value_when_unset(
            mut self,
            input: std::option::Option<crate::model::DecimalValueWhenUnsetConfiguration>,
        ) -> Self {
            self.value_when_unset = input;
            self
        }
        /// Consumes the builder and constructs a [`DecimalParameterDeclaration`](crate::model::DecimalParameterDeclaration).
        pub fn build(self) -> crate::model::DecimalParameterDeclaration {
            crate::model::DecimalParameterDeclaration {
                parameter_value_type: self.parameter_value_type,
                name: self.name,
                default_values: self.default_values,
                value_when_unset: self.value_when_unset,
            }
        }
    }
}
impl DecimalParameterDeclaration {
    /// Creates a new builder-style object to manufacture [`DecimalParameterDeclaration`](crate::model::DecimalParameterDeclaration).
    pub fn builder() -> crate::model::decimal_parameter_declaration::Builder {
        crate::model::decimal_parameter_declaration::Builder::default()
    }
}

/// <p>The configuration that defines the default value of a <code>Decimal</code> parameter when a value has not been set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DecimalValueWhenUnsetConfiguration {
    /// <p>The built-in options for default values. The value can be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>RECOMMENDED</code>: The recommended value.</p> </li>
    /// <li> <p> <code>NULL</code>: The <code>NULL</code> value.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub value_when_unset_option: std::option::Option<crate::model::ValueWhenUnsetOption>,
    /// <p>A custom value that's used when the value of a parameter isn't set.</p>
    #[doc(hidden)]
    pub custom_value: std::option::Option<f64>,
}
impl DecimalValueWhenUnsetConfiguration {
    /// <p>The built-in options for default values. The value can be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>RECOMMENDED</code>: The recommended value.</p> </li>
    /// <li> <p> <code>NULL</code>: The <code>NULL</code> value.</p> </li>
    /// </ul>
    pub fn value_when_unset_option(
        &self,
    ) -> std::option::Option<&crate::model::ValueWhenUnsetOption> {
        self.value_when_unset_option.as_ref()
    }
    /// <p>A custom value that's used when the value of a parameter isn't set.</p>
    pub fn custom_value(&self) -> std::option::Option<f64> {
        self.custom_value
    }
}
impl std::fmt::Debug for DecimalValueWhenUnsetConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DecimalValueWhenUnsetConfiguration");
        formatter.field("value_when_unset_option", &self.value_when_unset_option);
        formatter.field("custom_value", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`DecimalValueWhenUnsetConfiguration`](crate::model::DecimalValueWhenUnsetConfiguration).
pub mod decimal_value_when_unset_configuration {

    /// A builder for [`DecimalValueWhenUnsetConfiguration`](crate::model::DecimalValueWhenUnsetConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) value_when_unset_option: std::option::Option<crate::model::ValueWhenUnsetOption>,
        pub(crate) custom_value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The built-in options for default values. The value can be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>RECOMMENDED</code>: The recommended value.</p> </li>
        /// <li> <p> <code>NULL</code>: The <code>NULL</code> value.</p> </li>
        /// </ul>
        pub fn value_when_unset_option(
            mut self,
            input: crate::model::ValueWhenUnsetOption,
        ) -> Self {
            self.value_when_unset_option = Some(input);
            self
        }
        /// <p>The built-in options for default values. The value can be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>RECOMMENDED</code>: The recommended value.</p> </li>
        /// <li> <p> <code>NULL</code>: The <code>NULL</code> value.</p> </li>
        /// </ul>
        pub fn set_value_when_unset_option(
            mut self,
            input: std::option::Option<crate::model::ValueWhenUnsetOption>,
        ) -> Self {
            self.value_when_unset_option = input;
            self
        }
        /// <p>A custom value that's used when the value of a parameter isn't set.</p>
        pub fn custom_value(mut self, input: f64) -> Self {
            self.custom_value = Some(input);
            self
        }
        /// <p>A custom value that's used when the value of a parameter isn't set.</p>
        pub fn set_custom_value(mut self, input: std::option::Option<f64>) -> Self {
            self.custom_value = input;
            self
        }
        /// Consumes the builder and constructs a [`DecimalValueWhenUnsetConfiguration`](crate::model::DecimalValueWhenUnsetConfiguration).
        pub fn build(self) -> crate::model::DecimalValueWhenUnsetConfiguration {
            crate::model::DecimalValueWhenUnsetConfiguration {
                value_when_unset_option: self.value_when_unset_option,
                custom_value: self.custom_value,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("value_when_unset_option", &self.value_when_unset_option);
            formatter.field("custom_value", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl DecimalValueWhenUnsetConfiguration {
    /// Creates a new builder-style object to manufacture [`DecimalValueWhenUnsetConfiguration`](crate::model::DecimalValueWhenUnsetConfiguration).
    pub fn builder() -> crate::model::decimal_value_when_unset_configuration::Builder {
        crate::model::decimal_value_when_unset_configuration::Builder::default()
    }
}

/// <p>The default values of the <code>DecimalParameterDeclaration</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DecimalDefaultValues {
    /// <p>The dynamic value of the <code>DecimalDefaultValues</code>. Different defaults are displayed according to users, groups, and values mapping.</p>
    #[doc(hidden)]
    pub dynamic_value: std::option::Option<crate::model::DynamicDefaultValue>,
    /// <p>The static values of the <code>DecimalDefaultValues</code>.</p>
    #[doc(hidden)]
    pub static_values: std::option::Option<std::vec::Vec<f64>>,
}
impl DecimalDefaultValues {
    /// <p>The dynamic value of the <code>DecimalDefaultValues</code>. Different defaults are displayed according to users, groups, and values mapping.</p>
    pub fn dynamic_value(&self) -> std::option::Option<&crate::model::DynamicDefaultValue> {
        self.dynamic_value.as_ref()
    }
    /// <p>The static values of the <code>DecimalDefaultValues</code>.</p>
    pub fn static_values(&self) -> std::option::Option<&[f64]> {
        self.static_values.as_deref()
    }
}
/// See [`DecimalDefaultValues`](crate::model::DecimalDefaultValues).
pub mod decimal_default_values {

    /// A builder for [`DecimalDefaultValues`](crate::model::DecimalDefaultValues).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dynamic_value: std::option::Option<crate::model::DynamicDefaultValue>,
        pub(crate) static_values: std::option::Option<std::vec::Vec<f64>>,
    }
    impl Builder {
        /// <p>The dynamic value of the <code>DecimalDefaultValues</code>. Different defaults are displayed according to users, groups, and values mapping.</p>
        pub fn dynamic_value(mut self, input: crate::model::DynamicDefaultValue) -> Self {
            self.dynamic_value = Some(input);
            self
        }
        /// <p>The dynamic value of the <code>DecimalDefaultValues</code>. Different defaults are displayed according to users, groups, and values mapping.</p>
        pub fn set_dynamic_value(
            mut self,
            input: std::option::Option<crate::model::DynamicDefaultValue>,
        ) -> Self {
            self.dynamic_value = input;
            self
        }
        /// Appends an item to `static_values`.
        ///
        /// To override the contents of this collection use [`set_static_values`](Self::set_static_values).
        ///
        /// <p>The static values of the <code>DecimalDefaultValues</code>.</p>
        pub fn static_values(mut self, input: f64) -> Self {
            let mut v = self.static_values.unwrap_or_default();
            v.push(input);
            self.static_values = Some(v);
            self
        }
        /// <p>The static values of the <code>DecimalDefaultValues</code>.</p>
        pub fn set_static_values(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.static_values = input;
            self
        }
        /// Consumes the builder and constructs a [`DecimalDefaultValues`](crate::model::DecimalDefaultValues).
        pub fn build(self) -> crate::model::DecimalDefaultValues {
            crate::model::DecimalDefaultValues {
                dynamic_value: self.dynamic_value,
                static_values: self.static_values,
            }
        }
    }
}
impl DecimalDefaultValues {
    /// Creates a new builder-style object to manufacture [`DecimalDefaultValues`](crate::model::DecimalDefaultValues).
    pub fn builder() -> crate::model::decimal_default_values::Builder {
        crate::model::decimal_default_values::Builder::default()
    }
}

/// <p>A parameter declaration for the <code>String</code> data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StringParameterDeclaration {
    /// <p>The value type determines whether the parameter is a single-value or multi-value parameter.</p>
    #[doc(hidden)]
    pub parameter_value_type: std::option::Option<crate::model::ParameterValueType>,
    /// <p>The name of the parameter that is being declared.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.</p>
    #[doc(hidden)]
    pub default_values: std::option::Option<crate::model::StringDefaultValues>,
    /// <p>The configuration that defines the default value of a <code>String</code> parameter when a value has not been set.</p>
    #[doc(hidden)]
    pub value_when_unset: std::option::Option<crate::model::StringValueWhenUnsetConfiguration>,
}
impl StringParameterDeclaration {
    /// <p>The value type determines whether the parameter is a single-value or multi-value parameter.</p>
    pub fn parameter_value_type(&self) -> std::option::Option<&crate::model::ParameterValueType> {
        self.parameter_value_type.as_ref()
    }
    /// <p>The name of the parameter that is being declared.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.</p>
    pub fn default_values(&self) -> std::option::Option<&crate::model::StringDefaultValues> {
        self.default_values.as_ref()
    }
    /// <p>The configuration that defines the default value of a <code>String</code> parameter when a value has not been set.</p>
    pub fn value_when_unset(
        &self,
    ) -> std::option::Option<&crate::model::StringValueWhenUnsetConfiguration> {
        self.value_when_unset.as_ref()
    }
}
/// See [`StringParameterDeclaration`](crate::model::StringParameterDeclaration).
pub mod string_parameter_declaration {

    /// A builder for [`StringParameterDeclaration`](crate::model::StringParameterDeclaration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_value_type: std::option::Option<crate::model::ParameterValueType>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) default_values: std::option::Option<crate::model::StringDefaultValues>,
        pub(crate) value_when_unset:
            std::option::Option<crate::model::StringValueWhenUnsetConfiguration>,
    }
    impl Builder {
        /// <p>The value type determines whether the parameter is a single-value or multi-value parameter.</p>
        pub fn parameter_value_type(mut self, input: crate::model::ParameterValueType) -> Self {
            self.parameter_value_type = Some(input);
            self
        }
        /// <p>The value type determines whether the parameter is a single-value or multi-value parameter.</p>
        pub fn set_parameter_value_type(
            mut self,
            input: std::option::Option<crate::model::ParameterValueType>,
        ) -> Self {
            self.parameter_value_type = input;
            self
        }
        /// <p>The name of the parameter that is being declared.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the parameter that is being declared.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.</p>
        pub fn default_values(mut self, input: crate::model::StringDefaultValues) -> Self {
            self.default_values = Some(input);
            self
        }
        /// <p>The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.</p>
        pub fn set_default_values(
            mut self,
            input: std::option::Option<crate::model::StringDefaultValues>,
        ) -> Self {
            self.default_values = input;
            self
        }
        /// <p>The configuration that defines the default value of a <code>String</code> parameter when a value has not been set.</p>
        pub fn value_when_unset(
            mut self,
            input: crate::model::StringValueWhenUnsetConfiguration,
        ) -> Self {
            self.value_when_unset = Some(input);
            self
        }
        /// <p>The configuration that defines the default value of a <code>String</code> parameter when a value has not been set.</p>
        pub fn set_value_when_unset(
            mut self,
            input: std::option::Option<crate::model::StringValueWhenUnsetConfiguration>,
        ) -> Self {
            self.value_when_unset = input;
            self
        }
        /// Consumes the builder and constructs a [`StringParameterDeclaration`](crate::model::StringParameterDeclaration).
        pub fn build(self) -> crate::model::StringParameterDeclaration {
            crate::model::StringParameterDeclaration {
                parameter_value_type: self.parameter_value_type,
                name: self.name,
                default_values: self.default_values,
                value_when_unset: self.value_when_unset,
            }
        }
    }
}
impl StringParameterDeclaration {
    /// Creates a new builder-style object to manufacture [`StringParameterDeclaration`](crate::model::StringParameterDeclaration).
    pub fn builder() -> crate::model::string_parameter_declaration::Builder {
        crate::model::string_parameter_declaration::Builder::default()
    }
}

/// <p>The configuration that defines the default value of a <code>String</code> parameter when a value has not been set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StringValueWhenUnsetConfiguration {
    /// <p>The built-in options for default values. The value can be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>RECOMMENDED</code>: The recommended value.</p> </li>
    /// <li> <p> <code>NULL</code>: The <code>NULL</code> value.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub value_when_unset_option: std::option::Option<crate::model::ValueWhenUnsetOption>,
    /// <p>A custom value that's used when the value of a parameter isn't set.</p>
    #[doc(hidden)]
    pub custom_value: std::option::Option<std::string::String>,
}
impl StringValueWhenUnsetConfiguration {
    /// <p>The built-in options for default values. The value can be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>RECOMMENDED</code>: The recommended value.</p> </li>
    /// <li> <p> <code>NULL</code>: The <code>NULL</code> value.</p> </li>
    /// </ul>
    pub fn value_when_unset_option(
        &self,
    ) -> std::option::Option<&crate::model::ValueWhenUnsetOption> {
        self.value_when_unset_option.as_ref()
    }
    /// <p>A custom value that's used when the value of a parameter isn't set.</p>
    pub fn custom_value(&self) -> std::option::Option<&str> {
        self.custom_value.as_deref()
    }
}
impl std::fmt::Debug for StringValueWhenUnsetConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StringValueWhenUnsetConfiguration");
        formatter.field("value_when_unset_option", &self.value_when_unset_option);
        formatter.field("custom_value", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`StringValueWhenUnsetConfiguration`](crate::model::StringValueWhenUnsetConfiguration).
pub mod string_value_when_unset_configuration {

    /// A builder for [`StringValueWhenUnsetConfiguration`](crate::model::StringValueWhenUnsetConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) value_when_unset_option: std::option::Option<crate::model::ValueWhenUnsetOption>,
        pub(crate) custom_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The built-in options for default values. The value can be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>RECOMMENDED</code>: The recommended value.</p> </li>
        /// <li> <p> <code>NULL</code>: The <code>NULL</code> value.</p> </li>
        /// </ul>
        pub fn value_when_unset_option(
            mut self,
            input: crate::model::ValueWhenUnsetOption,
        ) -> Self {
            self.value_when_unset_option = Some(input);
            self
        }
        /// <p>The built-in options for default values. The value can be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>RECOMMENDED</code>: The recommended value.</p> </li>
        /// <li> <p> <code>NULL</code>: The <code>NULL</code> value.</p> </li>
        /// </ul>
        pub fn set_value_when_unset_option(
            mut self,
            input: std::option::Option<crate::model::ValueWhenUnsetOption>,
        ) -> Self {
            self.value_when_unset_option = input;
            self
        }
        /// <p>A custom value that's used when the value of a parameter isn't set.</p>
        pub fn custom_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_value = Some(input.into());
            self
        }
        /// <p>A custom value that's used when the value of a parameter isn't set.</p>
        pub fn set_custom_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.custom_value = input;
            self
        }
        /// Consumes the builder and constructs a [`StringValueWhenUnsetConfiguration`](crate::model::StringValueWhenUnsetConfiguration).
        pub fn build(self) -> crate::model::StringValueWhenUnsetConfiguration {
            crate::model::StringValueWhenUnsetConfiguration {
                value_when_unset_option: self.value_when_unset_option,
                custom_value: self.custom_value,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("value_when_unset_option", &self.value_when_unset_option);
            formatter.field("custom_value", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl StringValueWhenUnsetConfiguration {
    /// Creates a new builder-style object to manufacture [`StringValueWhenUnsetConfiguration`](crate::model::StringValueWhenUnsetConfiguration).
    pub fn builder() -> crate::model::string_value_when_unset_configuration::Builder {
        crate::model::string_value_when_unset_configuration::Builder::default()
    }
}

/// <p>The default values of the <code>StringParameterDeclaration</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StringDefaultValues {
    /// <p>The dynamic value of the <code>StringDefaultValues</code>. Different defaults displayed according to users, groups, and values mapping.</p>
    #[doc(hidden)]
    pub dynamic_value: std::option::Option<crate::model::DynamicDefaultValue>,
    /// <p>The static values of the <code>DecimalDefaultValues</code>.</p>
    #[doc(hidden)]
    pub static_values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl StringDefaultValues {
    /// <p>The dynamic value of the <code>StringDefaultValues</code>. Different defaults displayed according to users, groups, and values mapping.</p>
    pub fn dynamic_value(&self) -> std::option::Option<&crate::model::DynamicDefaultValue> {
        self.dynamic_value.as_ref()
    }
    /// <p>The static values of the <code>DecimalDefaultValues</code>.</p>
    pub fn static_values(&self) -> std::option::Option<&[std::string::String]> {
        self.static_values.as_deref()
    }
}
/// See [`StringDefaultValues`](crate::model::StringDefaultValues).
pub mod string_default_values {

    /// A builder for [`StringDefaultValues`](crate::model::StringDefaultValues).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dynamic_value: std::option::Option<crate::model::DynamicDefaultValue>,
        pub(crate) static_values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The dynamic value of the <code>StringDefaultValues</code>. Different defaults displayed according to users, groups, and values mapping.</p>
        pub fn dynamic_value(mut self, input: crate::model::DynamicDefaultValue) -> Self {
            self.dynamic_value = Some(input);
            self
        }
        /// <p>The dynamic value of the <code>StringDefaultValues</code>. Different defaults displayed according to users, groups, and values mapping.</p>
        pub fn set_dynamic_value(
            mut self,
            input: std::option::Option<crate::model::DynamicDefaultValue>,
        ) -> Self {
            self.dynamic_value = input;
            self
        }
        /// Appends an item to `static_values`.
        ///
        /// To override the contents of this collection use [`set_static_values`](Self::set_static_values).
        ///
        /// <p>The static values of the <code>DecimalDefaultValues</code>.</p>
        pub fn static_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.static_values.unwrap_or_default();
            v.push(input.into());
            self.static_values = Some(v);
            self
        }
        /// <p>The static values of the <code>DecimalDefaultValues</code>.</p>
        pub fn set_static_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.static_values = input;
            self
        }
        /// Consumes the builder and constructs a [`StringDefaultValues`](crate::model::StringDefaultValues).
        pub fn build(self) -> crate::model::StringDefaultValues {
            crate::model::StringDefaultValues {
                dynamic_value: self.dynamic_value,
                static_values: self.static_values,
            }
        }
    }
}
impl StringDefaultValues {
    /// Creates a new builder-style object to manufacture [`StringDefaultValues`](crate::model::StringDefaultValues).
    pub fn builder() -> crate::model::string_default_values::Builder {
        crate::model::string_default_values::Builder::default()
    }
}

/// <p>The calculated field of an analysis.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CalculatedField {
    /// <p>The data set that is used in this calculated field.</p>
    #[doc(hidden)]
    pub data_set_identifier: std::option::Option<std::string::String>,
    /// <p>The name of the calculated field.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The expression of the calculated field.</p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::string::String>,
}
impl CalculatedField {
    /// <p>The data set that is used in this calculated field.</p>
    pub fn data_set_identifier(&self) -> std::option::Option<&str> {
        self.data_set_identifier.as_deref()
    }
    /// <p>The name of the calculated field.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The expression of the calculated field.</p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
}
impl std::fmt::Debug for CalculatedField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CalculatedField");
        formatter.field("data_set_identifier", &self.data_set_identifier);
        formatter.field("name", &self.name);
        formatter.field("expression", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`CalculatedField`](crate::model::CalculatedField).
pub mod calculated_field {

    /// A builder for [`CalculatedField`](crate::model::CalculatedField).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) data_set_identifier: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) expression: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The data set that is used in this calculated field.</p>
        pub fn data_set_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_set_identifier = Some(input.into());
            self
        }
        /// <p>The data set that is used in this calculated field.</p>
        pub fn set_data_set_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_set_identifier = input;
            self
        }
        /// <p>The name of the calculated field.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the calculated field.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The expression of the calculated field.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>The expression of the calculated field.</p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// Consumes the builder and constructs a [`CalculatedField`](crate::model::CalculatedField).
        pub fn build(self) -> crate::model::CalculatedField {
            crate::model::CalculatedField {
                data_set_identifier: self.data_set_identifier,
                name: self.name,
                expression: self.expression,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("data_set_identifier", &self.data_set_identifier);
            formatter.field("name", &self.name);
            formatter.field("expression", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl CalculatedField {
    /// Creates a new builder-style object to manufacture [`CalculatedField`](crate::model::CalculatedField).
    pub fn builder() -> crate::model::calculated_field::Builder {
        crate::model::calculated_field::Builder::default()
    }
}

/// <p>A sheet is an object that contains a set of visuals that are viewed together on one page in a paginated report. Every analysis and dashboard must contain at least one sheet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SheetDefinition {
    /// <p>The unique identifier of a sheet.</p>
    #[doc(hidden)]
    pub sheet_id: std::option::Option<std::string::String>,
    /// <p>The title of the sheet.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>A description of the sheet.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The name of the sheet. This name is displayed on the sheet's tab in the Amazon QuickSight console.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The list of parameter controls that are on a sheet.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-controls.html">Using a Control with a Parameter in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub parameter_controls: std::option::Option<std::vec::Vec<crate::model::ParameterControl>>,
    /// <p>The list of filter controls that are on a sheet.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/filter-controls.html">Adding filter controls to analysis sheets</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub filter_controls: std::option::Option<std::vec::Vec<crate::model::FilterControl>>,
    /// <p>A list of the visuals that are on a sheet. Visual placement is determined by the layout of the sheet.</p>
    #[doc(hidden)]
    pub visuals: std::option::Option<std::vec::Vec<crate::model::Visual>>,
    /// <p>The text boxes that are on a sheet.</p>
    #[doc(hidden)]
    pub text_boxes: std::option::Option<std::vec::Vec<crate::model::SheetTextBox>>,
    /// <p>Layouts define how the components of a sheet are arranged.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/types-of-layout.html">Types of layout</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub layouts: std::option::Option<std::vec::Vec<crate::model::Layout>>,
    /// <p>The control layouts of the sheet.</p>
    #[doc(hidden)]
    pub sheet_control_layouts: std::option::Option<std::vec::Vec<crate::model::SheetControlLayout>>,
    /// <p>The layout content type of the sheet. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>PAGINATED</code>: Creates a sheet for a paginated report.</p> </li>
    /// <li> <p> <code>INTERACTIVE</code>: Creates a sheet for an interactive dashboard.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub content_type: std::option::Option<crate::model::SheetContentType>,
}
impl SheetDefinition {
    /// <p>The unique identifier of a sheet.</p>
    pub fn sheet_id(&self) -> std::option::Option<&str> {
        self.sheet_id.as_deref()
    }
    /// <p>The title of the sheet.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>A description of the sheet.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The name of the sheet. This name is displayed on the sheet's tab in the Amazon QuickSight console.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The list of parameter controls that are on a sheet.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-controls.html">Using a Control with a Parameter in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn parameter_controls(&self) -> std::option::Option<&[crate::model::ParameterControl]> {
        self.parameter_controls.as_deref()
    }
    /// <p>The list of filter controls that are on a sheet.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/filter-controls.html">Adding filter controls to analysis sheets</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn filter_controls(&self) -> std::option::Option<&[crate::model::FilterControl]> {
        self.filter_controls.as_deref()
    }
    /// <p>A list of the visuals that are on a sheet. Visual placement is determined by the layout of the sheet.</p>
    pub fn visuals(&self) -> std::option::Option<&[crate::model::Visual]> {
        self.visuals.as_deref()
    }
    /// <p>The text boxes that are on a sheet.</p>
    pub fn text_boxes(&self) -> std::option::Option<&[crate::model::SheetTextBox]> {
        self.text_boxes.as_deref()
    }
    /// <p>Layouts define how the components of a sheet are arranged.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/types-of-layout.html">Types of layout</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn layouts(&self) -> std::option::Option<&[crate::model::Layout]> {
        self.layouts.as_deref()
    }
    /// <p>The control layouts of the sheet.</p>
    pub fn sheet_control_layouts(
        &self,
    ) -> std::option::Option<&[crate::model::SheetControlLayout]> {
        self.sheet_control_layouts.as_deref()
    }
    /// <p>The layout content type of the sheet. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>PAGINATED</code>: Creates a sheet for a paginated report.</p> </li>
    /// <li> <p> <code>INTERACTIVE</code>: Creates a sheet for an interactive dashboard.</p> </li>
    /// </ul>
    pub fn content_type(&self) -> std::option::Option<&crate::model::SheetContentType> {
        self.content_type.as_ref()
    }
}
/// See [`SheetDefinition`](crate::model::SheetDefinition).
pub mod sheet_definition {

    /// A builder for [`SheetDefinition`](crate::model::SheetDefinition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sheet_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) parameter_controls:
            std::option::Option<std::vec::Vec<crate::model::ParameterControl>>,
        pub(crate) filter_controls: std::option::Option<std::vec::Vec<crate::model::FilterControl>>,
        pub(crate) visuals: std::option::Option<std::vec::Vec<crate::model::Visual>>,
        pub(crate) text_boxes: std::option::Option<std::vec::Vec<crate::model::SheetTextBox>>,
        pub(crate) layouts: std::option::Option<std::vec::Vec<crate::model::Layout>>,
        pub(crate) sheet_control_layouts:
            std::option::Option<std::vec::Vec<crate::model::SheetControlLayout>>,
        pub(crate) content_type: std::option::Option<crate::model::SheetContentType>,
    }
    impl Builder {
        /// <p>The unique identifier of a sheet.</p>
        pub fn sheet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sheet_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a sheet.</p>
        pub fn set_sheet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sheet_id = input;
            self
        }
        /// <p>The title of the sheet.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the sheet.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>A description of the sheet.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the sheet.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The name of the sheet. This name is displayed on the sheet's tab in the Amazon QuickSight console.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the sheet. This name is displayed on the sheet's tab in the Amazon QuickSight console.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `parameter_controls`.
        ///
        /// To override the contents of this collection use [`set_parameter_controls`](Self::set_parameter_controls).
        ///
        /// <p>The list of parameter controls that are on a sheet.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-controls.html">Using a Control with a Parameter in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn parameter_controls(mut self, input: crate::model::ParameterControl) -> Self {
            let mut v = self.parameter_controls.unwrap_or_default();
            v.push(input);
            self.parameter_controls = Some(v);
            self
        }
        /// <p>The list of parameter controls that are on a sheet.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-controls.html">Using a Control with a Parameter in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_parameter_controls(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ParameterControl>>,
        ) -> Self {
            self.parameter_controls = input;
            self
        }
        /// Appends an item to `filter_controls`.
        ///
        /// To override the contents of this collection use [`set_filter_controls`](Self::set_filter_controls).
        ///
        /// <p>The list of filter controls that are on a sheet.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/filter-controls.html">Adding filter controls to analysis sheets</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn filter_controls(mut self, input: crate::model::FilterControl) -> Self {
            let mut v = self.filter_controls.unwrap_or_default();
            v.push(input);
            self.filter_controls = Some(v);
            self
        }
        /// <p>The list of filter controls that are on a sheet.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/filter-controls.html">Adding filter controls to analysis sheets</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_filter_controls(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FilterControl>>,
        ) -> Self {
            self.filter_controls = input;
            self
        }
        /// Appends an item to `visuals`.
        ///
        /// To override the contents of this collection use [`set_visuals`](Self::set_visuals).
        ///
        /// <p>A list of the visuals that are on a sheet. Visual placement is determined by the layout of the sheet.</p>
        pub fn visuals(mut self, input: crate::model::Visual) -> Self {
            let mut v = self.visuals.unwrap_or_default();
            v.push(input);
            self.visuals = Some(v);
            self
        }
        /// <p>A list of the visuals that are on a sheet. Visual placement is determined by the layout of the sheet.</p>
        pub fn set_visuals(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Visual>>,
        ) -> Self {
            self.visuals = input;
            self
        }
        /// Appends an item to `text_boxes`.
        ///
        /// To override the contents of this collection use [`set_text_boxes`](Self::set_text_boxes).
        ///
        /// <p>The text boxes that are on a sheet.</p>
        pub fn text_boxes(mut self, input: crate::model::SheetTextBox) -> Self {
            let mut v = self.text_boxes.unwrap_or_default();
            v.push(input);
            self.text_boxes = Some(v);
            self
        }
        /// <p>The text boxes that are on a sheet.</p>
        pub fn set_text_boxes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SheetTextBox>>,
        ) -> Self {
            self.text_boxes = input;
            self
        }
        /// Appends an item to `layouts`.
        ///
        /// To override the contents of this collection use [`set_layouts`](Self::set_layouts).
        ///
        /// <p>Layouts define how the components of a sheet are arranged.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/types-of-layout.html">Types of layout</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn layouts(mut self, input: crate::model::Layout) -> Self {
            let mut v = self.layouts.unwrap_or_default();
            v.push(input);
            self.layouts = Some(v);
            self
        }
        /// <p>Layouts define how the components of a sheet are arranged.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/types-of-layout.html">Types of layout</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_layouts(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Layout>>,
        ) -> Self {
            self.layouts = input;
            self
        }
        /// Appends an item to `sheet_control_layouts`.
        ///
        /// To override the contents of this collection use [`set_sheet_control_layouts`](Self::set_sheet_control_layouts).
        ///
        /// <p>The control layouts of the sheet.</p>
        pub fn sheet_control_layouts(mut self, input: crate::model::SheetControlLayout) -> Self {
            let mut v = self.sheet_control_layouts.unwrap_or_default();
            v.push(input);
            self.sheet_control_layouts = Some(v);
            self
        }
        /// <p>The control layouts of the sheet.</p>
        pub fn set_sheet_control_layouts(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SheetControlLayout>>,
        ) -> Self {
            self.sheet_control_layouts = input;
            self
        }
        /// <p>The layout content type of the sheet. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>PAGINATED</code>: Creates a sheet for a paginated report.</p> </li>
        /// <li> <p> <code>INTERACTIVE</code>: Creates a sheet for an interactive dashboard.</p> </li>
        /// </ul>
        pub fn content_type(mut self, input: crate::model::SheetContentType) -> Self {
            self.content_type = Some(input);
            self
        }
        /// <p>The layout content type of the sheet. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>PAGINATED</code>: Creates a sheet for a paginated report.</p> </li>
        /// <li> <p> <code>INTERACTIVE</code>: Creates a sheet for an interactive dashboard.</p> </li>
        /// </ul>
        pub fn set_content_type(
            mut self,
            input: std::option::Option<crate::model::SheetContentType>,
        ) -> Self {
            self.content_type = input;
            self
        }
        /// Consumes the builder and constructs a [`SheetDefinition`](crate::model::SheetDefinition).
        pub fn build(self) -> crate::model::SheetDefinition {
            crate::model::SheetDefinition {
                sheet_id: self.sheet_id,
                title: self.title,
                description: self.description,
                name: self.name,
                parameter_controls: self.parameter_controls,
                filter_controls: self.filter_controls,
                visuals: self.visuals,
                text_boxes: self.text_boxes,
                layouts: self.layouts,
                sheet_control_layouts: self.sheet_control_layouts,
                content_type: self.content_type,
            }
        }
    }
}
impl SheetDefinition {
    /// Creates a new builder-style object to manufacture [`SheetDefinition`](crate::model::SheetDefinition).
    pub fn builder() -> crate::model::sheet_definition::Builder {
        crate::model::sheet_definition::Builder::default()
    }
}

/// <p>A grid layout to define the placement of sheet control.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SheetControlLayout {
    /// <p>The configuration that determines the elements and canvas size options of sheet control.</p>
    #[doc(hidden)]
    pub configuration: std::option::Option<crate::model::SheetControlLayoutConfiguration>,
}
impl SheetControlLayout {
    /// <p>The configuration that determines the elements and canvas size options of sheet control.</p>
    pub fn configuration(
        &self,
    ) -> std::option::Option<&crate::model::SheetControlLayoutConfiguration> {
        self.configuration.as_ref()
    }
}
/// See [`SheetControlLayout`](crate::model::SheetControlLayout).
pub mod sheet_control_layout {

    /// A builder for [`SheetControlLayout`](crate::model::SheetControlLayout).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration:
            std::option::Option<crate::model::SheetControlLayoutConfiguration>,
    }
    impl Builder {
        /// <p>The configuration that determines the elements and canvas size options of sheet control.</p>
        pub fn configuration(
            mut self,
            input: crate::model::SheetControlLayoutConfiguration,
        ) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>The configuration that determines the elements and canvas size options of sheet control.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::SheetControlLayoutConfiguration>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`SheetControlLayout`](crate::model::SheetControlLayout).
        pub fn build(self) -> crate::model::SheetControlLayout {
            crate::model::SheetControlLayout {
                configuration: self.configuration,
            }
        }
    }
}
impl SheetControlLayout {
    /// Creates a new builder-style object to manufacture [`SheetControlLayout`](crate::model::SheetControlLayout).
    pub fn builder() -> crate::model::sheet_control_layout::Builder {
        crate::model::sheet_control_layout::Builder::default()
    }
}

/// <p>The configuration that determines the elements and canvas size options of sheet control.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SheetControlLayoutConfiguration {
    /// <p>The configuration that determines the elements and canvas size options of sheet control.</p>
    #[doc(hidden)]
    pub grid_layout: std::option::Option<crate::model::GridLayoutConfiguration>,
}
impl SheetControlLayoutConfiguration {
    /// <p>The configuration that determines the elements and canvas size options of sheet control.</p>
    pub fn grid_layout(&self) -> std::option::Option<&crate::model::GridLayoutConfiguration> {
        self.grid_layout.as_ref()
    }
}
/// See [`SheetControlLayoutConfiguration`](crate::model::SheetControlLayoutConfiguration).
pub mod sheet_control_layout_configuration {

    /// A builder for [`SheetControlLayoutConfiguration`](crate::model::SheetControlLayoutConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) grid_layout: std::option::Option<crate::model::GridLayoutConfiguration>,
    }
    impl Builder {
        /// <p>The configuration that determines the elements and canvas size options of sheet control.</p>
        pub fn grid_layout(mut self, input: crate::model::GridLayoutConfiguration) -> Self {
            self.grid_layout = Some(input);
            self
        }
        /// <p>The configuration that determines the elements and canvas size options of sheet control.</p>
        pub fn set_grid_layout(
            mut self,
            input: std::option::Option<crate::model::GridLayoutConfiguration>,
        ) -> Self {
            self.grid_layout = input;
            self
        }
        /// Consumes the builder and constructs a [`SheetControlLayoutConfiguration`](crate::model::SheetControlLayoutConfiguration).
        pub fn build(self) -> crate::model::SheetControlLayoutConfiguration {
            crate::model::SheetControlLayoutConfiguration {
                grid_layout: self.grid_layout,
            }
        }
    }
}
impl SheetControlLayoutConfiguration {
    /// Creates a new builder-style object to manufacture [`SheetControlLayoutConfiguration`](crate::model::SheetControlLayoutConfiguration).
    pub fn builder() -> crate::model::sheet_control_layout_configuration::Builder {
        crate::model::sheet_control_layout_configuration::Builder::default()
    }
}

/// <p>The configuration for a grid layout. Also called a tiled layout.</p>
/// <p>Visuals snap to a grid with standard spacing and alignment. Dashboards are displayed as designed, with options to fit to screen or view at actual size.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GridLayoutConfiguration {
    /// <p>The elements that are included in a grid layout.</p>
    #[doc(hidden)]
    pub elements: std::option::Option<std::vec::Vec<crate::model::GridLayoutElement>>,
    /// <p>Configuration options for the canvas of a grid layout.</p>
    #[doc(hidden)]
    pub canvas_size_options: std::option::Option<crate::model::GridLayoutCanvasSizeOptions>,
}
impl GridLayoutConfiguration {
    /// <p>The elements that are included in a grid layout.</p>
    pub fn elements(&self) -> std::option::Option<&[crate::model::GridLayoutElement]> {
        self.elements.as_deref()
    }
    /// <p>Configuration options for the canvas of a grid layout.</p>
    pub fn canvas_size_options(
        &self,
    ) -> std::option::Option<&crate::model::GridLayoutCanvasSizeOptions> {
        self.canvas_size_options.as_ref()
    }
}
/// See [`GridLayoutConfiguration`](crate::model::GridLayoutConfiguration).
pub mod grid_layout_configuration {

    /// A builder for [`GridLayoutConfiguration`](crate::model::GridLayoutConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) elements: std::option::Option<std::vec::Vec<crate::model::GridLayoutElement>>,
        pub(crate) canvas_size_options:
            std::option::Option<crate::model::GridLayoutCanvasSizeOptions>,
    }
    impl Builder {
        /// Appends an item to `elements`.
        ///
        /// To override the contents of this collection use [`set_elements`](Self::set_elements).
        ///
        /// <p>The elements that are included in a grid layout.</p>
        pub fn elements(mut self, input: crate::model::GridLayoutElement) -> Self {
            let mut v = self.elements.unwrap_or_default();
            v.push(input);
            self.elements = Some(v);
            self
        }
        /// <p>The elements that are included in a grid layout.</p>
        pub fn set_elements(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GridLayoutElement>>,
        ) -> Self {
            self.elements = input;
            self
        }
        /// <p>Configuration options for the canvas of a grid layout.</p>
        pub fn canvas_size_options(
            mut self,
            input: crate::model::GridLayoutCanvasSizeOptions,
        ) -> Self {
            self.canvas_size_options = Some(input);
            self
        }
        /// <p>Configuration options for the canvas of a grid layout.</p>
        pub fn set_canvas_size_options(
            mut self,
            input: std::option::Option<crate::model::GridLayoutCanvasSizeOptions>,
        ) -> Self {
            self.canvas_size_options = input;
            self
        }
        /// Consumes the builder and constructs a [`GridLayoutConfiguration`](crate::model::GridLayoutConfiguration).
        pub fn build(self) -> crate::model::GridLayoutConfiguration {
            crate::model::GridLayoutConfiguration {
                elements: self.elements,
                canvas_size_options: self.canvas_size_options,
            }
        }
    }
}
impl GridLayoutConfiguration {
    /// Creates a new builder-style object to manufacture [`GridLayoutConfiguration`](crate::model::GridLayoutConfiguration).
    pub fn builder() -> crate::model::grid_layout_configuration::Builder {
        crate::model::grid_layout_configuration::Builder::default()
    }
}

/// <p>An element within a grid layout.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GridLayoutElement {
    /// <p>A unique identifier for an element within a grid layout.</p>
    #[doc(hidden)]
    pub element_id: std::option::Option<std::string::String>,
    /// <p>The type of element.</p>
    #[doc(hidden)]
    pub element_type: std::option::Option<crate::model::LayoutElementType>,
    /// <p>The column index for the upper left corner of an element.</p>
    #[doc(hidden)]
    pub column_index: std::option::Option<i32>,
    /// <p>The width of a grid element expressed as a number of grid columns.</p>
    #[doc(hidden)]
    pub column_span: std::option::Option<i32>,
    /// <p>The row index for the upper left corner of an element.</p>
    #[doc(hidden)]
    pub row_index: std::option::Option<i32>,
    /// <p>The height of a grid element expressed as a number of grid rows.</p>
    #[doc(hidden)]
    pub row_span: std::option::Option<i32>,
}
impl GridLayoutElement {
    /// <p>A unique identifier for an element within a grid layout.</p>
    pub fn element_id(&self) -> std::option::Option<&str> {
        self.element_id.as_deref()
    }
    /// <p>The type of element.</p>
    pub fn element_type(&self) -> std::option::Option<&crate::model::LayoutElementType> {
        self.element_type.as_ref()
    }
    /// <p>The column index for the upper left corner of an element.</p>
    pub fn column_index(&self) -> std::option::Option<i32> {
        self.column_index
    }
    /// <p>The width of a grid element expressed as a number of grid columns.</p>
    pub fn column_span(&self) -> std::option::Option<i32> {
        self.column_span
    }
    /// <p>The row index for the upper left corner of an element.</p>
    pub fn row_index(&self) -> std::option::Option<i32> {
        self.row_index
    }
    /// <p>The height of a grid element expressed as a number of grid rows.</p>
    pub fn row_span(&self) -> std::option::Option<i32> {
        self.row_span
    }
}
/// See [`GridLayoutElement`](crate::model::GridLayoutElement).
pub mod grid_layout_element {

    /// A builder for [`GridLayoutElement`](crate::model::GridLayoutElement).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) element_id: std::option::Option<std::string::String>,
        pub(crate) element_type: std::option::Option<crate::model::LayoutElementType>,
        pub(crate) column_index: std::option::Option<i32>,
        pub(crate) column_span: std::option::Option<i32>,
        pub(crate) row_index: std::option::Option<i32>,
        pub(crate) row_span: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>A unique identifier for an element within a grid layout.</p>
        pub fn element_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.element_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for an element within a grid layout.</p>
        pub fn set_element_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.element_id = input;
            self
        }
        /// <p>The type of element.</p>
        pub fn element_type(mut self, input: crate::model::LayoutElementType) -> Self {
            self.element_type = Some(input);
            self
        }
        /// <p>The type of element.</p>
        pub fn set_element_type(
            mut self,
            input: std::option::Option<crate::model::LayoutElementType>,
        ) -> Self {
            self.element_type = input;
            self
        }
        /// <p>The column index for the upper left corner of an element.</p>
        pub fn column_index(mut self, input: i32) -> Self {
            self.column_index = Some(input);
            self
        }
        /// <p>The column index for the upper left corner of an element.</p>
        pub fn set_column_index(mut self, input: std::option::Option<i32>) -> Self {
            self.column_index = input;
            self
        }
        /// <p>The width of a grid element expressed as a number of grid columns.</p>
        pub fn column_span(mut self, input: i32) -> Self {
            self.column_span = Some(input);
            self
        }
        /// <p>The width of a grid element expressed as a number of grid columns.</p>
        pub fn set_column_span(mut self, input: std::option::Option<i32>) -> Self {
            self.column_span = input;
            self
        }
        /// <p>The row index for the upper left corner of an element.</p>
        pub fn row_index(mut self, input: i32) -> Self {
            self.row_index = Some(input);
            self
        }
        /// <p>The row index for the upper left corner of an element.</p>
        pub fn set_row_index(mut self, input: std::option::Option<i32>) -> Self {
            self.row_index = input;
            self
        }
        /// <p>The height of a grid element expressed as a number of grid rows.</p>
        pub fn row_span(mut self, input: i32) -> Self {
            self.row_span = Some(input);
            self
        }
        /// <p>The height of a grid element expressed as a number of grid rows.</p>
        pub fn set_row_span(mut self, input: std::option::Option<i32>) -> Self {
            self.row_span = input;
            self
        }
        /// Consumes the builder and constructs a [`GridLayoutElement`](crate::model::GridLayoutElement).
        pub fn build(self) -> crate::model::GridLayoutElement {
            crate::model::GridLayoutElement {
                element_id: self.element_id,
                element_type: self.element_type,
                column_index: self.column_index,
                column_span: self.column_span,
                row_index: self.row_index,
                row_span: self.row_span,
            }
        }
    }
}
impl GridLayoutElement {
    /// Creates a new builder-style object to manufacture [`GridLayoutElement`](crate::model::GridLayoutElement).
    pub fn builder() -> crate::model::grid_layout_element::Builder {
        crate::model::grid_layout_element::Builder::default()
    }
}

/// When writing a match expression against `LayoutElementType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let layoutelementtype = unimplemented!();
/// match layoutelementtype {
///     LayoutElementType::FilterControl => { /* ... */ },
///     LayoutElementType::ParameterControl => { /* ... */ },
///     LayoutElementType::TextBox => { /* ... */ },
///     LayoutElementType::Visual => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `layoutelementtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LayoutElementType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LayoutElementType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LayoutElementType::NewFeature` is defined.
/// Specifically, when `layoutelementtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LayoutElementType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LayoutElementType {
    #[allow(missing_docs)] // documentation missing in model
    FilterControl,
    #[allow(missing_docs)] // documentation missing in model
    ParameterControl,
    #[allow(missing_docs)] // documentation missing in model
    TextBox,
    #[allow(missing_docs)] // documentation missing in model
    Visual,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LayoutElementType {
    fn from(s: &str) -> Self {
        match s {
            "FILTER_CONTROL" => LayoutElementType::FilterControl,
            "PARAMETER_CONTROL" => LayoutElementType::ParameterControl,
            "TEXT_BOX" => LayoutElementType::TextBox,
            "VISUAL" => LayoutElementType::Visual,
            other => {
                LayoutElementType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for LayoutElementType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LayoutElementType::from(s))
    }
}
impl LayoutElementType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LayoutElementType::FilterControl => "FILTER_CONTROL",
            LayoutElementType::ParameterControl => "PARAMETER_CONTROL",
            LayoutElementType::TextBox => "TEXT_BOX",
            LayoutElementType::Visual => "VISUAL",
            LayoutElementType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FILTER_CONTROL", "PARAMETER_CONTROL", "TEXT_BOX", "VISUAL"]
    }
}
impl AsRef<str> for LayoutElementType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A <code>Layout</code> defines the placement of elements within a sheet.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/types-of-layout.html">Types of layout</a> in the <i>Amazon QuickSight User Guide</i>.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Layout {
    /// <p>The configuration that determines what the type of layout for a sheet.</p>
    #[doc(hidden)]
    pub configuration: std::option::Option<crate::model::LayoutConfiguration>,
}
impl Layout {
    /// <p>The configuration that determines what the type of layout for a sheet.</p>
    pub fn configuration(&self) -> std::option::Option<&crate::model::LayoutConfiguration> {
        self.configuration.as_ref()
    }
}
/// See [`Layout`](crate::model::Layout).
pub mod layout {

    /// A builder for [`Layout`](crate::model::Layout).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration: std::option::Option<crate::model::LayoutConfiguration>,
    }
    impl Builder {
        /// <p>The configuration that determines what the type of layout for a sheet.</p>
        pub fn configuration(mut self, input: crate::model::LayoutConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>The configuration that determines what the type of layout for a sheet.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::LayoutConfiguration>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`Layout`](crate::model::Layout).
        pub fn build(self) -> crate::model::Layout {
            crate::model::Layout {
                configuration: self.configuration,
            }
        }
    }
}
impl Layout {
    /// Creates a new builder-style object to manufacture [`Layout`](crate::model::Layout).
    pub fn builder() -> crate::model::layout::Builder {
        crate::model::layout::Builder::default()
    }
}

/// <p>The configuration that determines what the type of layout will be used on a sheet.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LayoutConfiguration {
    /// <p>A type of layout that can be used on a sheet. In a grid layout, visuals snap to a grid with standard spacing and alignment. Dashboards are displayed as designed, with options to fit to screen or view at actual size. A grid layout can be configured to behave in one of two ways when the viewport is resized: <code>FIXED</code> or <code>RESPONSIVE</code>.</p>
    #[doc(hidden)]
    pub grid_layout: std::option::Option<crate::model::GridLayoutConfiguration>,
    /// <p>A free-form is optimized for a fixed width and has more control over the exact placement of layout elements.</p>
    #[doc(hidden)]
    pub free_form_layout: std::option::Option<crate::model::FreeFormLayoutConfiguration>,
    /// <p>A section based layout organizes visuals into multiple sections and has customized header, footer and page break.</p>
    #[doc(hidden)]
    pub section_based_layout: std::option::Option<crate::model::SectionBasedLayoutConfiguration>,
}
impl LayoutConfiguration {
    /// <p>A type of layout that can be used on a sheet. In a grid layout, visuals snap to a grid with standard spacing and alignment. Dashboards are displayed as designed, with options to fit to screen or view at actual size. A grid layout can be configured to behave in one of two ways when the viewport is resized: <code>FIXED</code> or <code>RESPONSIVE</code>.</p>
    pub fn grid_layout(&self) -> std::option::Option<&crate::model::GridLayoutConfiguration> {
        self.grid_layout.as_ref()
    }
    /// <p>A free-form is optimized for a fixed width and has more control over the exact placement of layout elements.</p>
    pub fn free_form_layout(
        &self,
    ) -> std::option::Option<&crate::model::FreeFormLayoutConfiguration> {
        self.free_form_layout.as_ref()
    }
    /// <p>A section based layout organizes visuals into multiple sections and has customized header, footer and page break.</p>
    pub fn section_based_layout(
        &self,
    ) -> std::option::Option<&crate::model::SectionBasedLayoutConfiguration> {
        self.section_based_layout.as_ref()
    }
}
/// See [`LayoutConfiguration`](crate::model::LayoutConfiguration).
pub mod layout_configuration {

    /// A builder for [`LayoutConfiguration`](crate::model::LayoutConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) grid_layout: std::option::Option<crate::model::GridLayoutConfiguration>,
        pub(crate) free_form_layout: std::option::Option<crate::model::FreeFormLayoutConfiguration>,
        pub(crate) section_based_layout:
            std::option::Option<crate::model::SectionBasedLayoutConfiguration>,
    }
    impl Builder {
        /// <p>A type of layout that can be used on a sheet. In a grid layout, visuals snap to a grid with standard spacing and alignment. Dashboards are displayed as designed, with options to fit to screen or view at actual size. A grid layout can be configured to behave in one of two ways when the viewport is resized: <code>FIXED</code> or <code>RESPONSIVE</code>.</p>
        pub fn grid_layout(mut self, input: crate::model::GridLayoutConfiguration) -> Self {
            self.grid_layout = Some(input);
            self
        }
        /// <p>A type of layout that can be used on a sheet. In a grid layout, visuals snap to a grid with standard spacing and alignment. Dashboards are displayed as designed, with options to fit to screen or view at actual size. A grid layout can be configured to behave in one of two ways when the viewport is resized: <code>FIXED</code> or <code>RESPONSIVE</code>.</p>
        pub fn set_grid_layout(
            mut self,
            input: std::option::Option<crate::model::GridLayoutConfiguration>,
        ) -> Self {
            self.grid_layout = input;
            self
        }
        /// <p>A free-form is optimized for a fixed width and has more control over the exact placement of layout elements.</p>
        pub fn free_form_layout(
            mut self,
            input: crate::model::FreeFormLayoutConfiguration,
        ) -> Self {
            self.free_form_layout = Some(input);
            self
        }
        /// <p>A free-form is optimized for a fixed width and has more control over the exact placement of layout elements.</p>
        pub fn set_free_form_layout(
            mut self,
            input: std::option::Option<crate::model::FreeFormLayoutConfiguration>,
        ) -> Self {
            self.free_form_layout = input;
            self
        }
        /// <p>A section based layout organizes visuals into multiple sections and has customized header, footer and page break.</p>
        pub fn section_based_layout(
            mut self,
            input: crate::model::SectionBasedLayoutConfiguration,
        ) -> Self {
            self.section_based_layout = Some(input);
            self
        }
        /// <p>A section based layout organizes visuals into multiple sections and has customized header, footer and page break.</p>
        pub fn set_section_based_layout(
            mut self,
            input: std::option::Option<crate::model::SectionBasedLayoutConfiguration>,
        ) -> Self {
            self.section_based_layout = input;
            self
        }
        /// Consumes the builder and constructs a [`LayoutConfiguration`](crate::model::LayoutConfiguration).
        pub fn build(self) -> crate::model::LayoutConfiguration {
            crate::model::LayoutConfiguration {
                grid_layout: self.grid_layout,
                free_form_layout: self.free_form_layout,
                section_based_layout: self.section_based_layout,
            }
        }
    }
}
impl LayoutConfiguration {
    /// Creates a new builder-style object to manufacture [`LayoutConfiguration`](crate::model::LayoutConfiguration).
    pub fn builder() -> crate::model::layout_configuration::Builder {
        crate::model::layout_configuration::Builder::default()
    }
}

/// <p>The configuration for a section-based layout.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SectionBasedLayoutConfiguration {
    /// <p>A list of header section configurations.</p>
    #[doc(hidden)]
    pub header_sections:
        std::option::Option<std::vec::Vec<crate::model::HeaderFooterSectionConfiguration>>,
    /// <p>A list of body section configurations.</p>
    #[doc(hidden)]
    pub body_sections: std::option::Option<std::vec::Vec<crate::model::BodySectionConfiguration>>,
    /// <p>A list of footer section configurations.</p>
    #[doc(hidden)]
    pub footer_sections:
        std::option::Option<std::vec::Vec<crate::model::HeaderFooterSectionConfiguration>>,
    /// <p>The options for the canvas of a section-based layout.</p>
    #[doc(hidden)]
    pub canvas_size_options: std::option::Option<crate::model::SectionBasedLayoutCanvasSizeOptions>,
}
impl SectionBasedLayoutConfiguration {
    /// <p>A list of header section configurations.</p>
    pub fn header_sections(
        &self,
    ) -> std::option::Option<&[crate::model::HeaderFooterSectionConfiguration]> {
        self.header_sections.as_deref()
    }
    /// <p>A list of body section configurations.</p>
    pub fn body_sections(&self) -> std::option::Option<&[crate::model::BodySectionConfiguration]> {
        self.body_sections.as_deref()
    }
    /// <p>A list of footer section configurations.</p>
    pub fn footer_sections(
        &self,
    ) -> std::option::Option<&[crate::model::HeaderFooterSectionConfiguration]> {
        self.footer_sections.as_deref()
    }
    /// <p>The options for the canvas of a section-based layout.</p>
    pub fn canvas_size_options(
        &self,
    ) -> std::option::Option<&crate::model::SectionBasedLayoutCanvasSizeOptions> {
        self.canvas_size_options.as_ref()
    }
}
/// See [`SectionBasedLayoutConfiguration`](crate::model::SectionBasedLayoutConfiguration).
pub mod section_based_layout_configuration {

    /// A builder for [`SectionBasedLayoutConfiguration`](crate::model::SectionBasedLayoutConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) header_sections:
            std::option::Option<std::vec::Vec<crate::model::HeaderFooterSectionConfiguration>>,
        pub(crate) body_sections:
            std::option::Option<std::vec::Vec<crate::model::BodySectionConfiguration>>,
        pub(crate) footer_sections:
            std::option::Option<std::vec::Vec<crate::model::HeaderFooterSectionConfiguration>>,
        pub(crate) canvas_size_options:
            std::option::Option<crate::model::SectionBasedLayoutCanvasSizeOptions>,
    }
    impl Builder {
        /// Appends an item to `header_sections`.
        ///
        /// To override the contents of this collection use [`set_header_sections`](Self::set_header_sections).
        ///
        /// <p>A list of header section configurations.</p>
        pub fn header_sections(
            mut self,
            input: crate::model::HeaderFooterSectionConfiguration,
        ) -> Self {
            let mut v = self.header_sections.unwrap_or_default();
            v.push(input);
            self.header_sections = Some(v);
            self
        }
        /// <p>A list of header section configurations.</p>
        pub fn set_header_sections(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::HeaderFooterSectionConfiguration>,
            >,
        ) -> Self {
            self.header_sections = input;
            self
        }
        /// Appends an item to `body_sections`.
        ///
        /// To override the contents of this collection use [`set_body_sections`](Self::set_body_sections).
        ///
        /// <p>A list of body section configurations.</p>
        pub fn body_sections(mut self, input: crate::model::BodySectionConfiguration) -> Self {
            let mut v = self.body_sections.unwrap_or_default();
            v.push(input);
            self.body_sections = Some(v);
            self
        }
        /// <p>A list of body section configurations.</p>
        pub fn set_body_sections(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BodySectionConfiguration>>,
        ) -> Self {
            self.body_sections = input;
            self
        }
        /// Appends an item to `footer_sections`.
        ///
        /// To override the contents of this collection use [`set_footer_sections`](Self::set_footer_sections).
        ///
        /// <p>A list of footer section configurations.</p>
        pub fn footer_sections(
            mut self,
            input: crate::model::HeaderFooterSectionConfiguration,
        ) -> Self {
            let mut v = self.footer_sections.unwrap_or_default();
            v.push(input);
            self.footer_sections = Some(v);
            self
        }
        /// <p>A list of footer section configurations.</p>
        pub fn set_footer_sections(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::HeaderFooterSectionConfiguration>,
            >,
        ) -> Self {
            self.footer_sections = input;
            self
        }
        /// <p>The options for the canvas of a section-based layout.</p>
        pub fn canvas_size_options(
            mut self,
            input: crate::model::SectionBasedLayoutCanvasSizeOptions,
        ) -> Self {
            self.canvas_size_options = Some(input);
            self
        }
        /// <p>The options for the canvas of a section-based layout.</p>
        pub fn set_canvas_size_options(
            mut self,
            input: std::option::Option<crate::model::SectionBasedLayoutCanvasSizeOptions>,
        ) -> Self {
            self.canvas_size_options = input;
            self
        }
        /// Consumes the builder and constructs a [`SectionBasedLayoutConfiguration`](crate::model::SectionBasedLayoutConfiguration).
        pub fn build(self) -> crate::model::SectionBasedLayoutConfiguration {
            crate::model::SectionBasedLayoutConfiguration {
                header_sections: self.header_sections,
                body_sections: self.body_sections,
                footer_sections: self.footer_sections,
                canvas_size_options: self.canvas_size_options,
            }
        }
    }
}
impl SectionBasedLayoutConfiguration {
    /// Creates a new builder-style object to manufacture [`SectionBasedLayoutConfiguration`](crate::model::SectionBasedLayoutConfiguration).
    pub fn builder() -> crate::model::section_based_layout_configuration::Builder {
        crate::model::section_based_layout_configuration::Builder::default()
    }
}

/// <p>The configuration of a header or footer section.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HeaderFooterSectionConfiguration {
    /// <p>The unique identifier of the header or footer section.</p>
    #[doc(hidden)]
    pub section_id: std::option::Option<std::string::String>,
    /// <p>The layout configuration of the header or footer section.</p>
    #[doc(hidden)]
    pub layout: std::option::Option<crate::model::SectionLayoutConfiguration>,
    /// <p>The style options of a header or footer section.</p>
    #[doc(hidden)]
    pub style: std::option::Option<crate::model::SectionStyle>,
}
impl HeaderFooterSectionConfiguration {
    /// <p>The unique identifier of the header or footer section.</p>
    pub fn section_id(&self) -> std::option::Option<&str> {
        self.section_id.as_deref()
    }
    /// <p>The layout configuration of the header or footer section.</p>
    pub fn layout(&self) -> std::option::Option<&crate::model::SectionLayoutConfiguration> {
        self.layout.as_ref()
    }
    /// <p>The style options of a header or footer section.</p>
    pub fn style(&self) -> std::option::Option<&crate::model::SectionStyle> {
        self.style.as_ref()
    }
}
/// See [`HeaderFooterSectionConfiguration`](crate::model::HeaderFooterSectionConfiguration).
pub mod header_footer_section_configuration {

    /// A builder for [`HeaderFooterSectionConfiguration`](crate::model::HeaderFooterSectionConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) section_id: std::option::Option<std::string::String>,
        pub(crate) layout: std::option::Option<crate::model::SectionLayoutConfiguration>,
        pub(crate) style: std::option::Option<crate::model::SectionStyle>,
    }
    impl Builder {
        /// <p>The unique identifier of the header or footer section.</p>
        pub fn section_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.section_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the header or footer section.</p>
        pub fn set_section_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.section_id = input;
            self
        }
        /// <p>The layout configuration of the header or footer section.</p>
        pub fn layout(mut self, input: crate::model::SectionLayoutConfiguration) -> Self {
            self.layout = Some(input);
            self
        }
        /// <p>The layout configuration of the header or footer section.</p>
        pub fn set_layout(
            mut self,
            input: std::option::Option<crate::model::SectionLayoutConfiguration>,
        ) -> Self {
            self.layout = input;
            self
        }
        /// <p>The style options of a header or footer section.</p>
        pub fn style(mut self, input: crate::model::SectionStyle) -> Self {
            self.style = Some(input);
            self
        }
        /// <p>The style options of a header or footer section.</p>
        pub fn set_style(mut self, input: std::option::Option<crate::model::SectionStyle>) -> Self {
            self.style = input;
            self
        }
        /// Consumes the builder and constructs a [`HeaderFooterSectionConfiguration`](crate::model::HeaderFooterSectionConfiguration).
        pub fn build(self) -> crate::model::HeaderFooterSectionConfiguration {
            crate::model::HeaderFooterSectionConfiguration {
                section_id: self.section_id,
                layout: self.layout,
                style: self.style,
            }
        }
    }
}
impl HeaderFooterSectionConfiguration {
    /// Creates a new builder-style object to manufacture [`HeaderFooterSectionConfiguration`](crate::model::HeaderFooterSectionConfiguration).
    pub fn builder() -> crate::model::header_footer_section_configuration::Builder {
        crate::model::header_footer_section_configuration::Builder::default()
    }
}

/// <p>The options that style a section.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SectionStyle {
    /// <p>The height of a section.</p>
    /// <p>Heights can only be defined for header and footer sections. The default height margin is 0.5 inches. </p>
    #[doc(hidden)]
    pub height: std::option::Option<std::string::String>,
    /// <p>The spacing between section content and its top, bottom, left, and right edges.</p>
    /// <p>There is no padding by default.</p>
    #[doc(hidden)]
    pub padding: std::option::Option<crate::model::Spacing>,
}
impl SectionStyle {
    /// <p>The height of a section.</p>
    /// <p>Heights can only be defined for header and footer sections. The default height margin is 0.5 inches. </p>
    pub fn height(&self) -> std::option::Option<&str> {
        self.height.as_deref()
    }
    /// <p>The spacing between section content and its top, bottom, left, and right edges.</p>
    /// <p>There is no padding by default.</p>
    pub fn padding(&self) -> std::option::Option<&crate::model::Spacing> {
        self.padding.as_ref()
    }
}
/// See [`SectionStyle`](crate::model::SectionStyle).
pub mod section_style {

    /// A builder for [`SectionStyle`](crate::model::SectionStyle).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) height: std::option::Option<std::string::String>,
        pub(crate) padding: std::option::Option<crate::model::Spacing>,
    }
    impl Builder {
        /// <p>The height of a section.</p>
        /// <p>Heights can only be defined for header and footer sections. The default height margin is 0.5 inches. </p>
        pub fn height(mut self, input: impl Into<std::string::String>) -> Self {
            self.height = Some(input.into());
            self
        }
        /// <p>The height of a section.</p>
        /// <p>Heights can only be defined for header and footer sections. The default height margin is 0.5 inches. </p>
        pub fn set_height(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.height = input;
            self
        }
        /// <p>The spacing between section content and its top, bottom, left, and right edges.</p>
        /// <p>There is no padding by default.</p>
        pub fn padding(mut self, input: crate::model::Spacing) -> Self {
            self.padding = Some(input);
            self
        }
        /// <p>The spacing between section content and its top, bottom, left, and right edges.</p>
        /// <p>There is no padding by default.</p>
        pub fn set_padding(mut self, input: std::option::Option<crate::model::Spacing>) -> Self {
            self.padding = input;
            self
        }
        /// Consumes the builder and constructs a [`SectionStyle`](crate::model::SectionStyle).
        pub fn build(self) -> crate::model::SectionStyle {
            crate::model::SectionStyle {
                height: self.height,
                padding: self.padding,
            }
        }
    }
}
impl SectionStyle {
    /// Creates a new builder-style object to manufacture [`SectionStyle`](crate::model::SectionStyle).
    pub fn builder() -> crate::model::section_style::Builder {
        crate::model::section_style::Builder::default()
    }
}

/// <p>The layout configuration of a section.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SectionLayoutConfiguration {
    /// <p>The free-form layout configuration of a section.</p>
    #[doc(hidden)]
    pub free_form_layout: std::option::Option<crate::model::FreeFormSectionLayoutConfiguration>,
}
impl SectionLayoutConfiguration {
    /// <p>The free-form layout configuration of a section.</p>
    pub fn free_form_layout(
        &self,
    ) -> std::option::Option<&crate::model::FreeFormSectionLayoutConfiguration> {
        self.free_form_layout.as_ref()
    }
}
/// See [`SectionLayoutConfiguration`](crate::model::SectionLayoutConfiguration).
pub mod section_layout_configuration {

    /// A builder for [`SectionLayoutConfiguration`](crate::model::SectionLayoutConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) free_form_layout:
            std::option::Option<crate::model::FreeFormSectionLayoutConfiguration>,
    }
    impl Builder {
        /// <p>The free-form layout configuration of a section.</p>
        pub fn free_form_layout(
            mut self,
            input: crate::model::FreeFormSectionLayoutConfiguration,
        ) -> Self {
            self.free_form_layout = Some(input);
            self
        }
        /// <p>The free-form layout configuration of a section.</p>
        pub fn set_free_form_layout(
            mut self,
            input: std::option::Option<crate::model::FreeFormSectionLayoutConfiguration>,
        ) -> Self {
            self.free_form_layout = input;
            self
        }
        /// Consumes the builder and constructs a [`SectionLayoutConfiguration`](crate::model::SectionLayoutConfiguration).
        pub fn build(self) -> crate::model::SectionLayoutConfiguration {
            crate::model::SectionLayoutConfiguration {
                free_form_layout: self.free_form_layout,
            }
        }
    }
}
impl SectionLayoutConfiguration {
    /// Creates a new builder-style object to manufacture [`SectionLayoutConfiguration`](crate::model::SectionLayoutConfiguration).
    pub fn builder() -> crate::model::section_layout_configuration::Builder {
        crate::model::section_layout_configuration::Builder::default()
    }
}

/// <p>The free-form layout configuration of a section.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FreeFormSectionLayoutConfiguration {
    /// <p>The elements that are included in the free-form layout.</p>
    #[doc(hidden)]
    pub elements: std::option::Option<std::vec::Vec<crate::model::FreeFormLayoutElement>>,
}
impl FreeFormSectionLayoutConfiguration {
    /// <p>The elements that are included in the free-form layout.</p>
    pub fn elements(&self) -> std::option::Option<&[crate::model::FreeFormLayoutElement]> {
        self.elements.as_deref()
    }
}
/// See [`FreeFormSectionLayoutConfiguration`](crate::model::FreeFormSectionLayoutConfiguration).
pub mod free_form_section_layout_configuration {

    /// A builder for [`FreeFormSectionLayoutConfiguration`](crate::model::FreeFormSectionLayoutConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) elements:
            std::option::Option<std::vec::Vec<crate::model::FreeFormLayoutElement>>,
    }
    impl Builder {
        /// Appends an item to `elements`.
        ///
        /// To override the contents of this collection use [`set_elements`](Self::set_elements).
        ///
        /// <p>The elements that are included in the free-form layout.</p>
        pub fn elements(mut self, input: crate::model::FreeFormLayoutElement) -> Self {
            let mut v = self.elements.unwrap_or_default();
            v.push(input);
            self.elements = Some(v);
            self
        }
        /// <p>The elements that are included in the free-form layout.</p>
        pub fn set_elements(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FreeFormLayoutElement>>,
        ) -> Self {
            self.elements = input;
            self
        }
        /// Consumes the builder and constructs a [`FreeFormSectionLayoutConfiguration`](crate::model::FreeFormSectionLayoutConfiguration).
        pub fn build(self) -> crate::model::FreeFormSectionLayoutConfiguration {
            crate::model::FreeFormSectionLayoutConfiguration {
                elements: self.elements,
            }
        }
    }
}
impl FreeFormSectionLayoutConfiguration {
    /// Creates a new builder-style object to manufacture [`FreeFormSectionLayoutConfiguration`](crate::model::FreeFormSectionLayoutConfiguration).
    pub fn builder() -> crate::model::free_form_section_layout_configuration::Builder {
        crate::model::free_form_section_layout_configuration::Builder::default()
    }
}

/// <p>An element within a free-form layout.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FreeFormLayoutElement {
    /// <p>A unique identifier for an element within a free-form layout.</p>
    #[doc(hidden)]
    pub element_id: std::option::Option<std::string::String>,
    /// <p>The type of element.</p>
    #[doc(hidden)]
    pub element_type: std::option::Option<crate::model::LayoutElementType>,
    /// <p>The x-axis coordinate of the element.</p>
    #[doc(hidden)]
    pub x_axis_location: std::option::Option<std::string::String>,
    /// <p>The y-axis coordinate of the element.</p>
    #[doc(hidden)]
    pub y_axis_location: std::option::Option<std::string::String>,
    /// <p>The width of an element within a free-form layout.</p>
    #[doc(hidden)]
    pub width: std::option::Option<std::string::String>,
    /// <p>The height of an element within a free-form layout.</p>
    #[doc(hidden)]
    pub height: std::option::Option<std::string::String>,
    /// <p>The visibility of an element within a free-form layout.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The rendering rules that determine when an element should be displayed within a free-form layout.</p>
    #[doc(hidden)]
    pub rendering_rules:
        std::option::Option<std::vec::Vec<crate::model::SheetElementRenderingRule>>,
    /// <p>The border style configuration of a free-form layout element.</p>
    #[doc(hidden)]
    pub border_style: std::option::Option<crate::model::FreeFormLayoutElementBorderStyle>,
    /// <p>The border style configuration of a free-form layout element. This border style is used when the element is selected.</p>
    #[doc(hidden)]
    pub selected_border_style: std::option::Option<crate::model::FreeFormLayoutElementBorderStyle>,
    /// <p>The background style configuration of a free-form layout element.</p>
    #[doc(hidden)]
    pub background_style: std::option::Option<crate::model::FreeFormLayoutElementBackgroundStyle>,
    /// <p>The loading animation configuration of a free-form layout element.</p>
    #[doc(hidden)]
    pub loading_animation: std::option::Option<crate::model::LoadingAnimation>,
}
impl FreeFormLayoutElement {
    /// <p>A unique identifier for an element within a free-form layout.</p>
    pub fn element_id(&self) -> std::option::Option<&str> {
        self.element_id.as_deref()
    }
    /// <p>The type of element.</p>
    pub fn element_type(&self) -> std::option::Option<&crate::model::LayoutElementType> {
        self.element_type.as_ref()
    }
    /// <p>The x-axis coordinate of the element.</p>
    pub fn x_axis_location(&self) -> std::option::Option<&str> {
        self.x_axis_location.as_deref()
    }
    /// <p>The y-axis coordinate of the element.</p>
    pub fn y_axis_location(&self) -> std::option::Option<&str> {
        self.y_axis_location.as_deref()
    }
    /// <p>The width of an element within a free-form layout.</p>
    pub fn width(&self) -> std::option::Option<&str> {
        self.width.as_deref()
    }
    /// <p>The height of an element within a free-form layout.</p>
    pub fn height(&self) -> std::option::Option<&str> {
        self.height.as_deref()
    }
    /// <p>The visibility of an element within a free-form layout.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
    /// <p>The rendering rules that determine when an element should be displayed within a free-form layout.</p>
    pub fn rendering_rules(
        &self,
    ) -> std::option::Option<&[crate::model::SheetElementRenderingRule]> {
        self.rendering_rules.as_deref()
    }
    /// <p>The border style configuration of a free-form layout element.</p>
    pub fn border_style(
        &self,
    ) -> std::option::Option<&crate::model::FreeFormLayoutElementBorderStyle> {
        self.border_style.as_ref()
    }
    /// <p>The border style configuration of a free-form layout element. This border style is used when the element is selected.</p>
    pub fn selected_border_style(
        &self,
    ) -> std::option::Option<&crate::model::FreeFormLayoutElementBorderStyle> {
        self.selected_border_style.as_ref()
    }
    /// <p>The background style configuration of a free-form layout element.</p>
    pub fn background_style(
        &self,
    ) -> std::option::Option<&crate::model::FreeFormLayoutElementBackgroundStyle> {
        self.background_style.as_ref()
    }
    /// <p>The loading animation configuration of a free-form layout element.</p>
    pub fn loading_animation(&self) -> std::option::Option<&crate::model::LoadingAnimation> {
        self.loading_animation.as_ref()
    }
}
/// See [`FreeFormLayoutElement`](crate::model::FreeFormLayoutElement).
pub mod free_form_layout_element {

    /// A builder for [`FreeFormLayoutElement`](crate::model::FreeFormLayoutElement).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) element_id: std::option::Option<std::string::String>,
        pub(crate) element_type: std::option::Option<crate::model::LayoutElementType>,
        pub(crate) x_axis_location: std::option::Option<std::string::String>,
        pub(crate) y_axis_location: std::option::Option<std::string::String>,
        pub(crate) width: std::option::Option<std::string::String>,
        pub(crate) height: std::option::Option<std::string::String>,
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) rendering_rules:
            std::option::Option<std::vec::Vec<crate::model::SheetElementRenderingRule>>,
        pub(crate) border_style:
            std::option::Option<crate::model::FreeFormLayoutElementBorderStyle>,
        pub(crate) selected_border_style:
            std::option::Option<crate::model::FreeFormLayoutElementBorderStyle>,
        pub(crate) background_style:
            std::option::Option<crate::model::FreeFormLayoutElementBackgroundStyle>,
        pub(crate) loading_animation: std::option::Option<crate::model::LoadingAnimation>,
    }
    impl Builder {
        /// <p>A unique identifier for an element within a free-form layout.</p>
        pub fn element_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.element_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for an element within a free-form layout.</p>
        pub fn set_element_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.element_id = input;
            self
        }
        /// <p>The type of element.</p>
        pub fn element_type(mut self, input: crate::model::LayoutElementType) -> Self {
            self.element_type = Some(input);
            self
        }
        /// <p>The type of element.</p>
        pub fn set_element_type(
            mut self,
            input: std::option::Option<crate::model::LayoutElementType>,
        ) -> Self {
            self.element_type = input;
            self
        }
        /// <p>The x-axis coordinate of the element.</p>
        pub fn x_axis_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.x_axis_location = Some(input.into());
            self
        }
        /// <p>The x-axis coordinate of the element.</p>
        pub fn set_x_axis_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.x_axis_location = input;
            self
        }
        /// <p>The y-axis coordinate of the element.</p>
        pub fn y_axis_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.y_axis_location = Some(input.into());
            self
        }
        /// <p>The y-axis coordinate of the element.</p>
        pub fn set_y_axis_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.y_axis_location = input;
            self
        }
        /// <p>The width of an element within a free-form layout.</p>
        pub fn width(mut self, input: impl Into<std::string::String>) -> Self {
            self.width = Some(input.into());
            self
        }
        /// <p>The width of an element within a free-form layout.</p>
        pub fn set_width(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.width = input;
            self
        }
        /// <p>The height of an element within a free-form layout.</p>
        pub fn height(mut self, input: impl Into<std::string::String>) -> Self {
            self.height = Some(input.into());
            self
        }
        /// <p>The height of an element within a free-form layout.</p>
        pub fn set_height(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.height = input;
            self
        }
        /// <p>The visibility of an element within a free-form layout.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility of an element within a free-form layout.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// Appends an item to `rendering_rules`.
        ///
        /// To override the contents of this collection use [`set_rendering_rules`](Self::set_rendering_rules).
        ///
        /// <p>The rendering rules that determine when an element should be displayed within a free-form layout.</p>
        pub fn rendering_rules(mut self, input: crate::model::SheetElementRenderingRule) -> Self {
            let mut v = self.rendering_rules.unwrap_or_default();
            v.push(input);
            self.rendering_rules = Some(v);
            self
        }
        /// <p>The rendering rules that determine when an element should be displayed within a free-form layout.</p>
        pub fn set_rendering_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SheetElementRenderingRule>>,
        ) -> Self {
            self.rendering_rules = input;
            self
        }
        /// <p>The border style configuration of a free-form layout element.</p>
        pub fn border_style(
            mut self,
            input: crate::model::FreeFormLayoutElementBorderStyle,
        ) -> Self {
            self.border_style = Some(input);
            self
        }
        /// <p>The border style configuration of a free-form layout element.</p>
        pub fn set_border_style(
            mut self,
            input: std::option::Option<crate::model::FreeFormLayoutElementBorderStyle>,
        ) -> Self {
            self.border_style = input;
            self
        }
        /// <p>The border style configuration of a free-form layout element. This border style is used when the element is selected.</p>
        pub fn selected_border_style(
            mut self,
            input: crate::model::FreeFormLayoutElementBorderStyle,
        ) -> Self {
            self.selected_border_style = Some(input);
            self
        }
        /// <p>The border style configuration of a free-form layout element. This border style is used when the element is selected.</p>
        pub fn set_selected_border_style(
            mut self,
            input: std::option::Option<crate::model::FreeFormLayoutElementBorderStyle>,
        ) -> Self {
            self.selected_border_style = input;
            self
        }
        /// <p>The background style configuration of a free-form layout element.</p>
        pub fn background_style(
            mut self,
            input: crate::model::FreeFormLayoutElementBackgroundStyle,
        ) -> Self {
            self.background_style = Some(input);
            self
        }
        /// <p>The background style configuration of a free-form layout element.</p>
        pub fn set_background_style(
            mut self,
            input: std::option::Option<crate::model::FreeFormLayoutElementBackgroundStyle>,
        ) -> Self {
            self.background_style = input;
            self
        }
        /// <p>The loading animation configuration of a free-form layout element.</p>
        pub fn loading_animation(mut self, input: crate::model::LoadingAnimation) -> Self {
            self.loading_animation = Some(input);
            self
        }
        /// <p>The loading animation configuration of a free-form layout element.</p>
        pub fn set_loading_animation(
            mut self,
            input: std::option::Option<crate::model::LoadingAnimation>,
        ) -> Self {
            self.loading_animation = input;
            self
        }
        /// Consumes the builder and constructs a [`FreeFormLayoutElement`](crate::model::FreeFormLayoutElement).
        pub fn build(self) -> crate::model::FreeFormLayoutElement {
            crate::model::FreeFormLayoutElement {
                element_id: self.element_id,
                element_type: self.element_type,
                x_axis_location: self.x_axis_location,
                y_axis_location: self.y_axis_location,
                width: self.width,
                height: self.height,
                visibility: self.visibility,
                rendering_rules: self.rendering_rules,
                border_style: self.border_style,
                selected_border_style: self.selected_border_style,
                background_style: self.background_style,
                loading_animation: self.loading_animation,
            }
        }
    }
}
impl FreeFormLayoutElement {
    /// Creates a new builder-style object to manufacture [`FreeFormLayoutElement`](crate::model::FreeFormLayoutElement).
    pub fn builder() -> crate::model::free_form_layout_element::Builder {
        crate::model::free_form_layout_element::Builder::default()
    }
}

/// <p>The configuration of loading animation in free-form layout. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoadingAnimation {
    /// <p>The visibility configuration of <code>LoadingAnimation</code>.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
}
impl LoadingAnimation {
    /// <p>The visibility configuration of <code>LoadingAnimation</code>.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
}
/// See [`LoadingAnimation`](crate::model::LoadingAnimation).
pub mod loading_animation {

    /// A builder for [`LoadingAnimation`](crate::model::LoadingAnimation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>The visibility configuration of <code>LoadingAnimation</code>.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility configuration of <code>LoadingAnimation</code>.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`LoadingAnimation`](crate::model::LoadingAnimation).
        pub fn build(self) -> crate::model::LoadingAnimation {
            crate::model::LoadingAnimation {
                visibility: self.visibility,
            }
        }
    }
}
impl LoadingAnimation {
    /// Creates a new builder-style object to manufacture [`LoadingAnimation`](crate::model::LoadingAnimation).
    pub fn builder() -> crate::model::loading_animation::Builder {
        crate::model::loading_animation::Builder::default()
    }
}

/// <p>The background style configuration of a free-form layout element.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FreeFormLayoutElementBackgroundStyle {
    /// <p>The background visibility of a free-form layout element.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The background color of a free-form layout element.</p>
    #[doc(hidden)]
    pub color: std::option::Option<std::string::String>,
}
impl FreeFormLayoutElementBackgroundStyle {
    /// <p>The background visibility of a free-form layout element.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
    /// <p>The background color of a free-form layout element.</p>
    pub fn color(&self) -> std::option::Option<&str> {
        self.color.as_deref()
    }
}
/// See [`FreeFormLayoutElementBackgroundStyle`](crate::model::FreeFormLayoutElementBackgroundStyle).
pub mod free_form_layout_element_background_style {

    /// A builder for [`FreeFormLayoutElementBackgroundStyle`](crate::model::FreeFormLayoutElementBackgroundStyle).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) color: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The background visibility of a free-form layout element.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The background visibility of a free-form layout element.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// <p>The background color of a free-form layout element.</p>
        pub fn color(mut self, input: impl Into<std::string::String>) -> Self {
            self.color = Some(input.into());
            self
        }
        /// <p>The background color of a free-form layout element.</p>
        pub fn set_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.color = input;
            self
        }
        /// Consumes the builder and constructs a [`FreeFormLayoutElementBackgroundStyle`](crate::model::FreeFormLayoutElementBackgroundStyle).
        pub fn build(self) -> crate::model::FreeFormLayoutElementBackgroundStyle {
            crate::model::FreeFormLayoutElementBackgroundStyle {
                visibility: self.visibility,
                color: self.color,
            }
        }
    }
}
impl FreeFormLayoutElementBackgroundStyle {
    /// Creates a new builder-style object to manufacture [`FreeFormLayoutElementBackgroundStyle`](crate::model::FreeFormLayoutElementBackgroundStyle).
    pub fn builder() -> crate::model::free_form_layout_element_background_style::Builder {
        crate::model::free_form_layout_element_background_style::Builder::default()
    }
}

/// <p>The background style configuration of a free-form layout element.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FreeFormLayoutElementBorderStyle {
    /// <p>The border visibility of a free-form layout element.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The border color of a free-form layout element.</p>
    #[doc(hidden)]
    pub color: std::option::Option<std::string::String>,
}
impl FreeFormLayoutElementBorderStyle {
    /// <p>The border visibility of a free-form layout element.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
    /// <p>The border color of a free-form layout element.</p>
    pub fn color(&self) -> std::option::Option<&str> {
        self.color.as_deref()
    }
}
/// See [`FreeFormLayoutElementBorderStyle`](crate::model::FreeFormLayoutElementBorderStyle).
pub mod free_form_layout_element_border_style {

    /// A builder for [`FreeFormLayoutElementBorderStyle`](crate::model::FreeFormLayoutElementBorderStyle).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) color: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The border visibility of a free-form layout element.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The border visibility of a free-form layout element.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// <p>The border color of a free-form layout element.</p>
        pub fn color(mut self, input: impl Into<std::string::String>) -> Self {
            self.color = Some(input.into());
            self
        }
        /// <p>The border color of a free-form layout element.</p>
        pub fn set_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.color = input;
            self
        }
        /// Consumes the builder and constructs a [`FreeFormLayoutElementBorderStyle`](crate::model::FreeFormLayoutElementBorderStyle).
        pub fn build(self) -> crate::model::FreeFormLayoutElementBorderStyle {
            crate::model::FreeFormLayoutElementBorderStyle {
                visibility: self.visibility,
                color: self.color,
            }
        }
    }
}
impl FreeFormLayoutElementBorderStyle {
    /// Creates a new builder-style object to manufacture [`FreeFormLayoutElementBorderStyle`](crate::model::FreeFormLayoutElementBorderStyle).
    pub fn builder() -> crate::model::free_form_layout_element_border_style::Builder {
        crate::model::free_form_layout_element_border_style::Builder::default()
    }
}

/// <p>The rendering rules of a sheet that uses a free-form layout.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SheetElementRenderingRule {
    /// <p>The expression of the rendering rules of a sheet.</p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::string::String>,
    /// <p>The override configuration of the rendering rules of a sheet.</p>
    #[doc(hidden)]
    pub configuration_overrides:
        std::option::Option<crate::model::SheetElementConfigurationOverrides>,
}
impl SheetElementRenderingRule {
    /// <p>The expression of the rendering rules of a sheet.</p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
    /// <p>The override configuration of the rendering rules of a sheet.</p>
    pub fn configuration_overrides(
        &self,
    ) -> std::option::Option<&crate::model::SheetElementConfigurationOverrides> {
        self.configuration_overrides.as_ref()
    }
}
impl std::fmt::Debug for SheetElementRenderingRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SheetElementRenderingRule");
        formatter.field("expression", &"*** Sensitive Data Redacted ***");
        formatter.field("configuration_overrides", &self.configuration_overrides);
        formatter.finish()
    }
}
/// See [`SheetElementRenderingRule`](crate::model::SheetElementRenderingRule).
pub mod sheet_element_rendering_rule {

    /// A builder for [`SheetElementRenderingRule`](crate::model::SheetElementRenderingRule).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) expression: std::option::Option<std::string::String>,
        pub(crate) configuration_overrides:
            std::option::Option<crate::model::SheetElementConfigurationOverrides>,
    }
    impl Builder {
        /// <p>The expression of the rendering rules of a sheet.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>The expression of the rendering rules of a sheet.</p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// <p>The override configuration of the rendering rules of a sheet.</p>
        pub fn configuration_overrides(
            mut self,
            input: crate::model::SheetElementConfigurationOverrides,
        ) -> Self {
            self.configuration_overrides = Some(input);
            self
        }
        /// <p>The override configuration of the rendering rules of a sheet.</p>
        pub fn set_configuration_overrides(
            mut self,
            input: std::option::Option<crate::model::SheetElementConfigurationOverrides>,
        ) -> Self {
            self.configuration_overrides = input;
            self
        }
        /// Consumes the builder and constructs a [`SheetElementRenderingRule`](crate::model::SheetElementRenderingRule).
        pub fn build(self) -> crate::model::SheetElementRenderingRule {
            crate::model::SheetElementRenderingRule {
                expression: self.expression,
                configuration_overrides: self.configuration_overrides,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("expression", &"*** Sensitive Data Redacted ***");
            formatter.field("configuration_overrides", &self.configuration_overrides);
            formatter.finish()
        }
    }
}
impl SheetElementRenderingRule {
    /// Creates a new builder-style object to manufacture [`SheetElementRenderingRule`](crate::model::SheetElementRenderingRule).
    pub fn builder() -> crate::model::sheet_element_rendering_rule::Builder {
        crate::model::sheet_element_rendering_rule::Builder::default()
    }
}

/// <p>The override configuration of the rendering rules of a sheet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SheetElementConfigurationOverrides {
    /// <p>Determines whether or not the overrides are visible. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>VISIBLE</code> </p> </li>
    /// <li> <p> <code>HIDDEN</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
}
impl SheetElementConfigurationOverrides {
    /// <p>Determines whether or not the overrides are visible. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>VISIBLE</code> </p> </li>
    /// <li> <p> <code>HIDDEN</code> </p> </li>
    /// </ul>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
}
/// See [`SheetElementConfigurationOverrides`](crate::model::SheetElementConfigurationOverrides).
pub mod sheet_element_configuration_overrides {

    /// A builder for [`SheetElementConfigurationOverrides`](crate::model::SheetElementConfigurationOverrides).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>Determines whether or not the overrides are visible. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>VISIBLE</code> </p> </li>
        /// <li> <p> <code>HIDDEN</code> </p> </li>
        /// </ul>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>Determines whether or not the overrides are visible. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>VISIBLE</code> </p> </li>
        /// <li> <p> <code>HIDDEN</code> </p> </li>
        /// </ul>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`SheetElementConfigurationOverrides`](crate::model::SheetElementConfigurationOverrides).
        pub fn build(self) -> crate::model::SheetElementConfigurationOverrides {
            crate::model::SheetElementConfigurationOverrides {
                visibility: self.visibility,
            }
        }
    }
}
impl SheetElementConfigurationOverrides {
    /// Creates a new builder-style object to manufacture [`SheetElementConfigurationOverrides`](crate::model::SheetElementConfigurationOverrides).
    pub fn builder() -> crate::model::sheet_element_configuration_overrides::Builder {
        crate::model::sheet_element_configuration_overrides::Builder::default()
    }
}

/// <p>The configuration of a body section.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BodySectionConfiguration {
    /// <p>The unique identifier of a body section.</p>
    #[doc(hidden)]
    pub section_id: std::option::Option<std::string::String>,
    /// <p>The configuration of content in a body section.</p>
    #[doc(hidden)]
    pub content: std::option::Option<crate::model::BodySectionContent>,
    /// <p>The style options of a body section.</p>
    #[doc(hidden)]
    pub style: std::option::Option<crate::model::SectionStyle>,
    /// <p>The configuration of a page break for a section.</p>
    #[doc(hidden)]
    pub page_break_configuration: std::option::Option<crate::model::SectionPageBreakConfiguration>,
}
impl BodySectionConfiguration {
    /// <p>The unique identifier of a body section.</p>
    pub fn section_id(&self) -> std::option::Option<&str> {
        self.section_id.as_deref()
    }
    /// <p>The configuration of content in a body section.</p>
    pub fn content(&self) -> std::option::Option<&crate::model::BodySectionContent> {
        self.content.as_ref()
    }
    /// <p>The style options of a body section.</p>
    pub fn style(&self) -> std::option::Option<&crate::model::SectionStyle> {
        self.style.as_ref()
    }
    /// <p>The configuration of a page break for a section.</p>
    pub fn page_break_configuration(
        &self,
    ) -> std::option::Option<&crate::model::SectionPageBreakConfiguration> {
        self.page_break_configuration.as_ref()
    }
}
/// See [`BodySectionConfiguration`](crate::model::BodySectionConfiguration).
pub mod body_section_configuration {

    /// A builder for [`BodySectionConfiguration`](crate::model::BodySectionConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) section_id: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<crate::model::BodySectionContent>,
        pub(crate) style: std::option::Option<crate::model::SectionStyle>,
        pub(crate) page_break_configuration:
            std::option::Option<crate::model::SectionPageBreakConfiguration>,
    }
    impl Builder {
        /// <p>The unique identifier of a body section.</p>
        pub fn section_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.section_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a body section.</p>
        pub fn set_section_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.section_id = input;
            self
        }
        /// <p>The configuration of content in a body section.</p>
        pub fn content(mut self, input: crate::model::BodySectionContent) -> Self {
            self.content = Some(input);
            self
        }
        /// <p>The configuration of content in a body section.</p>
        pub fn set_content(
            mut self,
            input: std::option::Option<crate::model::BodySectionContent>,
        ) -> Self {
            self.content = input;
            self
        }
        /// <p>The style options of a body section.</p>
        pub fn style(mut self, input: crate::model::SectionStyle) -> Self {
            self.style = Some(input);
            self
        }
        /// <p>The style options of a body section.</p>
        pub fn set_style(mut self, input: std::option::Option<crate::model::SectionStyle>) -> Self {
            self.style = input;
            self
        }
        /// <p>The configuration of a page break for a section.</p>
        pub fn page_break_configuration(
            mut self,
            input: crate::model::SectionPageBreakConfiguration,
        ) -> Self {
            self.page_break_configuration = Some(input);
            self
        }
        /// <p>The configuration of a page break for a section.</p>
        pub fn set_page_break_configuration(
            mut self,
            input: std::option::Option<crate::model::SectionPageBreakConfiguration>,
        ) -> Self {
            self.page_break_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`BodySectionConfiguration`](crate::model::BodySectionConfiguration).
        pub fn build(self) -> crate::model::BodySectionConfiguration {
            crate::model::BodySectionConfiguration {
                section_id: self.section_id,
                content: self.content,
                style: self.style,
                page_break_configuration: self.page_break_configuration,
            }
        }
    }
}
impl BodySectionConfiguration {
    /// Creates a new builder-style object to manufacture [`BodySectionConfiguration`](crate::model::BodySectionConfiguration).
    pub fn builder() -> crate::model::body_section_configuration::Builder {
        crate::model::body_section_configuration::Builder::default()
    }
}

/// <p>The configuration of a page break for a section.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SectionPageBreakConfiguration {
    /// <p>The configuration of a page break after a section.</p>
    #[doc(hidden)]
    pub after: std::option::Option<crate::model::SectionAfterPageBreak>,
}
impl SectionPageBreakConfiguration {
    /// <p>The configuration of a page break after a section.</p>
    pub fn after(&self) -> std::option::Option<&crate::model::SectionAfterPageBreak> {
        self.after.as_ref()
    }
}
/// See [`SectionPageBreakConfiguration`](crate::model::SectionPageBreakConfiguration).
pub mod section_page_break_configuration {

    /// A builder for [`SectionPageBreakConfiguration`](crate::model::SectionPageBreakConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) after: std::option::Option<crate::model::SectionAfterPageBreak>,
    }
    impl Builder {
        /// <p>The configuration of a page break after a section.</p>
        pub fn after(mut self, input: crate::model::SectionAfterPageBreak) -> Self {
            self.after = Some(input);
            self
        }
        /// <p>The configuration of a page break after a section.</p>
        pub fn set_after(
            mut self,
            input: std::option::Option<crate::model::SectionAfterPageBreak>,
        ) -> Self {
            self.after = input;
            self
        }
        /// Consumes the builder and constructs a [`SectionPageBreakConfiguration`](crate::model::SectionPageBreakConfiguration).
        pub fn build(self) -> crate::model::SectionPageBreakConfiguration {
            crate::model::SectionPageBreakConfiguration { after: self.after }
        }
    }
}
impl SectionPageBreakConfiguration {
    /// Creates a new builder-style object to manufacture [`SectionPageBreakConfiguration`](crate::model::SectionPageBreakConfiguration).
    pub fn builder() -> crate::model::section_page_break_configuration::Builder {
        crate::model::section_page_break_configuration::Builder::default()
    }
}

/// <p>The configuration of a page break after a section.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SectionAfterPageBreak {
    /// <p>The option that enables or disables a page break at the end of a section.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::SectionPageBreakStatus>,
}
impl SectionAfterPageBreak {
    /// <p>The option that enables or disables a page break at the end of a section.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::SectionPageBreakStatus> {
        self.status.as_ref()
    }
}
/// See [`SectionAfterPageBreak`](crate::model::SectionAfterPageBreak).
pub mod section_after_page_break {

    /// A builder for [`SectionAfterPageBreak`](crate::model::SectionAfterPageBreak).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::SectionPageBreakStatus>,
    }
    impl Builder {
        /// <p>The option that enables or disables a page break at the end of a section.</p>
        pub fn status(mut self, input: crate::model::SectionPageBreakStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The option that enables or disables a page break at the end of a section.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SectionPageBreakStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`SectionAfterPageBreak`](crate::model::SectionAfterPageBreak).
        pub fn build(self) -> crate::model::SectionAfterPageBreak {
            crate::model::SectionAfterPageBreak {
                status: self.status,
            }
        }
    }
}
impl SectionAfterPageBreak {
    /// Creates a new builder-style object to manufacture [`SectionAfterPageBreak`](crate::model::SectionAfterPageBreak).
    pub fn builder() -> crate::model::section_after_page_break::Builder {
        crate::model::section_after_page_break::Builder::default()
    }
}

/// When writing a match expression against `SectionPageBreakStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sectionpagebreakstatus = unimplemented!();
/// match sectionpagebreakstatus {
///     SectionPageBreakStatus::Disabled => { /* ... */ },
///     SectionPageBreakStatus::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sectionpagebreakstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SectionPageBreakStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SectionPageBreakStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SectionPageBreakStatus::NewFeature` is defined.
/// Specifically, when `sectionpagebreakstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SectionPageBreakStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SectionPageBreakStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SectionPageBreakStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => SectionPageBreakStatus::Disabled,
            "ENABLED" => SectionPageBreakStatus::Enabled,
            other => {
                SectionPageBreakStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SectionPageBreakStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SectionPageBreakStatus::from(s))
    }
}
impl SectionPageBreakStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SectionPageBreakStatus::Disabled => "DISABLED",
            SectionPageBreakStatus::Enabled => "ENABLED",
            SectionPageBreakStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for SectionPageBreakStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration of content in a body section.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BodySectionContent {
    /// <p>The layout configuration of a body section.</p>
    #[doc(hidden)]
    pub layout: std::option::Option<crate::model::SectionLayoutConfiguration>,
}
impl BodySectionContent {
    /// <p>The layout configuration of a body section.</p>
    pub fn layout(&self) -> std::option::Option<&crate::model::SectionLayoutConfiguration> {
        self.layout.as_ref()
    }
}
/// See [`BodySectionContent`](crate::model::BodySectionContent).
pub mod body_section_content {

    /// A builder for [`BodySectionContent`](crate::model::BodySectionContent).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) layout: std::option::Option<crate::model::SectionLayoutConfiguration>,
    }
    impl Builder {
        /// <p>The layout configuration of a body section.</p>
        pub fn layout(mut self, input: crate::model::SectionLayoutConfiguration) -> Self {
            self.layout = Some(input);
            self
        }
        /// <p>The layout configuration of a body section.</p>
        pub fn set_layout(
            mut self,
            input: std::option::Option<crate::model::SectionLayoutConfiguration>,
        ) -> Self {
            self.layout = input;
            self
        }
        /// Consumes the builder and constructs a [`BodySectionContent`](crate::model::BodySectionContent).
        pub fn build(self) -> crate::model::BodySectionContent {
            crate::model::BodySectionContent {
                layout: self.layout,
            }
        }
    }
}
impl BodySectionContent {
    /// Creates a new builder-style object to manufacture [`BodySectionContent`](crate::model::BodySectionContent).
    pub fn builder() -> crate::model::body_section_content::Builder {
        crate::model::body_section_content::Builder::default()
    }
}

/// <p>The configuration of a free-form layout.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FreeFormLayoutConfiguration {
    /// <p>The elements that are included in a free-form layout.</p>
    #[doc(hidden)]
    pub elements: std::option::Option<std::vec::Vec<crate::model::FreeFormLayoutElement>>,
    /// <p>Configuration options for the canvas of a free-form layout.</p>
    #[doc(hidden)]
    pub canvas_size_options: std::option::Option<crate::model::FreeFormLayoutCanvasSizeOptions>,
}
impl FreeFormLayoutConfiguration {
    /// <p>The elements that are included in a free-form layout.</p>
    pub fn elements(&self) -> std::option::Option<&[crate::model::FreeFormLayoutElement]> {
        self.elements.as_deref()
    }
    /// <p>Configuration options for the canvas of a free-form layout.</p>
    pub fn canvas_size_options(
        &self,
    ) -> std::option::Option<&crate::model::FreeFormLayoutCanvasSizeOptions> {
        self.canvas_size_options.as_ref()
    }
}
/// See [`FreeFormLayoutConfiguration`](crate::model::FreeFormLayoutConfiguration).
pub mod free_form_layout_configuration {

    /// A builder for [`FreeFormLayoutConfiguration`](crate::model::FreeFormLayoutConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) elements:
            std::option::Option<std::vec::Vec<crate::model::FreeFormLayoutElement>>,
        pub(crate) canvas_size_options:
            std::option::Option<crate::model::FreeFormLayoutCanvasSizeOptions>,
    }
    impl Builder {
        /// Appends an item to `elements`.
        ///
        /// To override the contents of this collection use [`set_elements`](Self::set_elements).
        ///
        /// <p>The elements that are included in a free-form layout.</p>
        pub fn elements(mut self, input: crate::model::FreeFormLayoutElement) -> Self {
            let mut v = self.elements.unwrap_or_default();
            v.push(input);
            self.elements = Some(v);
            self
        }
        /// <p>The elements that are included in a free-form layout.</p>
        pub fn set_elements(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FreeFormLayoutElement>>,
        ) -> Self {
            self.elements = input;
            self
        }
        /// <p>Configuration options for the canvas of a free-form layout.</p>
        pub fn canvas_size_options(
            mut self,
            input: crate::model::FreeFormLayoutCanvasSizeOptions,
        ) -> Self {
            self.canvas_size_options = Some(input);
            self
        }
        /// <p>Configuration options for the canvas of a free-form layout.</p>
        pub fn set_canvas_size_options(
            mut self,
            input: std::option::Option<crate::model::FreeFormLayoutCanvasSizeOptions>,
        ) -> Self {
            self.canvas_size_options = input;
            self
        }
        /// Consumes the builder and constructs a [`FreeFormLayoutConfiguration`](crate::model::FreeFormLayoutConfiguration).
        pub fn build(self) -> crate::model::FreeFormLayoutConfiguration {
            crate::model::FreeFormLayoutConfiguration {
                elements: self.elements,
                canvas_size_options: self.canvas_size_options,
            }
        }
    }
}
impl FreeFormLayoutConfiguration {
    /// Creates a new builder-style object to manufacture [`FreeFormLayoutConfiguration`](crate::model::FreeFormLayoutConfiguration).
    pub fn builder() -> crate::model::free_form_layout_configuration::Builder {
        crate::model::free_form_layout_configuration::Builder::default()
    }
}

/// <p>A text box.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SheetTextBox {
    /// <p>The unique identifier for a text box. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have text boxes that share identifiers.</p>
    #[doc(hidden)]
    pub sheet_text_box_id: std::option::Option<std::string::String>,
    /// <p>The content that is displayed in the text box.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
}
impl SheetTextBox {
    /// <p>The unique identifier for a text box. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have text boxes that share identifiers.</p>
    pub fn sheet_text_box_id(&self) -> std::option::Option<&str> {
        self.sheet_text_box_id.as_deref()
    }
    /// <p>The content that is displayed in the text box.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
}
/// See [`SheetTextBox`](crate::model::SheetTextBox).
pub mod sheet_text_box {

    /// A builder for [`SheetTextBox`](crate::model::SheetTextBox).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sheet_text_box_id: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for a text box. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have text boxes that share identifiers.</p>
        pub fn sheet_text_box_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sheet_text_box_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for a text box. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have text boxes that share identifiers.</p>
        pub fn set_sheet_text_box_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sheet_text_box_id = input;
            self
        }
        /// <p>The content that is displayed in the text box.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The content that is displayed in the text box.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`SheetTextBox`](crate::model::SheetTextBox).
        pub fn build(self) -> crate::model::SheetTextBox {
            crate::model::SheetTextBox {
                sheet_text_box_id: self.sheet_text_box_id,
                content: self.content,
            }
        }
    }
}
impl SheetTextBox {
    /// Creates a new builder-style object to manufacture [`SheetTextBox`](crate::model::SheetTextBox).
    pub fn builder() -> crate::model::sheet_text_box::Builder {
        crate::model::sheet_text_box::Builder::default()
    }
}

/// <p>A visual displayed on a sheet in an analysis, dashboard, or template.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Visual {
    /// <p>A table visual.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/tabular.html">Using tables as visuals</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub table_visual: std::option::Option<crate::model::TableVisual>,
    /// <p>A pivot table.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/pivot-table.html">Using pivot tables</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub pivot_table_visual: std::option::Option<crate::model::PivotTableVisual>,
    /// <p>A bar chart.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/bar-charts.html">Using bar charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub bar_chart_visual: std::option::Option<crate::model::BarChartVisual>,
    /// <p>A key performance indicator (KPI).</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/kpi.html">Using KPIs</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub kpi_visual: std::option::Option<crate::model::KpiVisual>,
    /// <p>A pie or donut chart.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/pie-chart.html">Using pie charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub pie_chart_visual: std::option::Option<crate::model::PieChartVisual>,
    /// <p>A gauge chart.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/gauge-chart.html">Using gauge charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub gauge_chart_visual: std::option::Option<crate::model::GaugeChartVisual>,
    /// <p>A line chart.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/line-charts.html">Using line charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub line_chart_visual: std::option::Option<crate::model::LineChartVisual>,
    /// <p>A heat map.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/heat-map.html">Using heat maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub heat_map_visual: std::option::Option<crate::model::HeatMapVisual>,
    /// <p>A tree map.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/tree-map.html">Using tree maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub tree_map_visual: std::option::Option<crate::model::TreeMapVisual>,
    /// <p>A geospatial map or a points on map visual.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/point-maps.html">Creating point maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub geospatial_map_visual: std::option::Option<crate::model::GeospatialMapVisual>,
    /// <p>A filled map.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/filled-maps.html">Creating filled maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub filled_map_visual: std::option::Option<crate::model::FilledMapVisual>,
    /// <p>A funnel chart.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/funnel-visual-content.html">Using funnel charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub funnel_chart_visual: std::option::Option<crate::model::FunnelChartVisual>,
    /// <p>A scatter plot.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/scatter-plot.html">Using scatter plots</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub scatter_plot_visual: std::option::Option<crate::model::ScatterPlotVisual>,
    /// <p>A combo chart.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/combo-charts.html">Using combo charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub combo_chart_visual: std::option::Option<crate::model::ComboChartVisual>,
    /// <p>A box plot.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/box-plots.html">Using box plots</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub box_plot_visual: std::option::Option<crate::model::BoxPlotVisual>,
    /// <p>A waterfall chart.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/waterfall-chart.html">Using waterfall charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub waterfall_visual: std::option::Option<crate::model::WaterfallVisual>,
    /// <p>A histogram.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/histogram-charts.html">Using histograms</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub histogram_visual: std::option::Option<crate::model::HistogramVisual>,
    /// <p>A word cloud.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/word-cloud.html">Using word clouds</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub word_cloud_visual: std::option::Option<crate::model::WordCloudVisual>,
    /// <p>An insight visual.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/computational-insights.html">Working with insights</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub insight_visual: std::option::Option<crate::model::InsightVisual>,
    /// <p>A sankey diagram.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/sankey-diagram.html">Using Sankey diagrams</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub sankey_diagram_visual: std::option::Option<crate::model::SankeyDiagramVisual>,
    /// <p>A visual that contains custom content.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/custom-visual-content.html">Using custom visual content</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub custom_content_visual: std::option::Option<crate::model::CustomContentVisual>,
    /// <p>An empty visual.</p>
    #[doc(hidden)]
    pub empty_visual: std::option::Option<crate::model::EmptyVisual>,
}
impl Visual {
    /// <p>A table visual.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/tabular.html">Using tables as visuals</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn table_visual(&self) -> std::option::Option<&crate::model::TableVisual> {
        self.table_visual.as_ref()
    }
    /// <p>A pivot table.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/pivot-table.html">Using pivot tables</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn pivot_table_visual(&self) -> std::option::Option<&crate::model::PivotTableVisual> {
        self.pivot_table_visual.as_ref()
    }
    /// <p>A bar chart.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/bar-charts.html">Using bar charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn bar_chart_visual(&self) -> std::option::Option<&crate::model::BarChartVisual> {
        self.bar_chart_visual.as_ref()
    }
    /// <p>A key performance indicator (KPI).</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/kpi.html">Using KPIs</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn kpi_visual(&self) -> std::option::Option<&crate::model::KpiVisual> {
        self.kpi_visual.as_ref()
    }
    /// <p>A pie or donut chart.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/pie-chart.html">Using pie charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn pie_chart_visual(&self) -> std::option::Option<&crate::model::PieChartVisual> {
        self.pie_chart_visual.as_ref()
    }
    /// <p>A gauge chart.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/gauge-chart.html">Using gauge charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn gauge_chart_visual(&self) -> std::option::Option<&crate::model::GaugeChartVisual> {
        self.gauge_chart_visual.as_ref()
    }
    /// <p>A line chart.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/line-charts.html">Using line charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn line_chart_visual(&self) -> std::option::Option<&crate::model::LineChartVisual> {
        self.line_chart_visual.as_ref()
    }
    /// <p>A heat map.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/heat-map.html">Using heat maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn heat_map_visual(&self) -> std::option::Option<&crate::model::HeatMapVisual> {
        self.heat_map_visual.as_ref()
    }
    /// <p>A tree map.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/tree-map.html">Using tree maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn tree_map_visual(&self) -> std::option::Option<&crate::model::TreeMapVisual> {
        self.tree_map_visual.as_ref()
    }
    /// <p>A geospatial map or a points on map visual.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/point-maps.html">Creating point maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn geospatial_map_visual(&self) -> std::option::Option<&crate::model::GeospatialMapVisual> {
        self.geospatial_map_visual.as_ref()
    }
    /// <p>A filled map.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/filled-maps.html">Creating filled maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn filled_map_visual(&self) -> std::option::Option<&crate::model::FilledMapVisual> {
        self.filled_map_visual.as_ref()
    }
    /// <p>A funnel chart.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/funnel-visual-content.html">Using funnel charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn funnel_chart_visual(&self) -> std::option::Option<&crate::model::FunnelChartVisual> {
        self.funnel_chart_visual.as_ref()
    }
    /// <p>A scatter plot.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/scatter-plot.html">Using scatter plots</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn scatter_plot_visual(&self) -> std::option::Option<&crate::model::ScatterPlotVisual> {
        self.scatter_plot_visual.as_ref()
    }
    /// <p>A combo chart.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/combo-charts.html">Using combo charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn combo_chart_visual(&self) -> std::option::Option<&crate::model::ComboChartVisual> {
        self.combo_chart_visual.as_ref()
    }
    /// <p>A box plot.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/box-plots.html">Using box plots</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn box_plot_visual(&self) -> std::option::Option<&crate::model::BoxPlotVisual> {
        self.box_plot_visual.as_ref()
    }
    /// <p>A waterfall chart.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/waterfall-chart.html">Using waterfall charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn waterfall_visual(&self) -> std::option::Option<&crate::model::WaterfallVisual> {
        self.waterfall_visual.as_ref()
    }
    /// <p>A histogram.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/histogram-charts.html">Using histograms</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn histogram_visual(&self) -> std::option::Option<&crate::model::HistogramVisual> {
        self.histogram_visual.as_ref()
    }
    /// <p>A word cloud.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/word-cloud.html">Using word clouds</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn word_cloud_visual(&self) -> std::option::Option<&crate::model::WordCloudVisual> {
        self.word_cloud_visual.as_ref()
    }
    /// <p>An insight visual.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/computational-insights.html">Working with insights</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn insight_visual(&self) -> std::option::Option<&crate::model::InsightVisual> {
        self.insight_visual.as_ref()
    }
    /// <p>A sankey diagram.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/sankey-diagram.html">Using Sankey diagrams</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn sankey_diagram_visual(&self) -> std::option::Option<&crate::model::SankeyDiagramVisual> {
        self.sankey_diagram_visual.as_ref()
    }
    /// <p>A visual that contains custom content.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/custom-visual-content.html">Using custom visual content</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn custom_content_visual(&self) -> std::option::Option<&crate::model::CustomContentVisual> {
        self.custom_content_visual.as_ref()
    }
    /// <p>An empty visual.</p>
    pub fn empty_visual(&self) -> std::option::Option<&crate::model::EmptyVisual> {
        self.empty_visual.as_ref()
    }
}
/// See [`Visual`](crate::model::Visual).
pub mod visual {

    /// A builder for [`Visual`](crate::model::Visual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_visual: std::option::Option<crate::model::TableVisual>,
        pub(crate) pivot_table_visual: std::option::Option<crate::model::PivotTableVisual>,
        pub(crate) bar_chart_visual: std::option::Option<crate::model::BarChartVisual>,
        pub(crate) kpi_visual: std::option::Option<crate::model::KpiVisual>,
        pub(crate) pie_chart_visual: std::option::Option<crate::model::PieChartVisual>,
        pub(crate) gauge_chart_visual: std::option::Option<crate::model::GaugeChartVisual>,
        pub(crate) line_chart_visual: std::option::Option<crate::model::LineChartVisual>,
        pub(crate) heat_map_visual: std::option::Option<crate::model::HeatMapVisual>,
        pub(crate) tree_map_visual: std::option::Option<crate::model::TreeMapVisual>,
        pub(crate) geospatial_map_visual: std::option::Option<crate::model::GeospatialMapVisual>,
        pub(crate) filled_map_visual: std::option::Option<crate::model::FilledMapVisual>,
        pub(crate) funnel_chart_visual: std::option::Option<crate::model::FunnelChartVisual>,
        pub(crate) scatter_plot_visual: std::option::Option<crate::model::ScatterPlotVisual>,
        pub(crate) combo_chart_visual: std::option::Option<crate::model::ComboChartVisual>,
        pub(crate) box_plot_visual: std::option::Option<crate::model::BoxPlotVisual>,
        pub(crate) waterfall_visual: std::option::Option<crate::model::WaterfallVisual>,
        pub(crate) histogram_visual: std::option::Option<crate::model::HistogramVisual>,
        pub(crate) word_cloud_visual: std::option::Option<crate::model::WordCloudVisual>,
        pub(crate) insight_visual: std::option::Option<crate::model::InsightVisual>,
        pub(crate) sankey_diagram_visual: std::option::Option<crate::model::SankeyDiagramVisual>,
        pub(crate) custom_content_visual: std::option::Option<crate::model::CustomContentVisual>,
        pub(crate) empty_visual: std::option::Option<crate::model::EmptyVisual>,
    }
    impl Builder {
        /// <p>A table visual.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/tabular.html">Using tables as visuals</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn table_visual(mut self, input: crate::model::TableVisual) -> Self {
            self.table_visual = Some(input);
            self
        }
        /// <p>A table visual.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/tabular.html">Using tables as visuals</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_table_visual(
            mut self,
            input: std::option::Option<crate::model::TableVisual>,
        ) -> Self {
            self.table_visual = input;
            self
        }
        /// <p>A pivot table.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/pivot-table.html">Using pivot tables</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn pivot_table_visual(mut self, input: crate::model::PivotTableVisual) -> Self {
            self.pivot_table_visual = Some(input);
            self
        }
        /// <p>A pivot table.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/pivot-table.html">Using pivot tables</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_pivot_table_visual(
            mut self,
            input: std::option::Option<crate::model::PivotTableVisual>,
        ) -> Self {
            self.pivot_table_visual = input;
            self
        }
        /// <p>A bar chart.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/bar-charts.html">Using bar charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn bar_chart_visual(mut self, input: crate::model::BarChartVisual) -> Self {
            self.bar_chart_visual = Some(input);
            self
        }
        /// <p>A bar chart.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/bar-charts.html">Using bar charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_bar_chart_visual(
            mut self,
            input: std::option::Option<crate::model::BarChartVisual>,
        ) -> Self {
            self.bar_chart_visual = input;
            self
        }
        /// <p>A key performance indicator (KPI).</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/kpi.html">Using KPIs</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn kpi_visual(mut self, input: crate::model::KpiVisual) -> Self {
            self.kpi_visual = Some(input);
            self
        }
        /// <p>A key performance indicator (KPI).</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/kpi.html">Using KPIs</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_kpi_visual(
            mut self,
            input: std::option::Option<crate::model::KpiVisual>,
        ) -> Self {
            self.kpi_visual = input;
            self
        }
        /// <p>A pie or donut chart.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/pie-chart.html">Using pie charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn pie_chart_visual(mut self, input: crate::model::PieChartVisual) -> Self {
            self.pie_chart_visual = Some(input);
            self
        }
        /// <p>A pie or donut chart.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/pie-chart.html">Using pie charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_pie_chart_visual(
            mut self,
            input: std::option::Option<crate::model::PieChartVisual>,
        ) -> Self {
            self.pie_chart_visual = input;
            self
        }
        /// <p>A gauge chart.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/gauge-chart.html">Using gauge charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn gauge_chart_visual(mut self, input: crate::model::GaugeChartVisual) -> Self {
            self.gauge_chart_visual = Some(input);
            self
        }
        /// <p>A gauge chart.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/gauge-chart.html">Using gauge charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_gauge_chart_visual(
            mut self,
            input: std::option::Option<crate::model::GaugeChartVisual>,
        ) -> Self {
            self.gauge_chart_visual = input;
            self
        }
        /// <p>A line chart.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/line-charts.html">Using line charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn line_chart_visual(mut self, input: crate::model::LineChartVisual) -> Self {
            self.line_chart_visual = Some(input);
            self
        }
        /// <p>A line chart.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/line-charts.html">Using line charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_line_chart_visual(
            mut self,
            input: std::option::Option<crate::model::LineChartVisual>,
        ) -> Self {
            self.line_chart_visual = input;
            self
        }
        /// <p>A heat map.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/heat-map.html">Using heat maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn heat_map_visual(mut self, input: crate::model::HeatMapVisual) -> Self {
            self.heat_map_visual = Some(input);
            self
        }
        /// <p>A heat map.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/heat-map.html">Using heat maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_heat_map_visual(
            mut self,
            input: std::option::Option<crate::model::HeatMapVisual>,
        ) -> Self {
            self.heat_map_visual = input;
            self
        }
        /// <p>A tree map.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/tree-map.html">Using tree maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn tree_map_visual(mut self, input: crate::model::TreeMapVisual) -> Self {
            self.tree_map_visual = Some(input);
            self
        }
        /// <p>A tree map.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/tree-map.html">Using tree maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_tree_map_visual(
            mut self,
            input: std::option::Option<crate::model::TreeMapVisual>,
        ) -> Self {
            self.tree_map_visual = input;
            self
        }
        /// <p>A geospatial map or a points on map visual.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/point-maps.html">Creating point maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn geospatial_map_visual(mut self, input: crate::model::GeospatialMapVisual) -> Self {
            self.geospatial_map_visual = Some(input);
            self
        }
        /// <p>A geospatial map or a points on map visual.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/point-maps.html">Creating point maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_geospatial_map_visual(
            mut self,
            input: std::option::Option<crate::model::GeospatialMapVisual>,
        ) -> Self {
            self.geospatial_map_visual = input;
            self
        }
        /// <p>A filled map.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/filled-maps.html">Creating filled maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn filled_map_visual(mut self, input: crate::model::FilledMapVisual) -> Self {
            self.filled_map_visual = Some(input);
            self
        }
        /// <p>A filled map.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/filled-maps.html">Creating filled maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_filled_map_visual(
            mut self,
            input: std::option::Option<crate::model::FilledMapVisual>,
        ) -> Self {
            self.filled_map_visual = input;
            self
        }
        /// <p>A funnel chart.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/funnel-visual-content.html">Using funnel charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn funnel_chart_visual(mut self, input: crate::model::FunnelChartVisual) -> Self {
            self.funnel_chart_visual = Some(input);
            self
        }
        /// <p>A funnel chart.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/funnel-visual-content.html">Using funnel charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_funnel_chart_visual(
            mut self,
            input: std::option::Option<crate::model::FunnelChartVisual>,
        ) -> Self {
            self.funnel_chart_visual = input;
            self
        }
        /// <p>A scatter plot.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/scatter-plot.html">Using scatter plots</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn scatter_plot_visual(mut self, input: crate::model::ScatterPlotVisual) -> Self {
            self.scatter_plot_visual = Some(input);
            self
        }
        /// <p>A scatter plot.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/scatter-plot.html">Using scatter plots</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_scatter_plot_visual(
            mut self,
            input: std::option::Option<crate::model::ScatterPlotVisual>,
        ) -> Self {
            self.scatter_plot_visual = input;
            self
        }
        /// <p>A combo chart.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/combo-charts.html">Using combo charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn combo_chart_visual(mut self, input: crate::model::ComboChartVisual) -> Self {
            self.combo_chart_visual = Some(input);
            self
        }
        /// <p>A combo chart.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/combo-charts.html">Using combo charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_combo_chart_visual(
            mut self,
            input: std::option::Option<crate::model::ComboChartVisual>,
        ) -> Self {
            self.combo_chart_visual = input;
            self
        }
        /// <p>A box plot.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/box-plots.html">Using box plots</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn box_plot_visual(mut self, input: crate::model::BoxPlotVisual) -> Self {
            self.box_plot_visual = Some(input);
            self
        }
        /// <p>A box plot.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/box-plots.html">Using box plots</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_box_plot_visual(
            mut self,
            input: std::option::Option<crate::model::BoxPlotVisual>,
        ) -> Self {
            self.box_plot_visual = input;
            self
        }
        /// <p>A waterfall chart.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/waterfall-chart.html">Using waterfall charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn waterfall_visual(mut self, input: crate::model::WaterfallVisual) -> Self {
            self.waterfall_visual = Some(input);
            self
        }
        /// <p>A waterfall chart.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/waterfall-chart.html">Using waterfall charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_waterfall_visual(
            mut self,
            input: std::option::Option<crate::model::WaterfallVisual>,
        ) -> Self {
            self.waterfall_visual = input;
            self
        }
        /// <p>A histogram.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/histogram-charts.html">Using histograms</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn histogram_visual(mut self, input: crate::model::HistogramVisual) -> Self {
            self.histogram_visual = Some(input);
            self
        }
        /// <p>A histogram.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/histogram-charts.html">Using histograms</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_histogram_visual(
            mut self,
            input: std::option::Option<crate::model::HistogramVisual>,
        ) -> Self {
            self.histogram_visual = input;
            self
        }
        /// <p>A word cloud.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/word-cloud.html">Using word clouds</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn word_cloud_visual(mut self, input: crate::model::WordCloudVisual) -> Self {
            self.word_cloud_visual = Some(input);
            self
        }
        /// <p>A word cloud.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/word-cloud.html">Using word clouds</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_word_cloud_visual(
            mut self,
            input: std::option::Option<crate::model::WordCloudVisual>,
        ) -> Self {
            self.word_cloud_visual = input;
            self
        }
        /// <p>An insight visual.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/computational-insights.html">Working with insights</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn insight_visual(mut self, input: crate::model::InsightVisual) -> Self {
            self.insight_visual = Some(input);
            self
        }
        /// <p>An insight visual.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/computational-insights.html">Working with insights</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_insight_visual(
            mut self,
            input: std::option::Option<crate::model::InsightVisual>,
        ) -> Self {
            self.insight_visual = input;
            self
        }
        /// <p>A sankey diagram.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/sankey-diagram.html">Using Sankey diagrams</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn sankey_diagram_visual(mut self, input: crate::model::SankeyDiagramVisual) -> Self {
            self.sankey_diagram_visual = Some(input);
            self
        }
        /// <p>A sankey diagram.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/sankey-diagram.html">Using Sankey diagrams</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_sankey_diagram_visual(
            mut self,
            input: std::option::Option<crate::model::SankeyDiagramVisual>,
        ) -> Self {
            self.sankey_diagram_visual = input;
            self
        }
        /// <p>A visual that contains custom content.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/custom-visual-content.html">Using custom visual content</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn custom_content_visual(mut self, input: crate::model::CustomContentVisual) -> Self {
            self.custom_content_visual = Some(input);
            self
        }
        /// <p>A visual that contains custom content.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/custom-visual-content.html">Using custom visual content</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_custom_content_visual(
            mut self,
            input: std::option::Option<crate::model::CustomContentVisual>,
        ) -> Self {
            self.custom_content_visual = input;
            self
        }
        /// <p>An empty visual.</p>
        pub fn empty_visual(mut self, input: crate::model::EmptyVisual) -> Self {
            self.empty_visual = Some(input);
            self
        }
        /// <p>An empty visual.</p>
        pub fn set_empty_visual(
            mut self,
            input: std::option::Option<crate::model::EmptyVisual>,
        ) -> Self {
            self.empty_visual = input;
            self
        }
        /// Consumes the builder and constructs a [`Visual`](crate::model::Visual).
        pub fn build(self) -> crate::model::Visual {
            crate::model::Visual {
                table_visual: self.table_visual,
                pivot_table_visual: self.pivot_table_visual,
                bar_chart_visual: self.bar_chart_visual,
                kpi_visual: self.kpi_visual,
                pie_chart_visual: self.pie_chart_visual,
                gauge_chart_visual: self.gauge_chart_visual,
                line_chart_visual: self.line_chart_visual,
                heat_map_visual: self.heat_map_visual,
                tree_map_visual: self.tree_map_visual,
                geospatial_map_visual: self.geospatial_map_visual,
                filled_map_visual: self.filled_map_visual,
                funnel_chart_visual: self.funnel_chart_visual,
                scatter_plot_visual: self.scatter_plot_visual,
                combo_chart_visual: self.combo_chart_visual,
                box_plot_visual: self.box_plot_visual,
                waterfall_visual: self.waterfall_visual,
                histogram_visual: self.histogram_visual,
                word_cloud_visual: self.word_cloud_visual,
                insight_visual: self.insight_visual,
                sankey_diagram_visual: self.sankey_diagram_visual,
                custom_content_visual: self.custom_content_visual,
                empty_visual: self.empty_visual,
            }
        }
    }
}
impl Visual {
    /// Creates a new builder-style object to manufacture [`Visual`](crate::model::Visual).
    pub fn builder() -> crate::model::visual::Builder {
        crate::model::visual::Builder::default()
    }
}

/// <p>An empty visual.</p>
/// <p>Empty visuals are used in layouts but have not been configured to show any data. A new visual created in the Amazon QuickSight console is considered an <code>EmptyVisual</code> until a visual type is selected.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EmptyVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The data set that is used in the empty visual. Every visual requires a dataset to render.</p>
    #[doc(hidden)]
    pub data_set_identifier: std::option::Option<std::string::String>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
}
impl EmptyVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The data set that is used in the empty visual. Every visual requires a dataset to render.</p>
    pub fn data_set_identifier(&self) -> std::option::Option<&str> {
        self.data_set_identifier.as_deref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
}
/// See [`EmptyVisual`](crate::model::EmptyVisual).
pub mod empty_visual {

    /// A builder for [`EmptyVisual`](crate::model::EmptyVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) data_set_identifier: std::option::Option<std::string::String>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The data set that is used in the empty visual. Every visual requires a dataset to render.</p>
        pub fn data_set_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_set_identifier = Some(input.into());
            self
        }
        /// <p>The data set that is used in the empty visual. Every visual requires a dataset to render.</p>
        pub fn set_data_set_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_set_identifier = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Consumes the builder and constructs a [`EmptyVisual`](crate::model::EmptyVisual).
        pub fn build(self) -> crate::model::EmptyVisual {
            crate::model::EmptyVisual {
                visual_id: self.visual_id,
                data_set_identifier: self.data_set_identifier,
                actions: self.actions,
            }
        }
    }
}
impl EmptyVisual {
    /// Creates a new builder-style object to manufacture [`EmptyVisual`](crate::model::EmptyVisual).
    pub fn builder() -> crate::model::empty_visual::Builder {
        crate::model::empty_visual::Builder::default()
    }
}

/// <p>A custom action defined on a visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VisualCustomAction {
    /// <p>The ID of the <code>VisualCustomAction</code>.</p>
    #[doc(hidden)]
    pub custom_action_id: std::option::Option<std::string::String>,
    /// <p>The name of the <code>VisualCustomAction</code>.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The status of the <code>VisualCustomAction</code>.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::WidgetStatus>,
    /// <p>The trigger of the <code>VisualCustomAction</code>.</p>
    /// <p>Valid values are defined as follows:</p>
    /// <ul>
    /// <li> <p> <code>DATA_POINT_CLICK</code>: Initiates a custom action by a left pointer click on a data point.</p> </li>
    /// <li> <p> <code>DATA_POINT_MENU</code>: Initiates a custom action by right pointer click from the menu.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub trigger: std::option::Option<crate::model::VisualCustomActionTrigger>,
    /// <p>A list of <code>VisualCustomActionOperations</code>.</p>
    /// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
    #[doc(hidden)]
    pub action_operations:
        std::option::Option<std::vec::Vec<crate::model::VisualCustomActionOperation>>,
}
impl VisualCustomAction {
    /// <p>The ID of the <code>VisualCustomAction</code>.</p>
    pub fn custom_action_id(&self) -> std::option::Option<&str> {
        self.custom_action_id.as_deref()
    }
    /// <p>The name of the <code>VisualCustomAction</code>.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The status of the <code>VisualCustomAction</code>.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::WidgetStatus> {
        self.status.as_ref()
    }
    /// <p>The trigger of the <code>VisualCustomAction</code>.</p>
    /// <p>Valid values are defined as follows:</p>
    /// <ul>
    /// <li> <p> <code>DATA_POINT_CLICK</code>: Initiates a custom action by a left pointer click on a data point.</p> </li>
    /// <li> <p> <code>DATA_POINT_MENU</code>: Initiates a custom action by right pointer click from the menu.</p> </li>
    /// </ul>
    pub fn trigger(&self) -> std::option::Option<&crate::model::VisualCustomActionTrigger> {
        self.trigger.as_ref()
    }
    /// <p>A list of <code>VisualCustomActionOperations</code>.</p>
    /// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
    pub fn action_operations(
        &self,
    ) -> std::option::Option<&[crate::model::VisualCustomActionOperation]> {
        self.action_operations.as_deref()
    }
}
/// See [`VisualCustomAction`](crate::model::VisualCustomAction).
pub mod visual_custom_action {

    /// A builder for [`VisualCustomAction`](crate::model::VisualCustomAction).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) custom_action_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::WidgetStatus>,
        pub(crate) trigger: std::option::Option<crate::model::VisualCustomActionTrigger>,
        pub(crate) action_operations:
            std::option::Option<std::vec::Vec<crate::model::VisualCustomActionOperation>>,
    }
    impl Builder {
        /// <p>The ID of the <code>VisualCustomAction</code>.</p>
        pub fn custom_action_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_action_id = Some(input.into());
            self
        }
        /// <p>The ID of the <code>VisualCustomAction</code>.</p>
        pub fn set_custom_action_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.custom_action_id = input;
            self
        }
        /// <p>The name of the <code>VisualCustomAction</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the <code>VisualCustomAction</code>.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The status of the <code>VisualCustomAction</code>.</p>
        pub fn status(mut self, input: crate::model::WidgetStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the <code>VisualCustomAction</code>.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::WidgetStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The trigger of the <code>VisualCustomAction</code>.</p>
        /// <p>Valid values are defined as follows:</p>
        /// <ul>
        /// <li> <p> <code>DATA_POINT_CLICK</code>: Initiates a custom action by a left pointer click on a data point.</p> </li>
        /// <li> <p> <code>DATA_POINT_MENU</code>: Initiates a custom action by right pointer click from the menu.</p> </li>
        /// </ul>
        pub fn trigger(mut self, input: crate::model::VisualCustomActionTrigger) -> Self {
            self.trigger = Some(input);
            self
        }
        /// <p>The trigger of the <code>VisualCustomAction</code>.</p>
        /// <p>Valid values are defined as follows:</p>
        /// <ul>
        /// <li> <p> <code>DATA_POINT_CLICK</code>: Initiates a custom action by a left pointer click on a data point.</p> </li>
        /// <li> <p> <code>DATA_POINT_MENU</code>: Initiates a custom action by right pointer click from the menu.</p> </li>
        /// </ul>
        pub fn set_trigger(
            mut self,
            input: std::option::Option<crate::model::VisualCustomActionTrigger>,
        ) -> Self {
            self.trigger = input;
            self
        }
        /// Appends an item to `action_operations`.
        ///
        /// To override the contents of this collection use [`set_action_operations`](Self::set_action_operations).
        ///
        /// <p>A list of <code>VisualCustomActionOperations</code>.</p>
        /// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
        pub fn action_operations(
            mut self,
            input: crate::model::VisualCustomActionOperation,
        ) -> Self {
            let mut v = self.action_operations.unwrap_or_default();
            v.push(input);
            self.action_operations = Some(v);
            self
        }
        /// <p>A list of <code>VisualCustomActionOperations</code>.</p>
        /// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
        pub fn set_action_operations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomActionOperation>>,
        ) -> Self {
            self.action_operations = input;
            self
        }
        /// Consumes the builder and constructs a [`VisualCustomAction`](crate::model::VisualCustomAction).
        pub fn build(self) -> crate::model::VisualCustomAction {
            crate::model::VisualCustomAction {
                custom_action_id: self.custom_action_id,
                name: self.name,
                status: self.status,
                trigger: self.trigger,
                action_operations: self.action_operations,
            }
        }
    }
}
impl VisualCustomAction {
    /// Creates a new builder-style object to manufacture [`VisualCustomAction`](crate::model::VisualCustomAction).
    pub fn builder() -> crate::model::visual_custom_action::Builder {
        crate::model::visual_custom_action::Builder::default()
    }
}

/// <p>The operation that is defined by the custom action.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VisualCustomActionOperation {
    /// <p>The filter operation that filters data included in a visual or in an entire sheet.</p>
    #[doc(hidden)]
    pub filter_operation: std::option::Option<crate::model::CustomActionFilterOperation>,
    /// <p>The navigation operation that navigates between different sheets in the same analysis.</p>
    #[doc(hidden)]
    pub navigation_operation: std::option::Option<crate::model::CustomActionNavigationOperation>,
    /// <p>The URL operation that opens a link to another webpage.</p>
    #[doc(hidden)]
    pub url_operation: std::option::Option<crate::model::CustomActionUrlOperation>,
    /// <p>The set parameter operation that sets parameters in custom action.</p>
    #[doc(hidden)]
    pub set_parameters_operation:
        std::option::Option<crate::model::CustomActionSetParametersOperation>,
}
impl VisualCustomActionOperation {
    /// <p>The filter operation that filters data included in a visual or in an entire sheet.</p>
    pub fn filter_operation(
        &self,
    ) -> std::option::Option<&crate::model::CustomActionFilterOperation> {
        self.filter_operation.as_ref()
    }
    /// <p>The navigation operation that navigates between different sheets in the same analysis.</p>
    pub fn navigation_operation(
        &self,
    ) -> std::option::Option<&crate::model::CustomActionNavigationOperation> {
        self.navigation_operation.as_ref()
    }
    /// <p>The URL operation that opens a link to another webpage.</p>
    pub fn url_operation(&self) -> std::option::Option<&crate::model::CustomActionUrlOperation> {
        self.url_operation.as_ref()
    }
    /// <p>The set parameter operation that sets parameters in custom action.</p>
    pub fn set_parameters_operation(
        &self,
    ) -> std::option::Option<&crate::model::CustomActionSetParametersOperation> {
        self.set_parameters_operation.as_ref()
    }
}
/// See [`VisualCustomActionOperation`](crate::model::VisualCustomActionOperation).
pub mod visual_custom_action_operation {

    /// A builder for [`VisualCustomActionOperation`](crate::model::VisualCustomActionOperation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_operation: std::option::Option<crate::model::CustomActionFilterOperation>,
        pub(crate) navigation_operation:
            std::option::Option<crate::model::CustomActionNavigationOperation>,
        pub(crate) url_operation: std::option::Option<crate::model::CustomActionUrlOperation>,
        pub(crate) set_parameters_operation:
            std::option::Option<crate::model::CustomActionSetParametersOperation>,
    }
    impl Builder {
        /// <p>The filter operation that filters data included in a visual or in an entire sheet.</p>
        pub fn filter_operation(
            mut self,
            input: crate::model::CustomActionFilterOperation,
        ) -> Self {
            self.filter_operation = Some(input);
            self
        }
        /// <p>The filter operation that filters data included in a visual or in an entire sheet.</p>
        pub fn set_filter_operation(
            mut self,
            input: std::option::Option<crate::model::CustomActionFilterOperation>,
        ) -> Self {
            self.filter_operation = input;
            self
        }
        /// <p>The navigation operation that navigates between different sheets in the same analysis.</p>
        pub fn navigation_operation(
            mut self,
            input: crate::model::CustomActionNavigationOperation,
        ) -> Self {
            self.navigation_operation = Some(input);
            self
        }
        /// <p>The navigation operation that navigates between different sheets in the same analysis.</p>
        pub fn set_navigation_operation(
            mut self,
            input: std::option::Option<crate::model::CustomActionNavigationOperation>,
        ) -> Self {
            self.navigation_operation = input;
            self
        }
        /// <p>The URL operation that opens a link to another webpage.</p>
        pub fn url_operation(mut self, input: crate::model::CustomActionUrlOperation) -> Self {
            self.url_operation = Some(input);
            self
        }
        /// <p>The URL operation that opens a link to another webpage.</p>
        pub fn set_url_operation(
            mut self,
            input: std::option::Option<crate::model::CustomActionUrlOperation>,
        ) -> Self {
            self.url_operation = input;
            self
        }
        /// <p>The set parameter operation that sets parameters in custom action.</p>
        pub fn set_parameters_operation(
            mut self,
            input: crate::model::CustomActionSetParametersOperation,
        ) -> Self {
            self.set_parameters_operation = Some(input);
            self
        }
        /// <p>The set parameter operation that sets parameters in custom action.</p>
        pub fn set_set_parameters_operation(
            mut self,
            input: std::option::Option<crate::model::CustomActionSetParametersOperation>,
        ) -> Self {
            self.set_parameters_operation = input;
            self
        }
        /// Consumes the builder and constructs a [`VisualCustomActionOperation`](crate::model::VisualCustomActionOperation).
        pub fn build(self) -> crate::model::VisualCustomActionOperation {
            crate::model::VisualCustomActionOperation {
                filter_operation: self.filter_operation,
                navigation_operation: self.navigation_operation,
                url_operation: self.url_operation,
                set_parameters_operation: self.set_parameters_operation,
            }
        }
    }
}
impl VisualCustomActionOperation {
    /// Creates a new builder-style object to manufacture [`VisualCustomActionOperation`](crate::model::VisualCustomActionOperation).
    pub fn builder() -> crate::model::visual_custom_action_operation::Builder {
        crate::model::visual_custom_action_operation::Builder::default()
    }
}

/// <p>The set parameter operation that sets parameters in custom action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomActionSetParametersOperation {
    /// <p>The parameter that determines the value configuration.</p>
    #[doc(hidden)]
    pub parameter_value_configurations:
        std::option::Option<std::vec::Vec<crate::model::SetParameterValueConfiguration>>,
}
impl CustomActionSetParametersOperation {
    /// <p>The parameter that determines the value configuration.</p>
    pub fn parameter_value_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::SetParameterValueConfiguration]> {
        self.parameter_value_configurations.as_deref()
    }
}
/// See [`CustomActionSetParametersOperation`](crate::model::CustomActionSetParametersOperation).
pub mod custom_action_set_parameters_operation {

    /// A builder for [`CustomActionSetParametersOperation`](crate::model::CustomActionSetParametersOperation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_value_configurations:
            std::option::Option<std::vec::Vec<crate::model::SetParameterValueConfiguration>>,
    }
    impl Builder {
        /// Appends an item to `parameter_value_configurations`.
        ///
        /// To override the contents of this collection use [`set_parameter_value_configurations`](Self::set_parameter_value_configurations).
        ///
        /// <p>The parameter that determines the value configuration.</p>
        pub fn parameter_value_configurations(
            mut self,
            input: crate::model::SetParameterValueConfiguration,
        ) -> Self {
            let mut v = self.parameter_value_configurations.unwrap_or_default();
            v.push(input);
            self.parameter_value_configurations = Some(v);
            self
        }
        /// <p>The parameter that determines the value configuration.</p>
        pub fn set_parameter_value_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SetParameterValueConfiguration>>,
        ) -> Self {
            self.parameter_value_configurations = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomActionSetParametersOperation`](crate::model::CustomActionSetParametersOperation).
        pub fn build(self) -> crate::model::CustomActionSetParametersOperation {
            crate::model::CustomActionSetParametersOperation {
                parameter_value_configurations: self.parameter_value_configurations,
            }
        }
    }
}
impl CustomActionSetParametersOperation {
    /// Creates a new builder-style object to manufacture [`CustomActionSetParametersOperation`](crate::model::CustomActionSetParametersOperation).
    pub fn builder() -> crate::model::custom_action_set_parameters_operation::Builder {
        crate::model::custom_action_set_parameters_operation::Builder::default()
    }
}

/// <p>The configuration of adding parameters in action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SetParameterValueConfiguration {
    /// <p>The destination parameter name of the <code>SetParameterValueConfiguration</code>.</p>
    #[doc(hidden)]
    pub destination_parameter_name: std::option::Option<std::string::String>,
    /// <p>The configuration of destination parameter values.</p>
    /// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::DestinationParameterValueConfiguration>,
}
impl SetParameterValueConfiguration {
    /// <p>The destination parameter name of the <code>SetParameterValueConfiguration</code>.</p>
    pub fn destination_parameter_name(&self) -> std::option::Option<&str> {
        self.destination_parameter_name.as_deref()
    }
    /// <p>The configuration of destination parameter values.</p>
    /// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
    pub fn value(
        &self,
    ) -> std::option::Option<&crate::model::DestinationParameterValueConfiguration> {
        self.value.as_ref()
    }
}
/// See [`SetParameterValueConfiguration`](crate::model::SetParameterValueConfiguration).
pub mod set_parameter_value_configuration {

    /// A builder for [`SetParameterValueConfiguration`](crate::model::SetParameterValueConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_parameter_name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<crate::model::DestinationParameterValueConfiguration>,
    }
    impl Builder {
        /// <p>The destination parameter name of the <code>SetParameterValueConfiguration</code>.</p>
        pub fn destination_parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_parameter_name = Some(input.into());
            self
        }
        /// <p>The destination parameter name of the <code>SetParameterValueConfiguration</code>.</p>
        pub fn set_destination_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_parameter_name = input;
            self
        }
        /// <p>The configuration of destination parameter values.</p>
        /// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
        pub fn value(
            mut self,
            input: crate::model::DestinationParameterValueConfiguration,
        ) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The configuration of destination parameter values.</p>
        /// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
        pub fn set_value(
            mut self,
            input: std::option::Option<crate::model::DestinationParameterValueConfiguration>,
        ) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`SetParameterValueConfiguration`](crate::model::SetParameterValueConfiguration).
        pub fn build(self) -> crate::model::SetParameterValueConfiguration {
            crate::model::SetParameterValueConfiguration {
                destination_parameter_name: self.destination_parameter_name,
                value: self.value,
            }
        }
    }
}
impl SetParameterValueConfiguration {
    /// Creates a new builder-style object to manufacture [`SetParameterValueConfiguration`](crate::model::SetParameterValueConfiguration).
    pub fn builder() -> crate::model::set_parameter_value_configuration::Builder {
        crate::model::set_parameter_value_configuration::Builder::default()
    }
}

/// <p>The configuration of destination parameter values.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DestinationParameterValueConfiguration {
    /// <p>The configuration of custom values for destination parameter in <code>DestinationParameterValueConfiguration</code>.</p>
    #[doc(hidden)]
    pub custom_values_configuration: std::option::Option<crate::model::CustomValuesConfiguration>,
    /// <p>The configuration that selects all options.</p>
    #[doc(hidden)]
    pub select_all_value_options: std::option::Option<crate::model::SelectAllValueOptions>,
    /// <p>The source parameter name of the destination parameter.</p>
    #[doc(hidden)]
    pub source_parameter_name: std::option::Option<std::string::String>,
    /// <p>The source field ID of the destination parameter.</p>
    #[doc(hidden)]
    pub source_field: std::option::Option<std::string::String>,
}
impl DestinationParameterValueConfiguration {
    /// <p>The configuration of custom values for destination parameter in <code>DestinationParameterValueConfiguration</code>.</p>
    pub fn custom_values_configuration(
        &self,
    ) -> std::option::Option<&crate::model::CustomValuesConfiguration> {
        self.custom_values_configuration.as_ref()
    }
    /// <p>The configuration that selects all options.</p>
    pub fn select_all_value_options(
        &self,
    ) -> std::option::Option<&crate::model::SelectAllValueOptions> {
        self.select_all_value_options.as_ref()
    }
    /// <p>The source parameter name of the destination parameter.</p>
    pub fn source_parameter_name(&self) -> std::option::Option<&str> {
        self.source_parameter_name.as_deref()
    }
    /// <p>The source field ID of the destination parameter.</p>
    pub fn source_field(&self) -> std::option::Option<&str> {
        self.source_field.as_deref()
    }
}
/// See [`DestinationParameterValueConfiguration`](crate::model::DestinationParameterValueConfiguration).
pub mod destination_parameter_value_configuration {

    /// A builder for [`DestinationParameterValueConfiguration`](crate::model::DestinationParameterValueConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) custom_values_configuration:
            std::option::Option<crate::model::CustomValuesConfiguration>,
        pub(crate) select_all_value_options:
            std::option::Option<crate::model::SelectAllValueOptions>,
        pub(crate) source_parameter_name: std::option::Option<std::string::String>,
        pub(crate) source_field: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The configuration of custom values for destination parameter in <code>DestinationParameterValueConfiguration</code>.</p>
        pub fn custom_values_configuration(
            mut self,
            input: crate::model::CustomValuesConfiguration,
        ) -> Self {
            self.custom_values_configuration = Some(input);
            self
        }
        /// <p>The configuration of custom values for destination parameter in <code>DestinationParameterValueConfiguration</code>.</p>
        pub fn set_custom_values_configuration(
            mut self,
            input: std::option::Option<crate::model::CustomValuesConfiguration>,
        ) -> Self {
            self.custom_values_configuration = input;
            self
        }
        /// <p>The configuration that selects all options.</p>
        pub fn select_all_value_options(
            mut self,
            input: crate::model::SelectAllValueOptions,
        ) -> Self {
            self.select_all_value_options = Some(input);
            self
        }
        /// <p>The configuration that selects all options.</p>
        pub fn set_select_all_value_options(
            mut self,
            input: std::option::Option<crate::model::SelectAllValueOptions>,
        ) -> Self {
            self.select_all_value_options = input;
            self
        }
        /// <p>The source parameter name of the destination parameter.</p>
        pub fn source_parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_parameter_name = Some(input.into());
            self
        }
        /// <p>The source parameter name of the destination parameter.</p>
        pub fn set_source_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_parameter_name = input;
            self
        }
        /// <p>The source field ID of the destination parameter.</p>
        pub fn source_field(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_field = Some(input.into());
            self
        }
        /// <p>The source field ID of the destination parameter.</p>
        pub fn set_source_field(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_field = input;
            self
        }
        /// Consumes the builder and constructs a [`DestinationParameterValueConfiguration`](crate::model::DestinationParameterValueConfiguration).
        pub fn build(self) -> crate::model::DestinationParameterValueConfiguration {
            crate::model::DestinationParameterValueConfiguration {
                custom_values_configuration: self.custom_values_configuration,
                select_all_value_options: self.select_all_value_options,
                source_parameter_name: self.source_parameter_name,
                source_field: self.source_field,
            }
        }
    }
}
impl DestinationParameterValueConfiguration {
    /// Creates a new builder-style object to manufacture [`DestinationParameterValueConfiguration`](crate::model::DestinationParameterValueConfiguration).
    pub fn builder() -> crate::model::destination_parameter_value_configuration::Builder {
        crate::model::destination_parameter_value_configuration::Builder::default()
    }
}

/// When writing a match expression against `SelectAllValueOptions`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let selectallvalueoptions = unimplemented!();
/// match selectallvalueoptions {
///     SelectAllValueOptions::AllValues => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `selectallvalueoptions` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SelectAllValueOptions::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SelectAllValueOptions::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SelectAllValueOptions::NewFeature` is defined.
/// Specifically, when `selectallvalueoptions` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SelectAllValueOptions::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SelectAllValueOptions {
    #[allow(missing_docs)] // documentation missing in model
    AllValues,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SelectAllValueOptions {
    fn from(s: &str) -> Self {
        match s {
            "ALL_VALUES" => SelectAllValueOptions::AllValues,
            other => {
                SelectAllValueOptions::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SelectAllValueOptions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SelectAllValueOptions::from(s))
    }
}
impl SelectAllValueOptions {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SelectAllValueOptions::AllValues => "ALL_VALUES",
            SelectAllValueOptions::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL_VALUES"]
    }
}
impl AsRef<str> for SelectAllValueOptions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration of custom values for the destination parameter in <code>DestinationParameterValueConfiguration</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomValuesConfiguration {
    /// <p>Includes the null value in custom action parameter values.</p>
    #[doc(hidden)]
    pub include_null_value: std::option::Option<bool>,
    /// <p>The customized parameter values.</p>
    /// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
    #[doc(hidden)]
    pub custom_values: std::option::Option<crate::model::CustomParameterValues>,
}
impl CustomValuesConfiguration {
    /// <p>Includes the null value in custom action parameter values.</p>
    pub fn include_null_value(&self) -> std::option::Option<bool> {
        self.include_null_value
    }
    /// <p>The customized parameter values.</p>
    /// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
    pub fn custom_values(&self) -> std::option::Option<&crate::model::CustomParameterValues> {
        self.custom_values.as_ref()
    }
}
/// See [`CustomValuesConfiguration`](crate::model::CustomValuesConfiguration).
pub mod custom_values_configuration {

    /// A builder for [`CustomValuesConfiguration`](crate::model::CustomValuesConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) include_null_value: std::option::Option<bool>,
        pub(crate) custom_values: std::option::Option<crate::model::CustomParameterValues>,
    }
    impl Builder {
        /// <p>Includes the null value in custom action parameter values.</p>
        pub fn include_null_value(mut self, input: bool) -> Self {
            self.include_null_value = Some(input);
            self
        }
        /// <p>Includes the null value in custom action parameter values.</p>
        pub fn set_include_null_value(mut self, input: std::option::Option<bool>) -> Self {
            self.include_null_value = input;
            self
        }
        /// <p>The customized parameter values.</p>
        /// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
        pub fn custom_values(mut self, input: crate::model::CustomParameterValues) -> Self {
            self.custom_values = Some(input);
            self
        }
        /// <p>The customized parameter values.</p>
        /// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
        pub fn set_custom_values(
            mut self,
            input: std::option::Option<crate::model::CustomParameterValues>,
        ) -> Self {
            self.custom_values = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomValuesConfiguration`](crate::model::CustomValuesConfiguration).
        pub fn build(self) -> crate::model::CustomValuesConfiguration {
            crate::model::CustomValuesConfiguration {
                include_null_value: self.include_null_value,
                custom_values: self.custom_values,
            }
        }
    }
}
impl CustomValuesConfiguration {
    /// Creates a new builder-style object to manufacture [`CustomValuesConfiguration`](crate::model::CustomValuesConfiguration).
    pub fn builder() -> crate::model::custom_values_configuration::Builder {
        crate::model::custom_values_configuration::Builder::default()
    }
}

/// <p>The customized parameter values.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomParameterValues {
    /// <p>A list of string-type parameter values.</p>
    #[doc(hidden)]
    pub string_values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of integer-type parameter values.</p>
    #[doc(hidden)]
    pub integer_values: std::option::Option<std::vec::Vec<i64>>,
    /// <p>A list of decimal-type parameter values.</p>
    #[doc(hidden)]
    pub decimal_values: std::option::Option<std::vec::Vec<f64>>,
    /// <p>A list of datetime-type parameter values.</p>
    #[doc(hidden)]
    pub date_time_values: std::option::Option<std::vec::Vec<aws_smithy_types::DateTime>>,
}
impl CustomParameterValues {
    /// <p>A list of string-type parameter values.</p>
    pub fn string_values(&self) -> std::option::Option<&[std::string::String]> {
        self.string_values.as_deref()
    }
    /// <p>A list of integer-type parameter values.</p>
    pub fn integer_values(&self) -> std::option::Option<&[i64]> {
        self.integer_values.as_deref()
    }
    /// <p>A list of decimal-type parameter values.</p>
    pub fn decimal_values(&self) -> std::option::Option<&[f64]> {
        self.decimal_values.as_deref()
    }
    /// <p>A list of datetime-type parameter values.</p>
    pub fn date_time_values(&self) -> std::option::Option<&[aws_smithy_types::DateTime]> {
        self.date_time_values.as_deref()
    }
}
/// See [`CustomParameterValues`](crate::model::CustomParameterValues).
pub mod custom_parameter_values {

    /// A builder for [`CustomParameterValues`](crate::model::CustomParameterValues).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) string_values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) integer_values: std::option::Option<std::vec::Vec<i64>>,
        pub(crate) decimal_values: std::option::Option<std::vec::Vec<f64>>,
        pub(crate) date_time_values: std::option::Option<std::vec::Vec<aws_smithy_types::DateTime>>,
    }
    impl Builder {
        /// Appends an item to `string_values`.
        ///
        /// To override the contents of this collection use [`set_string_values`](Self::set_string_values).
        ///
        /// <p>A list of string-type parameter values.</p>
        pub fn string_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.string_values.unwrap_or_default();
            v.push(input.into());
            self.string_values = Some(v);
            self
        }
        /// <p>A list of string-type parameter values.</p>
        pub fn set_string_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.string_values = input;
            self
        }
        /// Appends an item to `integer_values`.
        ///
        /// To override the contents of this collection use [`set_integer_values`](Self::set_integer_values).
        ///
        /// <p>A list of integer-type parameter values.</p>
        pub fn integer_values(mut self, input: i64) -> Self {
            let mut v = self.integer_values.unwrap_or_default();
            v.push(input);
            self.integer_values = Some(v);
            self
        }
        /// <p>A list of integer-type parameter values.</p>
        pub fn set_integer_values(
            mut self,
            input: std::option::Option<std::vec::Vec<i64>>,
        ) -> Self {
            self.integer_values = input;
            self
        }
        /// Appends an item to `decimal_values`.
        ///
        /// To override the contents of this collection use [`set_decimal_values`](Self::set_decimal_values).
        ///
        /// <p>A list of decimal-type parameter values.</p>
        pub fn decimal_values(mut self, input: f64) -> Self {
            let mut v = self.decimal_values.unwrap_or_default();
            v.push(input);
            self.decimal_values = Some(v);
            self
        }
        /// <p>A list of decimal-type parameter values.</p>
        pub fn set_decimal_values(
            mut self,
            input: std::option::Option<std::vec::Vec<f64>>,
        ) -> Self {
            self.decimal_values = input;
            self
        }
        /// Appends an item to `date_time_values`.
        ///
        /// To override the contents of this collection use [`set_date_time_values`](Self::set_date_time_values).
        ///
        /// <p>A list of datetime-type parameter values.</p>
        pub fn date_time_values(mut self, input: aws_smithy_types::DateTime) -> Self {
            let mut v = self.date_time_values.unwrap_or_default();
            v.push(input);
            self.date_time_values = Some(v);
            self
        }
        /// <p>A list of datetime-type parameter values.</p>
        pub fn set_date_time_values(
            mut self,
            input: std::option::Option<std::vec::Vec<aws_smithy_types::DateTime>>,
        ) -> Self {
            self.date_time_values = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomParameterValues`](crate::model::CustomParameterValues).
        pub fn build(self) -> crate::model::CustomParameterValues {
            crate::model::CustomParameterValues {
                string_values: self.string_values,
                integer_values: self.integer_values,
                decimal_values: self.decimal_values,
                date_time_values: self.date_time_values,
            }
        }
    }
}
impl CustomParameterValues {
    /// Creates a new builder-style object to manufacture [`CustomParameterValues`](crate::model::CustomParameterValues).
    pub fn builder() -> crate::model::custom_parameter_values::Builder {
        crate::model::custom_parameter_values::Builder::default()
    }
}

/// <p>The URL operation that opens a link to another webpage.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomActionUrlOperation {
    /// <p>THe URL link of the <code>CustomActionURLOperation</code>.</p>
    #[doc(hidden)]
    pub url_template: std::option::Option<std::string::String>,
    /// <p>The target of the <code>CustomActionURLOperation</code>.</p>
    /// <p>Valid values are defined as follows:</p>
    /// <ul>
    /// <li> <p> <code>NEW_TAB</code>: Opens the target URL in a new browser tab.</p> </li>
    /// <li> <p> <code>NEW_WINDOW</code>: Opens the target URL in a new browser window.</p> </li>
    /// <li> <p> <code>SAME_TAB</code>: Opens the target URL in the same browser tab.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub url_target: std::option::Option<crate::model::UrlTargetConfiguration>,
}
impl CustomActionUrlOperation {
    /// <p>THe URL link of the <code>CustomActionURLOperation</code>.</p>
    pub fn url_template(&self) -> std::option::Option<&str> {
        self.url_template.as_deref()
    }
    /// <p>The target of the <code>CustomActionURLOperation</code>.</p>
    /// <p>Valid values are defined as follows:</p>
    /// <ul>
    /// <li> <p> <code>NEW_TAB</code>: Opens the target URL in a new browser tab.</p> </li>
    /// <li> <p> <code>NEW_WINDOW</code>: Opens the target URL in a new browser window.</p> </li>
    /// <li> <p> <code>SAME_TAB</code>: Opens the target URL in the same browser tab.</p> </li>
    /// </ul>
    pub fn url_target(&self) -> std::option::Option<&crate::model::UrlTargetConfiguration> {
        self.url_target.as_ref()
    }
}
/// See [`CustomActionUrlOperation`](crate::model::CustomActionUrlOperation).
pub mod custom_action_url_operation {

    /// A builder for [`CustomActionUrlOperation`](crate::model::CustomActionUrlOperation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) url_template: std::option::Option<std::string::String>,
        pub(crate) url_target: std::option::Option<crate::model::UrlTargetConfiguration>,
    }
    impl Builder {
        /// <p>THe URL link of the <code>CustomActionURLOperation</code>.</p>
        pub fn url_template(mut self, input: impl Into<std::string::String>) -> Self {
            self.url_template = Some(input.into());
            self
        }
        /// <p>THe URL link of the <code>CustomActionURLOperation</code>.</p>
        pub fn set_url_template(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url_template = input;
            self
        }
        /// <p>The target of the <code>CustomActionURLOperation</code>.</p>
        /// <p>Valid values are defined as follows:</p>
        /// <ul>
        /// <li> <p> <code>NEW_TAB</code>: Opens the target URL in a new browser tab.</p> </li>
        /// <li> <p> <code>NEW_WINDOW</code>: Opens the target URL in a new browser window.</p> </li>
        /// <li> <p> <code>SAME_TAB</code>: Opens the target URL in the same browser tab.</p> </li>
        /// </ul>
        pub fn url_target(mut self, input: crate::model::UrlTargetConfiguration) -> Self {
            self.url_target = Some(input);
            self
        }
        /// <p>The target of the <code>CustomActionURLOperation</code>.</p>
        /// <p>Valid values are defined as follows:</p>
        /// <ul>
        /// <li> <p> <code>NEW_TAB</code>: Opens the target URL in a new browser tab.</p> </li>
        /// <li> <p> <code>NEW_WINDOW</code>: Opens the target URL in a new browser window.</p> </li>
        /// <li> <p> <code>SAME_TAB</code>: Opens the target URL in the same browser tab.</p> </li>
        /// </ul>
        pub fn set_url_target(
            mut self,
            input: std::option::Option<crate::model::UrlTargetConfiguration>,
        ) -> Self {
            self.url_target = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomActionUrlOperation`](crate::model::CustomActionUrlOperation).
        pub fn build(self) -> crate::model::CustomActionUrlOperation {
            crate::model::CustomActionUrlOperation {
                url_template: self.url_template,
                url_target: self.url_target,
            }
        }
    }
}
impl CustomActionUrlOperation {
    /// Creates a new builder-style object to manufacture [`CustomActionUrlOperation`](crate::model::CustomActionUrlOperation).
    pub fn builder() -> crate::model::custom_action_url_operation::Builder {
        crate::model::custom_action_url_operation::Builder::default()
    }
}

/// When writing a match expression against `UrlTargetConfiguration`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let urltargetconfiguration = unimplemented!();
/// match urltargetconfiguration {
///     UrlTargetConfiguration::NewTab => { /* ... */ },
///     UrlTargetConfiguration::NewWindow => { /* ... */ },
///     UrlTargetConfiguration::SameTab => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `urltargetconfiguration` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UrlTargetConfiguration::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UrlTargetConfiguration::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UrlTargetConfiguration::NewFeature` is defined.
/// Specifically, when `urltargetconfiguration` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UrlTargetConfiguration::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UrlTargetConfiguration {
    #[allow(missing_docs)] // documentation missing in model
    NewTab,
    #[allow(missing_docs)] // documentation missing in model
    NewWindow,
    #[allow(missing_docs)] // documentation missing in model
    SameTab,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UrlTargetConfiguration {
    fn from(s: &str) -> Self {
        match s {
            "NEW_TAB" => UrlTargetConfiguration::NewTab,
            "NEW_WINDOW" => UrlTargetConfiguration::NewWindow,
            "SAME_TAB" => UrlTargetConfiguration::SameTab,
            other => {
                UrlTargetConfiguration::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for UrlTargetConfiguration {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UrlTargetConfiguration::from(s))
    }
}
impl UrlTargetConfiguration {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UrlTargetConfiguration::NewTab => "NEW_TAB",
            UrlTargetConfiguration::NewWindow => "NEW_WINDOW",
            UrlTargetConfiguration::SameTab => "SAME_TAB",
            UrlTargetConfiguration::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NEW_TAB", "NEW_WINDOW", "SAME_TAB"]
    }
}
impl AsRef<str> for UrlTargetConfiguration {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The navigation operation that navigates between different sheets in the same analysis.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomActionNavigationOperation {
    /// <p>The configuration that chooses the navigation target.</p>
    #[doc(hidden)]
    pub local_navigation_configuration:
        std::option::Option<crate::model::LocalNavigationConfiguration>,
}
impl CustomActionNavigationOperation {
    /// <p>The configuration that chooses the navigation target.</p>
    pub fn local_navigation_configuration(
        &self,
    ) -> std::option::Option<&crate::model::LocalNavigationConfiguration> {
        self.local_navigation_configuration.as_ref()
    }
}
/// See [`CustomActionNavigationOperation`](crate::model::CustomActionNavigationOperation).
pub mod custom_action_navigation_operation {

    /// A builder for [`CustomActionNavigationOperation`](crate::model::CustomActionNavigationOperation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) local_navigation_configuration:
            std::option::Option<crate::model::LocalNavigationConfiguration>,
    }
    impl Builder {
        /// <p>The configuration that chooses the navigation target.</p>
        pub fn local_navigation_configuration(
            mut self,
            input: crate::model::LocalNavigationConfiguration,
        ) -> Self {
            self.local_navigation_configuration = Some(input);
            self
        }
        /// <p>The configuration that chooses the navigation target.</p>
        pub fn set_local_navigation_configuration(
            mut self,
            input: std::option::Option<crate::model::LocalNavigationConfiguration>,
        ) -> Self {
            self.local_navigation_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomActionNavigationOperation`](crate::model::CustomActionNavigationOperation).
        pub fn build(self) -> crate::model::CustomActionNavigationOperation {
            crate::model::CustomActionNavigationOperation {
                local_navigation_configuration: self.local_navigation_configuration,
            }
        }
    }
}
impl CustomActionNavigationOperation {
    /// Creates a new builder-style object to manufacture [`CustomActionNavigationOperation`](crate::model::CustomActionNavigationOperation).
    pub fn builder() -> crate::model::custom_action_navigation_operation::Builder {
        crate::model::custom_action_navigation_operation::Builder::default()
    }
}

/// <p>The navigation configuration for <code>CustomActionNavigationOperation</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LocalNavigationConfiguration {
    /// <p>The sheet that is targeted for navigation in the same analysis.</p>
    #[doc(hidden)]
    pub target_sheet_id: std::option::Option<std::string::String>,
}
impl LocalNavigationConfiguration {
    /// <p>The sheet that is targeted for navigation in the same analysis.</p>
    pub fn target_sheet_id(&self) -> std::option::Option<&str> {
        self.target_sheet_id.as_deref()
    }
}
/// See [`LocalNavigationConfiguration`](crate::model::LocalNavigationConfiguration).
pub mod local_navigation_configuration {

    /// A builder for [`LocalNavigationConfiguration`](crate::model::LocalNavigationConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_sheet_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The sheet that is targeted for navigation in the same analysis.</p>
        pub fn target_sheet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_sheet_id = Some(input.into());
            self
        }
        /// <p>The sheet that is targeted for navigation in the same analysis.</p>
        pub fn set_target_sheet_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_sheet_id = input;
            self
        }
        /// Consumes the builder and constructs a [`LocalNavigationConfiguration`](crate::model::LocalNavigationConfiguration).
        pub fn build(self) -> crate::model::LocalNavigationConfiguration {
            crate::model::LocalNavigationConfiguration {
                target_sheet_id: self.target_sheet_id,
            }
        }
    }
}
impl LocalNavigationConfiguration {
    /// Creates a new builder-style object to manufacture [`LocalNavigationConfiguration`](crate::model::LocalNavigationConfiguration).
    pub fn builder() -> crate::model::local_navigation_configuration::Builder {
        crate::model::local_navigation_configuration::Builder::default()
    }
}

/// <p>The filter operation that filters data included in a visual or in an entire sheet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomActionFilterOperation {
    /// <p>The configuration that chooses the fields to be filtered.</p>
    #[doc(hidden)]
    pub selected_fields_configuration:
        std::option::Option<crate::model::FilterOperationSelectedFieldsConfiguration>,
    /// <p>The configuration that chooses the target visuals to be filtered.</p>
    #[doc(hidden)]
    pub target_visuals_configuration:
        std::option::Option<crate::model::FilterOperationTargetVisualsConfiguration>,
}
impl CustomActionFilterOperation {
    /// <p>The configuration that chooses the fields to be filtered.</p>
    pub fn selected_fields_configuration(
        &self,
    ) -> std::option::Option<&crate::model::FilterOperationSelectedFieldsConfiguration> {
        self.selected_fields_configuration.as_ref()
    }
    /// <p>The configuration that chooses the target visuals to be filtered.</p>
    pub fn target_visuals_configuration(
        &self,
    ) -> std::option::Option<&crate::model::FilterOperationTargetVisualsConfiguration> {
        self.target_visuals_configuration.as_ref()
    }
}
/// See [`CustomActionFilterOperation`](crate::model::CustomActionFilterOperation).
pub mod custom_action_filter_operation {

    /// A builder for [`CustomActionFilterOperation`](crate::model::CustomActionFilterOperation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) selected_fields_configuration:
            std::option::Option<crate::model::FilterOperationSelectedFieldsConfiguration>,
        pub(crate) target_visuals_configuration:
            std::option::Option<crate::model::FilterOperationTargetVisualsConfiguration>,
    }
    impl Builder {
        /// <p>The configuration that chooses the fields to be filtered.</p>
        pub fn selected_fields_configuration(
            mut self,
            input: crate::model::FilterOperationSelectedFieldsConfiguration,
        ) -> Self {
            self.selected_fields_configuration = Some(input);
            self
        }
        /// <p>The configuration that chooses the fields to be filtered.</p>
        pub fn set_selected_fields_configuration(
            mut self,
            input: std::option::Option<crate::model::FilterOperationSelectedFieldsConfiguration>,
        ) -> Self {
            self.selected_fields_configuration = input;
            self
        }
        /// <p>The configuration that chooses the target visuals to be filtered.</p>
        pub fn target_visuals_configuration(
            mut self,
            input: crate::model::FilterOperationTargetVisualsConfiguration,
        ) -> Self {
            self.target_visuals_configuration = Some(input);
            self
        }
        /// <p>The configuration that chooses the target visuals to be filtered.</p>
        pub fn set_target_visuals_configuration(
            mut self,
            input: std::option::Option<crate::model::FilterOperationTargetVisualsConfiguration>,
        ) -> Self {
            self.target_visuals_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomActionFilterOperation`](crate::model::CustomActionFilterOperation).
        pub fn build(self) -> crate::model::CustomActionFilterOperation {
            crate::model::CustomActionFilterOperation {
                selected_fields_configuration: self.selected_fields_configuration,
                target_visuals_configuration: self.target_visuals_configuration,
            }
        }
    }
}
impl CustomActionFilterOperation {
    /// Creates a new builder-style object to manufacture [`CustomActionFilterOperation`](crate::model::CustomActionFilterOperation).
    pub fn builder() -> crate::model::custom_action_filter_operation::Builder {
        crate::model::custom_action_filter_operation::Builder::default()
    }
}

/// <p>The configuration of target visuals that you want to be filtered.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterOperationTargetVisualsConfiguration {
    /// <p>The configuration of the same-sheet target visuals that you want to be filtered.</p>
    #[doc(hidden)]
    pub same_sheet_target_visual_configuration:
        std::option::Option<crate::model::SameSheetTargetVisualConfiguration>,
}
impl FilterOperationTargetVisualsConfiguration {
    /// <p>The configuration of the same-sheet target visuals that you want to be filtered.</p>
    pub fn same_sheet_target_visual_configuration(
        &self,
    ) -> std::option::Option<&crate::model::SameSheetTargetVisualConfiguration> {
        self.same_sheet_target_visual_configuration.as_ref()
    }
}
/// See [`FilterOperationTargetVisualsConfiguration`](crate::model::FilterOperationTargetVisualsConfiguration).
pub mod filter_operation_target_visuals_configuration {

    /// A builder for [`FilterOperationTargetVisualsConfiguration`](crate::model::FilterOperationTargetVisualsConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) same_sheet_target_visual_configuration:
            std::option::Option<crate::model::SameSheetTargetVisualConfiguration>,
    }
    impl Builder {
        /// <p>The configuration of the same-sheet target visuals that you want to be filtered.</p>
        pub fn same_sheet_target_visual_configuration(
            mut self,
            input: crate::model::SameSheetTargetVisualConfiguration,
        ) -> Self {
            self.same_sheet_target_visual_configuration = Some(input);
            self
        }
        /// <p>The configuration of the same-sheet target visuals that you want to be filtered.</p>
        pub fn set_same_sheet_target_visual_configuration(
            mut self,
            input: std::option::Option<crate::model::SameSheetTargetVisualConfiguration>,
        ) -> Self {
            self.same_sheet_target_visual_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterOperationTargetVisualsConfiguration`](crate::model::FilterOperationTargetVisualsConfiguration).
        pub fn build(self) -> crate::model::FilterOperationTargetVisualsConfiguration {
            crate::model::FilterOperationTargetVisualsConfiguration {
                same_sheet_target_visual_configuration: self.same_sheet_target_visual_configuration,
            }
        }
    }
}
impl FilterOperationTargetVisualsConfiguration {
    /// Creates a new builder-style object to manufacture [`FilterOperationTargetVisualsConfiguration`](crate::model::FilterOperationTargetVisualsConfiguration).
    pub fn builder() -> crate::model::filter_operation_target_visuals_configuration::Builder {
        crate::model::filter_operation_target_visuals_configuration::Builder::default()
    }
}

/// <p>The configuration of the same-sheet target visuals that you want to be filtered.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SameSheetTargetVisualConfiguration {
    /// <p>A list of the target visual IDs that are located in the same sheet of the analysis.</p>
    #[doc(hidden)]
    pub target_visuals: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The options that choose the target visual in the same sheet.</p>
    /// <p>Valid values are defined as follows:</p>
    /// <ul>
    /// <li> <p> <code>ALL_VISUALS</code>: Applies the filter operation to all visuals in the same sheet.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub target_visual_options: std::option::Option<crate::model::TargetVisualOptions>,
}
impl SameSheetTargetVisualConfiguration {
    /// <p>A list of the target visual IDs that are located in the same sheet of the analysis.</p>
    pub fn target_visuals(&self) -> std::option::Option<&[std::string::String]> {
        self.target_visuals.as_deref()
    }
    /// <p>The options that choose the target visual in the same sheet.</p>
    /// <p>Valid values are defined as follows:</p>
    /// <ul>
    /// <li> <p> <code>ALL_VISUALS</code>: Applies the filter operation to all visuals in the same sheet.</p> </li>
    /// </ul>
    pub fn target_visual_options(&self) -> std::option::Option<&crate::model::TargetVisualOptions> {
        self.target_visual_options.as_ref()
    }
}
/// See [`SameSheetTargetVisualConfiguration`](crate::model::SameSheetTargetVisualConfiguration).
pub mod same_sheet_target_visual_configuration {

    /// A builder for [`SameSheetTargetVisualConfiguration`](crate::model::SameSheetTargetVisualConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_visuals: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) target_visual_options: std::option::Option<crate::model::TargetVisualOptions>,
    }
    impl Builder {
        /// Appends an item to `target_visuals`.
        ///
        /// To override the contents of this collection use [`set_target_visuals`](Self::set_target_visuals).
        ///
        /// <p>A list of the target visual IDs that are located in the same sheet of the analysis.</p>
        pub fn target_visuals(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_visuals.unwrap_or_default();
            v.push(input.into());
            self.target_visuals = Some(v);
            self
        }
        /// <p>A list of the target visual IDs that are located in the same sheet of the analysis.</p>
        pub fn set_target_visuals(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_visuals = input;
            self
        }
        /// <p>The options that choose the target visual in the same sheet.</p>
        /// <p>Valid values are defined as follows:</p>
        /// <ul>
        /// <li> <p> <code>ALL_VISUALS</code>: Applies the filter operation to all visuals in the same sheet.</p> </li>
        /// </ul>
        pub fn target_visual_options(mut self, input: crate::model::TargetVisualOptions) -> Self {
            self.target_visual_options = Some(input);
            self
        }
        /// <p>The options that choose the target visual in the same sheet.</p>
        /// <p>Valid values are defined as follows:</p>
        /// <ul>
        /// <li> <p> <code>ALL_VISUALS</code>: Applies the filter operation to all visuals in the same sheet.</p> </li>
        /// </ul>
        pub fn set_target_visual_options(
            mut self,
            input: std::option::Option<crate::model::TargetVisualOptions>,
        ) -> Self {
            self.target_visual_options = input;
            self
        }
        /// Consumes the builder and constructs a [`SameSheetTargetVisualConfiguration`](crate::model::SameSheetTargetVisualConfiguration).
        pub fn build(self) -> crate::model::SameSheetTargetVisualConfiguration {
            crate::model::SameSheetTargetVisualConfiguration {
                target_visuals: self.target_visuals,
                target_visual_options: self.target_visual_options,
            }
        }
    }
}
impl SameSheetTargetVisualConfiguration {
    /// Creates a new builder-style object to manufacture [`SameSheetTargetVisualConfiguration`](crate::model::SameSheetTargetVisualConfiguration).
    pub fn builder() -> crate::model::same_sheet_target_visual_configuration::Builder {
        crate::model::same_sheet_target_visual_configuration::Builder::default()
    }
}

/// When writing a match expression against `TargetVisualOptions`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let targetvisualoptions = unimplemented!();
/// match targetvisualoptions {
///     TargetVisualOptions::AllVisuals => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `targetvisualoptions` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TargetVisualOptions::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TargetVisualOptions::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TargetVisualOptions::NewFeature` is defined.
/// Specifically, when `targetvisualoptions` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TargetVisualOptions::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetVisualOptions {
    #[allow(missing_docs)] // documentation missing in model
    AllVisuals,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TargetVisualOptions {
    fn from(s: &str) -> Self {
        match s {
            "ALL_VISUALS" => TargetVisualOptions::AllVisuals,
            other => {
                TargetVisualOptions::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TargetVisualOptions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetVisualOptions::from(s))
    }
}
impl TargetVisualOptions {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TargetVisualOptions::AllVisuals => "ALL_VISUALS",
            TargetVisualOptions::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL_VISUALS"]
    }
}
impl AsRef<str> for TargetVisualOptions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration of selected fields in the<code>CustomActionFilterOperation</code>.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterOperationSelectedFieldsConfiguration {
    /// <p>Chooses the fields that are filtered in <code>CustomActionFilterOperation</code>.</p>
    #[doc(hidden)]
    pub selected_fields: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A structure that contains the options that choose which fields are filtered in the <code>CustomActionFilterOperation</code>.</p>
    /// <p>Valid values are defined as follows:</p>
    /// <ul>
    /// <li> <p> <code>ALL_FIELDS</code>: Applies the filter operation to all fields.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub selected_field_options: std::option::Option<crate::model::SelectedFieldOptions>,
}
impl FilterOperationSelectedFieldsConfiguration {
    /// <p>Chooses the fields that are filtered in <code>CustomActionFilterOperation</code>.</p>
    pub fn selected_fields(&self) -> std::option::Option<&[std::string::String]> {
        self.selected_fields.as_deref()
    }
    /// <p>A structure that contains the options that choose which fields are filtered in the <code>CustomActionFilterOperation</code>.</p>
    /// <p>Valid values are defined as follows:</p>
    /// <ul>
    /// <li> <p> <code>ALL_FIELDS</code>: Applies the filter operation to all fields.</p> </li>
    /// </ul>
    pub fn selected_field_options(
        &self,
    ) -> std::option::Option<&crate::model::SelectedFieldOptions> {
        self.selected_field_options.as_ref()
    }
}
/// See [`FilterOperationSelectedFieldsConfiguration`](crate::model::FilterOperationSelectedFieldsConfiguration).
pub mod filter_operation_selected_fields_configuration {

    /// A builder for [`FilterOperationSelectedFieldsConfiguration`](crate::model::FilterOperationSelectedFieldsConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) selected_fields: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) selected_field_options: std::option::Option<crate::model::SelectedFieldOptions>,
    }
    impl Builder {
        /// Appends an item to `selected_fields`.
        ///
        /// To override the contents of this collection use [`set_selected_fields`](Self::set_selected_fields).
        ///
        /// <p>Chooses the fields that are filtered in <code>CustomActionFilterOperation</code>.</p>
        pub fn selected_fields(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.selected_fields.unwrap_or_default();
            v.push(input.into());
            self.selected_fields = Some(v);
            self
        }
        /// <p>Chooses the fields that are filtered in <code>CustomActionFilterOperation</code>.</p>
        pub fn set_selected_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.selected_fields = input;
            self
        }
        /// <p>A structure that contains the options that choose which fields are filtered in the <code>CustomActionFilterOperation</code>.</p>
        /// <p>Valid values are defined as follows:</p>
        /// <ul>
        /// <li> <p> <code>ALL_FIELDS</code>: Applies the filter operation to all fields.</p> </li>
        /// </ul>
        pub fn selected_field_options(mut self, input: crate::model::SelectedFieldOptions) -> Self {
            self.selected_field_options = Some(input);
            self
        }
        /// <p>A structure that contains the options that choose which fields are filtered in the <code>CustomActionFilterOperation</code>.</p>
        /// <p>Valid values are defined as follows:</p>
        /// <ul>
        /// <li> <p> <code>ALL_FIELDS</code>: Applies the filter operation to all fields.</p> </li>
        /// </ul>
        pub fn set_selected_field_options(
            mut self,
            input: std::option::Option<crate::model::SelectedFieldOptions>,
        ) -> Self {
            self.selected_field_options = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterOperationSelectedFieldsConfiguration`](crate::model::FilterOperationSelectedFieldsConfiguration).
        pub fn build(self) -> crate::model::FilterOperationSelectedFieldsConfiguration {
            crate::model::FilterOperationSelectedFieldsConfiguration {
                selected_fields: self.selected_fields,
                selected_field_options: self.selected_field_options,
            }
        }
    }
}
impl FilterOperationSelectedFieldsConfiguration {
    /// Creates a new builder-style object to manufacture [`FilterOperationSelectedFieldsConfiguration`](crate::model::FilterOperationSelectedFieldsConfiguration).
    pub fn builder() -> crate::model::filter_operation_selected_fields_configuration::Builder {
        crate::model::filter_operation_selected_fields_configuration::Builder::default()
    }
}

/// When writing a match expression against `SelectedFieldOptions`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let selectedfieldoptions = unimplemented!();
/// match selectedfieldoptions {
///     SelectedFieldOptions::AllFields => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `selectedfieldoptions` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SelectedFieldOptions::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SelectedFieldOptions::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SelectedFieldOptions::NewFeature` is defined.
/// Specifically, when `selectedfieldoptions` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SelectedFieldOptions::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SelectedFieldOptions {
    #[allow(missing_docs)] // documentation missing in model
    AllFields,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SelectedFieldOptions {
    fn from(s: &str) -> Self {
        match s {
            "ALL_FIELDS" => SelectedFieldOptions::AllFields,
            other => {
                SelectedFieldOptions::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SelectedFieldOptions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SelectedFieldOptions::from(s))
    }
}
impl SelectedFieldOptions {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SelectedFieldOptions::AllFields => "ALL_FIELDS",
            SelectedFieldOptions::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL_FIELDS"]
    }
}
impl AsRef<str> for SelectedFieldOptions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `VisualCustomActionTrigger`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let visualcustomactiontrigger = unimplemented!();
/// match visualcustomactiontrigger {
///     VisualCustomActionTrigger::DataPointClick => { /* ... */ },
///     VisualCustomActionTrigger::DataPointMenu => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `visualcustomactiontrigger` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VisualCustomActionTrigger::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VisualCustomActionTrigger::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VisualCustomActionTrigger::NewFeature` is defined.
/// Specifically, when `visualcustomactiontrigger` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VisualCustomActionTrigger::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VisualCustomActionTrigger {
    #[allow(missing_docs)] // documentation missing in model
    DataPointClick,
    #[allow(missing_docs)] // documentation missing in model
    DataPointMenu,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VisualCustomActionTrigger {
    fn from(s: &str) -> Self {
        match s {
            "DATA_POINT_CLICK" => VisualCustomActionTrigger::DataPointClick,
            "DATA_POINT_MENU" => VisualCustomActionTrigger::DataPointMenu,
            other => VisualCustomActionTrigger::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for VisualCustomActionTrigger {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VisualCustomActionTrigger::from(s))
    }
}
impl VisualCustomActionTrigger {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VisualCustomActionTrigger::DataPointClick => "DATA_POINT_CLICK",
            VisualCustomActionTrigger::DataPointMenu => "DATA_POINT_MENU",
            VisualCustomActionTrigger::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DATA_POINT_CLICK", "DATA_POINT_MENU"]
    }
}
impl AsRef<str> for VisualCustomActionTrigger {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A visual that contains custom content.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/custom-visual-content.html">Using custom visual content</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomContentVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration of a <code>CustomContentVisual</code>.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::CustomContentConfiguration>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    /// <p>The dataset that is used to create the custom content visual. You can't create a visual without a dataset.</p>
    #[doc(hidden)]
    pub data_set_identifier: std::option::Option<std::string::String>,
}
impl CustomContentVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration of a <code>CustomContentVisual</code>.</p>
    pub fn chart_configuration(
        &self,
    ) -> std::option::Option<&crate::model::CustomContentConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
    /// <p>The dataset that is used to create the custom content visual. You can't create a visual without a dataset.</p>
    pub fn data_set_identifier(&self) -> std::option::Option<&str> {
        self.data_set_identifier.as_deref()
    }
}
/// See [`CustomContentVisual`](crate::model::CustomContentVisual).
pub mod custom_content_visual {

    /// A builder for [`CustomContentVisual`](crate::model::CustomContentVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration:
            std::option::Option<crate::model::CustomContentConfiguration>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        pub(crate) data_set_identifier: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration of a <code>CustomContentVisual</code>.</p>
        pub fn chart_configuration(
            mut self,
            input: crate::model::CustomContentConfiguration,
        ) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration of a <code>CustomContentVisual</code>.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::CustomContentConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// <p>The dataset that is used to create the custom content visual. You can't create a visual without a dataset.</p>
        pub fn data_set_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_set_identifier = Some(input.into());
            self
        }
        /// <p>The dataset that is used to create the custom content visual. You can't create a visual without a dataset.</p>
        pub fn set_data_set_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_set_identifier = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomContentVisual`](crate::model::CustomContentVisual).
        pub fn build(self) -> crate::model::CustomContentVisual {
            crate::model::CustomContentVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                actions: self.actions,
                data_set_identifier: self.data_set_identifier,
            }
        }
    }
}
impl CustomContentVisual {
    /// Creates a new builder-style object to manufacture [`CustomContentVisual`](crate::model::CustomContentVisual).
    pub fn builder() -> crate::model::custom_content_visual::Builder {
        crate::model::custom_content_visual::Builder::default()
    }
}

/// <p>The configuration of a <code>CustomContentVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomContentConfiguration {
    /// <p>The input URL that links to the custom content that you want in the custom visual.</p>
    #[doc(hidden)]
    pub content_url: std::option::Option<std::string::String>,
    /// <p>The content type of the custom content visual. You can use this to have the visual render as an image.</p>
    #[doc(hidden)]
    pub content_type: std::option::Option<crate::model::CustomContentType>,
    /// <p>The sizing options for the size of the custom content visual. This structure is required when the <code>ContentType</code> of the visual is <code>'IMAGE'</code>.</p>
    #[doc(hidden)]
    pub image_scaling: std::option::Option<crate::model::CustomContentImageScalingConfiguration>,
}
impl CustomContentConfiguration {
    /// <p>The input URL that links to the custom content that you want in the custom visual.</p>
    pub fn content_url(&self) -> std::option::Option<&str> {
        self.content_url.as_deref()
    }
    /// <p>The content type of the custom content visual. You can use this to have the visual render as an image.</p>
    pub fn content_type(&self) -> std::option::Option<&crate::model::CustomContentType> {
        self.content_type.as_ref()
    }
    /// <p>The sizing options for the size of the custom content visual. This structure is required when the <code>ContentType</code> of the visual is <code>'IMAGE'</code>.</p>
    pub fn image_scaling(
        &self,
    ) -> std::option::Option<&crate::model::CustomContentImageScalingConfiguration> {
        self.image_scaling.as_ref()
    }
}
/// See [`CustomContentConfiguration`](crate::model::CustomContentConfiguration).
pub mod custom_content_configuration {

    /// A builder for [`CustomContentConfiguration`](crate::model::CustomContentConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content_url: std::option::Option<std::string::String>,
        pub(crate) content_type: std::option::Option<crate::model::CustomContentType>,
        pub(crate) image_scaling:
            std::option::Option<crate::model::CustomContentImageScalingConfiguration>,
    }
    impl Builder {
        /// <p>The input URL that links to the custom content that you want in the custom visual.</p>
        pub fn content_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_url = Some(input.into());
            self
        }
        /// <p>The input URL that links to the custom content that you want in the custom visual.</p>
        pub fn set_content_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_url = input;
            self
        }
        /// <p>The content type of the custom content visual. You can use this to have the visual render as an image.</p>
        pub fn content_type(mut self, input: crate::model::CustomContentType) -> Self {
            self.content_type = Some(input);
            self
        }
        /// <p>The content type of the custom content visual. You can use this to have the visual render as an image.</p>
        pub fn set_content_type(
            mut self,
            input: std::option::Option<crate::model::CustomContentType>,
        ) -> Self {
            self.content_type = input;
            self
        }
        /// <p>The sizing options for the size of the custom content visual. This structure is required when the <code>ContentType</code> of the visual is <code>'IMAGE'</code>.</p>
        pub fn image_scaling(
            mut self,
            input: crate::model::CustomContentImageScalingConfiguration,
        ) -> Self {
            self.image_scaling = Some(input);
            self
        }
        /// <p>The sizing options for the size of the custom content visual. This structure is required when the <code>ContentType</code> of the visual is <code>'IMAGE'</code>.</p>
        pub fn set_image_scaling(
            mut self,
            input: std::option::Option<crate::model::CustomContentImageScalingConfiguration>,
        ) -> Self {
            self.image_scaling = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomContentConfiguration`](crate::model::CustomContentConfiguration).
        pub fn build(self) -> crate::model::CustomContentConfiguration {
            crate::model::CustomContentConfiguration {
                content_url: self.content_url,
                content_type: self.content_type,
                image_scaling: self.image_scaling,
            }
        }
    }
}
impl CustomContentConfiguration {
    /// Creates a new builder-style object to manufacture [`CustomContentConfiguration`](crate::model::CustomContentConfiguration).
    pub fn builder() -> crate::model::custom_content_configuration::Builder {
        crate::model::custom_content_configuration::Builder::default()
    }
}

/// When writing a match expression against `CustomContentImageScalingConfiguration`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let customcontentimagescalingconfiguration = unimplemented!();
/// match customcontentimagescalingconfiguration {
///     CustomContentImageScalingConfiguration::DoNotScale => { /* ... */ },
///     CustomContentImageScalingConfiguration::FitToHeight => { /* ... */ },
///     CustomContentImageScalingConfiguration::FitToWidth => { /* ... */ },
///     CustomContentImageScalingConfiguration::ScaleToVisual => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `customcontentimagescalingconfiguration` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CustomContentImageScalingConfiguration::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CustomContentImageScalingConfiguration::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CustomContentImageScalingConfiguration::NewFeature` is defined.
/// Specifically, when `customcontentimagescalingconfiguration` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CustomContentImageScalingConfiguration::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CustomContentImageScalingConfiguration {
    #[allow(missing_docs)] // documentation missing in model
    DoNotScale,
    #[allow(missing_docs)] // documentation missing in model
    FitToHeight,
    #[allow(missing_docs)] // documentation missing in model
    FitToWidth,
    #[allow(missing_docs)] // documentation missing in model
    ScaleToVisual,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CustomContentImageScalingConfiguration {
    fn from(s: &str) -> Self {
        match s {
            "DO_NOT_SCALE" => CustomContentImageScalingConfiguration::DoNotScale,
            "FIT_TO_HEIGHT" => CustomContentImageScalingConfiguration::FitToHeight,
            "FIT_TO_WIDTH" => CustomContentImageScalingConfiguration::FitToWidth,
            "SCALE_TO_VISUAL" => CustomContentImageScalingConfiguration::ScaleToVisual,
            other => CustomContentImageScalingConfiguration::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for CustomContentImageScalingConfiguration {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CustomContentImageScalingConfiguration::from(s))
    }
}
impl CustomContentImageScalingConfiguration {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CustomContentImageScalingConfiguration::DoNotScale => "DO_NOT_SCALE",
            CustomContentImageScalingConfiguration::FitToHeight => "FIT_TO_HEIGHT",
            CustomContentImageScalingConfiguration::FitToWidth => "FIT_TO_WIDTH",
            CustomContentImageScalingConfiguration::ScaleToVisual => "SCALE_TO_VISUAL",
            CustomContentImageScalingConfiguration::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DO_NOT_SCALE",
            "FIT_TO_HEIGHT",
            "FIT_TO_WIDTH",
            "SCALE_TO_VISUAL",
        ]
    }
}
impl AsRef<str> for CustomContentImageScalingConfiguration {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `CustomContentType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let customcontenttype = unimplemented!();
/// match customcontenttype {
///     CustomContentType::Image => { /* ... */ },
///     CustomContentType::OtherEmbeddedContent => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `customcontenttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CustomContentType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CustomContentType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CustomContentType::NewFeature` is defined.
/// Specifically, when `customcontenttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CustomContentType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CustomContentType {
    #[allow(missing_docs)] // documentation missing in model
    Image,
    #[allow(missing_docs)] // documentation missing in model
    OtherEmbeddedContent,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CustomContentType {
    fn from(s: &str) -> Self {
        match s {
            "IMAGE" => CustomContentType::Image,
            "OTHER_EMBEDDED_CONTENT" => CustomContentType::OtherEmbeddedContent,
            other => {
                CustomContentType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for CustomContentType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CustomContentType::from(s))
    }
}
impl CustomContentType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CustomContentType::Image => "IMAGE",
            CustomContentType::OtherEmbeddedContent => "OTHER_EMBEDDED_CONTENT",
            CustomContentType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["IMAGE", "OTHER_EMBEDDED_CONTENT"]
    }
}
impl AsRef<str> for CustomContentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The subtitle label options for a visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VisualSubtitleLabelOptions {
    /// <p>The visibility of the subtitle label.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The long text format of the subtitle label, such as plain text or rich text.</p>
    #[doc(hidden)]
    pub format_text: std::option::Option<crate::model::LongFormatText>,
}
impl VisualSubtitleLabelOptions {
    /// <p>The visibility of the subtitle label.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
    /// <p>The long text format of the subtitle label, such as plain text or rich text.</p>
    pub fn format_text(&self) -> std::option::Option<&crate::model::LongFormatText> {
        self.format_text.as_ref()
    }
}
/// See [`VisualSubtitleLabelOptions`](crate::model::VisualSubtitleLabelOptions).
pub mod visual_subtitle_label_options {

    /// A builder for [`VisualSubtitleLabelOptions`](crate::model::VisualSubtitleLabelOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) format_text: std::option::Option<crate::model::LongFormatText>,
    }
    impl Builder {
        /// <p>The visibility of the subtitle label.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility of the subtitle label.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// <p>The long text format of the subtitle label, such as plain text or rich text.</p>
        pub fn format_text(mut self, input: crate::model::LongFormatText) -> Self {
            self.format_text = Some(input);
            self
        }
        /// <p>The long text format of the subtitle label, such as plain text or rich text.</p>
        pub fn set_format_text(
            mut self,
            input: std::option::Option<crate::model::LongFormatText>,
        ) -> Self {
            self.format_text = input;
            self
        }
        /// Consumes the builder and constructs a [`VisualSubtitleLabelOptions`](crate::model::VisualSubtitleLabelOptions).
        pub fn build(self) -> crate::model::VisualSubtitleLabelOptions {
            crate::model::VisualSubtitleLabelOptions {
                visibility: self.visibility,
                format_text: self.format_text,
            }
        }
    }
}
impl VisualSubtitleLabelOptions {
    /// Creates a new builder-style object to manufacture [`VisualSubtitleLabelOptions`](crate::model::VisualSubtitleLabelOptions).
    pub fn builder() -> crate::model::visual_subtitle_label_options::Builder {
        crate::model::visual_subtitle_label_options::Builder::default()
    }
}

/// <p>The text format for a subtitle.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LongFormatText {
    /// <p>Plain text format.</p>
    #[doc(hidden)]
    pub plain_text: std::option::Option<std::string::String>,
    /// <p>Rich text. Examples of rich text include bold, underline, and italics.</p>
    #[doc(hidden)]
    pub rich_text: std::option::Option<std::string::String>,
}
impl LongFormatText {
    /// <p>Plain text format.</p>
    pub fn plain_text(&self) -> std::option::Option<&str> {
        self.plain_text.as_deref()
    }
    /// <p>Rich text. Examples of rich text include bold, underline, and italics.</p>
    pub fn rich_text(&self) -> std::option::Option<&str> {
        self.rich_text.as_deref()
    }
}
/// See [`LongFormatText`](crate::model::LongFormatText).
pub mod long_format_text {

    /// A builder for [`LongFormatText`](crate::model::LongFormatText).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) plain_text: std::option::Option<std::string::String>,
        pub(crate) rich_text: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Plain text format.</p>
        pub fn plain_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.plain_text = Some(input.into());
            self
        }
        /// <p>Plain text format.</p>
        pub fn set_plain_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.plain_text = input;
            self
        }
        /// <p>Rich text. Examples of rich text include bold, underline, and italics.</p>
        pub fn rich_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.rich_text = Some(input.into());
            self
        }
        /// <p>Rich text. Examples of rich text include bold, underline, and italics.</p>
        pub fn set_rich_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rich_text = input;
            self
        }
        /// Consumes the builder and constructs a [`LongFormatText`](crate::model::LongFormatText).
        pub fn build(self) -> crate::model::LongFormatText {
            crate::model::LongFormatText {
                plain_text: self.plain_text,
                rich_text: self.rich_text,
            }
        }
    }
}
impl LongFormatText {
    /// Creates a new builder-style object to manufacture [`LongFormatText`](crate::model::LongFormatText).
    pub fn builder() -> crate::model::long_format_text::Builder {
        crate::model::long_format_text::Builder::default()
    }
}

/// <p>The title label options for a visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VisualTitleLabelOptions {
    /// <p>The visibility of the title label.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The short text format of the title label, such as plain text or rich text.</p>
    #[doc(hidden)]
    pub format_text: std::option::Option<crate::model::ShortFormatText>,
}
impl VisualTitleLabelOptions {
    /// <p>The visibility of the title label.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
    /// <p>The short text format of the title label, such as plain text or rich text.</p>
    pub fn format_text(&self) -> std::option::Option<&crate::model::ShortFormatText> {
        self.format_text.as_ref()
    }
}
/// See [`VisualTitleLabelOptions`](crate::model::VisualTitleLabelOptions).
pub mod visual_title_label_options {

    /// A builder for [`VisualTitleLabelOptions`](crate::model::VisualTitleLabelOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) format_text: std::option::Option<crate::model::ShortFormatText>,
    }
    impl Builder {
        /// <p>The visibility of the title label.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility of the title label.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// <p>The short text format of the title label, such as plain text or rich text.</p>
        pub fn format_text(mut self, input: crate::model::ShortFormatText) -> Self {
            self.format_text = Some(input);
            self
        }
        /// <p>The short text format of the title label, such as plain text or rich text.</p>
        pub fn set_format_text(
            mut self,
            input: std::option::Option<crate::model::ShortFormatText>,
        ) -> Self {
            self.format_text = input;
            self
        }
        /// Consumes the builder and constructs a [`VisualTitleLabelOptions`](crate::model::VisualTitleLabelOptions).
        pub fn build(self) -> crate::model::VisualTitleLabelOptions {
            crate::model::VisualTitleLabelOptions {
                visibility: self.visibility,
                format_text: self.format_text,
            }
        }
    }
}
impl VisualTitleLabelOptions {
    /// Creates a new builder-style object to manufacture [`VisualTitleLabelOptions`](crate::model::VisualTitleLabelOptions).
    pub fn builder() -> crate::model::visual_title_label_options::Builder {
        crate::model::visual_title_label_options::Builder::default()
    }
}

/// <p>The text format for the title.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ShortFormatText {
    /// <p>Plain text format.</p>
    #[doc(hidden)]
    pub plain_text: std::option::Option<std::string::String>,
    /// <p>Rich text. Examples of rich text include bold, underline, and italics.</p>
    #[doc(hidden)]
    pub rich_text: std::option::Option<std::string::String>,
}
impl ShortFormatText {
    /// <p>Plain text format.</p>
    pub fn plain_text(&self) -> std::option::Option<&str> {
        self.plain_text.as_deref()
    }
    /// <p>Rich text. Examples of rich text include bold, underline, and italics.</p>
    pub fn rich_text(&self) -> std::option::Option<&str> {
        self.rich_text.as_deref()
    }
}
/// See [`ShortFormatText`](crate::model::ShortFormatText).
pub mod short_format_text {

    /// A builder for [`ShortFormatText`](crate::model::ShortFormatText).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) plain_text: std::option::Option<std::string::String>,
        pub(crate) rich_text: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Plain text format.</p>
        pub fn plain_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.plain_text = Some(input.into());
            self
        }
        /// <p>Plain text format.</p>
        pub fn set_plain_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.plain_text = input;
            self
        }
        /// <p>Rich text. Examples of rich text include bold, underline, and italics.</p>
        pub fn rich_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.rich_text = Some(input.into());
            self
        }
        /// <p>Rich text. Examples of rich text include bold, underline, and italics.</p>
        pub fn set_rich_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rich_text = input;
            self
        }
        /// Consumes the builder and constructs a [`ShortFormatText`](crate::model::ShortFormatText).
        pub fn build(self) -> crate::model::ShortFormatText {
            crate::model::ShortFormatText {
                plain_text: self.plain_text,
                rich_text: self.rich_text,
            }
        }
    }
}
impl ShortFormatText {
    /// Creates a new builder-style object to manufacture [`ShortFormatText`](crate::model::ShortFormatText).
    pub fn builder() -> crate::model::short_format_text::Builder {
        crate::model::short_format_text::Builder::default()
    }
}

/// <p>A sankey diagram.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/sankey-diagram.html">Using Sankey diagrams</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SankeyDiagramVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration of a sankey diagram.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::SankeyDiagramChartConfiguration>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
}
impl SankeyDiagramVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration of a sankey diagram.</p>
    pub fn chart_configuration(
        &self,
    ) -> std::option::Option<&crate::model::SankeyDiagramChartConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
}
/// See [`SankeyDiagramVisual`](crate::model::SankeyDiagramVisual).
pub mod sankey_diagram_visual {

    /// A builder for [`SankeyDiagramVisual`](crate::model::SankeyDiagramVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration:
            std::option::Option<crate::model::SankeyDiagramChartConfiguration>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration of a sankey diagram.</p>
        pub fn chart_configuration(
            mut self,
            input: crate::model::SankeyDiagramChartConfiguration,
        ) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration of a sankey diagram.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::SankeyDiagramChartConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Consumes the builder and constructs a [`SankeyDiagramVisual`](crate::model::SankeyDiagramVisual).
        pub fn build(self) -> crate::model::SankeyDiagramVisual {
            crate::model::SankeyDiagramVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                actions: self.actions,
            }
        }
    }
}
impl SankeyDiagramVisual {
    /// Creates a new builder-style object to manufacture [`SankeyDiagramVisual`](crate::model::SankeyDiagramVisual).
    pub fn builder() -> crate::model::sankey_diagram_visual::Builder {
        crate::model::sankey_diagram_visual::Builder::default()
    }
}

/// <p>The configuration of a sankey diagram.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SankeyDiagramChartConfiguration {
    /// <p>The field well configuration of a sankey diagram.</p>
    #[doc(hidden)]
    pub field_wells: std::option::Option<crate::model::SankeyDiagramFieldWells>,
    /// <p>The sort configuration of a sankey diagram.</p>
    #[doc(hidden)]
    pub sort_configuration: std::option::Option<crate::model::SankeyDiagramSortConfiguration>,
    /// <p>The data label configuration of a sankey diagram.</p>
    #[doc(hidden)]
    pub data_labels: std::option::Option<crate::model::DataLabelOptions>,
}
impl SankeyDiagramChartConfiguration {
    /// <p>The field well configuration of a sankey diagram.</p>
    pub fn field_wells(&self) -> std::option::Option<&crate::model::SankeyDiagramFieldWells> {
        self.field_wells.as_ref()
    }
    /// <p>The sort configuration of a sankey diagram.</p>
    pub fn sort_configuration(
        &self,
    ) -> std::option::Option<&crate::model::SankeyDiagramSortConfiguration> {
        self.sort_configuration.as_ref()
    }
    /// <p>The data label configuration of a sankey diagram.</p>
    pub fn data_labels(&self) -> std::option::Option<&crate::model::DataLabelOptions> {
        self.data_labels.as_ref()
    }
}
/// See [`SankeyDiagramChartConfiguration`](crate::model::SankeyDiagramChartConfiguration).
pub mod sankey_diagram_chart_configuration {

    /// A builder for [`SankeyDiagramChartConfiguration`](crate::model::SankeyDiagramChartConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_wells: std::option::Option<crate::model::SankeyDiagramFieldWells>,
        pub(crate) sort_configuration:
            std::option::Option<crate::model::SankeyDiagramSortConfiguration>,
        pub(crate) data_labels: std::option::Option<crate::model::DataLabelOptions>,
    }
    impl Builder {
        /// <p>The field well configuration of a sankey diagram.</p>
        pub fn field_wells(mut self, input: crate::model::SankeyDiagramFieldWells) -> Self {
            self.field_wells = Some(input);
            self
        }
        /// <p>The field well configuration of a sankey diagram.</p>
        pub fn set_field_wells(
            mut self,
            input: std::option::Option<crate::model::SankeyDiagramFieldWells>,
        ) -> Self {
            self.field_wells = input;
            self
        }
        /// <p>The sort configuration of a sankey diagram.</p>
        pub fn sort_configuration(
            mut self,
            input: crate::model::SankeyDiagramSortConfiguration,
        ) -> Self {
            self.sort_configuration = Some(input);
            self
        }
        /// <p>The sort configuration of a sankey diagram.</p>
        pub fn set_sort_configuration(
            mut self,
            input: std::option::Option<crate::model::SankeyDiagramSortConfiguration>,
        ) -> Self {
            self.sort_configuration = input;
            self
        }
        /// <p>The data label configuration of a sankey diagram.</p>
        pub fn data_labels(mut self, input: crate::model::DataLabelOptions) -> Self {
            self.data_labels = Some(input);
            self
        }
        /// <p>The data label configuration of a sankey diagram.</p>
        pub fn set_data_labels(
            mut self,
            input: std::option::Option<crate::model::DataLabelOptions>,
        ) -> Self {
            self.data_labels = input;
            self
        }
        /// Consumes the builder and constructs a [`SankeyDiagramChartConfiguration`](crate::model::SankeyDiagramChartConfiguration).
        pub fn build(self) -> crate::model::SankeyDiagramChartConfiguration {
            crate::model::SankeyDiagramChartConfiguration {
                field_wells: self.field_wells,
                sort_configuration: self.sort_configuration,
                data_labels: self.data_labels,
            }
        }
    }
}
impl SankeyDiagramChartConfiguration {
    /// Creates a new builder-style object to manufacture [`SankeyDiagramChartConfiguration`](crate::model::SankeyDiagramChartConfiguration).
    pub fn builder() -> crate::model::sankey_diagram_chart_configuration::Builder {
        crate::model::sankey_diagram_chart_configuration::Builder::default()
    }
}

/// <p>The options that determine the presentation of the data labels.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataLabelOptions {
    /// <p>Determines the visibility of the data labels.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
    /// <p>Determines the visibility of the category field labels.</p>
    #[doc(hidden)]
    pub category_label_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>Determines the visibility of the measure field labels.</p>
    #[doc(hidden)]
    pub measure_label_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The option that determines the data label type.</p>
    #[doc(hidden)]
    pub data_label_types: std::option::Option<std::vec::Vec<crate::model::DataLabelType>>,
    /// <p>Determines the position of the data labels.</p>
    #[doc(hidden)]
    pub position: std::option::Option<crate::model::DataLabelPosition>,
    /// <p>Determines the content of the data labels.</p>
    #[doc(hidden)]
    pub label_content: std::option::Option<crate::model::DataLabelContent>,
    /// <p>Determines the font configuration of the data labels.</p>
    #[doc(hidden)]
    pub label_font_configuration: std::option::Option<crate::model::FontConfiguration>,
    /// <p>Determines the color of the data labels.</p>
    #[doc(hidden)]
    pub label_color: std::option::Option<std::string::String>,
    /// <p>Determines whether overlap is enabled or disabled for the data labels.</p>
    #[doc(hidden)]
    pub overlap: std::option::Option<crate::model::DataLabelOverlap>,
}
impl DataLabelOptions {
    /// <p>Determines the visibility of the data labels.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
    /// <p>Determines the visibility of the category field labels.</p>
    pub fn category_label_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.category_label_visibility.as_ref()
    }
    /// <p>Determines the visibility of the measure field labels.</p>
    pub fn measure_label_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.measure_label_visibility.as_ref()
    }
    /// <p>The option that determines the data label type.</p>
    pub fn data_label_types(&self) -> std::option::Option<&[crate::model::DataLabelType]> {
        self.data_label_types.as_deref()
    }
    /// <p>Determines the position of the data labels.</p>
    pub fn position(&self) -> std::option::Option<&crate::model::DataLabelPosition> {
        self.position.as_ref()
    }
    /// <p>Determines the content of the data labels.</p>
    pub fn label_content(&self) -> std::option::Option<&crate::model::DataLabelContent> {
        self.label_content.as_ref()
    }
    /// <p>Determines the font configuration of the data labels.</p>
    pub fn label_font_configuration(
        &self,
    ) -> std::option::Option<&crate::model::FontConfiguration> {
        self.label_font_configuration.as_ref()
    }
    /// <p>Determines the color of the data labels.</p>
    pub fn label_color(&self) -> std::option::Option<&str> {
        self.label_color.as_deref()
    }
    /// <p>Determines whether overlap is enabled or disabled for the data labels.</p>
    pub fn overlap(&self) -> std::option::Option<&crate::model::DataLabelOverlap> {
        self.overlap.as_ref()
    }
}
/// See [`DataLabelOptions`](crate::model::DataLabelOptions).
pub mod data_label_options {

    /// A builder for [`DataLabelOptions`](crate::model::DataLabelOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) category_label_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) measure_label_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) data_label_types:
            std::option::Option<std::vec::Vec<crate::model::DataLabelType>>,
        pub(crate) position: std::option::Option<crate::model::DataLabelPosition>,
        pub(crate) label_content: std::option::Option<crate::model::DataLabelContent>,
        pub(crate) label_font_configuration: std::option::Option<crate::model::FontConfiguration>,
        pub(crate) label_color: std::option::Option<std::string::String>,
        pub(crate) overlap: std::option::Option<crate::model::DataLabelOverlap>,
    }
    impl Builder {
        /// <p>Determines the visibility of the data labels.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>Determines the visibility of the data labels.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// <p>Determines the visibility of the category field labels.</p>
        pub fn category_label_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.category_label_visibility = Some(input);
            self
        }
        /// <p>Determines the visibility of the category field labels.</p>
        pub fn set_category_label_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.category_label_visibility = input;
            self
        }
        /// <p>Determines the visibility of the measure field labels.</p>
        pub fn measure_label_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.measure_label_visibility = Some(input);
            self
        }
        /// <p>Determines the visibility of the measure field labels.</p>
        pub fn set_measure_label_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.measure_label_visibility = input;
            self
        }
        /// Appends an item to `data_label_types`.
        ///
        /// To override the contents of this collection use [`set_data_label_types`](Self::set_data_label_types).
        ///
        /// <p>The option that determines the data label type.</p>
        pub fn data_label_types(mut self, input: crate::model::DataLabelType) -> Self {
            let mut v = self.data_label_types.unwrap_or_default();
            v.push(input);
            self.data_label_types = Some(v);
            self
        }
        /// <p>The option that determines the data label type.</p>
        pub fn set_data_label_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataLabelType>>,
        ) -> Self {
            self.data_label_types = input;
            self
        }
        /// <p>Determines the position of the data labels.</p>
        pub fn position(mut self, input: crate::model::DataLabelPosition) -> Self {
            self.position = Some(input);
            self
        }
        /// <p>Determines the position of the data labels.</p>
        pub fn set_position(
            mut self,
            input: std::option::Option<crate::model::DataLabelPosition>,
        ) -> Self {
            self.position = input;
            self
        }
        /// <p>Determines the content of the data labels.</p>
        pub fn label_content(mut self, input: crate::model::DataLabelContent) -> Self {
            self.label_content = Some(input);
            self
        }
        /// <p>Determines the content of the data labels.</p>
        pub fn set_label_content(
            mut self,
            input: std::option::Option<crate::model::DataLabelContent>,
        ) -> Self {
            self.label_content = input;
            self
        }
        /// <p>Determines the font configuration of the data labels.</p>
        pub fn label_font_configuration(mut self, input: crate::model::FontConfiguration) -> Self {
            self.label_font_configuration = Some(input);
            self
        }
        /// <p>Determines the font configuration of the data labels.</p>
        pub fn set_label_font_configuration(
            mut self,
            input: std::option::Option<crate::model::FontConfiguration>,
        ) -> Self {
            self.label_font_configuration = input;
            self
        }
        /// <p>Determines the color of the data labels.</p>
        pub fn label_color(mut self, input: impl Into<std::string::String>) -> Self {
            self.label_color = Some(input.into());
            self
        }
        /// <p>Determines the color of the data labels.</p>
        pub fn set_label_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.label_color = input;
            self
        }
        /// <p>Determines whether overlap is enabled or disabled for the data labels.</p>
        pub fn overlap(mut self, input: crate::model::DataLabelOverlap) -> Self {
            self.overlap = Some(input);
            self
        }
        /// <p>Determines whether overlap is enabled or disabled for the data labels.</p>
        pub fn set_overlap(
            mut self,
            input: std::option::Option<crate::model::DataLabelOverlap>,
        ) -> Self {
            self.overlap = input;
            self
        }
        /// Consumes the builder and constructs a [`DataLabelOptions`](crate::model::DataLabelOptions).
        pub fn build(self) -> crate::model::DataLabelOptions {
            crate::model::DataLabelOptions {
                visibility: self.visibility,
                category_label_visibility: self.category_label_visibility,
                measure_label_visibility: self.measure_label_visibility,
                data_label_types: self.data_label_types,
                position: self.position,
                label_content: self.label_content,
                label_font_configuration: self.label_font_configuration,
                label_color: self.label_color,
                overlap: self.overlap,
            }
        }
    }
}
impl DataLabelOptions {
    /// Creates a new builder-style object to manufacture [`DataLabelOptions`](crate::model::DataLabelOptions).
    pub fn builder() -> crate::model::data_label_options::Builder {
        crate::model::data_label_options::Builder::default()
    }
}

/// When writing a match expression against `DataLabelOverlap`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datalabeloverlap = unimplemented!();
/// match datalabeloverlap {
///     DataLabelOverlap::DisableOverlap => { /* ... */ },
///     DataLabelOverlap::EnableOverlap => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datalabeloverlap` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataLabelOverlap::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataLabelOverlap::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataLabelOverlap::NewFeature` is defined.
/// Specifically, when `datalabeloverlap` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataLabelOverlap::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataLabelOverlap {
    #[allow(missing_docs)] // documentation missing in model
    DisableOverlap,
    #[allow(missing_docs)] // documentation missing in model
    EnableOverlap,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataLabelOverlap {
    fn from(s: &str) -> Self {
        match s {
            "DISABLE_OVERLAP" => DataLabelOverlap::DisableOverlap,
            "ENABLE_OVERLAP" => DataLabelOverlap::EnableOverlap,
            other => DataLabelOverlap::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DataLabelOverlap {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataLabelOverlap::from(s))
    }
}
impl DataLabelOverlap {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataLabelOverlap::DisableOverlap => "DISABLE_OVERLAP",
            DataLabelOverlap::EnableOverlap => "ENABLE_OVERLAP",
            DataLabelOverlap::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLE_OVERLAP", "ENABLE_OVERLAP"]
    }
}
impl AsRef<str> for DataLabelOverlap {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configures the display properties of the given text.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FontConfiguration {
    /// <p>The option that determines the text display size.</p>
    #[doc(hidden)]
    pub font_size: std::option::Option<crate::model::FontSize>,
    /// <p>Determines the appearance of decorative lines on the text.</p>
    #[doc(hidden)]
    pub font_decoration: std::option::Option<crate::model::FontDecoration>,
    /// <p>Determines the color of the text.</p>
    #[doc(hidden)]
    pub font_color: std::option::Option<std::string::String>,
    /// <p>The option that determines the text display weight, or boldness.</p>
    #[doc(hidden)]
    pub font_weight: std::option::Option<crate::model::FontWeight>,
    /// <p>Determines the text display face that is inherited by the given font family.</p>
    #[doc(hidden)]
    pub font_style: std::option::Option<crate::model::FontStyle>,
}
impl FontConfiguration {
    /// <p>The option that determines the text display size.</p>
    pub fn font_size(&self) -> std::option::Option<&crate::model::FontSize> {
        self.font_size.as_ref()
    }
    /// <p>Determines the appearance of decorative lines on the text.</p>
    pub fn font_decoration(&self) -> std::option::Option<&crate::model::FontDecoration> {
        self.font_decoration.as_ref()
    }
    /// <p>Determines the color of the text.</p>
    pub fn font_color(&self) -> std::option::Option<&str> {
        self.font_color.as_deref()
    }
    /// <p>The option that determines the text display weight, or boldness.</p>
    pub fn font_weight(&self) -> std::option::Option<&crate::model::FontWeight> {
        self.font_weight.as_ref()
    }
    /// <p>Determines the text display face that is inherited by the given font family.</p>
    pub fn font_style(&self) -> std::option::Option<&crate::model::FontStyle> {
        self.font_style.as_ref()
    }
}
/// See [`FontConfiguration`](crate::model::FontConfiguration).
pub mod font_configuration {

    /// A builder for [`FontConfiguration`](crate::model::FontConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) font_size: std::option::Option<crate::model::FontSize>,
        pub(crate) font_decoration: std::option::Option<crate::model::FontDecoration>,
        pub(crate) font_color: std::option::Option<std::string::String>,
        pub(crate) font_weight: std::option::Option<crate::model::FontWeight>,
        pub(crate) font_style: std::option::Option<crate::model::FontStyle>,
    }
    impl Builder {
        /// <p>The option that determines the text display size.</p>
        pub fn font_size(mut self, input: crate::model::FontSize) -> Self {
            self.font_size = Some(input);
            self
        }
        /// <p>The option that determines the text display size.</p>
        pub fn set_font_size(mut self, input: std::option::Option<crate::model::FontSize>) -> Self {
            self.font_size = input;
            self
        }
        /// <p>Determines the appearance of decorative lines on the text.</p>
        pub fn font_decoration(mut self, input: crate::model::FontDecoration) -> Self {
            self.font_decoration = Some(input);
            self
        }
        /// <p>Determines the appearance of decorative lines on the text.</p>
        pub fn set_font_decoration(
            mut self,
            input: std::option::Option<crate::model::FontDecoration>,
        ) -> Self {
            self.font_decoration = input;
            self
        }
        /// <p>Determines the color of the text.</p>
        pub fn font_color(mut self, input: impl Into<std::string::String>) -> Self {
            self.font_color = Some(input.into());
            self
        }
        /// <p>Determines the color of the text.</p>
        pub fn set_font_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.font_color = input;
            self
        }
        /// <p>The option that determines the text display weight, or boldness.</p>
        pub fn font_weight(mut self, input: crate::model::FontWeight) -> Self {
            self.font_weight = Some(input);
            self
        }
        /// <p>The option that determines the text display weight, or boldness.</p>
        pub fn set_font_weight(
            mut self,
            input: std::option::Option<crate::model::FontWeight>,
        ) -> Self {
            self.font_weight = input;
            self
        }
        /// <p>Determines the text display face that is inherited by the given font family.</p>
        pub fn font_style(mut self, input: crate::model::FontStyle) -> Self {
            self.font_style = Some(input);
            self
        }
        /// <p>Determines the text display face that is inherited by the given font family.</p>
        pub fn set_font_style(
            mut self,
            input: std::option::Option<crate::model::FontStyle>,
        ) -> Self {
            self.font_style = input;
            self
        }
        /// Consumes the builder and constructs a [`FontConfiguration`](crate::model::FontConfiguration).
        pub fn build(self) -> crate::model::FontConfiguration {
            crate::model::FontConfiguration {
                font_size: self.font_size,
                font_decoration: self.font_decoration,
                font_color: self.font_color,
                font_weight: self.font_weight,
                font_style: self.font_style,
            }
        }
    }
}
impl FontConfiguration {
    /// Creates a new builder-style object to manufacture [`FontConfiguration`](crate::model::FontConfiguration).
    pub fn builder() -> crate::model::font_configuration::Builder {
        crate::model::font_configuration::Builder::default()
    }
}

/// When writing a match expression against `FontStyle`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let fontstyle = unimplemented!();
/// match fontstyle {
///     FontStyle::Italic => { /* ... */ },
///     FontStyle::Normal => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `fontstyle` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FontStyle::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FontStyle::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FontStyle::NewFeature` is defined.
/// Specifically, when `fontstyle` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FontStyle::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FontStyle {
    #[allow(missing_docs)] // documentation missing in model
    Italic,
    #[allow(missing_docs)] // documentation missing in model
    Normal,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FontStyle {
    fn from(s: &str) -> Self {
        match s {
            "ITALIC" => FontStyle::Italic,
            "NORMAL" => FontStyle::Normal,
            other => FontStyle::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FontStyle {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FontStyle::from(s))
    }
}
impl FontStyle {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FontStyle::Italic => "ITALIC",
            FontStyle::Normal => "NORMAL",
            FontStyle::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ITALIC", "NORMAL"]
    }
}
impl AsRef<str> for FontStyle {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The option that determines the text display weight, or boldness.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FontWeight {
    /// <p>The lexical name for the level of boldness of the text display.</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::FontWeightName>,
}
impl FontWeight {
    /// <p>The lexical name for the level of boldness of the text display.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::FontWeightName> {
        self.name.as_ref()
    }
}
/// See [`FontWeight`](crate::model::FontWeight).
pub mod font_weight {

    /// A builder for [`FontWeight`](crate::model::FontWeight).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::FontWeightName>,
    }
    impl Builder {
        /// <p>The lexical name for the level of boldness of the text display.</p>
        pub fn name(mut self, input: crate::model::FontWeightName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The lexical name for the level of boldness of the text display.</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::FontWeightName>,
        ) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`FontWeight`](crate::model::FontWeight).
        pub fn build(self) -> crate::model::FontWeight {
            crate::model::FontWeight { name: self.name }
        }
    }
}
impl FontWeight {
    /// Creates a new builder-style object to manufacture [`FontWeight`](crate::model::FontWeight).
    pub fn builder() -> crate::model::font_weight::Builder {
        crate::model::font_weight::Builder::default()
    }
}

/// When writing a match expression against `FontWeightName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let fontweightname = unimplemented!();
/// match fontweightname {
///     FontWeightName::Bold => { /* ... */ },
///     FontWeightName::Normal => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `fontweightname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FontWeightName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FontWeightName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FontWeightName::NewFeature` is defined.
/// Specifically, when `fontweightname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FontWeightName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FontWeightName {
    #[allow(missing_docs)] // documentation missing in model
    Bold,
    #[allow(missing_docs)] // documentation missing in model
    Normal,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FontWeightName {
    fn from(s: &str) -> Self {
        match s {
            "BOLD" => FontWeightName::Bold,
            "NORMAL" => FontWeightName::Normal,
            other => FontWeightName::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FontWeightName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FontWeightName::from(s))
    }
}
impl FontWeightName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FontWeightName::Bold => "BOLD",
            FontWeightName::Normal => "NORMAL",
            FontWeightName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BOLD", "NORMAL"]
    }
}
impl AsRef<str> for FontWeightName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `FontDecoration`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let fontdecoration = unimplemented!();
/// match fontdecoration {
///     FontDecoration::None => { /* ... */ },
///     FontDecoration::Underline => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `fontdecoration` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FontDecoration::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FontDecoration::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FontDecoration::NewFeature` is defined.
/// Specifically, when `fontdecoration` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FontDecoration::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FontDecoration {
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Underline,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FontDecoration {
    fn from(s: &str) -> Self {
        match s {
            "NONE" => FontDecoration::None,
            "UNDERLINE" => FontDecoration::Underline,
            other => FontDecoration::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FontDecoration {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FontDecoration::from(s))
    }
}
impl FontDecoration {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FontDecoration::None => "NONE",
            FontDecoration::Underline => "UNDERLINE",
            FontDecoration::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NONE", "UNDERLINE"]
    }
}
impl AsRef<str> for FontDecoration {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The option that determines the text display size.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FontSize {
    /// <p>The lexical name for the text size, proportional to its surrounding context.</p>
    #[doc(hidden)]
    pub relative: std::option::Option<crate::model::RelativeFontSize>,
}
impl FontSize {
    /// <p>The lexical name for the text size, proportional to its surrounding context.</p>
    pub fn relative(&self) -> std::option::Option<&crate::model::RelativeFontSize> {
        self.relative.as_ref()
    }
}
/// See [`FontSize`](crate::model::FontSize).
pub mod font_size {

    /// A builder for [`FontSize`](crate::model::FontSize).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relative: std::option::Option<crate::model::RelativeFontSize>,
    }
    impl Builder {
        /// <p>The lexical name for the text size, proportional to its surrounding context.</p>
        pub fn relative(mut self, input: crate::model::RelativeFontSize) -> Self {
            self.relative = Some(input);
            self
        }
        /// <p>The lexical name for the text size, proportional to its surrounding context.</p>
        pub fn set_relative(
            mut self,
            input: std::option::Option<crate::model::RelativeFontSize>,
        ) -> Self {
            self.relative = input;
            self
        }
        /// Consumes the builder and constructs a [`FontSize`](crate::model::FontSize).
        pub fn build(self) -> crate::model::FontSize {
            crate::model::FontSize {
                relative: self.relative,
            }
        }
    }
}
impl FontSize {
    /// Creates a new builder-style object to manufacture [`FontSize`](crate::model::FontSize).
    pub fn builder() -> crate::model::font_size::Builder {
        crate::model::font_size::Builder::default()
    }
}

/// When writing a match expression against `RelativeFontSize`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let relativefontsize = unimplemented!();
/// match relativefontsize {
///     RelativeFontSize::ExtraLarge => { /* ... */ },
///     RelativeFontSize::ExtraSmall => { /* ... */ },
///     RelativeFontSize::Large => { /* ... */ },
///     RelativeFontSize::Medium => { /* ... */ },
///     RelativeFontSize::Small => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `relativefontsize` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RelativeFontSize::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RelativeFontSize::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RelativeFontSize::NewFeature` is defined.
/// Specifically, when `relativefontsize` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RelativeFontSize::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RelativeFontSize {
    #[allow(missing_docs)] // documentation missing in model
    ExtraLarge,
    #[allow(missing_docs)] // documentation missing in model
    ExtraSmall,
    #[allow(missing_docs)] // documentation missing in model
    Large,
    #[allow(missing_docs)] // documentation missing in model
    Medium,
    #[allow(missing_docs)] // documentation missing in model
    Small,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RelativeFontSize {
    fn from(s: &str) -> Self {
        match s {
            "EXTRA_LARGE" => RelativeFontSize::ExtraLarge,
            "EXTRA_SMALL" => RelativeFontSize::ExtraSmall,
            "LARGE" => RelativeFontSize::Large,
            "MEDIUM" => RelativeFontSize::Medium,
            "SMALL" => RelativeFontSize::Small,
            other => RelativeFontSize::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for RelativeFontSize {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RelativeFontSize::from(s))
    }
}
impl RelativeFontSize {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RelativeFontSize::ExtraLarge => "EXTRA_LARGE",
            RelativeFontSize::ExtraSmall => "EXTRA_SMALL",
            RelativeFontSize::Large => "LARGE",
            RelativeFontSize::Medium => "MEDIUM",
            RelativeFontSize::Small => "SMALL",
            RelativeFontSize::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EXTRA_LARGE", "EXTRA_SMALL", "LARGE", "MEDIUM", "SMALL"]
    }
}
impl AsRef<str> for RelativeFontSize {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DataLabelContent`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datalabelcontent = unimplemented!();
/// match datalabelcontent {
///     DataLabelContent::Percent => { /* ... */ },
///     DataLabelContent::Value => { /* ... */ },
///     DataLabelContent::ValueAndPercent => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datalabelcontent` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataLabelContent::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataLabelContent::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataLabelContent::NewFeature` is defined.
/// Specifically, when `datalabelcontent` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataLabelContent::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataLabelContent {
    #[allow(missing_docs)] // documentation missing in model
    Percent,
    #[allow(missing_docs)] // documentation missing in model
    Value,
    #[allow(missing_docs)] // documentation missing in model
    ValueAndPercent,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataLabelContent {
    fn from(s: &str) -> Self {
        match s {
            "PERCENT" => DataLabelContent::Percent,
            "VALUE" => DataLabelContent::Value,
            "VALUE_AND_PERCENT" => DataLabelContent::ValueAndPercent,
            other => DataLabelContent::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DataLabelContent {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataLabelContent::from(s))
    }
}
impl DataLabelContent {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataLabelContent::Percent => "PERCENT",
            DataLabelContent::Value => "VALUE",
            DataLabelContent::ValueAndPercent => "VALUE_AND_PERCENT",
            DataLabelContent::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PERCENT", "VALUE", "VALUE_AND_PERCENT"]
    }
}
impl AsRef<str> for DataLabelContent {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DataLabelPosition`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datalabelposition = unimplemented!();
/// match datalabelposition {
///     DataLabelPosition::Bottom => { /* ... */ },
///     DataLabelPosition::Inside => { /* ... */ },
///     DataLabelPosition::Left => { /* ... */ },
///     DataLabelPosition::Outside => { /* ... */ },
///     DataLabelPosition::Right => { /* ... */ },
///     DataLabelPosition::Top => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datalabelposition` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataLabelPosition::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataLabelPosition::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataLabelPosition::NewFeature` is defined.
/// Specifically, when `datalabelposition` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataLabelPosition::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataLabelPosition {
    #[allow(missing_docs)] // documentation missing in model
    Bottom,
    #[allow(missing_docs)] // documentation missing in model
    Inside,
    #[allow(missing_docs)] // documentation missing in model
    Left,
    #[allow(missing_docs)] // documentation missing in model
    Outside,
    #[allow(missing_docs)] // documentation missing in model
    Right,
    #[allow(missing_docs)] // documentation missing in model
    Top,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataLabelPosition {
    fn from(s: &str) -> Self {
        match s {
            "BOTTOM" => DataLabelPosition::Bottom,
            "INSIDE" => DataLabelPosition::Inside,
            "LEFT" => DataLabelPosition::Left,
            "OUTSIDE" => DataLabelPosition::Outside,
            "RIGHT" => DataLabelPosition::Right,
            "TOP" => DataLabelPosition::Top,
            other => {
                DataLabelPosition::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DataLabelPosition {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataLabelPosition::from(s))
    }
}
impl DataLabelPosition {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataLabelPosition::Bottom => "BOTTOM",
            DataLabelPosition::Inside => "INSIDE",
            DataLabelPosition::Left => "LEFT",
            DataLabelPosition::Outside => "OUTSIDE",
            DataLabelPosition::Right => "RIGHT",
            DataLabelPosition::Top => "TOP",
            DataLabelPosition::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BOTTOM", "INSIDE", "LEFT", "OUTSIDE", "RIGHT", "TOP"]
    }
}
impl AsRef<str> for DataLabelPosition {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The option that determines the data label type.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataLabelType {
    /// <p>Determines the label configuration for the entire field.</p>
    #[doc(hidden)]
    pub field_label_type: std::option::Option<crate::model::FieldLabelType>,
    /// <p>The option that specifies individual data values for labels.</p>
    #[doc(hidden)]
    pub data_path_label_type: std::option::Option<crate::model::DataPathLabelType>,
    /// <p>Determines the label configuration for range end value in a visual.</p>
    #[doc(hidden)]
    pub range_ends_label_type: std::option::Option<crate::model::RangeEndsLabelType>,
    /// <p>Determines the label configuration for the minimum value in a visual.</p>
    #[doc(hidden)]
    pub minimum_label_type: std::option::Option<crate::model::MinimumLabelType>,
    /// <p>Determines the label configuration for the maximum value in a visual.</p>
    #[doc(hidden)]
    pub maximum_label_type: std::option::Option<crate::model::MaximumLabelType>,
}
impl DataLabelType {
    /// <p>Determines the label configuration for the entire field.</p>
    pub fn field_label_type(&self) -> std::option::Option<&crate::model::FieldLabelType> {
        self.field_label_type.as_ref()
    }
    /// <p>The option that specifies individual data values for labels.</p>
    pub fn data_path_label_type(&self) -> std::option::Option<&crate::model::DataPathLabelType> {
        self.data_path_label_type.as_ref()
    }
    /// <p>Determines the label configuration for range end value in a visual.</p>
    pub fn range_ends_label_type(&self) -> std::option::Option<&crate::model::RangeEndsLabelType> {
        self.range_ends_label_type.as_ref()
    }
    /// <p>Determines the label configuration for the minimum value in a visual.</p>
    pub fn minimum_label_type(&self) -> std::option::Option<&crate::model::MinimumLabelType> {
        self.minimum_label_type.as_ref()
    }
    /// <p>Determines the label configuration for the maximum value in a visual.</p>
    pub fn maximum_label_type(&self) -> std::option::Option<&crate::model::MaximumLabelType> {
        self.maximum_label_type.as_ref()
    }
}
/// See [`DataLabelType`](crate::model::DataLabelType).
pub mod data_label_type {

    /// A builder for [`DataLabelType`](crate::model::DataLabelType).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_label_type: std::option::Option<crate::model::FieldLabelType>,
        pub(crate) data_path_label_type: std::option::Option<crate::model::DataPathLabelType>,
        pub(crate) range_ends_label_type: std::option::Option<crate::model::RangeEndsLabelType>,
        pub(crate) minimum_label_type: std::option::Option<crate::model::MinimumLabelType>,
        pub(crate) maximum_label_type: std::option::Option<crate::model::MaximumLabelType>,
    }
    impl Builder {
        /// <p>Determines the label configuration for the entire field.</p>
        pub fn field_label_type(mut self, input: crate::model::FieldLabelType) -> Self {
            self.field_label_type = Some(input);
            self
        }
        /// <p>Determines the label configuration for the entire field.</p>
        pub fn set_field_label_type(
            mut self,
            input: std::option::Option<crate::model::FieldLabelType>,
        ) -> Self {
            self.field_label_type = input;
            self
        }
        /// <p>The option that specifies individual data values for labels.</p>
        pub fn data_path_label_type(mut self, input: crate::model::DataPathLabelType) -> Self {
            self.data_path_label_type = Some(input);
            self
        }
        /// <p>The option that specifies individual data values for labels.</p>
        pub fn set_data_path_label_type(
            mut self,
            input: std::option::Option<crate::model::DataPathLabelType>,
        ) -> Self {
            self.data_path_label_type = input;
            self
        }
        /// <p>Determines the label configuration for range end value in a visual.</p>
        pub fn range_ends_label_type(mut self, input: crate::model::RangeEndsLabelType) -> Self {
            self.range_ends_label_type = Some(input);
            self
        }
        /// <p>Determines the label configuration for range end value in a visual.</p>
        pub fn set_range_ends_label_type(
            mut self,
            input: std::option::Option<crate::model::RangeEndsLabelType>,
        ) -> Self {
            self.range_ends_label_type = input;
            self
        }
        /// <p>Determines the label configuration for the minimum value in a visual.</p>
        pub fn minimum_label_type(mut self, input: crate::model::MinimumLabelType) -> Self {
            self.minimum_label_type = Some(input);
            self
        }
        /// <p>Determines the label configuration for the minimum value in a visual.</p>
        pub fn set_minimum_label_type(
            mut self,
            input: std::option::Option<crate::model::MinimumLabelType>,
        ) -> Self {
            self.minimum_label_type = input;
            self
        }
        /// <p>Determines the label configuration for the maximum value in a visual.</p>
        pub fn maximum_label_type(mut self, input: crate::model::MaximumLabelType) -> Self {
            self.maximum_label_type = Some(input);
            self
        }
        /// <p>Determines the label configuration for the maximum value in a visual.</p>
        pub fn set_maximum_label_type(
            mut self,
            input: std::option::Option<crate::model::MaximumLabelType>,
        ) -> Self {
            self.maximum_label_type = input;
            self
        }
        /// Consumes the builder and constructs a [`DataLabelType`](crate::model::DataLabelType).
        pub fn build(self) -> crate::model::DataLabelType {
            crate::model::DataLabelType {
                field_label_type: self.field_label_type,
                data_path_label_type: self.data_path_label_type,
                range_ends_label_type: self.range_ends_label_type,
                minimum_label_type: self.minimum_label_type,
                maximum_label_type: self.maximum_label_type,
            }
        }
    }
}
impl DataLabelType {
    /// Creates a new builder-style object to manufacture [`DataLabelType`](crate::model::DataLabelType).
    pub fn builder() -> crate::model::data_label_type::Builder {
        crate::model::data_label_type::Builder::default()
    }
}

/// <p>The maximum label of a data path label.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MaximumLabelType {
    /// <p>The visibility of the maximum label.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
}
impl MaximumLabelType {
    /// <p>The visibility of the maximum label.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
}
/// See [`MaximumLabelType`](crate::model::MaximumLabelType).
pub mod maximum_label_type {

    /// A builder for [`MaximumLabelType`](crate::model::MaximumLabelType).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>The visibility of the maximum label.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility of the maximum label.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumLabelType`](crate::model::MaximumLabelType).
        pub fn build(self) -> crate::model::MaximumLabelType {
            crate::model::MaximumLabelType {
                visibility: self.visibility,
            }
        }
    }
}
impl MaximumLabelType {
    /// Creates a new builder-style object to manufacture [`MaximumLabelType`](crate::model::MaximumLabelType).
    pub fn builder() -> crate::model::maximum_label_type::Builder {
        crate::model::maximum_label_type::Builder::default()
    }
}

/// <p>The minimum label of a data path label.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MinimumLabelType {
    /// <p>The visibility of the minimum label.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
}
impl MinimumLabelType {
    /// <p>The visibility of the minimum label.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
}
/// See [`MinimumLabelType`](crate::model::MinimumLabelType).
pub mod minimum_label_type {

    /// A builder for [`MinimumLabelType`](crate::model::MinimumLabelType).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>The visibility of the minimum label.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility of the minimum label.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`MinimumLabelType`](crate::model::MinimumLabelType).
        pub fn build(self) -> crate::model::MinimumLabelType {
            crate::model::MinimumLabelType {
                visibility: self.visibility,
            }
        }
    }
}
impl MinimumLabelType {
    /// Creates a new builder-style object to manufacture [`MinimumLabelType`](crate::model::MinimumLabelType).
    pub fn builder() -> crate::model::minimum_label_type::Builder {
        crate::model::minimum_label_type::Builder::default()
    }
}

/// <p>The range ends label type of a data path label.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RangeEndsLabelType {
    /// <p>The visibility of the range ends label.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
}
impl RangeEndsLabelType {
    /// <p>The visibility of the range ends label.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
}
/// See [`RangeEndsLabelType`](crate::model::RangeEndsLabelType).
pub mod range_ends_label_type {

    /// A builder for [`RangeEndsLabelType`](crate::model::RangeEndsLabelType).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>The visibility of the range ends label.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility of the range ends label.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`RangeEndsLabelType`](crate::model::RangeEndsLabelType).
        pub fn build(self) -> crate::model::RangeEndsLabelType {
            crate::model::RangeEndsLabelType {
                visibility: self.visibility,
            }
        }
    }
}
impl RangeEndsLabelType {
    /// Creates a new builder-style object to manufacture [`RangeEndsLabelType`](crate::model::RangeEndsLabelType).
    pub fn builder() -> crate::model::range_ends_label_type::Builder {
        crate::model::range_ends_label_type::Builder::default()
    }
}

/// <p>The option that specifies individual data values for labels.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataPathLabelType {
    /// <p>The field ID of the field that the data label needs to be applied to.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The actual value of the field that is labeled.</p>
    #[doc(hidden)]
    pub field_value: std::option::Option<std::string::String>,
    /// <p>The visibility of the data label.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
}
impl DataPathLabelType {
    /// <p>The field ID of the field that the data label needs to be applied to.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The actual value of the field that is labeled.</p>
    pub fn field_value(&self) -> std::option::Option<&str> {
        self.field_value.as_deref()
    }
    /// <p>The visibility of the data label.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
}
impl std::fmt::Debug for DataPathLabelType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataPathLabelType");
        formatter.field("field_id", &self.field_id);
        formatter.field("field_value", &"*** Sensitive Data Redacted ***");
        formatter.field("visibility", &self.visibility);
        formatter.finish()
    }
}
/// See [`DataPathLabelType`](crate::model::DataPathLabelType).
pub mod data_path_label_type {

    /// A builder for [`DataPathLabelType`](crate::model::DataPathLabelType).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) field_value: std::option::Option<std::string::String>,
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>The field ID of the field that the data label needs to be applied to.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The field ID of the field that the data label needs to be applied to.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The actual value of the field that is labeled.</p>
        pub fn field_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_value = Some(input.into());
            self
        }
        /// <p>The actual value of the field that is labeled.</p>
        pub fn set_field_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_value = input;
            self
        }
        /// <p>The visibility of the data label.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility of the data label.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`DataPathLabelType`](crate::model::DataPathLabelType).
        pub fn build(self) -> crate::model::DataPathLabelType {
            crate::model::DataPathLabelType {
                field_id: self.field_id,
                field_value: self.field_value,
                visibility: self.visibility,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("field_id", &self.field_id);
            formatter.field("field_value", &"*** Sensitive Data Redacted ***");
            formatter.field("visibility", &self.visibility);
            formatter.finish()
        }
    }
}
impl DataPathLabelType {
    /// Creates a new builder-style object to manufacture [`DataPathLabelType`](crate::model::DataPathLabelType).
    pub fn builder() -> crate::model::data_path_label_type::Builder {
        crate::model::data_path_label_type::Builder::default()
    }
}

/// <p>The field label type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldLabelType {
    /// <p>Indicates the field that is targeted by the field label.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The visibility of the field label.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
}
impl FieldLabelType {
    /// <p>Indicates the field that is targeted by the field label.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The visibility of the field label.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
}
/// See [`FieldLabelType`](crate::model::FieldLabelType).
pub mod field_label_type {

    /// A builder for [`FieldLabelType`](crate::model::FieldLabelType).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>Indicates the field that is targeted by the field label.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>Indicates the field that is targeted by the field label.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The visibility of the field label.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility of the field label.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldLabelType`](crate::model::FieldLabelType).
        pub fn build(self) -> crate::model::FieldLabelType {
            crate::model::FieldLabelType {
                field_id: self.field_id,
                visibility: self.visibility,
            }
        }
    }
}
impl FieldLabelType {
    /// Creates a new builder-style object to manufacture [`FieldLabelType`](crate::model::FieldLabelType).
    pub fn builder() -> crate::model::field_label_type::Builder {
        crate::model::field_label_type::Builder::default()
    }
}

/// <p>The sort configuration of a sankey diagram.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SankeyDiagramSortConfiguration {
    /// <p>The sort configuration of the weight fields.</p>
    #[doc(hidden)]
    pub weight_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    /// <p>The limit on the number of source nodes that are displayed in a sankey diagram.</p>
    #[doc(hidden)]
    pub source_items_limit: std::option::Option<crate::model::ItemsLimitConfiguration>,
    /// <p>The limit on the number of destination nodes that are displayed in a sankey diagram.</p>
    #[doc(hidden)]
    pub destination_items_limit: std::option::Option<crate::model::ItemsLimitConfiguration>,
}
impl SankeyDiagramSortConfiguration {
    /// <p>The sort configuration of the weight fields.</p>
    pub fn weight_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.weight_sort.as_deref()
    }
    /// <p>The limit on the number of source nodes that are displayed in a sankey diagram.</p>
    pub fn source_items_limit(
        &self,
    ) -> std::option::Option<&crate::model::ItemsLimitConfiguration> {
        self.source_items_limit.as_ref()
    }
    /// <p>The limit on the number of destination nodes that are displayed in a sankey diagram.</p>
    pub fn destination_items_limit(
        &self,
    ) -> std::option::Option<&crate::model::ItemsLimitConfiguration> {
        self.destination_items_limit.as_ref()
    }
}
/// See [`SankeyDiagramSortConfiguration`](crate::model::SankeyDiagramSortConfiguration).
pub mod sankey_diagram_sort_configuration {

    /// A builder for [`SankeyDiagramSortConfiguration`](crate::model::SankeyDiagramSortConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) weight_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        pub(crate) source_items_limit: std::option::Option<crate::model::ItemsLimitConfiguration>,
        pub(crate) destination_items_limit:
            std::option::Option<crate::model::ItemsLimitConfiguration>,
    }
    impl Builder {
        /// Appends an item to `weight_sort`.
        ///
        /// To override the contents of this collection use [`set_weight_sort`](Self::set_weight_sort).
        ///
        /// <p>The sort configuration of the weight fields.</p>
        pub fn weight_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.weight_sort.unwrap_or_default();
            v.push(input);
            self.weight_sort = Some(v);
            self
        }
        /// <p>The sort configuration of the weight fields.</p>
        pub fn set_weight_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.weight_sort = input;
            self
        }
        /// <p>The limit on the number of source nodes that are displayed in a sankey diagram.</p>
        pub fn source_items_limit(mut self, input: crate::model::ItemsLimitConfiguration) -> Self {
            self.source_items_limit = Some(input);
            self
        }
        /// <p>The limit on the number of source nodes that are displayed in a sankey diagram.</p>
        pub fn set_source_items_limit(
            mut self,
            input: std::option::Option<crate::model::ItemsLimitConfiguration>,
        ) -> Self {
            self.source_items_limit = input;
            self
        }
        /// <p>The limit on the number of destination nodes that are displayed in a sankey diagram.</p>
        pub fn destination_items_limit(
            mut self,
            input: crate::model::ItemsLimitConfiguration,
        ) -> Self {
            self.destination_items_limit = Some(input);
            self
        }
        /// <p>The limit on the number of destination nodes that are displayed in a sankey diagram.</p>
        pub fn set_destination_items_limit(
            mut self,
            input: std::option::Option<crate::model::ItemsLimitConfiguration>,
        ) -> Self {
            self.destination_items_limit = input;
            self
        }
        /// Consumes the builder and constructs a [`SankeyDiagramSortConfiguration`](crate::model::SankeyDiagramSortConfiguration).
        pub fn build(self) -> crate::model::SankeyDiagramSortConfiguration {
            crate::model::SankeyDiagramSortConfiguration {
                weight_sort: self.weight_sort,
                source_items_limit: self.source_items_limit,
                destination_items_limit: self.destination_items_limit,
            }
        }
    }
}
impl SankeyDiagramSortConfiguration {
    /// Creates a new builder-style object to manufacture [`SankeyDiagramSortConfiguration`](crate::model::SankeyDiagramSortConfiguration).
    pub fn builder() -> crate::model::sankey_diagram_sort_configuration::Builder {
        crate::model::sankey_diagram_sort_configuration::Builder::default()
    }
}

/// <p>The limit configuration of the visual display for an axis.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ItemsLimitConfiguration {
    /// <p>The limit on how many items of a field are showed in the chart. For example, the number of slices that are displayed in a pie chart.</p>
    #[doc(hidden)]
    pub items_limit: std::option::Option<i64>,
    /// <p>The <code>Show other</code> of an axis in the chart. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>INCLUDE</code> </p> </li>
    /// <li> <p> <code>EXCLUDE</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub other_categories: std::option::Option<crate::model::OtherCategories>,
}
impl ItemsLimitConfiguration {
    /// <p>The limit on how many items of a field are showed in the chart. For example, the number of slices that are displayed in a pie chart.</p>
    pub fn items_limit(&self) -> std::option::Option<i64> {
        self.items_limit
    }
    /// <p>The <code>Show other</code> of an axis in the chart. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>INCLUDE</code> </p> </li>
    /// <li> <p> <code>EXCLUDE</code> </p> </li>
    /// </ul>
    pub fn other_categories(&self) -> std::option::Option<&crate::model::OtherCategories> {
        self.other_categories.as_ref()
    }
}
/// See [`ItemsLimitConfiguration`](crate::model::ItemsLimitConfiguration).
pub mod items_limit_configuration {

    /// A builder for [`ItemsLimitConfiguration`](crate::model::ItemsLimitConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items_limit: std::option::Option<i64>,
        pub(crate) other_categories: std::option::Option<crate::model::OtherCategories>,
    }
    impl Builder {
        /// <p>The limit on how many items of a field are showed in the chart. For example, the number of slices that are displayed in a pie chart.</p>
        pub fn items_limit(mut self, input: i64) -> Self {
            self.items_limit = Some(input);
            self
        }
        /// <p>The limit on how many items of a field are showed in the chart. For example, the number of slices that are displayed in a pie chart.</p>
        pub fn set_items_limit(mut self, input: std::option::Option<i64>) -> Self {
            self.items_limit = input;
            self
        }
        /// <p>The <code>Show other</code> of an axis in the chart. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>INCLUDE</code> </p> </li>
        /// <li> <p> <code>EXCLUDE</code> </p> </li>
        /// </ul>
        pub fn other_categories(mut self, input: crate::model::OtherCategories) -> Self {
            self.other_categories = Some(input);
            self
        }
        /// <p>The <code>Show other</code> of an axis in the chart. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>INCLUDE</code> </p> </li>
        /// <li> <p> <code>EXCLUDE</code> </p> </li>
        /// </ul>
        pub fn set_other_categories(
            mut self,
            input: std::option::Option<crate::model::OtherCategories>,
        ) -> Self {
            self.other_categories = input;
            self
        }
        /// Consumes the builder and constructs a [`ItemsLimitConfiguration`](crate::model::ItemsLimitConfiguration).
        pub fn build(self) -> crate::model::ItemsLimitConfiguration {
            crate::model::ItemsLimitConfiguration {
                items_limit: self.items_limit,
                other_categories: self.other_categories,
            }
        }
    }
}
impl ItemsLimitConfiguration {
    /// Creates a new builder-style object to manufacture [`ItemsLimitConfiguration`](crate::model::ItemsLimitConfiguration).
    pub fn builder() -> crate::model::items_limit_configuration::Builder {
        crate::model::items_limit_configuration::Builder::default()
    }
}

/// When writing a match expression against `OtherCategories`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let othercategories = unimplemented!();
/// match othercategories {
///     OtherCategories::Exclude => { /* ... */ },
///     OtherCategories::Include => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `othercategories` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OtherCategories::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OtherCategories::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OtherCategories::NewFeature` is defined.
/// Specifically, when `othercategories` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OtherCategories::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OtherCategories {
    #[allow(missing_docs)] // documentation missing in model
    Exclude,
    #[allow(missing_docs)] // documentation missing in model
    Include,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OtherCategories {
    fn from(s: &str) -> Self {
        match s {
            "EXCLUDE" => OtherCategories::Exclude,
            "INCLUDE" => OtherCategories::Include,
            other => OtherCategories::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for OtherCategories {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OtherCategories::from(s))
    }
}
impl OtherCategories {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OtherCategories::Exclude => "EXCLUDE",
            OtherCategories::Include => "INCLUDE",
            OtherCategories::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EXCLUDE", "INCLUDE"]
    }
}
impl AsRef<str> for OtherCategories {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The field sort options in a chart configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldSortOptions {
    /// <p>The sort configuration for a field in a field well.</p>
    #[doc(hidden)]
    pub field_sort: std::option::Option<crate::model::FieldSort>,
    /// <p>The sort configuration for a column that is not used in a field well.</p>
    #[doc(hidden)]
    pub column_sort: std::option::Option<crate::model::ColumnSort>,
}
impl FieldSortOptions {
    /// <p>The sort configuration for a field in a field well.</p>
    pub fn field_sort(&self) -> std::option::Option<&crate::model::FieldSort> {
        self.field_sort.as_ref()
    }
    /// <p>The sort configuration for a column that is not used in a field well.</p>
    pub fn column_sort(&self) -> std::option::Option<&crate::model::ColumnSort> {
        self.column_sort.as_ref()
    }
}
/// See [`FieldSortOptions`](crate::model::FieldSortOptions).
pub mod field_sort_options {

    /// A builder for [`FieldSortOptions`](crate::model::FieldSortOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_sort: std::option::Option<crate::model::FieldSort>,
        pub(crate) column_sort: std::option::Option<crate::model::ColumnSort>,
    }
    impl Builder {
        /// <p>The sort configuration for a field in a field well.</p>
        pub fn field_sort(mut self, input: crate::model::FieldSort) -> Self {
            self.field_sort = Some(input);
            self
        }
        /// <p>The sort configuration for a field in a field well.</p>
        pub fn set_field_sort(
            mut self,
            input: std::option::Option<crate::model::FieldSort>,
        ) -> Self {
            self.field_sort = input;
            self
        }
        /// <p>The sort configuration for a column that is not used in a field well.</p>
        pub fn column_sort(mut self, input: crate::model::ColumnSort) -> Self {
            self.column_sort = Some(input);
            self
        }
        /// <p>The sort configuration for a column that is not used in a field well.</p>
        pub fn set_column_sort(
            mut self,
            input: std::option::Option<crate::model::ColumnSort>,
        ) -> Self {
            self.column_sort = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldSortOptions`](crate::model::FieldSortOptions).
        pub fn build(self) -> crate::model::FieldSortOptions {
            crate::model::FieldSortOptions {
                field_sort: self.field_sort,
                column_sort: self.column_sort,
            }
        }
    }
}
impl FieldSortOptions {
    /// Creates a new builder-style object to manufacture [`FieldSortOptions`](crate::model::FieldSortOptions).
    pub fn builder() -> crate::model::field_sort_options::Builder {
        crate::model::field_sort_options::Builder::default()
    }
}

/// <p>The sort configuration for a column that is not used in a field well.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnSort {
    /// <p>A column of a data set.</p>
    #[doc(hidden)]
    pub sort_by: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The sort direction.</p>
    #[doc(hidden)]
    pub direction: std::option::Option<crate::model::SortDirection>,
    /// <p>The aggregation function that is defined in the column sort.</p>
    #[doc(hidden)]
    pub aggregation_function: std::option::Option<crate::model::AggregationFunction>,
}
impl ColumnSort {
    /// <p>A column of a data set.</p>
    pub fn sort_by(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.sort_by.as_ref()
    }
    /// <p>The sort direction.</p>
    pub fn direction(&self) -> std::option::Option<&crate::model::SortDirection> {
        self.direction.as_ref()
    }
    /// <p>The aggregation function that is defined in the column sort.</p>
    pub fn aggregation_function(&self) -> std::option::Option<&crate::model::AggregationFunction> {
        self.aggregation_function.as_ref()
    }
}
/// See [`ColumnSort`](crate::model::ColumnSort).
pub mod column_sort {

    /// A builder for [`ColumnSort`](crate::model::ColumnSort).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sort_by: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) direction: std::option::Option<crate::model::SortDirection>,
        pub(crate) aggregation_function: std::option::Option<crate::model::AggregationFunction>,
    }
    impl Builder {
        /// <p>A column of a data set.</p>
        pub fn sort_by(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.sort_by = Some(input);
            self
        }
        /// <p>A column of a data set.</p>
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.sort_by = input;
            self
        }
        /// <p>The sort direction.</p>
        pub fn direction(mut self, input: crate::model::SortDirection) -> Self {
            self.direction = Some(input);
            self
        }
        /// <p>The sort direction.</p>
        pub fn set_direction(
            mut self,
            input: std::option::Option<crate::model::SortDirection>,
        ) -> Self {
            self.direction = input;
            self
        }
        /// <p>The aggregation function that is defined in the column sort.</p>
        pub fn aggregation_function(mut self, input: crate::model::AggregationFunction) -> Self {
            self.aggregation_function = Some(input);
            self
        }
        /// <p>The aggregation function that is defined in the column sort.</p>
        pub fn set_aggregation_function(
            mut self,
            input: std::option::Option<crate::model::AggregationFunction>,
        ) -> Self {
            self.aggregation_function = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnSort`](crate::model::ColumnSort).
        pub fn build(self) -> crate::model::ColumnSort {
            crate::model::ColumnSort {
                sort_by: self.sort_by,
                direction: self.direction,
                aggregation_function: self.aggregation_function,
            }
        }
    }
}
impl ColumnSort {
    /// Creates a new builder-style object to manufacture [`ColumnSort`](crate::model::ColumnSort).
    pub fn builder() -> crate::model::column_sort::Builder {
        crate::model::column_sort::Builder::default()
    }
}

/// <p>The sort configuration for a field in a field well.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldSort {
    /// <p>The sort configuration target field.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The sort direction. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>ASC</code>: Ascending</p> </li>
    /// <li> <p> <code>DESC</code>: Descending</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub direction: std::option::Option<crate::model::SortDirection>,
}
impl FieldSort {
    /// <p>The sort configuration target field.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The sort direction. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>ASC</code>: Ascending</p> </li>
    /// <li> <p> <code>DESC</code>: Descending</p> </li>
    /// </ul>
    pub fn direction(&self) -> std::option::Option<&crate::model::SortDirection> {
        self.direction.as_ref()
    }
}
/// See [`FieldSort`](crate::model::FieldSort).
pub mod field_sort {

    /// A builder for [`FieldSort`](crate::model::FieldSort).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) direction: std::option::Option<crate::model::SortDirection>,
    }
    impl Builder {
        /// <p>The sort configuration target field.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The sort configuration target field.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The sort direction. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>ASC</code>: Ascending</p> </li>
        /// <li> <p> <code>DESC</code>: Descending</p> </li>
        /// </ul>
        pub fn direction(mut self, input: crate::model::SortDirection) -> Self {
            self.direction = Some(input);
            self
        }
        /// <p>The sort direction. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>ASC</code>: Ascending</p> </li>
        /// <li> <p> <code>DESC</code>: Descending</p> </li>
        /// </ul>
        pub fn set_direction(
            mut self,
            input: std::option::Option<crate::model::SortDirection>,
        ) -> Self {
            self.direction = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldSort`](crate::model::FieldSort).
        pub fn build(self) -> crate::model::FieldSort {
            crate::model::FieldSort {
                field_id: self.field_id,
                direction: self.direction,
            }
        }
    }
}
impl FieldSort {
    /// Creates a new builder-style object to manufacture [`FieldSort`](crate::model::FieldSort).
    pub fn builder() -> crate::model::field_sort::Builder {
        crate::model::field_sort::Builder::default()
    }
}

/// <p>The field well configuration of a sankey diagram.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SankeyDiagramFieldWells {
    /// <p>The field well configuration of a sankey diagram.</p>
    #[doc(hidden)]
    pub sankey_diagram_aggregated_field_wells:
        std::option::Option<crate::model::SankeyDiagramAggregatedFieldWells>,
}
impl SankeyDiagramFieldWells {
    /// <p>The field well configuration of a sankey diagram.</p>
    pub fn sankey_diagram_aggregated_field_wells(
        &self,
    ) -> std::option::Option<&crate::model::SankeyDiagramAggregatedFieldWells> {
        self.sankey_diagram_aggregated_field_wells.as_ref()
    }
}
/// See [`SankeyDiagramFieldWells`](crate::model::SankeyDiagramFieldWells).
pub mod sankey_diagram_field_wells {

    /// A builder for [`SankeyDiagramFieldWells`](crate::model::SankeyDiagramFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sankey_diagram_aggregated_field_wells:
            std::option::Option<crate::model::SankeyDiagramAggregatedFieldWells>,
    }
    impl Builder {
        /// <p>The field well configuration of a sankey diagram.</p>
        pub fn sankey_diagram_aggregated_field_wells(
            mut self,
            input: crate::model::SankeyDiagramAggregatedFieldWells,
        ) -> Self {
            self.sankey_diagram_aggregated_field_wells = Some(input);
            self
        }
        /// <p>The field well configuration of a sankey diagram.</p>
        pub fn set_sankey_diagram_aggregated_field_wells(
            mut self,
            input: std::option::Option<crate::model::SankeyDiagramAggregatedFieldWells>,
        ) -> Self {
            self.sankey_diagram_aggregated_field_wells = input;
            self
        }
        /// Consumes the builder and constructs a [`SankeyDiagramFieldWells`](crate::model::SankeyDiagramFieldWells).
        pub fn build(self) -> crate::model::SankeyDiagramFieldWells {
            crate::model::SankeyDiagramFieldWells {
                sankey_diagram_aggregated_field_wells: self.sankey_diagram_aggregated_field_wells,
            }
        }
    }
}
impl SankeyDiagramFieldWells {
    /// Creates a new builder-style object to manufacture [`SankeyDiagramFieldWells`](crate::model::SankeyDiagramFieldWells).
    pub fn builder() -> crate::model::sankey_diagram_field_wells::Builder {
        crate::model::sankey_diagram_field_wells::Builder::default()
    }
}

/// <p>The field well configuration of a sankey diagram.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SankeyDiagramAggregatedFieldWells {
    /// <p>The source field wells of a sankey diagram.</p>
    #[doc(hidden)]
    pub source: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The destination field wells of a sankey diagram.</p>
    #[doc(hidden)]
    pub destination: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The weight field wells of a sankey diagram.</p>
    #[doc(hidden)]
    pub weight: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
}
impl SankeyDiagramAggregatedFieldWells {
    /// <p>The source field wells of a sankey diagram.</p>
    pub fn source(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.source.as_deref()
    }
    /// <p>The destination field wells of a sankey diagram.</p>
    pub fn destination(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.destination.as_deref()
    }
    /// <p>The weight field wells of a sankey diagram.</p>
    pub fn weight(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.weight.as_deref()
    }
}
/// See [`SankeyDiagramAggregatedFieldWells`](crate::model::SankeyDiagramAggregatedFieldWells).
pub mod sankey_diagram_aggregated_field_wells {

    /// A builder for [`SankeyDiagramAggregatedFieldWells`](crate::model::SankeyDiagramAggregatedFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) destination: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) weight: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    }
    impl Builder {
        /// Appends an item to `source`.
        ///
        /// To override the contents of this collection use [`set_source`](Self::set_source).
        ///
        /// <p>The source field wells of a sankey diagram.</p>
        pub fn source(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.source.unwrap_or_default();
            v.push(input);
            self.source = Some(v);
            self
        }
        /// <p>The source field wells of a sankey diagram.</p>
        pub fn set_source(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.source = input;
            self
        }
        /// Appends an item to `destination`.
        ///
        /// To override the contents of this collection use [`set_destination`](Self::set_destination).
        ///
        /// <p>The destination field wells of a sankey diagram.</p>
        pub fn destination(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.destination.unwrap_or_default();
            v.push(input);
            self.destination = Some(v);
            self
        }
        /// <p>The destination field wells of a sankey diagram.</p>
        pub fn set_destination(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.destination = input;
            self
        }
        /// Appends an item to `weight`.
        ///
        /// To override the contents of this collection use [`set_weight`](Self::set_weight).
        ///
        /// <p>The weight field wells of a sankey diagram.</p>
        pub fn weight(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.weight.unwrap_or_default();
            v.push(input);
            self.weight = Some(v);
            self
        }
        /// <p>The weight field wells of a sankey diagram.</p>
        pub fn set_weight(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.weight = input;
            self
        }
        /// Consumes the builder and constructs a [`SankeyDiagramAggregatedFieldWells`](crate::model::SankeyDiagramAggregatedFieldWells).
        pub fn build(self) -> crate::model::SankeyDiagramAggregatedFieldWells {
            crate::model::SankeyDiagramAggregatedFieldWells {
                source: self.source,
                destination: self.destination,
                weight: self.weight,
            }
        }
    }
}
impl SankeyDiagramAggregatedFieldWells {
    /// Creates a new builder-style object to manufacture [`SankeyDiagramAggregatedFieldWells`](crate::model::SankeyDiagramAggregatedFieldWells).
    pub fn builder() -> crate::model::sankey_diagram_aggregated_field_wells::Builder {
        crate::model::sankey_diagram_aggregated_field_wells::Builder::default()
    }
}

/// <p>The measure (metric) type field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MeasureField {
    /// <p>The measure type field with numerical type columns.</p>
    #[doc(hidden)]
    pub numerical_measure_field: std::option::Option<crate::model::NumericalMeasureField>,
    /// <p>The measure type field with categorical type columns.</p>
    #[doc(hidden)]
    pub categorical_measure_field: std::option::Option<crate::model::CategoricalMeasureField>,
    /// <p>The measure type field with date type columns.</p>
    #[doc(hidden)]
    pub date_measure_field: std::option::Option<crate::model::DateMeasureField>,
    /// <p>The calculated measure field only used in pivot tables.</p>
    #[doc(hidden)]
    pub calculated_measure_field: std::option::Option<crate::model::CalculatedMeasureField>,
}
impl MeasureField {
    /// <p>The measure type field with numerical type columns.</p>
    pub fn numerical_measure_field(
        &self,
    ) -> std::option::Option<&crate::model::NumericalMeasureField> {
        self.numerical_measure_field.as_ref()
    }
    /// <p>The measure type field with categorical type columns.</p>
    pub fn categorical_measure_field(
        &self,
    ) -> std::option::Option<&crate::model::CategoricalMeasureField> {
        self.categorical_measure_field.as_ref()
    }
    /// <p>The measure type field with date type columns.</p>
    pub fn date_measure_field(&self) -> std::option::Option<&crate::model::DateMeasureField> {
        self.date_measure_field.as_ref()
    }
    /// <p>The calculated measure field only used in pivot tables.</p>
    pub fn calculated_measure_field(
        &self,
    ) -> std::option::Option<&crate::model::CalculatedMeasureField> {
        self.calculated_measure_field.as_ref()
    }
}
/// See [`MeasureField`](crate::model::MeasureField).
pub mod measure_field {

    /// A builder for [`MeasureField`](crate::model::MeasureField).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) numerical_measure_field:
            std::option::Option<crate::model::NumericalMeasureField>,
        pub(crate) categorical_measure_field:
            std::option::Option<crate::model::CategoricalMeasureField>,
        pub(crate) date_measure_field: std::option::Option<crate::model::DateMeasureField>,
        pub(crate) calculated_measure_field:
            std::option::Option<crate::model::CalculatedMeasureField>,
    }
    impl Builder {
        /// <p>The measure type field with numerical type columns.</p>
        pub fn numerical_measure_field(
            mut self,
            input: crate::model::NumericalMeasureField,
        ) -> Self {
            self.numerical_measure_field = Some(input);
            self
        }
        /// <p>The measure type field with numerical type columns.</p>
        pub fn set_numerical_measure_field(
            mut self,
            input: std::option::Option<crate::model::NumericalMeasureField>,
        ) -> Self {
            self.numerical_measure_field = input;
            self
        }
        /// <p>The measure type field with categorical type columns.</p>
        pub fn categorical_measure_field(
            mut self,
            input: crate::model::CategoricalMeasureField,
        ) -> Self {
            self.categorical_measure_field = Some(input);
            self
        }
        /// <p>The measure type field with categorical type columns.</p>
        pub fn set_categorical_measure_field(
            mut self,
            input: std::option::Option<crate::model::CategoricalMeasureField>,
        ) -> Self {
            self.categorical_measure_field = input;
            self
        }
        /// <p>The measure type field with date type columns.</p>
        pub fn date_measure_field(mut self, input: crate::model::DateMeasureField) -> Self {
            self.date_measure_field = Some(input);
            self
        }
        /// <p>The measure type field with date type columns.</p>
        pub fn set_date_measure_field(
            mut self,
            input: std::option::Option<crate::model::DateMeasureField>,
        ) -> Self {
            self.date_measure_field = input;
            self
        }
        /// <p>The calculated measure field only used in pivot tables.</p>
        pub fn calculated_measure_field(
            mut self,
            input: crate::model::CalculatedMeasureField,
        ) -> Self {
            self.calculated_measure_field = Some(input);
            self
        }
        /// <p>The calculated measure field only used in pivot tables.</p>
        pub fn set_calculated_measure_field(
            mut self,
            input: std::option::Option<crate::model::CalculatedMeasureField>,
        ) -> Self {
            self.calculated_measure_field = input;
            self
        }
        /// Consumes the builder and constructs a [`MeasureField`](crate::model::MeasureField).
        pub fn build(self) -> crate::model::MeasureField {
            crate::model::MeasureField {
                numerical_measure_field: self.numerical_measure_field,
                categorical_measure_field: self.categorical_measure_field,
                date_measure_field: self.date_measure_field,
                calculated_measure_field: self.calculated_measure_field,
            }
        }
    }
}
impl MeasureField {
    /// Creates a new builder-style object to manufacture [`MeasureField`](crate::model::MeasureField).
    pub fn builder() -> crate::model::measure_field::Builder {
        crate::model::measure_field::Builder::default()
    }
}

/// <p>The table calculation measure field for pivot tables.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CalculatedMeasureField {
    /// <p>The custom field ID.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The expression in the table calculation.</p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::string::String>,
}
impl CalculatedMeasureField {
    /// <p>The custom field ID.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The expression in the table calculation.</p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
}
impl std::fmt::Debug for CalculatedMeasureField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CalculatedMeasureField");
        formatter.field("field_id", &self.field_id);
        formatter.field("expression", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`CalculatedMeasureField`](crate::model::CalculatedMeasureField).
pub mod calculated_measure_field {

    /// A builder for [`CalculatedMeasureField`](crate::model::CalculatedMeasureField).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) expression: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The custom field ID.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The custom field ID.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The expression in the table calculation.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>The expression in the table calculation.</p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// Consumes the builder and constructs a [`CalculatedMeasureField`](crate::model::CalculatedMeasureField).
        pub fn build(self) -> crate::model::CalculatedMeasureField {
            crate::model::CalculatedMeasureField {
                field_id: self.field_id,
                expression: self.expression,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("field_id", &self.field_id);
            formatter.field("expression", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl CalculatedMeasureField {
    /// Creates a new builder-style object to manufacture [`CalculatedMeasureField`](crate::model::CalculatedMeasureField).
    pub fn builder() -> crate::model::calculated_measure_field::Builder {
        crate::model::calculated_measure_field::Builder::default()
    }
}

/// <p>The measure type field with date type columns.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DateMeasureField {
    /// <p>The custom field ID.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The column that is used in the <code>DateMeasureField</code>.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The aggregation function of the measure field.</p>
    #[doc(hidden)]
    pub aggregation_function: std::option::Option<crate::model::DateAggregationFunction>,
    /// <p>The format configuration of the field.</p>
    #[doc(hidden)]
    pub format_configuration: std::option::Option<crate::model::DateTimeFormatConfiguration>,
}
impl DateMeasureField {
    /// <p>The custom field ID.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The column that is used in the <code>DateMeasureField</code>.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>The aggregation function of the measure field.</p>
    pub fn aggregation_function(
        &self,
    ) -> std::option::Option<&crate::model::DateAggregationFunction> {
        self.aggregation_function.as_ref()
    }
    /// <p>The format configuration of the field.</p>
    pub fn format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DateTimeFormatConfiguration> {
        self.format_configuration.as_ref()
    }
}
/// See [`DateMeasureField`](crate::model::DateMeasureField).
pub mod date_measure_field {

    /// A builder for [`DateMeasureField`](crate::model::DateMeasureField).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) aggregation_function: std::option::Option<crate::model::DateAggregationFunction>,
        pub(crate) format_configuration:
            std::option::Option<crate::model::DateTimeFormatConfiguration>,
    }
    impl Builder {
        /// <p>The custom field ID.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The custom field ID.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The column that is used in the <code>DateMeasureField</code>.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that is used in the <code>DateMeasureField</code>.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The aggregation function of the measure field.</p>
        pub fn aggregation_function(
            mut self,
            input: crate::model::DateAggregationFunction,
        ) -> Self {
            self.aggregation_function = Some(input);
            self
        }
        /// <p>The aggregation function of the measure field.</p>
        pub fn set_aggregation_function(
            mut self,
            input: std::option::Option<crate::model::DateAggregationFunction>,
        ) -> Self {
            self.aggregation_function = input;
            self
        }
        /// <p>The format configuration of the field.</p>
        pub fn format_configuration(
            mut self,
            input: crate::model::DateTimeFormatConfiguration,
        ) -> Self {
            self.format_configuration = Some(input);
            self
        }
        /// <p>The format configuration of the field.</p>
        pub fn set_format_configuration(
            mut self,
            input: std::option::Option<crate::model::DateTimeFormatConfiguration>,
        ) -> Self {
            self.format_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`DateMeasureField`](crate::model::DateMeasureField).
        pub fn build(self) -> crate::model::DateMeasureField {
            crate::model::DateMeasureField {
                field_id: self.field_id,
                column: self.column,
                aggregation_function: self.aggregation_function,
                format_configuration: self.format_configuration,
            }
        }
    }
}
impl DateMeasureField {
    /// Creates a new builder-style object to manufacture [`DateMeasureField`](crate::model::DateMeasureField).
    pub fn builder() -> crate::model::date_measure_field::Builder {
        crate::model::date_measure_field::Builder::default()
    }
}

/// <p>The measure type field with categorical type columns.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CategoricalMeasureField {
    /// <p>The custom field ID.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The column that is used in the <code>CategoricalMeasureField</code>.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The aggregation function of the measure field.</p>
    #[doc(hidden)]
    pub aggregation_function: std::option::Option<crate::model::CategoricalAggregationFunction>,
    /// <p>The format configuration of the field.</p>
    #[doc(hidden)]
    pub format_configuration: std::option::Option<crate::model::StringFormatConfiguration>,
}
impl CategoricalMeasureField {
    /// <p>The custom field ID.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The column that is used in the <code>CategoricalMeasureField</code>.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>The aggregation function of the measure field.</p>
    pub fn aggregation_function(
        &self,
    ) -> std::option::Option<&crate::model::CategoricalAggregationFunction> {
        self.aggregation_function.as_ref()
    }
    /// <p>The format configuration of the field.</p>
    pub fn format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::StringFormatConfiguration> {
        self.format_configuration.as_ref()
    }
}
/// See [`CategoricalMeasureField`](crate::model::CategoricalMeasureField).
pub mod categorical_measure_field {

    /// A builder for [`CategoricalMeasureField`](crate::model::CategoricalMeasureField).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) aggregation_function:
            std::option::Option<crate::model::CategoricalAggregationFunction>,
        pub(crate) format_configuration:
            std::option::Option<crate::model::StringFormatConfiguration>,
    }
    impl Builder {
        /// <p>The custom field ID.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The custom field ID.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The column that is used in the <code>CategoricalMeasureField</code>.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that is used in the <code>CategoricalMeasureField</code>.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The aggregation function of the measure field.</p>
        pub fn aggregation_function(
            mut self,
            input: crate::model::CategoricalAggregationFunction,
        ) -> Self {
            self.aggregation_function = Some(input);
            self
        }
        /// <p>The aggregation function of the measure field.</p>
        pub fn set_aggregation_function(
            mut self,
            input: std::option::Option<crate::model::CategoricalAggregationFunction>,
        ) -> Self {
            self.aggregation_function = input;
            self
        }
        /// <p>The format configuration of the field.</p>
        pub fn format_configuration(
            mut self,
            input: crate::model::StringFormatConfiguration,
        ) -> Self {
            self.format_configuration = Some(input);
            self
        }
        /// <p>The format configuration of the field.</p>
        pub fn set_format_configuration(
            mut self,
            input: std::option::Option<crate::model::StringFormatConfiguration>,
        ) -> Self {
            self.format_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`CategoricalMeasureField`](crate::model::CategoricalMeasureField).
        pub fn build(self) -> crate::model::CategoricalMeasureField {
            crate::model::CategoricalMeasureField {
                field_id: self.field_id,
                column: self.column,
                aggregation_function: self.aggregation_function,
                format_configuration: self.format_configuration,
            }
        }
    }
}
impl CategoricalMeasureField {
    /// Creates a new builder-style object to manufacture [`CategoricalMeasureField`](crate::model::CategoricalMeasureField).
    pub fn builder() -> crate::model::categorical_measure_field::Builder {
        crate::model::categorical_measure_field::Builder::default()
    }
}

/// <p>The measure type field with numerical type columns.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NumericalMeasureField {
    /// <p>The custom field ID.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The column that is used in the <code>NumericalMeasureField</code>.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The aggregation function of the measure field.</p>
    #[doc(hidden)]
    pub aggregation_function: std::option::Option<crate::model::NumericalAggregationFunction>,
    /// <p>The format configuration of the field.</p>
    #[doc(hidden)]
    pub format_configuration: std::option::Option<crate::model::NumberFormatConfiguration>,
}
impl NumericalMeasureField {
    /// <p>The custom field ID.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The column that is used in the <code>NumericalMeasureField</code>.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>The aggregation function of the measure field.</p>
    pub fn aggregation_function(
        &self,
    ) -> std::option::Option<&crate::model::NumericalAggregationFunction> {
        self.aggregation_function.as_ref()
    }
    /// <p>The format configuration of the field.</p>
    pub fn format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NumberFormatConfiguration> {
        self.format_configuration.as_ref()
    }
}
/// See [`NumericalMeasureField`](crate::model::NumericalMeasureField).
pub mod numerical_measure_field {

    /// A builder for [`NumericalMeasureField`](crate::model::NumericalMeasureField).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) aggregation_function:
            std::option::Option<crate::model::NumericalAggregationFunction>,
        pub(crate) format_configuration:
            std::option::Option<crate::model::NumberFormatConfiguration>,
    }
    impl Builder {
        /// <p>The custom field ID.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The custom field ID.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The column that is used in the <code>NumericalMeasureField</code>.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that is used in the <code>NumericalMeasureField</code>.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The aggregation function of the measure field.</p>
        pub fn aggregation_function(
            mut self,
            input: crate::model::NumericalAggregationFunction,
        ) -> Self {
            self.aggregation_function = Some(input);
            self
        }
        /// <p>The aggregation function of the measure field.</p>
        pub fn set_aggregation_function(
            mut self,
            input: std::option::Option<crate::model::NumericalAggregationFunction>,
        ) -> Self {
            self.aggregation_function = input;
            self
        }
        /// <p>The format configuration of the field.</p>
        pub fn format_configuration(
            mut self,
            input: crate::model::NumberFormatConfiguration,
        ) -> Self {
            self.format_configuration = Some(input);
            self
        }
        /// <p>The format configuration of the field.</p>
        pub fn set_format_configuration(
            mut self,
            input: std::option::Option<crate::model::NumberFormatConfiguration>,
        ) -> Self {
            self.format_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`NumericalMeasureField`](crate::model::NumericalMeasureField).
        pub fn build(self) -> crate::model::NumericalMeasureField {
            crate::model::NumericalMeasureField {
                field_id: self.field_id,
                column: self.column,
                aggregation_function: self.aggregation_function,
                format_configuration: self.format_configuration,
            }
        }
    }
}
impl NumericalMeasureField {
    /// Creates a new builder-style object to manufacture [`NumericalMeasureField`](crate::model::NumericalMeasureField).
    pub fn builder() -> crate::model::numerical_measure_field::Builder {
        crate::model::numerical_measure_field::Builder::default()
    }
}

/// <p>The dimension type field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DimensionField {
    /// <p>The dimension type field with numerical type columns.</p>
    #[doc(hidden)]
    pub numerical_dimension_field: std::option::Option<crate::model::NumericalDimensionField>,
    /// <p>The dimension type field with categorical type columns.</p>
    #[doc(hidden)]
    pub categorical_dimension_field: std::option::Option<crate::model::CategoricalDimensionField>,
    /// <p>The dimension type field with date type columns.</p>
    #[doc(hidden)]
    pub date_dimension_field: std::option::Option<crate::model::DateDimensionField>,
}
impl DimensionField {
    /// <p>The dimension type field with numerical type columns.</p>
    pub fn numerical_dimension_field(
        &self,
    ) -> std::option::Option<&crate::model::NumericalDimensionField> {
        self.numerical_dimension_field.as_ref()
    }
    /// <p>The dimension type field with categorical type columns.</p>
    pub fn categorical_dimension_field(
        &self,
    ) -> std::option::Option<&crate::model::CategoricalDimensionField> {
        self.categorical_dimension_field.as_ref()
    }
    /// <p>The dimension type field with date type columns.</p>
    pub fn date_dimension_field(&self) -> std::option::Option<&crate::model::DateDimensionField> {
        self.date_dimension_field.as_ref()
    }
}
/// See [`DimensionField`](crate::model::DimensionField).
pub mod dimension_field {

    /// A builder for [`DimensionField`](crate::model::DimensionField).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) numerical_dimension_field:
            std::option::Option<crate::model::NumericalDimensionField>,
        pub(crate) categorical_dimension_field:
            std::option::Option<crate::model::CategoricalDimensionField>,
        pub(crate) date_dimension_field: std::option::Option<crate::model::DateDimensionField>,
    }
    impl Builder {
        /// <p>The dimension type field with numerical type columns.</p>
        pub fn numerical_dimension_field(
            mut self,
            input: crate::model::NumericalDimensionField,
        ) -> Self {
            self.numerical_dimension_field = Some(input);
            self
        }
        /// <p>The dimension type field with numerical type columns.</p>
        pub fn set_numerical_dimension_field(
            mut self,
            input: std::option::Option<crate::model::NumericalDimensionField>,
        ) -> Self {
            self.numerical_dimension_field = input;
            self
        }
        /// <p>The dimension type field with categorical type columns.</p>
        pub fn categorical_dimension_field(
            mut self,
            input: crate::model::CategoricalDimensionField,
        ) -> Self {
            self.categorical_dimension_field = Some(input);
            self
        }
        /// <p>The dimension type field with categorical type columns.</p>
        pub fn set_categorical_dimension_field(
            mut self,
            input: std::option::Option<crate::model::CategoricalDimensionField>,
        ) -> Self {
            self.categorical_dimension_field = input;
            self
        }
        /// <p>The dimension type field with date type columns.</p>
        pub fn date_dimension_field(mut self, input: crate::model::DateDimensionField) -> Self {
            self.date_dimension_field = Some(input);
            self
        }
        /// <p>The dimension type field with date type columns.</p>
        pub fn set_date_dimension_field(
            mut self,
            input: std::option::Option<crate::model::DateDimensionField>,
        ) -> Self {
            self.date_dimension_field = input;
            self
        }
        /// Consumes the builder and constructs a [`DimensionField`](crate::model::DimensionField).
        pub fn build(self) -> crate::model::DimensionField {
            crate::model::DimensionField {
                numerical_dimension_field: self.numerical_dimension_field,
                categorical_dimension_field: self.categorical_dimension_field,
                date_dimension_field: self.date_dimension_field,
            }
        }
    }
}
impl DimensionField {
    /// Creates a new builder-style object to manufacture [`DimensionField`](crate::model::DimensionField).
    pub fn builder() -> crate::model::dimension_field::Builder {
        crate::model::dimension_field::Builder::default()
    }
}

/// <p>The dimension type field with date type columns.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DateDimensionField {
    /// <p>The custom field ID.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The column that is used in the <code>DateDimensionField</code>.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The date granularity of the <code>DateDimensionField</code>. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>YEAR</code> </p> </li>
    /// <li> <p> <code>QUARTER</code> </p> </li>
    /// <li> <p> <code>MONTH</code> </p> </li>
    /// <li> <p> <code>WEEK</code> </p> </li>
    /// <li> <p> <code>DAY</code> </p> </li>
    /// <li> <p> <code>HOUR</code> </p> </li>
    /// <li> <p> <code>MINUTE</code> </p> </li>
    /// <li> <p> <code>SECOND</code> </p> </li>
    /// <li> <p> <code>MILLISECOND</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub date_granularity: std::option::Option<crate::model::TimeGranularity>,
    /// <p>The custom hierarchy ID.</p>
    #[doc(hidden)]
    pub hierarchy_id: std::option::Option<std::string::String>,
    /// <p>The format configuration of the field.</p>
    #[doc(hidden)]
    pub format_configuration: std::option::Option<crate::model::DateTimeFormatConfiguration>,
}
impl DateDimensionField {
    /// <p>The custom field ID.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The column that is used in the <code>DateDimensionField</code>.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>The date granularity of the <code>DateDimensionField</code>. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>YEAR</code> </p> </li>
    /// <li> <p> <code>QUARTER</code> </p> </li>
    /// <li> <p> <code>MONTH</code> </p> </li>
    /// <li> <p> <code>WEEK</code> </p> </li>
    /// <li> <p> <code>DAY</code> </p> </li>
    /// <li> <p> <code>HOUR</code> </p> </li>
    /// <li> <p> <code>MINUTE</code> </p> </li>
    /// <li> <p> <code>SECOND</code> </p> </li>
    /// <li> <p> <code>MILLISECOND</code> </p> </li>
    /// </ul>
    pub fn date_granularity(&self) -> std::option::Option<&crate::model::TimeGranularity> {
        self.date_granularity.as_ref()
    }
    /// <p>The custom hierarchy ID.</p>
    pub fn hierarchy_id(&self) -> std::option::Option<&str> {
        self.hierarchy_id.as_deref()
    }
    /// <p>The format configuration of the field.</p>
    pub fn format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DateTimeFormatConfiguration> {
        self.format_configuration.as_ref()
    }
}
/// See [`DateDimensionField`](crate::model::DateDimensionField).
pub mod date_dimension_field {

    /// A builder for [`DateDimensionField`](crate::model::DateDimensionField).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) date_granularity: std::option::Option<crate::model::TimeGranularity>,
        pub(crate) hierarchy_id: std::option::Option<std::string::String>,
        pub(crate) format_configuration:
            std::option::Option<crate::model::DateTimeFormatConfiguration>,
    }
    impl Builder {
        /// <p>The custom field ID.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The custom field ID.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The column that is used in the <code>DateDimensionField</code>.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that is used in the <code>DateDimensionField</code>.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The date granularity of the <code>DateDimensionField</code>. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>YEAR</code> </p> </li>
        /// <li> <p> <code>QUARTER</code> </p> </li>
        /// <li> <p> <code>MONTH</code> </p> </li>
        /// <li> <p> <code>WEEK</code> </p> </li>
        /// <li> <p> <code>DAY</code> </p> </li>
        /// <li> <p> <code>HOUR</code> </p> </li>
        /// <li> <p> <code>MINUTE</code> </p> </li>
        /// <li> <p> <code>SECOND</code> </p> </li>
        /// <li> <p> <code>MILLISECOND</code> </p> </li>
        /// </ul>
        pub fn date_granularity(mut self, input: crate::model::TimeGranularity) -> Self {
            self.date_granularity = Some(input);
            self
        }
        /// <p>The date granularity of the <code>DateDimensionField</code>. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>YEAR</code> </p> </li>
        /// <li> <p> <code>QUARTER</code> </p> </li>
        /// <li> <p> <code>MONTH</code> </p> </li>
        /// <li> <p> <code>WEEK</code> </p> </li>
        /// <li> <p> <code>DAY</code> </p> </li>
        /// <li> <p> <code>HOUR</code> </p> </li>
        /// <li> <p> <code>MINUTE</code> </p> </li>
        /// <li> <p> <code>SECOND</code> </p> </li>
        /// <li> <p> <code>MILLISECOND</code> </p> </li>
        /// </ul>
        pub fn set_date_granularity(
            mut self,
            input: std::option::Option<crate::model::TimeGranularity>,
        ) -> Self {
            self.date_granularity = input;
            self
        }
        /// <p>The custom hierarchy ID.</p>
        pub fn hierarchy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hierarchy_id = Some(input.into());
            self
        }
        /// <p>The custom hierarchy ID.</p>
        pub fn set_hierarchy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hierarchy_id = input;
            self
        }
        /// <p>The format configuration of the field.</p>
        pub fn format_configuration(
            mut self,
            input: crate::model::DateTimeFormatConfiguration,
        ) -> Self {
            self.format_configuration = Some(input);
            self
        }
        /// <p>The format configuration of the field.</p>
        pub fn set_format_configuration(
            mut self,
            input: std::option::Option<crate::model::DateTimeFormatConfiguration>,
        ) -> Self {
            self.format_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`DateDimensionField`](crate::model::DateDimensionField).
        pub fn build(self) -> crate::model::DateDimensionField {
            crate::model::DateDimensionField {
                field_id: self.field_id,
                column: self.column,
                date_granularity: self.date_granularity,
                hierarchy_id: self.hierarchy_id,
                format_configuration: self.format_configuration,
            }
        }
    }
}
impl DateDimensionField {
    /// Creates a new builder-style object to manufacture [`DateDimensionField`](crate::model::DateDimensionField).
    pub fn builder() -> crate::model::date_dimension_field::Builder {
        crate::model::date_dimension_field::Builder::default()
    }
}

/// <p>The dimension type field with categorical type columns..</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CategoricalDimensionField {
    /// <p>The custom field ID.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The column that is used in the <code>CategoricalDimensionField</code>.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The custom hierarchy ID.</p>
    #[doc(hidden)]
    pub hierarchy_id: std::option::Option<std::string::String>,
    /// <p>The format configuration of the field.</p>
    #[doc(hidden)]
    pub format_configuration: std::option::Option<crate::model::StringFormatConfiguration>,
}
impl CategoricalDimensionField {
    /// <p>The custom field ID.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The column that is used in the <code>CategoricalDimensionField</code>.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>The custom hierarchy ID.</p>
    pub fn hierarchy_id(&self) -> std::option::Option<&str> {
        self.hierarchy_id.as_deref()
    }
    /// <p>The format configuration of the field.</p>
    pub fn format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::StringFormatConfiguration> {
        self.format_configuration.as_ref()
    }
}
/// See [`CategoricalDimensionField`](crate::model::CategoricalDimensionField).
pub mod categorical_dimension_field {

    /// A builder for [`CategoricalDimensionField`](crate::model::CategoricalDimensionField).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) hierarchy_id: std::option::Option<std::string::String>,
        pub(crate) format_configuration:
            std::option::Option<crate::model::StringFormatConfiguration>,
    }
    impl Builder {
        /// <p>The custom field ID.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The custom field ID.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The column that is used in the <code>CategoricalDimensionField</code>.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that is used in the <code>CategoricalDimensionField</code>.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The custom hierarchy ID.</p>
        pub fn hierarchy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hierarchy_id = Some(input.into());
            self
        }
        /// <p>The custom hierarchy ID.</p>
        pub fn set_hierarchy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hierarchy_id = input;
            self
        }
        /// <p>The format configuration of the field.</p>
        pub fn format_configuration(
            mut self,
            input: crate::model::StringFormatConfiguration,
        ) -> Self {
            self.format_configuration = Some(input);
            self
        }
        /// <p>The format configuration of the field.</p>
        pub fn set_format_configuration(
            mut self,
            input: std::option::Option<crate::model::StringFormatConfiguration>,
        ) -> Self {
            self.format_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`CategoricalDimensionField`](crate::model::CategoricalDimensionField).
        pub fn build(self) -> crate::model::CategoricalDimensionField {
            crate::model::CategoricalDimensionField {
                field_id: self.field_id,
                column: self.column,
                hierarchy_id: self.hierarchy_id,
                format_configuration: self.format_configuration,
            }
        }
    }
}
impl CategoricalDimensionField {
    /// Creates a new builder-style object to manufacture [`CategoricalDimensionField`](crate::model::CategoricalDimensionField).
    pub fn builder() -> crate::model::categorical_dimension_field::Builder {
        crate::model::categorical_dimension_field::Builder::default()
    }
}

/// <p>The dimension type field with numerical type columns.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NumericalDimensionField {
    /// <p>The custom field ID.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The column that is used in the <code>NumericalDimensionField</code>.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The custom hierarchy ID.</p>
    #[doc(hidden)]
    pub hierarchy_id: std::option::Option<std::string::String>,
    /// <p>The format configuration of the field.</p>
    #[doc(hidden)]
    pub format_configuration: std::option::Option<crate::model::NumberFormatConfiguration>,
}
impl NumericalDimensionField {
    /// <p>The custom field ID.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The column that is used in the <code>NumericalDimensionField</code>.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>The custom hierarchy ID.</p>
    pub fn hierarchy_id(&self) -> std::option::Option<&str> {
        self.hierarchy_id.as_deref()
    }
    /// <p>The format configuration of the field.</p>
    pub fn format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NumberFormatConfiguration> {
        self.format_configuration.as_ref()
    }
}
/// See [`NumericalDimensionField`](crate::model::NumericalDimensionField).
pub mod numerical_dimension_field {

    /// A builder for [`NumericalDimensionField`](crate::model::NumericalDimensionField).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) hierarchy_id: std::option::Option<std::string::String>,
        pub(crate) format_configuration:
            std::option::Option<crate::model::NumberFormatConfiguration>,
    }
    impl Builder {
        /// <p>The custom field ID.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The custom field ID.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The column that is used in the <code>NumericalDimensionField</code>.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that is used in the <code>NumericalDimensionField</code>.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The custom hierarchy ID.</p>
        pub fn hierarchy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hierarchy_id = Some(input.into());
            self
        }
        /// <p>The custom hierarchy ID.</p>
        pub fn set_hierarchy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hierarchy_id = input;
            self
        }
        /// <p>The format configuration of the field.</p>
        pub fn format_configuration(
            mut self,
            input: crate::model::NumberFormatConfiguration,
        ) -> Self {
            self.format_configuration = Some(input);
            self
        }
        /// <p>The format configuration of the field.</p>
        pub fn set_format_configuration(
            mut self,
            input: std::option::Option<crate::model::NumberFormatConfiguration>,
        ) -> Self {
            self.format_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`NumericalDimensionField`](crate::model::NumericalDimensionField).
        pub fn build(self) -> crate::model::NumericalDimensionField {
            crate::model::NumericalDimensionField {
                field_id: self.field_id,
                column: self.column,
                hierarchy_id: self.hierarchy_id,
                format_configuration: self.format_configuration,
            }
        }
    }
}
impl NumericalDimensionField {
    /// Creates a new builder-style object to manufacture [`NumericalDimensionField`](crate::model::NumericalDimensionField).
    pub fn builder() -> crate::model::numerical_dimension_field::Builder {
        crate::model::numerical_dimension_field::Builder::default()
    }
}

/// <p>An insight visual.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/computational-insights.html">Working with insights</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InsightVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration of an insight visual.</p>
    #[doc(hidden)]
    pub insight_configuration: std::option::Option<crate::model::InsightConfiguration>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    /// <p>The dataset that is used in the insight visual.</p>
    #[doc(hidden)]
    pub data_set_identifier: std::option::Option<std::string::String>,
}
impl InsightVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration of an insight visual.</p>
    pub fn insight_configuration(
        &self,
    ) -> std::option::Option<&crate::model::InsightConfiguration> {
        self.insight_configuration.as_ref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
    /// <p>The dataset that is used in the insight visual.</p>
    pub fn data_set_identifier(&self) -> std::option::Option<&str> {
        self.data_set_identifier.as_deref()
    }
}
/// See [`InsightVisual`](crate::model::InsightVisual).
pub mod insight_visual {

    /// A builder for [`InsightVisual`](crate::model::InsightVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) insight_configuration: std::option::Option<crate::model::InsightConfiguration>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        pub(crate) data_set_identifier: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration of an insight visual.</p>
        pub fn insight_configuration(mut self, input: crate::model::InsightConfiguration) -> Self {
            self.insight_configuration = Some(input);
            self
        }
        /// <p>The configuration of an insight visual.</p>
        pub fn set_insight_configuration(
            mut self,
            input: std::option::Option<crate::model::InsightConfiguration>,
        ) -> Self {
            self.insight_configuration = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// <p>The dataset that is used in the insight visual.</p>
        pub fn data_set_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_set_identifier = Some(input.into());
            self
        }
        /// <p>The dataset that is used in the insight visual.</p>
        pub fn set_data_set_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_set_identifier = input;
            self
        }
        /// Consumes the builder and constructs a [`InsightVisual`](crate::model::InsightVisual).
        pub fn build(self) -> crate::model::InsightVisual {
            crate::model::InsightVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                insight_configuration: self.insight_configuration,
                actions: self.actions,
                data_set_identifier: self.data_set_identifier,
            }
        }
    }
}
impl InsightVisual {
    /// Creates a new builder-style object to manufacture [`InsightVisual`](crate::model::InsightVisual).
    pub fn builder() -> crate::model::insight_visual::Builder {
        crate::model::insight_visual::Builder::default()
    }
}

/// <p>The configuration of an insight visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InsightConfiguration {
    /// <p>The computations configurations of the insight visual</p>
    #[doc(hidden)]
    pub computations: std::option::Option<std::vec::Vec<crate::model::Computation>>,
    /// <p>The custom narrative of the insight visual.</p>
    #[doc(hidden)]
    pub custom_narrative: std::option::Option<crate::model::CustomNarrativeOptions>,
}
impl InsightConfiguration {
    /// <p>The computations configurations of the insight visual</p>
    pub fn computations(&self) -> std::option::Option<&[crate::model::Computation]> {
        self.computations.as_deref()
    }
    /// <p>The custom narrative of the insight visual.</p>
    pub fn custom_narrative(&self) -> std::option::Option<&crate::model::CustomNarrativeOptions> {
        self.custom_narrative.as_ref()
    }
}
/// See [`InsightConfiguration`](crate::model::InsightConfiguration).
pub mod insight_configuration {

    /// A builder for [`InsightConfiguration`](crate::model::InsightConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) computations: std::option::Option<std::vec::Vec<crate::model::Computation>>,
        pub(crate) custom_narrative: std::option::Option<crate::model::CustomNarrativeOptions>,
    }
    impl Builder {
        /// Appends an item to `computations`.
        ///
        /// To override the contents of this collection use [`set_computations`](Self::set_computations).
        ///
        /// <p>The computations configurations of the insight visual</p>
        pub fn computations(mut self, input: crate::model::Computation) -> Self {
            let mut v = self.computations.unwrap_or_default();
            v.push(input);
            self.computations = Some(v);
            self
        }
        /// <p>The computations configurations of the insight visual</p>
        pub fn set_computations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Computation>>,
        ) -> Self {
            self.computations = input;
            self
        }
        /// <p>The custom narrative of the insight visual.</p>
        pub fn custom_narrative(mut self, input: crate::model::CustomNarrativeOptions) -> Self {
            self.custom_narrative = Some(input);
            self
        }
        /// <p>The custom narrative of the insight visual.</p>
        pub fn set_custom_narrative(
            mut self,
            input: std::option::Option<crate::model::CustomNarrativeOptions>,
        ) -> Self {
            self.custom_narrative = input;
            self
        }
        /// Consumes the builder and constructs a [`InsightConfiguration`](crate::model::InsightConfiguration).
        pub fn build(self) -> crate::model::InsightConfiguration {
            crate::model::InsightConfiguration {
                computations: self.computations,
                custom_narrative: self.custom_narrative,
            }
        }
    }
}
impl InsightConfiguration {
    /// Creates a new builder-style object to manufacture [`InsightConfiguration`](crate::model::InsightConfiguration).
    pub fn builder() -> crate::model::insight_configuration::Builder {
        crate::model::insight_configuration::Builder::default()
    }
}

/// <p>The custom narrative options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomNarrativeOptions {
    /// <p>The string input of custom narrative.</p>
    #[doc(hidden)]
    pub narrative: std::option::Option<std::string::String>,
}
impl CustomNarrativeOptions {
    /// <p>The string input of custom narrative.</p>
    pub fn narrative(&self) -> std::option::Option<&str> {
        self.narrative.as_deref()
    }
}
/// See [`CustomNarrativeOptions`](crate::model::CustomNarrativeOptions).
pub mod custom_narrative_options {

    /// A builder for [`CustomNarrativeOptions`](crate::model::CustomNarrativeOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) narrative: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The string input of custom narrative.</p>
        pub fn narrative(mut self, input: impl Into<std::string::String>) -> Self {
            self.narrative = Some(input.into());
            self
        }
        /// <p>The string input of custom narrative.</p>
        pub fn set_narrative(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.narrative = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomNarrativeOptions`](crate::model::CustomNarrativeOptions).
        pub fn build(self) -> crate::model::CustomNarrativeOptions {
            crate::model::CustomNarrativeOptions {
                narrative: self.narrative,
            }
        }
    }
}
impl CustomNarrativeOptions {
    /// Creates a new builder-style object to manufacture [`CustomNarrativeOptions`](crate::model::CustomNarrativeOptions).
    pub fn builder() -> crate::model::custom_narrative_options::Builder {
        crate::model::custom_narrative_options::Builder::default()
    }
}

/// <p>The computation union that is used in an insight visual.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Computation {
    /// <p>The top ranked and bottom ranked computation configuration.</p>
    #[doc(hidden)]
    pub top_bottom_ranked: std::option::Option<crate::model::TopBottomRankedComputation>,
    /// <p>The top movers and bottom movers computation configuration.</p>
    #[doc(hidden)]
    pub top_bottom_movers: std::option::Option<crate::model::TopBottomMoversComputation>,
    /// <p>The total aggregation computation configuration.</p>
    #[doc(hidden)]
    pub total_aggregation: std::option::Option<crate::model::TotalAggregationComputation>,
    /// <p>The maximum and minimum computation configuration.</p>
    #[doc(hidden)]
    pub maximum_minimum: std::option::Option<crate::model::MaximumMinimumComputation>,
    /// <p>The metric comparison computation configuration.</p>
    #[doc(hidden)]
    pub metric_comparison: std::option::Option<crate::model::MetricComparisonComputation>,
    /// <p>The period over period computation configuration.</p>
    #[doc(hidden)]
    pub period_over_period: std::option::Option<crate::model::PeriodOverPeriodComputation>,
    /// <p>The period to <code>DataSetIdentifier</code> computation configuration.</p>
    #[doc(hidden)]
    pub period_to_date: std::option::Option<crate::model::PeriodToDateComputation>,
    /// <p>The growth rate computation configuration.</p>
    #[doc(hidden)]
    pub growth_rate: std::option::Option<crate::model::GrowthRateComputation>,
    /// <p>The unique values computation configuration.</p>
    #[doc(hidden)]
    pub unique_values: std::option::Option<crate::model::UniqueValuesComputation>,
    /// <p>The forecast computation configuration.</p>
    #[doc(hidden)]
    pub forecast: std::option::Option<crate::model::ForecastComputation>,
}
impl Computation {
    /// <p>The top ranked and bottom ranked computation configuration.</p>
    pub fn top_bottom_ranked(
        &self,
    ) -> std::option::Option<&crate::model::TopBottomRankedComputation> {
        self.top_bottom_ranked.as_ref()
    }
    /// <p>The top movers and bottom movers computation configuration.</p>
    pub fn top_bottom_movers(
        &self,
    ) -> std::option::Option<&crate::model::TopBottomMoversComputation> {
        self.top_bottom_movers.as_ref()
    }
    /// <p>The total aggregation computation configuration.</p>
    pub fn total_aggregation(
        &self,
    ) -> std::option::Option<&crate::model::TotalAggregationComputation> {
        self.total_aggregation.as_ref()
    }
    /// <p>The maximum and minimum computation configuration.</p>
    pub fn maximum_minimum(&self) -> std::option::Option<&crate::model::MaximumMinimumComputation> {
        self.maximum_minimum.as_ref()
    }
    /// <p>The metric comparison computation configuration.</p>
    pub fn metric_comparison(
        &self,
    ) -> std::option::Option<&crate::model::MetricComparisonComputation> {
        self.metric_comparison.as_ref()
    }
    /// <p>The period over period computation configuration.</p>
    pub fn period_over_period(
        &self,
    ) -> std::option::Option<&crate::model::PeriodOverPeriodComputation> {
        self.period_over_period.as_ref()
    }
    /// <p>The period to <code>DataSetIdentifier</code> computation configuration.</p>
    pub fn period_to_date(&self) -> std::option::Option<&crate::model::PeriodToDateComputation> {
        self.period_to_date.as_ref()
    }
    /// <p>The growth rate computation configuration.</p>
    pub fn growth_rate(&self) -> std::option::Option<&crate::model::GrowthRateComputation> {
        self.growth_rate.as_ref()
    }
    /// <p>The unique values computation configuration.</p>
    pub fn unique_values(&self) -> std::option::Option<&crate::model::UniqueValuesComputation> {
        self.unique_values.as_ref()
    }
    /// <p>The forecast computation configuration.</p>
    pub fn forecast(&self) -> std::option::Option<&crate::model::ForecastComputation> {
        self.forecast.as_ref()
    }
}
/// See [`Computation`](crate::model::Computation).
pub mod computation {

    /// A builder for [`Computation`](crate::model::Computation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) top_bottom_ranked: std::option::Option<crate::model::TopBottomRankedComputation>,
        pub(crate) top_bottom_movers: std::option::Option<crate::model::TopBottomMoversComputation>,
        pub(crate) total_aggregation:
            std::option::Option<crate::model::TotalAggregationComputation>,
        pub(crate) maximum_minimum: std::option::Option<crate::model::MaximumMinimumComputation>,
        pub(crate) metric_comparison:
            std::option::Option<crate::model::MetricComparisonComputation>,
        pub(crate) period_over_period:
            std::option::Option<crate::model::PeriodOverPeriodComputation>,
        pub(crate) period_to_date: std::option::Option<crate::model::PeriodToDateComputation>,
        pub(crate) growth_rate: std::option::Option<crate::model::GrowthRateComputation>,
        pub(crate) unique_values: std::option::Option<crate::model::UniqueValuesComputation>,
        pub(crate) forecast: std::option::Option<crate::model::ForecastComputation>,
    }
    impl Builder {
        /// <p>The top ranked and bottom ranked computation configuration.</p>
        pub fn top_bottom_ranked(
            mut self,
            input: crate::model::TopBottomRankedComputation,
        ) -> Self {
            self.top_bottom_ranked = Some(input);
            self
        }
        /// <p>The top ranked and bottom ranked computation configuration.</p>
        pub fn set_top_bottom_ranked(
            mut self,
            input: std::option::Option<crate::model::TopBottomRankedComputation>,
        ) -> Self {
            self.top_bottom_ranked = input;
            self
        }
        /// <p>The top movers and bottom movers computation configuration.</p>
        pub fn top_bottom_movers(
            mut self,
            input: crate::model::TopBottomMoversComputation,
        ) -> Self {
            self.top_bottom_movers = Some(input);
            self
        }
        /// <p>The top movers and bottom movers computation configuration.</p>
        pub fn set_top_bottom_movers(
            mut self,
            input: std::option::Option<crate::model::TopBottomMoversComputation>,
        ) -> Self {
            self.top_bottom_movers = input;
            self
        }
        /// <p>The total aggregation computation configuration.</p>
        pub fn total_aggregation(
            mut self,
            input: crate::model::TotalAggregationComputation,
        ) -> Self {
            self.total_aggregation = Some(input);
            self
        }
        /// <p>The total aggregation computation configuration.</p>
        pub fn set_total_aggregation(
            mut self,
            input: std::option::Option<crate::model::TotalAggregationComputation>,
        ) -> Self {
            self.total_aggregation = input;
            self
        }
        /// <p>The maximum and minimum computation configuration.</p>
        pub fn maximum_minimum(mut self, input: crate::model::MaximumMinimumComputation) -> Self {
            self.maximum_minimum = Some(input);
            self
        }
        /// <p>The maximum and minimum computation configuration.</p>
        pub fn set_maximum_minimum(
            mut self,
            input: std::option::Option<crate::model::MaximumMinimumComputation>,
        ) -> Self {
            self.maximum_minimum = input;
            self
        }
        /// <p>The metric comparison computation configuration.</p>
        pub fn metric_comparison(
            mut self,
            input: crate::model::MetricComparisonComputation,
        ) -> Self {
            self.metric_comparison = Some(input);
            self
        }
        /// <p>The metric comparison computation configuration.</p>
        pub fn set_metric_comparison(
            mut self,
            input: std::option::Option<crate::model::MetricComparisonComputation>,
        ) -> Self {
            self.metric_comparison = input;
            self
        }
        /// <p>The period over period computation configuration.</p>
        pub fn period_over_period(
            mut self,
            input: crate::model::PeriodOverPeriodComputation,
        ) -> Self {
            self.period_over_period = Some(input);
            self
        }
        /// <p>The period over period computation configuration.</p>
        pub fn set_period_over_period(
            mut self,
            input: std::option::Option<crate::model::PeriodOverPeriodComputation>,
        ) -> Self {
            self.period_over_period = input;
            self
        }
        /// <p>The period to <code>DataSetIdentifier</code> computation configuration.</p>
        pub fn period_to_date(mut self, input: crate::model::PeriodToDateComputation) -> Self {
            self.period_to_date = Some(input);
            self
        }
        /// <p>The period to <code>DataSetIdentifier</code> computation configuration.</p>
        pub fn set_period_to_date(
            mut self,
            input: std::option::Option<crate::model::PeriodToDateComputation>,
        ) -> Self {
            self.period_to_date = input;
            self
        }
        /// <p>The growth rate computation configuration.</p>
        pub fn growth_rate(mut self, input: crate::model::GrowthRateComputation) -> Self {
            self.growth_rate = Some(input);
            self
        }
        /// <p>The growth rate computation configuration.</p>
        pub fn set_growth_rate(
            mut self,
            input: std::option::Option<crate::model::GrowthRateComputation>,
        ) -> Self {
            self.growth_rate = input;
            self
        }
        /// <p>The unique values computation configuration.</p>
        pub fn unique_values(mut self, input: crate::model::UniqueValuesComputation) -> Self {
            self.unique_values = Some(input);
            self
        }
        /// <p>The unique values computation configuration.</p>
        pub fn set_unique_values(
            mut self,
            input: std::option::Option<crate::model::UniqueValuesComputation>,
        ) -> Self {
            self.unique_values = input;
            self
        }
        /// <p>The forecast computation configuration.</p>
        pub fn forecast(mut self, input: crate::model::ForecastComputation) -> Self {
            self.forecast = Some(input);
            self
        }
        /// <p>The forecast computation configuration.</p>
        pub fn set_forecast(
            mut self,
            input: std::option::Option<crate::model::ForecastComputation>,
        ) -> Self {
            self.forecast = input;
            self
        }
        /// Consumes the builder and constructs a [`Computation`](crate::model::Computation).
        pub fn build(self) -> crate::model::Computation {
            crate::model::Computation {
                top_bottom_ranked: self.top_bottom_ranked,
                top_bottom_movers: self.top_bottom_movers,
                total_aggregation: self.total_aggregation,
                maximum_minimum: self.maximum_minimum,
                metric_comparison: self.metric_comparison,
                period_over_period: self.period_over_period,
                period_to_date: self.period_to_date,
                growth_rate: self.growth_rate,
                unique_values: self.unique_values,
                forecast: self.forecast,
            }
        }
    }
}
impl Computation {
    /// Creates a new builder-style object to manufacture [`Computation`](crate::model::Computation).
    pub fn builder() -> crate::model::computation::Builder {
        crate::model::computation::Builder::default()
    }
}

/// <p>The forecast computation configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ForecastComputation {
    /// <p>The ID for a computation.</p>
    #[doc(hidden)]
    pub computation_id: std::option::Option<std::string::String>,
    /// <p>The name of a computation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time field that is used in a computation.</p>
    #[doc(hidden)]
    pub time: std::option::Option<crate::model::DimensionField>,
    /// <p>The value field that is used in a computation.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::MeasureField>,
    /// <p>The periods forward setup of a forecast computation.</p>
    #[doc(hidden)]
    pub periods_forward: std::option::Option<i32>,
    /// <p>The periods backward setup of a forecast computation.</p>
    #[doc(hidden)]
    pub periods_backward: std::option::Option<i32>,
    /// <p>The upper boundary setup of a forecast computation.</p>
    #[doc(hidden)]
    pub upper_boundary: std::option::Option<f64>,
    /// <p>The lower boundary setup of a forecast computation.</p>
    #[doc(hidden)]
    pub lower_boundary: std::option::Option<f64>,
    /// <p>The prediction interval setup of a forecast computation.</p>
    #[doc(hidden)]
    pub prediction_interval: std::option::Option<i32>,
    /// <p>The seasonality setup of a forecast computation. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>AUTOMATIC</code> </p> </li>
    /// <li> <p> <code>CUSTOM</code>: Checks the custom seasonality value.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub seasonality: std::option::Option<crate::model::ForecastComputationSeasonality>,
    /// <p>The custom seasonality value setup of a forecast computation.</p>
    #[doc(hidden)]
    pub custom_seasonality_value: std::option::Option<i32>,
}
impl ForecastComputation {
    /// <p>The ID for a computation.</p>
    pub fn computation_id(&self) -> std::option::Option<&str> {
        self.computation_id.as_deref()
    }
    /// <p>The name of a computation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time field that is used in a computation.</p>
    pub fn time(&self) -> std::option::Option<&crate::model::DimensionField> {
        self.time.as_ref()
    }
    /// <p>The value field that is used in a computation.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::MeasureField> {
        self.value.as_ref()
    }
    /// <p>The periods forward setup of a forecast computation.</p>
    pub fn periods_forward(&self) -> std::option::Option<i32> {
        self.periods_forward
    }
    /// <p>The periods backward setup of a forecast computation.</p>
    pub fn periods_backward(&self) -> std::option::Option<i32> {
        self.periods_backward
    }
    /// <p>The upper boundary setup of a forecast computation.</p>
    pub fn upper_boundary(&self) -> std::option::Option<f64> {
        self.upper_boundary
    }
    /// <p>The lower boundary setup of a forecast computation.</p>
    pub fn lower_boundary(&self) -> std::option::Option<f64> {
        self.lower_boundary
    }
    /// <p>The prediction interval setup of a forecast computation.</p>
    pub fn prediction_interval(&self) -> std::option::Option<i32> {
        self.prediction_interval
    }
    /// <p>The seasonality setup of a forecast computation. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>AUTOMATIC</code> </p> </li>
    /// <li> <p> <code>CUSTOM</code>: Checks the custom seasonality value.</p> </li>
    /// </ul>
    pub fn seasonality(
        &self,
    ) -> std::option::Option<&crate::model::ForecastComputationSeasonality> {
        self.seasonality.as_ref()
    }
    /// <p>The custom seasonality value setup of a forecast computation.</p>
    pub fn custom_seasonality_value(&self) -> std::option::Option<i32> {
        self.custom_seasonality_value
    }
}
/// See [`ForecastComputation`](crate::model::ForecastComputation).
pub mod forecast_computation {

    /// A builder for [`ForecastComputation`](crate::model::ForecastComputation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) computation_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) time: std::option::Option<crate::model::DimensionField>,
        pub(crate) value: std::option::Option<crate::model::MeasureField>,
        pub(crate) periods_forward: std::option::Option<i32>,
        pub(crate) periods_backward: std::option::Option<i32>,
        pub(crate) upper_boundary: std::option::Option<f64>,
        pub(crate) lower_boundary: std::option::Option<f64>,
        pub(crate) prediction_interval: std::option::Option<i32>,
        pub(crate) seasonality: std::option::Option<crate::model::ForecastComputationSeasonality>,
        pub(crate) custom_seasonality_value: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID for a computation.</p>
        pub fn computation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.computation_id = Some(input.into());
            self
        }
        /// <p>The ID for a computation.</p>
        pub fn set_computation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.computation_id = input;
            self
        }
        /// <p>The name of a computation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a computation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time field that is used in a computation.</p>
        pub fn time(mut self, input: crate::model::DimensionField) -> Self {
            self.time = Some(input);
            self
        }
        /// <p>The time field that is used in a computation.</p>
        pub fn set_time(
            mut self,
            input: std::option::Option<crate::model::DimensionField>,
        ) -> Self {
            self.time = input;
            self
        }
        /// <p>The value field that is used in a computation.</p>
        pub fn value(mut self, input: crate::model::MeasureField) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value field that is used in a computation.</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::MeasureField>) -> Self {
            self.value = input;
            self
        }
        /// <p>The periods forward setup of a forecast computation.</p>
        pub fn periods_forward(mut self, input: i32) -> Self {
            self.periods_forward = Some(input);
            self
        }
        /// <p>The periods forward setup of a forecast computation.</p>
        pub fn set_periods_forward(mut self, input: std::option::Option<i32>) -> Self {
            self.periods_forward = input;
            self
        }
        /// <p>The periods backward setup of a forecast computation.</p>
        pub fn periods_backward(mut self, input: i32) -> Self {
            self.periods_backward = Some(input);
            self
        }
        /// <p>The periods backward setup of a forecast computation.</p>
        pub fn set_periods_backward(mut self, input: std::option::Option<i32>) -> Self {
            self.periods_backward = input;
            self
        }
        /// <p>The upper boundary setup of a forecast computation.</p>
        pub fn upper_boundary(mut self, input: f64) -> Self {
            self.upper_boundary = Some(input);
            self
        }
        /// <p>The upper boundary setup of a forecast computation.</p>
        pub fn set_upper_boundary(mut self, input: std::option::Option<f64>) -> Self {
            self.upper_boundary = input;
            self
        }
        /// <p>The lower boundary setup of a forecast computation.</p>
        pub fn lower_boundary(mut self, input: f64) -> Self {
            self.lower_boundary = Some(input);
            self
        }
        /// <p>The lower boundary setup of a forecast computation.</p>
        pub fn set_lower_boundary(mut self, input: std::option::Option<f64>) -> Self {
            self.lower_boundary = input;
            self
        }
        /// <p>The prediction interval setup of a forecast computation.</p>
        pub fn prediction_interval(mut self, input: i32) -> Self {
            self.prediction_interval = Some(input);
            self
        }
        /// <p>The prediction interval setup of a forecast computation.</p>
        pub fn set_prediction_interval(mut self, input: std::option::Option<i32>) -> Self {
            self.prediction_interval = input;
            self
        }
        /// <p>The seasonality setup of a forecast computation. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>AUTOMATIC</code> </p> </li>
        /// <li> <p> <code>CUSTOM</code>: Checks the custom seasonality value.</p> </li>
        /// </ul>
        pub fn seasonality(mut self, input: crate::model::ForecastComputationSeasonality) -> Self {
            self.seasonality = Some(input);
            self
        }
        /// <p>The seasonality setup of a forecast computation. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>AUTOMATIC</code> </p> </li>
        /// <li> <p> <code>CUSTOM</code>: Checks the custom seasonality value.</p> </li>
        /// </ul>
        pub fn set_seasonality(
            mut self,
            input: std::option::Option<crate::model::ForecastComputationSeasonality>,
        ) -> Self {
            self.seasonality = input;
            self
        }
        /// <p>The custom seasonality value setup of a forecast computation.</p>
        pub fn custom_seasonality_value(mut self, input: i32) -> Self {
            self.custom_seasonality_value = Some(input);
            self
        }
        /// <p>The custom seasonality value setup of a forecast computation.</p>
        pub fn set_custom_seasonality_value(mut self, input: std::option::Option<i32>) -> Self {
            self.custom_seasonality_value = input;
            self
        }
        /// Consumes the builder and constructs a [`ForecastComputation`](crate::model::ForecastComputation).
        pub fn build(self) -> crate::model::ForecastComputation {
            crate::model::ForecastComputation {
                computation_id: self.computation_id,
                name: self.name,
                time: self.time,
                value: self.value,
                periods_forward: self.periods_forward,
                periods_backward: self.periods_backward,
                upper_boundary: self.upper_boundary,
                lower_boundary: self.lower_boundary,
                prediction_interval: self.prediction_interval,
                seasonality: self.seasonality,
                custom_seasonality_value: self.custom_seasonality_value,
            }
        }
    }
}
impl ForecastComputation {
    /// Creates a new builder-style object to manufacture [`ForecastComputation`](crate::model::ForecastComputation).
    pub fn builder() -> crate::model::forecast_computation::Builder {
        crate::model::forecast_computation::Builder::default()
    }
}

/// When writing a match expression against `ForecastComputationSeasonality`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let forecastcomputationseasonality = unimplemented!();
/// match forecastcomputationseasonality {
///     ForecastComputationSeasonality::Automatic => { /* ... */ },
///     ForecastComputationSeasonality::Custom => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `forecastcomputationseasonality` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ForecastComputationSeasonality::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ForecastComputationSeasonality::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ForecastComputationSeasonality::NewFeature` is defined.
/// Specifically, when `forecastcomputationseasonality` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ForecastComputationSeasonality::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ForecastComputationSeasonality {
    #[allow(missing_docs)] // documentation missing in model
    Automatic,
    #[allow(missing_docs)] // documentation missing in model
    Custom,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ForecastComputationSeasonality {
    fn from(s: &str) -> Self {
        match s {
            "AUTOMATIC" => ForecastComputationSeasonality::Automatic,
            "CUSTOM" => ForecastComputationSeasonality::Custom,
            other => ForecastComputationSeasonality::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ForecastComputationSeasonality {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ForecastComputationSeasonality::from(s))
    }
}
impl ForecastComputationSeasonality {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ForecastComputationSeasonality::Automatic => "AUTOMATIC",
            ForecastComputationSeasonality::Custom => "CUSTOM",
            ForecastComputationSeasonality::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AUTOMATIC", "CUSTOM"]
    }
}
impl AsRef<str> for ForecastComputationSeasonality {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The unique values computation configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UniqueValuesComputation {
    /// <p>The ID for a computation.</p>
    #[doc(hidden)]
    pub computation_id: std::option::Option<std::string::String>,
    /// <p>The name of a computation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The category field that is used in a computation.</p>
    #[doc(hidden)]
    pub category: std::option::Option<crate::model::DimensionField>,
}
impl UniqueValuesComputation {
    /// <p>The ID for a computation.</p>
    pub fn computation_id(&self) -> std::option::Option<&str> {
        self.computation_id.as_deref()
    }
    /// <p>The name of a computation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The category field that is used in a computation.</p>
    pub fn category(&self) -> std::option::Option<&crate::model::DimensionField> {
        self.category.as_ref()
    }
}
/// See [`UniqueValuesComputation`](crate::model::UniqueValuesComputation).
pub mod unique_values_computation {

    /// A builder for [`UniqueValuesComputation`](crate::model::UniqueValuesComputation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) computation_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) category: std::option::Option<crate::model::DimensionField>,
    }
    impl Builder {
        /// <p>The ID for a computation.</p>
        pub fn computation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.computation_id = Some(input.into());
            self
        }
        /// <p>The ID for a computation.</p>
        pub fn set_computation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.computation_id = input;
            self
        }
        /// <p>The name of a computation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a computation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The category field that is used in a computation.</p>
        pub fn category(mut self, input: crate::model::DimensionField) -> Self {
            self.category = Some(input);
            self
        }
        /// <p>The category field that is used in a computation.</p>
        pub fn set_category(
            mut self,
            input: std::option::Option<crate::model::DimensionField>,
        ) -> Self {
            self.category = input;
            self
        }
        /// Consumes the builder and constructs a [`UniqueValuesComputation`](crate::model::UniqueValuesComputation).
        pub fn build(self) -> crate::model::UniqueValuesComputation {
            crate::model::UniqueValuesComputation {
                computation_id: self.computation_id,
                name: self.name,
                category: self.category,
            }
        }
    }
}
impl UniqueValuesComputation {
    /// Creates a new builder-style object to manufacture [`UniqueValuesComputation`](crate::model::UniqueValuesComputation).
    pub fn builder() -> crate::model::unique_values_computation::Builder {
        crate::model::unique_values_computation::Builder::default()
    }
}

/// <p>The growth rate computation configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GrowthRateComputation {
    /// <p>The ID for a computation.</p>
    #[doc(hidden)]
    pub computation_id: std::option::Option<std::string::String>,
    /// <p>The name of a computation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time field that is used in a computation.</p>
    #[doc(hidden)]
    pub time: std::option::Option<crate::model::DimensionField>,
    /// <p>The value field that is used in a computation.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::MeasureField>,
    /// <p>The period size setup of a growth rate computation.</p>
    #[doc(hidden)]
    pub period_size: i32,
}
impl GrowthRateComputation {
    /// <p>The ID for a computation.</p>
    pub fn computation_id(&self) -> std::option::Option<&str> {
        self.computation_id.as_deref()
    }
    /// <p>The name of a computation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time field that is used in a computation.</p>
    pub fn time(&self) -> std::option::Option<&crate::model::DimensionField> {
        self.time.as_ref()
    }
    /// <p>The value field that is used in a computation.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::MeasureField> {
        self.value.as_ref()
    }
    /// <p>The period size setup of a growth rate computation.</p>
    pub fn period_size(&self) -> i32 {
        self.period_size
    }
}
/// See [`GrowthRateComputation`](crate::model::GrowthRateComputation).
pub mod growth_rate_computation {

    /// A builder for [`GrowthRateComputation`](crate::model::GrowthRateComputation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) computation_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) time: std::option::Option<crate::model::DimensionField>,
        pub(crate) value: std::option::Option<crate::model::MeasureField>,
        pub(crate) period_size: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID for a computation.</p>
        pub fn computation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.computation_id = Some(input.into());
            self
        }
        /// <p>The ID for a computation.</p>
        pub fn set_computation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.computation_id = input;
            self
        }
        /// <p>The name of a computation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a computation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time field that is used in a computation.</p>
        pub fn time(mut self, input: crate::model::DimensionField) -> Self {
            self.time = Some(input);
            self
        }
        /// <p>The time field that is used in a computation.</p>
        pub fn set_time(
            mut self,
            input: std::option::Option<crate::model::DimensionField>,
        ) -> Self {
            self.time = input;
            self
        }
        /// <p>The value field that is used in a computation.</p>
        pub fn value(mut self, input: crate::model::MeasureField) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value field that is used in a computation.</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::MeasureField>) -> Self {
            self.value = input;
            self
        }
        /// <p>The period size setup of a growth rate computation.</p>
        pub fn period_size(mut self, input: i32) -> Self {
            self.period_size = Some(input);
            self
        }
        /// <p>The period size setup of a growth rate computation.</p>
        pub fn set_period_size(mut self, input: std::option::Option<i32>) -> Self {
            self.period_size = input;
            self
        }
        /// Consumes the builder and constructs a [`GrowthRateComputation`](crate::model::GrowthRateComputation).
        pub fn build(self) -> crate::model::GrowthRateComputation {
            crate::model::GrowthRateComputation {
                computation_id: self.computation_id,
                name: self.name,
                time: self.time,
                value: self.value,
                period_size: self.period_size.unwrap_or_default(),
            }
        }
    }
}
impl GrowthRateComputation {
    /// Creates a new builder-style object to manufacture [`GrowthRateComputation`](crate::model::GrowthRateComputation).
    pub fn builder() -> crate::model::growth_rate_computation::Builder {
        crate::model::growth_rate_computation::Builder::default()
    }
}

/// <p>The period to date computation configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PeriodToDateComputation {
    /// <p>The ID for a computation.</p>
    #[doc(hidden)]
    pub computation_id: std::option::Option<std::string::String>,
    /// <p>The name of a computation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time field that is used in a computation.</p>
    #[doc(hidden)]
    pub time: std::option::Option<crate::model::DimensionField>,
    /// <p>The value field that is used in a computation.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::MeasureField>,
    /// <p>The time granularity setup of period to date computation. Choose from the following options:</p>
    /// <ul>
    /// <li> <p>YEAR: Year to date.</p> </li>
    /// <li> <p>MONTH: Month to date.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub period_time_granularity: std::option::Option<crate::model::TimeGranularity>,
}
impl PeriodToDateComputation {
    /// <p>The ID for a computation.</p>
    pub fn computation_id(&self) -> std::option::Option<&str> {
        self.computation_id.as_deref()
    }
    /// <p>The name of a computation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time field that is used in a computation.</p>
    pub fn time(&self) -> std::option::Option<&crate::model::DimensionField> {
        self.time.as_ref()
    }
    /// <p>The value field that is used in a computation.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::MeasureField> {
        self.value.as_ref()
    }
    /// <p>The time granularity setup of period to date computation. Choose from the following options:</p>
    /// <ul>
    /// <li> <p>YEAR: Year to date.</p> </li>
    /// <li> <p>MONTH: Month to date.</p> </li>
    /// </ul>
    pub fn period_time_granularity(&self) -> std::option::Option<&crate::model::TimeGranularity> {
        self.period_time_granularity.as_ref()
    }
}
/// See [`PeriodToDateComputation`](crate::model::PeriodToDateComputation).
pub mod period_to_date_computation {

    /// A builder for [`PeriodToDateComputation`](crate::model::PeriodToDateComputation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) computation_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) time: std::option::Option<crate::model::DimensionField>,
        pub(crate) value: std::option::Option<crate::model::MeasureField>,
        pub(crate) period_time_granularity: std::option::Option<crate::model::TimeGranularity>,
    }
    impl Builder {
        /// <p>The ID for a computation.</p>
        pub fn computation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.computation_id = Some(input.into());
            self
        }
        /// <p>The ID for a computation.</p>
        pub fn set_computation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.computation_id = input;
            self
        }
        /// <p>The name of a computation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a computation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time field that is used in a computation.</p>
        pub fn time(mut self, input: crate::model::DimensionField) -> Self {
            self.time = Some(input);
            self
        }
        /// <p>The time field that is used in a computation.</p>
        pub fn set_time(
            mut self,
            input: std::option::Option<crate::model::DimensionField>,
        ) -> Self {
            self.time = input;
            self
        }
        /// <p>The value field that is used in a computation.</p>
        pub fn value(mut self, input: crate::model::MeasureField) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value field that is used in a computation.</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::MeasureField>) -> Self {
            self.value = input;
            self
        }
        /// <p>The time granularity setup of period to date computation. Choose from the following options:</p>
        /// <ul>
        /// <li> <p>YEAR: Year to date.</p> </li>
        /// <li> <p>MONTH: Month to date.</p> </li>
        /// </ul>
        pub fn period_time_granularity(mut self, input: crate::model::TimeGranularity) -> Self {
            self.period_time_granularity = Some(input);
            self
        }
        /// <p>The time granularity setup of period to date computation. Choose from the following options:</p>
        /// <ul>
        /// <li> <p>YEAR: Year to date.</p> </li>
        /// <li> <p>MONTH: Month to date.</p> </li>
        /// </ul>
        pub fn set_period_time_granularity(
            mut self,
            input: std::option::Option<crate::model::TimeGranularity>,
        ) -> Self {
            self.period_time_granularity = input;
            self
        }
        /// Consumes the builder and constructs a [`PeriodToDateComputation`](crate::model::PeriodToDateComputation).
        pub fn build(self) -> crate::model::PeriodToDateComputation {
            crate::model::PeriodToDateComputation {
                computation_id: self.computation_id,
                name: self.name,
                time: self.time,
                value: self.value,
                period_time_granularity: self.period_time_granularity,
            }
        }
    }
}
impl PeriodToDateComputation {
    /// Creates a new builder-style object to manufacture [`PeriodToDateComputation`](crate::model::PeriodToDateComputation).
    pub fn builder() -> crate::model::period_to_date_computation::Builder {
        crate::model::period_to_date_computation::Builder::default()
    }
}

/// <p>The period over period computation configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PeriodOverPeriodComputation {
    /// <p>The ID for a computation.</p>
    #[doc(hidden)]
    pub computation_id: std::option::Option<std::string::String>,
    /// <p>The name of a computation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time field that is used in a computation.</p>
    #[doc(hidden)]
    pub time: std::option::Option<crate::model::DimensionField>,
    /// <p>The value field that is used in a computation.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::MeasureField>,
}
impl PeriodOverPeriodComputation {
    /// <p>The ID for a computation.</p>
    pub fn computation_id(&self) -> std::option::Option<&str> {
        self.computation_id.as_deref()
    }
    /// <p>The name of a computation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time field that is used in a computation.</p>
    pub fn time(&self) -> std::option::Option<&crate::model::DimensionField> {
        self.time.as_ref()
    }
    /// <p>The value field that is used in a computation.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::MeasureField> {
        self.value.as_ref()
    }
}
/// See [`PeriodOverPeriodComputation`](crate::model::PeriodOverPeriodComputation).
pub mod period_over_period_computation {

    /// A builder for [`PeriodOverPeriodComputation`](crate::model::PeriodOverPeriodComputation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) computation_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) time: std::option::Option<crate::model::DimensionField>,
        pub(crate) value: std::option::Option<crate::model::MeasureField>,
    }
    impl Builder {
        /// <p>The ID for a computation.</p>
        pub fn computation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.computation_id = Some(input.into());
            self
        }
        /// <p>The ID for a computation.</p>
        pub fn set_computation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.computation_id = input;
            self
        }
        /// <p>The name of a computation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a computation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time field that is used in a computation.</p>
        pub fn time(mut self, input: crate::model::DimensionField) -> Self {
            self.time = Some(input);
            self
        }
        /// <p>The time field that is used in a computation.</p>
        pub fn set_time(
            mut self,
            input: std::option::Option<crate::model::DimensionField>,
        ) -> Self {
            self.time = input;
            self
        }
        /// <p>The value field that is used in a computation.</p>
        pub fn value(mut self, input: crate::model::MeasureField) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value field that is used in a computation.</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::MeasureField>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`PeriodOverPeriodComputation`](crate::model::PeriodOverPeriodComputation).
        pub fn build(self) -> crate::model::PeriodOverPeriodComputation {
            crate::model::PeriodOverPeriodComputation {
                computation_id: self.computation_id,
                name: self.name,
                time: self.time,
                value: self.value,
            }
        }
    }
}
impl PeriodOverPeriodComputation {
    /// Creates a new builder-style object to manufacture [`PeriodOverPeriodComputation`](crate::model::PeriodOverPeriodComputation).
    pub fn builder() -> crate::model::period_over_period_computation::Builder {
        crate::model::period_over_period_computation::Builder::default()
    }
}

/// <p>The metric comparison computation configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MetricComparisonComputation {
    /// <p>The ID for a computation.</p>
    #[doc(hidden)]
    pub computation_id: std::option::Option<std::string::String>,
    /// <p>The name of a computation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time field that is used in a computation.</p>
    #[doc(hidden)]
    pub time: std::option::Option<crate::model::DimensionField>,
    /// <p>The field that is used in a metric comparison from value setup.</p>
    #[doc(hidden)]
    pub from_value: std::option::Option<crate::model::MeasureField>,
    /// <p>The field that is used in a metric comparison to value setup.</p>
    #[doc(hidden)]
    pub target_value: std::option::Option<crate::model::MeasureField>,
}
impl MetricComparisonComputation {
    /// <p>The ID for a computation.</p>
    pub fn computation_id(&self) -> std::option::Option<&str> {
        self.computation_id.as_deref()
    }
    /// <p>The name of a computation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time field that is used in a computation.</p>
    pub fn time(&self) -> std::option::Option<&crate::model::DimensionField> {
        self.time.as_ref()
    }
    /// <p>The field that is used in a metric comparison from value setup.</p>
    pub fn from_value(&self) -> std::option::Option<&crate::model::MeasureField> {
        self.from_value.as_ref()
    }
    /// <p>The field that is used in a metric comparison to value setup.</p>
    pub fn target_value(&self) -> std::option::Option<&crate::model::MeasureField> {
        self.target_value.as_ref()
    }
}
/// See [`MetricComparisonComputation`](crate::model::MetricComparisonComputation).
pub mod metric_comparison_computation {

    /// A builder for [`MetricComparisonComputation`](crate::model::MetricComparisonComputation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) computation_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) time: std::option::Option<crate::model::DimensionField>,
        pub(crate) from_value: std::option::Option<crate::model::MeasureField>,
        pub(crate) target_value: std::option::Option<crate::model::MeasureField>,
    }
    impl Builder {
        /// <p>The ID for a computation.</p>
        pub fn computation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.computation_id = Some(input.into());
            self
        }
        /// <p>The ID for a computation.</p>
        pub fn set_computation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.computation_id = input;
            self
        }
        /// <p>The name of a computation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a computation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time field that is used in a computation.</p>
        pub fn time(mut self, input: crate::model::DimensionField) -> Self {
            self.time = Some(input);
            self
        }
        /// <p>The time field that is used in a computation.</p>
        pub fn set_time(
            mut self,
            input: std::option::Option<crate::model::DimensionField>,
        ) -> Self {
            self.time = input;
            self
        }
        /// <p>The field that is used in a metric comparison from value setup.</p>
        pub fn from_value(mut self, input: crate::model::MeasureField) -> Self {
            self.from_value = Some(input);
            self
        }
        /// <p>The field that is used in a metric comparison from value setup.</p>
        pub fn set_from_value(
            mut self,
            input: std::option::Option<crate::model::MeasureField>,
        ) -> Self {
            self.from_value = input;
            self
        }
        /// <p>The field that is used in a metric comparison to value setup.</p>
        pub fn target_value(mut self, input: crate::model::MeasureField) -> Self {
            self.target_value = Some(input);
            self
        }
        /// <p>The field that is used in a metric comparison to value setup.</p>
        pub fn set_target_value(
            mut self,
            input: std::option::Option<crate::model::MeasureField>,
        ) -> Self {
            self.target_value = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricComparisonComputation`](crate::model::MetricComparisonComputation).
        pub fn build(self) -> crate::model::MetricComparisonComputation {
            crate::model::MetricComparisonComputation {
                computation_id: self.computation_id,
                name: self.name,
                time: self.time,
                from_value: self.from_value,
                target_value: self.target_value,
            }
        }
    }
}
impl MetricComparisonComputation {
    /// Creates a new builder-style object to manufacture [`MetricComparisonComputation`](crate::model::MetricComparisonComputation).
    pub fn builder() -> crate::model::metric_comparison_computation::Builder {
        crate::model::metric_comparison_computation::Builder::default()
    }
}

/// <p>The maximum and minimum computation configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MaximumMinimumComputation {
    /// <p>The ID for a computation.</p>
    #[doc(hidden)]
    pub computation_id: std::option::Option<std::string::String>,
    /// <p>The name of a computation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time field that is used in a computation.</p>
    #[doc(hidden)]
    pub time: std::option::Option<crate::model::DimensionField>,
    /// <p>The value field that is used in a computation.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::MeasureField>,
    /// <p>The type of computation. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p>MAXIMUM: A maximum computation.</p> </li>
    /// <li> <p>MINIMUM: A minimum computation.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::MaximumMinimumComputationType>,
}
impl MaximumMinimumComputation {
    /// <p>The ID for a computation.</p>
    pub fn computation_id(&self) -> std::option::Option<&str> {
        self.computation_id.as_deref()
    }
    /// <p>The name of a computation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time field that is used in a computation.</p>
    pub fn time(&self) -> std::option::Option<&crate::model::DimensionField> {
        self.time.as_ref()
    }
    /// <p>The value field that is used in a computation.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::MeasureField> {
        self.value.as_ref()
    }
    /// <p>The type of computation. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p>MAXIMUM: A maximum computation.</p> </li>
    /// <li> <p>MINIMUM: A minimum computation.</p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&crate::model::MaximumMinimumComputationType> {
        self.r#type.as_ref()
    }
}
/// See [`MaximumMinimumComputation`](crate::model::MaximumMinimumComputation).
pub mod maximum_minimum_computation {

    /// A builder for [`MaximumMinimumComputation`](crate::model::MaximumMinimumComputation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) computation_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) time: std::option::Option<crate::model::DimensionField>,
        pub(crate) value: std::option::Option<crate::model::MeasureField>,
        pub(crate) r#type: std::option::Option<crate::model::MaximumMinimumComputationType>,
    }
    impl Builder {
        /// <p>The ID for a computation.</p>
        pub fn computation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.computation_id = Some(input.into());
            self
        }
        /// <p>The ID for a computation.</p>
        pub fn set_computation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.computation_id = input;
            self
        }
        /// <p>The name of a computation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a computation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time field that is used in a computation.</p>
        pub fn time(mut self, input: crate::model::DimensionField) -> Self {
            self.time = Some(input);
            self
        }
        /// <p>The time field that is used in a computation.</p>
        pub fn set_time(
            mut self,
            input: std::option::Option<crate::model::DimensionField>,
        ) -> Self {
            self.time = input;
            self
        }
        /// <p>The value field that is used in a computation.</p>
        pub fn value(mut self, input: crate::model::MeasureField) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value field that is used in a computation.</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::MeasureField>) -> Self {
            self.value = input;
            self
        }
        /// <p>The type of computation. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p>MAXIMUM: A maximum computation.</p> </li>
        /// <li> <p>MINIMUM: A minimum computation.</p> </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::MaximumMinimumComputationType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of computation. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p>MAXIMUM: A maximum computation.</p> </li>
        /// <li> <p>MINIMUM: A minimum computation.</p> </li>
        /// </ul>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::MaximumMinimumComputationType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumMinimumComputation`](crate::model::MaximumMinimumComputation).
        pub fn build(self) -> crate::model::MaximumMinimumComputation {
            crate::model::MaximumMinimumComputation {
                computation_id: self.computation_id,
                name: self.name,
                time: self.time,
                value: self.value,
                r#type: self.r#type,
            }
        }
    }
}
impl MaximumMinimumComputation {
    /// Creates a new builder-style object to manufacture [`MaximumMinimumComputation`](crate::model::MaximumMinimumComputation).
    pub fn builder() -> crate::model::maximum_minimum_computation::Builder {
        crate::model::maximum_minimum_computation::Builder::default()
    }
}

/// When writing a match expression against `MaximumMinimumComputationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let maximumminimumcomputationtype = unimplemented!();
/// match maximumminimumcomputationtype {
///     MaximumMinimumComputationType::Maximum => { /* ... */ },
///     MaximumMinimumComputationType::Minimum => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `maximumminimumcomputationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MaximumMinimumComputationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MaximumMinimumComputationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MaximumMinimumComputationType::NewFeature` is defined.
/// Specifically, when `maximumminimumcomputationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MaximumMinimumComputationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MaximumMinimumComputationType {
    #[allow(missing_docs)] // documentation missing in model
    Maximum,
    #[allow(missing_docs)] // documentation missing in model
    Minimum,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MaximumMinimumComputationType {
    fn from(s: &str) -> Self {
        match s {
            "MAXIMUM" => MaximumMinimumComputationType::Maximum,
            "MINIMUM" => MaximumMinimumComputationType::Minimum,
            other => MaximumMinimumComputationType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for MaximumMinimumComputationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MaximumMinimumComputationType::from(s))
    }
}
impl MaximumMinimumComputationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MaximumMinimumComputationType::Maximum => "MAXIMUM",
            MaximumMinimumComputationType::Minimum => "MINIMUM",
            MaximumMinimumComputationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["MAXIMUM", "MINIMUM"]
    }
}
impl AsRef<str> for MaximumMinimumComputationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The total aggregation computation configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TotalAggregationComputation {
    /// <p>The ID for a computation.</p>
    #[doc(hidden)]
    pub computation_id: std::option::Option<std::string::String>,
    /// <p>The name of a computation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The value field that is used in a computation.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::MeasureField>,
}
impl TotalAggregationComputation {
    /// <p>The ID for a computation.</p>
    pub fn computation_id(&self) -> std::option::Option<&str> {
        self.computation_id.as_deref()
    }
    /// <p>The name of a computation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The value field that is used in a computation.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::MeasureField> {
        self.value.as_ref()
    }
}
/// See [`TotalAggregationComputation`](crate::model::TotalAggregationComputation).
pub mod total_aggregation_computation {

    /// A builder for [`TotalAggregationComputation`](crate::model::TotalAggregationComputation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) computation_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<crate::model::MeasureField>,
    }
    impl Builder {
        /// <p>The ID for a computation.</p>
        pub fn computation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.computation_id = Some(input.into());
            self
        }
        /// <p>The ID for a computation.</p>
        pub fn set_computation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.computation_id = input;
            self
        }
        /// <p>The name of a computation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a computation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value field that is used in a computation.</p>
        pub fn value(mut self, input: crate::model::MeasureField) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value field that is used in a computation.</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::MeasureField>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`TotalAggregationComputation`](crate::model::TotalAggregationComputation).
        pub fn build(self) -> crate::model::TotalAggregationComputation {
            crate::model::TotalAggregationComputation {
                computation_id: self.computation_id,
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl TotalAggregationComputation {
    /// Creates a new builder-style object to manufacture [`TotalAggregationComputation`](crate::model::TotalAggregationComputation).
    pub fn builder() -> crate::model::total_aggregation_computation::Builder {
        crate::model::total_aggregation_computation::Builder::default()
    }
}

/// <p>The top movers and bottom movers computation setup.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TopBottomMoversComputation {
    /// <p>The ID for a computation.</p>
    #[doc(hidden)]
    pub computation_id: std::option::Option<std::string::String>,
    /// <p>The name of a computation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time field that is used in a computation.</p>
    #[doc(hidden)]
    pub time: std::option::Option<crate::model::DimensionField>,
    /// <p>The category field that is used in a computation.</p>
    #[doc(hidden)]
    pub category: std::option::Option<crate::model::DimensionField>,
    /// <p>The value field that is used in a computation.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::MeasureField>,
    /// <p>The mover size setup of the top and bottom movers computation.</p>
    #[doc(hidden)]
    pub mover_size: i32,
    /// <p>The sort order setup of the top and bottom movers computation.</p>
    #[doc(hidden)]
    pub sort_order: std::option::Option<crate::model::TopBottomSortOrder>,
    /// <p>The computation type. Choose from the following options:</p>
    /// <ul>
    /// <li> <p>TOP: Top movers computation.</p> </li>
    /// <li> <p>BOTTOM: Bottom movers computation.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::TopBottomComputationType>,
}
impl TopBottomMoversComputation {
    /// <p>The ID for a computation.</p>
    pub fn computation_id(&self) -> std::option::Option<&str> {
        self.computation_id.as_deref()
    }
    /// <p>The name of a computation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time field that is used in a computation.</p>
    pub fn time(&self) -> std::option::Option<&crate::model::DimensionField> {
        self.time.as_ref()
    }
    /// <p>The category field that is used in a computation.</p>
    pub fn category(&self) -> std::option::Option<&crate::model::DimensionField> {
        self.category.as_ref()
    }
    /// <p>The value field that is used in a computation.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::MeasureField> {
        self.value.as_ref()
    }
    /// <p>The mover size setup of the top and bottom movers computation.</p>
    pub fn mover_size(&self) -> i32 {
        self.mover_size
    }
    /// <p>The sort order setup of the top and bottom movers computation.</p>
    pub fn sort_order(&self) -> std::option::Option<&crate::model::TopBottomSortOrder> {
        self.sort_order.as_ref()
    }
    /// <p>The computation type. Choose from the following options:</p>
    /// <ul>
    /// <li> <p>TOP: Top movers computation.</p> </li>
    /// <li> <p>BOTTOM: Bottom movers computation.</p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&crate::model::TopBottomComputationType> {
        self.r#type.as_ref()
    }
}
/// See [`TopBottomMoversComputation`](crate::model::TopBottomMoversComputation).
pub mod top_bottom_movers_computation {

    /// A builder for [`TopBottomMoversComputation`](crate::model::TopBottomMoversComputation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) computation_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) time: std::option::Option<crate::model::DimensionField>,
        pub(crate) category: std::option::Option<crate::model::DimensionField>,
        pub(crate) value: std::option::Option<crate::model::MeasureField>,
        pub(crate) mover_size: std::option::Option<i32>,
        pub(crate) sort_order: std::option::Option<crate::model::TopBottomSortOrder>,
        pub(crate) r#type: std::option::Option<crate::model::TopBottomComputationType>,
    }
    impl Builder {
        /// <p>The ID for a computation.</p>
        pub fn computation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.computation_id = Some(input.into());
            self
        }
        /// <p>The ID for a computation.</p>
        pub fn set_computation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.computation_id = input;
            self
        }
        /// <p>The name of a computation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a computation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time field that is used in a computation.</p>
        pub fn time(mut self, input: crate::model::DimensionField) -> Self {
            self.time = Some(input);
            self
        }
        /// <p>The time field that is used in a computation.</p>
        pub fn set_time(
            mut self,
            input: std::option::Option<crate::model::DimensionField>,
        ) -> Self {
            self.time = input;
            self
        }
        /// <p>The category field that is used in a computation.</p>
        pub fn category(mut self, input: crate::model::DimensionField) -> Self {
            self.category = Some(input);
            self
        }
        /// <p>The category field that is used in a computation.</p>
        pub fn set_category(
            mut self,
            input: std::option::Option<crate::model::DimensionField>,
        ) -> Self {
            self.category = input;
            self
        }
        /// <p>The value field that is used in a computation.</p>
        pub fn value(mut self, input: crate::model::MeasureField) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value field that is used in a computation.</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::MeasureField>) -> Self {
            self.value = input;
            self
        }
        /// <p>The mover size setup of the top and bottom movers computation.</p>
        pub fn mover_size(mut self, input: i32) -> Self {
            self.mover_size = Some(input);
            self
        }
        /// <p>The mover size setup of the top and bottom movers computation.</p>
        pub fn set_mover_size(mut self, input: std::option::Option<i32>) -> Self {
            self.mover_size = input;
            self
        }
        /// <p>The sort order setup of the top and bottom movers computation.</p>
        pub fn sort_order(mut self, input: crate::model::TopBottomSortOrder) -> Self {
            self.sort_order = Some(input);
            self
        }
        /// <p>The sort order setup of the top and bottom movers computation.</p>
        pub fn set_sort_order(
            mut self,
            input: std::option::Option<crate::model::TopBottomSortOrder>,
        ) -> Self {
            self.sort_order = input;
            self
        }
        /// <p>The computation type. Choose from the following options:</p>
        /// <ul>
        /// <li> <p>TOP: Top movers computation.</p> </li>
        /// <li> <p>BOTTOM: Bottom movers computation.</p> </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::TopBottomComputationType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The computation type. Choose from the following options:</p>
        /// <ul>
        /// <li> <p>TOP: Top movers computation.</p> </li>
        /// <li> <p>BOTTOM: Bottom movers computation.</p> </li>
        /// </ul>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::TopBottomComputationType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`TopBottomMoversComputation`](crate::model::TopBottomMoversComputation).
        pub fn build(self) -> crate::model::TopBottomMoversComputation {
            crate::model::TopBottomMoversComputation {
                computation_id: self.computation_id,
                name: self.name,
                time: self.time,
                category: self.category,
                value: self.value,
                mover_size: self.mover_size.unwrap_or_default(),
                sort_order: self.sort_order,
                r#type: self.r#type,
            }
        }
    }
}
impl TopBottomMoversComputation {
    /// Creates a new builder-style object to manufacture [`TopBottomMoversComputation`](crate::model::TopBottomMoversComputation).
    pub fn builder() -> crate::model::top_bottom_movers_computation::Builder {
        crate::model::top_bottom_movers_computation::Builder::default()
    }
}

/// When writing a match expression against `TopBottomComputationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let topbottomcomputationtype = unimplemented!();
/// match topbottomcomputationtype {
///     TopBottomComputationType::Bottom => { /* ... */ },
///     TopBottomComputationType::Top => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `topbottomcomputationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TopBottomComputationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TopBottomComputationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TopBottomComputationType::NewFeature` is defined.
/// Specifically, when `topbottomcomputationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TopBottomComputationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TopBottomComputationType {
    #[allow(missing_docs)] // documentation missing in model
    Bottom,
    #[allow(missing_docs)] // documentation missing in model
    Top,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TopBottomComputationType {
    fn from(s: &str) -> Self {
        match s {
            "BOTTOM" => TopBottomComputationType::Bottom,
            "TOP" => TopBottomComputationType::Top,
            other => TopBottomComputationType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for TopBottomComputationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TopBottomComputationType::from(s))
    }
}
impl TopBottomComputationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TopBottomComputationType::Bottom => "BOTTOM",
            TopBottomComputationType::Top => "TOP",
            TopBottomComputationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BOTTOM", "TOP"]
    }
}
impl AsRef<str> for TopBottomComputationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TopBottomSortOrder`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let topbottomsortorder = unimplemented!();
/// match topbottomsortorder {
///     TopBottomSortOrder::AbsoluteDifference => { /* ... */ },
///     TopBottomSortOrder::PercentDifference => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `topbottomsortorder` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TopBottomSortOrder::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TopBottomSortOrder::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TopBottomSortOrder::NewFeature` is defined.
/// Specifically, when `topbottomsortorder` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TopBottomSortOrder::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TopBottomSortOrder {
    #[allow(missing_docs)] // documentation missing in model
    AbsoluteDifference,
    #[allow(missing_docs)] // documentation missing in model
    PercentDifference,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TopBottomSortOrder {
    fn from(s: &str) -> Self {
        match s {
            "ABSOLUTE_DIFFERENCE" => TopBottomSortOrder::AbsoluteDifference,
            "PERCENT_DIFFERENCE" => TopBottomSortOrder::PercentDifference,
            other => {
                TopBottomSortOrder::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TopBottomSortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TopBottomSortOrder::from(s))
    }
}
impl TopBottomSortOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TopBottomSortOrder::AbsoluteDifference => "ABSOLUTE_DIFFERENCE",
            TopBottomSortOrder::PercentDifference => "PERCENT_DIFFERENCE",
            TopBottomSortOrder::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ABSOLUTE_DIFFERENCE", "PERCENT_DIFFERENCE"]
    }
}
impl AsRef<str> for TopBottomSortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The top ranked and bottom ranked computation configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TopBottomRankedComputation {
    /// <p>The ID for a computation.</p>
    #[doc(hidden)]
    pub computation_id: std::option::Option<std::string::String>,
    /// <p>The name of a computation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The category field that is used in a computation.</p>
    #[doc(hidden)]
    pub category: std::option::Option<crate::model::DimensionField>,
    /// <p>The value field that is used in a computation.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::MeasureField>,
    /// <p>The result size of a top and bottom ranked computation.</p>
    #[doc(hidden)]
    pub result_size: i32,
    /// <p>The computation type. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p>TOP: A top ranked computation.</p> </li>
    /// <li> <p>BOTTOM: A bottom ranked computation.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::TopBottomComputationType>,
}
impl TopBottomRankedComputation {
    /// <p>The ID for a computation.</p>
    pub fn computation_id(&self) -> std::option::Option<&str> {
        self.computation_id.as_deref()
    }
    /// <p>The name of a computation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The category field that is used in a computation.</p>
    pub fn category(&self) -> std::option::Option<&crate::model::DimensionField> {
        self.category.as_ref()
    }
    /// <p>The value field that is used in a computation.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::MeasureField> {
        self.value.as_ref()
    }
    /// <p>The result size of a top and bottom ranked computation.</p>
    pub fn result_size(&self) -> i32 {
        self.result_size
    }
    /// <p>The computation type. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p>TOP: A top ranked computation.</p> </li>
    /// <li> <p>BOTTOM: A bottom ranked computation.</p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&crate::model::TopBottomComputationType> {
        self.r#type.as_ref()
    }
}
/// See [`TopBottomRankedComputation`](crate::model::TopBottomRankedComputation).
pub mod top_bottom_ranked_computation {

    /// A builder for [`TopBottomRankedComputation`](crate::model::TopBottomRankedComputation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) computation_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) category: std::option::Option<crate::model::DimensionField>,
        pub(crate) value: std::option::Option<crate::model::MeasureField>,
        pub(crate) result_size: std::option::Option<i32>,
        pub(crate) r#type: std::option::Option<crate::model::TopBottomComputationType>,
    }
    impl Builder {
        /// <p>The ID for a computation.</p>
        pub fn computation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.computation_id = Some(input.into());
            self
        }
        /// <p>The ID for a computation.</p>
        pub fn set_computation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.computation_id = input;
            self
        }
        /// <p>The name of a computation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a computation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The category field that is used in a computation.</p>
        pub fn category(mut self, input: crate::model::DimensionField) -> Self {
            self.category = Some(input);
            self
        }
        /// <p>The category field that is used in a computation.</p>
        pub fn set_category(
            mut self,
            input: std::option::Option<crate::model::DimensionField>,
        ) -> Self {
            self.category = input;
            self
        }
        /// <p>The value field that is used in a computation.</p>
        pub fn value(mut self, input: crate::model::MeasureField) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value field that is used in a computation.</p>
        pub fn set_value(mut self, input: std::option::Option<crate::model::MeasureField>) -> Self {
            self.value = input;
            self
        }
        /// <p>The result size of a top and bottom ranked computation.</p>
        pub fn result_size(mut self, input: i32) -> Self {
            self.result_size = Some(input);
            self
        }
        /// <p>The result size of a top and bottom ranked computation.</p>
        pub fn set_result_size(mut self, input: std::option::Option<i32>) -> Self {
            self.result_size = input;
            self
        }
        /// <p>The computation type. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p>TOP: A top ranked computation.</p> </li>
        /// <li> <p>BOTTOM: A bottom ranked computation.</p> </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::TopBottomComputationType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The computation type. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p>TOP: A top ranked computation.</p> </li>
        /// <li> <p>BOTTOM: A bottom ranked computation.</p> </li>
        /// </ul>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::TopBottomComputationType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`TopBottomRankedComputation`](crate::model::TopBottomRankedComputation).
        pub fn build(self) -> crate::model::TopBottomRankedComputation {
            crate::model::TopBottomRankedComputation {
                computation_id: self.computation_id,
                name: self.name,
                category: self.category,
                value: self.value,
                result_size: self.result_size.unwrap_or_default(),
                r#type: self.r#type,
            }
        }
    }
}
impl TopBottomRankedComputation {
    /// Creates a new builder-style object to manufacture [`TopBottomRankedComputation`](crate::model::TopBottomRankedComputation).
    pub fn builder() -> crate::model::top_bottom_ranked_computation::Builder {
        crate::model::top_bottom_ranked_computation::Builder::default()
    }
}

/// <p>A word cloud.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/word-cloud.html">Using word clouds</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WordCloudVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration settings of the visual.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::WordCloudChartConfiguration>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    #[doc(hidden)]
    pub column_hierarchies: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
}
impl WordCloudVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration settings of the visual.</p>
    pub fn chart_configuration(
        &self,
    ) -> std::option::Option<&crate::model::WordCloudChartConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    pub fn column_hierarchies(&self) -> std::option::Option<&[crate::model::ColumnHierarchy]> {
        self.column_hierarchies.as_deref()
    }
}
/// See [`WordCloudVisual`](crate::model::WordCloudVisual).
pub mod word_cloud_visual {

    /// A builder for [`WordCloudVisual`](crate::model::WordCloudVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration:
            std::option::Option<crate::model::WordCloudChartConfiguration>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        pub(crate) column_hierarchies:
            std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn chart_configuration(
            mut self,
            input: crate::model::WordCloudChartConfiguration,
        ) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::WordCloudChartConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Appends an item to `column_hierarchies`.
        ///
        /// To override the contents of this collection use [`set_column_hierarchies`](Self::set_column_hierarchies).
        ///
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn column_hierarchies(mut self, input: crate::model::ColumnHierarchy) -> Self {
            let mut v = self.column_hierarchies.unwrap_or_default();
            v.push(input);
            self.column_hierarchies = Some(v);
            self
        }
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn set_column_hierarchies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
        ) -> Self {
            self.column_hierarchies = input;
            self
        }
        /// Consumes the builder and constructs a [`WordCloudVisual`](crate::model::WordCloudVisual).
        pub fn build(self) -> crate::model::WordCloudVisual {
            crate::model::WordCloudVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                actions: self.actions,
                column_hierarchies: self.column_hierarchies,
            }
        }
    }
}
impl WordCloudVisual {
    /// Creates a new builder-style object to manufacture [`WordCloudVisual`](crate::model::WordCloudVisual).
    pub fn builder() -> crate::model::word_cloud_visual::Builder {
        crate::model::word_cloud_visual::Builder::default()
    }
}

/// <p>The option that determines the hierarchy of the fields for a visual element.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnHierarchy {
    /// <p>The option that determines the hierarchy of the fields that are built within a visual's field wells. These fields can't be duplicated to other visuals.</p>
    #[doc(hidden)]
    pub explicit_hierarchy: std::option::Option<crate::model::ExplicitHierarchy>,
    /// <p>The option that determines the hierarchy of any <code>DateTime</code> fields.</p>
    #[doc(hidden)]
    pub date_time_hierarchy: std::option::Option<crate::model::DateTimeHierarchy>,
    /// <p>The option that determines the hierarchy of the fields that are defined during data preparation. These fields are available to use in any analysis that uses the data source.</p>
    #[doc(hidden)]
    pub predefined_hierarchy: std::option::Option<crate::model::PredefinedHierarchy>,
}
impl ColumnHierarchy {
    /// <p>The option that determines the hierarchy of the fields that are built within a visual's field wells. These fields can't be duplicated to other visuals.</p>
    pub fn explicit_hierarchy(&self) -> std::option::Option<&crate::model::ExplicitHierarchy> {
        self.explicit_hierarchy.as_ref()
    }
    /// <p>The option that determines the hierarchy of any <code>DateTime</code> fields.</p>
    pub fn date_time_hierarchy(&self) -> std::option::Option<&crate::model::DateTimeHierarchy> {
        self.date_time_hierarchy.as_ref()
    }
    /// <p>The option that determines the hierarchy of the fields that are defined during data preparation. These fields are available to use in any analysis that uses the data source.</p>
    pub fn predefined_hierarchy(&self) -> std::option::Option<&crate::model::PredefinedHierarchy> {
        self.predefined_hierarchy.as_ref()
    }
}
/// See [`ColumnHierarchy`](crate::model::ColumnHierarchy).
pub mod column_hierarchy {

    /// A builder for [`ColumnHierarchy`](crate::model::ColumnHierarchy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) explicit_hierarchy: std::option::Option<crate::model::ExplicitHierarchy>,
        pub(crate) date_time_hierarchy: std::option::Option<crate::model::DateTimeHierarchy>,
        pub(crate) predefined_hierarchy: std::option::Option<crate::model::PredefinedHierarchy>,
    }
    impl Builder {
        /// <p>The option that determines the hierarchy of the fields that are built within a visual's field wells. These fields can't be duplicated to other visuals.</p>
        pub fn explicit_hierarchy(mut self, input: crate::model::ExplicitHierarchy) -> Self {
            self.explicit_hierarchy = Some(input);
            self
        }
        /// <p>The option that determines the hierarchy of the fields that are built within a visual's field wells. These fields can't be duplicated to other visuals.</p>
        pub fn set_explicit_hierarchy(
            mut self,
            input: std::option::Option<crate::model::ExplicitHierarchy>,
        ) -> Self {
            self.explicit_hierarchy = input;
            self
        }
        /// <p>The option that determines the hierarchy of any <code>DateTime</code> fields.</p>
        pub fn date_time_hierarchy(mut self, input: crate::model::DateTimeHierarchy) -> Self {
            self.date_time_hierarchy = Some(input);
            self
        }
        /// <p>The option that determines the hierarchy of any <code>DateTime</code> fields.</p>
        pub fn set_date_time_hierarchy(
            mut self,
            input: std::option::Option<crate::model::DateTimeHierarchy>,
        ) -> Self {
            self.date_time_hierarchy = input;
            self
        }
        /// <p>The option that determines the hierarchy of the fields that are defined during data preparation. These fields are available to use in any analysis that uses the data source.</p>
        pub fn predefined_hierarchy(mut self, input: crate::model::PredefinedHierarchy) -> Self {
            self.predefined_hierarchy = Some(input);
            self
        }
        /// <p>The option that determines the hierarchy of the fields that are defined during data preparation. These fields are available to use in any analysis that uses the data source.</p>
        pub fn set_predefined_hierarchy(
            mut self,
            input: std::option::Option<crate::model::PredefinedHierarchy>,
        ) -> Self {
            self.predefined_hierarchy = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnHierarchy`](crate::model::ColumnHierarchy).
        pub fn build(self) -> crate::model::ColumnHierarchy {
            crate::model::ColumnHierarchy {
                explicit_hierarchy: self.explicit_hierarchy,
                date_time_hierarchy: self.date_time_hierarchy,
                predefined_hierarchy: self.predefined_hierarchy,
            }
        }
    }
}
impl ColumnHierarchy {
    /// Creates a new builder-style object to manufacture [`ColumnHierarchy`](crate::model::ColumnHierarchy).
    pub fn builder() -> crate::model::column_hierarchy::Builder {
        crate::model::column_hierarchy::Builder::default()
    }
}

/// <p>The option that determines the hierarchy of the fields that are defined during data preparation. These fields are available to use in any analysis that uses the data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PredefinedHierarchy {
    /// <p>The hierarchy ID of the predefined hierarchy.</p>
    #[doc(hidden)]
    pub hierarchy_id: std::option::Option<std::string::String>,
    /// <p>The list of columns that define the predefined hierarchy.</p>
    #[doc(hidden)]
    pub columns: std::option::Option<std::vec::Vec<crate::model::ColumnIdentifier>>,
    /// <p>The option that determines the drill down filters for the predefined hierarchy.</p>
    #[doc(hidden)]
    pub drill_down_filters: std::option::Option<std::vec::Vec<crate::model::DrillDownFilter>>,
}
impl PredefinedHierarchy {
    /// <p>The hierarchy ID of the predefined hierarchy.</p>
    pub fn hierarchy_id(&self) -> std::option::Option<&str> {
        self.hierarchy_id.as_deref()
    }
    /// <p>The list of columns that define the predefined hierarchy.</p>
    pub fn columns(&self) -> std::option::Option<&[crate::model::ColumnIdentifier]> {
        self.columns.as_deref()
    }
    /// <p>The option that determines the drill down filters for the predefined hierarchy.</p>
    pub fn drill_down_filters(&self) -> std::option::Option<&[crate::model::DrillDownFilter]> {
        self.drill_down_filters.as_deref()
    }
}
/// See [`PredefinedHierarchy`](crate::model::PredefinedHierarchy).
pub mod predefined_hierarchy {

    /// A builder for [`PredefinedHierarchy`](crate::model::PredefinedHierarchy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hierarchy_id: std::option::Option<std::string::String>,
        pub(crate) columns: std::option::Option<std::vec::Vec<crate::model::ColumnIdentifier>>,
        pub(crate) drill_down_filters:
            std::option::Option<std::vec::Vec<crate::model::DrillDownFilter>>,
    }
    impl Builder {
        /// <p>The hierarchy ID of the predefined hierarchy.</p>
        pub fn hierarchy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hierarchy_id = Some(input.into());
            self
        }
        /// <p>The hierarchy ID of the predefined hierarchy.</p>
        pub fn set_hierarchy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hierarchy_id = input;
            self
        }
        /// Appends an item to `columns`.
        ///
        /// To override the contents of this collection use [`set_columns`](Self::set_columns).
        ///
        /// <p>The list of columns that define the predefined hierarchy.</p>
        pub fn columns(mut self, input: crate::model::ColumnIdentifier) -> Self {
            let mut v = self.columns.unwrap_or_default();
            v.push(input);
            self.columns = Some(v);
            self
        }
        /// <p>The list of columns that define the predefined hierarchy.</p>
        pub fn set_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnIdentifier>>,
        ) -> Self {
            self.columns = input;
            self
        }
        /// Appends an item to `drill_down_filters`.
        ///
        /// To override the contents of this collection use [`set_drill_down_filters`](Self::set_drill_down_filters).
        ///
        /// <p>The option that determines the drill down filters for the predefined hierarchy.</p>
        pub fn drill_down_filters(mut self, input: crate::model::DrillDownFilter) -> Self {
            let mut v = self.drill_down_filters.unwrap_or_default();
            v.push(input);
            self.drill_down_filters = Some(v);
            self
        }
        /// <p>The option that determines the drill down filters for the predefined hierarchy.</p>
        pub fn set_drill_down_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DrillDownFilter>>,
        ) -> Self {
            self.drill_down_filters = input;
            self
        }
        /// Consumes the builder and constructs a [`PredefinedHierarchy`](crate::model::PredefinedHierarchy).
        pub fn build(self) -> crate::model::PredefinedHierarchy {
            crate::model::PredefinedHierarchy {
                hierarchy_id: self.hierarchy_id,
                columns: self.columns,
                drill_down_filters: self.drill_down_filters,
            }
        }
    }
}
impl PredefinedHierarchy {
    /// Creates a new builder-style object to manufacture [`PredefinedHierarchy`](crate::model::PredefinedHierarchy).
    pub fn builder() -> crate::model::predefined_hierarchy::Builder {
        crate::model::predefined_hierarchy::Builder::default()
    }
}

/// <p>The drill down filter for the column hierarchies.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DrillDownFilter {
    /// <p>The numeric equality type drill down filter. This filter is used for number type columns.</p>
    #[doc(hidden)]
    pub numeric_equality_filter: std::option::Option<crate::model::NumericEqualityDrillDownFilter>,
    /// <p>The category type drill down filter. This filter is used for string type columns.</p>
    #[doc(hidden)]
    pub category_filter: std::option::Option<crate::model::CategoryDrillDownFilter>,
    /// <p>The time range drill down filter. This filter is used for date time columns.</p>
    #[doc(hidden)]
    pub time_range_filter: std::option::Option<crate::model::TimeRangeDrillDownFilter>,
}
impl DrillDownFilter {
    /// <p>The numeric equality type drill down filter. This filter is used for number type columns.</p>
    pub fn numeric_equality_filter(
        &self,
    ) -> std::option::Option<&crate::model::NumericEqualityDrillDownFilter> {
        self.numeric_equality_filter.as_ref()
    }
    /// <p>The category type drill down filter. This filter is used for string type columns.</p>
    pub fn category_filter(&self) -> std::option::Option<&crate::model::CategoryDrillDownFilter> {
        self.category_filter.as_ref()
    }
    /// <p>The time range drill down filter. This filter is used for date time columns.</p>
    pub fn time_range_filter(
        &self,
    ) -> std::option::Option<&crate::model::TimeRangeDrillDownFilter> {
        self.time_range_filter.as_ref()
    }
}
/// See [`DrillDownFilter`](crate::model::DrillDownFilter).
pub mod drill_down_filter {

    /// A builder for [`DrillDownFilter`](crate::model::DrillDownFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) numeric_equality_filter:
            std::option::Option<crate::model::NumericEqualityDrillDownFilter>,
        pub(crate) category_filter: std::option::Option<crate::model::CategoryDrillDownFilter>,
        pub(crate) time_range_filter: std::option::Option<crate::model::TimeRangeDrillDownFilter>,
    }
    impl Builder {
        /// <p>The numeric equality type drill down filter. This filter is used for number type columns.</p>
        pub fn numeric_equality_filter(
            mut self,
            input: crate::model::NumericEqualityDrillDownFilter,
        ) -> Self {
            self.numeric_equality_filter = Some(input);
            self
        }
        /// <p>The numeric equality type drill down filter. This filter is used for number type columns.</p>
        pub fn set_numeric_equality_filter(
            mut self,
            input: std::option::Option<crate::model::NumericEqualityDrillDownFilter>,
        ) -> Self {
            self.numeric_equality_filter = input;
            self
        }
        /// <p>The category type drill down filter. This filter is used for string type columns.</p>
        pub fn category_filter(mut self, input: crate::model::CategoryDrillDownFilter) -> Self {
            self.category_filter = Some(input);
            self
        }
        /// <p>The category type drill down filter. This filter is used for string type columns.</p>
        pub fn set_category_filter(
            mut self,
            input: std::option::Option<crate::model::CategoryDrillDownFilter>,
        ) -> Self {
            self.category_filter = input;
            self
        }
        /// <p>The time range drill down filter. This filter is used for date time columns.</p>
        pub fn time_range_filter(mut self, input: crate::model::TimeRangeDrillDownFilter) -> Self {
            self.time_range_filter = Some(input);
            self
        }
        /// <p>The time range drill down filter. This filter is used for date time columns.</p>
        pub fn set_time_range_filter(
            mut self,
            input: std::option::Option<crate::model::TimeRangeDrillDownFilter>,
        ) -> Self {
            self.time_range_filter = input;
            self
        }
        /// Consumes the builder and constructs a [`DrillDownFilter`](crate::model::DrillDownFilter).
        pub fn build(self) -> crate::model::DrillDownFilter {
            crate::model::DrillDownFilter {
                numeric_equality_filter: self.numeric_equality_filter,
                category_filter: self.category_filter,
                time_range_filter: self.time_range_filter,
            }
        }
    }
}
impl DrillDownFilter {
    /// Creates a new builder-style object to manufacture [`DrillDownFilter`](crate::model::DrillDownFilter).
    pub fn builder() -> crate::model::drill_down_filter::Builder {
        crate::model::drill_down_filter::Builder::default()
    }
}

/// <p>The time range drill down filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimeRangeDrillDownFilter {
    /// <p>The column that the filter is applied to.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The minimum value for the filter value range.</p>
    #[doc(hidden)]
    pub range_minimum: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The maximum value for the filter value range.</p>
    #[doc(hidden)]
    pub range_maximum: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
    #[doc(hidden)]
    pub time_granularity: std::option::Option<crate::model::TimeGranularity>,
}
impl TimeRangeDrillDownFilter {
    /// <p>The column that the filter is applied to.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>The minimum value for the filter value range.</p>
    pub fn range_minimum(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.range_minimum.as_ref()
    }
    /// <p>The maximum value for the filter value range.</p>
    pub fn range_maximum(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.range_maximum.as_ref()
    }
    /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
    pub fn time_granularity(&self) -> std::option::Option<&crate::model::TimeGranularity> {
        self.time_granularity.as_ref()
    }
}
/// See [`TimeRangeDrillDownFilter`](crate::model::TimeRangeDrillDownFilter).
pub mod time_range_drill_down_filter {

    /// A builder for [`TimeRangeDrillDownFilter`](crate::model::TimeRangeDrillDownFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) range_minimum: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) range_maximum: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) time_granularity: std::option::Option<crate::model::TimeGranularity>,
    }
    impl Builder {
        /// <p>The column that the filter is applied to.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that the filter is applied to.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The minimum value for the filter value range.</p>
        pub fn range_minimum(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.range_minimum = Some(input);
            self
        }
        /// <p>The minimum value for the filter value range.</p>
        pub fn set_range_minimum(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.range_minimum = input;
            self
        }
        /// <p>The maximum value for the filter value range.</p>
        pub fn range_maximum(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.range_maximum = Some(input);
            self
        }
        /// <p>The maximum value for the filter value range.</p>
        pub fn set_range_maximum(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.range_maximum = input;
            self
        }
        /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
        pub fn time_granularity(mut self, input: crate::model::TimeGranularity) -> Self {
            self.time_granularity = Some(input);
            self
        }
        /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
        pub fn set_time_granularity(
            mut self,
            input: std::option::Option<crate::model::TimeGranularity>,
        ) -> Self {
            self.time_granularity = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeRangeDrillDownFilter`](crate::model::TimeRangeDrillDownFilter).
        pub fn build(self) -> crate::model::TimeRangeDrillDownFilter {
            crate::model::TimeRangeDrillDownFilter {
                column: self.column,
                range_minimum: self.range_minimum,
                range_maximum: self.range_maximum,
                time_granularity: self.time_granularity,
            }
        }
    }
}
impl TimeRangeDrillDownFilter {
    /// Creates a new builder-style object to manufacture [`TimeRangeDrillDownFilter`](crate::model::TimeRangeDrillDownFilter).
    pub fn builder() -> crate::model::time_range_drill_down_filter::Builder {
        crate::model::time_range_drill_down_filter::Builder::default()
    }
}

/// <p>The numeric equality type drill down filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CategoryDrillDownFilter {
    /// <p>The column that the filter is applied to.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>A list of the string inputs that are the values of the category drill down filter.</p>
    #[doc(hidden)]
    pub category_values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CategoryDrillDownFilter {
    /// <p>The column that the filter is applied to.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>A list of the string inputs that are the values of the category drill down filter.</p>
    pub fn category_values(&self) -> std::option::Option<&[std::string::String]> {
        self.category_values.as_deref()
    }
}
/// See [`CategoryDrillDownFilter`](crate::model::CategoryDrillDownFilter).
pub mod category_drill_down_filter {

    /// A builder for [`CategoryDrillDownFilter`](crate::model::CategoryDrillDownFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) category_values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The column that the filter is applied to.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that the filter is applied to.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// Appends an item to `category_values`.
        ///
        /// To override the contents of this collection use [`set_category_values`](Self::set_category_values).
        ///
        /// <p>A list of the string inputs that are the values of the category drill down filter.</p>
        pub fn category_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.category_values.unwrap_or_default();
            v.push(input.into());
            self.category_values = Some(v);
            self
        }
        /// <p>A list of the string inputs that are the values of the category drill down filter.</p>
        pub fn set_category_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.category_values = input;
            self
        }
        /// Consumes the builder and constructs a [`CategoryDrillDownFilter`](crate::model::CategoryDrillDownFilter).
        pub fn build(self) -> crate::model::CategoryDrillDownFilter {
            crate::model::CategoryDrillDownFilter {
                column: self.column,
                category_values: self.category_values,
            }
        }
    }
}
impl CategoryDrillDownFilter {
    /// Creates a new builder-style object to manufacture [`CategoryDrillDownFilter`](crate::model::CategoryDrillDownFilter).
    pub fn builder() -> crate::model::category_drill_down_filter::Builder {
        crate::model::category_drill_down_filter::Builder::default()
    }
}

/// <p>The category drill down filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NumericEqualityDrillDownFilter {
    /// <p>The column that the filter is applied to.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The value of the double input numeric drill down filter.</p>
    #[doc(hidden)]
    pub value: f64,
}
impl NumericEqualityDrillDownFilter {
    /// <p>The column that the filter is applied to.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>The value of the double input numeric drill down filter.</p>
    pub fn value(&self) -> f64 {
        self.value
    }
}
/// See [`NumericEqualityDrillDownFilter`](crate::model::NumericEqualityDrillDownFilter).
pub mod numeric_equality_drill_down_filter {

    /// A builder for [`NumericEqualityDrillDownFilter`](crate::model::NumericEqualityDrillDownFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The column that the filter is applied to.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that the filter is applied to.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The value of the double input numeric drill down filter.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the double input numeric drill down filter.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`NumericEqualityDrillDownFilter`](crate::model::NumericEqualityDrillDownFilter).
        pub fn build(self) -> crate::model::NumericEqualityDrillDownFilter {
            crate::model::NumericEqualityDrillDownFilter {
                column: self.column,
                value: self.value.unwrap_or_default(),
            }
        }
    }
}
impl NumericEqualityDrillDownFilter {
    /// Creates a new builder-style object to manufacture [`NumericEqualityDrillDownFilter`](crate::model::NumericEqualityDrillDownFilter).
    pub fn builder() -> crate::model::numeric_equality_drill_down_filter::Builder {
        crate::model::numeric_equality_drill_down_filter::Builder::default()
    }
}

/// <p>The option that determines the hierarchy of any <code>DateTime</code> fields.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DateTimeHierarchy {
    /// <p>The hierarchy ID of the <code>DateTime</code> hierarchy.</p>
    #[doc(hidden)]
    pub hierarchy_id: std::option::Option<std::string::String>,
    /// <p>The option that determines the drill down filters for the <code>DateTime</code> hierarchy.</p>
    #[doc(hidden)]
    pub drill_down_filters: std::option::Option<std::vec::Vec<crate::model::DrillDownFilter>>,
}
impl DateTimeHierarchy {
    /// <p>The hierarchy ID of the <code>DateTime</code> hierarchy.</p>
    pub fn hierarchy_id(&self) -> std::option::Option<&str> {
        self.hierarchy_id.as_deref()
    }
    /// <p>The option that determines the drill down filters for the <code>DateTime</code> hierarchy.</p>
    pub fn drill_down_filters(&self) -> std::option::Option<&[crate::model::DrillDownFilter]> {
        self.drill_down_filters.as_deref()
    }
}
/// See [`DateTimeHierarchy`](crate::model::DateTimeHierarchy).
pub mod date_time_hierarchy {

    /// A builder for [`DateTimeHierarchy`](crate::model::DateTimeHierarchy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hierarchy_id: std::option::Option<std::string::String>,
        pub(crate) drill_down_filters:
            std::option::Option<std::vec::Vec<crate::model::DrillDownFilter>>,
    }
    impl Builder {
        /// <p>The hierarchy ID of the <code>DateTime</code> hierarchy.</p>
        pub fn hierarchy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hierarchy_id = Some(input.into());
            self
        }
        /// <p>The hierarchy ID of the <code>DateTime</code> hierarchy.</p>
        pub fn set_hierarchy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hierarchy_id = input;
            self
        }
        /// Appends an item to `drill_down_filters`.
        ///
        /// To override the contents of this collection use [`set_drill_down_filters`](Self::set_drill_down_filters).
        ///
        /// <p>The option that determines the drill down filters for the <code>DateTime</code> hierarchy.</p>
        pub fn drill_down_filters(mut self, input: crate::model::DrillDownFilter) -> Self {
            let mut v = self.drill_down_filters.unwrap_or_default();
            v.push(input);
            self.drill_down_filters = Some(v);
            self
        }
        /// <p>The option that determines the drill down filters for the <code>DateTime</code> hierarchy.</p>
        pub fn set_drill_down_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DrillDownFilter>>,
        ) -> Self {
            self.drill_down_filters = input;
            self
        }
        /// Consumes the builder and constructs a [`DateTimeHierarchy`](crate::model::DateTimeHierarchy).
        pub fn build(self) -> crate::model::DateTimeHierarchy {
            crate::model::DateTimeHierarchy {
                hierarchy_id: self.hierarchy_id,
                drill_down_filters: self.drill_down_filters,
            }
        }
    }
}
impl DateTimeHierarchy {
    /// Creates a new builder-style object to manufacture [`DateTimeHierarchy`](crate::model::DateTimeHierarchy).
    pub fn builder() -> crate::model::date_time_hierarchy::Builder {
        crate::model::date_time_hierarchy::Builder::default()
    }
}

/// <p>The option that determines the hierarchy of the fields that are built within a visual's field wells. These fields can't be duplicated to other visuals.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExplicitHierarchy {
    /// <p>The hierarchy ID of the explicit hierarchy.</p>
    #[doc(hidden)]
    pub hierarchy_id: std::option::Option<std::string::String>,
    /// <p>The list of columns that define the explicit hierarchy.</p>
    #[doc(hidden)]
    pub columns: std::option::Option<std::vec::Vec<crate::model::ColumnIdentifier>>,
    /// <p>The option that determines the drill down filters for the explicit hierarchy.</p>
    #[doc(hidden)]
    pub drill_down_filters: std::option::Option<std::vec::Vec<crate::model::DrillDownFilter>>,
}
impl ExplicitHierarchy {
    /// <p>The hierarchy ID of the explicit hierarchy.</p>
    pub fn hierarchy_id(&self) -> std::option::Option<&str> {
        self.hierarchy_id.as_deref()
    }
    /// <p>The list of columns that define the explicit hierarchy.</p>
    pub fn columns(&self) -> std::option::Option<&[crate::model::ColumnIdentifier]> {
        self.columns.as_deref()
    }
    /// <p>The option that determines the drill down filters for the explicit hierarchy.</p>
    pub fn drill_down_filters(&self) -> std::option::Option<&[crate::model::DrillDownFilter]> {
        self.drill_down_filters.as_deref()
    }
}
/// See [`ExplicitHierarchy`](crate::model::ExplicitHierarchy).
pub mod explicit_hierarchy {

    /// A builder for [`ExplicitHierarchy`](crate::model::ExplicitHierarchy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hierarchy_id: std::option::Option<std::string::String>,
        pub(crate) columns: std::option::Option<std::vec::Vec<crate::model::ColumnIdentifier>>,
        pub(crate) drill_down_filters:
            std::option::Option<std::vec::Vec<crate::model::DrillDownFilter>>,
    }
    impl Builder {
        /// <p>The hierarchy ID of the explicit hierarchy.</p>
        pub fn hierarchy_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hierarchy_id = Some(input.into());
            self
        }
        /// <p>The hierarchy ID of the explicit hierarchy.</p>
        pub fn set_hierarchy_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hierarchy_id = input;
            self
        }
        /// Appends an item to `columns`.
        ///
        /// To override the contents of this collection use [`set_columns`](Self::set_columns).
        ///
        /// <p>The list of columns that define the explicit hierarchy.</p>
        pub fn columns(mut self, input: crate::model::ColumnIdentifier) -> Self {
            let mut v = self.columns.unwrap_or_default();
            v.push(input);
            self.columns = Some(v);
            self
        }
        /// <p>The list of columns that define the explicit hierarchy.</p>
        pub fn set_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnIdentifier>>,
        ) -> Self {
            self.columns = input;
            self
        }
        /// Appends an item to `drill_down_filters`.
        ///
        /// To override the contents of this collection use [`set_drill_down_filters`](Self::set_drill_down_filters).
        ///
        /// <p>The option that determines the drill down filters for the explicit hierarchy.</p>
        pub fn drill_down_filters(mut self, input: crate::model::DrillDownFilter) -> Self {
            let mut v = self.drill_down_filters.unwrap_or_default();
            v.push(input);
            self.drill_down_filters = Some(v);
            self
        }
        /// <p>The option that determines the drill down filters for the explicit hierarchy.</p>
        pub fn set_drill_down_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DrillDownFilter>>,
        ) -> Self {
            self.drill_down_filters = input;
            self
        }
        /// Consumes the builder and constructs a [`ExplicitHierarchy`](crate::model::ExplicitHierarchy).
        pub fn build(self) -> crate::model::ExplicitHierarchy {
            crate::model::ExplicitHierarchy {
                hierarchy_id: self.hierarchy_id,
                columns: self.columns,
                drill_down_filters: self.drill_down_filters,
            }
        }
    }
}
impl ExplicitHierarchy {
    /// Creates a new builder-style object to manufacture [`ExplicitHierarchy`](crate::model::ExplicitHierarchy).
    pub fn builder() -> crate::model::explicit_hierarchy::Builder {
        crate::model::explicit_hierarchy::Builder::default()
    }
}

/// <p>The configuration of a word cloud visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WordCloudChartConfiguration {
    /// <p>The field wells of the visual.</p>
    #[doc(hidden)]
    pub field_wells: std::option::Option<crate::model::WordCloudFieldWells>,
    /// <p>The sort configuration of a word cloud visual.</p>
    #[doc(hidden)]
    pub sort_configuration: std::option::Option<crate::model::WordCloudSortConfiguration>,
    /// <p>The label options (label text, label visibility, and sort icon visibility) for the word cloud category.</p>
    #[doc(hidden)]
    pub category_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The options for a word cloud visual.</p>
    #[doc(hidden)]
    pub word_cloud_options: std::option::Option<crate::model::WordCloudOptions>,
}
impl WordCloudChartConfiguration {
    /// <p>The field wells of the visual.</p>
    pub fn field_wells(&self) -> std::option::Option<&crate::model::WordCloudFieldWells> {
        self.field_wells.as_ref()
    }
    /// <p>The sort configuration of a word cloud visual.</p>
    pub fn sort_configuration(
        &self,
    ) -> std::option::Option<&crate::model::WordCloudSortConfiguration> {
        self.sort_configuration.as_ref()
    }
    /// <p>The label options (label text, label visibility, and sort icon visibility) for the word cloud category.</p>
    pub fn category_label_options(
        &self,
    ) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.category_label_options.as_ref()
    }
    /// <p>The options for a word cloud visual.</p>
    pub fn word_cloud_options(&self) -> std::option::Option<&crate::model::WordCloudOptions> {
        self.word_cloud_options.as_ref()
    }
}
/// See [`WordCloudChartConfiguration`](crate::model::WordCloudChartConfiguration).
pub mod word_cloud_chart_configuration {

    /// A builder for [`WordCloudChartConfiguration`](crate::model::WordCloudChartConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_wells: std::option::Option<crate::model::WordCloudFieldWells>,
        pub(crate) sort_configuration:
            std::option::Option<crate::model::WordCloudSortConfiguration>,
        pub(crate) category_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) word_cloud_options: std::option::Option<crate::model::WordCloudOptions>,
    }
    impl Builder {
        /// <p>The field wells of the visual.</p>
        pub fn field_wells(mut self, input: crate::model::WordCloudFieldWells) -> Self {
            self.field_wells = Some(input);
            self
        }
        /// <p>The field wells of the visual.</p>
        pub fn set_field_wells(
            mut self,
            input: std::option::Option<crate::model::WordCloudFieldWells>,
        ) -> Self {
            self.field_wells = input;
            self
        }
        /// <p>The sort configuration of a word cloud visual.</p>
        pub fn sort_configuration(
            mut self,
            input: crate::model::WordCloudSortConfiguration,
        ) -> Self {
            self.sort_configuration = Some(input);
            self
        }
        /// <p>The sort configuration of a word cloud visual.</p>
        pub fn set_sort_configuration(
            mut self,
            input: std::option::Option<crate::model::WordCloudSortConfiguration>,
        ) -> Self {
            self.sort_configuration = input;
            self
        }
        /// <p>The label options (label text, label visibility, and sort icon visibility) for the word cloud category.</p>
        pub fn category_label_options(
            mut self,
            input: crate::model::ChartAxisLabelOptions,
        ) -> Self {
            self.category_label_options = Some(input);
            self
        }
        /// <p>The label options (label text, label visibility, and sort icon visibility) for the word cloud category.</p>
        pub fn set_category_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.category_label_options = input;
            self
        }
        /// <p>The options for a word cloud visual.</p>
        pub fn word_cloud_options(mut self, input: crate::model::WordCloudOptions) -> Self {
            self.word_cloud_options = Some(input);
            self
        }
        /// <p>The options for a word cloud visual.</p>
        pub fn set_word_cloud_options(
            mut self,
            input: std::option::Option<crate::model::WordCloudOptions>,
        ) -> Self {
            self.word_cloud_options = input;
            self
        }
        /// Consumes the builder and constructs a [`WordCloudChartConfiguration`](crate::model::WordCloudChartConfiguration).
        pub fn build(self) -> crate::model::WordCloudChartConfiguration {
            crate::model::WordCloudChartConfiguration {
                field_wells: self.field_wells,
                sort_configuration: self.sort_configuration,
                category_label_options: self.category_label_options,
                word_cloud_options: self.word_cloud_options,
            }
        }
    }
}
impl WordCloudChartConfiguration {
    /// Creates a new builder-style object to manufacture [`WordCloudChartConfiguration`](crate::model::WordCloudChartConfiguration).
    pub fn builder() -> crate::model::word_cloud_chart_configuration::Builder {
        crate::model::word_cloud_chart_configuration::Builder::default()
    }
}

/// <p>The word cloud options for a word cloud visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WordCloudOptions {
    /// <p>The word orientation options (horizontal, horizontal_and_vertical) for the words in a word cloud.</p>
    #[doc(hidden)]
    pub word_orientation: std::option::Option<crate::model::WordCloudWordOrientation>,
    /// <p>The word scaling options (emphasize, normal) for the words in a word cloud.</p>
    #[doc(hidden)]
    pub word_scaling: std::option::Option<crate::model::WordCloudWordScaling>,
    /// <p>The cloud layout options (fluid, normal) of a word cloud.</p>
    #[doc(hidden)]
    pub cloud_layout: std::option::Option<crate::model::WordCloudCloudLayout>,
    /// <p>The word casing options (lower_case, existing_case) for the words in a word cloud.</p>
    #[doc(hidden)]
    pub word_casing: std::option::Option<crate::model::WordCloudWordCasing>,
    /// <p>The word padding options (none, small, medium, large) for the words in a word cloud.</p>
    #[doc(hidden)]
    pub word_padding: std::option::Option<crate::model::WordCloudWordPadding>,
    /// <p>The length limit of each word from 1-100.</p>
    #[doc(hidden)]
    pub maximum_string_length: std::option::Option<i32>,
}
impl WordCloudOptions {
    /// <p>The word orientation options (horizontal, horizontal_and_vertical) for the words in a word cloud.</p>
    pub fn word_orientation(&self) -> std::option::Option<&crate::model::WordCloudWordOrientation> {
        self.word_orientation.as_ref()
    }
    /// <p>The word scaling options (emphasize, normal) for the words in a word cloud.</p>
    pub fn word_scaling(&self) -> std::option::Option<&crate::model::WordCloudWordScaling> {
        self.word_scaling.as_ref()
    }
    /// <p>The cloud layout options (fluid, normal) of a word cloud.</p>
    pub fn cloud_layout(&self) -> std::option::Option<&crate::model::WordCloudCloudLayout> {
        self.cloud_layout.as_ref()
    }
    /// <p>The word casing options (lower_case, existing_case) for the words in a word cloud.</p>
    pub fn word_casing(&self) -> std::option::Option<&crate::model::WordCloudWordCasing> {
        self.word_casing.as_ref()
    }
    /// <p>The word padding options (none, small, medium, large) for the words in a word cloud.</p>
    pub fn word_padding(&self) -> std::option::Option<&crate::model::WordCloudWordPadding> {
        self.word_padding.as_ref()
    }
    /// <p>The length limit of each word from 1-100.</p>
    pub fn maximum_string_length(&self) -> std::option::Option<i32> {
        self.maximum_string_length
    }
}
/// See [`WordCloudOptions`](crate::model::WordCloudOptions).
pub mod word_cloud_options {

    /// A builder for [`WordCloudOptions`](crate::model::WordCloudOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) word_orientation: std::option::Option<crate::model::WordCloudWordOrientation>,
        pub(crate) word_scaling: std::option::Option<crate::model::WordCloudWordScaling>,
        pub(crate) cloud_layout: std::option::Option<crate::model::WordCloudCloudLayout>,
        pub(crate) word_casing: std::option::Option<crate::model::WordCloudWordCasing>,
        pub(crate) word_padding: std::option::Option<crate::model::WordCloudWordPadding>,
        pub(crate) maximum_string_length: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The word orientation options (horizontal, horizontal_and_vertical) for the words in a word cloud.</p>
        pub fn word_orientation(mut self, input: crate::model::WordCloudWordOrientation) -> Self {
            self.word_orientation = Some(input);
            self
        }
        /// <p>The word orientation options (horizontal, horizontal_and_vertical) for the words in a word cloud.</p>
        pub fn set_word_orientation(
            mut self,
            input: std::option::Option<crate::model::WordCloudWordOrientation>,
        ) -> Self {
            self.word_orientation = input;
            self
        }
        /// <p>The word scaling options (emphasize, normal) for the words in a word cloud.</p>
        pub fn word_scaling(mut self, input: crate::model::WordCloudWordScaling) -> Self {
            self.word_scaling = Some(input);
            self
        }
        /// <p>The word scaling options (emphasize, normal) for the words in a word cloud.</p>
        pub fn set_word_scaling(
            mut self,
            input: std::option::Option<crate::model::WordCloudWordScaling>,
        ) -> Self {
            self.word_scaling = input;
            self
        }
        /// <p>The cloud layout options (fluid, normal) of a word cloud.</p>
        pub fn cloud_layout(mut self, input: crate::model::WordCloudCloudLayout) -> Self {
            self.cloud_layout = Some(input);
            self
        }
        /// <p>The cloud layout options (fluid, normal) of a word cloud.</p>
        pub fn set_cloud_layout(
            mut self,
            input: std::option::Option<crate::model::WordCloudCloudLayout>,
        ) -> Self {
            self.cloud_layout = input;
            self
        }
        /// <p>The word casing options (lower_case, existing_case) for the words in a word cloud.</p>
        pub fn word_casing(mut self, input: crate::model::WordCloudWordCasing) -> Self {
            self.word_casing = Some(input);
            self
        }
        /// <p>The word casing options (lower_case, existing_case) for the words in a word cloud.</p>
        pub fn set_word_casing(
            mut self,
            input: std::option::Option<crate::model::WordCloudWordCasing>,
        ) -> Self {
            self.word_casing = input;
            self
        }
        /// <p>The word padding options (none, small, medium, large) for the words in a word cloud.</p>
        pub fn word_padding(mut self, input: crate::model::WordCloudWordPadding) -> Self {
            self.word_padding = Some(input);
            self
        }
        /// <p>The word padding options (none, small, medium, large) for the words in a word cloud.</p>
        pub fn set_word_padding(
            mut self,
            input: std::option::Option<crate::model::WordCloudWordPadding>,
        ) -> Self {
            self.word_padding = input;
            self
        }
        /// <p>The length limit of each word from 1-100.</p>
        pub fn maximum_string_length(mut self, input: i32) -> Self {
            self.maximum_string_length = Some(input);
            self
        }
        /// <p>The length limit of each word from 1-100.</p>
        pub fn set_maximum_string_length(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_string_length = input;
            self
        }
        /// Consumes the builder and constructs a [`WordCloudOptions`](crate::model::WordCloudOptions).
        pub fn build(self) -> crate::model::WordCloudOptions {
            crate::model::WordCloudOptions {
                word_orientation: self.word_orientation,
                word_scaling: self.word_scaling,
                cloud_layout: self.cloud_layout,
                word_casing: self.word_casing,
                word_padding: self.word_padding,
                maximum_string_length: self.maximum_string_length,
            }
        }
    }
}
impl WordCloudOptions {
    /// Creates a new builder-style object to manufacture [`WordCloudOptions`](crate::model::WordCloudOptions).
    pub fn builder() -> crate::model::word_cloud_options::Builder {
        crate::model::word_cloud_options::Builder::default()
    }
}

/// When writing a match expression against `WordCloudWordPadding`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let wordcloudwordpadding = unimplemented!();
/// match wordcloudwordpadding {
///     WordCloudWordPadding::Large => { /* ... */ },
///     WordCloudWordPadding::Medium => { /* ... */ },
///     WordCloudWordPadding::None => { /* ... */ },
///     WordCloudWordPadding::Small => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `wordcloudwordpadding` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WordCloudWordPadding::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WordCloudWordPadding::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WordCloudWordPadding::NewFeature` is defined.
/// Specifically, when `wordcloudwordpadding` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WordCloudWordPadding::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WordCloudWordPadding {
    #[allow(missing_docs)] // documentation missing in model
    Large,
    #[allow(missing_docs)] // documentation missing in model
    Medium,
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Small,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WordCloudWordPadding {
    fn from(s: &str) -> Self {
        match s {
            "LARGE" => WordCloudWordPadding::Large,
            "MEDIUM" => WordCloudWordPadding::Medium,
            "NONE" => WordCloudWordPadding::None,
            "SMALL" => WordCloudWordPadding::Small,
            other => {
                WordCloudWordPadding::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for WordCloudWordPadding {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WordCloudWordPadding::from(s))
    }
}
impl WordCloudWordPadding {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WordCloudWordPadding::Large => "LARGE",
            WordCloudWordPadding::Medium => "MEDIUM",
            WordCloudWordPadding::None => "NONE",
            WordCloudWordPadding::Small => "SMALL",
            WordCloudWordPadding::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LARGE", "MEDIUM", "NONE", "SMALL"]
    }
}
impl AsRef<str> for WordCloudWordPadding {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `WordCloudWordCasing`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let wordcloudwordcasing = unimplemented!();
/// match wordcloudwordcasing {
///     WordCloudWordCasing::ExistingCase => { /* ... */ },
///     WordCloudWordCasing::LowerCase => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `wordcloudwordcasing` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WordCloudWordCasing::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WordCloudWordCasing::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WordCloudWordCasing::NewFeature` is defined.
/// Specifically, when `wordcloudwordcasing` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WordCloudWordCasing::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WordCloudWordCasing {
    #[allow(missing_docs)] // documentation missing in model
    ExistingCase,
    #[allow(missing_docs)] // documentation missing in model
    LowerCase,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WordCloudWordCasing {
    fn from(s: &str) -> Self {
        match s {
            "EXISTING_CASE" => WordCloudWordCasing::ExistingCase,
            "LOWER_CASE" => WordCloudWordCasing::LowerCase,
            other => {
                WordCloudWordCasing::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for WordCloudWordCasing {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WordCloudWordCasing::from(s))
    }
}
impl WordCloudWordCasing {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WordCloudWordCasing::ExistingCase => "EXISTING_CASE",
            WordCloudWordCasing::LowerCase => "LOWER_CASE",
            WordCloudWordCasing::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EXISTING_CASE", "LOWER_CASE"]
    }
}
impl AsRef<str> for WordCloudWordCasing {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `WordCloudCloudLayout`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let wordcloudcloudlayout = unimplemented!();
/// match wordcloudcloudlayout {
///     WordCloudCloudLayout::Fluid => { /* ... */ },
///     WordCloudCloudLayout::Normal => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `wordcloudcloudlayout` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WordCloudCloudLayout::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WordCloudCloudLayout::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WordCloudCloudLayout::NewFeature` is defined.
/// Specifically, when `wordcloudcloudlayout` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WordCloudCloudLayout::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WordCloudCloudLayout {
    #[allow(missing_docs)] // documentation missing in model
    Fluid,
    #[allow(missing_docs)] // documentation missing in model
    Normal,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WordCloudCloudLayout {
    fn from(s: &str) -> Self {
        match s {
            "FLUID" => WordCloudCloudLayout::Fluid,
            "NORMAL" => WordCloudCloudLayout::Normal,
            other => {
                WordCloudCloudLayout::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for WordCloudCloudLayout {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WordCloudCloudLayout::from(s))
    }
}
impl WordCloudCloudLayout {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WordCloudCloudLayout::Fluid => "FLUID",
            WordCloudCloudLayout::Normal => "NORMAL",
            WordCloudCloudLayout::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FLUID", "NORMAL"]
    }
}
impl AsRef<str> for WordCloudCloudLayout {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `WordCloudWordScaling`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let wordcloudwordscaling = unimplemented!();
/// match wordcloudwordscaling {
///     WordCloudWordScaling::Emphasize => { /* ... */ },
///     WordCloudWordScaling::Normal => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `wordcloudwordscaling` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WordCloudWordScaling::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WordCloudWordScaling::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WordCloudWordScaling::NewFeature` is defined.
/// Specifically, when `wordcloudwordscaling` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WordCloudWordScaling::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WordCloudWordScaling {
    #[allow(missing_docs)] // documentation missing in model
    Emphasize,
    #[allow(missing_docs)] // documentation missing in model
    Normal,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WordCloudWordScaling {
    fn from(s: &str) -> Self {
        match s {
            "EMPHASIZE" => WordCloudWordScaling::Emphasize,
            "NORMAL" => WordCloudWordScaling::Normal,
            other => {
                WordCloudWordScaling::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for WordCloudWordScaling {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WordCloudWordScaling::from(s))
    }
}
impl WordCloudWordScaling {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WordCloudWordScaling::Emphasize => "EMPHASIZE",
            WordCloudWordScaling::Normal => "NORMAL",
            WordCloudWordScaling::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EMPHASIZE", "NORMAL"]
    }
}
impl AsRef<str> for WordCloudWordScaling {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `WordCloudWordOrientation`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let wordcloudwordorientation = unimplemented!();
/// match wordcloudwordorientation {
///     WordCloudWordOrientation::Horizontal => { /* ... */ },
///     WordCloudWordOrientation::HorizontalAndVertical => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `wordcloudwordorientation` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WordCloudWordOrientation::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WordCloudWordOrientation::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WordCloudWordOrientation::NewFeature` is defined.
/// Specifically, when `wordcloudwordorientation` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WordCloudWordOrientation::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WordCloudWordOrientation {
    #[allow(missing_docs)] // documentation missing in model
    Horizontal,
    #[allow(missing_docs)] // documentation missing in model
    HorizontalAndVertical,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WordCloudWordOrientation {
    fn from(s: &str) -> Self {
        match s {
            "HORIZONTAL" => WordCloudWordOrientation::Horizontal,
            "HORIZONTAL_AND_VERTICAL" => WordCloudWordOrientation::HorizontalAndVertical,
            other => WordCloudWordOrientation::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for WordCloudWordOrientation {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WordCloudWordOrientation::from(s))
    }
}
impl WordCloudWordOrientation {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WordCloudWordOrientation::Horizontal => "HORIZONTAL",
            WordCloudWordOrientation::HorizontalAndVertical => "HORIZONTAL_AND_VERTICAL",
            WordCloudWordOrientation::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HORIZONTAL", "HORIZONTAL_AND_VERTICAL"]
    }
}
impl AsRef<str> for WordCloudWordOrientation {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The label options for an axis on a chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ChartAxisLabelOptions {
    /// <p>The visibility of an axis label on a chart. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>VISIBLE</code>: Shows the axis.</p> </li>
    /// <li> <p> <code>HIDDEN</code>: Hides the axis.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The visibility configuration of the sort icon on a chart's axis label.</p>
    #[doc(hidden)]
    pub sort_icon_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The label options for a chart axis.</p>
    #[doc(hidden)]
    pub axis_label_options: std::option::Option<std::vec::Vec<crate::model::AxisLabelOptions>>,
}
impl ChartAxisLabelOptions {
    /// <p>The visibility of an axis label on a chart. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>VISIBLE</code>: Shows the axis.</p> </li>
    /// <li> <p> <code>HIDDEN</code>: Hides the axis.</p> </li>
    /// </ul>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
    /// <p>The visibility configuration of the sort icon on a chart's axis label.</p>
    pub fn sort_icon_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.sort_icon_visibility.as_ref()
    }
    /// <p>The label options for a chart axis.</p>
    pub fn axis_label_options(&self) -> std::option::Option<&[crate::model::AxisLabelOptions]> {
        self.axis_label_options.as_deref()
    }
}
/// See [`ChartAxisLabelOptions`](crate::model::ChartAxisLabelOptions).
pub mod chart_axis_label_options {

    /// A builder for [`ChartAxisLabelOptions`](crate::model::ChartAxisLabelOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) sort_icon_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) axis_label_options:
            std::option::Option<std::vec::Vec<crate::model::AxisLabelOptions>>,
    }
    impl Builder {
        /// <p>The visibility of an axis label on a chart. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>VISIBLE</code>: Shows the axis.</p> </li>
        /// <li> <p> <code>HIDDEN</code>: Hides the axis.</p> </li>
        /// </ul>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility of an axis label on a chart. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>VISIBLE</code>: Shows the axis.</p> </li>
        /// <li> <p> <code>HIDDEN</code>: Hides the axis.</p> </li>
        /// </ul>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// <p>The visibility configuration of the sort icon on a chart's axis label.</p>
        pub fn sort_icon_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.sort_icon_visibility = Some(input);
            self
        }
        /// <p>The visibility configuration of the sort icon on a chart's axis label.</p>
        pub fn set_sort_icon_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.sort_icon_visibility = input;
            self
        }
        /// Appends an item to `axis_label_options`.
        ///
        /// To override the contents of this collection use [`set_axis_label_options`](Self::set_axis_label_options).
        ///
        /// <p>The label options for a chart axis.</p>
        pub fn axis_label_options(mut self, input: crate::model::AxisLabelOptions) -> Self {
            let mut v = self.axis_label_options.unwrap_or_default();
            v.push(input);
            self.axis_label_options = Some(v);
            self
        }
        /// <p>The label options for a chart axis.</p>
        pub fn set_axis_label_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AxisLabelOptions>>,
        ) -> Self {
            self.axis_label_options = input;
            self
        }
        /// Consumes the builder and constructs a [`ChartAxisLabelOptions`](crate::model::ChartAxisLabelOptions).
        pub fn build(self) -> crate::model::ChartAxisLabelOptions {
            crate::model::ChartAxisLabelOptions {
                visibility: self.visibility,
                sort_icon_visibility: self.sort_icon_visibility,
                axis_label_options: self.axis_label_options,
            }
        }
    }
}
impl ChartAxisLabelOptions {
    /// Creates a new builder-style object to manufacture [`ChartAxisLabelOptions`](crate::model::ChartAxisLabelOptions).
    pub fn builder() -> crate::model::chart_axis_label_options::Builder {
        crate::model::chart_axis_label_options::Builder::default()
    }
}

/// <p>The label options for a chart axis. You must specify the field that the label is targeted to.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AxisLabelOptions {
    /// <p>The font configuration of the axis label.</p>
    #[doc(hidden)]
    pub font_configuration: std::option::Option<crate::model::FontConfiguration>,
    /// <p>The text for the axis label.</p>
    #[doc(hidden)]
    pub custom_label: std::option::Option<std::string::String>,
    /// <p>The options that indicate which field the label belongs to.</p>
    #[doc(hidden)]
    pub apply_to: std::option::Option<crate::model::AxisLabelReferenceOptions>,
}
impl AxisLabelOptions {
    /// <p>The font configuration of the axis label.</p>
    pub fn font_configuration(&self) -> std::option::Option<&crate::model::FontConfiguration> {
        self.font_configuration.as_ref()
    }
    /// <p>The text for the axis label.</p>
    pub fn custom_label(&self) -> std::option::Option<&str> {
        self.custom_label.as_deref()
    }
    /// <p>The options that indicate which field the label belongs to.</p>
    pub fn apply_to(&self) -> std::option::Option<&crate::model::AxisLabelReferenceOptions> {
        self.apply_to.as_ref()
    }
}
/// See [`AxisLabelOptions`](crate::model::AxisLabelOptions).
pub mod axis_label_options {

    /// A builder for [`AxisLabelOptions`](crate::model::AxisLabelOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) font_configuration: std::option::Option<crate::model::FontConfiguration>,
        pub(crate) custom_label: std::option::Option<std::string::String>,
        pub(crate) apply_to: std::option::Option<crate::model::AxisLabelReferenceOptions>,
    }
    impl Builder {
        /// <p>The font configuration of the axis label.</p>
        pub fn font_configuration(mut self, input: crate::model::FontConfiguration) -> Self {
            self.font_configuration = Some(input);
            self
        }
        /// <p>The font configuration of the axis label.</p>
        pub fn set_font_configuration(
            mut self,
            input: std::option::Option<crate::model::FontConfiguration>,
        ) -> Self {
            self.font_configuration = input;
            self
        }
        /// <p>The text for the axis label.</p>
        pub fn custom_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_label = Some(input.into());
            self
        }
        /// <p>The text for the axis label.</p>
        pub fn set_custom_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.custom_label = input;
            self
        }
        /// <p>The options that indicate which field the label belongs to.</p>
        pub fn apply_to(mut self, input: crate::model::AxisLabelReferenceOptions) -> Self {
            self.apply_to = Some(input);
            self
        }
        /// <p>The options that indicate which field the label belongs to.</p>
        pub fn set_apply_to(
            mut self,
            input: std::option::Option<crate::model::AxisLabelReferenceOptions>,
        ) -> Self {
            self.apply_to = input;
            self
        }
        /// Consumes the builder and constructs a [`AxisLabelOptions`](crate::model::AxisLabelOptions).
        pub fn build(self) -> crate::model::AxisLabelOptions {
            crate::model::AxisLabelOptions {
                font_configuration: self.font_configuration,
                custom_label: self.custom_label,
                apply_to: self.apply_to,
            }
        }
    }
}
impl AxisLabelOptions {
    /// Creates a new builder-style object to manufacture [`AxisLabelOptions`](crate::model::AxisLabelOptions).
    pub fn builder() -> crate::model::axis_label_options::Builder {
        crate::model::axis_label_options::Builder::default()
    }
}

/// <p>The reference that specifies where the axis label is applied to.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AxisLabelReferenceOptions {
    /// <p>The field that the axis label is targeted to.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The column that the axis label is targeted to.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
}
impl AxisLabelReferenceOptions {
    /// <p>The field that the axis label is targeted to.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The column that the axis label is targeted to.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
}
/// See [`AxisLabelReferenceOptions`](crate::model::AxisLabelReferenceOptions).
pub mod axis_label_reference_options {

    /// A builder for [`AxisLabelReferenceOptions`](crate::model::AxisLabelReferenceOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
    }
    impl Builder {
        /// <p>The field that the axis label is targeted to.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The field that the axis label is targeted to.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The column that the axis label is targeted to.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that the axis label is targeted to.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// Consumes the builder and constructs a [`AxisLabelReferenceOptions`](crate::model::AxisLabelReferenceOptions).
        pub fn build(self) -> crate::model::AxisLabelReferenceOptions {
            crate::model::AxisLabelReferenceOptions {
                field_id: self.field_id,
                column: self.column,
            }
        }
    }
}
impl AxisLabelReferenceOptions {
    /// Creates a new builder-style object to manufacture [`AxisLabelReferenceOptions`](crate::model::AxisLabelReferenceOptions).
    pub fn builder() -> crate::model::axis_label_reference_options::Builder {
        crate::model::axis_label_reference_options::Builder::default()
    }
}

/// <p>The sort configuration of a word cloud visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WordCloudSortConfiguration {
    /// <p>The limit on the number of groups that are displayed in a word cloud.</p>
    #[doc(hidden)]
    pub category_items_limit: std::option::Option<crate::model::ItemsLimitConfiguration>,
    /// <p>The sort configuration of group by fields.</p>
    #[doc(hidden)]
    pub category_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
}
impl WordCloudSortConfiguration {
    /// <p>The limit on the number of groups that are displayed in a word cloud.</p>
    pub fn category_items_limit(
        &self,
    ) -> std::option::Option<&crate::model::ItemsLimitConfiguration> {
        self.category_items_limit.as_ref()
    }
    /// <p>The sort configuration of group by fields.</p>
    pub fn category_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.category_sort.as_deref()
    }
}
/// See [`WordCloudSortConfiguration`](crate::model::WordCloudSortConfiguration).
pub mod word_cloud_sort_configuration {

    /// A builder for [`WordCloudSortConfiguration`](crate::model::WordCloudSortConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category_items_limit: std::option::Option<crate::model::ItemsLimitConfiguration>,
        pub(crate) category_sort:
            std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    }
    impl Builder {
        /// <p>The limit on the number of groups that are displayed in a word cloud.</p>
        pub fn category_items_limit(
            mut self,
            input: crate::model::ItemsLimitConfiguration,
        ) -> Self {
            self.category_items_limit = Some(input);
            self
        }
        /// <p>The limit on the number of groups that are displayed in a word cloud.</p>
        pub fn set_category_items_limit(
            mut self,
            input: std::option::Option<crate::model::ItemsLimitConfiguration>,
        ) -> Self {
            self.category_items_limit = input;
            self
        }
        /// Appends an item to `category_sort`.
        ///
        /// To override the contents of this collection use [`set_category_sort`](Self::set_category_sort).
        ///
        /// <p>The sort configuration of group by fields.</p>
        pub fn category_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.category_sort.unwrap_or_default();
            v.push(input);
            self.category_sort = Some(v);
            self
        }
        /// <p>The sort configuration of group by fields.</p>
        pub fn set_category_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.category_sort = input;
            self
        }
        /// Consumes the builder and constructs a [`WordCloudSortConfiguration`](crate::model::WordCloudSortConfiguration).
        pub fn build(self) -> crate::model::WordCloudSortConfiguration {
            crate::model::WordCloudSortConfiguration {
                category_items_limit: self.category_items_limit,
                category_sort: self.category_sort,
            }
        }
    }
}
impl WordCloudSortConfiguration {
    /// Creates a new builder-style object to manufacture [`WordCloudSortConfiguration`](crate::model::WordCloudSortConfiguration).
    pub fn builder() -> crate::model::word_cloud_sort_configuration::Builder {
        crate::model::word_cloud_sort_configuration::Builder::default()
    }
}

/// <p>The field wells of a word cloud visual.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WordCloudFieldWells {
    /// <p>The aggregated field wells of a word cloud.</p>
    #[doc(hidden)]
    pub word_cloud_aggregated_field_wells:
        std::option::Option<crate::model::WordCloudAggregatedFieldWells>,
}
impl WordCloudFieldWells {
    /// <p>The aggregated field wells of a word cloud.</p>
    pub fn word_cloud_aggregated_field_wells(
        &self,
    ) -> std::option::Option<&crate::model::WordCloudAggregatedFieldWells> {
        self.word_cloud_aggregated_field_wells.as_ref()
    }
}
/// See [`WordCloudFieldWells`](crate::model::WordCloudFieldWells).
pub mod word_cloud_field_wells {

    /// A builder for [`WordCloudFieldWells`](crate::model::WordCloudFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) word_cloud_aggregated_field_wells:
            std::option::Option<crate::model::WordCloudAggregatedFieldWells>,
    }
    impl Builder {
        /// <p>The aggregated field wells of a word cloud.</p>
        pub fn word_cloud_aggregated_field_wells(
            mut self,
            input: crate::model::WordCloudAggregatedFieldWells,
        ) -> Self {
            self.word_cloud_aggregated_field_wells = Some(input);
            self
        }
        /// <p>The aggregated field wells of a word cloud.</p>
        pub fn set_word_cloud_aggregated_field_wells(
            mut self,
            input: std::option::Option<crate::model::WordCloudAggregatedFieldWells>,
        ) -> Self {
            self.word_cloud_aggregated_field_wells = input;
            self
        }
        /// Consumes the builder and constructs a [`WordCloudFieldWells`](crate::model::WordCloudFieldWells).
        pub fn build(self) -> crate::model::WordCloudFieldWells {
            crate::model::WordCloudFieldWells {
                word_cloud_aggregated_field_wells: self.word_cloud_aggregated_field_wells,
            }
        }
    }
}
impl WordCloudFieldWells {
    /// Creates a new builder-style object to manufacture [`WordCloudFieldWells`](crate::model::WordCloudFieldWells).
    pub fn builder() -> crate::model::word_cloud_field_wells::Builder {
        crate::model::word_cloud_field_wells::Builder::default()
    }
}

/// <p>The aggregated field wells of a word cloud.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WordCloudAggregatedFieldWells {
    /// <p>The group by field well of a word cloud. Values are grouped by group by fields.</p>
    #[doc(hidden)]
    pub group_by: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The size field well of a word cloud. Values are aggregated based on group by fields.</p>
    #[doc(hidden)]
    pub size: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
}
impl WordCloudAggregatedFieldWells {
    /// <p>The group by field well of a word cloud. Values are grouped by group by fields.</p>
    pub fn group_by(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.group_by.as_deref()
    }
    /// <p>The size field well of a word cloud. Values are aggregated based on group by fields.</p>
    pub fn size(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.size.as_deref()
    }
}
/// See [`WordCloudAggregatedFieldWells`](crate::model::WordCloudAggregatedFieldWells).
pub mod word_cloud_aggregated_field_wells {

    /// A builder for [`WordCloudAggregatedFieldWells`](crate::model::WordCloudAggregatedFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_by: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) size: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    }
    impl Builder {
        /// Appends an item to `group_by`.
        ///
        /// To override the contents of this collection use [`set_group_by`](Self::set_group_by).
        ///
        /// <p>The group by field well of a word cloud. Values are grouped by group by fields.</p>
        pub fn group_by(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.group_by.unwrap_or_default();
            v.push(input);
            self.group_by = Some(v);
            self
        }
        /// <p>The group by field well of a word cloud. Values are grouped by group by fields.</p>
        pub fn set_group_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.group_by = input;
            self
        }
        /// Appends an item to `size`.
        ///
        /// To override the contents of this collection use [`set_size`](Self::set_size).
        ///
        /// <p>The size field well of a word cloud. Values are aggregated based on group by fields.</p>
        pub fn size(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.size.unwrap_or_default();
            v.push(input);
            self.size = Some(v);
            self
        }
        /// <p>The size field well of a word cloud. Values are aggregated based on group by fields.</p>
        pub fn set_size(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.size = input;
            self
        }
        /// Consumes the builder and constructs a [`WordCloudAggregatedFieldWells`](crate::model::WordCloudAggregatedFieldWells).
        pub fn build(self) -> crate::model::WordCloudAggregatedFieldWells {
            crate::model::WordCloudAggregatedFieldWells {
                group_by: self.group_by,
                size: self.size,
            }
        }
    }
}
impl WordCloudAggregatedFieldWells {
    /// Creates a new builder-style object to manufacture [`WordCloudAggregatedFieldWells`](crate::model::WordCloudAggregatedFieldWells).
    pub fn builder() -> crate::model::word_cloud_aggregated_field_wells::Builder {
        crate::model::word_cloud_aggregated_field_wells::Builder::default()
    }
}

/// <p>A histogram.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/histogram-charts.html">Using histograms</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HistogramVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration for a <code>HistogramVisual</code>.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::HistogramConfiguration>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
}
impl HistogramVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration for a <code>HistogramVisual</code>.</p>
    pub fn chart_configuration(
        &self,
    ) -> std::option::Option<&crate::model::HistogramConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
}
/// See [`HistogramVisual`](crate::model::HistogramVisual).
pub mod histogram_visual {

    /// A builder for [`HistogramVisual`](crate::model::HistogramVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration: std::option::Option<crate::model::HistogramConfiguration>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration for a <code>HistogramVisual</code>.</p>
        pub fn chart_configuration(mut self, input: crate::model::HistogramConfiguration) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration for a <code>HistogramVisual</code>.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::HistogramConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Consumes the builder and constructs a [`HistogramVisual`](crate::model::HistogramVisual).
        pub fn build(self) -> crate::model::HistogramVisual {
            crate::model::HistogramVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                actions: self.actions,
            }
        }
    }
}
impl HistogramVisual {
    /// Creates a new builder-style object to manufacture [`HistogramVisual`](crate::model::HistogramVisual).
    pub fn builder() -> crate::model::histogram_visual::Builder {
        crate::model::histogram_visual::Builder::default()
    }
}

/// <p>The configuration for a <code>HistogramVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HistogramConfiguration {
    /// <p>The field well configuration of a histogram.</p>
    #[doc(hidden)]
    pub field_wells: std::option::Option<crate::model::HistogramFieldWells>,
    /// <p>The options that determine the presentation of the x-axis.</p>
    #[doc(hidden)]
    pub x_axis_display_options: std::option::Option<crate::model::AxisDisplayOptions>,
    /// <p>The options that determine the presentation of the x-axis label.</p>
    #[doc(hidden)]
    pub x_axis_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The options that determine the presentation of the y-axis.</p>
    #[doc(hidden)]
    pub y_axis_display_options: std::option::Option<crate::model::AxisDisplayOptions>,
    /// <p>The options that determine the presentation of histogram bins.</p>
    #[doc(hidden)]
    pub bin_options: std::option::Option<crate::model::HistogramBinOptions>,
    /// <p>The data label configuration of a histogram.</p>
    #[doc(hidden)]
    pub data_labels: std::option::Option<crate::model::DataLabelOptions>,
    /// <p>The tooltip configuration of a histogram.</p>
    #[doc(hidden)]
    pub tooltip: std::option::Option<crate::model::TooltipOptions>,
    /// <p>The visual palette configuration of a histogram.</p>
    #[doc(hidden)]
    pub visual_palette: std::option::Option<crate::model::VisualPalette>,
}
impl HistogramConfiguration {
    /// <p>The field well configuration of a histogram.</p>
    pub fn field_wells(&self) -> std::option::Option<&crate::model::HistogramFieldWells> {
        self.field_wells.as_ref()
    }
    /// <p>The options that determine the presentation of the x-axis.</p>
    pub fn x_axis_display_options(&self) -> std::option::Option<&crate::model::AxisDisplayOptions> {
        self.x_axis_display_options.as_ref()
    }
    /// <p>The options that determine the presentation of the x-axis label.</p>
    pub fn x_axis_label_options(
        &self,
    ) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.x_axis_label_options.as_ref()
    }
    /// <p>The options that determine the presentation of the y-axis.</p>
    pub fn y_axis_display_options(&self) -> std::option::Option<&crate::model::AxisDisplayOptions> {
        self.y_axis_display_options.as_ref()
    }
    /// <p>The options that determine the presentation of histogram bins.</p>
    pub fn bin_options(&self) -> std::option::Option<&crate::model::HistogramBinOptions> {
        self.bin_options.as_ref()
    }
    /// <p>The data label configuration of a histogram.</p>
    pub fn data_labels(&self) -> std::option::Option<&crate::model::DataLabelOptions> {
        self.data_labels.as_ref()
    }
    /// <p>The tooltip configuration of a histogram.</p>
    pub fn tooltip(&self) -> std::option::Option<&crate::model::TooltipOptions> {
        self.tooltip.as_ref()
    }
    /// <p>The visual palette configuration of a histogram.</p>
    pub fn visual_palette(&self) -> std::option::Option<&crate::model::VisualPalette> {
        self.visual_palette.as_ref()
    }
}
/// See [`HistogramConfiguration`](crate::model::HistogramConfiguration).
pub mod histogram_configuration {

    /// A builder for [`HistogramConfiguration`](crate::model::HistogramConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_wells: std::option::Option<crate::model::HistogramFieldWells>,
        pub(crate) x_axis_display_options: std::option::Option<crate::model::AxisDisplayOptions>,
        pub(crate) x_axis_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) y_axis_display_options: std::option::Option<crate::model::AxisDisplayOptions>,
        pub(crate) bin_options: std::option::Option<crate::model::HistogramBinOptions>,
        pub(crate) data_labels: std::option::Option<crate::model::DataLabelOptions>,
        pub(crate) tooltip: std::option::Option<crate::model::TooltipOptions>,
        pub(crate) visual_palette: std::option::Option<crate::model::VisualPalette>,
    }
    impl Builder {
        /// <p>The field well configuration of a histogram.</p>
        pub fn field_wells(mut self, input: crate::model::HistogramFieldWells) -> Self {
            self.field_wells = Some(input);
            self
        }
        /// <p>The field well configuration of a histogram.</p>
        pub fn set_field_wells(
            mut self,
            input: std::option::Option<crate::model::HistogramFieldWells>,
        ) -> Self {
            self.field_wells = input;
            self
        }
        /// <p>The options that determine the presentation of the x-axis.</p>
        pub fn x_axis_display_options(mut self, input: crate::model::AxisDisplayOptions) -> Self {
            self.x_axis_display_options = Some(input);
            self
        }
        /// <p>The options that determine the presentation of the x-axis.</p>
        pub fn set_x_axis_display_options(
            mut self,
            input: std::option::Option<crate::model::AxisDisplayOptions>,
        ) -> Self {
            self.x_axis_display_options = input;
            self
        }
        /// <p>The options that determine the presentation of the x-axis label.</p>
        pub fn x_axis_label_options(mut self, input: crate::model::ChartAxisLabelOptions) -> Self {
            self.x_axis_label_options = Some(input);
            self
        }
        /// <p>The options that determine the presentation of the x-axis label.</p>
        pub fn set_x_axis_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.x_axis_label_options = input;
            self
        }
        /// <p>The options that determine the presentation of the y-axis.</p>
        pub fn y_axis_display_options(mut self, input: crate::model::AxisDisplayOptions) -> Self {
            self.y_axis_display_options = Some(input);
            self
        }
        /// <p>The options that determine the presentation of the y-axis.</p>
        pub fn set_y_axis_display_options(
            mut self,
            input: std::option::Option<crate::model::AxisDisplayOptions>,
        ) -> Self {
            self.y_axis_display_options = input;
            self
        }
        /// <p>The options that determine the presentation of histogram bins.</p>
        pub fn bin_options(mut self, input: crate::model::HistogramBinOptions) -> Self {
            self.bin_options = Some(input);
            self
        }
        /// <p>The options that determine the presentation of histogram bins.</p>
        pub fn set_bin_options(
            mut self,
            input: std::option::Option<crate::model::HistogramBinOptions>,
        ) -> Self {
            self.bin_options = input;
            self
        }
        /// <p>The data label configuration of a histogram.</p>
        pub fn data_labels(mut self, input: crate::model::DataLabelOptions) -> Self {
            self.data_labels = Some(input);
            self
        }
        /// <p>The data label configuration of a histogram.</p>
        pub fn set_data_labels(
            mut self,
            input: std::option::Option<crate::model::DataLabelOptions>,
        ) -> Self {
            self.data_labels = input;
            self
        }
        /// <p>The tooltip configuration of a histogram.</p>
        pub fn tooltip(mut self, input: crate::model::TooltipOptions) -> Self {
            self.tooltip = Some(input);
            self
        }
        /// <p>The tooltip configuration of a histogram.</p>
        pub fn set_tooltip(
            mut self,
            input: std::option::Option<crate::model::TooltipOptions>,
        ) -> Self {
            self.tooltip = input;
            self
        }
        /// <p>The visual palette configuration of a histogram.</p>
        pub fn visual_palette(mut self, input: crate::model::VisualPalette) -> Self {
            self.visual_palette = Some(input);
            self
        }
        /// <p>The visual palette configuration of a histogram.</p>
        pub fn set_visual_palette(
            mut self,
            input: std::option::Option<crate::model::VisualPalette>,
        ) -> Self {
            self.visual_palette = input;
            self
        }
        /// Consumes the builder and constructs a [`HistogramConfiguration`](crate::model::HistogramConfiguration).
        pub fn build(self) -> crate::model::HistogramConfiguration {
            crate::model::HistogramConfiguration {
                field_wells: self.field_wells,
                x_axis_display_options: self.x_axis_display_options,
                x_axis_label_options: self.x_axis_label_options,
                y_axis_display_options: self.y_axis_display_options,
                bin_options: self.bin_options,
                data_labels: self.data_labels,
                tooltip: self.tooltip,
                visual_palette: self.visual_palette,
            }
        }
    }
}
impl HistogramConfiguration {
    /// Creates a new builder-style object to manufacture [`HistogramConfiguration`](crate::model::HistogramConfiguration).
    pub fn builder() -> crate::model::histogram_configuration::Builder {
        crate::model::histogram_configuration::Builder::default()
    }
}

/// <p>The visual display options for the visual palette.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VisualPalette {
    /// <p>The chart color options for the visual palette.</p>
    #[doc(hidden)]
    pub chart_color: std::option::Option<std::string::String>,
    /// <p>The color map options for the visual palette.</p>
    #[doc(hidden)]
    pub color_map: std::option::Option<std::vec::Vec<crate::model::DataPathColor>>,
}
impl VisualPalette {
    /// <p>The chart color options for the visual palette.</p>
    pub fn chart_color(&self) -> std::option::Option<&str> {
        self.chart_color.as_deref()
    }
    /// <p>The color map options for the visual palette.</p>
    pub fn color_map(&self) -> std::option::Option<&[crate::model::DataPathColor]> {
        self.color_map.as_deref()
    }
}
/// See [`VisualPalette`](crate::model::VisualPalette).
pub mod visual_palette {

    /// A builder for [`VisualPalette`](crate::model::VisualPalette).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) chart_color: std::option::Option<std::string::String>,
        pub(crate) color_map: std::option::Option<std::vec::Vec<crate::model::DataPathColor>>,
    }
    impl Builder {
        /// <p>The chart color options for the visual palette.</p>
        pub fn chart_color(mut self, input: impl Into<std::string::String>) -> Self {
            self.chart_color = Some(input.into());
            self
        }
        /// <p>The chart color options for the visual palette.</p>
        pub fn set_chart_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chart_color = input;
            self
        }
        /// Appends an item to `color_map`.
        ///
        /// To override the contents of this collection use [`set_color_map`](Self::set_color_map).
        ///
        /// <p>The color map options for the visual palette.</p>
        pub fn color_map(mut self, input: crate::model::DataPathColor) -> Self {
            let mut v = self.color_map.unwrap_or_default();
            v.push(input);
            self.color_map = Some(v);
            self
        }
        /// <p>The color map options for the visual palette.</p>
        pub fn set_color_map(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataPathColor>>,
        ) -> Self {
            self.color_map = input;
            self
        }
        /// Consumes the builder and constructs a [`VisualPalette`](crate::model::VisualPalette).
        pub fn build(self) -> crate::model::VisualPalette {
            crate::model::VisualPalette {
                chart_color: self.chart_color,
                color_map: self.color_map,
            }
        }
    }
}
impl VisualPalette {
    /// Creates a new builder-style object to manufacture [`VisualPalette`](crate::model::VisualPalette).
    pub fn builder() -> crate::model::visual_palette::Builder {
        crate::model::visual_palette::Builder::default()
    }
}

/// <p>The color map that determines the color options for a particular element.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataPathColor {
    /// <p>The element that the color needs to be applied to.</p>
    #[doc(hidden)]
    pub element: std::option::Option<crate::model::DataPathValue>,
    /// <p>The color that needs to be applied to the element.</p>
    #[doc(hidden)]
    pub color: std::option::Option<std::string::String>,
    /// <p>The time granularity of the field that the color needs to be applied to.</p>
    #[doc(hidden)]
    pub time_granularity: std::option::Option<crate::model::TimeGranularity>,
}
impl DataPathColor {
    /// <p>The element that the color needs to be applied to.</p>
    pub fn element(&self) -> std::option::Option<&crate::model::DataPathValue> {
        self.element.as_ref()
    }
    /// <p>The color that needs to be applied to the element.</p>
    pub fn color(&self) -> std::option::Option<&str> {
        self.color.as_deref()
    }
    /// <p>The time granularity of the field that the color needs to be applied to.</p>
    pub fn time_granularity(&self) -> std::option::Option<&crate::model::TimeGranularity> {
        self.time_granularity.as_ref()
    }
}
/// See [`DataPathColor`](crate::model::DataPathColor).
pub mod data_path_color {

    /// A builder for [`DataPathColor`](crate::model::DataPathColor).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) element: std::option::Option<crate::model::DataPathValue>,
        pub(crate) color: std::option::Option<std::string::String>,
        pub(crate) time_granularity: std::option::Option<crate::model::TimeGranularity>,
    }
    impl Builder {
        /// <p>The element that the color needs to be applied to.</p>
        pub fn element(mut self, input: crate::model::DataPathValue) -> Self {
            self.element = Some(input);
            self
        }
        /// <p>The element that the color needs to be applied to.</p>
        pub fn set_element(
            mut self,
            input: std::option::Option<crate::model::DataPathValue>,
        ) -> Self {
            self.element = input;
            self
        }
        /// <p>The color that needs to be applied to the element.</p>
        pub fn color(mut self, input: impl Into<std::string::String>) -> Self {
            self.color = Some(input.into());
            self
        }
        /// <p>The color that needs to be applied to the element.</p>
        pub fn set_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.color = input;
            self
        }
        /// <p>The time granularity of the field that the color needs to be applied to.</p>
        pub fn time_granularity(mut self, input: crate::model::TimeGranularity) -> Self {
            self.time_granularity = Some(input);
            self
        }
        /// <p>The time granularity of the field that the color needs to be applied to.</p>
        pub fn set_time_granularity(
            mut self,
            input: std::option::Option<crate::model::TimeGranularity>,
        ) -> Self {
            self.time_granularity = input;
            self
        }
        /// Consumes the builder and constructs a [`DataPathColor`](crate::model::DataPathColor).
        pub fn build(self) -> crate::model::DataPathColor {
            crate::model::DataPathColor {
                element: self.element,
                color: self.color,
                time_granularity: self.time_granularity,
            }
        }
    }
}
impl DataPathColor {
    /// Creates a new builder-style object to manufacture [`DataPathColor`](crate::model::DataPathColor).
    pub fn builder() -> crate::model::data_path_color::Builder {
        crate::model::data_path_color::Builder::default()
    }
}

/// <p>The data path that needs to be sorted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataPathValue {
    /// <p>The field ID of the field that needs to be sorted.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The actual value of the field that needs to be sorted.</p>
    #[doc(hidden)]
    pub field_value: std::option::Option<std::string::String>,
}
impl DataPathValue {
    /// <p>The field ID of the field that needs to be sorted.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The actual value of the field that needs to be sorted.</p>
    pub fn field_value(&self) -> std::option::Option<&str> {
        self.field_value.as_deref()
    }
}
impl std::fmt::Debug for DataPathValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataPathValue");
        formatter.field("field_id", &self.field_id);
        formatter.field("field_value", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`DataPathValue`](crate::model::DataPathValue).
pub mod data_path_value {

    /// A builder for [`DataPathValue`](crate::model::DataPathValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) field_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The field ID of the field that needs to be sorted.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The field ID of the field that needs to be sorted.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The actual value of the field that needs to be sorted.</p>
        pub fn field_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_value = Some(input.into());
            self
        }
        /// <p>The actual value of the field that needs to be sorted.</p>
        pub fn set_field_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_value = input;
            self
        }
        /// Consumes the builder and constructs a [`DataPathValue`](crate::model::DataPathValue).
        pub fn build(self) -> crate::model::DataPathValue {
            crate::model::DataPathValue {
                field_id: self.field_id,
                field_value: self.field_value,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("field_id", &self.field_id);
            formatter.field("field_value", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl DataPathValue {
    /// Creates a new builder-style object to manufacture [`DataPathValue`](crate::model::DataPathValue).
    pub fn builder() -> crate::model::data_path_value::Builder {
        crate::model::data_path_value::Builder::default()
    }
}

/// <p>The display options for the visual tooltip.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooltipOptions {
    /// <p>Determines whether or not the tooltip is visible.</p>
    #[doc(hidden)]
    pub tooltip_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The selected type for the tooltip. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>BASIC</code>: A basic tooltip.</p> </li>
    /// <li> <p> <code>DETAILED</code>: A detailed tooltip.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub selected_tooltip_type: std::option::Option<crate::model::SelectedTooltipType>,
    /// <p>The setup for the detailed tooltip. The tooltip setup is always saved. The display type is decided based on the tooltip type.</p>
    #[doc(hidden)]
    pub field_based_tooltip: std::option::Option<crate::model::FieldBasedTooltip>,
}
impl TooltipOptions {
    /// <p>Determines whether or not the tooltip is visible.</p>
    pub fn tooltip_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.tooltip_visibility.as_ref()
    }
    /// <p>The selected type for the tooltip. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>BASIC</code>: A basic tooltip.</p> </li>
    /// <li> <p> <code>DETAILED</code>: A detailed tooltip.</p> </li>
    /// </ul>
    pub fn selected_tooltip_type(&self) -> std::option::Option<&crate::model::SelectedTooltipType> {
        self.selected_tooltip_type.as_ref()
    }
    /// <p>The setup for the detailed tooltip. The tooltip setup is always saved. The display type is decided based on the tooltip type.</p>
    pub fn field_based_tooltip(&self) -> std::option::Option<&crate::model::FieldBasedTooltip> {
        self.field_based_tooltip.as_ref()
    }
}
/// See [`TooltipOptions`](crate::model::TooltipOptions).
pub mod tooltip_options {

    /// A builder for [`TooltipOptions`](crate::model::TooltipOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tooltip_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) selected_tooltip_type: std::option::Option<crate::model::SelectedTooltipType>,
        pub(crate) field_based_tooltip: std::option::Option<crate::model::FieldBasedTooltip>,
    }
    impl Builder {
        /// <p>Determines whether or not the tooltip is visible.</p>
        pub fn tooltip_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.tooltip_visibility = Some(input);
            self
        }
        /// <p>Determines whether or not the tooltip is visible.</p>
        pub fn set_tooltip_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.tooltip_visibility = input;
            self
        }
        /// <p>The selected type for the tooltip. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>BASIC</code>: A basic tooltip.</p> </li>
        /// <li> <p> <code>DETAILED</code>: A detailed tooltip.</p> </li>
        /// </ul>
        pub fn selected_tooltip_type(mut self, input: crate::model::SelectedTooltipType) -> Self {
            self.selected_tooltip_type = Some(input);
            self
        }
        /// <p>The selected type for the tooltip. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>BASIC</code>: A basic tooltip.</p> </li>
        /// <li> <p> <code>DETAILED</code>: A detailed tooltip.</p> </li>
        /// </ul>
        pub fn set_selected_tooltip_type(
            mut self,
            input: std::option::Option<crate::model::SelectedTooltipType>,
        ) -> Self {
            self.selected_tooltip_type = input;
            self
        }
        /// <p>The setup for the detailed tooltip. The tooltip setup is always saved. The display type is decided based on the tooltip type.</p>
        pub fn field_based_tooltip(mut self, input: crate::model::FieldBasedTooltip) -> Self {
            self.field_based_tooltip = Some(input);
            self
        }
        /// <p>The setup for the detailed tooltip. The tooltip setup is always saved. The display type is decided based on the tooltip type.</p>
        pub fn set_field_based_tooltip(
            mut self,
            input: std::option::Option<crate::model::FieldBasedTooltip>,
        ) -> Self {
            self.field_based_tooltip = input;
            self
        }
        /// Consumes the builder and constructs a [`TooltipOptions`](crate::model::TooltipOptions).
        pub fn build(self) -> crate::model::TooltipOptions {
            crate::model::TooltipOptions {
                tooltip_visibility: self.tooltip_visibility,
                selected_tooltip_type: self.selected_tooltip_type,
                field_based_tooltip: self.field_based_tooltip,
            }
        }
    }
}
impl TooltipOptions {
    /// Creates a new builder-style object to manufacture [`TooltipOptions`](crate::model::TooltipOptions).
    pub fn builder() -> crate::model::tooltip_options::Builder {
        crate::model::tooltip_options::Builder::default()
    }
}

/// <p>The setup for the detailed tooltip.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldBasedTooltip {
    /// <p>The visibility of <code>Show aggregations</code>.</p>
    #[doc(hidden)]
    pub aggregation_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The type for the &gt;tooltip title. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>NONE</code>: Doesn't use the primary value as the title.</p> </li>
    /// <li> <p> <code>PRIMARY_VALUE</code>: Uses primary value as the title.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub tooltip_title_type: std::option::Option<crate::model::TooltipTitleType>,
    /// <p>The fields configuration in the tooltip.</p>
    #[doc(hidden)]
    pub tooltip_fields: std::option::Option<std::vec::Vec<crate::model::TooltipItem>>,
}
impl FieldBasedTooltip {
    /// <p>The visibility of <code>Show aggregations</code>.</p>
    pub fn aggregation_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.aggregation_visibility.as_ref()
    }
    /// <p>The type for the &gt;tooltip title. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>NONE</code>: Doesn't use the primary value as the title.</p> </li>
    /// <li> <p> <code>PRIMARY_VALUE</code>: Uses primary value as the title.</p> </li>
    /// </ul>
    pub fn tooltip_title_type(&self) -> std::option::Option<&crate::model::TooltipTitleType> {
        self.tooltip_title_type.as_ref()
    }
    /// <p>The fields configuration in the tooltip.</p>
    pub fn tooltip_fields(&self) -> std::option::Option<&[crate::model::TooltipItem]> {
        self.tooltip_fields.as_deref()
    }
}
/// See [`FieldBasedTooltip`](crate::model::FieldBasedTooltip).
pub mod field_based_tooltip {

    /// A builder for [`FieldBasedTooltip`](crate::model::FieldBasedTooltip).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) aggregation_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) tooltip_title_type: std::option::Option<crate::model::TooltipTitleType>,
        pub(crate) tooltip_fields: std::option::Option<std::vec::Vec<crate::model::TooltipItem>>,
    }
    impl Builder {
        /// <p>The visibility of <code>Show aggregations</code>.</p>
        pub fn aggregation_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.aggregation_visibility = Some(input);
            self
        }
        /// <p>The visibility of <code>Show aggregations</code>.</p>
        pub fn set_aggregation_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.aggregation_visibility = input;
            self
        }
        /// <p>The type for the &gt;tooltip title. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>NONE</code>: Doesn't use the primary value as the title.</p> </li>
        /// <li> <p> <code>PRIMARY_VALUE</code>: Uses primary value as the title.</p> </li>
        /// </ul>
        pub fn tooltip_title_type(mut self, input: crate::model::TooltipTitleType) -> Self {
            self.tooltip_title_type = Some(input);
            self
        }
        /// <p>The type for the &gt;tooltip title. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>NONE</code>: Doesn't use the primary value as the title.</p> </li>
        /// <li> <p> <code>PRIMARY_VALUE</code>: Uses primary value as the title.</p> </li>
        /// </ul>
        pub fn set_tooltip_title_type(
            mut self,
            input: std::option::Option<crate::model::TooltipTitleType>,
        ) -> Self {
            self.tooltip_title_type = input;
            self
        }
        /// Appends an item to `tooltip_fields`.
        ///
        /// To override the contents of this collection use [`set_tooltip_fields`](Self::set_tooltip_fields).
        ///
        /// <p>The fields configuration in the tooltip.</p>
        pub fn tooltip_fields(mut self, input: crate::model::TooltipItem) -> Self {
            let mut v = self.tooltip_fields.unwrap_or_default();
            v.push(input);
            self.tooltip_fields = Some(v);
            self
        }
        /// <p>The fields configuration in the tooltip.</p>
        pub fn set_tooltip_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TooltipItem>>,
        ) -> Self {
            self.tooltip_fields = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldBasedTooltip`](crate::model::FieldBasedTooltip).
        pub fn build(self) -> crate::model::FieldBasedTooltip {
            crate::model::FieldBasedTooltip {
                aggregation_visibility: self.aggregation_visibility,
                tooltip_title_type: self.tooltip_title_type,
                tooltip_fields: self.tooltip_fields,
            }
        }
    }
}
impl FieldBasedTooltip {
    /// Creates a new builder-style object to manufacture [`FieldBasedTooltip`](crate::model::FieldBasedTooltip).
    pub fn builder() -> crate::model::field_based_tooltip::Builder {
        crate::model::field_based_tooltip::Builder::default()
    }
}

/// <p>The tooltip.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooltipItem {
    /// <p>The tooltip item for the fields.</p>
    #[doc(hidden)]
    pub field_tooltip_item: std::option::Option<crate::model::FieldTooltipItem>,
    /// <p>The tooltip item for the columns that are not part of a field well.</p>
    #[doc(hidden)]
    pub column_tooltip_item: std::option::Option<crate::model::ColumnTooltipItem>,
}
impl TooltipItem {
    /// <p>The tooltip item for the fields.</p>
    pub fn field_tooltip_item(&self) -> std::option::Option<&crate::model::FieldTooltipItem> {
        self.field_tooltip_item.as_ref()
    }
    /// <p>The tooltip item for the columns that are not part of a field well.</p>
    pub fn column_tooltip_item(&self) -> std::option::Option<&crate::model::ColumnTooltipItem> {
        self.column_tooltip_item.as_ref()
    }
}
/// See [`TooltipItem`](crate::model::TooltipItem).
pub mod tooltip_item {

    /// A builder for [`TooltipItem`](crate::model::TooltipItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_tooltip_item: std::option::Option<crate::model::FieldTooltipItem>,
        pub(crate) column_tooltip_item: std::option::Option<crate::model::ColumnTooltipItem>,
    }
    impl Builder {
        /// <p>The tooltip item for the fields.</p>
        pub fn field_tooltip_item(mut self, input: crate::model::FieldTooltipItem) -> Self {
            self.field_tooltip_item = Some(input);
            self
        }
        /// <p>The tooltip item for the fields.</p>
        pub fn set_field_tooltip_item(
            mut self,
            input: std::option::Option<crate::model::FieldTooltipItem>,
        ) -> Self {
            self.field_tooltip_item = input;
            self
        }
        /// <p>The tooltip item for the columns that are not part of a field well.</p>
        pub fn column_tooltip_item(mut self, input: crate::model::ColumnTooltipItem) -> Self {
            self.column_tooltip_item = Some(input);
            self
        }
        /// <p>The tooltip item for the columns that are not part of a field well.</p>
        pub fn set_column_tooltip_item(
            mut self,
            input: std::option::Option<crate::model::ColumnTooltipItem>,
        ) -> Self {
            self.column_tooltip_item = input;
            self
        }
        /// Consumes the builder and constructs a [`TooltipItem`](crate::model::TooltipItem).
        pub fn build(self) -> crate::model::TooltipItem {
            crate::model::TooltipItem {
                field_tooltip_item: self.field_tooltip_item,
                column_tooltip_item: self.column_tooltip_item,
            }
        }
    }
}
impl TooltipItem {
    /// Creates a new builder-style object to manufacture [`TooltipItem`](crate::model::TooltipItem).
    pub fn builder() -> crate::model::tooltip_item::Builder {
        crate::model::tooltip_item::Builder::default()
    }
}

/// <p>The tooltip item for the columns that are not part of a field well.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnTooltipItem {
    /// <p>The target column of the tooltip item.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The label of the tooltip item.</p>
    #[doc(hidden)]
    pub label: std::option::Option<std::string::String>,
    /// <p>The visibility of the tooltip item.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The aggregation function of the column tooltip item.</p>
    #[doc(hidden)]
    pub aggregation: std::option::Option<crate::model::AggregationFunction>,
}
impl ColumnTooltipItem {
    /// <p>The target column of the tooltip item.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>The label of the tooltip item.</p>
    pub fn label(&self) -> std::option::Option<&str> {
        self.label.as_deref()
    }
    /// <p>The visibility of the tooltip item.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
    /// <p>The aggregation function of the column tooltip item.</p>
    pub fn aggregation(&self) -> std::option::Option<&crate::model::AggregationFunction> {
        self.aggregation.as_ref()
    }
}
/// See [`ColumnTooltipItem`](crate::model::ColumnTooltipItem).
pub mod column_tooltip_item {

    /// A builder for [`ColumnTooltipItem`](crate::model::ColumnTooltipItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) label: std::option::Option<std::string::String>,
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) aggregation: std::option::Option<crate::model::AggregationFunction>,
    }
    impl Builder {
        /// <p>The target column of the tooltip item.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The target column of the tooltip item.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The label of the tooltip item.</p>
        pub fn label(mut self, input: impl Into<std::string::String>) -> Self {
            self.label = Some(input.into());
            self
        }
        /// <p>The label of the tooltip item.</p>
        pub fn set_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.label = input;
            self
        }
        /// <p>The visibility of the tooltip item.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility of the tooltip item.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// <p>The aggregation function of the column tooltip item.</p>
        pub fn aggregation(mut self, input: crate::model::AggregationFunction) -> Self {
            self.aggregation = Some(input);
            self
        }
        /// <p>The aggregation function of the column tooltip item.</p>
        pub fn set_aggregation(
            mut self,
            input: std::option::Option<crate::model::AggregationFunction>,
        ) -> Self {
            self.aggregation = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnTooltipItem`](crate::model::ColumnTooltipItem).
        pub fn build(self) -> crate::model::ColumnTooltipItem {
            crate::model::ColumnTooltipItem {
                column: self.column,
                label: self.label,
                visibility: self.visibility,
                aggregation: self.aggregation,
            }
        }
    }
}
impl ColumnTooltipItem {
    /// Creates a new builder-style object to manufacture [`ColumnTooltipItem`](crate::model::ColumnTooltipItem).
    pub fn builder() -> crate::model::column_tooltip_item::Builder {
        crate::model::column_tooltip_item::Builder::default()
    }
}

/// <p>The tooltip item for the fields.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldTooltipItem {
    /// <p>The unique ID of the field that is targeted by the tooltip.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The label of the tooltip item.</p>
    #[doc(hidden)]
    pub label: std::option::Option<std::string::String>,
    /// <p>The visibility of the tooltip item.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
}
impl FieldTooltipItem {
    /// <p>The unique ID of the field that is targeted by the tooltip.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The label of the tooltip item.</p>
    pub fn label(&self) -> std::option::Option<&str> {
        self.label.as_deref()
    }
    /// <p>The visibility of the tooltip item.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
}
/// See [`FieldTooltipItem`](crate::model::FieldTooltipItem).
pub mod field_tooltip_item {

    /// A builder for [`FieldTooltipItem`](crate::model::FieldTooltipItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) label: std::option::Option<std::string::String>,
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>The unique ID of the field that is targeted by the tooltip.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the field that is targeted by the tooltip.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The label of the tooltip item.</p>
        pub fn label(mut self, input: impl Into<std::string::String>) -> Self {
            self.label = Some(input.into());
            self
        }
        /// <p>The label of the tooltip item.</p>
        pub fn set_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.label = input;
            self
        }
        /// <p>The visibility of the tooltip item.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility of the tooltip item.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldTooltipItem`](crate::model::FieldTooltipItem).
        pub fn build(self) -> crate::model::FieldTooltipItem {
            crate::model::FieldTooltipItem {
                field_id: self.field_id,
                label: self.label,
                visibility: self.visibility,
            }
        }
    }
}
impl FieldTooltipItem {
    /// Creates a new builder-style object to manufacture [`FieldTooltipItem`](crate::model::FieldTooltipItem).
    pub fn builder() -> crate::model::field_tooltip_item::Builder {
        crate::model::field_tooltip_item::Builder::default()
    }
}

/// When writing a match expression against `TooltipTitleType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let tooltiptitletype = unimplemented!();
/// match tooltiptitletype {
///     TooltipTitleType::None => { /* ... */ },
///     TooltipTitleType::PrimaryValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `tooltiptitletype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TooltipTitleType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TooltipTitleType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TooltipTitleType::NewFeature` is defined.
/// Specifically, when `tooltiptitletype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TooltipTitleType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TooltipTitleType {
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    PrimaryValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TooltipTitleType {
    fn from(s: &str) -> Self {
        match s {
            "NONE" => TooltipTitleType::None,
            "PRIMARY_VALUE" => TooltipTitleType::PrimaryValue,
            other => TooltipTitleType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TooltipTitleType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TooltipTitleType::from(s))
    }
}
impl TooltipTitleType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TooltipTitleType::None => "NONE",
            TooltipTitleType::PrimaryValue => "PRIMARY_VALUE",
            TooltipTitleType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NONE", "PRIMARY_VALUE"]
    }
}
impl AsRef<str> for TooltipTitleType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SelectedTooltipType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let selectedtooltiptype = unimplemented!();
/// match selectedtooltiptype {
///     SelectedTooltipType::Basic => { /* ... */ },
///     SelectedTooltipType::Detailed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `selectedtooltiptype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SelectedTooltipType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SelectedTooltipType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SelectedTooltipType::NewFeature` is defined.
/// Specifically, when `selectedtooltiptype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SelectedTooltipType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SelectedTooltipType {
    #[allow(missing_docs)] // documentation missing in model
    Basic,
    #[allow(missing_docs)] // documentation missing in model
    Detailed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SelectedTooltipType {
    fn from(s: &str) -> Self {
        match s {
            "BASIC" => SelectedTooltipType::Basic,
            "DETAILED" => SelectedTooltipType::Detailed,
            other => {
                SelectedTooltipType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SelectedTooltipType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SelectedTooltipType::from(s))
    }
}
impl SelectedTooltipType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SelectedTooltipType::Basic => "BASIC",
            SelectedTooltipType::Detailed => "DETAILED",
            SelectedTooltipType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BASIC", "DETAILED"]
    }
}
impl AsRef<str> for SelectedTooltipType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The options that determine the presentation of histogram bins.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HistogramBinOptions {
    /// <p>The options that determine the selected bin type.</p>
    #[doc(hidden)]
    pub selected_bin_type: std::option::Option<crate::model::HistogramBinType>,
    /// <p>The options that determine the bin count of a histogram.</p>
    #[doc(hidden)]
    pub bin_count: std::option::Option<crate::model::BinCountOptions>,
    /// <p>The options that determine the bin width of a histogram.</p>
    #[doc(hidden)]
    pub bin_width: std::option::Option<crate::model::BinWidthOptions>,
    /// <p>The options that determine the bin start value.</p>
    #[doc(hidden)]
    pub start_value: std::option::Option<f64>,
}
impl HistogramBinOptions {
    /// <p>The options that determine the selected bin type.</p>
    pub fn selected_bin_type(&self) -> std::option::Option<&crate::model::HistogramBinType> {
        self.selected_bin_type.as_ref()
    }
    /// <p>The options that determine the bin count of a histogram.</p>
    pub fn bin_count(&self) -> std::option::Option<&crate::model::BinCountOptions> {
        self.bin_count.as_ref()
    }
    /// <p>The options that determine the bin width of a histogram.</p>
    pub fn bin_width(&self) -> std::option::Option<&crate::model::BinWidthOptions> {
        self.bin_width.as_ref()
    }
    /// <p>The options that determine the bin start value.</p>
    pub fn start_value(&self) -> std::option::Option<f64> {
        self.start_value
    }
}
/// See [`HistogramBinOptions`](crate::model::HistogramBinOptions).
pub mod histogram_bin_options {

    /// A builder for [`HistogramBinOptions`](crate::model::HistogramBinOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) selected_bin_type: std::option::Option<crate::model::HistogramBinType>,
        pub(crate) bin_count: std::option::Option<crate::model::BinCountOptions>,
        pub(crate) bin_width: std::option::Option<crate::model::BinWidthOptions>,
        pub(crate) start_value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The options that determine the selected bin type.</p>
        pub fn selected_bin_type(mut self, input: crate::model::HistogramBinType) -> Self {
            self.selected_bin_type = Some(input);
            self
        }
        /// <p>The options that determine the selected bin type.</p>
        pub fn set_selected_bin_type(
            mut self,
            input: std::option::Option<crate::model::HistogramBinType>,
        ) -> Self {
            self.selected_bin_type = input;
            self
        }
        /// <p>The options that determine the bin count of a histogram.</p>
        pub fn bin_count(mut self, input: crate::model::BinCountOptions) -> Self {
            self.bin_count = Some(input);
            self
        }
        /// <p>The options that determine the bin count of a histogram.</p>
        pub fn set_bin_count(
            mut self,
            input: std::option::Option<crate::model::BinCountOptions>,
        ) -> Self {
            self.bin_count = input;
            self
        }
        /// <p>The options that determine the bin width of a histogram.</p>
        pub fn bin_width(mut self, input: crate::model::BinWidthOptions) -> Self {
            self.bin_width = Some(input);
            self
        }
        /// <p>The options that determine the bin width of a histogram.</p>
        pub fn set_bin_width(
            mut self,
            input: std::option::Option<crate::model::BinWidthOptions>,
        ) -> Self {
            self.bin_width = input;
            self
        }
        /// <p>The options that determine the bin start value.</p>
        pub fn start_value(mut self, input: f64) -> Self {
            self.start_value = Some(input);
            self
        }
        /// <p>The options that determine the bin start value.</p>
        pub fn set_start_value(mut self, input: std::option::Option<f64>) -> Self {
            self.start_value = input;
            self
        }
        /// Consumes the builder and constructs a [`HistogramBinOptions`](crate::model::HistogramBinOptions).
        pub fn build(self) -> crate::model::HistogramBinOptions {
            crate::model::HistogramBinOptions {
                selected_bin_type: self.selected_bin_type,
                bin_count: self.bin_count,
                bin_width: self.bin_width,
                start_value: self.start_value,
            }
        }
    }
}
impl HistogramBinOptions {
    /// Creates a new builder-style object to manufacture [`HistogramBinOptions`](crate::model::HistogramBinOptions).
    pub fn builder() -> crate::model::histogram_bin_options::Builder {
        crate::model::histogram_bin_options::Builder::default()
    }
}

/// <p>The options that determine the bin width of a histogram.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BinWidthOptions {
    /// <p>The options that determine the bin width value.</p>
    #[doc(hidden)]
    pub value: std::option::Option<f64>,
    /// <p>The options that determine the bin count limit.</p>
    #[doc(hidden)]
    pub bin_count_limit: std::option::Option<i64>,
}
impl BinWidthOptions {
    /// <p>The options that determine the bin width value.</p>
    pub fn value(&self) -> std::option::Option<f64> {
        self.value
    }
    /// <p>The options that determine the bin count limit.</p>
    pub fn bin_count_limit(&self) -> std::option::Option<i64> {
        self.bin_count_limit
    }
}
/// See [`BinWidthOptions`](crate::model::BinWidthOptions).
pub mod bin_width_options {

    /// A builder for [`BinWidthOptions`](crate::model::BinWidthOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<f64>,
        pub(crate) bin_count_limit: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The options that determine the bin width value.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The options that determine the bin width value.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input;
            self
        }
        /// <p>The options that determine the bin count limit.</p>
        pub fn bin_count_limit(mut self, input: i64) -> Self {
            self.bin_count_limit = Some(input);
            self
        }
        /// <p>The options that determine the bin count limit.</p>
        pub fn set_bin_count_limit(mut self, input: std::option::Option<i64>) -> Self {
            self.bin_count_limit = input;
            self
        }
        /// Consumes the builder and constructs a [`BinWidthOptions`](crate::model::BinWidthOptions).
        pub fn build(self) -> crate::model::BinWidthOptions {
            crate::model::BinWidthOptions {
                value: self.value,
                bin_count_limit: self.bin_count_limit,
            }
        }
    }
}
impl BinWidthOptions {
    /// Creates a new builder-style object to manufacture [`BinWidthOptions`](crate::model::BinWidthOptions).
    pub fn builder() -> crate::model::bin_width_options::Builder {
        crate::model::bin_width_options::Builder::default()
    }
}

/// <p>The options that determine the bin count of a histogram.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BinCountOptions {
    /// <p>The options that determine the bin count value.</p>
    #[doc(hidden)]
    pub value: std::option::Option<i32>,
}
impl BinCountOptions {
    /// <p>The options that determine the bin count value.</p>
    pub fn value(&self) -> std::option::Option<i32> {
        self.value
    }
}
/// See [`BinCountOptions`](crate::model::BinCountOptions).
pub mod bin_count_options {

    /// A builder for [`BinCountOptions`](crate::model::BinCountOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The options that determine the bin count value.</p>
        pub fn value(mut self, input: i32) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The options that determine the bin count value.</p>
        pub fn set_value(mut self, input: std::option::Option<i32>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`BinCountOptions`](crate::model::BinCountOptions).
        pub fn build(self) -> crate::model::BinCountOptions {
            crate::model::BinCountOptions { value: self.value }
        }
    }
}
impl BinCountOptions {
    /// Creates a new builder-style object to manufacture [`BinCountOptions`](crate::model::BinCountOptions).
    pub fn builder() -> crate::model::bin_count_options::Builder {
        crate::model::bin_count_options::Builder::default()
    }
}

/// When writing a match expression against `HistogramBinType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let histogrambintype = unimplemented!();
/// match histogrambintype {
///     HistogramBinType::BinCount => { /* ... */ },
///     HistogramBinType::BinWidth => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `histogrambintype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `HistogramBinType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `HistogramBinType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `HistogramBinType::NewFeature` is defined.
/// Specifically, when `histogrambintype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `HistogramBinType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HistogramBinType {
    #[allow(missing_docs)] // documentation missing in model
    BinCount,
    #[allow(missing_docs)] // documentation missing in model
    BinWidth,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for HistogramBinType {
    fn from(s: &str) -> Self {
        match s {
            "BIN_COUNT" => HistogramBinType::BinCount,
            "BIN_WIDTH" => HistogramBinType::BinWidth,
            other => HistogramBinType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for HistogramBinType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HistogramBinType::from(s))
    }
}
impl HistogramBinType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HistogramBinType::BinCount => "BIN_COUNT",
            HistogramBinType::BinWidth => "BIN_WIDTH",
            HistogramBinType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BIN_COUNT", "BIN_WIDTH"]
    }
}
impl AsRef<str> for HistogramBinType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The display options for the axis label.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AxisDisplayOptions {
    /// <p>The tick label options of an axis.</p>
    #[doc(hidden)]
    pub tick_label_options: std::option::Option<crate::model::AxisTickLabelOptions>,
    /// <p>Determines whether or not the axis line is visible.</p>
    #[doc(hidden)]
    pub axis_line_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>Determines whether or not the grid line is visible.</p>
    #[doc(hidden)]
    pub grid_line_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The data options for an axis.</p>
    #[doc(hidden)]
    pub data_options: std::option::Option<crate::model::AxisDataOptions>,
    /// <p>The scroll bar options for an axis.</p>
    #[doc(hidden)]
    pub scrollbar_options: std::option::Option<crate::model::ScrollBarOptions>,
    /// <p>The offset value that determines the starting placement of the axis within a visual's bounds.</p>
    #[doc(hidden)]
    pub axis_offset: std::option::Option<std::string::String>,
}
impl AxisDisplayOptions {
    /// <p>The tick label options of an axis.</p>
    pub fn tick_label_options(&self) -> std::option::Option<&crate::model::AxisTickLabelOptions> {
        self.tick_label_options.as_ref()
    }
    /// <p>Determines whether or not the axis line is visible.</p>
    pub fn axis_line_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.axis_line_visibility.as_ref()
    }
    /// <p>Determines whether or not the grid line is visible.</p>
    pub fn grid_line_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.grid_line_visibility.as_ref()
    }
    /// <p>The data options for an axis.</p>
    pub fn data_options(&self) -> std::option::Option<&crate::model::AxisDataOptions> {
        self.data_options.as_ref()
    }
    /// <p>The scroll bar options for an axis.</p>
    pub fn scrollbar_options(&self) -> std::option::Option<&crate::model::ScrollBarOptions> {
        self.scrollbar_options.as_ref()
    }
    /// <p>The offset value that determines the starting placement of the axis within a visual's bounds.</p>
    pub fn axis_offset(&self) -> std::option::Option<&str> {
        self.axis_offset.as_deref()
    }
}
/// See [`AxisDisplayOptions`](crate::model::AxisDisplayOptions).
pub mod axis_display_options {

    /// A builder for [`AxisDisplayOptions`](crate::model::AxisDisplayOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tick_label_options: std::option::Option<crate::model::AxisTickLabelOptions>,
        pub(crate) axis_line_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) grid_line_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) data_options: std::option::Option<crate::model::AxisDataOptions>,
        pub(crate) scrollbar_options: std::option::Option<crate::model::ScrollBarOptions>,
        pub(crate) axis_offset: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The tick label options of an axis.</p>
        pub fn tick_label_options(mut self, input: crate::model::AxisTickLabelOptions) -> Self {
            self.tick_label_options = Some(input);
            self
        }
        /// <p>The tick label options of an axis.</p>
        pub fn set_tick_label_options(
            mut self,
            input: std::option::Option<crate::model::AxisTickLabelOptions>,
        ) -> Self {
            self.tick_label_options = input;
            self
        }
        /// <p>Determines whether or not the axis line is visible.</p>
        pub fn axis_line_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.axis_line_visibility = Some(input);
            self
        }
        /// <p>Determines whether or not the axis line is visible.</p>
        pub fn set_axis_line_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.axis_line_visibility = input;
            self
        }
        /// <p>Determines whether or not the grid line is visible.</p>
        pub fn grid_line_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.grid_line_visibility = Some(input);
            self
        }
        /// <p>Determines whether or not the grid line is visible.</p>
        pub fn set_grid_line_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.grid_line_visibility = input;
            self
        }
        /// <p>The data options for an axis.</p>
        pub fn data_options(mut self, input: crate::model::AxisDataOptions) -> Self {
            self.data_options = Some(input);
            self
        }
        /// <p>The data options for an axis.</p>
        pub fn set_data_options(
            mut self,
            input: std::option::Option<crate::model::AxisDataOptions>,
        ) -> Self {
            self.data_options = input;
            self
        }
        /// <p>The scroll bar options for an axis.</p>
        pub fn scrollbar_options(mut self, input: crate::model::ScrollBarOptions) -> Self {
            self.scrollbar_options = Some(input);
            self
        }
        /// <p>The scroll bar options for an axis.</p>
        pub fn set_scrollbar_options(
            mut self,
            input: std::option::Option<crate::model::ScrollBarOptions>,
        ) -> Self {
            self.scrollbar_options = input;
            self
        }
        /// <p>The offset value that determines the starting placement of the axis within a visual's bounds.</p>
        pub fn axis_offset(mut self, input: impl Into<std::string::String>) -> Self {
            self.axis_offset = Some(input.into());
            self
        }
        /// <p>The offset value that determines the starting placement of the axis within a visual's bounds.</p>
        pub fn set_axis_offset(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.axis_offset = input;
            self
        }
        /// Consumes the builder and constructs a [`AxisDisplayOptions`](crate::model::AxisDisplayOptions).
        pub fn build(self) -> crate::model::AxisDisplayOptions {
            crate::model::AxisDisplayOptions {
                tick_label_options: self.tick_label_options,
                axis_line_visibility: self.axis_line_visibility,
                grid_line_visibility: self.grid_line_visibility,
                data_options: self.data_options,
                scrollbar_options: self.scrollbar_options,
                axis_offset: self.axis_offset,
            }
        }
    }
}
impl AxisDisplayOptions {
    /// Creates a new builder-style object to manufacture [`AxisDisplayOptions`](crate::model::AxisDisplayOptions).
    pub fn builder() -> crate::model::axis_display_options::Builder {
        crate::model::axis_display_options::Builder::default()
    }
}

/// <p>The visual display options for a data zoom scroll bar.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScrollBarOptions {
    /// <p>The visibility of the data zoom scroll bar.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The visibility range for the data zoom scroll bar.</p>
    #[doc(hidden)]
    pub visible_range: std::option::Option<crate::model::VisibleRangeOptions>,
}
impl ScrollBarOptions {
    /// <p>The visibility of the data zoom scroll bar.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
    /// <p>The visibility range for the data zoom scroll bar.</p>
    pub fn visible_range(&self) -> std::option::Option<&crate::model::VisibleRangeOptions> {
        self.visible_range.as_ref()
    }
}
/// See [`ScrollBarOptions`](crate::model::ScrollBarOptions).
pub mod scroll_bar_options {

    /// A builder for [`ScrollBarOptions`](crate::model::ScrollBarOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) visible_range: std::option::Option<crate::model::VisibleRangeOptions>,
    }
    impl Builder {
        /// <p>The visibility of the data zoom scroll bar.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility of the data zoom scroll bar.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// <p>The visibility range for the data zoom scroll bar.</p>
        pub fn visible_range(mut self, input: crate::model::VisibleRangeOptions) -> Self {
            self.visible_range = Some(input);
            self
        }
        /// <p>The visibility range for the data zoom scroll bar.</p>
        pub fn set_visible_range(
            mut self,
            input: std::option::Option<crate::model::VisibleRangeOptions>,
        ) -> Self {
            self.visible_range = input;
            self
        }
        /// Consumes the builder and constructs a [`ScrollBarOptions`](crate::model::ScrollBarOptions).
        pub fn build(self) -> crate::model::ScrollBarOptions {
            crate::model::ScrollBarOptions {
                visibility: self.visibility,
                visible_range: self.visible_range,
            }
        }
    }
}
impl ScrollBarOptions {
    /// Creates a new builder-style object to manufacture [`ScrollBarOptions`](crate::model::ScrollBarOptions).
    pub fn builder() -> crate::model::scroll_bar_options::Builder {
        crate::model::scroll_bar_options::Builder::default()
    }
}

/// <p>The range options for the data zoom scroll bar.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VisibleRangeOptions {
    /// <p>The percent range in the visible range.</p>
    #[doc(hidden)]
    pub percent_range: std::option::Option<crate::model::PercentVisibleRange>,
}
impl VisibleRangeOptions {
    /// <p>The percent range in the visible range.</p>
    pub fn percent_range(&self) -> std::option::Option<&crate::model::PercentVisibleRange> {
        self.percent_range.as_ref()
    }
}
/// See [`VisibleRangeOptions`](crate::model::VisibleRangeOptions).
pub mod visible_range_options {

    /// A builder for [`VisibleRangeOptions`](crate::model::VisibleRangeOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) percent_range: std::option::Option<crate::model::PercentVisibleRange>,
    }
    impl Builder {
        /// <p>The percent range in the visible range.</p>
        pub fn percent_range(mut self, input: crate::model::PercentVisibleRange) -> Self {
            self.percent_range = Some(input);
            self
        }
        /// <p>The percent range in the visible range.</p>
        pub fn set_percent_range(
            mut self,
            input: std::option::Option<crate::model::PercentVisibleRange>,
        ) -> Self {
            self.percent_range = input;
            self
        }
        /// Consumes the builder and constructs a [`VisibleRangeOptions`](crate::model::VisibleRangeOptions).
        pub fn build(self) -> crate::model::VisibleRangeOptions {
            crate::model::VisibleRangeOptions {
                percent_range: self.percent_range,
            }
        }
    }
}
impl VisibleRangeOptions {
    /// Creates a new builder-style object to manufacture [`VisibleRangeOptions`](crate::model::VisibleRangeOptions).
    pub fn builder() -> crate::model::visible_range_options::Builder {
        crate::model::visible_range_options::Builder::default()
    }
}

/// <p>The percent range in the visible range.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PercentVisibleRange {
    /// <p>The lower bound of the range.</p>
    #[doc(hidden)]
    pub from: std::option::Option<f64>,
    /// <p>The top bound of the range.</p>
    #[doc(hidden)]
    pub to: std::option::Option<f64>,
}
impl PercentVisibleRange {
    /// <p>The lower bound of the range.</p>
    pub fn from(&self) -> std::option::Option<f64> {
        self.from
    }
    /// <p>The top bound of the range.</p>
    pub fn to(&self) -> std::option::Option<f64> {
        self.to
    }
}
/// See [`PercentVisibleRange`](crate::model::PercentVisibleRange).
pub mod percent_visible_range {

    /// A builder for [`PercentVisibleRange`](crate::model::PercentVisibleRange).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) from: std::option::Option<f64>,
        pub(crate) to: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The lower bound of the range.</p>
        pub fn from(mut self, input: f64) -> Self {
            self.from = Some(input);
            self
        }
        /// <p>The lower bound of the range.</p>
        pub fn set_from(mut self, input: std::option::Option<f64>) -> Self {
            self.from = input;
            self
        }
        /// <p>The top bound of the range.</p>
        pub fn to(mut self, input: f64) -> Self {
            self.to = Some(input);
            self
        }
        /// <p>The top bound of the range.</p>
        pub fn set_to(mut self, input: std::option::Option<f64>) -> Self {
            self.to = input;
            self
        }
        /// Consumes the builder and constructs a [`PercentVisibleRange`](crate::model::PercentVisibleRange).
        pub fn build(self) -> crate::model::PercentVisibleRange {
            crate::model::PercentVisibleRange {
                from: self.from,
                to: self.to,
            }
        }
    }
}
impl PercentVisibleRange {
    /// Creates a new builder-style object to manufacture [`PercentVisibleRange`](crate::model::PercentVisibleRange).
    pub fn builder() -> crate::model::percent_visible_range::Builder {
        crate::model::percent_visible_range::Builder::default()
    }
}

/// <p>The data options for an axis.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AxisDataOptions {
    /// <p>The options for an axis with a numeric field.</p>
    #[doc(hidden)]
    pub numeric_axis_options: std::option::Option<crate::model::NumericAxisOptions>,
    /// <p>The options for an axis with a date field.</p>
    #[doc(hidden)]
    pub date_axis_options: std::option::Option<crate::model::DateAxisOptions>,
}
impl AxisDataOptions {
    /// <p>The options for an axis with a numeric field.</p>
    pub fn numeric_axis_options(&self) -> std::option::Option<&crate::model::NumericAxisOptions> {
        self.numeric_axis_options.as_ref()
    }
    /// <p>The options for an axis with a date field.</p>
    pub fn date_axis_options(&self) -> std::option::Option<&crate::model::DateAxisOptions> {
        self.date_axis_options.as_ref()
    }
}
/// See [`AxisDataOptions`](crate::model::AxisDataOptions).
pub mod axis_data_options {

    /// A builder for [`AxisDataOptions`](crate::model::AxisDataOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) numeric_axis_options: std::option::Option<crate::model::NumericAxisOptions>,
        pub(crate) date_axis_options: std::option::Option<crate::model::DateAxisOptions>,
    }
    impl Builder {
        /// <p>The options for an axis with a numeric field.</p>
        pub fn numeric_axis_options(mut self, input: crate::model::NumericAxisOptions) -> Self {
            self.numeric_axis_options = Some(input);
            self
        }
        /// <p>The options for an axis with a numeric field.</p>
        pub fn set_numeric_axis_options(
            mut self,
            input: std::option::Option<crate::model::NumericAxisOptions>,
        ) -> Self {
            self.numeric_axis_options = input;
            self
        }
        /// <p>The options for an axis with a date field.</p>
        pub fn date_axis_options(mut self, input: crate::model::DateAxisOptions) -> Self {
            self.date_axis_options = Some(input);
            self
        }
        /// <p>The options for an axis with a date field.</p>
        pub fn set_date_axis_options(
            mut self,
            input: std::option::Option<crate::model::DateAxisOptions>,
        ) -> Self {
            self.date_axis_options = input;
            self
        }
        /// Consumes the builder and constructs a [`AxisDataOptions`](crate::model::AxisDataOptions).
        pub fn build(self) -> crate::model::AxisDataOptions {
            crate::model::AxisDataOptions {
                numeric_axis_options: self.numeric_axis_options,
                date_axis_options: self.date_axis_options,
            }
        }
    }
}
impl AxisDataOptions {
    /// Creates a new builder-style object to manufacture [`AxisDataOptions`](crate::model::AxisDataOptions).
    pub fn builder() -> crate::model::axis_data_options::Builder {
        crate::model::axis_data_options::Builder::default()
    }
}

/// <p>The options that determine how a date axis is displayed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DateAxisOptions {
    /// <p>Determines whether or not missing dates are displayed.</p>
    #[doc(hidden)]
    pub missing_date_visibility: std::option::Option<crate::model::Visibility>,
}
impl DateAxisOptions {
    /// <p>Determines whether or not missing dates are displayed.</p>
    pub fn missing_date_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.missing_date_visibility.as_ref()
    }
}
/// See [`DateAxisOptions`](crate::model::DateAxisOptions).
pub mod date_axis_options {

    /// A builder for [`DateAxisOptions`](crate::model::DateAxisOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) missing_date_visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>Determines whether or not missing dates are displayed.</p>
        pub fn missing_date_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.missing_date_visibility = Some(input);
            self
        }
        /// <p>Determines whether or not missing dates are displayed.</p>
        pub fn set_missing_date_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.missing_date_visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`DateAxisOptions`](crate::model::DateAxisOptions).
        pub fn build(self) -> crate::model::DateAxisOptions {
            crate::model::DateAxisOptions {
                missing_date_visibility: self.missing_date_visibility,
            }
        }
    }
}
impl DateAxisOptions {
    /// Creates a new builder-style object to manufacture [`DateAxisOptions`](crate::model::DateAxisOptions).
    pub fn builder() -> crate::model::date_axis_options::Builder {
        crate::model::date_axis_options::Builder::default()
    }
}

/// <p>The options for an axis with a numeric field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NumericAxisOptions {
    /// <p>The scale setup of a numeric axis.</p>
    #[doc(hidden)]
    pub scale: std::option::Option<crate::model::AxisScale>,
    /// <p>The range setup of a numeric axis.</p>
    #[doc(hidden)]
    pub range: std::option::Option<crate::model::AxisDisplayRange>,
}
impl NumericAxisOptions {
    /// <p>The scale setup of a numeric axis.</p>
    pub fn scale(&self) -> std::option::Option<&crate::model::AxisScale> {
        self.scale.as_ref()
    }
    /// <p>The range setup of a numeric axis.</p>
    pub fn range(&self) -> std::option::Option<&crate::model::AxisDisplayRange> {
        self.range.as_ref()
    }
}
/// See [`NumericAxisOptions`](crate::model::NumericAxisOptions).
pub mod numeric_axis_options {

    /// A builder for [`NumericAxisOptions`](crate::model::NumericAxisOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scale: std::option::Option<crate::model::AxisScale>,
        pub(crate) range: std::option::Option<crate::model::AxisDisplayRange>,
    }
    impl Builder {
        /// <p>The scale setup of a numeric axis.</p>
        pub fn scale(mut self, input: crate::model::AxisScale) -> Self {
            self.scale = Some(input);
            self
        }
        /// <p>The scale setup of a numeric axis.</p>
        pub fn set_scale(mut self, input: std::option::Option<crate::model::AxisScale>) -> Self {
            self.scale = input;
            self
        }
        /// <p>The range setup of a numeric axis.</p>
        pub fn range(mut self, input: crate::model::AxisDisplayRange) -> Self {
            self.range = Some(input);
            self
        }
        /// <p>The range setup of a numeric axis.</p>
        pub fn set_range(
            mut self,
            input: std::option::Option<crate::model::AxisDisplayRange>,
        ) -> Self {
            self.range = input;
            self
        }
        /// Consumes the builder and constructs a [`NumericAxisOptions`](crate::model::NumericAxisOptions).
        pub fn build(self) -> crate::model::NumericAxisOptions {
            crate::model::NumericAxisOptions {
                scale: self.scale,
                range: self.range,
            }
        }
    }
}
impl NumericAxisOptions {
    /// Creates a new builder-style object to manufacture [`NumericAxisOptions`](crate::model::NumericAxisOptions).
    pub fn builder() -> crate::model::numeric_axis_options::Builder {
        crate::model::numeric_axis_options::Builder::default()
    }
}

/// <p>The range setup of a numeric axis display range.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AxisDisplayRange {
    /// <p>The minimum and maximum setup of an axis display range.</p>
    #[doc(hidden)]
    pub min_max: std::option::Option<crate::model::AxisDisplayMinMaxRange>,
    /// <p>The data-driven setup of an axis display range.</p>
    #[doc(hidden)]
    pub data_driven: std::option::Option<crate::model::AxisDisplayDataDrivenRange>,
}
impl AxisDisplayRange {
    /// <p>The minimum and maximum setup of an axis display range.</p>
    pub fn min_max(&self) -> std::option::Option<&crate::model::AxisDisplayMinMaxRange> {
        self.min_max.as_ref()
    }
    /// <p>The data-driven setup of an axis display range.</p>
    pub fn data_driven(&self) -> std::option::Option<&crate::model::AxisDisplayDataDrivenRange> {
        self.data_driven.as_ref()
    }
}
/// See [`AxisDisplayRange`](crate::model::AxisDisplayRange).
pub mod axis_display_range {

    /// A builder for [`AxisDisplayRange`](crate::model::AxisDisplayRange).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) min_max: std::option::Option<crate::model::AxisDisplayMinMaxRange>,
        pub(crate) data_driven: std::option::Option<crate::model::AxisDisplayDataDrivenRange>,
    }
    impl Builder {
        /// <p>The minimum and maximum setup of an axis display range.</p>
        pub fn min_max(mut self, input: crate::model::AxisDisplayMinMaxRange) -> Self {
            self.min_max = Some(input);
            self
        }
        /// <p>The minimum and maximum setup of an axis display range.</p>
        pub fn set_min_max(
            mut self,
            input: std::option::Option<crate::model::AxisDisplayMinMaxRange>,
        ) -> Self {
            self.min_max = input;
            self
        }
        /// <p>The data-driven setup of an axis display range.</p>
        pub fn data_driven(mut self, input: crate::model::AxisDisplayDataDrivenRange) -> Self {
            self.data_driven = Some(input);
            self
        }
        /// <p>The data-driven setup of an axis display range.</p>
        pub fn set_data_driven(
            mut self,
            input: std::option::Option<crate::model::AxisDisplayDataDrivenRange>,
        ) -> Self {
            self.data_driven = input;
            self
        }
        /// Consumes the builder and constructs a [`AxisDisplayRange`](crate::model::AxisDisplayRange).
        pub fn build(self) -> crate::model::AxisDisplayRange {
            crate::model::AxisDisplayRange {
                min_max: self.min_max,
                data_driven: self.data_driven,
            }
        }
    }
}
impl AxisDisplayRange {
    /// Creates a new builder-style object to manufacture [`AxisDisplayRange`](crate::model::AxisDisplayRange).
    pub fn builder() -> crate::model::axis_display_range::Builder {
        crate::model::axis_display_range::Builder::default()
    }
}

/// <p>The options that are saved for future extension.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AxisDisplayDataDrivenRange {}
/// See [`AxisDisplayDataDrivenRange`](crate::model::AxisDisplayDataDrivenRange).
pub mod axis_display_data_driven_range {

    /// A builder for [`AxisDisplayDataDrivenRange`](crate::model::AxisDisplayDataDrivenRange).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`AxisDisplayDataDrivenRange`](crate::model::AxisDisplayDataDrivenRange).
        pub fn build(self) -> crate::model::AxisDisplayDataDrivenRange {
            crate::model::AxisDisplayDataDrivenRange {}
        }
    }
}
impl AxisDisplayDataDrivenRange {
    /// Creates a new builder-style object to manufacture [`AxisDisplayDataDrivenRange`](crate::model::AxisDisplayDataDrivenRange).
    pub fn builder() -> crate::model::axis_display_data_driven_range::Builder {
        crate::model::axis_display_data_driven_range::Builder::default()
    }
}

/// <p>The minimum and maximum setup for an axis display range.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AxisDisplayMinMaxRange {
    /// <p>The minimum setup for an axis display range.</p>
    #[doc(hidden)]
    pub minimum: std::option::Option<f64>,
    /// <p>The maximum setup for an axis display range.</p>
    #[doc(hidden)]
    pub maximum: std::option::Option<f64>,
}
impl AxisDisplayMinMaxRange {
    /// <p>The minimum setup for an axis display range.</p>
    pub fn minimum(&self) -> std::option::Option<f64> {
        self.minimum
    }
    /// <p>The maximum setup for an axis display range.</p>
    pub fn maximum(&self) -> std::option::Option<f64> {
        self.maximum
    }
}
/// See [`AxisDisplayMinMaxRange`](crate::model::AxisDisplayMinMaxRange).
pub mod axis_display_min_max_range {

    /// A builder for [`AxisDisplayMinMaxRange`](crate::model::AxisDisplayMinMaxRange).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) minimum: std::option::Option<f64>,
        pub(crate) maximum: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The minimum setup for an axis display range.</p>
        pub fn minimum(mut self, input: f64) -> Self {
            self.minimum = Some(input);
            self
        }
        /// <p>The minimum setup for an axis display range.</p>
        pub fn set_minimum(mut self, input: std::option::Option<f64>) -> Self {
            self.minimum = input;
            self
        }
        /// <p>The maximum setup for an axis display range.</p>
        pub fn maximum(mut self, input: f64) -> Self {
            self.maximum = Some(input);
            self
        }
        /// <p>The maximum setup for an axis display range.</p>
        pub fn set_maximum(mut self, input: std::option::Option<f64>) -> Self {
            self.maximum = input;
            self
        }
        /// Consumes the builder and constructs a [`AxisDisplayMinMaxRange`](crate::model::AxisDisplayMinMaxRange).
        pub fn build(self) -> crate::model::AxisDisplayMinMaxRange {
            crate::model::AxisDisplayMinMaxRange {
                minimum: self.minimum,
                maximum: self.maximum,
            }
        }
    }
}
impl AxisDisplayMinMaxRange {
    /// Creates a new builder-style object to manufacture [`AxisDisplayMinMaxRange`](crate::model::AxisDisplayMinMaxRange).
    pub fn builder() -> crate::model::axis_display_min_max_range::Builder {
        crate::model::axis_display_min_max_range::Builder::default()
    }
}

/// <p>The scale setup options for a numeric axis display.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AxisScale {
    /// <p>The linear axis scale setup.</p>
    #[doc(hidden)]
    pub linear: std::option::Option<crate::model::AxisLinearScale>,
    /// <p>The logarithmic axis scale setup.</p>
    #[doc(hidden)]
    pub logarithmic: std::option::Option<crate::model::AxisLogarithmicScale>,
}
impl AxisScale {
    /// <p>The linear axis scale setup.</p>
    pub fn linear(&self) -> std::option::Option<&crate::model::AxisLinearScale> {
        self.linear.as_ref()
    }
    /// <p>The logarithmic axis scale setup.</p>
    pub fn logarithmic(&self) -> std::option::Option<&crate::model::AxisLogarithmicScale> {
        self.logarithmic.as_ref()
    }
}
/// See [`AxisScale`](crate::model::AxisScale).
pub mod axis_scale {

    /// A builder for [`AxisScale`](crate::model::AxisScale).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) linear: std::option::Option<crate::model::AxisLinearScale>,
        pub(crate) logarithmic: std::option::Option<crate::model::AxisLogarithmicScale>,
    }
    impl Builder {
        /// <p>The linear axis scale setup.</p>
        pub fn linear(mut self, input: crate::model::AxisLinearScale) -> Self {
            self.linear = Some(input);
            self
        }
        /// <p>The linear axis scale setup.</p>
        pub fn set_linear(
            mut self,
            input: std::option::Option<crate::model::AxisLinearScale>,
        ) -> Self {
            self.linear = input;
            self
        }
        /// <p>The logarithmic axis scale setup.</p>
        pub fn logarithmic(mut self, input: crate::model::AxisLogarithmicScale) -> Self {
            self.logarithmic = Some(input);
            self
        }
        /// <p>The logarithmic axis scale setup.</p>
        pub fn set_logarithmic(
            mut self,
            input: std::option::Option<crate::model::AxisLogarithmicScale>,
        ) -> Self {
            self.logarithmic = input;
            self
        }
        /// Consumes the builder and constructs a [`AxisScale`](crate::model::AxisScale).
        pub fn build(self) -> crate::model::AxisScale {
            crate::model::AxisScale {
                linear: self.linear,
                logarithmic: self.logarithmic,
            }
        }
    }
}
impl AxisScale {
    /// Creates a new builder-style object to manufacture [`AxisScale`](crate::model::AxisScale).
    pub fn builder() -> crate::model::axis_scale::Builder {
        crate::model::axis_scale::Builder::default()
    }
}

/// <p>The logarithmic axis scale setup.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AxisLogarithmicScale {
    /// <p>The base setup of a logarithmic axis scale.</p>
    #[doc(hidden)]
    pub base: std::option::Option<f64>,
}
impl AxisLogarithmicScale {
    /// <p>The base setup of a logarithmic axis scale.</p>
    pub fn base(&self) -> std::option::Option<f64> {
        self.base
    }
}
/// See [`AxisLogarithmicScale`](crate::model::AxisLogarithmicScale).
pub mod axis_logarithmic_scale {

    /// A builder for [`AxisLogarithmicScale`](crate::model::AxisLogarithmicScale).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) base: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The base setup of a logarithmic axis scale.</p>
        pub fn base(mut self, input: f64) -> Self {
            self.base = Some(input);
            self
        }
        /// <p>The base setup of a logarithmic axis scale.</p>
        pub fn set_base(mut self, input: std::option::Option<f64>) -> Self {
            self.base = input;
            self
        }
        /// Consumes the builder and constructs a [`AxisLogarithmicScale`](crate::model::AxisLogarithmicScale).
        pub fn build(self) -> crate::model::AxisLogarithmicScale {
            crate::model::AxisLogarithmicScale { base: self.base }
        }
    }
}
impl AxisLogarithmicScale {
    /// Creates a new builder-style object to manufacture [`AxisLogarithmicScale`](crate::model::AxisLogarithmicScale).
    pub fn builder() -> crate::model::axis_logarithmic_scale::Builder {
        crate::model::axis_logarithmic_scale::Builder::default()
    }
}

/// <p>The liner axis scale setup.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AxisLinearScale {
    /// <p>The step count setup of a linear axis.</p>
    #[doc(hidden)]
    pub step_count: std::option::Option<i32>,
    /// <p>The step size setup of a linear axis.</p>
    #[doc(hidden)]
    pub step_size: std::option::Option<f64>,
}
impl AxisLinearScale {
    /// <p>The step count setup of a linear axis.</p>
    pub fn step_count(&self) -> std::option::Option<i32> {
        self.step_count
    }
    /// <p>The step size setup of a linear axis.</p>
    pub fn step_size(&self) -> std::option::Option<f64> {
        self.step_size
    }
}
/// See [`AxisLinearScale`](crate::model::AxisLinearScale).
pub mod axis_linear_scale {

    /// A builder for [`AxisLinearScale`](crate::model::AxisLinearScale).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) step_count: std::option::Option<i32>,
        pub(crate) step_size: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The step count setup of a linear axis.</p>
        pub fn step_count(mut self, input: i32) -> Self {
            self.step_count = Some(input);
            self
        }
        /// <p>The step count setup of a linear axis.</p>
        pub fn set_step_count(mut self, input: std::option::Option<i32>) -> Self {
            self.step_count = input;
            self
        }
        /// <p>The step size setup of a linear axis.</p>
        pub fn step_size(mut self, input: f64) -> Self {
            self.step_size = Some(input);
            self
        }
        /// <p>The step size setup of a linear axis.</p>
        pub fn set_step_size(mut self, input: std::option::Option<f64>) -> Self {
            self.step_size = input;
            self
        }
        /// Consumes the builder and constructs a [`AxisLinearScale`](crate::model::AxisLinearScale).
        pub fn build(self) -> crate::model::AxisLinearScale {
            crate::model::AxisLinearScale {
                step_count: self.step_count,
                step_size: self.step_size,
            }
        }
    }
}
impl AxisLinearScale {
    /// Creates a new builder-style object to manufacture [`AxisLinearScale`](crate::model::AxisLinearScale).
    pub fn builder() -> crate::model::axis_linear_scale::Builder {
        crate::model::axis_linear_scale::Builder::default()
    }
}

/// <p>The tick label options of an axis.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AxisTickLabelOptions {
    /// <p>Determines whether or not the axis ticks are visible.</p>
    #[doc(hidden)]
    pub label_options: std::option::Option<crate::model::LabelOptions>,
    /// <p>The rotation angle of the axis tick labels.</p>
    #[doc(hidden)]
    pub rotation_angle: std::option::Option<f64>,
}
impl AxisTickLabelOptions {
    /// <p>Determines whether or not the axis ticks are visible.</p>
    pub fn label_options(&self) -> std::option::Option<&crate::model::LabelOptions> {
        self.label_options.as_ref()
    }
    /// <p>The rotation angle of the axis tick labels.</p>
    pub fn rotation_angle(&self) -> std::option::Option<f64> {
        self.rotation_angle
    }
}
/// See [`AxisTickLabelOptions`](crate::model::AxisTickLabelOptions).
pub mod axis_tick_label_options {

    /// A builder for [`AxisTickLabelOptions`](crate::model::AxisTickLabelOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) label_options: std::option::Option<crate::model::LabelOptions>,
        pub(crate) rotation_angle: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>Determines whether or not the axis ticks are visible.</p>
        pub fn label_options(mut self, input: crate::model::LabelOptions) -> Self {
            self.label_options = Some(input);
            self
        }
        /// <p>Determines whether or not the axis ticks are visible.</p>
        pub fn set_label_options(
            mut self,
            input: std::option::Option<crate::model::LabelOptions>,
        ) -> Self {
            self.label_options = input;
            self
        }
        /// <p>The rotation angle of the axis tick labels.</p>
        pub fn rotation_angle(mut self, input: f64) -> Self {
            self.rotation_angle = Some(input);
            self
        }
        /// <p>The rotation angle of the axis tick labels.</p>
        pub fn set_rotation_angle(mut self, input: std::option::Option<f64>) -> Self {
            self.rotation_angle = input;
            self
        }
        /// Consumes the builder and constructs a [`AxisTickLabelOptions`](crate::model::AxisTickLabelOptions).
        pub fn build(self) -> crate::model::AxisTickLabelOptions {
            crate::model::AxisTickLabelOptions {
                label_options: self.label_options,
                rotation_angle: self.rotation_angle,
            }
        }
    }
}
impl AxisTickLabelOptions {
    /// Creates a new builder-style object to manufacture [`AxisTickLabelOptions`](crate::model::AxisTickLabelOptions).
    pub fn builder() -> crate::model::axis_tick_label_options::Builder {
        crate::model::axis_tick_label_options::Builder::default()
    }
}

/// <p>The share label options for the labels.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LabelOptions {
    /// <p>Determines whether or not the label is visible.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The font configuration of the label.</p>
    #[doc(hidden)]
    pub font_configuration: std::option::Option<crate::model::FontConfiguration>,
    /// <p>The text for the label.</p>
    #[doc(hidden)]
    pub custom_label: std::option::Option<std::string::String>,
}
impl LabelOptions {
    /// <p>Determines whether or not the label is visible.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
    /// <p>The font configuration of the label.</p>
    pub fn font_configuration(&self) -> std::option::Option<&crate::model::FontConfiguration> {
        self.font_configuration.as_ref()
    }
    /// <p>The text for the label.</p>
    pub fn custom_label(&self) -> std::option::Option<&str> {
        self.custom_label.as_deref()
    }
}
/// See [`LabelOptions`](crate::model::LabelOptions).
pub mod label_options {

    /// A builder for [`LabelOptions`](crate::model::LabelOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) font_configuration: std::option::Option<crate::model::FontConfiguration>,
        pub(crate) custom_label: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Determines whether or not the label is visible.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>Determines whether or not the label is visible.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// <p>The font configuration of the label.</p>
        pub fn font_configuration(mut self, input: crate::model::FontConfiguration) -> Self {
            self.font_configuration = Some(input);
            self
        }
        /// <p>The font configuration of the label.</p>
        pub fn set_font_configuration(
            mut self,
            input: std::option::Option<crate::model::FontConfiguration>,
        ) -> Self {
            self.font_configuration = input;
            self
        }
        /// <p>The text for the label.</p>
        pub fn custom_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_label = Some(input.into());
            self
        }
        /// <p>The text for the label.</p>
        pub fn set_custom_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.custom_label = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelOptions`](crate::model::LabelOptions).
        pub fn build(self) -> crate::model::LabelOptions {
            crate::model::LabelOptions {
                visibility: self.visibility,
                font_configuration: self.font_configuration,
                custom_label: self.custom_label,
            }
        }
    }
}
impl LabelOptions {
    /// Creates a new builder-style object to manufacture [`LabelOptions`](crate::model::LabelOptions).
    pub fn builder() -> crate::model::label_options::Builder {
        crate::model::label_options::Builder::default()
    }
}

/// <p>The field well configuration of a histogram.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HistogramFieldWells {
    /// <p>The field well configuration of a histogram.</p>
    #[doc(hidden)]
    pub histogram_aggregated_field_wells:
        std::option::Option<crate::model::HistogramAggregatedFieldWells>,
}
impl HistogramFieldWells {
    /// <p>The field well configuration of a histogram.</p>
    pub fn histogram_aggregated_field_wells(
        &self,
    ) -> std::option::Option<&crate::model::HistogramAggregatedFieldWells> {
        self.histogram_aggregated_field_wells.as_ref()
    }
}
/// See [`HistogramFieldWells`](crate::model::HistogramFieldWells).
pub mod histogram_field_wells {

    /// A builder for [`HistogramFieldWells`](crate::model::HistogramFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) histogram_aggregated_field_wells:
            std::option::Option<crate::model::HistogramAggregatedFieldWells>,
    }
    impl Builder {
        /// <p>The field well configuration of a histogram.</p>
        pub fn histogram_aggregated_field_wells(
            mut self,
            input: crate::model::HistogramAggregatedFieldWells,
        ) -> Self {
            self.histogram_aggregated_field_wells = Some(input);
            self
        }
        /// <p>The field well configuration of a histogram.</p>
        pub fn set_histogram_aggregated_field_wells(
            mut self,
            input: std::option::Option<crate::model::HistogramAggregatedFieldWells>,
        ) -> Self {
            self.histogram_aggregated_field_wells = input;
            self
        }
        /// Consumes the builder and constructs a [`HistogramFieldWells`](crate::model::HistogramFieldWells).
        pub fn build(self) -> crate::model::HistogramFieldWells {
            crate::model::HistogramFieldWells {
                histogram_aggregated_field_wells: self.histogram_aggregated_field_wells,
            }
        }
    }
}
impl HistogramFieldWells {
    /// Creates a new builder-style object to manufacture [`HistogramFieldWells`](crate::model::HistogramFieldWells).
    pub fn builder() -> crate::model::histogram_field_wells::Builder {
        crate::model::histogram_field_wells::Builder::default()
    }
}

/// <p>The field well configuration of a histogram.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HistogramAggregatedFieldWells {
    /// <p>The value field wells of a histogram. Values are aggregated by <code>COUNT</code> or <code>DISTINCT_COUNT</code>.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
}
impl HistogramAggregatedFieldWells {
    /// <p>The value field wells of a histogram. Values are aggregated by <code>COUNT</code> or <code>DISTINCT_COUNT</code>.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.values.as_deref()
    }
}
/// See [`HistogramAggregatedFieldWells`](crate::model::HistogramAggregatedFieldWells).
pub mod histogram_aggregated_field_wells {

    /// A builder for [`HistogramAggregatedFieldWells`](crate::model::HistogramAggregatedFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    }
    impl Builder {
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The value field wells of a histogram. Values are aggregated by <code>COUNT</code> or <code>DISTINCT_COUNT</code>.</p>
        pub fn values(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>The value field wells of a histogram. Values are aggregated by <code>COUNT</code> or <code>DISTINCT_COUNT</code>.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`HistogramAggregatedFieldWells`](crate::model::HistogramAggregatedFieldWells).
        pub fn build(self) -> crate::model::HistogramAggregatedFieldWells {
            crate::model::HistogramAggregatedFieldWells {
                values: self.values,
            }
        }
    }
}
impl HistogramAggregatedFieldWells {
    /// Creates a new builder-style object to manufacture [`HistogramAggregatedFieldWells`](crate::model::HistogramAggregatedFieldWells).
    pub fn builder() -> crate::model::histogram_aggregated_field_wells::Builder {
        crate::model::histogram_aggregated_field_wells::Builder::default()
    }
}

/// <p>A waterfall chart.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/waterfall-chart.html">Using waterfall charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WaterfallVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration for a waterfall visual.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::WaterfallChartConfiguration>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    #[doc(hidden)]
    pub column_hierarchies: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
}
impl WaterfallVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration for a waterfall visual.</p>
    pub fn chart_configuration(
        &self,
    ) -> std::option::Option<&crate::model::WaterfallChartConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    pub fn column_hierarchies(&self) -> std::option::Option<&[crate::model::ColumnHierarchy]> {
        self.column_hierarchies.as_deref()
    }
}
/// See [`WaterfallVisual`](crate::model::WaterfallVisual).
pub mod waterfall_visual {

    /// A builder for [`WaterfallVisual`](crate::model::WaterfallVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration:
            std::option::Option<crate::model::WaterfallChartConfiguration>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        pub(crate) column_hierarchies:
            std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration for a waterfall visual.</p>
        pub fn chart_configuration(
            mut self,
            input: crate::model::WaterfallChartConfiguration,
        ) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration for a waterfall visual.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::WaterfallChartConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Appends an item to `column_hierarchies`.
        ///
        /// To override the contents of this collection use [`set_column_hierarchies`](Self::set_column_hierarchies).
        ///
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn column_hierarchies(mut self, input: crate::model::ColumnHierarchy) -> Self {
            let mut v = self.column_hierarchies.unwrap_or_default();
            v.push(input);
            self.column_hierarchies = Some(v);
            self
        }
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn set_column_hierarchies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
        ) -> Self {
            self.column_hierarchies = input;
            self
        }
        /// Consumes the builder and constructs a [`WaterfallVisual`](crate::model::WaterfallVisual).
        pub fn build(self) -> crate::model::WaterfallVisual {
            crate::model::WaterfallVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                actions: self.actions,
                column_hierarchies: self.column_hierarchies,
            }
        }
    }
}
impl WaterfallVisual {
    /// Creates a new builder-style object to manufacture [`WaterfallVisual`](crate::model::WaterfallVisual).
    pub fn builder() -> crate::model::waterfall_visual::Builder {
        crate::model::waterfall_visual::Builder::default()
    }
}

/// <p>The configuration for a waterfall visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WaterfallChartConfiguration {
    /// <p>The field well configuration of a waterfall visual.</p>
    #[doc(hidden)]
    pub field_wells: std::option::Option<crate::model::WaterfallChartFieldWells>,
    /// <p>The sort configuration of a waterfall visual.</p>
    #[doc(hidden)]
    pub sort_configuration: std::option::Option<crate::model::WaterfallChartSortConfiguration>,
    /// <p>The options that determine the presentation of a waterfall visual.</p>
    #[doc(hidden)]
    pub waterfall_chart_options: std::option::Option<crate::model::WaterfallChartOptions>,
    /// <p>The options that determine the presentation of the category axis label.</p>
    #[doc(hidden)]
    pub category_axis_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The options that determine the presentation of the category axis.</p>
    #[doc(hidden)]
    pub category_axis_display_options: std::option::Option<crate::model::AxisDisplayOptions>,
    /// <p>The options that determine the presentation of the y-axis label.</p>
    #[doc(hidden)]
    pub primary_y_axis_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The options that determine the presentation of the y-axis.</p>
    #[doc(hidden)]
    pub primary_y_axis_display_options: std::option::Option<crate::model::AxisDisplayOptions>,
    /// <p>The legend configuration of a waterfall visual.</p>
    #[doc(hidden)]
    pub legend: std::option::Option<crate::model::LegendOptions>,
    /// <p>The data label configuration of a waterfall visual.</p>
    #[doc(hidden)]
    pub data_labels: std::option::Option<crate::model::DataLabelOptions>,
    /// <p>The visual palette configuration of a waterfall visual.</p>
    #[doc(hidden)]
    pub visual_palette: std::option::Option<crate::model::VisualPalette>,
}
impl WaterfallChartConfiguration {
    /// <p>The field well configuration of a waterfall visual.</p>
    pub fn field_wells(&self) -> std::option::Option<&crate::model::WaterfallChartFieldWells> {
        self.field_wells.as_ref()
    }
    /// <p>The sort configuration of a waterfall visual.</p>
    pub fn sort_configuration(
        &self,
    ) -> std::option::Option<&crate::model::WaterfallChartSortConfiguration> {
        self.sort_configuration.as_ref()
    }
    /// <p>The options that determine the presentation of a waterfall visual.</p>
    pub fn waterfall_chart_options(
        &self,
    ) -> std::option::Option<&crate::model::WaterfallChartOptions> {
        self.waterfall_chart_options.as_ref()
    }
    /// <p>The options that determine the presentation of the category axis label.</p>
    pub fn category_axis_label_options(
        &self,
    ) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.category_axis_label_options.as_ref()
    }
    /// <p>The options that determine the presentation of the category axis.</p>
    pub fn category_axis_display_options(
        &self,
    ) -> std::option::Option<&crate::model::AxisDisplayOptions> {
        self.category_axis_display_options.as_ref()
    }
    /// <p>The options that determine the presentation of the y-axis label.</p>
    pub fn primary_y_axis_label_options(
        &self,
    ) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.primary_y_axis_label_options.as_ref()
    }
    /// <p>The options that determine the presentation of the y-axis.</p>
    pub fn primary_y_axis_display_options(
        &self,
    ) -> std::option::Option<&crate::model::AxisDisplayOptions> {
        self.primary_y_axis_display_options.as_ref()
    }
    /// <p>The legend configuration of a waterfall visual.</p>
    pub fn legend(&self) -> std::option::Option<&crate::model::LegendOptions> {
        self.legend.as_ref()
    }
    /// <p>The data label configuration of a waterfall visual.</p>
    pub fn data_labels(&self) -> std::option::Option<&crate::model::DataLabelOptions> {
        self.data_labels.as_ref()
    }
    /// <p>The visual palette configuration of a waterfall visual.</p>
    pub fn visual_palette(&self) -> std::option::Option<&crate::model::VisualPalette> {
        self.visual_palette.as_ref()
    }
}
/// See [`WaterfallChartConfiguration`](crate::model::WaterfallChartConfiguration).
pub mod waterfall_chart_configuration {

    /// A builder for [`WaterfallChartConfiguration`](crate::model::WaterfallChartConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_wells: std::option::Option<crate::model::WaterfallChartFieldWells>,
        pub(crate) sort_configuration:
            std::option::Option<crate::model::WaterfallChartSortConfiguration>,
        pub(crate) waterfall_chart_options:
            std::option::Option<crate::model::WaterfallChartOptions>,
        pub(crate) category_axis_label_options:
            std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) category_axis_display_options:
            std::option::Option<crate::model::AxisDisplayOptions>,
        pub(crate) primary_y_axis_label_options:
            std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) primary_y_axis_display_options:
            std::option::Option<crate::model::AxisDisplayOptions>,
        pub(crate) legend: std::option::Option<crate::model::LegendOptions>,
        pub(crate) data_labels: std::option::Option<crate::model::DataLabelOptions>,
        pub(crate) visual_palette: std::option::Option<crate::model::VisualPalette>,
    }
    impl Builder {
        /// <p>The field well configuration of a waterfall visual.</p>
        pub fn field_wells(mut self, input: crate::model::WaterfallChartFieldWells) -> Self {
            self.field_wells = Some(input);
            self
        }
        /// <p>The field well configuration of a waterfall visual.</p>
        pub fn set_field_wells(
            mut self,
            input: std::option::Option<crate::model::WaterfallChartFieldWells>,
        ) -> Self {
            self.field_wells = input;
            self
        }
        /// <p>The sort configuration of a waterfall visual.</p>
        pub fn sort_configuration(
            mut self,
            input: crate::model::WaterfallChartSortConfiguration,
        ) -> Self {
            self.sort_configuration = Some(input);
            self
        }
        /// <p>The sort configuration of a waterfall visual.</p>
        pub fn set_sort_configuration(
            mut self,
            input: std::option::Option<crate::model::WaterfallChartSortConfiguration>,
        ) -> Self {
            self.sort_configuration = input;
            self
        }
        /// <p>The options that determine the presentation of a waterfall visual.</p>
        pub fn waterfall_chart_options(
            mut self,
            input: crate::model::WaterfallChartOptions,
        ) -> Self {
            self.waterfall_chart_options = Some(input);
            self
        }
        /// <p>The options that determine the presentation of a waterfall visual.</p>
        pub fn set_waterfall_chart_options(
            mut self,
            input: std::option::Option<crate::model::WaterfallChartOptions>,
        ) -> Self {
            self.waterfall_chart_options = input;
            self
        }
        /// <p>The options that determine the presentation of the category axis label.</p>
        pub fn category_axis_label_options(
            mut self,
            input: crate::model::ChartAxisLabelOptions,
        ) -> Self {
            self.category_axis_label_options = Some(input);
            self
        }
        /// <p>The options that determine the presentation of the category axis label.</p>
        pub fn set_category_axis_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.category_axis_label_options = input;
            self
        }
        /// <p>The options that determine the presentation of the category axis.</p>
        pub fn category_axis_display_options(
            mut self,
            input: crate::model::AxisDisplayOptions,
        ) -> Self {
            self.category_axis_display_options = Some(input);
            self
        }
        /// <p>The options that determine the presentation of the category axis.</p>
        pub fn set_category_axis_display_options(
            mut self,
            input: std::option::Option<crate::model::AxisDisplayOptions>,
        ) -> Self {
            self.category_axis_display_options = input;
            self
        }
        /// <p>The options that determine the presentation of the y-axis label.</p>
        pub fn primary_y_axis_label_options(
            mut self,
            input: crate::model::ChartAxisLabelOptions,
        ) -> Self {
            self.primary_y_axis_label_options = Some(input);
            self
        }
        /// <p>The options that determine the presentation of the y-axis label.</p>
        pub fn set_primary_y_axis_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.primary_y_axis_label_options = input;
            self
        }
        /// <p>The options that determine the presentation of the y-axis.</p>
        pub fn primary_y_axis_display_options(
            mut self,
            input: crate::model::AxisDisplayOptions,
        ) -> Self {
            self.primary_y_axis_display_options = Some(input);
            self
        }
        /// <p>The options that determine the presentation of the y-axis.</p>
        pub fn set_primary_y_axis_display_options(
            mut self,
            input: std::option::Option<crate::model::AxisDisplayOptions>,
        ) -> Self {
            self.primary_y_axis_display_options = input;
            self
        }
        /// <p>The legend configuration of a waterfall visual.</p>
        pub fn legend(mut self, input: crate::model::LegendOptions) -> Self {
            self.legend = Some(input);
            self
        }
        /// <p>The legend configuration of a waterfall visual.</p>
        pub fn set_legend(
            mut self,
            input: std::option::Option<crate::model::LegendOptions>,
        ) -> Self {
            self.legend = input;
            self
        }
        /// <p>The data label configuration of a waterfall visual.</p>
        pub fn data_labels(mut self, input: crate::model::DataLabelOptions) -> Self {
            self.data_labels = Some(input);
            self
        }
        /// <p>The data label configuration of a waterfall visual.</p>
        pub fn set_data_labels(
            mut self,
            input: std::option::Option<crate::model::DataLabelOptions>,
        ) -> Self {
            self.data_labels = input;
            self
        }
        /// <p>The visual palette configuration of a waterfall visual.</p>
        pub fn visual_palette(mut self, input: crate::model::VisualPalette) -> Self {
            self.visual_palette = Some(input);
            self
        }
        /// <p>The visual palette configuration of a waterfall visual.</p>
        pub fn set_visual_palette(
            mut self,
            input: std::option::Option<crate::model::VisualPalette>,
        ) -> Self {
            self.visual_palette = input;
            self
        }
        /// Consumes the builder and constructs a [`WaterfallChartConfiguration`](crate::model::WaterfallChartConfiguration).
        pub fn build(self) -> crate::model::WaterfallChartConfiguration {
            crate::model::WaterfallChartConfiguration {
                field_wells: self.field_wells,
                sort_configuration: self.sort_configuration,
                waterfall_chart_options: self.waterfall_chart_options,
                category_axis_label_options: self.category_axis_label_options,
                category_axis_display_options: self.category_axis_display_options,
                primary_y_axis_label_options: self.primary_y_axis_label_options,
                primary_y_axis_display_options: self.primary_y_axis_display_options,
                legend: self.legend,
                data_labels: self.data_labels,
                visual_palette: self.visual_palette,
            }
        }
    }
}
impl WaterfallChartConfiguration {
    /// Creates a new builder-style object to manufacture [`WaterfallChartConfiguration`](crate::model::WaterfallChartConfiguration).
    pub fn builder() -> crate::model::waterfall_chart_configuration::Builder {
        crate::model::waterfall_chart_configuration::Builder::default()
    }
}

/// <p>The options for the legend setup of a visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LegendOptions {
    /// <p>Determines whether or not the legend is visible.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The custom title for the legend.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::LabelOptions>,
    /// <p>The positions for the legend. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>AUTO</code> </p> </li>
    /// <li> <p> <code>RIGHT</code> </p> </li>
    /// <li> <p> <code>BOTTOM</code> </p> </li>
    /// <li> <p> <code>LEFT</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub position: std::option::Option<crate::model::LegendPosition>,
    /// <p>The width of the legend. If this value is omitted, a default width is used when rendering.</p>
    #[doc(hidden)]
    pub width: std::option::Option<std::string::String>,
    /// <p>The height of the legend. If this value is omitted, a default height is used when rendering.</p>
    #[doc(hidden)]
    pub height: std::option::Option<std::string::String>,
}
impl LegendOptions {
    /// <p>Determines whether or not the legend is visible.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
    /// <p>The custom title for the legend.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::LabelOptions> {
        self.title.as_ref()
    }
    /// <p>The positions for the legend. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>AUTO</code> </p> </li>
    /// <li> <p> <code>RIGHT</code> </p> </li>
    /// <li> <p> <code>BOTTOM</code> </p> </li>
    /// <li> <p> <code>LEFT</code> </p> </li>
    /// </ul>
    pub fn position(&self) -> std::option::Option<&crate::model::LegendPosition> {
        self.position.as_ref()
    }
    /// <p>The width of the legend. If this value is omitted, a default width is used when rendering.</p>
    pub fn width(&self) -> std::option::Option<&str> {
        self.width.as_deref()
    }
    /// <p>The height of the legend. If this value is omitted, a default height is used when rendering.</p>
    pub fn height(&self) -> std::option::Option<&str> {
        self.height.as_deref()
    }
}
/// See [`LegendOptions`](crate::model::LegendOptions).
pub mod legend_options {

    /// A builder for [`LegendOptions`](crate::model::LegendOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) title: std::option::Option<crate::model::LabelOptions>,
        pub(crate) position: std::option::Option<crate::model::LegendPosition>,
        pub(crate) width: std::option::Option<std::string::String>,
        pub(crate) height: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Determines whether or not the legend is visible.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>Determines whether or not the legend is visible.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// <p>The custom title for the legend.</p>
        pub fn title(mut self, input: crate::model::LabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The custom title for the legend.</p>
        pub fn set_title(mut self, input: std::option::Option<crate::model::LabelOptions>) -> Self {
            self.title = input;
            self
        }
        /// <p>The positions for the legend. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>AUTO</code> </p> </li>
        /// <li> <p> <code>RIGHT</code> </p> </li>
        /// <li> <p> <code>BOTTOM</code> </p> </li>
        /// <li> <p> <code>LEFT</code> </p> </li>
        /// </ul>
        pub fn position(mut self, input: crate::model::LegendPosition) -> Self {
            self.position = Some(input);
            self
        }
        /// <p>The positions for the legend. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>AUTO</code> </p> </li>
        /// <li> <p> <code>RIGHT</code> </p> </li>
        /// <li> <p> <code>BOTTOM</code> </p> </li>
        /// <li> <p> <code>LEFT</code> </p> </li>
        /// </ul>
        pub fn set_position(
            mut self,
            input: std::option::Option<crate::model::LegendPosition>,
        ) -> Self {
            self.position = input;
            self
        }
        /// <p>The width of the legend. If this value is omitted, a default width is used when rendering.</p>
        pub fn width(mut self, input: impl Into<std::string::String>) -> Self {
            self.width = Some(input.into());
            self
        }
        /// <p>The width of the legend. If this value is omitted, a default width is used when rendering.</p>
        pub fn set_width(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.width = input;
            self
        }
        /// <p>The height of the legend. If this value is omitted, a default height is used when rendering.</p>
        pub fn height(mut self, input: impl Into<std::string::String>) -> Self {
            self.height = Some(input.into());
            self
        }
        /// <p>The height of the legend. If this value is omitted, a default height is used when rendering.</p>
        pub fn set_height(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.height = input;
            self
        }
        /// Consumes the builder and constructs a [`LegendOptions`](crate::model::LegendOptions).
        pub fn build(self) -> crate::model::LegendOptions {
            crate::model::LegendOptions {
                visibility: self.visibility,
                title: self.title,
                position: self.position,
                width: self.width,
                height: self.height,
            }
        }
    }
}
impl LegendOptions {
    /// Creates a new builder-style object to manufacture [`LegendOptions`](crate::model::LegendOptions).
    pub fn builder() -> crate::model::legend_options::Builder {
        crate::model::legend_options::Builder::default()
    }
}

/// When writing a match expression against `LegendPosition`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let legendposition = unimplemented!();
/// match legendposition {
///     LegendPosition::Auto => { /* ... */ },
///     LegendPosition::Bottom => { /* ... */ },
///     LegendPosition::Right => { /* ... */ },
///     LegendPosition::Top => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `legendposition` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LegendPosition::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LegendPosition::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LegendPosition::NewFeature` is defined.
/// Specifically, when `legendposition` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LegendPosition::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LegendPosition {
    #[allow(missing_docs)] // documentation missing in model
    Auto,
    #[allow(missing_docs)] // documentation missing in model
    Bottom,
    #[allow(missing_docs)] // documentation missing in model
    Right,
    #[allow(missing_docs)] // documentation missing in model
    Top,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LegendPosition {
    fn from(s: &str) -> Self {
        match s {
            "AUTO" => LegendPosition::Auto,
            "BOTTOM" => LegendPosition::Bottom,
            "RIGHT" => LegendPosition::Right,
            "TOP" => LegendPosition::Top,
            other => LegendPosition::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LegendPosition {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LegendPosition::from(s))
    }
}
impl LegendPosition {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LegendPosition::Auto => "AUTO",
            LegendPosition::Bottom => "BOTTOM",
            LegendPosition::Right => "RIGHT",
            LegendPosition::Top => "TOP",
            LegendPosition::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AUTO", "BOTTOM", "RIGHT", "TOP"]
    }
}
impl AsRef<str> for LegendPosition {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The options that determine the presentation of a waterfall visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WaterfallChartOptions {
    /// <p>This option determines the total bar label of a waterfall visual.</p>
    #[doc(hidden)]
    pub total_bar_label: std::option::Option<std::string::String>,
}
impl WaterfallChartOptions {
    /// <p>This option determines the total bar label of a waterfall visual.</p>
    pub fn total_bar_label(&self) -> std::option::Option<&str> {
        self.total_bar_label.as_deref()
    }
}
/// See [`WaterfallChartOptions`](crate::model::WaterfallChartOptions).
pub mod waterfall_chart_options {

    /// A builder for [`WaterfallChartOptions`](crate::model::WaterfallChartOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_bar_label: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>This option determines the total bar label of a waterfall visual.</p>
        pub fn total_bar_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.total_bar_label = Some(input.into());
            self
        }
        /// <p>This option determines the total bar label of a waterfall visual.</p>
        pub fn set_total_bar_label(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.total_bar_label = input;
            self
        }
        /// Consumes the builder and constructs a [`WaterfallChartOptions`](crate::model::WaterfallChartOptions).
        pub fn build(self) -> crate::model::WaterfallChartOptions {
            crate::model::WaterfallChartOptions {
                total_bar_label: self.total_bar_label,
            }
        }
    }
}
impl WaterfallChartOptions {
    /// Creates a new builder-style object to manufacture [`WaterfallChartOptions`](crate::model::WaterfallChartOptions).
    pub fn builder() -> crate::model::waterfall_chart_options::Builder {
        crate::model::waterfall_chart_options::Builder::default()
    }
}

/// <p>The sort configuration of a waterfall visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WaterfallChartSortConfiguration {
    /// <p>The sort configuration of the category fields.</p>
    #[doc(hidden)]
    pub category_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    /// <p>The limit on the number of bar groups that are displayed.</p>
    #[doc(hidden)]
    pub breakdown_items_limit: std::option::Option<crate::model::ItemsLimitConfiguration>,
}
impl WaterfallChartSortConfiguration {
    /// <p>The sort configuration of the category fields.</p>
    pub fn category_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.category_sort.as_deref()
    }
    /// <p>The limit on the number of bar groups that are displayed.</p>
    pub fn breakdown_items_limit(
        &self,
    ) -> std::option::Option<&crate::model::ItemsLimitConfiguration> {
        self.breakdown_items_limit.as_ref()
    }
}
/// See [`WaterfallChartSortConfiguration`](crate::model::WaterfallChartSortConfiguration).
pub mod waterfall_chart_sort_configuration {

    /// A builder for [`WaterfallChartSortConfiguration`](crate::model::WaterfallChartSortConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category_sort:
            std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        pub(crate) breakdown_items_limit:
            std::option::Option<crate::model::ItemsLimitConfiguration>,
    }
    impl Builder {
        /// Appends an item to `category_sort`.
        ///
        /// To override the contents of this collection use [`set_category_sort`](Self::set_category_sort).
        ///
        /// <p>The sort configuration of the category fields.</p>
        pub fn category_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.category_sort.unwrap_or_default();
            v.push(input);
            self.category_sort = Some(v);
            self
        }
        /// <p>The sort configuration of the category fields.</p>
        pub fn set_category_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.category_sort = input;
            self
        }
        /// <p>The limit on the number of bar groups that are displayed.</p>
        pub fn breakdown_items_limit(
            mut self,
            input: crate::model::ItemsLimitConfiguration,
        ) -> Self {
            self.breakdown_items_limit = Some(input);
            self
        }
        /// <p>The limit on the number of bar groups that are displayed.</p>
        pub fn set_breakdown_items_limit(
            mut self,
            input: std::option::Option<crate::model::ItemsLimitConfiguration>,
        ) -> Self {
            self.breakdown_items_limit = input;
            self
        }
        /// Consumes the builder and constructs a [`WaterfallChartSortConfiguration`](crate::model::WaterfallChartSortConfiguration).
        pub fn build(self) -> crate::model::WaterfallChartSortConfiguration {
            crate::model::WaterfallChartSortConfiguration {
                category_sort: self.category_sort,
                breakdown_items_limit: self.breakdown_items_limit,
            }
        }
    }
}
impl WaterfallChartSortConfiguration {
    /// Creates a new builder-style object to manufacture [`WaterfallChartSortConfiguration`](crate::model::WaterfallChartSortConfiguration).
    pub fn builder() -> crate::model::waterfall_chart_sort_configuration::Builder {
        crate::model::waterfall_chart_sort_configuration::Builder::default()
    }
}

/// <p>The field well configuration of a waterfall visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WaterfallChartFieldWells {
    /// <p>The field well configuration of a waterfall visual.</p>
    #[doc(hidden)]
    pub waterfall_chart_aggregated_field_wells:
        std::option::Option<crate::model::WaterfallChartAggregatedFieldWells>,
}
impl WaterfallChartFieldWells {
    /// <p>The field well configuration of a waterfall visual.</p>
    pub fn waterfall_chart_aggregated_field_wells(
        &self,
    ) -> std::option::Option<&crate::model::WaterfallChartAggregatedFieldWells> {
        self.waterfall_chart_aggregated_field_wells.as_ref()
    }
}
/// See [`WaterfallChartFieldWells`](crate::model::WaterfallChartFieldWells).
pub mod waterfall_chart_field_wells {

    /// A builder for [`WaterfallChartFieldWells`](crate::model::WaterfallChartFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) waterfall_chart_aggregated_field_wells:
            std::option::Option<crate::model::WaterfallChartAggregatedFieldWells>,
    }
    impl Builder {
        /// <p>The field well configuration of a waterfall visual.</p>
        pub fn waterfall_chart_aggregated_field_wells(
            mut self,
            input: crate::model::WaterfallChartAggregatedFieldWells,
        ) -> Self {
            self.waterfall_chart_aggregated_field_wells = Some(input);
            self
        }
        /// <p>The field well configuration of a waterfall visual.</p>
        pub fn set_waterfall_chart_aggregated_field_wells(
            mut self,
            input: std::option::Option<crate::model::WaterfallChartAggregatedFieldWells>,
        ) -> Self {
            self.waterfall_chart_aggregated_field_wells = input;
            self
        }
        /// Consumes the builder and constructs a [`WaterfallChartFieldWells`](crate::model::WaterfallChartFieldWells).
        pub fn build(self) -> crate::model::WaterfallChartFieldWells {
            crate::model::WaterfallChartFieldWells {
                waterfall_chart_aggregated_field_wells: self.waterfall_chart_aggregated_field_wells,
            }
        }
    }
}
impl WaterfallChartFieldWells {
    /// Creates a new builder-style object to manufacture [`WaterfallChartFieldWells`](crate::model::WaterfallChartFieldWells).
    pub fn builder() -> crate::model::waterfall_chart_field_wells::Builder {
        crate::model::waterfall_chart_field_wells::Builder::default()
    }
}

/// <p>The field well configuration of a waterfall visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WaterfallChartAggregatedFieldWells {
    /// <p>The category field wells of a waterfall visual.</p>
    #[doc(hidden)]
    pub categories: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The value field wells of a waterfall visual.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    /// <p>The breakdown field wells of a waterfall visual.</p>
    #[doc(hidden)]
    pub breakdowns: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
}
impl WaterfallChartAggregatedFieldWells {
    /// <p>The category field wells of a waterfall visual.</p>
    pub fn categories(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.categories.as_deref()
    }
    /// <p>The value field wells of a waterfall visual.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.values.as_deref()
    }
    /// <p>The breakdown field wells of a waterfall visual.</p>
    pub fn breakdowns(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.breakdowns.as_deref()
    }
}
/// See [`WaterfallChartAggregatedFieldWells`](crate::model::WaterfallChartAggregatedFieldWells).
pub mod waterfall_chart_aggregated_field_wells {

    /// A builder for [`WaterfallChartAggregatedFieldWells`](crate::model::WaterfallChartAggregatedFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) categories: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        pub(crate) breakdowns: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    }
    impl Builder {
        /// Appends an item to `categories`.
        ///
        /// To override the contents of this collection use [`set_categories`](Self::set_categories).
        ///
        /// <p>The category field wells of a waterfall visual.</p>
        pub fn categories(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.categories.unwrap_or_default();
            v.push(input);
            self.categories = Some(v);
            self
        }
        /// <p>The category field wells of a waterfall visual.</p>
        pub fn set_categories(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.categories = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The value field wells of a waterfall visual.</p>
        pub fn values(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>The value field wells of a waterfall visual.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Appends an item to `breakdowns`.
        ///
        /// To override the contents of this collection use [`set_breakdowns`](Self::set_breakdowns).
        ///
        /// <p>The breakdown field wells of a waterfall visual.</p>
        pub fn breakdowns(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.breakdowns.unwrap_or_default();
            v.push(input);
            self.breakdowns = Some(v);
            self
        }
        /// <p>The breakdown field wells of a waterfall visual.</p>
        pub fn set_breakdowns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.breakdowns = input;
            self
        }
        /// Consumes the builder and constructs a [`WaterfallChartAggregatedFieldWells`](crate::model::WaterfallChartAggregatedFieldWells).
        pub fn build(self) -> crate::model::WaterfallChartAggregatedFieldWells {
            crate::model::WaterfallChartAggregatedFieldWells {
                categories: self.categories,
                values: self.values,
                breakdowns: self.breakdowns,
            }
        }
    }
}
impl WaterfallChartAggregatedFieldWells {
    /// Creates a new builder-style object to manufacture [`WaterfallChartAggregatedFieldWells`](crate::model::WaterfallChartAggregatedFieldWells).
    pub fn builder() -> crate::model::waterfall_chart_aggregated_field_wells::Builder {
        crate::model::waterfall_chart_aggregated_field_wells::Builder::default()
    }
}

/// <p>A box plot.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/box-plots.html">Using box plots</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BoxPlotVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration settings of the visual.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::BoxPlotChartConfiguration>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    #[doc(hidden)]
    pub column_hierarchies: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
}
impl BoxPlotVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration settings of the visual.</p>
    pub fn chart_configuration(
        &self,
    ) -> std::option::Option<&crate::model::BoxPlotChartConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    pub fn column_hierarchies(&self) -> std::option::Option<&[crate::model::ColumnHierarchy]> {
        self.column_hierarchies.as_deref()
    }
}
/// See [`BoxPlotVisual`](crate::model::BoxPlotVisual).
pub mod box_plot_visual {

    /// A builder for [`BoxPlotVisual`](crate::model::BoxPlotVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration:
            std::option::Option<crate::model::BoxPlotChartConfiguration>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        pub(crate) column_hierarchies:
            std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn chart_configuration(
            mut self,
            input: crate::model::BoxPlotChartConfiguration,
        ) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::BoxPlotChartConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Appends an item to `column_hierarchies`.
        ///
        /// To override the contents of this collection use [`set_column_hierarchies`](Self::set_column_hierarchies).
        ///
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn column_hierarchies(mut self, input: crate::model::ColumnHierarchy) -> Self {
            let mut v = self.column_hierarchies.unwrap_or_default();
            v.push(input);
            self.column_hierarchies = Some(v);
            self
        }
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn set_column_hierarchies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
        ) -> Self {
            self.column_hierarchies = input;
            self
        }
        /// Consumes the builder and constructs a [`BoxPlotVisual`](crate::model::BoxPlotVisual).
        pub fn build(self) -> crate::model::BoxPlotVisual {
            crate::model::BoxPlotVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                actions: self.actions,
                column_hierarchies: self.column_hierarchies,
            }
        }
    }
}
impl BoxPlotVisual {
    /// Creates a new builder-style object to manufacture [`BoxPlotVisual`](crate::model::BoxPlotVisual).
    pub fn builder() -> crate::model::box_plot_visual::Builder {
        crate::model::box_plot_visual::Builder::default()
    }
}

/// <p>The configuration of a <code>BoxPlotVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BoxPlotChartConfiguration {
    /// <p>The field wells of the visual.</p>
    #[doc(hidden)]
    pub field_wells: std::option::Option<crate::model::BoxPlotFieldWells>,
    /// <p>The sort configuration of a <code>BoxPlotVisual</code>.</p>
    #[doc(hidden)]
    pub sort_configuration: std::option::Option<crate::model::BoxPlotSortConfiguration>,
    /// <p>The box plot chart options for a box plot visual</p>
    #[doc(hidden)]
    pub box_plot_options: std::option::Option<crate::model::BoxPlotOptions>,
    /// <p>The label display options (grid line, range, scale, axis step) of a box plot category.</p>
    #[doc(hidden)]
    pub category_axis: std::option::Option<crate::model::AxisDisplayOptions>,
    /// <p>The label options (label text, label visibility and sort Icon visibility) of a box plot category.</p>
    #[doc(hidden)]
    pub category_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The label display options (grid line, range, scale, axis step) of a box plot category.</p>
    #[doc(hidden)]
    pub primary_y_axis_display_options: std::option::Option<crate::model::AxisDisplayOptions>,
    /// <p>The label options (label text, label visibility and sort icon visibility) of a box plot value.</p>
    #[doc(hidden)]
    pub primary_y_axis_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The options for the legend setup of a visual.</p>
    #[doc(hidden)]
    pub legend: std::option::Option<crate::model::LegendOptions>,
    /// <p>The tooltip display setup of the visual.</p>
    #[doc(hidden)]
    pub tooltip: std::option::Option<crate::model::TooltipOptions>,
    /// <p>The reference line setup of the visual.</p>
    #[doc(hidden)]
    pub reference_lines: std::option::Option<std::vec::Vec<crate::model::ReferenceLine>>,
    /// <p>The palette (chart color) display setup of the visual.</p>
    #[doc(hidden)]
    pub visual_palette: std::option::Option<crate::model::VisualPalette>,
}
impl BoxPlotChartConfiguration {
    /// <p>The field wells of the visual.</p>
    pub fn field_wells(&self) -> std::option::Option<&crate::model::BoxPlotFieldWells> {
        self.field_wells.as_ref()
    }
    /// <p>The sort configuration of a <code>BoxPlotVisual</code>.</p>
    pub fn sort_configuration(
        &self,
    ) -> std::option::Option<&crate::model::BoxPlotSortConfiguration> {
        self.sort_configuration.as_ref()
    }
    /// <p>The box plot chart options for a box plot visual</p>
    pub fn box_plot_options(&self) -> std::option::Option<&crate::model::BoxPlotOptions> {
        self.box_plot_options.as_ref()
    }
    /// <p>The label display options (grid line, range, scale, axis step) of a box plot category.</p>
    pub fn category_axis(&self) -> std::option::Option<&crate::model::AxisDisplayOptions> {
        self.category_axis.as_ref()
    }
    /// <p>The label options (label text, label visibility and sort Icon visibility) of a box plot category.</p>
    pub fn category_label_options(
        &self,
    ) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.category_label_options.as_ref()
    }
    /// <p>The label display options (grid line, range, scale, axis step) of a box plot category.</p>
    pub fn primary_y_axis_display_options(
        &self,
    ) -> std::option::Option<&crate::model::AxisDisplayOptions> {
        self.primary_y_axis_display_options.as_ref()
    }
    /// <p>The label options (label text, label visibility and sort icon visibility) of a box plot value.</p>
    pub fn primary_y_axis_label_options(
        &self,
    ) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.primary_y_axis_label_options.as_ref()
    }
    /// <p>The options for the legend setup of a visual.</p>
    pub fn legend(&self) -> std::option::Option<&crate::model::LegendOptions> {
        self.legend.as_ref()
    }
    /// <p>The tooltip display setup of the visual.</p>
    pub fn tooltip(&self) -> std::option::Option<&crate::model::TooltipOptions> {
        self.tooltip.as_ref()
    }
    /// <p>The reference line setup of the visual.</p>
    pub fn reference_lines(&self) -> std::option::Option<&[crate::model::ReferenceLine]> {
        self.reference_lines.as_deref()
    }
    /// <p>The palette (chart color) display setup of the visual.</p>
    pub fn visual_palette(&self) -> std::option::Option<&crate::model::VisualPalette> {
        self.visual_palette.as_ref()
    }
}
/// See [`BoxPlotChartConfiguration`](crate::model::BoxPlotChartConfiguration).
pub mod box_plot_chart_configuration {

    /// A builder for [`BoxPlotChartConfiguration`](crate::model::BoxPlotChartConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_wells: std::option::Option<crate::model::BoxPlotFieldWells>,
        pub(crate) sort_configuration: std::option::Option<crate::model::BoxPlotSortConfiguration>,
        pub(crate) box_plot_options: std::option::Option<crate::model::BoxPlotOptions>,
        pub(crate) category_axis: std::option::Option<crate::model::AxisDisplayOptions>,
        pub(crate) category_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) primary_y_axis_display_options:
            std::option::Option<crate::model::AxisDisplayOptions>,
        pub(crate) primary_y_axis_label_options:
            std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) legend: std::option::Option<crate::model::LegendOptions>,
        pub(crate) tooltip: std::option::Option<crate::model::TooltipOptions>,
        pub(crate) reference_lines: std::option::Option<std::vec::Vec<crate::model::ReferenceLine>>,
        pub(crate) visual_palette: std::option::Option<crate::model::VisualPalette>,
    }
    impl Builder {
        /// <p>The field wells of the visual.</p>
        pub fn field_wells(mut self, input: crate::model::BoxPlotFieldWells) -> Self {
            self.field_wells = Some(input);
            self
        }
        /// <p>The field wells of the visual.</p>
        pub fn set_field_wells(
            mut self,
            input: std::option::Option<crate::model::BoxPlotFieldWells>,
        ) -> Self {
            self.field_wells = input;
            self
        }
        /// <p>The sort configuration of a <code>BoxPlotVisual</code>.</p>
        pub fn sort_configuration(mut self, input: crate::model::BoxPlotSortConfiguration) -> Self {
            self.sort_configuration = Some(input);
            self
        }
        /// <p>The sort configuration of a <code>BoxPlotVisual</code>.</p>
        pub fn set_sort_configuration(
            mut self,
            input: std::option::Option<crate::model::BoxPlotSortConfiguration>,
        ) -> Self {
            self.sort_configuration = input;
            self
        }
        /// <p>The box plot chart options for a box plot visual</p>
        pub fn box_plot_options(mut self, input: crate::model::BoxPlotOptions) -> Self {
            self.box_plot_options = Some(input);
            self
        }
        /// <p>The box plot chart options for a box plot visual</p>
        pub fn set_box_plot_options(
            mut self,
            input: std::option::Option<crate::model::BoxPlotOptions>,
        ) -> Self {
            self.box_plot_options = input;
            self
        }
        /// <p>The label display options (grid line, range, scale, axis step) of a box plot category.</p>
        pub fn category_axis(mut self, input: crate::model::AxisDisplayOptions) -> Self {
            self.category_axis = Some(input);
            self
        }
        /// <p>The label display options (grid line, range, scale, axis step) of a box plot category.</p>
        pub fn set_category_axis(
            mut self,
            input: std::option::Option<crate::model::AxisDisplayOptions>,
        ) -> Self {
            self.category_axis = input;
            self
        }
        /// <p>The label options (label text, label visibility and sort Icon visibility) of a box plot category.</p>
        pub fn category_label_options(
            mut self,
            input: crate::model::ChartAxisLabelOptions,
        ) -> Self {
            self.category_label_options = Some(input);
            self
        }
        /// <p>The label options (label text, label visibility and sort Icon visibility) of a box plot category.</p>
        pub fn set_category_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.category_label_options = input;
            self
        }
        /// <p>The label display options (grid line, range, scale, axis step) of a box plot category.</p>
        pub fn primary_y_axis_display_options(
            mut self,
            input: crate::model::AxisDisplayOptions,
        ) -> Self {
            self.primary_y_axis_display_options = Some(input);
            self
        }
        /// <p>The label display options (grid line, range, scale, axis step) of a box plot category.</p>
        pub fn set_primary_y_axis_display_options(
            mut self,
            input: std::option::Option<crate::model::AxisDisplayOptions>,
        ) -> Self {
            self.primary_y_axis_display_options = input;
            self
        }
        /// <p>The label options (label text, label visibility and sort icon visibility) of a box plot value.</p>
        pub fn primary_y_axis_label_options(
            mut self,
            input: crate::model::ChartAxisLabelOptions,
        ) -> Self {
            self.primary_y_axis_label_options = Some(input);
            self
        }
        /// <p>The label options (label text, label visibility and sort icon visibility) of a box plot value.</p>
        pub fn set_primary_y_axis_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.primary_y_axis_label_options = input;
            self
        }
        /// <p>The options for the legend setup of a visual.</p>
        pub fn legend(mut self, input: crate::model::LegendOptions) -> Self {
            self.legend = Some(input);
            self
        }
        /// <p>The options for the legend setup of a visual.</p>
        pub fn set_legend(
            mut self,
            input: std::option::Option<crate::model::LegendOptions>,
        ) -> Self {
            self.legend = input;
            self
        }
        /// <p>The tooltip display setup of the visual.</p>
        pub fn tooltip(mut self, input: crate::model::TooltipOptions) -> Self {
            self.tooltip = Some(input);
            self
        }
        /// <p>The tooltip display setup of the visual.</p>
        pub fn set_tooltip(
            mut self,
            input: std::option::Option<crate::model::TooltipOptions>,
        ) -> Self {
            self.tooltip = input;
            self
        }
        /// Appends an item to `reference_lines`.
        ///
        /// To override the contents of this collection use [`set_reference_lines`](Self::set_reference_lines).
        ///
        /// <p>The reference line setup of the visual.</p>
        pub fn reference_lines(mut self, input: crate::model::ReferenceLine) -> Self {
            let mut v = self.reference_lines.unwrap_or_default();
            v.push(input);
            self.reference_lines = Some(v);
            self
        }
        /// <p>The reference line setup of the visual.</p>
        pub fn set_reference_lines(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReferenceLine>>,
        ) -> Self {
            self.reference_lines = input;
            self
        }
        /// <p>The palette (chart color) display setup of the visual.</p>
        pub fn visual_palette(mut self, input: crate::model::VisualPalette) -> Self {
            self.visual_palette = Some(input);
            self
        }
        /// <p>The palette (chart color) display setup of the visual.</p>
        pub fn set_visual_palette(
            mut self,
            input: std::option::Option<crate::model::VisualPalette>,
        ) -> Self {
            self.visual_palette = input;
            self
        }
        /// Consumes the builder and constructs a [`BoxPlotChartConfiguration`](crate::model::BoxPlotChartConfiguration).
        pub fn build(self) -> crate::model::BoxPlotChartConfiguration {
            crate::model::BoxPlotChartConfiguration {
                field_wells: self.field_wells,
                sort_configuration: self.sort_configuration,
                box_plot_options: self.box_plot_options,
                category_axis: self.category_axis,
                category_label_options: self.category_label_options,
                primary_y_axis_display_options: self.primary_y_axis_display_options,
                primary_y_axis_label_options: self.primary_y_axis_label_options,
                legend: self.legend,
                tooltip: self.tooltip,
                reference_lines: self.reference_lines,
                visual_palette: self.visual_palette,
            }
        }
    }
}
impl BoxPlotChartConfiguration {
    /// Creates a new builder-style object to manufacture [`BoxPlotChartConfiguration`](crate::model::BoxPlotChartConfiguration).
    pub fn builder() -> crate::model::box_plot_chart_configuration::Builder {
        crate::model::box_plot_chart_configuration::Builder::default()
    }
}

/// <p>The reference line visual display options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReferenceLine {
    /// <p>The status of the reference line. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>ENABLE</code> </p> </li>
    /// <li> <p> <code>DISABLE</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::WidgetStatus>,
    /// <p>The data configuration of the reference line.</p>
    #[doc(hidden)]
    pub data_configuration: std::option::Option<crate::model::ReferenceLineDataConfiguration>,
    /// <p>The style configuration of the reference line.</p>
    #[doc(hidden)]
    pub style_configuration: std::option::Option<crate::model::ReferenceLineStyleConfiguration>,
    /// <p>The label configuration of the reference line.</p>
    #[doc(hidden)]
    pub label_configuration: std::option::Option<crate::model::ReferenceLineLabelConfiguration>,
}
impl ReferenceLine {
    /// <p>The status of the reference line. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>ENABLE</code> </p> </li>
    /// <li> <p> <code>DISABLE</code> </p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::WidgetStatus> {
        self.status.as_ref()
    }
    /// <p>The data configuration of the reference line.</p>
    pub fn data_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ReferenceLineDataConfiguration> {
        self.data_configuration.as_ref()
    }
    /// <p>The style configuration of the reference line.</p>
    pub fn style_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ReferenceLineStyleConfiguration> {
        self.style_configuration.as_ref()
    }
    /// <p>The label configuration of the reference line.</p>
    pub fn label_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ReferenceLineLabelConfiguration> {
        self.label_configuration.as_ref()
    }
}
/// See [`ReferenceLine`](crate::model::ReferenceLine).
pub mod reference_line {

    /// A builder for [`ReferenceLine`](crate::model::ReferenceLine).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::WidgetStatus>,
        pub(crate) data_configuration:
            std::option::Option<crate::model::ReferenceLineDataConfiguration>,
        pub(crate) style_configuration:
            std::option::Option<crate::model::ReferenceLineStyleConfiguration>,
        pub(crate) label_configuration:
            std::option::Option<crate::model::ReferenceLineLabelConfiguration>,
    }
    impl Builder {
        /// <p>The status of the reference line. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>ENABLE</code> </p> </li>
        /// <li> <p> <code>DISABLE</code> </p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::WidgetStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the reference line. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>ENABLE</code> </p> </li>
        /// <li> <p> <code>DISABLE</code> </p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::WidgetStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The data configuration of the reference line.</p>
        pub fn data_configuration(
            mut self,
            input: crate::model::ReferenceLineDataConfiguration,
        ) -> Self {
            self.data_configuration = Some(input);
            self
        }
        /// <p>The data configuration of the reference line.</p>
        pub fn set_data_configuration(
            mut self,
            input: std::option::Option<crate::model::ReferenceLineDataConfiguration>,
        ) -> Self {
            self.data_configuration = input;
            self
        }
        /// <p>The style configuration of the reference line.</p>
        pub fn style_configuration(
            mut self,
            input: crate::model::ReferenceLineStyleConfiguration,
        ) -> Self {
            self.style_configuration = Some(input);
            self
        }
        /// <p>The style configuration of the reference line.</p>
        pub fn set_style_configuration(
            mut self,
            input: std::option::Option<crate::model::ReferenceLineStyleConfiguration>,
        ) -> Self {
            self.style_configuration = input;
            self
        }
        /// <p>The label configuration of the reference line.</p>
        pub fn label_configuration(
            mut self,
            input: crate::model::ReferenceLineLabelConfiguration,
        ) -> Self {
            self.label_configuration = Some(input);
            self
        }
        /// <p>The label configuration of the reference line.</p>
        pub fn set_label_configuration(
            mut self,
            input: std::option::Option<crate::model::ReferenceLineLabelConfiguration>,
        ) -> Self {
            self.label_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceLine`](crate::model::ReferenceLine).
        pub fn build(self) -> crate::model::ReferenceLine {
            crate::model::ReferenceLine {
                status: self.status,
                data_configuration: self.data_configuration,
                style_configuration: self.style_configuration,
                label_configuration: self.label_configuration,
            }
        }
    }
}
impl ReferenceLine {
    /// Creates a new builder-style object to manufacture [`ReferenceLine`](crate::model::ReferenceLine).
    pub fn builder() -> crate::model::reference_line::Builder {
        crate::model::reference_line::Builder::default()
    }
}

/// <p>The label configuration of a reference line.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReferenceLineLabelConfiguration {
    /// <p>The value label configuration of the label in a reference line.</p>
    #[doc(hidden)]
    pub value_label_configuration:
        std::option::Option<crate::model::ReferenceLineValueLabelConfiguration>,
    /// <p>The custom label configuration of the label in a reference line.</p>
    #[doc(hidden)]
    pub custom_label_configuration:
        std::option::Option<crate::model::ReferenceLineCustomLabelConfiguration>,
    /// <p>The font configuration of the label in a reference line.</p>
    #[doc(hidden)]
    pub font_configuration: std::option::Option<crate::model::FontConfiguration>,
    /// <p>The font color configuration of the label in a reference line.</p>
    #[doc(hidden)]
    pub font_color: std::option::Option<std::string::String>,
    /// <p>The horizontal position configuration of the label in a reference line. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>LEFT</code> </p> </li>
    /// <li> <p> <code>CENTER</code> </p> </li>
    /// <li> <p> <code>RIGHT</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub horizontal_position:
        std::option::Option<crate::model::ReferenceLineLabelHorizontalPosition>,
    /// <p>The vertical position configuration of the label in a reference line. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>ABOVE</code> </p> </li>
    /// <li> <p> <code>BELOW</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub vertical_position: std::option::Option<crate::model::ReferenceLineLabelVerticalPosition>,
}
impl ReferenceLineLabelConfiguration {
    /// <p>The value label configuration of the label in a reference line.</p>
    pub fn value_label_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ReferenceLineValueLabelConfiguration> {
        self.value_label_configuration.as_ref()
    }
    /// <p>The custom label configuration of the label in a reference line.</p>
    pub fn custom_label_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ReferenceLineCustomLabelConfiguration> {
        self.custom_label_configuration.as_ref()
    }
    /// <p>The font configuration of the label in a reference line.</p>
    pub fn font_configuration(&self) -> std::option::Option<&crate::model::FontConfiguration> {
        self.font_configuration.as_ref()
    }
    /// <p>The font color configuration of the label in a reference line.</p>
    pub fn font_color(&self) -> std::option::Option<&str> {
        self.font_color.as_deref()
    }
    /// <p>The horizontal position configuration of the label in a reference line. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>LEFT</code> </p> </li>
    /// <li> <p> <code>CENTER</code> </p> </li>
    /// <li> <p> <code>RIGHT</code> </p> </li>
    /// </ul>
    pub fn horizontal_position(
        &self,
    ) -> std::option::Option<&crate::model::ReferenceLineLabelHorizontalPosition> {
        self.horizontal_position.as_ref()
    }
    /// <p>The vertical position configuration of the label in a reference line. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>ABOVE</code> </p> </li>
    /// <li> <p> <code>BELOW</code> </p> </li>
    /// </ul>
    pub fn vertical_position(
        &self,
    ) -> std::option::Option<&crate::model::ReferenceLineLabelVerticalPosition> {
        self.vertical_position.as_ref()
    }
}
/// See [`ReferenceLineLabelConfiguration`](crate::model::ReferenceLineLabelConfiguration).
pub mod reference_line_label_configuration {

    /// A builder for [`ReferenceLineLabelConfiguration`](crate::model::ReferenceLineLabelConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value_label_configuration:
            std::option::Option<crate::model::ReferenceLineValueLabelConfiguration>,
        pub(crate) custom_label_configuration:
            std::option::Option<crate::model::ReferenceLineCustomLabelConfiguration>,
        pub(crate) font_configuration: std::option::Option<crate::model::FontConfiguration>,
        pub(crate) font_color: std::option::Option<std::string::String>,
        pub(crate) horizontal_position:
            std::option::Option<crate::model::ReferenceLineLabelHorizontalPosition>,
        pub(crate) vertical_position:
            std::option::Option<crate::model::ReferenceLineLabelVerticalPosition>,
    }
    impl Builder {
        /// <p>The value label configuration of the label in a reference line.</p>
        pub fn value_label_configuration(
            mut self,
            input: crate::model::ReferenceLineValueLabelConfiguration,
        ) -> Self {
            self.value_label_configuration = Some(input);
            self
        }
        /// <p>The value label configuration of the label in a reference line.</p>
        pub fn set_value_label_configuration(
            mut self,
            input: std::option::Option<crate::model::ReferenceLineValueLabelConfiguration>,
        ) -> Self {
            self.value_label_configuration = input;
            self
        }
        /// <p>The custom label configuration of the label in a reference line.</p>
        pub fn custom_label_configuration(
            mut self,
            input: crate::model::ReferenceLineCustomLabelConfiguration,
        ) -> Self {
            self.custom_label_configuration = Some(input);
            self
        }
        /// <p>The custom label configuration of the label in a reference line.</p>
        pub fn set_custom_label_configuration(
            mut self,
            input: std::option::Option<crate::model::ReferenceLineCustomLabelConfiguration>,
        ) -> Self {
            self.custom_label_configuration = input;
            self
        }
        /// <p>The font configuration of the label in a reference line.</p>
        pub fn font_configuration(mut self, input: crate::model::FontConfiguration) -> Self {
            self.font_configuration = Some(input);
            self
        }
        /// <p>The font configuration of the label in a reference line.</p>
        pub fn set_font_configuration(
            mut self,
            input: std::option::Option<crate::model::FontConfiguration>,
        ) -> Self {
            self.font_configuration = input;
            self
        }
        /// <p>The font color configuration of the label in a reference line.</p>
        pub fn font_color(mut self, input: impl Into<std::string::String>) -> Self {
            self.font_color = Some(input.into());
            self
        }
        /// <p>The font color configuration of the label in a reference line.</p>
        pub fn set_font_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.font_color = input;
            self
        }
        /// <p>The horizontal position configuration of the label in a reference line. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>LEFT</code> </p> </li>
        /// <li> <p> <code>CENTER</code> </p> </li>
        /// <li> <p> <code>RIGHT</code> </p> </li>
        /// </ul>
        pub fn horizontal_position(
            mut self,
            input: crate::model::ReferenceLineLabelHorizontalPosition,
        ) -> Self {
            self.horizontal_position = Some(input);
            self
        }
        /// <p>The horizontal position configuration of the label in a reference line. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>LEFT</code> </p> </li>
        /// <li> <p> <code>CENTER</code> </p> </li>
        /// <li> <p> <code>RIGHT</code> </p> </li>
        /// </ul>
        pub fn set_horizontal_position(
            mut self,
            input: std::option::Option<crate::model::ReferenceLineLabelHorizontalPosition>,
        ) -> Self {
            self.horizontal_position = input;
            self
        }
        /// <p>The vertical position configuration of the label in a reference line. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>ABOVE</code> </p> </li>
        /// <li> <p> <code>BELOW</code> </p> </li>
        /// </ul>
        pub fn vertical_position(
            mut self,
            input: crate::model::ReferenceLineLabelVerticalPosition,
        ) -> Self {
            self.vertical_position = Some(input);
            self
        }
        /// <p>The vertical position configuration of the label in a reference line. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>ABOVE</code> </p> </li>
        /// <li> <p> <code>BELOW</code> </p> </li>
        /// </ul>
        pub fn set_vertical_position(
            mut self,
            input: std::option::Option<crate::model::ReferenceLineLabelVerticalPosition>,
        ) -> Self {
            self.vertical_position = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceLineLabelConfiguration`](crate::model::ReferenceLineLabelConfiguration).
        pub fn build(self) -> crate::model::ReferenceLineLabelConfiguration {
            crate::model::ReferenceLineLabelConfiguration {
                value_label_configuration: self.value_label_configuration,
                custom_label_configuration: self.custom_label_configuration,
                font_configuration: self.font_configuration,
                font_color: self.font_color,
                horizontal_position: self.horizontal_position,
                vertical_position: self.vertical_position,
            }
        }
    }
}
impl ReferenceLineLabelConfiguration {
    /// Creates a new builder-style object to manufacture [`ReferenceLineLabelConfiguration`](crate::model::ReferenceLineLabelConfiguration).
    pub fn builder() -> crate::model::reference_line_label_configuration::Builder {
        crate::model::reference_line_label_configuration::Builder::default()
    }
}

/// When writing a match expression against `ReferenceLineLabelVerticalPosition`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let referencelinelabelverticalposition = unimplemented!();
/// match referencelinelabelverticalposition {
///     ReferenceLineLabelVerticalPosition::Above => { /* ... */ },
///     ReferenceLineLabelVerticalPosition::Below => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `referencelinelabelverticalposition` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReferenceLineLabelVerticalPosition::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReferenceLineLabelVerticalPosition::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReferenceLineLabelVerticalPosition::NewFeature` is defined.
/// Specifically, when `referencelinelabelverticalposition` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReferenceLineLabelVerticalPosition::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReferenceLineLabelVerticalPosition {
    #[allow(missing_docs)] // documentation missing in model
    Above,
    #[allow(missing_docs)] // documentation missing in model
    Below,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReferenceLineLabelVerticalPosition {
    fn from(s: &str) -> Self {
        match s {
            "ABOVE" => ReferenceLineLabelVerticalPosition::Above,
            "BELOW" => ReferenceLineLabelVerticalPosition::Below,
            other => ReferenceLineLabelVerticalPosition::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for ReferenceLineLabelVerticalPosition {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReferenceLineLabelVerticalPosition::from(s))
    }
}
impl ReferenceLineLabelVerticalPosition {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReferenceLineLabelVerticalPosition::Above => "ABOVE",
            ReferenceLineLabelVerticalPosition::Below => "BELOW",
            ReferenceLineLabelVerticalPosition::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ABOVE", "BELOW"]
    }
}
impl AsRef<str> for ReferenceLineLabelVerticalPosition {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ReferenceLineLabelHorizontalPosition`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let referencelinelabelhorizontalposition = unimplemented!();
/// match referencelinelabelhorizontalposition {
///     ReferenceLineLabelHorizontalPosition::Center => { /* ... */ },
///     ReferenceLineLabelHorizontalPosition::Left => { /* ... */ },
///     ReferenceLineLabelHorizontalPosition::Right => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `referencelinelabelhorizontalposition` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReferenceLineLabelHorizontalPosition::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReferenceLineLabelHorizontalPosition::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReferenceLineLabelHorizontalPosition::NewFeature` is defined.
/// Specifically, when `referencelinelabelhorizontalposition` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReferenceLineLabelHorizontalPosition::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReferenceLineLabelHorizontalPosition {
    #[allow(missing_docs)] // documentation missing in model
    Center,
    #[allow(missing_docs)] // documentation missing in model
    Left,
    #[allow(missing_docs)] // documentation missing in model
    Right,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReferenceLineLabelHorizontalPosition {
    fn from(s: &str) -> Self {
        match s {
            "CENTER" => ReferenceLineLabelHorizontalPosition::Center,
            "LEFT" => ReferenceLineLabelHorizontalPosition::Left,
            "RIGHT" => ReferenceLineLabelHorizontalPosition::Right,
            other => ReferenceLineLabelHorizontalPosition::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for ReferenceLineLabelHorizontalPosition {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReferenceLineLabelHorizontalPosition::from(s))
    }
}
impl ReferenceLineLabelHorizontalPosition {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReferenceLineLabelHorizontalPosition::Center => "CENTER",
            ReferenceLineLabelHorizontalPosition::Left => "LEFT",
            ReferenceLineLabelHorizontalPosition::Right => "RIGHT",
            ReferenceLineLabelHorizontalPosition::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CENTER", "LEFT", "RIGHT"]
    }
}
impl AsRef<str> for ReferenceLineLabelHorizontalPosition {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration for a custom label on a <code>ReferenceLine</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReferenceLineCustomLabelConfiguration {
    /// <p>The string text of the custom label.</p>
    #[doc(hidden)]
    pub custom_label: std::option::Option<std::string::String>,
}
impl ReferenceLineCustomLabelConfiguration {
    /// <p>The string text of the custom label.</p>
    pub fn custom_label(&self) -> std::option::Option<&str> {
        self.custom_label.as_deref()
    }
}
/// See [`ReferenceLineCustomLabelConfiguration`](crate::model::ReferenceLineCustomLabelConfiguration).
pub mod reference_line_custom_label_configuration {

    /// A builder for [`ReferenceLineCustomLabelConfiguration`](crate::model::ReferenceLineCustomLabelConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) custom_label: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The string text of the custom label.</p>
        pub fn custom_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_label = Some(input.into());
            self
        }
        /// <p>The string text of the custom label.</p>
        pub fn set_custom_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.custom_label = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceLineCustomLabelConfiguration`](crate::model::ReferenceLineCustomLabelConfiguration).
        pub fn build(self) -> crate::model::ReferenceLineCustomLabelConfiguration {
            crate::model::ReferenceLineCustomLabelConfiguration {
                custom_label: self.custom_label,
            }
        }
    }
}
impl ReferenceLineCustomLabelConfiguration {
    /// Creates a new builder-style object to manufacture [`ReferenceLineCustomLabelConfiguration`](crate::model::ReferenceLineCustomLabelConfiguration).
    pub fn builder() -> crate::model::reference_line_custom_label_configuration::Builder {
        crate::model::reference_line_custom_label_configuration::Builder::default()
    }
}

/// <p>The value label configuration of the label in a reference line.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReferenceLineValueLabelConfiguration {
    /// <p>The relative position of the value label. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>BEFORE_CUSTOM_LABEL</code> </p> </li>
    /// <li> <p> <code>AFTER_CUSTOM_LABEL</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub relative_position:
        std::option::Option<crate::model::ReferenceLineValueLabelRelativePosition>,
    /// <p>The format configuration of the value label.</p>
    #[doc(hidden)]
    pub format_configuration: std::option::Option<crate::model::NumericFormatConfiguration>,
}
impl ReferenceLineValueLabelConfiguration {
    /// <p>The relative position of the value label. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>BEFORE_CUSTOM_LABEL</code> </p> </li>
    /// <li> <p> <code>AFTER_CUSTOM_LABEL</code> </p> </li>
    /// </ul>
    pub fn relative_position(
        &self,
    ) -> std::option::Option<&crate::model::ReferenceLineValueLabelRelativePosition> {
        self.relative_position.as_ref()
    }
    /// <p>The format configuration of the value label.</p>
    pub fn format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NumericFormatConfiguration> {
        self.format_configuration.as_ref()
    }
}
/// See [`ReferenceLineValueLabelConfiguration`](crate::model::ReferenceLineValueLabelConfiguration).
pub mod reference_line_value_label_configuration {

    /// A builder for [`ReferenceLineValueLabelConfiguration`](crate::model::ReferenceLineValueLabelConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relative_position:
            std::option::Option<crate::model::ReferenceLineValueLabelRelativePosition>,
        pub(crate) format_configuration:
            std::option::Option<crate::model::NumericFormatConfiguration>,
    }
    impl Builder {
        /// <p>The relative position of the value label. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>BEFORE_CUSTOM_LABEL</code> </p> </li>
        /// <li> <p> <code>AFTER_CUSTOM_LABEL</code> </p> </li>
        /// </ul>
        pub fn relative_position(
            mut self,
            input: crate::model::ReferenceLineValueLabelRelativePosition,
        ) -> Self {
            self.relative_position = Some(input);
            self
        }
        /// <p>The relative position of the value label. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>BEFORE_CUSTOM_LABEL</code> </p> </li>
        /// <li> <p> <code>AFTER_CUSTOM_LABEL</code> </p> </li>
        /// </ul>
        pub fn set_relative_position(
            mut self,
            input: std::option::Option<crate::model::ReferenceLineValueLabelRelativePosition>,
        ) -> Self {
            self.relative_position = input;
            self
        }
        /// <p>The format configuration of the value label.</p>
        pub fn format_configuration(
            mut self,
            input: crate::model::NumericFormatConfiguration,
        ) -> Self {
            self.format_configuration = Some(input);
            self
        }
        /// <p>The format configuration of the value label.</p>
        pub fn set_format_configuration(
            mut self,
            input: std::option::Option<crate::model::NumericFormatConfiguration>,
        ) -> Self {
            self.format_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceLineValueLabelConfiguration`](crate::model::ReferenceLineValueLabelConfiguration).
        pub fn build(self) -> crate::model::ReferenceLineValueLabelConfiguration {
            crate::model::ReferenceLineValueLabelConfiguration {
                relative_position: self.relative_position,
                format_configuration: self.format_configuration,
            }
        }
    }
}
impl ReferenceLineValueLabelConfiguration {
    /// Creates a new builder-style object to manufacture [`ReferenceLineValueLabelConfiguration`](crate::model::ReferenceLineValueLabelConfiguration).
    pub fn builder() -> crate::model::reference_line_value_label_configuration::Builder {
        crate::model::reference_line_value_label_configuration::Builder::default()
    }
}

/// When writing a match expression against `ReferenceLineValueLabelRelativePosition`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let referencelinevaluelabelrelativeposition = unimplemented!();
/// match referencelinevaluelabelrelativeposition {
///     ReferenceLineValueLabelRelativePosition::AfterCustomLabel => { /* ... */ },
///     ReferenceLineValueLabelRelativePosition::BeforeCustomLabel => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `referencelinevaluelabelrelativeposition` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReferenceLineValueLabelRelativePosition::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReferenceLineValueLabelRelativePosition::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReferenceLineValueLabelRelativePosition::NewFeature` is defined.
/// Specifically, when `referencelinevaluelabelrelativeposition` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReferenceLineValueLabelRelativePosition::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReferenceLineValueLabelRelativePosition {
    #[allow(missing_docs)] // documentation missing in model
    AfterCustomLabel,
    #[allow(missing_docs)] // documentation missing in model
    BeforeCustomLabel,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReferenceLineValueLabelRelativePosition {
    fn from(s: &str) -> Self {
        match s {
            "AFTER_CUSTOM_LABEL" => ReferenceLineValueLabelRelativePosition::AfterCustomLabel,
            "BEFORE_CUSTOM_LABEL" => ReferenceLineValueLabelRelativePosition::BeforeCustomLabel,
            other => ReferenceLineValueLabelRelativePosition::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for ReferenceLineValueLabelRelativePosition {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReferenceLineValueLabelRelativePosition::from(s))
    }
}
impl ReferenceLineValueLabelRelativePosition {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReferenceLineValueLabelRelativePosition::AfterCustomLabel => "AFTER_CUSTOM_LABEL",
            ReferenceLineValueLabelRelativePosition::BeforeCustomLabel => "BEFORE_CUSTOM_LABEL",
            ReferenceLineValueLabelRelativePosition::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AFTER_CUSTOM_LABEL", "BEFORE_CUSTOM_LABEL"]
    }
}
impl AsRef<str> for ReferenceLineValueLabelRelativePosition {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The style configuration of the reference line.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReferenceLineStyleConfiguration {
    /// <p>The pattern type of the line style. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>SOLID</code> </p> </li>
    /// <li> <p> <code>DASHED</code> </p> </li>
    /// <li> <p> <code>DOTTED</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub pattern: std::option::Option<crate::model::ReferenceLinePatternType>,
    /// <p>The hex color of the reference line.</p>
    #[doc(hidden)]
    pub color: std::option::Option<std::string::String>,
}
impl ReferenceLineStyleConfiguration {
    /// <p>The pattern type of the line style. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>SOLID</code> </p> </li>
    /// <li> <p> <code>DASHED</code> </p> </li>
    /// <li> <p> <code>DOTTED</code> </p> </li>
    /// </ul>
    pub fn pattern(&self) -> std::option::Option<&crate::model::ReferenceLinePatternType> {
        self.pattern.as_ref()
    }
    /// <p>The hex color of the reference line.</p>
    pub fn color(&self) -> std::option::Option<&str> {
        self.color.as_deref()
    }
}
/// See [`ReferenceLineStyleConfiguration`](crate::model::ReferenceLineStyleConfiguration).
pub mod reference_line_style_configuration {

    /// A builder for [`ReferenceLineStyleConfiguration`](crate::model::ReferenceLineStyleConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pattern: std::option::Option<crate::model::ReferenceLinePatternType>,
        pub(crate) color: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The pattern type of the line style. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>SOLID</code> </p> </li>
        /// <li> <p> <code>DASHED</code> </p> </li>
        /// <li> <p> <code>DOTTED</code> </p> </li>
        /// </ul>
        pub fn pattern(mut self, input: crate::model::ReferenceLinePatternType) -> Self {
            self.pattern = Some(input);
            self
        }
        /// <p>The pattern type of the line style. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>SOLID</code> </p> </li>
        /// <li> <p> <code>DASHED</code> </p> </li>
        /// <li> <p> <code>DOTTED</code> </p> </li>
        /// </ul>
        pub fn set_pattern(
            mut self,
            input: std::option::Option<crate::model::ReferenceLinePatternType>,
        ) -> Self {
            self.pattern = input;
            self
        }
        /// <p>The hex color of the reference line.</p>
        pub fn color(mut self, input: impl Into<std::string::String>) -> Self {
            self.color = Some(input.into());
            self
        }
        /// <p>The hex color of the reference line.</p>
        pub fn set_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.color = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceLineStyleConfiguration`](crate::model::ReferenceLineStyleConfiguration).
        pub fn build(self) -> crate::model::ReferenceLineStyleConfiguration {
            crate::model::ReferenceLineStyleConfiguration {
                pattern: self.pattern,
                color: self.color,
            }
        }
    }
}
impl ReferenceLineStyleConfiguration {
    /// Creates a new builder-style object to manufacture [`ReferenceLineStyleConfiguration`](crate::model::ReferenceLineStyleConfiguration).
    pub fn builder() -> crate::model::reference_line_style_configuration::Builder {
        crate::model::reference_line_style_configuration::Builder::default()
    }
}

/// When writing a match expression against `ReferenceLinePatternType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let referencelinepatterntype = unimplemented!();
/// match referencelinepatterntype {
///     ReferenceLinePatternType::Dashed => { /* ... */ },
///     ReferenceLinePatternType::Dotted => { /* ... */ },
///     ReferenceLinePatternType::Solid => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `referencelinepatterntype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReferenceLinePatternType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReferenceLinePatternType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReferenceLinePatternType::NewFeature` is defined.
/// Specifically, when `referencelinepatterntype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReferenceLinePatternType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReferenceLinePatternType {
    #[allow(missing_docs)] // documentation missing in model
    Dashed,
    #[allow(missing_docs)] // documentation missing in model
    Dotted,
    #[allow(missing_docs)] // documentation missing in model
    Solid,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReferenceLinePatternType {
    fn from(s: &str) -> Self {
        match s {
            "DASHED" => ReferenceLinePatternType::Dashed,
            "DOTTED" => ReferenceLinePatternType::Dotted,
            "SOLID" => ReferenceLinePatternType::Solid,
            other => ReferenceLinePatternType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ReferenceLinePatternType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReferenceLinePatternType::from(s))
    }
}
impl ReferenceLinePatternType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReferenceLinePatternType::Dashed => "DASHED",
            ReferenceLinePatternType::Dotted => "DOTTED",
            ReferenceLinePatternType::Solid => "SOLID",
            ReferenceLinePatternType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DASHED", "DOTTED", "SOLID"]
    }
}
impl AsRef<str> for ReferenceLinePatternType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The data configuration of the reference line.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReferenceLineDataConfiguration {
    /// <p>The static data configuration of the reference line data configuration.</p>
    #[doc(hidden)]
    pub static_configuration:
        std::option::Option<crate::model::ReferenceLineStaticDataConfiguration>,
    /// <p>The dynamic configuration of the reference line data configuration.</p>
    #[doc(hidden)]
    pub dynamic_configuration:
        std::option::Option<crate::model::ReferenceLineDynamicDataConfiguration>,
    /// <p>The axis binding type of the reference line. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p>PrimaryY</p> </li>
    /// <li> <p>SecondaryY</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub axis_binding: std::option::Option<crate::model::AxisBinding>,
}
impl ReferenceLineDataConfiguration {
    /// <p>The static data configuration of the reference line data configuration.</p>
    pub fn static_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ReferenceLineStaticDataConfiguration> {
        self.static_configuration.as_ref()
    }
    /// <p>The dynamic configuration of the reference line data configuration.</p>
    pub fn dynamic_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ReferenceLineDynamicDataConfiguration> {
        self.dynamic_configuration.as_ref()
    }
    /// <p>The axis binding type of the reference line. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p>PrimaryY</p> </li>
    /// <li> <p>SecondaryY</p> </li>
    /// </ul>
    pub fn axis_binding(&self) -> std::option::Option<&crate::model::AxisBinding> {
        self.axis_binding.as_ref()
    }
}
/// See [`ReferenceLineDataConfiguration`](crate::model::ReferenceLineDataConfiguration).
pub mod reference_line_data_configuration {

    /// A builder for [`ReferenceLineDataConfiguration`](crate::model::ReferenceLineDataConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) static_configuration:
            std::option::Option<crate::model::ReferenceLineStaticDataConfiguration>,
        pub(crate) dynamic_configuration:
            std::option::Option<crate::model::ReferenceLineDynamicDataConfiguration>,
        pub(crate) axis_binding: std::option::Option<crate::model::AxisBinding>,
    }
    impl Builder {
        /// <p>The static data configuration of the reference line data configuration.</p>
        pub fn static_configuration(
            mut self,
            input: crate::model::ReferenceLineStaticDataConfiguration,
        ) -> Self {
            self.static_configuration = Some(input);
            self
        }
        /// <p>The static data configuration of the reference line data configuration.</p>
        pub fn set_static_configuration(
            mut self,
            input: std::option::Option<crate::model::ReferenceLineStaticDataConfiguration>,
        ) -> Self {
            self.static_configuration = input;
            self
        }
        /// <p>The dynamic configuration of the reference line data configuration.</p>
        pub fn dynamic_configuration(
            mut self,
            input: crate::model::ReferenceLineDynamicDataConfiguration,
        ) -> Self {
            self.dynamic_configuration = Some(input);
            self
        }
        /// <p>The dynamic configuration of the reference line data configuration.</p>
        pub fn set_dynamic_configuration(
            mut self,
            input: std::option::Option<crate::model::ReferenceLineDynamicDataConfiguration>,
        ) -> Self {
            self.dynamic_configuration = input;
            self
        }
        /// <p>The axis binding type of the reference line. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p>PrimaryY</p> </li>
        /// <li> <p>SecondaryY</p> </li>
        /// </ul>
        pub fn axis_binding(mut self, input: crate::model::AxisBinding) -> Self {
            self.axis_binding = Some(input);
            self
        }
        /// <p>The axis binding type of the reference line. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p>PrimaryY</p> </li>
        /// <li> <p>SecondaryY</p> </li>
        /// </ul>
        pub fn set_axis_binding(
            mut self,
            input: std::option::Option<crate::model::AxisBinding>,
        ) -> Self {
            self.axis_binding = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceLineDataConfiguration`](crate::model::ReferenceLineDataConfiguration).
        pub fn build(self) -> crate::model::ReferenceLineDataConfiguration {
            crate::model::ReferenceLineDataConfiguration {
                static_configuration: self.static_configuration,
                dynamic_configuration: self.dynamic_configuration,
                axis_binding: self.axis_binding,
            }
        }
    }
}
impl ReferenceLineDataConfiguration {
    /// Creates a new builder-style object to manufacture [`ReferenceLineDataConfiguration`](crate::model::ReferenceLineDataConfiguration).
    pub fn builder() -> crate::model::reference_line_data_configuration::Builder {
        crate::model::reference_line_data_configuration::Builder::default()
    }
}

/// When writing a match expression against `AxisBinding`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let axisbinding = unimplemented!();
/// match axisbinding {
///     AxisBinding::PrimaryYaxis => { /* ... */ },
///     AxisBinding::SecondaryYaxis => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `axisbinding` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AxisBinding::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AxisBinding::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AxisBinding::NewFeature` is defined.
/// Specifically, when `axisbinding` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AxisBinding::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AxisBinding {
    #[allow(missing_docs)] // documentation missing in model
    PrimaryYaxis,
    #[allow(missing_docs)] // documentation missing in model
    SecondaryYaxis,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AxisBinding {
    fn from(s: &str) -> Self {
        match s {
            "PRIMARY_YAXIS" => AxisBinding::PrimaryYaxis,
            "SECONDARY_YAXIS" => AxisBinding::SecondaryYaxis,
            other => AxisBinding::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AxisBinding {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AxisBinding::from(s))
    }
}
impl AxisBinding {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AxisBinding::PrimaryYaxis => "PRIMARY_YAXIS",
            AxisBinding::SecondaryYaxis => "SECONDARY_YAXIS",
            AxisBinding::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PRIMARY_YAXIS", "SECONDARY_YAXIS"]
    }
}
impl AsRef<str> for AxisBinding {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The dynamic configuration of the reference line data configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReferenceLineDynamicDataConfiguration {
    /// <p>The column that the dynamic data targets.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The aggregation function that is used in the dynamic data.</p>
    #[doc(hidden)]
    pub measure_aggregation_function: std::option::Option<crate::model::AggregationFunction>,
    /// <p>The calculation that is used in the dynamic data.</p>
    #[doc(hidden)]
    pub calculation: std::option::Option<crate::model::NumericalAggregationFunction>,
}
impl ReferenceLineDynamicDataConfiguration {
    /// <p>The column that the dynamic data targets.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>The aggregation function that is used in the dynamic data.</p>
    pub fn measure_aggregation_function(
        &self,
    ) -> std::option::Option<&crate::model::AggregationFunction> {
        self.measure_aggregation_function.as_ref()
    }
    /// <p>The calculation that is used in the dynamic data.</p>
    pub fn calculation(&self) -> std::option::Option<&crate::model::NumericalAggregationFunction> {
        self.calculation.as_ref()
    }
}
/// See [`ReferenceLineDynamicDataConfiguration`](crate::model::ReferenceLineDynamicDataConfiguration).
pub mod reference_line_dynamic_data_configuration {

    /// A builder for [`ReferenceLineDynamicDataConfiguration`](crate::model::ReferenceLineDynamicDataConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) measure_aggregation_function:
            std::option::Option<crate::model::AggregationFunction>,
        pub(crate) calculation: std::option::Option<crate::model::NumericalAggregationFunction>,
    }
    impl Builder {
        /// <p>The column that the dynamic data targets.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that the dynamic data targets.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The aggregation function that is used in the dynamic data.</p>
        pub fn measure_aggregation_function(
            mut self,
            input: crate::model::AggregationFunction,
        ) -> Self {
            self.measure_aggregation_function = Some(input);
            self
        }
        /// <p>The aggregation function that is used in the dynamic data.</p>
        pub fn set_measure_aggregation_function(
            mut self,
            input: std::option::Option<crate::model::AggregationFunction>,
        ) -> Self {
            self.measure_aggregation_function = input;
            self
        }
        /// <p>The calculation that is used in the dynamic data.</p>
        pub fn calculation(mut self, input: crate::model::NumericalAggregationFunction) -> Self {
            self.calculation = Some(input);
            self
        }
        /// <p>The calculation that is used in the dynamic data.</p>
        pub fn set_calculation(
            mut self,
            input: std::option::Option<crate::model::NumericalAggregationFunction>,
        ) -> Self {
            self.calculation = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceLineDynamicDataConfiguration`](crate::model::ReferenceLineDynamicDataConfiguration).
        pub fn build(self) -> crate::model::ReferenceLineDynamicDataConfiguration {
            crate::model::ReferenceLineDynamicDataConfiguration {
                column: self.column,
                measure_aggregation_function: self.measure_aggregation_function,
                calculation: self.calculation,
            }
        }
    }
}
impl ReferenceLineDynamicDataConfiguration {
    /// Creates a new builder-style object to manufacture [`ReferenceLineDynamicDataConfiguration`](crate::model::ReferenceLineDynamicDataConfiguration).
    pub fn builder() -> crate::model::reference_line_dynamic_data_configuration::Builder {
        crate::model::reference_line_dynamic_data_configuration::Builder::default()
    }
}

/// <p>The static data configuration of the reference line data configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReferenceLineStaticDataConfiguration {
    /// <p>The double input of the static data.</p>
    #[doc(hidden)]
    pub value: f64,
}
impl ReferenceLineStaticDataConfiguration {
    /// <p>The double input of the static data.</p>
    pub fn value(&self) -> f64 {
        self.value
    }
}
impl std::fmt::Debug for ReferenceLineStaticDataConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReferenceLineStaticDataConfiguration");
        formatter.field("value", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`ReferenceLineStaticDataConfiguration`](crate::model::ReferenceLineStaticDataConfiguration).
pub mod reference_line_static_data_configuration {

    /// A builder for [`ReferenceLineStaticDataConfiguration`](crate::model::ReferenceLineStaticDataConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The double input of the static data.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The double input of the static data.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceLineStaticDataConfiguration`](crate::model::ReferenceLineStaticDataConfiguration).
        pub fn build(self) -> crate::model::ReferenceLineStaticDataConfiguration {
            crate::model::ReferenceLineStaticDataConfiguration {
                value: self.value.unwrap_or_default(),
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("value", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl ReferenceLineStaticDataConfiguration {
    /// Creates a new builder-style object to manufacture [`ReferenceLineStaticDataConfiguration`](crate::model::ReferenceLineStaticDataConfiguration).
    pub fn builder() -> crate::model::reference_line_static_data_configuration::Builder {
        crate::model::reference_line_static_data_configuration::Builder::default()
    }
}

/// <p>The options of a box plot visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BoxPlotOptions {
    /// <p>The style options of the box plot.</p>
    #[doc(hidden)]
    pub style_options: std::option::Option<crate::model::BoxPlotStyleOptions>,
    /// <p>Determines the visibility of the outlier in a box plot.</p>
    #[doc(hidden)]
    pub outlier_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>Determines the visibility of all data points of the box plot.</p>
    #[doc(hidden)]
    pub all_data_points_visibility: std::option::Option<crate::model::Visibility>,
}
impl BoxPlotOptions {
    /// <p>The style options of the box plot.</p>
    pub fn style_options(&self) -> std::option::Option<&crate::model::BoxPlotStyleOptions> {
        self.style_options.as_ref()
    }
    /// <p>Determines the visibility of the outlier in a box plot.</p>
    pub fn outlier_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.outlier_visibility.as_ref()
    }
    /// <p>Determines the visibility of all data points of the box plot.</p>
    pub fn all_data_points_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.all_data_points_visibility.as_ref()
    }
}
/// See [`BoxPlotOptions`](crate::model::BoxPlotOptions).
pub mod box_plot_options {

    /// A builder for [`BoxPlotOptions`](crate::model::BoxPlotOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) style_options: std::option::Option<crate::model::BoxPlotStyleOptions>,
        pub(crate) outlier_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) all_data_points_visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>The style options of the box plot.</p>
        pub fn style_options(mut self, input: crate::model::BoxPlotStyleOptions) -> Self {
            self.style_options = Some(input);
            self
        }
        /// <p>The style options of the box plot.</p>
        pub fn set_style_options(
            mut self,
            input: std::option::Option<crate::model::BoxPlotStyleOptions>,
        ) -> Self {
            self.style_options = input;
            self
        }
        /// <p>Determines the visibility of the outlier in a box plot.</p>
        pub fn outlier_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.outlier_visibility = Some(input);
            self
        }
        /// <p>Determines the visibility of the outlier in a box plot.</p>
        pub fn set_outlier_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.outlier_visibility = input;
            self
        }
        /// <p>Determines the visibility of all data points of the box plot.</p>
        pub fn all_data_points_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.all_data_points_visibility = Some(input);
            self
        }
        /// <p>Determines the visibility of all data points of the box plot.</p>
        pub fn set_all_data_points_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.all_data_points_visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`BoxPlotOptions`](crate::model::BoxPlotOptions).
        pub fn build(self) -> crate::model::BoxPlotOptions {
            crate::model::BoxPlotOptions {
                style_options: self.style_options,
                outlier_visibility: self.outlier_visibility,
                all_data_points_visibility: self.all_data_points_visibility,
            }
        }
    }
}
impl BoxPlotOptions {
    /// Creates a new builder-style object to manufacture [`BoxPlotOptions`](crate::model::BoxPlotOptions).
    pub fn builder() -> crate::model::box_plot_options::Builder {
        crate::model::box_plot_options::Builder::default()
    }
}

/// <p>The style options of the box plot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BoxPlotStyleOptions {
    /// <p>The fill styles (solid, transparent) of the box plot.</p>
    #[doc(hidden)]
    pub fill_style: std::option::Option<crate::model::BoxPlotFillStyle>,
}
impl BoxPlotStyleOptions {
    /// <p>The fill styles (solid, transparent) of the box plot.</p>
    pub fn fill_style(&self) -> std::option::Option<&crate::model::BoxPlotFillStyle> {
        self.fill_style.as_ref()
    }
}
/// See [`BoxPlotStyleOptions`](crate::model::BoxPlotStyleOptions).
pub mod box_plot_style_options {

    /// A builder for [`BoxPlotStyleOptions`](crate::model::BoxPlotStyleOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fill_style: std::option::Option<crate::model::BoxPlotFillStyle>,
    }
    impl Builder {
        /// <p>The fill styles (solid, transparent) of the box plot.</p>
        pub fn fill_style(mut self, input: crate::model::BoxPlotFillStyle) -> Self {
            self.fill_style = Some(input);
            self
        }
        /// <p>The fill styles (solid, transparent) of the box plot.</p>
        pub fn set_fill_style(
            mut self,
            input: std::option::Option<crate::model::BoxPlotFillStyle>,
        ) -> Self {
            self.fill_style = input;
            self
        }
        /// Consumes the builder and constructs a [`BoxPlotStyleOptions`](crate::model::BoxPlotStyleOptions).
        pub fn build(self) -> crate::model::BoxPlotStyleOptions {
            crate::model::BoxPlotStyleOptions {
                fill_style: self.fill_style,
            }
        }
    }
}
impl BoxPlotStyleOptions {
    /// Creates a new builder-style object to manufacture [`BoxPlotStyleOptions`](crate::model::BoxPlotStyleOptions).
    pub fn builder() -> crate::model::box_plot_style_options::Builder {
        crate::model::box_plot_style_options::Builder::default()
    }
}

/// When writing a match expression against `BoxPlotFillStyle`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let boxplotfillstyle = unimplemented!();
/// match boxplotfillstyle {
///     BoxPlotFillStyle::Solid => { /* ... */ },
///     BoxPlotFillStyle::Transparent => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `boxplotfillstyle` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BoxPlotFillStyle::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BoxPlotFillStyle::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BoxPlotFillStyle::NewFeature` is defined.
/// Specifically, when `boxplotfillstyle` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BoxPlotFillStyle::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BoxPlotFillStyle {
    #[allow(missing_docs)] // documentation missing in model
    Solid,
    #[allow(missing_docs)] // documentation missing in model
    Transparent,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BoxPlotFillStyle {
    fn from(s: &str) -> Self {
        match s {
            "SOLID" => BoxPlotFillStyle::Solid,
            "TRANSPARENT" => BoxPlotFillStyle::Transparent,
            other => BoxPlotFillStyle::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for BoxPlotFillStyle {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BoxPlotFillStyle::from(s))
    }
}
impl BoxPlotFillStyle {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BoxPlotFillStyle::Solid => "SOLID",
            BoxPlotFillStyle::Transparent => "TRANSPARENT",
            BoxPlotFillStyle::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SOLID", "TRANSPARENT"]
    }
}
impl AsRef<str> for BoxPlotFillStyle {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The sort configuration of a <code>BoxPlotVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BoxPlotSortConfiguration {
    /// <p>The sort configuration of a group by fields.</p>
    #[doc(hidden)]
    pub category_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    /// <p>The pagination configuration of a table visual or box plot.</p>
    #[doc(hidden)]
    pub pagination_configuration: std::option::Option<crate::model::PaginationConfiguration>,
}
impl BoxPlotSortConfiguration {
    /// <p>The sort configuration of a group by fields.</p>
    pub fn category_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.category_sort.as_deref()
    }
    /// <p>The pagination configuration of a table visual or box plot.</p>
    pub fn pagination_configuration(
        &self,
    ) -> std::option::Option<&crate::model::PaginationConfiguration> {
        self.pagination_configuration.as_ref()
    }
}
/// See [`BoxPlotSortConfiguration`](crate::model::BoxPlotSortConfiguration).
pub mod box_plot_sort_configuration {

    /// A builder for [`BoxPlotSortConfiguration`](crate::model::BoxPlotSortConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category_sort:
            std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        pub(crate) pagination_configuration:
            std::option::Option<crate::model::PaginationConfiguration>,
    }
    impl Builder {
        /// Appends an item to `category_sort`.
        ///
        /// To override the contents of this collection use [`set_category_sort`](Self::set_category_sort).
        ///
        /// <p>The sort configuration of a group by fields.</p>
        pub fn category_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.category_sort.unwrap_or_default();
            v.push(input);
            self.category_sort = Some(v);
            self
        }
        /// <p>The sort configuration of a group by fields.</p>
        pub fn set_category_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.category_sort = input;
            self
        }
        /// <p>The pagination configuration of a table visual or box plot.</p>
        pub fn pagination_configuration(
            mut self,
            input: crate::model::PaginationConfiguration,
        ) -> Self {
            self.pagination_configuration = Some(input);
            self
        }
        /// <p>The pagination configuration of a table visual or box plot.</p>
        pub fn set_pagination_configuration(
            mut self,
            input: std::option::Option<crate::model::PaginationConfiguration>,
        ) -> Self {
            self.pagination_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`BoxPlotSortConfiguration`](crate::model::BoxPlotSortConfiguration).
        pub fn build(self) -> crate::model::BoxPlotSortConfiguration {
            crate::model::BoxPlotSortConfiguration {
                category_sort: self.category_sort,
                pagination_configuration: self.pagination_configuration,
            }
        }
    }
}
impl BoxPlotSortConfiguration {
    /// Creates a new builder-style object to manufacture [`BoxPlotSortConfiguration`](crate::model::BoxPlotSortConfiguration).
    pub fn builder() -> crate::model::box_plot_sort_configuration::Builder {
        crate::model::box_plot_sort_configuration::Builder::default()
    }
}

/// <p>The pagination configuration for a table visual or boxplot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PaginationConfiguration {
    /// <p>Indicates how many items render in one page.</p>
    #[doc(hidden)]
    pub page_size: std::option::Option<i64>,
    /// <p>Indicates the page number.</p>
    #[doc(hidden)]
    pub page_number: std::option::Option<i64>,
}
impl PaginationConfiguration {
    /// <p>Indicates how many items render in one page.</p>
    pub fn page_size(&self) -> std::option::Option<i64> {
        self.page_size
    }
    /// <p>Indicates the page number.</p>
    pub fn page_number(&self) -> std::option::Option<i64> {
        self.page_number
    }
}
/// See [`PaginationConfiguration`](crate::model::PaginationConfiguration).
pub mod pagination_configuration {

    /// A builder for [`PaginationConfiguration`](crate::model::PaginationConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_size: std::option::Option<i64>,
        pub(crate) page_number: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>Indicates how many items render in one page.</p>
        pub fn page_size(mut self, input: i64) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>Indicates how many items render in one page.</p>
        pub fn set_page_size(mut self, input: std::option::Option<i64>) -> Self {
            self.page_size = input;
            self
        }
        /// <p>Indicates the page number.</p>
        pub fn page_number(mut self, input: i64) -> Self {
            self.page_number = Some(input);
            self
        }
        /// <p>Indicates the page number.</p>
        pub fn set_page_number(mut self, input: std::option::Option<i64>) -> Self {
            self.page_number = input;
            self
        }
        /// Consumes the builder and constructs a [`PaginationConfiguration`](crate::model::PaginationConfiguration).
        pub fn build(self) -> crate::model::PaginationConfiguration {
            crate::model::PaginationConfiguration {
                page_size: self.page_size,
                page_number: self.page_number,
            }
        }
    }
}
impl PaginationConfiguration {
    /// Creates a new builder-style object to manufacture [`PaginationConfiguration`](crate::model::PaginationConfiguration).
    pub fn builder() -> crate::model::pagination_configuration::Builder {
        crate::model::pagination_configuration::Builder::default()
    }
}

/// <p>The field wells of a <code>BoxPlotVisual</code>.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BoxPlotFieldWells {
    /// <p>The aggregated field wells of a box plot.</p>
    #[doc(hidden)]
    pub box_plot_aggregated_field_wells:
        std::option::Option<crate::model::BoxPlotAggregatedFieldWells>,
}
impl BoxPlotFieldWells {
    /// <p>The aggregated field wells of a box plot.</p>
    pub fn box_plot_aggregated_field_wells(
        &self,
    ) -> std::option::Option<&crate::model::BoxPlotAggregatedFieldWells> {
        self.box_plot_aggregated_field_wells.as_ref()
    }
}
/// See [`BoxPlotFieldWells`](crate::model::BoxPlotFieldWells).
pub mod box_plot_field_wells {

    /// A builder for [`BoxPlotFieldWells`](crate::model::BoxPlotFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) box_plot_aggregated_field_wells:
            std::option::Option<crate::model::BoxPlotAggregatedFieldWells>,
    }
    impl Builder {
        /// <p>The aggregated field wells of a box plot.</p>
        pub fn box_plot_aggregated_field_wells(
            mut self,
            input: crate::model::BoxPlotAggregatedFieldWells,
        ) -> Self {
            self.box_plot_aggregated_field_wells = Some(input);
            self
        }
        /// <p>The aggregated field wells of a box plot.</p>
        pub fn set_box_plot_aggregated_field_wells(
            mut self,
            input: std::option::Option<crate::model::BoxPlotAggregatedFieldWells>,
        ) -> Self {
            self.box_plot_aggregated_field_wells = input;
            self
        }
        /// Consumes the builder and constructs a [`BoxPlotFieldWells`](crate::model::BoxPlotFieldWells).
        pub fn build(self) -> crate::model::BoxPlotFieldWells {
            crate::model::BoxPlotFieldWells {
                box_plot_aggregated_field_wells: self.box_plot_aggregated_field_wells,
            }
        }
    }
}
impl BoxPlotFieldWells {
    /// Creates a new builder-style object to manufacture [`BoxPlotFieldWells`](crate::model::BoxPlotFieldWells).
    pub fn builder() -> crate::model::box_plot_field_wells::Builder {
        crate::model::box_plot_field_wells::Builder::default()
    }
}

/// <p>The aggregated field well for a box plot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BoxPlotAggregatedFieldWells {
    /// <p>The group by field well of a box plot chart. Values are grouped based on group by fields.</p>
    #[doc(hidden)]
    pub group_by: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The value field well of a box plot chart. Values are aggregated based on group by fields.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
}
impl BoxPlotAggregatedFieldWells {
    /// <p>The group by field well of a box plot chart. Values are grouped based on group by fields.</p>
    pub fn group_by(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.group_by.as_deref()
    }
    /// <p>The value field well of a box plot chart. Values are aggregated based on group by fields.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.values.as_deref()
    }
}
/// See [`BoxPlotAggregatedFieldWells`](crate::model::BoxPlotAggregatedFieldWells).
pub mod box_plot_aggregated_field_wells {

    /// A builder for [`BoxPlotAggregatedFieldWells`](crate::model::BoxPlotAggregatedFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_by: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    }
    impl Builder {
        /// Appends an item to `group_by`.
        ///
        /// To override the contents of this collection use [`set_group_by`](Self::set_group_by).
        ///
        /// <p>The group by field well of a box plot chart. Values are grouped based on group by fields.</p>
        pub fn group_by(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.group_by.unwrap_or_default();
            v.push(input);
            self.group_by = Some(v);
            self
        }
        /// <p>The group by field well of a box plot chart. Values are grouped based on group by fields.</p>
        pub fn set_group_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.group_by = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The value field well of a box plot chart. Values are aggregated based on group by fields.</p>
        pub fn values(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>The value field well of a box plot chart. Values are aggregated based on group by fields.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`BoxPlotAggregatedFieldWells`](crate::model::BoxPlotAggregatedFieldWells).
        pub fn build(self) -> crate::model::BoxPlotAggregatedFieldWells {
            crate::model::BoxPlotAggregatedFieldWells {
                group_by: self.group_by,
                values: self.values,
            }
        }
    }
}
impl BoxPlotAggregatedFieldWells {
    /// Creates a new builder-style object to manufacture [`BoxPlotAggregatedFieldWells`](crate::model::BoxPlotAggregatedFieldWells).
    pub fn builder() -> crate::model::box_plot_aggregated_field_wells::Builder {
        crate::model::box_plot_aggregated_field_wells::Builder::default()
    }
}

/// <p>A combo chart.</p>
/// <p>The <code>ComboChartVisual</code> includes stacked bar combo charts and clustered bar combo charts</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/combo-charts.html">Using combo charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComboChartVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration settings of the visual.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::ComboChartConfiguration>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    #[doc(hidden)]
    pub column_hierarchies: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
}
impl ComboChartVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration settings of the visual.</p>
    pub fn chart_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ComboChartConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    pub fn column_hierarchies(&self) -> std::option::Option<&[crate::model::ColumnHierarchy]> {
        self.column_hierarchies.as_deref()
    }
}
/// See [`ComboChartVisual`](crate::model::ComboChartVisual).
pub mod combo_chart_visual {

    /// A builder for [`ComboChartVisual`](crate::model::ComboChartVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration: std::option::Option<crate::model::ComboChartConfiguration>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        pub(crate) column_hierarchies:
            std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn chart_configuration(mut self, input: crate::model::ComboChartConfiguration) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::ComboChartConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Appends an item to `column_hierarchies`.
        ///
        /// To override the contents of this collection use [`set_column_hierarchies`](Self::set_column_hierarchies).
        ///
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn column_hierarchies(mut self, input: crate::model::ColumnHierarchy) -> Self {
            let mut v = self.column_hierarchies.unwrap_or_default();
            v.push(input);
            self.column_hierarchies = Some(v);
            self
        }
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn set_column_hierarchies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
        ) -> Self {
            self.column_hierarchies = input;
            self
        }
        /// Consumes the builder and constructs a [`ComboChartVisual`](crate::model::ComboChartVisual).
        pub fn build(self) -> crate::model::ComboChartVisual {
            crate::model::ComboChartVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                actions: self.actions,
                column_hierarchies: self.column_hierarchies,
            }
        }
    }
}
impl ComboChartVisual {
    /// Creates a new builder-style object to manufacture [`ComboChartVisual`](crate::model::ComboChartVisual).
    pub fn builder() -> crate::model::combo_chart_visual::Builder {
        crate::model::combo_chart_visual::Builder::default()
    }
}

/// <p>The configuration of a <code>ComboChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComboChartConfiguration {
    /// <p>The field wells of the visual.</p>
    #[doc(hidden)]
    pub field_wells: std::option::Option<crate::model::ComboChartFieldWells>,
    /// <p>The sort configuration of a <code>ComboChartVisual</code>.</p>
    #[doc(hidden)]
    pub sort_configuration: std::option::Option<crate::model::ComboChartSortConfiguration>,
    /// <p>Determines the bar arrangement in a combo chart. The following are valid values in this structure:</p>
    /// <ul>
    /// <li> <p> <code>CLUSTERED</code>: For clustered bar combo charts.</p> </li>
    /// <li> <p> <code>STACKED</code>: For stacked bar combo charts.</p> </li>
    /// <li> <p> <code>STACKED_PERCENT</code>: Do not use. If you use this value, the operation returns a validation error.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub bars_arrangement: std::option::Option<crate::model::BarsArrangement>,
    /// <p>The category axis of a combo chart.</p>
    #[doc(hidden)]
    pub category_axis: std::option::Option<crate::model::AxisDisplayOptions>,
    /// <p>The label options (label text, label visibility, and sort icon visibility) of a combo chart category (group/color) field well.</p>
    #[doc(hidden)]
    pub category_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The label display options (grid line, range, scale, and axis step) of a combo chart's primary y-axis (bar) field well.</p>
    #[doc(hidden)]
    pub primary_y_axis_display_options: std::option::Option<crate::model::AxisDisplayOptions>,
    /// <p>The label options (label text, label visibility, and sort icon visibility) of a combo chart's primary y-axis (bar) field well.</p>
    #[doc(hidden)]
    pub primary_y_axis_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The label display options (grid line, range, scale, axis step) of a combo chart's secondary y-axis (line) field well.</p>
    #[doc(hidden)]
    pub secondary_y_axis_display_options: std::option::Option<crate::model::AxisDisplayOptions>,
    /// <p>The label options (label text, label visibility, and sort icon visibility) of a combo chart's secondary y-axis(line) field well.</p>
    #[doc(hidden)]
    pub secondary_y_axis_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The label options (label text, label visibility, and sort icon visibility) of a combo chart's color field well.</p>
    #[doc(hidden)]
    pub color_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The legend display setup of the visual.</p>
    #[doc(hidden)]
    pub legend: std::option::Option<crate::model::LegendOptions>,
    /// <p>The options that determine if visual data labels are displayed.</p>
    /// <p>The data label options for a bar in a combo chart.</p>
    #[doc(hidden)]
    pub bar_data_labels: std::option::Option<crate::model::DataLabelOptions>,
    /// <p>The options that determine if visual data labels are displayed.</p>
    /// <p>The data label options for a line in a combo chart.</p>
    #[doc(hidden)]
    pub line_data_labels: std::option::Option<crate::model::DataLabelOptions>,
    /// <p>The legend display setup of the visual.</p>
    #[doc(hidden)]
    pub tooltip: std::option::Option<crate::model::TooltipOptions>,
    /// <p>The reference line setup of the visual.</p>
    #[doc(hidden)]
    pub reference_lines: std::option::Option<std::vec::Vec<crate::model::ReferenceLine>>,
    /// <p>The palette (chart color) display setup of the visual.</p>
    #[doc(hidden)]
    pub visual_palette: std::option::Option<crate::model::VisualPalette>,
}
impl ComboChartConfiguration {
    /// <p>The field wells of the visual.</p>
    pub fn field_wells(&self) -> std::option::Option<&crate::model::ComboChartFieldWells> {
        self.field_wells.as_ref()
    }
    /// <p>The sort configuration of a <code>ComboChartVisual</code>.</p>
    pub fn sort_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ComboChartSortConfiguration> {
        self.sort_configuration.as_ref()
    }
    /// <p>Determines the bar arrangement in a combo chart. The following are valid values in this structure:</p>
    /// <ul>
    /// <li> <p> <code>CLUSTERED</code>: For clustered bar combo charts.</p> </li>
    /// <li> <p> <code>STACKED</code>: For stacked bar combo charts.</p> </li>
    /// <li> <p> <code>STACKED_PERCENT</code>: Do not use. If you use this value, the operation returns a validation error.</p> </li>
    /// </ul>
    pub fn bars_arrangement(&self) -> std::option::Option<&crate::model::BarsArrangement> {
        self.bars_arrangement.as_ref()
    }
    /// <p>The category axis of a combo chart.</p>
    pub fn category_axis(&self) -> std::option::Option<&crate::model::AxisDisplayOptions> {
        self.category_axis.as_ref()
    }
    /// <p>The label options (label text, label visibility, and sort icon visibility) of a combo chart category (group/color) field well.</p>
    pub fn category_label_options(
        &self,
    ) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.category_label_options.as_ref()
    }
    /// <p>The label display options (grid line, range, scale, and axis step) of a combo chart's primary y-axis (bar) field well.</p>
    pub fn primary_y_axis_display_options(
        &self,
    ) -> std::option::Option<&crate::model::AxisDisplayOptions> {
        self.primary_y_axis_display_options.as_ref()
    }
    /// <p>The label options (label text, label visibility, and sort icon visibility) of a combo chart's primary y-axis (bar) field well.</p>
    pub fn primary_y_axis_label_options(
        &self,
    ) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.primary_y_axis_label_options.as_ref()
    }
    /// <p>The label display options (grid line, range, scale, axis step) of a combo chart's secondary y-axis (line) field well.</p>
    pub fn secondary_y_axis_display_options(
        &self,
    ) -> std::option::Option<&crate::model::AxisDisplayOptions> {
        self.secondary_y_axis_display_options.as_ref()
    }
    /// <p>The label options (label text, label visibility, and sort icon visibility) of a combo chart's secondary y-axis(line) field well.</p>
    pub fn secondary_y_axis_label_options(
        &self,
    ) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.secondary_y_axis_label_options.as_ref()
    }
    /// <p>The label options (label text, label visibility, and sort icon visibility) of a combo chart's color field well.</p>
    pub fn color_label_options(&self) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.color_label_options.as_ref()
    }
    /// <p>The legend display setup of the visual.</p>
    pub fn legend(&self) -> std::option::Option<&crate::model::LegendOptions> {
        self.legend.as_ref()
    }
    /// <p>The options that determine if visual data labels are displayed.</p>
    /// <p>The data label options for a bar in a combo chart.</p>
    pub fn bar_data_labels(&self) -> std::option::Option<&crate::model::DataLabelOptions> {
        self.bar_data_labels.as_ref()
    }
    /// <p>The options that determine if visual data labels are displayed.</p>
    /// <p>The data label options for a line in a combo chart.</p>
    pub fn line_data_labels(&self) -> std::option::Option<&crate::model::DataLabelOptions> {
        self.line_data_labels.as_ref()
    }
    /// <p>The legend display setup of the visual.</p>
    pub fn tooltip(&self) -> std::option::Option<&crate::model::TooltipOptions> {
        self.tooltip.as_ref()
    }
    /// <p>The reference line setup of the visual.</p>
    pub fn reference_lines(&self) -> std::option::Option<&[crate::model::ReferenceLine]> {
        self.reference_lines.as_deref()
    }
    /// <p>The palette (chart color) display setup of the visual.</p>
    pub fn visual_palette(&self) -> std::option::Option<&crate::model::VisualPalette> {
        self.visual_palette.as_ref()
    }
}
/// See [`ComboChartConfiguration`](crate::model::ComboChartConfiguration).
pub mod combo_chart_configuration {

    /// A builder for [`ComboChartConfiguration`](crate::model::ComboChartConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_wells: std::option::Option<crate::model::ComboChartFieldWells>,
        pub(crate) sort_configuration:
            std::option::Option<crate::model::ComboChartSortConfiguration>,
        pub(crate) bars_arrangement: std::option::Option<crate::model::BarsArrangement>,
        pub(crate) category_axis: std::option::Option<crate::model::AxisDisplayOptions>,
        pub(crate) category_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) primary_y_axis_display_options:
            std::option::Option<crate::model::AxisDisplayOptions>,
        pub(crate) primary_y_axis_label_options:
            std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) secondary_y_axis_display_options:
            std::option::Option<crate::model::AxisDisplayOptions>,
        pub(crate) secondary_y_axis_label_options:
            std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) color_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) legend: std::option::Option<crate::model::LegendOptions>,
        pub(crate) bar_data_labels: std::option::Option<crate::model::DataLabelOptions>,
        pub(crate) line_data_labels: std::option::Option<crate::model::DataLabelOptions>,
        pub(crate) tooltip: std::option::Option<crate::model::TooltipOptions>,
        pub(crate) reference_lines: std::option::Option<std::vec::Vec<crate::model::ReferenceLine>>,
        pub(crate) visual_palette: std::option::Option<crate::model::VisualPalette>,
    }
    impl Builder {
        /// <p>The field wells of the visual.</p>
        pub fn field_wells(mut self, input: crate::model::ComboChartFieldWells) -> Self {
            self.field_wells = Some(input);
            self
        }
        /// <p>The field wells of the visual.</p>
        pub fn set_field_wells(
            mut self,
            input: std::option::Option<crate::model::ComboChartFieldWells>,
        ) -> Self {
            self.field_wells = input;
            self
        }
        /// <p>The sort configuration of a <code>ComboChartVisual</code>.</p>
        pub fn sort_configuration(
            mut self,
            input: crate::model::ComboChartSortConfiguration,
        ) -> Self {
            self.sort_configuration = Some(input);
            self
        }
        /// <p>The sort configuration of a <code>ComboChartVisual</code>.</p>
        pub fn set_sort_configuration(
            mut self,
            input: std::option::Option<crate::model::ComboChartSortConfiguration>,
        ) -> Self {
            self.sort_configuration = input;
            self
        }
        /// <p>Determines the bar arrangement in a combo chart. The following are valid values in this structure:</p>
        /// <ul>
        /// <li> <p> <code>CLUSTERED</code>: For clustered bar combo charts.</p> </li>
        /// <li> <p> <code>STACKED</code>: For stacked bar combo charts.</p> </li>
        /// <li> <p> <code>STACKED_PERCENT</code>: Do not use. If you use this value, the operation returns a validation error.</p> </li>
        /// </ul>
        pub fn bars_arrangement(mut self, input: crate::model::BarsArrangement) -> Self {
            self.bars_arrangement = Some(input);
            self
        }
        /// <p>Determines the bar arrangement in a combo chart. The following are valid values in this structure:</p>
        /// <ul>
        /// <li> <p> <code>CLUSTERED</code>: For clustered bar combo charts.</p> </li>
        /// <li> <p> <code>STACKED</code>: For stacked bar combo charts.</p> </li>
        /// <li> <p> <code>STACKED_PERCENT</code>: Do not use. If you use this value, the operation returns a validation error.</p> </li>
        /// </ul>
        pub fn set_bars_arrangement(
            mut self,
            input: std::option::Option<crate::model::BarsArrangement>,
        ) -> Self {
            self.bars_arrangement = input;
            self
        }
        /// <p>The category axis of a combo chart.</p>
        pub fn category_axis(mut self, input: crate::model::AxisDisplayOptions) -> Self {
            self.category_axis = Some(input);
            self
        }
        /// <p>The category axis of a combo chart.</p>
        pub fn set_category_axis(
            mut self,
            input: std::option::Option<crate::model::AxisDisplayOptions>,
        ) -> Self {
            self.category_axis = input;
            self
        }
        /// <p>The label options (label text, label visibility, and sort icon visibility) of a combo chart category (group/color) field well.</p>
        pub fn category_label_options(
            mut self,
            input: crate::model::ChartAxisLabelOptions,
        ) -> Self {
            self.category_label_options = Some(input);
            self
        }
        /// <p>The label options (label text, label visibility, and sort icon visibility) of a combo chart category (group/color) field well.</p>
        pub fn set_category_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.category_label_options = input;
            self
        }
        /// <p>The label display options (grid line, range, scale, and axis step) of a combo chart's primary y-axis (bar) field well.</p>
        pub fn primary_y_axis_display_options(
            mut self,
            input: crate::model::AxisDisplayOptions,
        ) -> Self {
            self.primary_y_axis_display_options = Some(input);
            self
        }
        /// <p>The label display options (grid line, range, scale, and axis step) of a combo chart's primary y-axis (bar) field well.</p>
        pub fn set_primary_y_axis_display_options(
            mut self,
            input: std::option::Option<crate::model::AxisDisplayOptions>,
        ) -> Self {
            self.primary_y_axis_display_options = input;
            self
        }
        /// <p>The label options (label text, label visibility, and sort icon visibility) of a combo chart's primary y-axis (bar) field well.</p>
        pub fn primary_y_axis_label_options(
            mut self,
            input: crate::model::ChartAxisLabelOptions,
        ) -> Self {
            self.primary_y_axis_label_options = Some(input);
            self
        }
        /// <p>The label options (label text, label visibility, and sort icon visibility) of a combo chart's primary y-axis (bar) field well.</p>
        pub fn set_primary_y_axis_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.primary_y_axis_label_options = input;
            self
        }
        /// <p>The label display options (grid line, range, scale, axis step) of a combo chart's secondary y-axis (line) field well.</p>
        pub fn secondary_y_axis_display_options(
            mut self,
            input: crate::model::AxisDisplayOptions,
        ) -> Self {
            self.secondary_y_axis_display_options = Some(input);
            self
        }
        /// <p>The label display options (grid line, range, scale, axis step) of a combo chart's secondary y-axis (line) field well.</p>
        pub fn set_secondary_y_axis_display_options(
            mut self,
            input: std::option::Option<crate::model::AxisDisplayOptions>,
        ) -> Self {
            self.secondary_y_axis_display_options = input;
            self
        }
        /// <p>The label options (label text, label visibility, and sort icon visibility) of a combo chart's secondary y-axis(line) field well.</p>
        pub fn secondary_y_axis_label_options(
            mut self,
            input: crate::model::ChartAxisLabelOptions,
        ) -> Self {
            self.secondary_y_axis_label_options = Some(input);
            self
        }
        /// <p>The label options (label text, label visibility, and sort icon visibility) of a combo chart's secondary y-axis(line) field well.</p>
        pub fn set_secondary_y_axis_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.secondary_y_axis_label_options = input;
            self
        }
        /// <p>The label options (label text, label visibility, and sort icon visibility) of a combo chart's color field well.</p>
        pub fn color_label_options(mut self, input: crate::model::ChartAxisLabelOptions) -> Self {
            self.color_label_options = Some(input);
            self
        }
        /// <p>The label options (label text, label visibility, and sort icon visibility) of a combo chart's color field well.</p>
        pub fn set_color_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.color_label_options = input;
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn legend(mut self, input: crate::model::LegendOptions) -> Self {
            self.legend = Some(input);
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn set_legend(
            mut self,
            input: std::option::Option<crate::model::LegendOptions>,
        ) -> Self {
            self.legend = input;
            self
        }
        /// <p>The options that determine if visual data labels are displayed.</p>
        /// <p>The data label options for a bar in a combo chart.</p>
        pub fn bar_data_labels(mut self, input: crate::model::DataLabelOptions) -> Self {
            self.bar_data_labels = Some(input);
            self
        }
        /// <p>The options that determine if visual data labels are displayed.</p>
        /// <p>The data label options for a bar in a combo chart.</p>
        pub fn set_bar_data_labels(
            mut self,
            input: std::option::Option<crate::model::DataLabelOptions>,
        ) -> Self {
            self.bar_data_labels = input;
            self
        }
        /// <p>The options that determine if visual data labels are displayed.</p>
        /// <p>The data label options for a line in a combo chart.</p>
        pub fn line_data_labels(mut self, input: crate::model::DataLabelOptions) -> Self {
            self.line_data_labels = Some(input);
            self
        }
        /// <p>The options that determine if visual data labels are displayed.</p>
        /// <p>The data label options for a line in a combo chart.</p>
        pub fn set_line_data_labels(
            mut self,
            input: std::option::Option<crate::model::DataLabelOptions>,
        ) -> Self {
            self.line_data_labels = input;
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn tooltip(mut self, input: crate::model::TooltipOptions) -> Self {
            self.tooltip = Some(input);
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn set_tooltip(
            mut self,
            input: std::option::Option<crate::model::TooltipOptions>,
        ) -> Self {
            self.tooltip = input;
            self
        }
        /// Appends an item to `reference_lines`.
        ///
        /// To override the contents of this collection use [`set_reference_lines`](Self::set_reference_lines).
        ///
        /// <p>The reference line setup of the visual.</p>
        pub fn reference_lines(mut self, input: crate::model::ReferenceLine) -> Self {
            let mut v = self.reference_lines.unwrap_or_default();
            v.push(input);
            self.reference_lines = Some(v);
            self
        }
        /// <p>The reference line setup of the visual.</p>
        pub fn set_reference_lines(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReferenceLine>>,
        ) -> Self {
            self.reference_lines = input;
            self
        }
        /// <p>The palette (chart color) display setup of the visual.</p>
        pub fn visual_palette(mut self, input: crate::model::VisualPalette) -> Self {
            self.visual_palette = Some(input);
            self
        }
        /// <p>The palette (chart color) display setup of the visual.</p>
        pub fn set_visual_palette(
            mut self,
            input: std::option::Option<crate::model::VisualPalette>,
        ) -> Self {
            self.visual_palette = input;
            self
        }
        /// Consumes the builder and constructs a [`ComboChartConfiguration`](crate::model::ComboChartConfiguration).
        pub fn build(self) -> crate::model::ComboChartConfiguration {
            crate::model::ComboChartConfiguration {
                field_wells: self.field_wells,
                sort_configuration: self.sort_configuration,
                bars_arrangement: self.bars_arrangement,
                category_axis: self.category_axis,
                category_label_options: self.category_label_options,
                primary_y_axis_display_options: self.primary_y_axis_display_options,
                primary_y_axis_label_options: self.primary_y_axis_label_options,
                secondary_y_axis_display_options: self.secondary_y_axis_display_options,
                secondary_y_axis_label_options: self.secondary_y_axis_label_options,
                color_label_options: self.color_label_options,
                legend: self.legend,
                bar_data_labels: self.bar_data_labels,
                line_data_labels: self.line_data_labels,
                tooltip: self.tooltip,
                reference_lines: self.reference_lines,
                visual_palette: self.visual_palette,
            }
        }
    }
}
impl ComboChartConfiguration {
    /// Creates a new builder-style object to manufacture [`ComboChartConfiguration`](crate::model::ComboChartConfiguration).
    pub fn builder() -> crate::model::combo_chart_configuration::Builder {
        crate::model::combo_chart_configuration::Builder::default()
    }
}

/// When writing a match expression against `BarsArrangement`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let barsarrangement = unimplemented!();
/// match barsarrangement {
///     BarsArrangement::Clustered => { /* ... */ },
///     BarsArrangement::Stacked => { /* ... */ },
///     BarsArrangement::StackedPercent => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `barsarrangement` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BarsArrangement::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BarsArrangement::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BarsArrangement::NewFeature` is defined.
/// Specifically, when `barsarrangement` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BarsArrangement::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BarsArrangement {
    #[allow(missing_docs)] // documentation missing in model
    Clustered,
    #[allow(missing_docs)] // documentation missing in model
    Stacked,
    #[allow(missing_docs)] // documentation missing in model
    StackedPercent,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BarsArrangement {
    fn from(s: &str) -> Self {
        match s {
            "CLUSTERED" => BarsArrangement::Clustered,
            "STACKED" => BarsArrangement::Stacked,
            "STACKED_PERCENT" => BarsArrangement::StackedPercent,
            other => BarsArrangement::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for BarsArrangement {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BarsArrangement::from(s))
    }
}
impl BarsArrangement {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BarsArrangement::Clustered => "CLUSTERED",
            BarsArrangement::Stacked => "STACKED",
            BarsArrangement::StackedPercent => "STACKED_PERCENT",
            BarsArrangement::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CLUSTERED", "STACKED", "STACKED_PERCENT"]
    }
}
impl AsRef<str> for BarsArrangement {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The sort configuration of a <code>ComboChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComboChartSortConfiguration {
    /// <p>The sort configuration of the category field well in a combo chart.</p>
    #[doc(hidden)]
    pub category_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    /// <p>The item limit configuration for the category field well of a combo chart.</p>
    #[doc(hidden)]
    pub category_items_limit: std::option::Option<crate::model::ItemsLimitConfiguration>,
    /// <p>The sort configuration of the color field well in a combo chart.</p>
    #[doc(hidden)]
    pub color_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    /// <p>The item limit configuration of the color field well in a combo chart.</p>
    #[doc(hidden)]
    pub color_items_limit: std::option::Option<crate::model::ItemsLimitConfiguration>,
}
impl ComboChartSortConfiguration {
    /// <p>The sort configuration of the category field well in a combo chart.</p>
    pub fn category_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.category_sort.as_deref()
    }
    /// <p>The item limit configuration for the category field well of a combo chart.</p>
    pub fn category_items_limit(
        &self,
    ) -> std::option::Option<&crate::model::ItemsLimitConfiguration> {
        self.category_items_limit.as_ref()
    }
    /// <p>The sort configuration of the color field well in a combo chart.</p>
    pub fn color_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.color_sort.as_deref()
    }
    /// <p>The item limit configuration of the color field well in a combo chart.</p>
    pub fn color_items_limit(&self) -> std::option::Option<&crate::model::ItemsLimitConfiguration> {
        self.color_items_limit.as_ref()
    }
}
/// See [`ComboChartSortConfiguration`](crate::model::ComboChartSortConfiguration).
pub mod combo_chart_sort_configuration {

    /// A builder for [`ComboChartSortConfiguration`](crate::model::ComboChartSortConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category_sort:
            std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        pub(crate) category_items_limit: std::option::Option<crate::model::ItemsLimitConfiguration>,
        pub(crate) color_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        pub(crate) color_items_limit: std::option::Option<crate::model::ItemsLimitConfiguration>,
    }
    impl Builder {
        /// Appends an item to `category_sort`.
        ///
        /// To override the contents of this collection use [`set_category_sort`](Self::set_category_sort).
        ///
        /// <p>The sort configuration of the category field well in a combo chart.</p>
        pub fn category_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.category_sort.unwrap_or_default();
            v.push(input);
            self.category_sort = Some(v);
            self
        }
        /// <p>The sort configuration of the category field well in a combo chart.</p>
        pub fn set_category_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.category_sort = input;
            self
        }
        /// <p>The item limit configuration for the category field well of a combo chart.</p>
        pub fn category_items_limit(
            mut self,
            input: crate::model::ItemsLimitConfiguration,
        ) -> Self {
            self.category_items_limit = Some(input);
            self
        }
        /// <p>The item limit configuration for the category field well of a combo chart.</p>
        pub fn set_category_items_limit(
            mut self,
            input: std::option::Option<crate::model::ItemsLimitConfiguration>,
        ) -> Self {
            self.category_items_limit = input;
            self
        }
        /// Appends an item to `color_sort`.
        ///
        /// To override the contents of this collection use [`set_color_sort`](Self::set_color_sort).
        ///
        /// <p>The sort configuration of the color field well in a combo chart.</p>
        pub fn color_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.color_sort.unwrap_or_default();
            v.push(input);
            self.color_sort = Some(v);
            self
        }
        /// <p>The sort configuration of the color field well in a combo chart.</p>
        pub fn set_color_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.color_sort = input;
            self
        }
        /// <p>The item limit configuration of the color field well in a combo chart.</p>
        pub fn color_items_limit(mut self, input: crate::model::ItemsLimitConfiguration) -> Self {
            self.color_items_limit = Some(input);
            self
        }
        /// <p>The item limit configuration of the color field well in a combo chart.</p>
        pub fn set_color_items_limit(
            mut self,
            input: std::option::Option<crate::model::ItemsLimitConfiguration>,
        ) -> Self {
            self.color_items_limit = input;
            self
        }
        /// Consumes the builder and constructs a [`ComboChartSortConfiguration`](crate::model::ComboChartSortConfiguration).
        pub fn build(self) -> crate::model::ComboChartSortConfiguration {
            crate::model::ComboChartSortConfiguration {
                category_sort: self.category_sort,
                category_items_limit: self.category_items_limit,
                color_sort: self.color_sort,
                color_items_limit: self.color_items_limit,
            }
        }
    }
}
impl ComboChartSortConfiguration {
    /// Creates a new builder-style object to manufacture [`ComboChartSortConfiguration`](crate::model::ComboChartSortConfiguration).
    pub fn builder() -> crate::model::combo_chart_sort_configuration::Builder {
        crate::model::combo_chart_sort_configuration::Builder::default()
    }
}

/// <p>The field wells of the visual.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComboChartFieldWells {
    /// <p>The aggregated field wells of a combo chart. Combo charts only have aggregated field wells. Columns in a combo chart are aggregated by category.</p>
    #[doc(hidden)]
    pub combo_chart_aggregated_field_wells:
        std::option::Option<crate::model::ComboChartAggregatedFieldWells>,
}
impl ComboChartFieldWells {
    /// <p>The aggregated field wells of a combo chart. Combo charts only have aggregated field wells. Columns in a combo chart are aggregated by category.</p>
    pub fn combo_chart_aggregated_field_wells(
        &self,
    ) -> std::option::Option<&crate::model::ComboChartAggregatedFieldWells> {
        self.combo_chart_aggregated_field_wells.as_ref()
    }
}
/// See [`ComboChartFieldWells`](crate::model::ComboChartFieldWells).
pub mod combo_chart_field_wells {

    /// A builder for [`ComboChartFieldWells`](crate::model::ComboChartFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) combo_chart_aggregated_field_wells:
            std::option::Option<crate::model::ComboChartAggregatedFieldWells>,
    }
    impl Builder {
        /// <p>The aggregated field wells of a combo chart. Combo charts only have aggregated field wells. Columns in a combo chart are aggregated by category.</p>
        pub fn combo_chart_aggregated_field_wells(
            mut self,
            input: crate::model::ComboChartAggregatedFieldWells,
        ) -> Self {
            self.combo_chart_aggregated_field_wells = Some(input);
            self
        }
        /// <p>The aggregated field wells of a combo chart. Combo charts only have aggregated field wells. Columns in a combo chart are aggregated by category.</p>
        pub fn set_combo_chart_aggregated_field_wells(
            mut self,
            input: std::option::Option<crate::model::ComboChartAggregatedFieldWells>,
        ) -> Self {
            self.combo_chart_aggregated_field_wells = input;
            self
        }
        /// Consumes the builder and constructs a [`ComboChartFieldWells`](crate::model::ComboChartFieldWells).
        pub fn build(self) -> crate::model::ComboChartFieldWells {
            crate::model::ComboChartFieldWells {
                combo_chart_aggregated_field_wells: self.combo_chart_aggregated_field_wells,
            }
        }
    }
}
impl ComboChartFieldWells {
    /// Creates a new builder-style object to manufacture [`ComboChartFieldWells`](crate::model::ComboChartFieldWells).
    pub fn builder() -> crate::model::combo_chart_field_wells::Builder {
        crate::model::combo_chart_field_wells::Builder::default()
    }
}

/// <p>The aggregated field wells of a combo chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComboChartAggregatedFieldWells {
    /// <p>The aggregated category field wells of a combo chart.</p>
    #[doc(hidden)]
    pub category: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The aggregated <code>BarValues</code> field well of a combo chart.</p>
    #[doc(hidden)]
    pub bar_values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    /// <p>The aggregated colors field well of a combo chart.</p>
    #[doc(hidden)]
    pub colors: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The aggregated <code>LineValues</code> field well of a combo chart.</p>
    #[doc(hidden)]
    pub line_values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
}
impl ComboChartAggregatedFieldWells {
    /// <p>The aggregated category field wells of a combo chart.</p>
    pub fn category(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.category.as_deref()
    }
    /// <p>The aggregated <code>BarValues</code> field well of a combo chart.</p>
    pub fn bar_values(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.bar_values.as_deref()
    }
    /// <p>The aggregated colors field well of a combo chart.</p>
    pub fn colors(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.colors.as_deref()
    }
    /// <p>The aggregated <code>LineValues</code> field well of a combo chart.</p>
    pub fn line_values(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.line_values.as_deref()
    }
}
/// See [`ComboChartAggregatedFieldWells`](crate::model::ComboChartAggregatedFieldWells).
pub mod combo_chart_aggregated_field_wells {

    /// A builder for [`ComboChartAggregatedFieldWells`](crate::model::ComboChartAggregatedFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) bar_values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        pub(crate) colors: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) line_values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    }
    impl Builder {
        /// Appends an item to `category`.
        ///
        /// To override the contents of this collection use [`set_category`](Self::set_category).
        ///
        /// <p>The aggregated category field wells of a combo chart.</p>
        pub fn category(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.category.unwrap_or_default();
            v.push(input);
            self.category = Some(v);
            self
        }
        /// <p>The aggregated category field wells of a combo chart.</p>
        pub fn set_category(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.category = input;
            self
        }
        /// Appends an item to `bar_values`.
        ///
        /// To override the contents of this collection use [`set_bar_values`](Self::set_bar_values).
        ///
        /// <p>The aggregated <code>BarValues</code> field well of a combo chart.</p>
        pub fn bar_values(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.bar_values.unwrap_or_default();
            v.push(input);
            self.bar_values = Some(v);
            self
        }
        /// <p>The aggregated <code>BarValues</code> field well of a combo chart.</p>
        pub fn set_bar_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.bar_values = input;
            self
        }
        /// Appends an item to `colors`.
        ///
        /// To override the contents of this collection use [`set_colors`](Self::set_colors).
        ///
        /// <p>The aggregated colors field well of a combo chart.</p>
        pub fn colors(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.colors.unwrap_or_default();
            v.push(input);
            self.colors = Some(v);
            self
        }
        /// <p>The aggregated colors field well of a combo chart.</p>
        pub fn set_colors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.colors = input;
            self
        }
        /// Appends an item to `line_values`.
        ///
        /// To override the contents of this collection use [`set_line_values`](Self::set_line_values).
        ///
        /// <p>The aggregated <code>LineValues</code> field well of a combo chart.</p>
        pub fn line_values(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.line_values.unwrap_or_default();
            v.push(input);
            self.line_values = Some(v);
            self
        }
        /// <p>The aggregated <code>LineValues</code> field well of a combo chart.</p>
        pub fn set_line_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.line_values = input;
            self
        }
        /// Consumes the builder and constructs a [`ComboChartAggregatedFieldWells`](crate::model::ComboChartAggregatedFieldWells).
        pub fn build(self) -> crate::model::ComboChartAggregatedFieldWells {
            crate::model::ComboChartAggregatedFieldWells {
                category: self.category,
                bar_values: self.bar_values,
                colors: self.colors,
                line_values: self.line_values,
            }
        }
    }
}
impl ComboChartAggregatedFieldWells {
    /// Creates a new builder-style object to manufacture [`ComboChartAggregatedFieldWells`](crate::model::ComboChartAggregatedFieldWells).
    pub fn builder() -> crate::model::combo_chart_aggregated_field_wells::Builder {
        crate::model::combo_chart_aggregated_field_wells::Builder::default()
    }
}

/// <p>A scatter plot.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/scatter-plot.html">Using scatter plots</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScatterPlotVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration settings of the visual.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::ScatterPlotConfiguration>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    #[doc(hidden)]
    pub column_hierarchies: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
}
impl ScatterPlotVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration settings of the visual.</p>
    pub fn chart_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ScatterPlotConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    pub fn column_hierarchies(&self) -> std::option::Option<&[crate::model::ColumnHierarchy]> {
        self.column_hierarchies.as_deref()
    }
}
/// See [`ScatterPlotVisual`](crate::model::ScatterPlotVisual).
pub mod scatter_plot_visual {

    /// A builder for [`ScatterPlotVisual`](crate::model::ScatterPlotVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration: std::option::Option<crate::model::ScatterPlotConfiguration>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        pub(crate) column_hierarchies:
            std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn chart_configuration(
            mut self,
            input: crate::model::ScatterPlotConfiguration,
        ) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::ScatterPlotConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Appends an item to `column_hierarchies`.
        ///
        /// To override the contents of this collection use [`set_column_hierarchies`](Self::set_column_hierarchies).
        ///
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn column_hierarchies(mut self, input: crate::model::ColumnHierarchy) -> Self {
            let mut v = self.column_hierarchies.unwrap_or_default();
            v.push(input);
            self.column_hierarchies = Some(v);
            self
        }
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn set_column_hierarchies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
        ) -> Self {
            self.column_hierarchies = input;
            self
        }
        /// Consumes the builder and constructs a [`ScatterPlotVisual`](crate::model::ScatterPlotVisual).
        pub fn build(self) -> crate::model::ScatterPlotVisual {
            crate::model::ScatterPlotVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                actions: self.actions,
                column_hierarchies: self.column_hierarchies,
            }
        }
    }
}
impl ScatterPlotVisual {
    /// Creates a new builder-style object to manufacture [`ScatterPlotVisual`](crate::model::ScatterPlotVisual).
    pub fn builder() -> crate::model::scatter_plot_visual::Builder {
        crate::model::scatter_plot_visual::Builder::default()
    }
}

/// <p>The configuration of a scatter plot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScatterPlotConfiguration {
    /// <p>The field wells of the visual.</p>
    #[doc(hidden)]
    pub field_wells: std::option::Option<crate::model::ScatterPlotFieldWells>,
    /// <p>The label options (label text, label visibility, and sort icon visibility) of the scatter plot's x-axis.</p>
    #[doc(hidden)]
    pub x_axis_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The label display options (grid line, range, scale, and axis step) of the scatter plot's x-axis.</p>
    #[doc(hidden)]
    pub x_axis_display_options: std::option::Option<crate::model::AxisDisplayOptions>,
    /// <p>The label options (label text, label visibility, and sort icon visibility) of the scatter plot's y-axis.</p>
    #[doc(hidden)]
    pub y_axis_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The label display options (grid line, range, scale, and axis step) of the scatter plot's y-axis.</p>
    #[doc(hidden)]
    pub y_axis_display_options: std::option::Option<crate::model::AxisDisplayOptions>,
    /// <p>The legend display setup of the visual.</p>
    #[doc(hidden)]
    pub legend: std::option::Option<crate::model::LegendOptions>,
    /// <p>The options that determine if visual data labels are displayed.</p>
    #[doc(hidden)]
    pub data_labels: std::option::Option<crate::model::DataLabelOptions>,
    /// <p>The legend display setup of the visual.</p>
    #[doc(hidden)]
    pub tooltip: std::option::Option<crate::model::TooltipOptions>,
    /// <p>The palette (chart color) display setup of the visual.</p>
    #[doc(hidden)]
    pub visual_palette: std::option::Option<crate::model::VisualPalette>,
}
impl ScatterPlotConfiguration {
    /// <p>The field wells of the visual.</p>
    pub fn field_wells(&self) -> std::option::Option<&crate::model::ScatterPlotFieldWells> {
        self.field_wells.as_ref()
    }
    /// <p>The label options (label text, label visibility, and sort icon visibility) of the scatter plot's x-axis.</p>
    pub fn x_axis_label_options(
        &self,
    ) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.x_axis_label_options.as_ref()
    }
    /// <p>The label display options (grid line, range, scale, and axis step) of the scatter plot's x-axis.</p>
    pub fn x_axis_display_options(&self) -> std::option::Option<&crate::model::AxisDisplayOptions> {
        self.x_axis_display_options.as_ref()
    }
    /// <p>The label options (label text, label visibility, and sort icon visibility) of the scatter plot's y-axis.</p>
    pub fn y_axis_label_options(
        &self,
    ) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.y_axis_label_options.as_ref()
    }
    /// <p>The label display options (grid line, range, scale, and axis step) of the scatter plot's y-axis.</p>
    pub fn y_axis_display_options(&self) -> std::option::Option<&crate::model::AxisDisplayOptions> {
        self.y_axis_display_options.as_ref()
    }
    /// <p>The legend display setup of the visual.</p>
    pub fn legend(&self) -> std::option::Option<&crate::model::LegendOptions> {
        self.legend.as_ref()
    }
    /// <p>The options that determine if visual data labels are displayed.</p>
    pub fn data_labels(&self) -> std::option::Option<&crate::model::DataLabelOptions> {
        self.data_labels.as_ref()
    }
    /// <p>The legend display setup of the visual.</p>
    pub fn tooltip(&self) -> std::option::Option<&crate::model::TooltipOptions> {
        self.tooltip.as_ref()
    }
    /// <p>The palette (chart color) display setup of the visual.</p>
    pub fn visual_palette(&self) -> std::option::Option<&crate::model::VisualPalette> {
        self.visual_palette.as_ref()
    }
}
/// See [`ScatterPlotConfiguration`](crate::model::ScatterPlotConfiguration).
pub mod scatter_plot_configuration {

    /// A builder for [`ScatterPlotConfiguration`](crate::model::ScatterPlotConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_wells: std::option::Option<crate::model::ScatterPlotFieldWells>,
        pub(crate) x_axis_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) x_axis_display_options: std::option::Option<crate::model::AxisDisplayOptions>,
        pub(crate) y_axis_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) y_axis_display_options: std::option::Option<crate::model::AxisDisplayOptions>,
        pub(crate) legend: std::option::Option<crate::model::LegendOptions>,
        pub(crate) data_labels: std::option::Option<crate::model::DataLabelOptions>,
        pub(crate) tooltip: std::option::Option<crate::model::TooltipOptions>,
        pub(crate) visual_palette: std::option::Option<crate::model::VisualPalette>,
    }
    impl Builder {
        /// <p>The field wells of the visual.</p>
        pub fn field_wells(mut self, input: crate::model::ScatterPlotFieldWells) -> Self {
            self.field_wells = Some(input);
            self
        }
        /// <p>The field wells of the visual.</p>
        pub fn set_field_wells(
            mut self,
            input: std::option::Option<crate::model::ScatterPlotFieldWells>,
        ) -> Self {
            self.field_wells = input;
            self
        }
        /// <p>The label options (label text, label visibility, and sort icon visibility) of the scatter plot's x-axis.</p>
        pub fn x_axis_label_options(mut self, input: crate::model::ChartAxisLabelOptions) -> Self {
            self.x_axis_label_options = Some(input);
            self
        }
        /// <p>The label options (label text, label visibility, and sort icon visibility) of the scatter plot's x-axis.</p>
        pub fn set_x_axis_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.x_axis_label_options = input;
            self
        }
        /// <p>The label display options (grid line, range, scale, and axis step) of the scatter plot's x-axis.</p>
        pub fn x_axis_display_options(mut self, input: crate::model::AxisDisplayOptions) -> Self {
            self.x_axis_display_options = Some(input);
            self
        }
        /// <p>The label display options (grid line, range, scale, and axis step) of the scatter plot's x-axis.</p>
        pub fn set_x_axis_display_options(
            mut self,
            input: std::option::Option<crate::model::AxisDisplayOptions>,
        ) -> Self {
            self.x_axis_display_options = input;
            self
        }
        /// <p>The label options (label text, label visibility, and sort icon visibility) of the scatter plot's y-axis.</p>
        pub fn y_axis_label_options(mut self, input: crate::model::ChartAxisLabelOptions) -> Self {
            self.y_axis_label_options = Some(input);
            self
        }
        /// <p>The label options (label text, label visibility, and sort icon visibility) of the scatter plot's y-axis.</p>
        pub fn set_y_axis_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.y_axis_label_options = input;
            self
        }
        /// <p>The label display options (grid line, range, scale, and axis step) of the scatter plot's y-axis.</p>
        pub fn y_axis_display_options(mut self, input: crate::model::AxisDisplayOptions) -> Self {
            self.y_axis_display_options = Some(input);
            self
        }
        /// <p>The label display options (grid line, range, scale, and axis step) of the scatter plot's y-axis.</p>
        pub fn set_y_axis_display_options(
            mut self,
            input: std::option::Option<crate::model::AxisDisplayOptions>,
        ) -> Self {
            self.y_axis_display_options = input;
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn legend(mut self, input: crate::model::LegendOptions) -> Self {
            self.legend = Some(input);
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn set_legend(
            mut self,
            input: std::option::Option<crate::model::LegendOptions>,
        ) -> Self {
            self.legend = input;
            self
        }
        /// <p>The options that determine if visual data labels are displayed.</p>
        pub fn data_labels(mut self, input: crate::model::DataLabelOptions) -> Self {
            self.data_labels = Some(input);
            self
        }
        /// <p>The options that determine if visual data labels are displayed.</p>
        pub fn set_data_labels(
            mut self,
            input: std::option::Option<crate::model::DataLabelOptions>,
        ) -> Self {
            self.data_labels = input;
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn tooltip(mut self, input: crate::model::TooltipOptions) -> Self {
            self.tooltip = Some(input);
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn set_tooltip(
            mut self,
            input: std::option::Option<crate::model::TooltipOptions>,
        ) -> Self {
            self.tooltip = input;
            self
        }
        /// <p>The palette (chart color) display setup of the visual.</p>
        pub fn visual_palette(mut self, input: crate::model::VisualPalette) -> Self {
            self.visual_palette = Some(input);
            self
        }
        /// <p>The palette (chart color) display setup of the visual.</p>
        pub fn set_visual_palette(
            mut self,
            input: std::option::Option<crate::model::VisualPalette>,
        ) -> Self {
            self.visual_palette = input;
            self
        }
        /// Consumes the builder and constructs a [`ScatterPlotConfiguration`](crate::model::ScatterPlotConfiguration).
        pub fn build(self) -> crate::model::ScatterPlotConfiguration {
            crate::model::ScatterPlotConfiguration {
                field_wells: self.field_wells,
                x_axis_label_options: self.x_axis_label_options,
                x_axis_display_options: self.x_axis_display_options,
                y_axis_label_options: self.y_axis_label_options,
                y_axis_display_options: self.y_axis_display_options,
                legend: self.legend,
                data_labels: self.data_labels,
                tooltip: self.tooltip,
                visual_palette: self.visual_palette,
            }
        }
    }
}
impl ScatterPlotConfiguration {
    /// Creates a new builder-style object to manufacture [`ScatterPlotConfiguration`](crate::model::ScatterPlotConfiguration).
    pub fn builder() -> crate::model::scatter_plot_configuration::Builder {
        crate::model::scatter_plot_configuration::Builder::default()
    }
}

/// <p>The field well configuration of a scatter plot.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScatterPlotFieldWells {
    /// <p>The aggregated field wells of a scatter plot. Scatter plots that have a field in the category (group/color) field will have aggregated field wells. The x and y-axes of these scatter plots are aggregated by category.</p>
    #[doc(hidden)]
    pub scatter_plot_categorically_aggregated_field_wells:
        std::option::Option<crate::model::ScatterPlotCategoricallyAggregatedFieldWells>,
    /// <p>The unaggregated field wells of a scatter plot. Scatter plots without a category field well have unaggregated field wells. The x and y-axes of these scatter plots are unaggregated.</p>
    #[doc(hidden)]
    pub scatter_plot_unaggregated_field_wells:
        std::option::Option<crate::model::ScatterPlotUnaggregatedFieldWells>,
}
impl ScatterPlotFieldWells {
    /// <p>The aggregated field wells of a scatter plot. Scatter plots that have a field in the category (group/color) field will have aggregated field wells. The x and y-axes of these scatter plots are aggregated by category.</p>
    pub fn scatter_plot_categorically_aggregated_field_wells(
        &self,
    ) -> std::option::Option<&crate::model::ScatterPlotCategoricallyAggregatedFieldWells> {
        self.scatter_plot_categorically_aggregated_field_wells
            .as_ref()
    }
    /// <p>The unaggregated field wells of a scatter plot. Scatter plots without a category field well have unaggregated field wells. The x and y-axes of these scatter plots are unaggregated.</p>
    pub fn scatter_plot_unaggregated_field_wells(
        &self,
    ) -> std::option::Option<&crate::model::ScatterPlotUnaggregatedFieldWells> {
        self.scatter_plot_unaggregated_field_wells.as_ref()
    }
}
/// See [`ScatterPlotFieldWells`](crate::model::ScatterPlotFieldWells).
pub mod scatter_plot_field_wells {

    /// A builder for [`ScatterPlotFieldWells`](crate::model::ScatterPlotFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scatter_plot_categorically_aggregated_field_wells:
            std::option::Option<crate::model::ScatterPlotCategoricallyAggregatedFieldWells>,
        pub(crate) scatter_plot_unaggregated_field_wells:
            std::option::Option<crate::model::ScatterPlotUnaggregatedFieldWells>,
    }
    impl Builder {
        /// <p>The aggregated field wells of a scatter plot. Scatter plots that have a field in the category (group/color) field will have aggregated field wells. The x and y-axes of these scatter plots are aggregated by category.</p>
        pub fn scatter_plot_categorically_aggregated_field_wells(
            mut self,
            input: crate::model::ScatterPlotCategoricallyAggregatedFieldWells,
        ) -> Self {
            self.scatter_plot_categorically_aggregated_field_wells = Some(input);
            self
        }
        /// <p>The aggregated field wells of a scatter plot. Scatter plots that have a field in the category (group/color) field will have aggregated field wells. The x and y-axes of these scatter plots are aggregated by category.</p>
        pub fn set_scatter_plot_categorically_aggregated_field_wells(
            mut self,
            input: std::option::Option<crate::model::ScatterPlotCategoricallyAggregatedFieldWells>,
        ) -> Self {
            self.scatter_plot_categorically_aggregated_field_wells = input;
            self
        }
        /// <p>The unaggregated field wells of a scatter plot. Scatter plots without a category field well have unaggregated field wells. The x and y-axes of these scatter plots are unaggregated.</p>
        pub fn scatter_plot_unaggregated_field_wells(
            mut self,
            input: crate::model::ScatterPlotUnaggregatedFieldWells,
        ) -> Self {
            self.scatter_plot_unaggregated_field_wells = Some(input);
            self
        }
        /// <p>The unaggregated field wells of a scatter plot. Scatter plots without a category field well have unaggregated field wells. The x and y-axes of these scatter plots are unaggregated.</p>
        pub fn set_scatter_plot_unaggregated_field_wells(
            mut self,
            input: std::option::Option<crate::model::ScatterPlotUnaggregatedFieldWells>,
        ) -> Self {
            self.scatter_plot_unaggregated_field_wells = input;
            self
        }
        /// Consumes the builder and constructs a [`ScatterPlotFieldWells`](crate::model::ScatterPlotFieldWells).
        pub fn build(self) -> crate::model::ScatterPlotFieldWells {
            crate::model::ScatterPlotFieldWells {
                scatter_plot_categorically_aggregated_field_wells: self
                    .scatter_plot_categorically_aggregated_field_wells,
                scatter_plot_unaggregated_field_wells: self.scatter_plot_unaggregated_field_wells,
            }
        }
    }
}
impl ScatterPlotFieldWells {
    /// Creates a new builder-style object to manufacture [`ScatterPlotFieldWells`](crate::model::ScatterPlotFieldWells).
    pub fn builder() -> crate::model::scatter_plot_field_wells::Builder {
        crate::model::scatter_plot_field_wells::Builder::default()
    }
}

/// <p>The unaggregated field wells of a scatter plot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScatterPlotUnaggregatedFieldWells {
    /// <p>The x-axis field well of a scatter plot.</p>
    /// <p>The x-axis is a dimension field and cannot be aggregated.</p>
    #[doc(hidden)]
    pub x_axis: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The y-axis field well of a scatter plot.</p>
    /// <p>The y-axis is a dimension field and cannot be aggregated.</p>
    #[doc(hidden)]
    pub y_axis: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The size field well of a scatter plot.</p>
    #[doc(hidden)]
    pub size: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
}
impl ScatterPlotUnaggregatedFieldWells {
    /// <p>The x-axis field well of a scatter plot.</p>
    /// <p>The x-axis is a dimension field and cannot be aggregated.</p>
    pub fn x_axis(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.x_axis.as_deref()
    }
    /// <p>The y-axis field well of a scatter plot.</p>
    /// <p>The y-axis is a dimension field and cannot be aggregated.</p>
    pub fn y_axis(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.y_axis.as_deref()
    }
    /// <p>The size field well of a scatter plot.</p>
    pub fn size(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.size.as_deref()
    }
}
/// See [`ScatterPlotUnaggregatedFieldWells`](crate::model::ScatterPlotUnaggregatedFieldWells).
pub mod scatter_plot_unaggregated_field_wells {

    /// A builder for [`ScatterPlotUnaggregatedFieldWells`](crate::model::ScatterPlotUnaggregatedFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) x_axis: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) y_axis: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) size: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    }
    impl Builder {
        /// Appends an item to `x_axis`.
        ///
        /// To override the contents of this collection use [`set_x_axis`](Self::set_x_axis).
        ///
        /// <p>The x-axis field well of a scatter plot.</p>
        /// <p>The x-axis is a dimension field and cannot be aggregated.</p>
        pub fn x_axis(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.x_axis.unwrap_or_default();
            v.push(input);
            self.x_axis = Some(v);
            self
        }
        /// <p>The x-axis field well of a scatter plot.</p>
        /// <p>The x-axis is a dimension field and cannot be aggregated.</p>
        pub fn set_x_axis(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.x_axis = input;
            self
        }
        /// Appends an item to `y_axis`.
        ///
        /// To override the contents of this collection use [`set_y_axis`](Self::set_y_axis).
        ///
        /// <p>The y-axis field well of a scatter plot.</p>
        /// <p>The y-axis is a dimension field and cannot be aggregated.</p>
        pub fn y_axis(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.y_axis.unwrap_or_default();
            v.push(input);
            self.y_axis = Some(v);
            self
        }
        /// <p>The y-axis field well of a scatter plot.</p>
        /// <p>The y-axis is a dimension field and cannot be aggregated.</p>
        pub fn set_y_axis(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.y_axis = input;
            self
        }
        /// Appends an item to `size`.
        ///
        /// To override the contents of this collection use [`set_size`](Self::set_size).
        ///
        /// <p>The size field well of a scatter plot.</p>
        pub fn size(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.size.unwrap_or_default();
            v.push(input);
            self.size = Some(v);
            self
        }
        /// <p>The size field well of a scatter plot.</p>
        pub fn set_size(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.size = input;
            self
        }
        /// Consumes the builder and constructs a [`ScatterPlotUnaggregatedFieldWells`](crate::model::ScatterPlotUnaggregatedFieldWells).
        pub fn build(self) -> crate::model::ScatterPlotUnaggregatedFieldWells {
            crate::model::ScatterPlotUnaggregatedFieldWells {
                x_axis: self.x_axis,
                y_axis: self.y_axis,
                size: self.size,
            }
        }
    }
}
impl ScatterPlotUnaggregatedFieldWells {
    /// Creates a new builder-style object to manufacture [`ScatterPlotUnaggregatedFieldWells`](crate::model::ScatterPlotUnaggregatedFieldWells).
    pub fn builder() -> crate::model::scatter_plot_unaggregated_field_wells::Builder {
        crate::model::scatter_plot_unaggregated_field_wells::Builder::default()
    }
}

/// <p>The aggregated field well of a scatter plot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScatterPlotCategoricallyAggregatedFieldWells {
    /// <p>The x-axis field well of a scatter plot.</p>
    /// <p>The x-axis is aggregated by category.</p>
    #[doc(hidden)]
    pub x_axis: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    /// <p>The y-axis field well of a scatter plot.</p>
    /// <p>The y-axis is aggregated by category.</p>
    #[doc(hidden)]
    pub y_axis: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    /// <p>The category field well of a scatter plot.</p>
    #[doc(hidden)]
    pub category: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The size field well of a scatter plot.</p>
    #[doc(hidden)]
    pub size: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
}
impl ScatterPlotCategoricallyAggregatedFieldWells {
    /// <p>The x-axis field well of a scatter plot.</p>
    /// <p>The x-axis is aggregated by category.</p>
    pub fn x_axis(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.x_axis.as_deref()
    }
    /// <p>The y-axis field well of a scatter plot.</p>
    /// <p>The y-axis is aggregated by category.</p>
    pub fn y_axis(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.y_axis.as_deref()
    }
    /// <p>The category field well of a scatter plot.</p>
    pub fn category(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.category.as_deref()
    }
    /// <p>The size field well of a scatter plot.</p>
    pub fn size(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.size.as_deref()
    }
}
/// See [`ScatterPlotCategoricallyAggregatedFieldWells`](crate::model::ScatterPlotCategoricallyAggregatedFieldWells).
pub mod scatter_plot_categorically_aggregated_field_wells {

    /// A builder for [`ScatterPlotCategoricallyAggregatedFieldWells`](crate::model::ScatterPlotCategoricallyAggregatedFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) x_axis: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        pub(crate) y_axis: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        pub(crate) category: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) size: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    }
    impl Builder {
        /// Appends an item to `x_axis`.
        ///
        /// To override the contents of this collection use [`set_x_axis`](Self::set_x_axis).
        ///
        /// <p>The x-axis field well of a scatter plot.</p>
        /// <p>The x-axis is aggregated by category.</p>
        pub fn x_axis(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.x_axis.unwrap_or_default();
            v.push(input);
            self.x_axis = Some(v);
            self
        }
        /// <p>The x-axis field well of a scatter plot.</p>
        /// <p>The x-axis is aggregated by category.</p>
        pub fn set_x_axis(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.x_axis = input;
            self
        }
        /// Appends an item to `y_axis`.
        ///
        /// To override the contents of this collection use [`set_y_axis`](Self::set_y_axis).
        ///
        /// <p>The y-axis field well of a scatter plot.</p>
        /// <p>The y-axis is aggregated by category.</p>
        pub fn y_axis(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.y_axis.unwrap_or_default();
            v.push(input);
            self.y_axis = Some(v);
            self
        }
        /// <p>The y-axis field well of a scatter plot.</p>
        /// <p>The y-axis is aggregated by category.</p>
        pub fn set_y_axis(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.y_axis = input;
            self
        }
        /// Appends an item to `category`.
        ///
        /// To override the contents of this collection use [`set_category`](Self::set_category).
        ///
        /// <p>The category field well of a scatter plot.</p>
        pub fn category(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.category.unwrap_or_default();
            v.push(input);
            self.category = Some(v);
            self
        }
        /// <p>The category field well of a scatter plot.</p>
        pub fn set_category(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.category = input;
            self
        }
        /// Appends an item to `size`.
        ///
        /// To override the contents of this collection use [`set_size`](Self::set_size).
        ///
        /// <p>The size field well of a scatter plot.</p>
        pub fn size(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.size.unwrap_or_default();
            v.push(input);
            self.size = Some(v);
            self
        }
        /// <p>The size field well of a scatter plot.</p>
        pub fn set_size(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.size = input;
            self
        }
        /// Consumes the builder and constructs a [`ScatterPlotCategoricallyAggregatedFieldWells`](crate::model::ScatterPlotCategoricallyAggregatedFieldWells).
        pub fn build(self) -> crate::model::ScatterPlotCategoricallyAggregatedFieldWells {
            crate::model::ScatterPlotCategoricallyAggregatedFieldWells {
                x_axis: self.x_axis,
                y_axis: self.y_axis,
                category: self.category,
                size: self.size,
            }
        }
    }
}
impl ScatterPlotCategoricallyAggregatedFieldWells {
    /// Creates a new builder-style object to manufacture [`ScatterPlotCategoricallyAggregatedFieldWells`](crate::model::ScatterPlotCategoricallyAggregatedFieldWells).
    pub fn builder() -> crate::model::scatter_plot_categorically_aggregated_field_wells::Builder {
        crate::model::scatter_plot_categorically_aggregated_field_wells::Builder::default()
    }
}

/// <p>A funnel chart.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/funnel-visual-content.html">Using funnel charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FunnelChartVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration of a <code>FunnelChartVisual</code>.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::FunnelChartConfiguration>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    #[doc(hidden)]
    pub column_hierarchies: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
}
impl FunnelChartVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration of a <code>FunnelChartVisual</code>.</p>
    pub fn chart_configuration(
        &self,
    ) -> std::option::Option<&crate::model::FunnelChartConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    pub fn column_hierarchies(&self) -> std::option::Option<&[crate::model::ColumnHierarchy]> {
        self.column_hierarchies.as_deref()
    }
}
/// See [`FunnelChartVisual`](crate::model::FunnelChartVisual).
pub mod funnel_chart_visual {

    /// A builder for [`FunnelChartVisual`](crate::model::FunnelChartVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration: std::option::Option<crate::model::FunnelChartConfiguration>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        pub(crate) column_hierarchies:
            std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration of a <code>FunnelChartVisual</code>.</p>
        pub fn chart_configuration(
            mut self,
            input: crate::model::FunnelChartConfiguration,
        ) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration of a <code>FunnelChartVisual</code>.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::FunnelChartConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Appends an item to `column_hierarchies`.
        ///
        /// To override the contents of this collection use [`set_column_hierarchies`](Self::set_column_hierarchies).
        ///
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn column_hierarchies(mut self, input: crate::model::ColumnHierarchy) -> Self {
            let mut v = self.column_hierarchies.unwrap_or_default();
            v.push(input);
            self.column_hierarchies = Some(v);
            self
        }
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn set_column_hierarchies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
        ) -> Self {
            self.column_hierarchies = input;
            self
        }
        /// Consumes the builder and constructs a [`FunnelChartVisual`](crate::model::FunnelChartVisual).
        pub fn build(self) -> crate::model::FunnelChartVisual {
            crate::model::FunnelChartVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                actions: self.actions,
                column_hierarchies: self.column_hierarchies,
            }
        }
    }
}
impl FunnelChartVisual {
    /// Creates a new builder-style object to manufacture [`FunnelChartVisual`](crate::model::FunnelChartVisual).
    pub fn builder() -> crate::model::funnel_chart_visual::Builder {
        crate::model::funnel_chart_visual::Builder::default()
    }
}

/// <p>The configuration of a <code>FunnelChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FunnelChartConfiguration {
    /// <p>The field well configuration of a <code>FunnelChartVisual</code>.</p>
    #[doc(hidden)]
    pub field_wells: std::option::Option<crate::model::FunnelChartFieldWells>,
    /// <p>The sort configuration of a <code>FunnelChartVisual</code>.</p>
    #[doc(hidden)]
    pub sort_configuration: std::option::Option<crate::model::FunnelChartSortConfiguration>,
    /// <p>The label options of the categories that are displayed in a <code>FunnelChartVisual</code>.</p>
    #[doc(hidden)]
    pub category_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The label options for the values that are displayed in a <code>FunnelChartVisual</code>.</p>
    #[doc(hidden)]
    pub value_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The tooltip configuration of a <code>FunnelChartVisual</code>.</p>
    #[doc(hidden)]
    pub tooltip: std::option::Option<crate::model::TooltipOptions>,
    /// <p>The options that determine the presentation of the data labels.</p>
    #[doc(hidden)]
    pub data_label_options: std::option::Option<crate::model::FunnelChartDataLabelOptions>,
    /// <p>The visual palette configuration of a <code>FunnelChartVisual</code>.</p>
    #[doc(hidden)]
    pub visual_palette: std::option::Option<crate::model::VisualPalette>,
}
impl FunnelChartConfiguration {
    /// <p>The field well configuration of a <code>FunnelChartVisual</code>.</p>
    pub fn field_wells(&self) -> std::option::Option<&crate::model::FunnelChartFieldWells> {
        self.field_wells.as_ref()
    }
    /// <p>The sort configuration of a <code>FunnelChartVisual</code>.</p>
    pub fn sort_configuration(
        &self,
    ) -> std::option::Option<&crate::model::FunnelChartSortConfiguration> {
        self.sort_configuration.as_ref()
    }
    /// <p>The label options of the categories that are displayed in a <code>FunnelChartVisual</code>.</p>
    pub fn category_label_options(
        &self,
    ) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.category_label_options.as_ref()
    }
    /// <p>The label options for the values that are displayed in a <code>FunnelChartVisual</code>.</p>
    pub fn value_label_options(&self) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.value_label_options.as_ref()
    }
    /// <p>The tooltip configuration of a <code>FunnelChartVisual</code>.</p>
    pub fn tooltip(&self) -> std::option::Option<&crate::model::TooltipOptions> {
        self.tooltip.as_ref()
    }
    /// <p>The options that determine the presentation of the data labels.</p>
    pub fn data_label_options(
        &self,
    ) -> std::option::Option<&crate::model::FunnelChartDataLabelOptions> {
        self.data_label_options.as_ref()
    }
    /// <p>The visual palette configuration of a <code>FunnelChartVisual</code>.</p>
    pub fn visual_palette(&self) -> std::option::Option<&crate::model::VisualPalette> {
        self.visual_palette.as_ref()
    }
}
/// See [`FunnelChartConfiguration`](crate::model::FunnelChartConfiguration).
pub mod funnel_chart_configuration {

    /// A builder for [`FunnelChartConfiguration`](crate::model::FunnelChartConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_wells: std::option::Option<crate::model::FunnelChartFieldWells>,
        pub(crate) sort_configuration:
            std::option::Option<crate::model::FunnelChartSortConfiguration>,
        pub(crate) category_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) value_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) tooltip: std::option::Option<crate::model::TooltipOptions>,
        pub(crate) data_label_options:
            std::option::Option<crate::model::FunnelChartDataLabelOptions>,
        pub(crate) visual_palette: std::option::Option<crate::model::VisualPalette>,
    }
    impl Builder {
        /// <p>The field well configuration of a <code>FunnelChartVisual</code>.</p>
        pub fn field_wells(mut self, input: crate::model::FunnelChartFieldWells) -> Self {
            self.field_wells = Some(input);
            self
        }
        /// <p>The field well configuration of a <code>FunnelChartVisual</code>.</p>
        pub fn set_field_wells(
            mut self,
            input: std::option::Option<crate::model::FunnelChartFieldWells>,
        ) -> Self {
            self.field_wells = input;
            self
        }
        /// <p>The sort configuration of a <code>FunnelChartVisual</code>.</p>
        pub fn sort_configuration(
            mut self,
            input: crate::model::FunnelChartSortConfiguration,
        ) -> Self {
            self.sort_configuration = Some(input);
            self
        }
        /// <p>The sort configuration of a <code>FunnelChartVisual</code>.</p>
        pub fn set_sort_configuration(
            mut self,
            input: std::option::Option<crate::model::FunnelChartSortConfiguration>,
        ) -> Self {
            self.sort_configuration = input;
            self
        }
        /// <p>The label options of the categories that are displayed in a <code>FunnelChartVisual</code>.</p>
        pub fn category_label_options(
            mut self,
            input: crate::model::ChartAxisLabelOptions,
        ) -> Self {
            self.category_label_options = Some(input);
            self
        }
        /// <p>The label options of the categories that are displayed in a <code>FunnelChartVisual</code>.</p>
        pub fn set_category_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.category_label_options = input;
            self
        }
        /// <p>The label options for the values that are displayed in a <code>FunnelChartVisual</code>.</p>
        pub fn value_label_options(mut self, input: crate::model::ChartAxisLabelOptions) -> Self {
            self.value_label_options = Some(input);
            self
        }
        /// <p>The label options for the values that are displayed in a <code>FunnelChartVisual</code>.</p>
        pub fn set_value_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.value_label_options = input;
            self
        }
        /// <p>The tooltip configuration of a <code>FunnelChartVisual</code>.</p>
        pub fn tooltip(mut self, input: crate::model::TooltipOptions) -> Self {
            self.tooltip = Some(input);
            self
        }
        /// <p>The tooltip configuration of a <code>FunnelChartVisual</code>.</p>
        pub fn set_tooltip(
            mut self,
            input: std::option::Option<crate::model::TooltipOptions>,
        ) -> Self {
            self.tooltip = input;
            self
        }
        /// <p>The options that determine the presentation of the data labels.</p>
        pub fn data_label_options(
            mut self,
            input: crate::model::FunnelChartDataLabelOptions,
        ) -> Self {
            self.data_label_options = Some(input);
            self
        }
        /// <p>The options that determine the presentation of the data labels.</p>
        pub fn set_data_label_options(
            mut self,
            input: std::option::Option<crate::model::FunnelChartDataLabelOptions>,
        ) -> Self {
            self.data_label_options = input;
            self
        }
        /// <p>The visual palette configuration of a <code>FunnelChartVisual</code>.</p>
        pub fn visual_palette(mut self, input: crate::model::VisualPalette) -> Self {
            self.visual_palette = Some(input);
            self
        }
        /// <p>The visual palette configuration of a <code>FunnelChartVisual</code>.</p>
        pub fn set_visual_palette(
            mut self,
            input: std::option::Option<crate::model::VisualPalette>,
        ) -> Self {
            self.visual_palette = input;
            self
        }
        /// Consumes the builder and constructs a [`FunnelChartConfiguration`](crate::model::FunnelChartConfiguration).
        pub fn build(self) -> crate::model::FunnelChartConfiguration {
            crate::model::FunnelChartConfiguration {
                field_wells: self.field_wells,
                sort_configuration: self.sort_configuration,
                category_label_options: self.category_label_options,
                value_label_options: self.value_label_options,
                tooltip: self.tooltip,
                data_label_options: self.data_label_options,
                visual_palette: self.visual_palette,
            }
        }
    }
}
impl FunnelChartConfiguration {
    /// Creates a new builder-style object to manufacture [`FunnelChartConfiguration`](crate::model::FunnelChartConfiguration).
    pub fn builder() -> crate::model::funnel_chart_configuration::Builder {
        crate::model::funnel_chart_configuration::Builder::default()
    }
}

/// <p>The options that determine the presentation of the data labels.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FunnelChartDataLabelOptions {
    /// <p>The visibility option that determines if data labels are displayed.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The visibility of the category labels within the data labels.</p>
    #[doc(hidden)]
    pub category_label_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The visibility of the measure labels within the data labels.</p>
    #[doc(hidden)]
    pub measure_label_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>Determines the positioning of the data label relative to a section of the funnel.</p>
    #[doc(hidden)]
    pub position: std::option::Option<crate::model::DataLabelPosition>,
    /// <p>The font configuration for the data labels.</p>
    /// <p>Only the <code>FontSize</code> attribute of the font configuration is used for data labels.</p>
    #[doc(hidden)]
    pub label_font_configuration: std::option::Option<crate::model::FontConfiguration>,
    /// <p>The color of the data label text.</p>
    #[doc(hidden)]
    pub label_color: std::option::Option<std::string::String>,
    /// <p>Determines the style of the metric labels.</p>
    #[doc(hidden)]
    pub measure_data_label_style:
        std::option::Option<crate::model::FunnelChartMeasureDataLabelStyle>,
}
impl FunnelChartDataLabelOptions {
    /// <p>The visibility option that determines if data labels are displayed.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
    /// <p>The visibility of the category labels within the data labels.</p>
    pub fn category_label_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.category_label_visibility.as_ref()
    }
    /// <p>The visibility of the measure labels within the data labels.</p>
    pub fn measure_label_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.measure_label_visibility.as_ref()
    }
    /// <p>Determines the positioning of the data label relative to a section of the funnel.</p>
    pub fn position(&self) -> std::option::Option<&crate::model::DataLabelPosition> {
        self.position.as_ref()
    }
    /// <p>The font configuration for the data labels.</p>
    /// <p>Only the <code>FontSize</code> attribute of the font configuration is used for data labels.</p>
    pub fn label_font_configuration(
        &self,
    ) -> std::option::Option<&crate::model::FontConfiguration> {
        self.label_font_configuration.as_ref()
    }
    /// <p>The color of the data label text.</p>
    pub fn label_color(&self) -> std::option::Option<&str> {
        self.label_color.as_deref()
    }
    /// <p>Determines the style of the metric labels.</p>
    pub fn measure_data_label_style(
        &self,
    ) -> std::option::Option<&crate::model::FunnelChartMeasureDataLabelStyle> {
        self.measure_data_label_style.as_ref()
    }
}
/// See [`FunnelChartDataLabelOptions`](crate::model::FunnelChartDataLabelOptions).
pub mod funnel_chart_data_label_options {

    /// A builder for [`FunnelChartDataLabelOptions`](crate::model::FunnelChartDataLabelOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) category_label_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) measure_label_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) position: std::option::Option<crate::model::DataLabelPosition>,
        pub(crate) label_font_configuration: std::option::Option<crate::model::FontConfiguration>,
        pub(crate) label_color: std::option::Option<std::string::String>,
        pub(crate) measure_data_label_style:
            std::option::Option<crate::model::FunnelChartMeasureDataLabelStyle>,
    }
    impl Builder {
        /// <p>The visibility option that determines if data labels are displayed.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility option that determines if data labels are displayed.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// <p>The visibility of the category labels within the data labels.</p>
        pub fn category_label_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.category_label_visibility = Some(input);
            self
        }
        /// <p>The visibility of the category labels within the data labels.</p>
        pub fn set_category_label_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.category_label_visibility = input;
            self
        }
        /// <p>The visibility of the measure labels within the data labels.</p>
        pub fn measure_label_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.measure_label_visibility = Some(input);
            self
        }
        /// <p>The visibility of the measure labels within the data labels.</p>
        pub fn set_measure_label_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.measure_label_visibility = input;
            self
        }
        /// <p>Determines the positioning of the data label relative to a section of the funnel.</p>
        pub fn position(mut self, input: crate::model::DataLabelPosition) -> Self {
            self.position = Some(input);
            self
        }
        /// <p>Determines the positioning of the data label relative to a section of the funnel.</p>
        pub fn set_position(
            mut self,
            input: std::option::Option<crate::model::DataLabelPosition>,
        ) -> Self {
            self.position = input;
            self
        }
        /// <p>The font configuration for the data labels.</p>
        /// <p>Only the <code>FontSize</code> attribute of the font configuration is used for data labels.</p>
        pub fn label_font_configuration(mut self, input: crate::model::FontConfiguration) -> Self {
            self.label_font_configuration = Some(input);
            self
        }
        /// <p>The font configuration for the data labels.</p>
        /// <p>Only the <code>FontSize</code> attribute of the font configuration is used for data labels.</p>
        pub fn set_label_font_configuration(
            mut self,
            input: std::option::Option<crate::model::FontConfiguration>,
        ) -> Self {
            self.label_font_configuration = input;
            self
        }
        /// <p>The color of the data label text.</p>
        pub fn label_color(mut self, input: impl Into<std::string::String>) -> Self {
            self.label_color = Some(input.into());
            self
        }
        /// <p>The color of the data label text.</p>
        pub fn set_label_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.label_color = input;
            self
        }
        /// <p>Determines the style of the metric labels.</p>
        pub fn measure_data_label_style(
            mut self,
            input: crate::model::FunnelChartMeasureDataLabelStyle,
        ) -> Self {
            self.measure_data_label_style = Some(input);
            self
        }
        /// <p>Determines the style of the metric labels.</p>
        pub fn set_measure_data_label_style(
            mut self,
            input: std::option::Option<crate::model::FunnelChartMeasureDataLabelStyle>,
        ) -> Self {
            self.measure_data_label_style = input;
            self
        }
        /// Consumes the builder and constructs a [`FunnelChartDataLabelOptions`](crate::model::FunnelChartDataLabelOptions).
        pub fn build(self) -> crate::model::FunnelChartDataLabelOptions {
            crate::model::FunnelChartDataLabelOptions {
                visibility: self.visibility,
                category_label_visibility: self.category_label_visibility,
                measure_label_visibility: self.measure_label_visibility,
                position: self.position,
                label_font_configuration: self.label_font_configuration,
                label_color: self.label_color,
                measure_data_label_style: self.measure_data_label_style,
            }
        }
    }
}
impl FunnelChartDataLabelOptions {
    /// Creates a new builder-style object to manufacture [`FunnelChartDataLabelOptions`](crate::model::FunnelChartDataLabelOptions).
    pub fn builder() -> crate::model::funnel_chart_data_label_options::Builder {
        crate::model::funnel_chart_data_label_options::Builder::default()
    }
}

/// When writing a match expression against `FunnelChartMeasureDataLabelStyle`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let funnelchartmeasuredatalabelstyle = unimplemented!();
/// match funnelchartmeasuredatalabelstyle {
///     FunnelChartMeasureDataLabelStyle::PercentageByFirstStage => { /* ... */ },
///     FunnelChartMeasureDataLabelStyle::PercentageByPreviousStage => { /* ... */ },
///     FunnelChartMeasureDataLabelStyle::ValueAndPercentageByFirstStage => { /* ... */ },
///     FunnelChartMeasureDataLabelStyle::ValueAndPercentageByPreviousStage => { /* ... */ },
///     FunnelChartMeasureDataLabelStyle::ValueOnly => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `funnelchartmeasuredatalabelstyle` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FunnelChartMeasureDataLabelStyle::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FunnelChartMeasureDataLabelStyle::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FunnelChartMeasureDataLabelStyle::NewFeature` is defined.
/// Specifically, when `funnelchartmeasuredatalabelstyle` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FunnelChartMeasureDataLabelStyle::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FunnelChartMeasureDataLabelStyle {
    #[allow(missing_docs)] // documentation missing in model
    PercentageByFirstStage,
    #[allow(missing_docs)] // documentation missing in model
    PercentageByPreviousStage,
    #[allow(missing_docs)] // documentation missing in model
    ValueAndPercentageByFirstStage,
    #[allow(missing_docs)] // documentation missing in model
    ValueAndPercentageByPreviousStage,
    #[allow(missing_docs)] // documentation missing in model
    ValueOnly,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FunnelChartMeasureDataLabelStyle {
    fn from(s: &str) -> Self {
        match s {
            "PERCENTAGE_BY_FIRST_STAGE" => FunnelChartMeasureDataLabelStyle::PercentageByFirstStage,
            "PERCENTAGE_BY_PREVIOUS_STAGE" => {
                FunnelChartMeasureDataLabelStyle::PercentageByPreviousStage
            }
            "VALUE_AND_PERCENTAGE_BY_FIRST_STAGE" => {
                FunnelChartMeasureDataLabelStyle::ValueAndPercentageByFirstStage
            }
            "VALUE_AND_PERCENTAGE_BY_PREVIOUS_STAGE" => {
                FunnelChartMeasureDataLabelStyle::ValueAndPercentageByPreviousStage
            }
            "VALUE_ONLY" => FunnelChartMeasureDataLabelStyle::ValueOnly,
            other => FunnelChartMeasureDataLabelStyle::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for FunnelChartMeasureDataLabelStyle {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FunnelChartMeasureDataLabelStyle::from(s))
    }
}
impl FunnelChartMeasureDataLabelStyle {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FunnelChartMeasureDataLabelStyle::PercentageByFirstStage => "PERCENTAGE_BY_FIRST_STAGE",
            FunnelChartMeasureDataLabelStyle::PercentageByPreviousStage => {
                "PERCENTAGE_BY_PREVIOUS_STAGE"
            }
            FunnelChartMeasureDataLabelStyle::ValueAndPercentageByFirstStage => {
                "VALUE_AND_PERCENTAGE_BY_FIRST_STAGE"
            }
            FunnelChartMeasureDataLabelStyle::ValueAndPercentageByPreviousStage => {
                "VALUE_AND_PERCENTAGE_BY_PREVIOUS_STAGE"
            }
            FunnelChartMeasureDataLabelStyle::ValueOnly => "VALUE_ONLY",
            FunnelChartMeasureDataLabelStyle::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "PERCENTAGE_BY_FIRST_STAGE",
            "PERCENTAGE_BY_PREVIOUS_STAGE",
            "VALUE_AND_PERCENTAGE_BY_FIRST_STAGE",
            "VALUE_AND_PERCENTAGE_BY_PREVIOUS_STAGE",
            "VALUE_ONLY",
        ]
    }
}
impl AsRef<str> for FunnelChartMeasureDataLabelStyle {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The sort configuration of a <code>FunnelChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FunnelChartSortConfiguration {
    /// <p>The sort configuration of the category fields.</p>
    #[doc(hidden)]
    pub category_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    /// <p>The limit on the number of categories displayed.</p>
    #[doc(hidden)]
    pub category_items_limit: std::option::Option<crate::model::ItemsLimitConfiguration>,
}
impl FunnelChartSortConfiguration {
    /// <p>The sort configuration of the category fields.</p>
    pub fn category_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.category_sort.as_deref()
    }
    /// <p>The limit on the number of categories displayed.</p>
    pub fn category_items_limit(
        &self,
    ) -> std::option::Option<&crate::model::ItemsLimitConfiguration> {
        self.category_items_limit.as_ref()
    }
}
/// See [`FunnelChartSortConfiguration`](crate::model::FunnelChartSortConfiguration).
pub mod funnel_chart_sort_configuration {

    /// A builder for [`FunnelChartSortConfiguration`](crate::model::FunnelChartSortConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category_sort:
            std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        pub(crate) category_items_limit: std::option::Option<crate::model::ItemsLimitConfiguration>,
    }
    impl Builder {
        /// Appends an item to `category_sort`.
        ///
        /// To override the contents of this collection use [`set_category_sort`](Self::set_category_sort).
        ///
        /// <p>The sort configuration of the category fields.</p>
        pub fn category_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.category_sort.unwrap_or_default();
            v.push(input);
            self.category_sort = Some(v);
            self
        }
        /// <p>The sort configuration of the category fields.</p>
        pub fn set_category_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.category_sort = input;
            self
        }
        /// <p>The limit on the number of categories displayed.</p>
        pub fn category_items_limit(
            mut self,
            input: crate::model::ItemsLimitConfiguration,
        ) -> Self {
            self.category_items_limit = Some(input);
            self
        }
        /// <p>The limit on the number of categories displayed.</p>
        pub fn set_category_items_limit(
            mut self,
            input: std::option::Option<crate::model::ItemsLimitConfiguration>,
        ) -> Self {
            self.category_items_limit = input;
            self
        }
        /// Consumes the builder and constructs a [`FunnelChartSortConfiguration`](crate::model::FunnelChartSortConfiguration).
        pub fn build(self) -> crate::model::FunnelChartSortConfiguration {
            crate::model::FunnelChartSortConfiguration {
                category_sort: self.category_sort,
                category_items_limit: self.category_items_limit,
            }
        }
    }
}
impl FunnelChartSortConfiguration {
    /// Creates a new builder-style object to manufacture [`FunnelChartSortConfiguration`](crate::model::FunnelChartSortConfiguration).
    pub fn builder() -> crate::model::funnel_chart_sort_configuration::Builder {
        crate::model::funnel_chart_sort_configuration::Builder::default()
    }
}

/// <p>The field well configuration of a <code>FunnelChartVisual</code>.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FunnelChartFieldWells {
    /// <p>The field well configuration of a <code>FunnelChartVisual</code>.</p>
    #[doc(hidden)]
    pub funnel_chart_aggregated_field_wells:
        std::option::Option<crate::model::FunnelChartAggregatedFieldWells>,
}
impl FunnelChartFieldWells {
    /// <p>The field well configuration of a <code>FunnelChartVisual</code>.</p>
    pub fn funnel_chart_aggregated_field_wells(
        &self,
    ) -> std::option::Option<&crate::model::FunnelChartAggregatedFieldWells> {
        self.funnel_chart_aggregated_field_wells.as_ref()
    }
}
/// See [`FunnelChartFieldWells`](crate::model::FunnelChartFieldWells).
pub mod funnel_chart_field_wells {

    /// A builder for [`FunnelChartFieldWells`](crate::model::FunnelChartFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) funnel_chart_aggregated_field_wells:
            std::option::Option<crate::model::FunnelChartAggregatedFieldWells>,
    }
    impl Builder {
        /// <p>The field well configuration of a <code>FunnelChartVisual</code>.</p>
        pub fn funnel_chart_aggregated_field_wells(
            mut self,
            input: crate::model::FunnelChartAggregatedFieldWells,
        ) -> Self {
            self.funnel_chart_aggregated_field_wells = Some(input);
            self
        }
        /// <p>The field well configuration of a <code>FunnelChartVisual</code>.</p>
        pub fn set_funnel_chart_aggregated_field_wells(
            mut self,
            input: std::option::Option<crate::model::FunnelChartAggregatedFieldWells>,
        ) -> Self {
            self.funnel_chart_aggregated_field_wells = input;
            self
        }
        /// Consumes the builder and constructs a [`FunnelChartFieldWells`](crate::model::FunnelChartFieldWells).
        pub fn build(self) -> crate::model::FunnelChartFieldWells {
            crate::model::FunnelChartFieldWells {
                funnel_chart_aggregated_field_wells: self.funnel_chart_aggregated_field_wells,
            }
        }
    }
}
impl FunnelChartFieldWells {
    /// Creates a new builder-style object to manufacture [`FunnelChartFieldWells`](crate::model::FunnelChartFieldWells).
    pub fn builder() -> crate::model::funnel_chart_field_wells::Builder {
        crate::model::funnel_chart_field_wells::Builder::default()
    }
}

/// <p>The field well configuration of a <code>FunnelChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FunnelChartAggregatedFieldWells {
    /// <p>The category field wells of a funnel chart. Values are grouped by category fields.</p>
    #[doc(hidden)]
    pub category: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The value field wells of a funnel chart. Values are aggregated based on categories.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
}
impl FunnelChartAggregatedFieldWells {
    /// <p>The category field wells of a funnel chart. Values are grouped by category fields.</p>
    pub fn category(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.category.as_deref()
    }
    /// <p>The value field wells of a funnel chart. Values are aggregated based on categories.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.values.as_deref()
    }
}
/// See [`FunnelChartAggregatedFieldWells`](crate::model::FunnelChartAggregatedFieldWells).
pub mod funnel_chart_aggregated_field_wells {

    /// A builder for [`FunnelChartAggregatedFieldWells`](crate::model::FunnelChartAggregatedFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    }
    impl Builder {
        /// Appends an item to `category`.
        ///
        /// To override the contents of this collection use [`set_category`](Self::set_category).
        ///
        /// <p>The category field wells of a funnel chart. Values are grouped by category fields.</p>
        pub fn category(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.category.unwrap_or_default();
            v.push(input);
            self.category = Some(v);
            self
        }
        /// <p>The category field wells of a funnel chart. Values are grouped by category fields.</p>
        pub fn set_category(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.category = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The value field wells of a funnel chart. Values are aggregated based on categories.</p>
        pub fn values(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>The value field wells of a funnel chart. Values are aggregated based on categories.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`FunnelChartAggregatedFieldWells`](crate::model::FunnelChartAggregatedFieldWells).
        pub fn build(self) -> crate::model::FunnelChartAggregatedFieldWells {
            crate::model::FunnelChartAggregatedFieldWells {
                category: self.category,
                values: self.values,
            }
        }
    }
}
impl FunnelChartAggregatedFieldWells {
    /// Creates a new builder-style object to manufacture [`FunnelChartAggregatedFieldWells`](crate::model::FunnelChartAggregatedFieldWells).
    pub fn builder() -> crate::model::funnel_chart_aggregated_field_wells::Builder {
        crate::model::funnel_chart_aggregated_field_wells::Builder::default()
    }
}

/// <p>A filled map.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/filled-maps.html">Creating filled maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilledMapVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration settings of the visual.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::FilledMapConfiguration>,
    /// <p>The conditional formatting of a <code>FilledMapVisual</code>.</p>
    #[doc(hidden)]
    pub conditional_formatting: std::option::Option<crate::model::FilledMapConditionalFormatting>,
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    #[doc(hidden)]
    pub column_hierarchies: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
}
impl FilledMapVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration settings of the visual.</p>
    pub fn chart_configuration(
        &self,
    ) -> std::option::Option<&crate::model::FilledMapConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The conditional formatting of a <code>FilledMapVisual</code>.</p>
    pub fn conditional_formatting(
        &self,
    ) -> std::option::Option<&crate::model::FilledMapConditionalFormatting> {
        self.conditional_formatting.as_ref()
    }
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    pub fn column_hierarchies(&self) -> std::option::Option<&[crate::model::ColumnHierarchy]> {
        self.column_hierarchies.as_deref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
}
/// See [`FilledMapVisual`](crate::model::FilledMapVisual).
pub mod filled_map_visual {

    /// A builder for [`FilledMapVisual`](crate::model::FilledMapVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration: std::option::Option<crate::model::FilledMapConfiguration>,
        pub(crate) conditional_formatting:
            std::option::Option<crate::model::FilledMapConditionalFormatting>,
        pub(crate) column_hierarchies:
            std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn chart_configuration(mut self, input: crate::model::FilledMapConfiguration) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::FilledMapConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// <p>The conditional formatting of a <code>FilledMapVisual</code>.</p>
        pub fn conditional_formatting(
            mut self,
            input: crate::model::FilledMapConditionalFormatting,
        ) -> Self {
            self.conditional_formatting = Some(input);
            self
        }
        /// <p>The conditional formatting of a <code>FilledMapVisual</code>.</p>
        pub fn set_conditional_formatting(
            mut self,
            input: std::option::Option<crate::model::FilledMapConditionalFormatting>,
        ) -> Self {
            self.conditional_formatting = input;
            self
        }
        /// Appends an item to `column_hierarchies`.
        ///
        /// To override the contents of this collection use [`set_column_hierarchies`](Self::set_column_hierarchies).
        ///
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn column_hierarchies(mut self, input: crate::model::ColumnHierarchy) -> Self {
            let mut v = self.column_hierarchies.unwrap_or_default();
            v.push(input);
            self.column_hierarchies = Some(v);
            self
        }
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn set_column_hierarchies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
        ) -> Self {
            self.column_hierarchies = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Consumes the builder and constructs a [`FilledMapVisual`](crate::model::FilledMapVisual).
        pub fn build(self) -> crate::model::FilledMapVisual {
            crate::model::FilledMapVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                conditional_formatting: self.conditional_formatting,
                column_hierarchies: self.column_hierarchies,
                actions: self.actions,
            }
        }
    }
}
impl FilledMapVisual {
    /// Creates a new builder-style object to manufacture [`FilledMapVisual`](crate::model::FilledMapVisual).
    pub fn builder() -> crate::model::filled_map_visual::Builder {
        crate::model::filled_map_visual::Builder::default()
    }
}

/// <p>The conditional formatting of a <code>FilledMapVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilledMapConditionalFormatting {
    /// <p>Conditional formatting options of a <code>FilledMapVisual</code>.</p>
    #[doc(hidden)]
    pub conditional_formatting_options:
        std::option::Option<std::vec::Vec<crate::model::FilledMapConditionalFormattingOption>>,
}
impl FilledMapConditionalFormatting {
    /// <p>Conditional formatting options of a <code>FilledMapVisual</code>.</p>
    pub fn conditional_formatting_options(
        &self,
    ) -> std::option::Option<&[crate::model::FilledMapConditionalFormattingOption]> {
        self.conditional_formatting_options.as_deref()
    }
}
/// See [`FilledMapConditionalFormatting`](crate::model::FilledMapConditionalFormatting).
pub mod filled_map_conditional_formatting {

    /// A builder for [`FilledMapConditionalFormatting`](crate::model::FilledMapConditionalFormatting).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) conditional_formatting_options:
            std::option::Option<std::vec::Vec<crate::model::FilledMapConditionalFormattingOption>>,
    }
    impl Builder {
        /// Appends an item to `conditional_formatting_options`.
        ///
        /// To override the contents of this collection use [`set_conditional_formatting_options`](Self::set_conditional_formatting_options).
        ///
        /// <p>Conditional formatting options of a <code>FilledMapVisual</code>.</p>
        pub fn conditional_formatting_options(
            mut self,
            input: crate::model::FilledMapConditionalFormattingOption,
        ) -> Self {
            let mut v = self.conditional_formatting_options.unwrap_or_default();
            v.push(input);
            self.conditional_formatting_options = Some(v);
            self
        }
        /// <p>Conditional formatting options of a <code>FilledMapVisual</code>.</p>
        pub fn set_conditional_formatting_options(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::FilledMapConditionalFormattingOption>,
            >,
        ) -> Self {
            self.conditional_formatting_options = input;
            self
        }
        /// Consumes the builder and constructs a [`FilledMapConditionalFormatting`](crate::model::FilledMapConditionalFormatting).
        pub fn build(self) -> crate::model::FilledMapConditionalFormatting {
            crate::model::FilledMapConditionalFormatting {
                conditional_formatting_options: self.conditional_formatting_options,
            }
        }
    }
}
impl FilledMapConditionalFormatting {
    /// Creates a new builder-style object to manufacture [`FilledMapConditionalFormatting`](crate::model::FilledMapConditionalFormatting).
    pub fn builder() -> crate::model::filled_map_conditional_formatting::Builder {
        crate::model::filled_map_conditional_formatting::Builder::default()
    }
}

/// <p>Conditional formatting options of a <code>FilledMapVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilledMapConditionalFormattingOption {
    /// <p>The conditional formatting that determines the shape of the filled map.</p>
    #[doc(hidden)]
    pub shape: std::option::Option<crate::model::FilledMapShapeConditionalFormatting>,
}
impl FilledMapConditionalFormattingOption {
    /// <p>The conditional formatting that determines the shape of the filled map.</p>
    pub fn shape(&self) -> std::option::Option<&crate::model::FilledMapShapeConditionalFormatting> {
        self.shape.as_ref()
    }
}
/// See [`FilledMapConditionalFormattingOption`](crate::model::FilledMapConditionalFormattingOption).
pub mod filled_map_conditional_formatting_option {

    /// A builder for [`FilledMapConditionalFormattingOption`](crate::model::FilledMapConditionalFormattingOption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) shape: std::option::Option<crate::model::FilledMapShapeConditionalFormatting>,
    }
    impl Builder {
        /// <p>The conditional formatting that determines the shape of the filled map.</p>
        pub fn shape(mut self, input: crate::model::FilledMapShapeConditionalFormatting) -> Self {
            self.shape = Some(input);
            self
        }
        /// <p>The conditional formatting that determines the shape of the filled map.</p>
        pub fn set_shape(
            mut self,
            input: std::option::Option<crate::model::FilledMapShapeConditionalFormatting>,
        ) -> Self {
            self.shape = input;
            self
        }
        /// Consumes the builder and constructs a [`FilledMapConditionalFormattingOption`](crate::model::FilledMapConditionalFormattingOption).
        pub fn build(self) -> crate::model::FilledMapConditionalFormattingOption {
            crate::model::FilledMapConditionalFormattingOption { shape: self.shape }
        }
    }
}
impl FilledMapConditionalFormattingOption {
    /// Creates a new builder-style object to manufacture [`FilledMapConditionalFormattingOption`](crate::model::FilledMapConditionalFormattingOption).
    pub fn builder() -> crate::model::filled_map_conditional_formatting_option::Builder {
        crate::model::filled_map_conditional_formatting_option::Builder::default()
    }
}

/// <p>The conditional formatting that determines the shape of the filled map.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilledMapShapeConditionalFormatting {
    /// <p>The field ID of the filled map shape.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The conditional formatting that determines the background color of a filled map's shape.</p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::ShapeConditionalFormat>,
}
impl FilledMapShapeConditionalFormatting {
    /// <p>The field ID of the filled map shape.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The conditional formatting that determines the background color of a filled map's shape.</p>
    pub fn format(&self) -> std::option::Option<&crate::model::ShapeConditionalFormat> {
        self.format.as_ref()
    }
}
/// See [`FilledMapShapeConditionalFormatting`](crate::model::FilledMapShapeConditionalFormatting).
pub mod filled_map_shape_conditional_formatting {

    /// A builder for [`FilledMapShapeConditionalFormatting`](crate::model::FilledMapShapeConditionalFormatting).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::ShapeConditionalFormat>,
    }
    impl Builder {
        /// <p>The field ID of the filled map shape.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The field ID of the filled map shape.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The conditional formatting that determines the background color of a filled map's shape.</p>
        pub fn format(mut self, input: crate::model::ShapeConditionalFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p>The conditional formatting that determines the background color of a filled map's shape.</p>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::ShapeConditionalFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// Consumes the builder and constructs a [`FilledMapShapeConditionalFormatting`](crate::model::FilledMapShapeConditionalFormatting).
        pub fn build(self) -> crate::model::FilledMapShapeConditionalFormatting {
            crate::model::FilledMapShapeConditionalFormatting {
                field_id: self.field_id,
                format: self.format,
            }
        }
    }
}
impl FilledMapShapeConditionalFormatting {
    /// Creates a new builder-style object to manufacture [`FilledMapShapeConditionalFormatting`](crate::model::FilledMapShapeConditionalFormatting).
    pub fn builder() -> crate::model::filled_map_shape_conditional_formatting::Builder {
        crate::model::filled_map_shape_conditional_formatting::Builder::default()
    }
}

/// <p>The shape conditional formatting of a filled map visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ShapeConditionalFormat {
    /// <p>The conditional formatting for the shape background color of a filled map visual.</p>
    #[doc(hidden)]
    pub background_color: std::option::Option<crate::model::ConditionalFormattingColor>,
}
impl ShapeConditionalFormat {
    /// <p>The conditional formatting for the shape background color of a filled map visual.</p>
    pub fn background_color(
        &self,
    ) -> std::option::Option<&crate::model::ConditionalFormattingColor> {
        self.background_color.as_ref()
    }
}
/// See [`ShapeConditionalFormat`](crate::model::ShapeConditionalFormat).
pub mod shape_conditional_format {

    /// A builder for [`ShapeConditionalFormat`](crate::model::ShapeConditionalFormat).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) background_color: std::option::Option<crate::model::ConditionalFormattingColor>,
    }
    impl Builder {
        /// <p>The conditional formatting for the shape background color of a filled map visual.</p>
        pub fn background_color(mut self, input: crate::model::ConditionalFormattingColor) -> Self {
            self.background_color = Some(input);
            self
        }
        /// <p>The conditional formatting for the shape background color of a filled map visual.</p>
        pub fn set_background_color(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingColor>,
        ) -> Self {
            self.background_color = input;
            self
        }
        /// Consumes the builder and constructs a [`ShapeConditionalFormat`](crate::model::ShapeConditionalFormat).
        pub fn build(self) -> crate::model::ShapeConditionalFormat {
            crate::model::ShapeConditionalFormat {
                background_color: self.background_color,
            }
        }
    }
}
impl ShapeConditionalFormat {
    /// Creates a new builder-style object to manufacture [`ShapeConditionalFormat`](crate::model::ShapeConditionalFormat).
    pub fn builder() -> crate::model::shape_conditional_format::Builder {
        crate::model::shape_conditional_format::Builder::default()
    }
}

/// <p>The formatting configuration for the color.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConditionalFormattingColor {
    /// <p>Formatting configuration for solid color.</p>
    #[doc(hidden)]
    pub solid: std::option::Option<crate::model::ConditionalFormattingSolidColor>,
    /// <p>Formatting configuration for gradient color.</p>
    #[doc(hidden)]
    pub gradient: std::option::Option<crate::model::ConditionalFormattingGradientColor>,
}
impl ConditionalFormattingColor {
    /// <p>Formatting configuration for solid color.</p>
    pub fn solid(&self) -> std::option::Option<&crate::model::ConditionalFormattingSolidColor> {
        self.solid.as_ref()
    }
    /// <p>Formatting configuration for gradient color.</p>
    pub fn gradient(
        &self,
    ) -> std::option::Option<&crate::model::ConditionalFormattingGradientColor> {
        self.gradient.as_ref()
    }
}
/// See [`ConditionalFormattingColor`](crate::model::ConditionalFormattingColor).
pub mod conditional_formatting_color {

    /// A builder for [`ConditionalFormattingColor`](crate::model::ConditionalFormattingColor).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) solid: std::option::Option<crate::model::ConditionalFormattingSolidColor>,
        pub(crate) gradient: std::option::Option<crate::model::ConditionalFormattingGradientColor>,
    }
    impl Builder {
        /// <p>Formatting configuration for solid color.</p>
        pub fn solid(mut self, input: crate::model::ConditionalFormattingSolidColor) -> Self {
            self.solid = Some(input);
            self
        }
        /// <p>Formatting configuration for solid color.</p>
        pub fn set_solid(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingSolidColor>,
        ) -> Self {
            self.solid = input;
            self
        }
        /// <p>Formatting configuration for gradient color.</p>
        pub fn gradient(mut self, input: crate::model::ConditionalFormattingGradientColor) -> Self {
            self.gradient = Some(input);
            self
        }
        /// <p>Formatting configuration for gradient color.</p>
        pub fn set_gradient(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingGradientColor>,
        ) -> Self {
            self.gradient = input;
            self
        }
        /// Consumes the builder and constructs a [`ConditionalFormattingColor`](crate::model::ConditionalFormattingColor).
        pub fn build(self) -> crate::model::ConditionalFormattingColor {
            crate::model::ConditionalFormattingColor {
                solid: self.solid,
                gradient: self.gradient,
            }
        }
    }
}
impl ConditionalFormattingColor {
    /// Creates a new builder-style object to manufacture [`ConditionalFormattingColor`](crate::model::ConditionalFormattingColor).
    pub fn builder() -> crate::model::conditional_formatting_color::Builder {
        crate::model::conditional_formatting_color::Builder::default()
    }
}

/// <p>Formatting configuration for gradient color.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConditionalFormattingGradientColor {
    /// <p>The expression that determines the formatting configuration for gradient color.</p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::string::String>,
    /// <p>Determines the color.</p>
    #[doc(hidden)]
    pub color: std::option::Option<crate::model::GradientColor>,
}
impl ConditionalFormattingGradientColor {
    /// <p>The expression that determines the formatting configuration for gradient color.</p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
    /// <p>Determines the color.</p>
    pub fn color(&self) -> std::option::Option<&crate::model::GradientColor> {
        self.color.as_ref()
    }
}
impl std::fmt::Debug for ConditionalFormattingGradientColor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConditionalFormattingGradientColor");
        formatter.field("expression", &"*** Sensitive Data Redacted ***");
        formatter.field("color", &self.color);
        formatter.finish()
    }
}
/// See [`ConditionalFormattingGradientColor`](crate::model::ConditionalFormattingGradientColor).
pub mod conditional_formatting_gradient_color {

    /// A builder for [`ConditionalFormattingGradientColor`](crate::model::ConditionalFormattingGradientColor).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) expression: std::option::Option<std::string::String>,
        pub(crate) color: std::option::Option<crate::model::GradientColor>,
    }
    impl Builder {
        /// <p>The expression that determines the formatting configuration for gradient color.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>The expression that determines the formatting configuration for gradient color.</p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// <p>Determines the color.</p>
        pub fn color(mut self, input: crate::model::GradientColor) -> Self {
            self.color = Some(input);
            self
        }
        /// <p>Determines the color.</p>
        pub fn set_color(
            mut self,
            input: std::option::Option<crate::model::GradientColor>,
        ) -> Self {
            self.color = input;
            self
        }
        /// Consumes the builder and constructs a [`ConditionalFormattingGradientColor`](crate::model::ConditionalFormattingGradientColor).
        pub fn build(self) -> crate::model::ConditionalFormattingGradientColor {
            crate::model::ConditionalFormattingGradientColor {
                expression: self.expression,
                color: self.color,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("expression", &"*** Sensitive Data Redacted ***");
            formatter.field("color", &self.color);
            formatter.finish()
        }
    }
}
impl ConditionalFormattingGradientColor {
    /// Creates a new builder-style object to manufacture [`ConditionalFormattingGradientColor`](crate::model::ConditionalFormattingGradientColor).
    pub fn builder() -> crate::model::conditional_formatting_gradient_color::Builder {
        crate::model::conditional_formatting_gradient_color::Builder::default()
    }
}

/// <p>Determines the gradient color settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GradientColor {
    /// <p>The list of gradient color stops.</p>
    #[doc(hidden)]
    pub stops: std::option::Option<std::vec::Vec<crate::model::GradientStop>>,
}
impl GradientColor {
    /// <p>The list of gradient color stops.</p>
    pub fn stops(&self) -> std::option::Option<&[crate::model::GradientStop]> {
        self.stops.as_deref()
    }
}
/// See [`GradientColor`](crate::model::GradientColor).
pub mod gradient_color {

    /// A builder for [`GradientColor`](crate::model::GradientColor).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stops: std::option::Option<std::vec::Vec<crate::model::GradientStop>>,
    }
    impl Builder {
        /// Appends an item to `stops`.
        ///
        /// To override the contents of this collection use [`set_stops`](Self::set_stops).
        ///
        /// <p>The list of gradient color stops.</p>
        pub fn stops(mut self, input: crate::model::GradientStop) -> Self {
            let mut v = self.stops.unwrap_or_default();
            v.push(input);
            self.stops = Some(v);
            self
        }
        /// <p>The list of gradient color stops.</p>
        pub fn set_stops(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GradientStop>>,
        ) -> Self {
            self.stops = input;
            self
        }
        /// Consumes the builder and constructs a [`GradientColor`](crate::model::GradientColor).
        pub fn build(self) -> crate::model::GradientColor {
            crate::model::GradientColor { stops: self.stops }
        }
    }
}
impl GradientColor {
    /// Creates a new builder-style object to manufacture [`GradientColor`](crate::model::GradientColor).
    pub fn builder() -> crate::model::gradient_color::Builder {
        crate::model::gradient_color::Builder::default()
    }
}

/// <p>Determines the gradient stop configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GradientStop {
    /// <p>Determines gradient offset value.</p>
    #[doc(hidden)]
    pub gradient_offset: f64,
    /// <p>Determines the data value.</p>
    #[doc(hidden)]
    pub data_value: std::option::Option<f64>,
    /// <p>Determines the color.</p>
    #[doc(hidden)]
    pub color: std::option::Option<std::string::String>,
}
impl GradientStop {
    /// <p>Determines gradient offset value.</p>
    pub fn gradient_offset(&self) -> f64 {
        self.gradient_offset
    }
    /// <p>Determines the data value.</p>
    pub fn data_value(&self) -> std::option::Option<f64> {
        self.data_value
    }
    /// <p>Determines the color.</p>
    pub fn color(&self) -> std::option::Option<&str> {
        self.color.as_deref()
    }
}
/// See [`GradientStop`](crate::model::GradientStop).
pub mod gradient_stop {

    /// A builder for [`GradientStop`](crate::model::GradientStop).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gradient_offset: std::option::Option<f64>,
        pub(crate) data_value: std::option::Option<f64>,
        pub(crate) color: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Determines gradient offset value.</p>
        pub fn gradient_offset(mut self, input: f64) -> Self {
            self.gradient_offset = Some(input);
            self
        }
        /// <p>Determines gradient offset value.</p>
        pub fn set_gradient_offset(mut self, input: std::option::Option<f64>) -> Self {
            self.gradient_offset = input;
            self
        }
        /// <p>Determines the data value.</p>
        pub fn data_value(mut self, input: f64) -> Self {
            self.data_value = Some(input);
            self
        }
        /// <p>Determines the data value.</p>
        pub fn set_data_value(mut self, input: std::option::Option<f64>) -> Self {
            self.data_value = input;
            self
        }
        /// <p>Determines the color.</p>
        pub fn color(mut self, input: impl Into<std::string::String>) -> Self {
            self.color = Some(input.into());
            self
        }
        /// <p>Determines the color.</p>
        pub fn set_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.color = input;
            self
        }
        /// Consumes the builder and constructs a [`GradientStop`](crate::model::GradientStop).
        pub fn build(self) -> crate::model::GradientStop {
            crate::model::GradientStop {
                gradient_offset: self.gradient_offset.unwrap_or_default(),
                data_value: self.data_value,
                color: self.color,
            }
        }
    }
}
impl GradientStop {
    /// Creates a new builder-style object to manufacture [`GradientStop`](crate::model::GradientStop).
    pub fn builder() -> crate::model::gradient_stop::Builder {
        crate::model::gradient_stop::Builder::default()
    }
}

/// <p>Formatting configuration for solid color.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConditionalFormattingSolidColor {
    /// <p>The expression that determines the formatting configuration for solid color.</p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::string::String>,
    /// <p>Determines the color.</p>
    #[doc(hidden)]
    pub color: std::option::Option<std::string::String>,
}
impl ConditionalFormattingSolidColor {
    /// <p>The expression that determines the formatting configuration for solid color.</p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
    /// <p>Determines the color.</p>
    pub fn color(&self) -> std::option::Option<&str> {
        self.color.as_deref()
    }
}
impl std::fmt::Debug for ConditionalFormattingSolidColor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConditionalFormattingSolidColor");
        formatter.field("expression", &"*** Sensitive Data Redacted ***");
        formatter.field("color", &self.color);
        formatter.finish()
    }
}
/// See [`ConditionalFormattingSolidColor`](crate::model::ConditionalFormattingSolidColor).
pub mod conditional_formatting_solid_color {

    /// A builder for [`ConditionalFormattingSolidColor`](crate::model::ConditionalFormattingSolidColor).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) expression: std::option::Option<std::string::String>,
        pub(crate) color: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The expression that determines the formatting configuration for solid color.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>The expression that determines the formatting configuration for solid color.</p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// <p>Determines the color.</p>
        pub fn color(mut self, input: impl Into<std::string::String>) -> Self {
            self.color = Some(input.into());
            self
        }
        /// <p>Determines the color.</p>
        pub fn set_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.color = input;
            self
        }
        /// Consumes the builder and constructs a [`ConditionalFormattingSolidColor`](crate::model::ConditionalFormattingSolidColor).
        pub fn build(self) -> crate::model::ConditionalFormattingSolidColor {
            crate::model::ConditionalFormattingSolidColor {
                expression: self.expression,
                color: self.color,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("expression", &"*** Sensitive Data Redacted ***");
            formatter.field("color", &self.color);
            formatter.finish()
        }
    }
}
impl ConditionalFormattingSolidColor {
    /// Creates a new builder-style object to manufacture [`ConditionalFormattingSolidColor`](crate::model::ConditionalFormattingSolidColor).
    pub fn builder() -> crate::model::conditional_formatting_solid_color::Builder {
        crate::model::conditional_formatting_solid_color::Builder::default()
    }
}

/// <p>The configuration for a <code>FilledMapVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilledMapConfiguration {
    /// <p>The field wells of the visual.</p>
    #[doc(hidden)]
    pub field_wells: std::option::Option<crate::model::FilledMapFieldWells>,
    /// <p>The sort configuration of a <code>FilledMapVisual</code>.</p>
    #[doc(hidden)]
    pub sort_configuration: std::option::Option<crate::model::FilledMapSortConfiguration>,
    /// <p>The legend display setup of the visual.</p>
    #[doc(hidden)]
    pub legend: std::option::Option<crate::model::LegendOptions>,
    /// <p>The tooltip display setup of the visual.</p>
    #[doc(hidden)]
    pub tooltip: std::option::Option<crate::model::TooltipOptions>,
    /// <p>The window options of the filled map visual.</p>
    #[doc(hidden)]
    pub window_options: std::option::Option<crate::model::GeospatialWindowOptions>,
    /// <p>The map style options of the filled map visual.</p>
    #[doc(hidden)]
    pub map_style_options: std::option::Option<crate::model::GeospatialMapStyleOptions>,
}
impl FilledMapConfiguration {
    /// <p>The field wells of the visual.</p>
    pub fn field_wells(&self) -> std::option::Option<&crate::model::FilledMapFieldWells> {
        self.field_wells.as_ref()
    }
    /// <p>The sort configuration of a <code>FilledMapVisual</code>.</p>
    pub fn sort_configuration(
        &self,
    ) -> std::option::Option<&crate::model::FilledMapSortConfiguration> {
        self.sort_configuration.as_ref()
    }
    /// <p>The legend display setup of the visual.</p>
    pub fn legend(&self) -> std::option::Option<&crate::model::LegendOptions> {
        self.legend.as_ref()
    }
    /// <p>The tooltip display setup of the visual.</p>
    pub fn tooltip(&self) -> std::option::Option<&crate::model::TooltipOptions> {
        self.tooltip.as_ref()
    }
    /// <p>The window options of the filled map visual.</p>
    pub fn window_options(&self) -> std::option::Option<&crate::model::GeospatialWindowOptions> {
        self.window_options.as_ref()
    }
    /// <p>The map style options of the filled map visual.</p>
    pub fn map_style_options(
        &self,
    ) -> std::option::Option<&crate::model::GeospatialMapStyleOptions> {
        self.map_style_options.as_ref()
    }
}
/// See [`FilledMapConfiguration`](crate::model::FilledMapConfiguration).
pub mod filled_map_configuration {

    /// A builder for [`FilledMapConfiguration`](crate::model::FilledMapConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_wells: std::option::Option<crate::model::FilledMapFieldWells>,
        pub(crate) sort_configuration:
            std::option::Option<crate::model::FilledMapSortConfiguration>,
        pub(crate) legend: std::option::Option<crate::model::LegendOptions>,
        pub(crate) tooltip: std::option::Option<crate::model::TooltipOptions>,
        pub(crate) window_options: std::option::Option<crate::model::GeospatialWindowOptions>,
        pub(crate) map_style_options: std::option::Option<crate::model::GeospatialMapStyleOptions>,
    }
    impl Builder {
        /// <p>The field wells of the visual.</p>
        pub fn field_wells(mut self, input: crate::model::FilledMapFieldWells) -> Self {
            self.field_wells = Some(input);
            self
        }
        /// <p>The field wells of the visual.</p>
        pub fn set_field_wells(
            mut self,
            input: std::option::Option<crate::model::FilledMapFieldWells>,
        ) -> Self {
            self.field_wells = input;
            self
        }
        /// <p>The sort configuration of a <code>FilledMapVisual</code>.</p>
        pub fn sort_configuration(
            mut self,
            input: crate::model::FilledMapSortConfiguration,
        ) -> Self {
            self.sort_configuration = Some(input);
            self
        }
        /// <p>The sort configuration of a <code>FilledMapVisual</code>.</p>
        pub fn set_sort_configuration(
            mut self,
            input: std::option::Option<crate::model::FilledMapSortConfiguration>,
        ) -> Self {
            self.sort_configuration = input;
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn legend(mut self, input: crate::model::LegendOptions) -> Self {
            self.legend = Some(input);
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn set_legend(
            mut self,
            input: std::option::Option<crate::model::LegendOptions>,
        ) -> Self {
            self.legend = input;
            self
        }
        /// <p>The tooltip display setup of the visual.</p>
        pub fn tooltip(mut self, input: crate::model::TooltipOptions) -> Self {
            self.tooltip = Some(input);
            self
        }
        /// <p>The tooltip display setup of the visual.</p>
        pub fn set_tooltip(
            mut self,
            input: std::option::Option<crate::model::TooltipOptions>,
        ) -> Self {
            self.tooltip = input;
            self
        }
        /// <p>The window options of the filled map visual.</p>
        pub fn window_options(mut self, input: crate::model::GeospatialWindowOptions) -> Self {
            self.window_options = Some(input);
            self
        }
        /// <p>The window options of the filled map visual.</p>
        pub fn set_window_options(
            mut self,
            input: std::option::Option<crate::model::GeospatialWindowOptions>,
        ) -> Self {
            self.window_options = input;
            self
        }
        /// <p>The map style options of the filled map visual.</p>
        pub fn map_style_options(mut self, input: crate::model::GeospatialMapStyleOptions) -> Self {
            self.map_style_options = Some(input);
            self
        }
        /// <p>The map style options of the filled map visual.</p>
        pub fn set_map_style_options(
            mut self,
            input: std::option::Option<crate::model::GeospatialMapStyleOptions>,
        ) -> Self {
            self.map_style_options = input;
            self
        }
        /// Consumes the builder and constructs a [`FilledMapConfiguration`](crate::model::FilledMapConfiguration).
        pub fn build(self) -> crate::model::FilledMapConfiguration {
            crate::model::FilledMapConfiguration {
                field_wells: self.field_wells,
                sort_configuration: self.sort_configuration,
                legend: self.legend,
                tooltip: self.tooltip,
                window_options: self.window_options,
                map_style_options: self.map_style_options,
            }
        }
    }
}
impl FilledMapConfiguration {
    /// Creates a new builder-style object to manufacture [`FilledMapConfiguration`](crate::model::FilledMapConfiguration).
    pub fn builder() -> crate::model::filled_map_configuration::Builder {
        crate::model::filled_map_configuration::Builder::default()
    }
}

/// <p>The map style options of the geospatial map.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GeospatialMapStyleOptions {
    /// <p>The base map style of the geospatial map.</p>
    #[doc(hidden)]
    pub base_map_style: std::option::Option<crate::model::BaseMapStyleType>,
}
impl GeospatialMapStyleOptions {
    /// <p>The base map style of the geospatial map.</p>
    pub fn base_map_style(&self) -> std::option::Option<&crate::model::BaseMapStyleType> {
        self.base_map_style.as_ref()
    }
}
/// See [`GeospatialMapStyleOptions`](crate::model::GeospatialMapStyleOptions).
pub mod geospatial_map_style_options {

    /// A builder for [`GeospatialMapStyleOptions`](crate::model::GeospatialMapStyleOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) base_map_style: std::option::Option<crate::model::BaseMapStyleType>,
    }
    impl Builder {
        /// <p>The base map style of the geospatial map.</p>
        pub fn base_map_style(mut self, input: crate::model::BaseMapStyleType) -> Self {
            self.base_map_style = Some(input);
            self
        }
        /// <p>The base map style of the geospatial map.</p>
        pub fn set_base_map_style(
            mut self,
            input: std::option::Option<crate::model::BaseMapStyleType>,
        ) -> Self {
            self.base_map_style = input;
            self
        }
        /// Consumes the builder and constructs a [`GeospatialMapStyleOptions`](crate::model::GeospatialMapStyleOptions).
        pub fn build(self) -> crate::model::GeospatialMapStyleOptions {
            crate::model::GeospatialMapStyleOptions {
                base_map_style: self.base_map_style,
            }
        }
    }
}
impl GeospatialMapStyleOptions {
    /// Creates a new builder-style object to manufacture [`GeospatialMapStyleOptions`](crate::model::GeospatialMapStyleOptions).
    pub fn builder() -> crate::model::geospatial_map_style_options::Builder {
        crate::model::geospatial_map_style_options::Builder::default()
    }
}

/// When writing a match expression against `BaseMapStyleType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let basemapstyletype = unimplemented!();
/// match basemapstyletype {
///     BaseMapStyleType::DarkGray => { /* ... */ },
///     BaseMapStyleType::Imagery => { /* ... */ },
///     BaseMapStyleType::LightGray => { /* ... */ },
///     BaseMapStyleType::Street => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `basemapstyletype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BaseMapStyleType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BaseMapStyleType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BaseMapStyleType::NewFeature` is defined.
/// Specifically, when `basemapstyletype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BaseMapStyleType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BaseMapStyleType {
    #[allow(missing_docs)] // documentation missing in model
    DarkGray,
    #[allow(missing_docs)] // documentation missing in model
    Imagery,
    #[allow(missing_docs)] // documentation missing in model
    LightGray,
    #[allow(missing_docs)] // documentation missing in model
    Street,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BaseMapStyleType {
    fn from(s: &str) -> Self {
        match s {
            "DARK_GRAY" => BaseMapStyleType::DarkGray,
            "IMAGERY" => BaseMapStyleType::Imagery,
            "LIGHT_GRAY" => BaseMapStyleType::LightGray,
            "STREET" => BaseMapStyleType::Street,
            other => BaseMapStyleType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for BaseMapStyleType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BaseMapStyleType::from(s))
    }
}
impl BaseMapStyleType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BaseMapStyleType::DarkGray => "DARK_GRAY",
            BaseMapStyleType::Imagery => "IMAGERY",
            BaseMapStyleType::LightGray => "LIGHT_GRAY",
            BaseMapStyleType::Street => "STREET",
            BaseMapStyleType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DARK_GRAY", "IMAGERY", "LIGHT_GRAY", "STREET"]
    }
}
impl AsRef<str> for BaseMapStyleType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The window options of the geospatial map visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GeospatialWindowOptions {
    /// <p>The bounds options (north, south, west, east) of the geospatial window options.</p>
    #[doc(hidden)]
    pub bounds: std::option::Option<crate::model::GeospatialCoordinateBounds>,
    /// <p>The map zoom modes (manual, auto) of the geospatial window options.</p>
    #[doc(hidden)]
    pub map_zoom_mode: std::option::Option<crate::model::MapZoomMode>,
}
impl GeospatialWindowOptions {
    /// <p>The bounds options (north, south, west, east) of the geospatial window options.</p>
    pub fn bounds(&self) -> std::option::Option<&crate::model::GeospatialCoordinateBounds> {
        self.bounds.as_ref()
    }
    /// <p>The map zoom modes (manual, auto) of the geospatial window options.</p>
    pub fn map_zoom_mode(&self) -> std::option::Option<&crate::model::MapZoomMode> {
        self.map_zoom_mode.as_ref()
    }
}
/// See [`GeospatialWindowOptions`](crate::model::GeospatialWindowOptions).
pub mod geospatial_window_options {

    /// A builder for [`GeospatialWindowOptions`](crate::model::GeospatialWindowOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bounds: std::option::Option<crate::model::GeospatialCoordinateBounds>,
        pub(crate) map_zoom_mode: std::option::Option<crate::model::MapZoomMode>,
    }
    impl Builder {
        /// <p>The bounds options (north, south, west, east) of the geospatial window options.</p>
        pub fn bounds(mut self, input: crate::model::GeospatialCoordinateBounds) -> Self {
            self.bounds = Some(input);
            self
        }
        /// <p>The bounds options (north, south, west, east) of the geospatial window options.</p>
        pub fn set_bounds(
            mut self,
            input: std::option::Option<crate::model::GeospatialCoordinateBounds>,
        ) -> Self {
            self.bounds = input;
            self
        }
        /// <p>The map zoom modes (manual, auto) of the geospatial window options.</p>
        pub fn map_zoom_mode(mut self, input: crate::model::MapZoomMode) -> Self {
            self.map_zoom_mode = Some(input);
            self
        }
        /// <p>The map zoom modes (manual, auto) of the geospatial window options.</p>
        pub fn set_map_zoom_mode(
            mut self,
            input: std::option::Option<crate::model::MapZoomMode>,
        ) -> Self {
            self.map_zoom_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`GeospatialWindowOptions`](crate::model::GeospatialWindowOptions).
        pub fn build(self) -> crate::model::GeospatialWindowOptions {
            crate::model::GeospatialWindowOptions {
                bounds: self.bounds,
                map_zoom_mode: self.map_zoom_mode,
            }
        }
    }
}
impl GeospatialWindowOptions {
    /// Creates a new builder-style object to manufacture [`GeospatialWindowOptions`](crate::model::GeospatialWindowOptions).
    pub fn builder() -> crate::model::geospatial_window_options::Builder {
        crate::model::geospatial_window_options::Builder::default()
    }
}

/// When writing a match expression against `MapZoomMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let mapzoommode = unimplemented!();
/// match mapzoommode {
///     MapZoomMode::Auto => { /* ... */ },
///     MapZoomMode::Manual => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `mapzoommode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MapZoomMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MapZoomMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MapZoomMode::NewFeature` is defined.
/// Specifically, when `mapzoommode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MapZoomMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MapZoomMode {
    #[allow(missing_docs)] // documentation missing in model
    Auto,
    #[allow(missing_docs)] // documentation missing in model
    Manual,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MapZoomMode {
    fn from(s: &str) -> Self {
        match s {
            "AUTO" => MapZoomMode::Auto,
            "MANUAL" => MapZoomMode::Manual,
            other => MapZoomMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for MapZoomMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MapZoomMode::from(s))
    }
}
impl MapZoomMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MapZoomMode::Auto => "AUTO",
            MapZoomMode::Manual => "MANUAL",
            MapZoomMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AUTO", "MANUAL"]
    }
}
impl AsRef<str> for MapZoomMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The bound options (north, south, west, east) of the geospatial window options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GeospatialCoordinateBounds {
    /// <p>The latitude of the north bound of the geospatial coordinate bounds.</p>
    #[doc(hidden)]
    pub north: std::option::Option<f64>,
    /// <p>The latitude of the south bound of the geospatial coordinate bounds.</p>
    #[doc(hidden)]
    pub south: std::option::Option<f64>,
    /// <p>The longitude of the west bound of the geospatial coordinate bounds.</p>
    #[doc(hidden)]
    pub west: std::option::Option<f64>,
    /// <p>The longitude of the east bound of the geospatial coordinate bounds.</p>
    #[doc(hidden)]
    pub east: std::option::Option<f64>,
}
impl GeospatialCoordinateBounds {
    /// <p>The latitude of the north bound of the geospatial coordinate bounds.</p>
    pub fn north(&self) -> std::option::Option<f64> {
        self.north
    }
    /// <p>The latitude of the south bound of the geospatial coordinate bounds.</p>
    pub fn south(&self) -> std::option::Option<f64> {
        self.south
    }
    /// <p>The longitude of the west bound of the geospatial coordinate bounds.</p>
    pub fn west(&self) -> std::option::Option<f64> {
        self.west
    }
    /// <p>The longitude of the east bound of the geospatial coordinate bounds.</p>
    pub fn east(&self) -> std::option::Option<f64> {
        self.east
    }
}
/// See [`GeospatialCoordinateBounds`](crate::model::GeospatialCoordinateBounds).
pub mod geospatial_coordinate_bounds {

    /// A builder for [`GeospatialCoordinateBounds`](crate::model::GeospatialCoordinateBounds).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) north: std::option::Option<f64>,
        pub(crate) south: std::option::Option<f64>,
        pub(crate) west: std::option::Option<f64>,
        pub(crate) east: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The latitude of the north bound of the geospatial coordinate bounds.</p>
        pub fn north(mut self, input: f64) -> Self {
            self.north = Some(input);
            self
        }
        /// <p>The latitude of the north bound of the geospatial coordinate bounds.</p>
        pub fn set_north(mut self, input: std::option::Option<f64>) -> Self {
            self.north = input;
            self
        }
        /// <p>The latitude of the south bound of the geospatial coordinate bounds.</p>
        pub fn south(mut self, input: f64) -> Self {
            self.south = Some(input);
            self
        }
        /// <p>The latitude of the south bound of the geospatial coordinate bounds.</p>
        pub fn set_south(mut self, input: std::option::Option<f64>) -> Self {
            self.south = input;
            self
        }
        /// <p>The longitude of the west bound of the geospatial coordinate bounds.</p>
        pub fn west(mut self, input: f64) -> Self {
            self.west = Some(input);
            self
        }
        /// <p>The longitude of the west bound of the geospatial coordinate bounds.</p>
        pub fn set_west(mut self, input: std::option::Option<f64>) -> Self {
            self.west = input;
            self
        }
        /// <p>The longitude of the east bound of the geospatial coordinate bounds.</p>
        pub fn east(mut self, input: f64) -> Self {
            self.east = Some(input);
            self
        }
        /// <p>The longitude of the east bound of the geospatial coordinate bounds.</p>
        pub fn set_east(mut self, input: std::option::Option<f64>) -> Self {
            self.east = input;
            self
        }
        /// Consumes the builder and constructs a [`GeospatialCoordinateBounds`](crate::model::GeospatialCoordinateBounds).
        pub fn build(self) -> crate::model::GeospatialCoordinateBounds {
            crate::model::GeospatialCoordinateBounds {
                north: self.north,
                south: self.south,
                west: self.west,
                east: self.east,
            }
        }
    }
}
impl GeospatialCoordinateBounds {
    /// Creates a new builder-style object to manufacture [`GeospatialCoordinateBounds`](crate::model::GeospatialCoordinateBounds).
    pub fn builder() -> crate::model::geospatial_coordinate_bounds::Builder {
        crate::model::geospatial_coordinate_bounds::Builder::default()
    }
}

/// <p>The sort configuration of a <code>FilledMapVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilledMapSortConfiguration {
    /// <p>The sort configuration of the location fields.</p>
    #[doc(hidden)]
    pub category_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
}
impl FilledMapSortConfiguration {
    /// <p>The sort configuration of the location fields.</p>
    pub fn category_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.category_sort.as_deref()
    }
}
/// See [`FilledMapSortConfiguration`](crate::model::FilledMapSortConfiguration).
pub mod filled_map_sort_configuration {

    /// A builder for [`FilledMapSortConfiguration`](crate::model::FilledMapSortConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category_sort:
            std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    }
    impl Builder {
        /// Appends an item to `category_sort`.
        ///
        /// To override the contents of this collection use [`set_category_sort`](Self::set_category_sort).
        ///
        /// <p>The sort configuration of the location fields.</p>
        pub fn category_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.category_sort.unwrap_or_default();
            v.push(input);
            self.category_sort = Some(v);
            self
        }
        /// <p>The sort configuration of the location fields.</p>
        pub fn set_category_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.category_sort = input;
            self
        }
        /// Consumes the builder and constructs a [`FilledMapSortConfiguration`](crate::model::FilledMapSortConfiguration).
        pub fn build(self) -> crate::model::FilledMapSortConfiguration {
            crate::model::FilledMapSortConfiguration {
                category_sort: self.category_sort,
            }
        }
    }
}
impl FilledMapSortConfiguration {
    /// Creates a new builder-style object to manufacture [`FilledMapSortConfiguration`](crate::model::FilledMapSortConfiguration).
    pub fn builder() -> crate::model::filled_map_sort_configuration::Builder {
        crate::model::filled_map_sort_configuration::Builder::default()
    }
}

/// <p>The field wells of a <code>FilledMapVisual</code>.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilledMapFieldWells {
    /// <p>The aggregated field well of the filled map.</p>
    #[doc(hidden)]
    pub filled_map_aggregated_field_wells:
        std::option::Option<crate::model::FilledMapAggregatedFieldWells>,
}
impl FilledMapFieldWells {
    /// <p>The aggregated field well of the filled map.</p>
    pub fn filled_map_aggregated_field_wells(
        &self,
    ) -> std::option::Option<&crate::model::FilledMapAggregatedFieldWells> {
        self.filled_map_aggregated_field_wells.as_ref()
    }
}
/// See [`FilledMapFieldWells`](crate::model::FilledMapFieldWells).
pub mod filled_map_field_wells {

    /// A builder for [`FilledMapFieldWells`](crate::model::FilledMapFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filled_map_aggregated_field_wells:
            std::option::Option<crate::model::FilledMapAggregatedFieldWells>,
    }
    impl Builder {
        /// <p>The aggregated field well of the filled map.</p>
        pub fn filled_map_aggregated_field_wells(
            mut self,
            input: crate::model::FilledMapAggregatedFieldWells,
        ) -> Self {
            self.filled_map_aggregated_field_wells = Some(input);
            self
        }
        /// <p>The aggregated field well of the filled map.</p>
        pub fn set_filled_map_aggregated_field_wells(
            mut self,
            input: std::option::Option<crate::model::FilledMapAggregatedFieldWells>,
        ) -> Self {
            self.filled_map_aggregated_field_wells = input;
            self
        }
        /// Consumes the builder and constructs a [`FilledMapFieldWells`](crate::model::FilledMapFieldWells).
        pub fn build(self) -> crate::model::FilledMapFieldWells {
            crate::model::FilledMapFieldWells {
                filled_map_aggregated_field_wells: self.filled_map_aggregated_field_wells,
            }
        }
    }
}
impl FilledMapFieldWells {
    /// Creates a new builder-style object to manufacture [`FilledMapFieldWells`](crate::model::FilledMapFieldWells).
    pub fn builder() -> crate::model::filled_map_field_wells::Builder {
        crate::model::filled_map_field_wells::Builder::default()
    }
}

/// <p>The aggregated field well of the filled map.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilledMapAggregatedFieldWells {
    /// <p>The aggregated location field well of the filled map. Values are grouped by location fields.</p>
    #[doc(hidden)]
    pub geospatial: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The aggregated color field well of a filled map. Values are aggregated based on location fields.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
}
impl FilledMapAggregatedFieldWells {
    /// <p>The aggregated location field well of the filled map. Values are grouped by location fields.</p>
    pub fn geospatial(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.geospatial.as_deref()
    }
    /// <p>The aggregated color field well of a filled map. Values are aggregated based on location fields.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.values.as_deref()
    }
}
/// See [`FilledMapAggregatedFieldWells`](crate::model::FilledMapAggregatedFieldWells).
pub mod filled_map_aggregated_field_wells {

    /// A builder for [`FilledMapAggregatedFieldWells`](crate::model::FilledMapAggregatedFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) geospatial: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    }
    impl Builder {
        /// Appends an item to `geospatial`.
        ///
        /// To override the contents of this collection use [`set_geospatial`](Self::set_geospatial).
        ///
        /// <p>The aggregated location field well of the filled map. Values are grouped by location fields.</p>
        pub fn geospatial(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.geospatial.unwrap_or_default();
            v.push(input);
            self.geospatial = Some(v);
            self
        }
        /// <p>The aggregated location field well of the filled map. Values are grouped by location fields.</p>
        pub fn set_geospatial(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.geospatial = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The aggregated color field well of a filled map. Values are aggregated based on location fields.</p>
        pub fn values(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>The aggregated color field well of a filled map. Values are aggregated based on location fields.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`FilledMapAggregatedFieldWells`](crate::model::FilledMapAggregatedFieldWells).
        pub fn build(self) -> crate::model::FilledMapAggregatedFieldWells {
            crate::model::FilledMapAggregatedFieldWells {
                geospatial: self.geospatial,
                values: self.values,
            }
        }
    }
}
impl FilledMapAggregatedFieldWells {
    /// Creates a new builder-style object to manufacture [`FilledMapAggregatedFieldWells`](crate::model::FilledMapAggregatedFieldWells).
    pub fn builder() -> crate::model::filled_map_aggregated_field_wells::Builder {
        crate::model::filled_map_aggregated_field_wells::Builder::default()
    }
}

/// <p>A geospatial map or a points on map visual.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/point-maps.html">Creating point maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GeospatialMapVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration settings of the visual.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::GeospatialMapConfiguration>,
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    #[doc(hidden)]
    pub column_hierarchies: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
}
impl GeospatialMapVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration settings of the visual.</p>
    pub fn chart_configuration(
        &self,
    ) -> std::option::Option<&crate::model::GeospatialMapConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    pub fn column_hierarchies(&self) -> std::option::Option<&[crate::model::ColumnHierarchy]> {
        self.column_hierarchies.as_deref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
}
/// See [`GeospatialMapVisual`](crate::model::GeospatialMapVisual).
pub mod geospatial_map_visual {

    /// A builder for [`GeospatialMapVisual`](crate::model::GeospatialMapVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration:
            std::option::Option<crate::model::GeospatialMapConfiguration>,
        pub(crate) column_hierarchies:
            std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn chart_configuration(
            mut self,
            input: crate::model::GeospatialMapConfiguration,
        ) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::GeospatialMapConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// Appends an item to `column_hierarchies`.
        ///
        /// To override the contents of this collection use [`set_column_hierarchies`](Self::set_column_hierarchies).
        ///
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn column_hierarchies(mut self, input: crate::model::ColumnHierarchy) -> Self {
            let mut v = self.column_hierarchies.unwrap_or_default();
            v.push(input);
            self.column_hierarchies = Some(v);
            self
        }
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn set_column_hierarchies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
        ) -> Self {
            self.column_hierarchies = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Consumes the builder and constructs a [`GeospatialMapVisual`](crate::model::GeospatialMapVisual).
        pub fn build(self) -> crate::model::GeospatialMapVisual {
            crate::model::GeospatialMapVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                column_hierarchies: self.column_hierarchies,
                actions: self.actions,
            }
        }
    }
}
impl GeospatialMapVisual {
    /// Creates a new builder-style object to manufacture [`GeospatialMapVisual`](crate::model::GeospatialMapVisual).
    pub fn builder() -> crate::model::geospatial_map_visual::Builder {
        crate::model::geospatial_map_visual::Builder::default()
    }
}

/// <p>The configuration of a <code>GeospatialMapVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GeospatialMapConfiguration {
    /// <p>The field wells of the visual.</p>
    #[doc(hidden)]
    pub field_wells: std::option::Option<crate::model::GeospatialMapFieldWells>,
    /// <p>The legend display setup of the visual.</p>
    #[doc(hidden)]
    pub legend: std::option::Option<crate::model::LegendOptions>,
    /// <p>The tooltip display setup of the visual.</p>
    #[doc(hidden)]
    pub tooltip: std::option::Option<crate::model::TooltipOptions>,
    /// <p>The window options of the geospatial map.</p>
    #[doc(hidden)]
    pub window_options: std::option::Option<crate::model::GeospatialWindowOptions>,
    /// <p>The map style options of the geospatial map.</p>
    #[doc(hidden)]
    pub map_style_options: std::option::Option<crate::model::GeospatialMapStyleOptions>,
    /// <p>The point style options of the geospatial map.</p>
    #[doc(hidden)]
    pub point_style_options: std::option::Option<crate::model::GeospatialPointStyleOptions>,
    /// <p>The visual display options for the visual palette.</p>
    #[doc(hidden)]
    pub visual_palette: std::option::Option<crate::model::VisualPalette>,
}
impl GeospatialMapConfiguration {
    /// <p>The field wells of the visual.</p>
    pub fn field_wells(&self) -> std::option::Option<&crate::model::GeospatialMapFieldWells> {
        self.field_wells.as_ref()
    }
    /// <p>The legend display setup of the visual.</p>
    pub fn legend(&self) -> std::option::Option<&crate::model::LegendOptions> {
        self.legend.as_ref()
    }
    /// <p>The tooltip display setup of the visual.</p>
    pub fn tooltip(&self) -> std::option::Option<&crate::model::TooltipOptions> {
        self.tooltip.as_ref()
    }
    /// <p>The window options of the geospatial map.</p>
    pub fn window_options(&self) -> std::option::Option<&crate::model::GeospatialWindowOptions> {
        self.window_options.as_ref()
    }
    /// <p>The map style options of the geospatial map.</p>
    pub fn map_style_options(
        &self,
    ) -> std::option::Option<&crate::model::GeospatialMapStyleOptions> {
        self.map_style_options.as_ref()
    }
    /// <p>The point style options of the geospatial map.</p>
    pub fn point_style_options(
        &self,
    ) -> std::option::Option<&crate::model::GeospatialPointStyleOptions> {
        self.point_style_options.as_ref()
    }
    /// <p>The visual display options for the visual palette.</p>
    pub fn visual_palette(&self) -> std::option::Option<&crate::model::VisualPalette> {
        self.visual_palette.as_ref()
    }
}
/// See [`GeospatialMapConfiguration`](crate::model::GeospatialMapConfiguration).
pub mod geospatial_map_configuration {

    /// A builder for [`GeospatialMapConfiguration`](crate::model::GeospatialMapConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_wells: std::option::Option<crate::model::GeospatialMapFieldWells>,
        pub(crate) legend: std::option::Option<crate::model::LegendOptions>,
        pub(crate) tooltip: std::option::Option<crate::model::TooltipOptions>,
        pub(crate) window_options: std::option::Option<crate::model::GeospatialWindowOptions>,
        pub(crate) map_style_options: std::option::Option<crate::model::GeospatialMapStyleOptions>,
        pub(crate) point_style_options:
            std::option::Option<crate::model::GeospatialPointStyleOptions>,
        pub(crate) visual_palette: std::option::Option<crate::model::VisualPalette>,
    }
    impl Builder {
        /// <p>The field wells of the visual.</p>
        pub fn field_wells(mut self, input: crate::model::GeospatialMapFieldWells) -> Self {
            self.field_wells = Some(input);
            self
        }
        /// <p>The field wells of the visual.</p>
        pub fn set_field_wells(
            mut self,
            input: std::option::Option<crate::model::GeospatialMapFieldWells>,
        ) -> Self {
            self.field_wells = input;
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn legend(mut self, input: crate::model::LegendOptions) -> Self {
            self.legend = Some(input);
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn set_legend(
            mut self,
            input: std::option::Option<crate::model::LegendOptions>,
        ) -> Self {
            self.legend = input;
            self
        }
        /// <p>The tooltip display setup of the visual.</p>
        pub fn tooltip(mut self, input: crate::model::TooltipOptions) -> Self {
            self.tooltip = Some(input);
            self
        }
        /// <p>The tooltip display setup of the visual.</p>
        pub fn set_tooltip(
            mut self,
            input: std::option::Option<crate::model::TooltipOptions>,
        ) -> Self {
            self.tooltip = input;
            self
        }
        /// <p>The window options of the geospatial map.</p>
        pub fn window_options(mut self, input: crate::model::GeospatialWindowOptions) -> Self {
            self.window_options = Some(input);
            self
        }
        /// <p>The window options of the geospatial map.</p>
        pub fn set_window_options(
            mut self,
            input: std::option::Option<crate::model::GeospatialWindowOptions>,
        ) -> Self {
            self.window_options = input;
            self
        }
        /// <p>The map style options of the geospatial map.</p>
        pub fn map_style_options(mut self, input: crate::model::GeospatialMapStyleOptions) -> Self {
            self.map_style_options = Some(input);
            self
        }
        /// <p>The map style options of the geospatial map.</p>
        pub fn set_map_style_options(
            mut self,
            input: std::option::Option<crate::model::GeospatialMapStyleOptions>,
        ) -> Self {
            self.map_style_options = input;
            self
        }
        /// <p>The point style options of the geospatial map.</p>
        pub fn point_style_options(
            mut self,
            input: crate::model::GeospatialPointStyleOptions,
        ) -> Self {
            self.point_style_options = Some(input);
            self
        }
        /// <p>The point style options of the geospatial map.</p>
        pub fn set_point_style_options(
            mut self,
            input: std::option::Option<crate::model::GeospatialPointStyleOptions>,
        ) -> Self {
            self.point_style_options = input;
            self
        }
        /// <p>The visual display options for the visual palette.</p>
        pub fn visual_palette(mut self, input: crate::model::VisualPalette) -> Self {
            self.visual_palette = Some(input);
            self
        }
        /// <p>The visual display options for the visual palette.</p>
        pub fn set_visual_palette(
            mut self,
            input: std::option::Option<crate::model::VisualPalette>,
        ) -> Self {
            self.visual_palette = input;
            self
        }
        /// Consumes the builder and constructs a [`GeospatialMapConfiguration`](crate::model::GeospatialMapConfiguration).
        pub fn build(self) -> crate::model::GeospatialMapConfiguration {
            crate::model::GeospatialMapConfiguration {
                field_wells: self.field_wells,
                legend: self.legend,
                tooltip: self.tooltip,
                window_options: self.window_options,
                map_style_options: self.map_style_options,
                point_style_options: self.point_style_options,
                visual_palette: self.visual_palette,
            }
        }
    }
}
impl GeospatialMapConfiguration {
    /// Creates a new builder-style object to manufacture [`GeospatialMapConfiguration`](crate::model::GeospatialMapConfiguration).
    pub fn builder() -> crate::model::geospatial_map_configuration::Builder {
        crate::model::geospatial_map_configuration::Builder::default()
    }
}

/// <p>The point style of the geospatial map.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GeospatialPointStyleOptions {
    /// <p>The selected point styles (point, cluster) of the geospatial map.</p>
    #[doc(hidden)]
    pub selected_point_style: std::option::Option<crate::model::GeospatialSelectedPointStyle>,
    /// <p>The cluster marker configuration of the geospatial point style.</p>
    #[doc(hidden)]
    pub cluster_marker_configuration: std::option::Option<crate::model::ClusterMarkerConfiguration>,
}
impl GeospatialPointStyleOptions {
    /// <p>The selected point styles (point, cluster) of the geospatial map.</p>
    pub fn selected_point_style(
        &self,
    ) -> std::option::Option<&crate::model::GeospatialSelectedPointStyle> {
        self.selected_point_style.as_ref()
    }
    /// <p>The cluster marker configuration of the geospatial point style.</p>
    pub fn cluster_marker_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ClusterMarkerConfiguration> {
        self.cluster_marker_configuration.as_ref()
    }
}
/// See [`GeospatialPointStyleOptions`](crate::model::GeospatialPointStyleOptions).
pub mod geospatial_point_style_options {

    /// A builder for [`GeospatialPointStyleOptions`](crate::model::GeospatialPointStyleOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) selected_point_style:
            std::option::Option<crate::model::GeospatialSelectedPointStyle>,
        pub(crate) cluster_marker_configuration:
            std::option::Option<crate::model::ClusterMarkerConfiguration>,
    }
    impl Builder {
        /// <p>The selected point styles (point, cluster) of the geospatial map.</p>
        pub fn selected_point_style(
            mut self,
            input: crate::model::GeospatialSelectedPointStyle,
        ) -> Self {
            self.selected_point_style = Some(input);
            self
        }
        /// <p>The selected point styles (point, cluster) of the geospatial map.</p>
        pub fn set_selected_point_style(
            mut self,
            input: std::option::Option<crate::model::GeospatialSelectedPointStyle>,
        ) -> Self {
            self.selected_point_style = input;
            self
        }
        /// <p>The cluster marker configuration of the geospatial point style.</p>
        pub fn cluster_marker_configuration(
            mut self,
            input: crate::model::ClusterMarkerConfiguration,
        ) -> Self {
            self.cluster_marker_configuration = Some(input);
            self
        }
        /// <p>The cluster marker configuration of the geospatial point style.</p>
        pub fn set_cluster_marker_configuration(
            mut self,
            input: std::option::Option<crate::model::ClusterMarkerConfiguration>,
        ) -> Self {
            self.cluster_marker_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`GeospatialPointStyleOptions`](crate::model::GeospatialPointStyleOptions).
        pub fn build(self) -> crate::model::GeospatialPointStyleOptions {
            crate::model::GeospatialPointStyleOptions {
                selected_point_style: self.selected_point_style,
                cluster_marker_configuration: self.cluster_marker_configuration,
            }
        }
    }
}
impl GeospatialPointStyleOptions {
    /// Creates a new builder-style object to manufacture [`GeospatialPointStyleOptions`](crate::model::GeospatialPointStyleOptions).
    pub fn builder() -> crate::model::geospatial_point_style_options::Builder {
        crate::model::geospatial_point_style_options::Builder::default()
    }
}

/// <p>The cluster marker configuration of the geospatial map selected point style.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterMarkerConfiguration {
    /// <p>The cluster marker that is a part of the cluster marker configuration</p>
    #[doc(hidden)]
    pub cluster_marker: std::option::Option<crate::model::ClusterMarker>,
}
impl ClusterMarkerConfiguration {
    /// <p>The cluster marker that is a part of the cluster marker configuration</p>
    pub fn cluster_marker(&self) -> std::option::Option<&crate::model::ClusterMarker> {
        self.cluster_marker.as_ref()
    }
}
/// See [`ClusterMarkerConfiguration`](crate::model::ClusterMarkerConfiguration).
pub mod cluster_marker_configuration {

    /// A builder for [`ClusterMarkerConfiguration`](crate::model::ClusterMarkerConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_marker: std::option::Option<crate::model::ClusterMarker>,
    }
    impl Builder {
        /// <p>The cluster marker that is a part of the cluster marker configuration</p>
        pub fn cluster_marker(mut self, input: crate::model::ClusterMarker) -> Self {
            self.cluster_marker = Some(input);
            self
        }
        /// <p>The cluster marker that is a part of the cluster marker configuration</p>
        pub fn set_cluster_marker(
            mut self,
            input: std::option::Option<crate::model::ClusterMarker>,
        ) -> Self {
            self.cluster_marker = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterMarkerConfiguration`](crate::model::ClusterMarkerConfiguration).
        pub fn build(self) -> crate::model::ClusterMarkerConfiguration {
            crate::model::ClusterMarkerConfiguration {
                cluster_marker: self.cluster_marker,
            }
        }
    }
}
impl ClusterMarkerConfiguration {
    /// Creates a new builder-style object to manufacture [`ClusterMarkerConfiguration`](crate::model::ClusterMarkerConfiguration).
    pub fn builder() -> crate::model::cluster_marker_configuration::Builder {
        crate::model::cluster_marker_configuration::Builder::default()
    }
}

/// <p>The cluster marker that is a part of the cluster marker configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterMarker {
    /// <p>The simple cluster marker of the cluster marker.</p>
    #[doc(hidden)]
    pub simple_cluster_marker: std::option::Option<crate::model::SimpleClusterMarker>,
}
impl ClusterMarker {
    /// <p>The simple cluster marker of the cluster marker.</p>
    pub fn simple_cluster_marker(&self) -> std::option::Option<&crate::model::SimpleClusterMarker> {
        self.simple_cluster_marker.as_ref()
    }
}
/// See [`ClusterMarker`](crate::model::ClusterMarker).
pub mod cluster_marker {

    /// A builder for [`ClusterMarker`](crate::model::ClusterMarker).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) simple_cluster_marker: std::option::Option<crate::model::SimpleClusterMarker>,
    }
    impl Builder {
        /// <p>The simple cluster marker of the cluster marker.</p>
        pub fn simple_cluster_marker(mut self, input: crate::model::SimpleClusterMarker) -> Self {
            self.simple_cluster_marker = Some(input);
            self
        }
        /// <p>The simple cluster marker of the cluster marker.</p>
        pub fn set_simple_cluster_marker(
            mut self,
            input: std::option::Option<crate::model::SimpleClusterMarker>,
        ) -> Self {
            self.simple_cluster_marker = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterMarker`](crate::model::ClusterMarker).
        pub fn build(self) -> crate::model::ClusterMarker {
            crate::model::ClusterMarker {
                simple_cluster_marker: self.simple_cluster_marker,
            }
        }
    }
}
impl ClusterMarker {
    /// Creates a new builder-style object to manufacture [`ClusterMarker`](crate::model::ClusterMarker).
    pub fn builder() -> crate::model::cluster_marker::Builder {
        crate::model::cluster_marker::Builder::default()
    }
}

/// <p>The simple cluster marker of the cluster marker.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SimpleClusterMarker {
    /// <p>The color of the simple cluster marker.</p>
    #[doc(hidden)]
    pub color: std::option::Option<std::string::String>,
}
impl SimpleClusterMarker {
    /// <p>The color of the simple cluster marker.</p>
    pub fn color(&self) -> std::option::Option<&str> {
        self.color.as_deref()
    }
}
/// See [`SimpleClusterMarker`](crate::model::SimpleClusterMarker).
pub mod simple_cluster_marker {

    /// A builder for [`SimpleClusterMarker`](crate::model::SimpleClusterMarker).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) color: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The color of the simple cluster marker.</p>
        pub fn color(mut self, input: impl Into<std::string::String>) -> Self {
            self.color = Some(input.into());
            self
        }
        /// <p>The color of the simple cluster marker.</p>
        pub fn set_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.color = input;
            self
        }
        /// Consumes the builder and constructs a [`SimpleClusterMarker`](crate::model::SimpleClusterMarker).
        pub fn build(self) -> crate::model::SimpleClusterMarker {
            crate::model::SimpleClusterMarker { color: self.color }
        }
    }
}
impl SimpleClusterMarker {
    /// Creates a new builder-style object to manufacture [`SimpleClusterMarker`](crate::model::SimpleClusterMarker).
    pub fn builder() -> crate::model::simple_cluster_marker::Builder {
        crate::model::simple_cluster_marker::Builder::default()
    }
}

/// When writing a match expression against `GeospatialSelectedPointStyle`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let geospatialselectedpointstyle = unimplemented!();
/// match geospatialselectedpointstyle {
///     GeospatialSelectedPointStyle::Cluster => { /* ... */ },
///     GeospatialSelectedPointStyle::Point => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `geospatialselectedpointstyle` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `GeospatialSelectedPointStyle::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `GeospatialSelectedPointStyle::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `GeospatialSelectedPointStyle::NewFeature` is defined.
/// Specifically, when `geospatialselectedpointstyle` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `GeospatialSelectedPointStyle::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GeospatialSelectedPointStyle {
    #[allow(missing_docs)] // documentation missing in model
    Cluster,
    #[allow(missing_docs)] // documentation missing in model
    Point,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for GeospatialSelectedPointStyle {
    fn from(s: &str) -> Self {
        match s {
            "CLUSTER" => GeospatialSelectedPointStyle::Cluster,
            "POINT" => GeospatialSelectedPointStyle::Point,
            other => GeospatialSelectedPointStyle::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for GeospatialSelectedPointStyle {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(GeospatialSelectedPointStyle::from(s))
    }
}
impl GeospatialSelectedPointStyle {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            GeospatialSelectedPointStyle::Cluster => "CLUSTER",
            GeospatialSelectedPointStyle::Point => "POINT",
            GeospatialSelectedPointStyle::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CLUSTER", "POINT"]
    }
}
impl AsRef<str> for GeospatialSelectedPointStyle {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The field wells of a <code>GeospatialMapVisual</code>.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GeospatialMapFieldWells {
    /// <p>The aggregated field well for a geospatial map.</p>
    #[doc(hidden)]
    pub geospatial_map_aggregated_field_wells:
        std::option::Option<crate::model::GeospatialMapAggregatedFieldWells>,
}
impl GeospatialMapFieldWells {
    /// <p>The aggregated field well for a geospatial map.</p>
    pub fn geospatial_map_aggregated_field_wells(
        &self,
    ) -> std::option::Option<&crate::model::GeospatialMapAggregatedFieldWells> {
        self.geospatial_map_aggregated_field_wells.as_ref()
    }
}
/// See [`GeospatialMapFieldWells`](crate::model::GeospatialMapFieldWells).
pub mod geospatial_map_field_wells {

    /// A builder for [`GeospatialMapFieldWells`](crate::model::GeospatialMapFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) geospatial_map_aggregated_field_wells:
            std::option::Option<crate::model::GeospatialMapAggregatedFieldWells>,
    }
    impl Builder {
        /// <p>The aggregated field well for a geospatial map.</p>
        pub fn geospatial_map_aggregated_field_wells(
            mut self,
            input: crate::model::GeospatialMapAggregatedFieldWells,
        ) -> Self {
            self.geospatial_map_aggregated_field_wells = Some(input);
            self
        }
        /// <p>The aggregated field well for a geospatial map.</p>
        pub fn set_geospatial_map_aggregated_field_wells(
            mut self,
            input: std::option::Option<crate::model::GeospatialMapAggregatedFieldWells>,
        ) -> Self {
            self.geospatial_map_aggregated_field_wells = input;
            self
        }
        /// Consumes the builder and constructs a [`GeospatialMapFieldWells`](crate::model::GeospatialMapFieldWells).
        pub fn build(self) -> crate::model::GeospatialMapFieldWells {
            crate::model::GeospatialMapFieldWells {
                geospatial_map_aggregated_field_wells: self.geospatial_map_aggregated_field_wells,
            }
        }
    }
}
impl GeospatialMapFieldWells {
    /// Creates a new builder-style object to manufacture [`GeospatialMapFieldWells`](crate::model::GeospatialMapFieldWells).
    pub fn builder() -> crate::model::geospatial_map_field_wells::Builder {
        crate::model::geospatial_map_field_wells::Builder::default()
    }
}

/// <p>The aggregated field wells for a geospatial map.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GeospatialMapAggregatedFieldWells {
    /// <p>The geospatial field wells of a geospatial map. Values are grouped by geospatial fields.</p>
    #[doc(hidden)]
    pub geospatial: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The size field wells of a geospatial map. Values are aggregated based on geospatial fields.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    /// <p>The color field wells of a geospatial map.</p>
    #[doc(hidden)]
    pub colors: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
}
impl GeospatialMapAggregatedFieldWells {
    /// <p>The geospatial field wells of a geospatial map. Values are grouped by geospatial fields.</p>
    pub fn geospatial(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.geospatial.as_deref()
    }
    /// <p>The size field wells of a geospatial map. Values are aggregated based on geospatial fields.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.values.as_deref()
    }
    /// <p>The color field wells of a geospatial map.</p>
    pub fn colors(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.colors.as_deref()
    }
}
/// See [`GeospatialMapAggregatedFieldWells`](crate::model::GeospatialMapAggregatedFieldWells).
pub mod geospatial_map_aggregated_field_wells {

    /// A builder for [`GeospatialMapAggregatedFieldWells`](crate::model::GeospatialMapAggregatedFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) geospatial: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        pub(crate) colors: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    }
    impl Builder {
        /// Appends an item to `geospatial`.
        ///
        /// To override the contents of this collection use [`set_geospatial`](Self::set_geospatial).
        ///
        /// <p>The geospatial field wells of a geospatial map. Values are grouped by geospatial fields.</p>
        pub fn geospatial(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.geospatial.unwrap_or_default();
            v.push(input);
            self.geospatial = Some(v);
            self
        }
        /// <p>The geospatial field wells of a geospatial map. Values are grouped by geospatial fields.</p>
        pub fn set_geospatial(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.geospatial = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The size field wells of a geospatial map. Values are aggregated based on geospatial fields.</p>
        pub fn values(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>The size field wells of a geospatial map. Values are aggregated based on geospatial fields.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Appends an item to `colors`.
        ///
        /// To override the contents of this collection use [`set_colors`](Self::set_colors).
        ///
        /// <p>The color field wells of a geospatial map.</p>
        pub fn colors(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.colors.unwrap_or_default();
            v.push(input);
            self.colors = Some(v);
            self
        }
        /// <p>The color field wells of a geospatial map.</p>
        pub fn set_colors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.colors = input;
            self
        }
        /// Consumes the builder and constructs a [`GeospatialMapAggregatedFieldWells`](crate::model::GeospatialMapAggregatedFieldWells).
        pub fn build(self) -> crate::model::GeospatialMapAggregatedFieldWells {
            crate::model::GeospatialMapAggregatedFieldWells {
                geospatial: self.geospatial,
                values: self.values,
                colors: self.colors,
            }
        }
    }
}
impl GeospatialMapAggregatedFieldWells {
    /// Creates a new builder-style object to manufacture [`GeospatialMapAggregatedFieldWells`](crate::model::GeospatialMapAggregatedFieldWells).
    pub fn builder() -> crate::model::geospatial_map_aggregated_field_wells::Builder {
        crate::model::geospatial_map_aggregated_field_wells::Builder::default()
    }
}

/// <p>A tree map.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/tree-map.html">Using tree maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TreeMapVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration settings of the visual.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::TreeMapConfiguration>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    #[doc(hidden)]
    pub column_hierarchies: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
}
impl TreeMapVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration settings of the visual.</p>
    pub fn chart_configuration(&self) -> std::option::Option<&crate::model::TreeMapConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    pub fn column_hierarchies(&self) -> std::option::Option<&[crate::model::ColumnHierarchy]> {
        self.column_hierarchies.as_deref()
    }
}
/// See [`TreeMapVisual`](crate::model::TreeMapVisual).
pub mod tree_map_visual {

    /// A builder for [`TreeMapVisual`](crate::model::TreeMapVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration: std::option::Option<crate::model::TreeMapConfiguration>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        pub(crate) column_hierarchies:
            std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn chart_configuration(mut self, input: crate::model::TreeMapConfiguration) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::TreeMapConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Appends an item to `column_hierarchies`.
        ///
        /// To override the contents of this collection use [`set_column_hierarchies`](Self::set_column_hierarchies).
        ///
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn column_hierarchies(mut self, input: crate::model::ColumnHierarchy) -> Self {
            let mut v = self.column_hierarchies.unwrap_or_default();
            v.push(input);
            self.column_hierarchies = Some(v);
            self
        }
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn set_column_hierarchies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
        ) -> Self {
            self.column_hierarchies = input;
            self
        }
        /// Consumes the builder and constructs a [`TreeMapVisual`](crate::model::TreeMapVisual).
        pub fn build(self) -> crate::model::TreeMapVisual {
            crate::model::TreeMapVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                actions: self.actions,
                column_hierarchies: self.column_hierarchies,
            }
        }
    }
}
impl TreeMapVisual {
    /// Creates a new builder-style object to manufacture [`TreeMapVisual`](crate::model::TreeMapVisual).
    pub fn builder() -> crate::model::tree_map_visual::Builder {
        crate::model::tree_map_visual::Builder::default()
    }
}

/// <p>The configuration of a tree map.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TreeMapConfiguration {
    /// <p>The field wells of the visual.</p>
    #[doc(hidden)]
    pub field_wells: std::option::Option<crate::model::TreeMapFieldWells>,
    /// <p>The sort configuration of a tree map.</p>
    #[doc(hidden)]
    pub sort_configuration: std::option::Option<crate::model::TreeMapSortConfiguration>,
    /// <p>The label options (label text, label visibility) of the groups that are displayed in a tree map.</p>
    #[doc(hidden)]
    pub group_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The label options (label text, label visibility) of the sizes that are displayed in a tree map.</p>
    #[doc(hidden)]
    pub size_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The label options (label text, label visibility) for the colors displayed in a tree map.</p>
    #[doc(hidden)]
    pub color_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The color options (gradient color, point of divergence) of a tree map.</p>
    #[doc(hidden)]
    pub color_scale: std::option::Option<crate::model::ColorScale>,
    /// <p>The legend display setup of the visual.</p>
    #[doc(hidden)]
    pub legend: std::option::Option<crate::model::LegendOptions>,
    /// <p>The options that determine if visual data labels are displayed.</p>
    #[doc(hidden)]
    pub data_labels: std::option::Option<crate::model::DataLabelOptions>,
    /// <p>The tooltip display setup of the visual.</p>
    #[doc(hidden)]
    pub tooltip: std::option::Option<crate::model::TooltipOptions>,
}
impl TreeMapConfiguration {
    /// <p>The field wells of the visual.</p>
    pub fn field_wells(&self) -> std::option::Option<&crate::model::TreeMapFieldWells> {
        self.field_wells.as_ref()
    }
    /// <p>The sort configuration of a tree map.</p>
    pub fn sort_configuration(
        &self,
    ) -> std::option::Option<&crate::model::TreeMapSortConfiguration> {
        self.sort_configuration.as_ref()
    }
    /// <p>The label options (label text, label visibility) of the groups that are displayed in a tree map.</p>
    pub fn group_label_options(&self) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.group_label_options.as_ref()
    }
    /// <p>The label options (label text, label visibility) of the sizes that are displayed in a tree map.</p>
    pub fn size_label_options(&self) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.size_label_options.as_ref()
    }
    /// <p>The label options (label text, label visibility) for the colors displayed in a tree map.</p>
    pub fn color_label_options(&self) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.color_label_options.as_ref()
    }
    /// <p>The color options (gradient color, point of divergence) of a tree map.</p>
    pub fn color_scale(&self) -> std::option::Option<&crate::model::ColorScale> {
        self.color_scale.as_ref()
    }
    /// <p>The legend display setup of the visual.</p>
    pub fn legend(&self) -> std::option::Option<&crate::model::LegendOptions> {
        self.legend.as_ref()
    }
    /// <p>The options that determine if visual data labels are displayed.</p>
    pub fn data_labels(&self) -> std::option::Option<&crate::model::DataLabelOptions> {
        self.data_labels.as_ref()
    }
    /// <p>The tooltip display setup of the visual.</p>
    pub fn tooltip(&self) -> std::option::Option<&crate::model::TooltipOptions> {
        self.tooltip.as_ref()
    }
}
/// See [`TreeMapConfiguration`](crate::model::TreeMapConfiguration).
pub mod tree_map_configuration {

    /// A builder for [`TreeMapConfiguration`](crate::model::TreeMapConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_wells: std::option::Option<crate::model::TreeMapFieldWells>,
        pub(crate) sort_configuration: std::option::Option<crate::model::TreeMapSortConfiguration>,
        pub(crate) group_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) size_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) color_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) color_scale: std::option::Option<crate::model::ColorScale>,
        pub(crate) legend: std::option::Option<crate::model::LegendOptions>,
        pub(crate) data_labels: std::option::Option<crate::model::DataLabelOptions>,
        pub(crate) tooltip: std::option::Option<crate::model::TooltipOptions>,
    }
    impl Builder {
        /// <p>The field wells of the visual.</p>
        pub fn field_wells(mut self, input: crate::model::TreeMapFieldWells) -> Self {
            self.field_wells = Some(input);
            self
        }
        /// <p>The field wells of the visual.</p>
        pub fn set_field_wells(
            mut self,
            input: std::option::Option<crate::model::TreeMapFieldWells>,
        ) -> Self {
            self.field_wells = input;
            self
        }
        /// <p>The sort configuration of a tree map.</p>
        pub fn sort_configuration(mut self, input: crate::model::TreeMapSortConfiguration) -> Self {
            self.sort_configuration = Some(input);
            self
        }
        /// <p>The sort configuration of a tree map.</p>
        pub fn set_sort_configuration(
            mut self,
            input: std::option::Option<crate::model::TreeMapSortConfiguration>,
        ) -> Self {
            self.sort_configuration = input;
            self
        }
        /// <p>The label options (label text, label visibility) of the groups that are displayed in a tree map.</p>
        pub fn group_label_options(mut self, input: crate::model::ChartAxisLabelOptions) -> Self {
            self.group_label_options = Some(input);
            self
        }
        /// <p>The label options (label text, label visibility) of the groups that are displayed in a tree map.</p>
        pub fn set_group_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.group_label_options = input;
            self
        }
        /// <p>The label options (label text, label visibility) of the sizes that are displayed in a tree map.</p>
        pub fn size_label_options(mut self, input: crate::model::ChartAxisLabelOptions) -> Self {
            self.size_label_options = Some(input);
            self
        }
        /// <p>The label options (label text, label visibility) of the sizes that are displayed in a tree map.</p>
        pub fn set_size_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.size_label_options = input;
            self
        }
        /// <p>The label options (label text, label visibility) for the colors displayed in a tree map.</p>
        pub fn color_label_options(mut self, input: crate::model::ChartAxisLabelOptions) -> Self {
            self.color_label_options = Some(input);
            self
        }
        /// <p>The label options (label text, label visibility) for the colors displayed in a tree map.</p>
        pub fn set_color_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.color_label_options = input;
            self
        }
        /// <p>The color options (gradient color, point of divergence) of a tree map.</p>
        pub fn color_scale(mut self, input: crate::model::ColorScale) -> Self {
            self.color_scale = Some(input);
            self
        }
        /// <p>The color options (gradient color, point of divergence) of a tree map.</p>
        pub fn set_color_scale(
            mut self,
            input: std::option::Option<crate::model::ColorScale>,
        ) -> Self {
            self.color_scale = input;
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn legend(mut self, input: crate::model::LegendOptions) -> Self {
            self.legend = Some(input);
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn set_legend(
            mut self,
            input: std::option::Option<crate::model::LegendOptions>,
        ) -> Self {
            self.legend = input;
            self
        }
        /// <p>The options that determine if visual data labels are displayed.</p>
        pub fn data_labels(mut self, input: crate::model::DataLabelOptions) -> Self {
            self.data_labels = Some(input);
            self
        }
        /// <p>The options that determine if visual data labels are displayed.</p>
        pub fn set_data_labels(
            mut self,
            input: std::option::Option<crate::model::DataLabelOptions>,
        ) -> Self {
            self.data_labels = input;
            self
        }
        /// <p>The tooltip display setup of the visual.</p>
        pub fn tooltip(mut self, input: crate::model::TooltipOptions) -> Self {
            self.tooltip = Some(input);
            self
        }
        /// <p>The tooltip display setup of the visual.</p>
        pub fn set_tooltip(
            mut self,
            input: std::option::Option<crate::model::TooltipOptions>,
        ) -> Self {
            self.tooltip = input;
            self
        }
        /// Consumes the builder and constructs a [`TreeMapConfiguration`](crate::model::TreeMapConfiguration).
        pub fn build(self) -> crate::model::TreeMapConfiguration {
            crate::model::TreeMapConfiguration {
                field_wells: self.field_wells,
                sort_configuration: self.sort_configuration,
                group_label_options: self.group_label_options,
                size_label_options: self.size_label_options,
                color_label_options: self.color_label_options,
                color_scale: self.color_scale,
                legend: self.legend,
                data_labels: self.data_labels,
                tooltip: self.tooltip,
            }
        }
    }
}
impl TreeMapConfiguration {
    /// Creates a new builder-style object to manufacture [`TreeMapConfiguration`](crate::model::TreeMapConfiguration).
    pub fn builder() -> crate::model::tree_map_configuration::Builder {
        crate::model::tree_map_configuration::Builder::default()
    }
}

/// <p>Determines the color scale that is applied to the visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColorScale {
    /// <p>Determines the list of colors that are applied to the visual.</p>
    #[doc(hidden)]
    pub colors: std::option::Option<std::vec::Vec<crate::model::DataColor>>,
    /// <p>Determines the color fill type.</p>
    #[doc(hidden)]
    pub color_fill_type: std::option::Option<crate::model::ColorFillType>,
    /// <p>Determines the color that is applied to null values.</p>
    #[doc(hidden)]
    pub null_value_color: std::option::Option<crate::model::DataColor>,
}
impl ColorScale {
    /// <p>Determines the list of colors that are applied to the visual.</p>
    pub fn colors(&self) -> std::option::Option<&[crate::model::DataColor]> {
        self.colors.as_deref()
    }
    /// <p>Determines the color fill type.</p>
    pub fn color_fill_type(&self) -> std::option::Option<&crate::model::ColorFillType> {
        self.color_fill_type.as_ref()
    }
    /// <p>Determines the color that is applied to null values.</p>
    pub fn null_value_color(&self) -> std::option::Option<&crate::model::DataColor> {
        self.null_value_color.as_ref()
    }
}
/// See [`ColorScale`](crate::model::ColorScale).
pub mod color_scale {

    /// A builder for [`ColorScale`](crate::model::ColorScale).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) colors: std::option::Option<std::vec::Vec<crate::model::DataColor>>,
        pub(crate) color_fill_type: std::option::Option<crate::model::ColorFillType>,
        pub(crate) null_value_color: std::option::Option<crate::model::DataColor>,
    }
    impl Builder {
        /// Appends an item to `colors`.
        ///
        /// To override the contents of this collection use [`set_colors`](Self::set_colors).
        ///
        /// <p>Determines the list of colors that are applied to the visual.</p>
        pub fn colors(mut self, input: crate::model::DataColor) -> Self {
            let mut v = self.colors.unwrap_or_default();
            v.push(input);
            self.colors = Some(v);
            self
        }
        /// <p>Determines the list of colors that are applied to the visual.</p>
        pub fn set_colors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataColor>>,
        ) -> Self {
            self.colors = input;
            self
        }
        /// <p>Determines the color fill type.</p>
        pub fn color_fill_type(mut self, input: crate::model::ColorFillType) -> Self {
            self.color_fill_type = Some(input);
            self
        }
        /// <p>Determines the color fill type.</p>
        pub fn set_color_fill_type(
            mut self,
            input: std::option::Option<crate::model::ColorFillType>,
        ) -> Self {
            self.color_fill_type = input;
            self
        }
        /// <p>Determines the color that is applied to null values.</p>
        pub fn null_value_color(mut self, input: crate::model::DataColor) -> Self {
            self.null_value_color = Some(input);
            self
        }
        /// <p>Determines the color that is applied to null values.</p>
        pub fn set_null_value_color(
            mut self,
            input: std::option::Option<crate::model::DataColor>,
        ) -> Self {
            self.null_value_color = input;
            self
        }
        /// Consumes the builder and constructs a [`ColorScale`](crate::model::ColorScale).
        pub fn build(self) -> crate::model::ColorScale {
            crate::model::ColorScale {
                colors: self.colors,
                color_fill_type: self.color_fill_type,
                null_value_color: self.null_value_color,
            }
        }
    }
}
impl ColorScale {
    /// Creates a new builder-style object to manufacture [`ColorScale`](crate::model::ColorScale).
    pub fn builder() -> crate::model::color_scale::Builder {
        crate::model::color_scale::Builder::default()
    }
}

/// <p>Determines the color that is applied to a particular data value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataColor {
    /// <p>The color that is applied to the data value.</p>
    #[doc(hidden)]
    pub color: std::option::Option<std::string::String>,
    /// <p>The data value that the color is applied to.</p>
    #[doc(hidden)]
    pub data_value: std::option::Option<f64>,
}
impl DataColor {
    /// <p>The color that is applied to the data value.</p>
    pub fn color(&self) -> std::option::Option<&str> {
        self.color.as_deref()
    }
    /// <p>The data value that the color is applied to.</p>
    pub fn data_value(&self) -> std::option::Option<f64> {
        self.data_value
    }
}
/// See [`DataColor`](crate::model::DataColor).
pub mod data_color {

    /// A builder for [`DataColor`](crate::model::DataColor).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) color: std::option::Option<std::string::String>,
        pub(crate) data_value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The color that is applied to the data value.</p>
        pub fn color(mut self, input: impl Into<std::string::String>) -> Self {
            self.color = Some(input.into());
            self
        }
        /// <p>The color that is applied to the data value.</p>
        pub fn set_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.color = input;
            self
        }
        /// <p>The data value that the color is applied to.</p>
        pub fn data_value(mut self, input: f64) -> Self {
            self.data_value = Some(input);
            self
        }
        /// <p>The data value that the color is applied to.</p>
        pub fn set_data_value(mut self, input: std::option::Option<f64>) -> Self {
            self.data_value = input;
            self
        }
        /// Consumes the builder and constructs a [`DataColor`](crate::model::DataColor).
        pub fn build(self) -> crate::model::DataColor {
            crate::model::DataColor {
                color: self.color,
                data_value: self.data_value,
            }
        }
    }
}
impl DataColor {
    /// Creates a new builder-style object to manufacture [`DataColor`](crate::model::DataColor).
    pub fn builder() -> crate::model::data_color::Builder {
        crate::model::data_color::Builder::default()
    }
}

/// When writing a match expression against `ColorFillType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let colorfilltype = unimplemented!();
/// match colorfilltype {
///     ColorFillType::Discrete => { /* ... */ },
///     ColorFillType::Gradient => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `colorfilltype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ColorFillType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ColorFillType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ColorFillType::NewFeature` is defined.
/// Specifically, when `colorfilltype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ColorFillType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ColorFillType {
    #[allow(missing_docs)] // documentation missing in model
    Discrete,
    #[allow(missing_docs)] // documentation missing in model
    Gradient,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ColorFillType {
    fn from(s: &str) -> Self {
        match s {
            "DISCRETE" => ColorFillType::Discrete,
            "GRADIENT" => ColorFillType::Gradient,
            other => ColorFillType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ColorFillType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ColorFillType::from(s))
    }
}
impl ColorFillType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ColorFillType::Discrete => "DISCRETE",
            ColorFillType::Gradient => "GRADIENT",
            ColorFillType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISCRETE", "GRADIENT"]
    }
}
impl AsRef<str> for ColorFillType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The sort configuration of a tree map.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TreeMapSortConfiguration {
    /// <p>The sort configuration of group by fields.</p>
    #[doc(hidden)]
    pub tree_map_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    /// <p>The limit on the number of groups that are displayed.</p>
    #[doc(hidden)]
    pub tree_map_group_items_limit_configuration:
        std::option::Option<crate::model::ItemsLimitConfiguration>,
}
impl TreeMapSortConfiguration {
    /// <p>The sort configuration of group by fields.</p>
    pub fn tree_map_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.tree_map_sort.as_deref()
    }
    /// <p>The limit on the number of groups that are displayed.</p>
    pub fn tree_map_group_items_limit_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ItemsLimitConfiguration> {
        self.tree_map_group_items_limit_configuration.as_ref()
    }
}
/// See [`TreeMapSortConfiguration`](crate::model::TreeMapSortConfiguration).
pub mod tree_map_sort_configuration {

    /// A builder for [`TreeMapSortConfiguration`](crate::model::TreeMapSortConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tree_map_sort:
            std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        pub(crate) tree_map_group_items_limit_configuration:
            std::option::Option<crate::model::ItemsLimitConfiguration>,
    }
    impl Builder {
        /// Appends an item to `tree_map_sort`.
        ///
        /// To override the contents of this collection use [`set_tree_map_sort`](Self::set_tree_map_sort).
        ///
        /// <p>The sort configuration of group by fields.</p>
        pub fn tree_map_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.tree_map_sort.unwrap_or_default();
            v.push(input);
            self.tree_map_sort = Some(v);
            self
        }
        /// <p>The sort configuration of group by fields.</p>
        pub fn set_tree_map_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.tree_map_sort = input;
            self
        }
        /// <p>The limit on the number of groups that are displayed.</p>
        pub fn tree_map_group_items_limit_configuration(
            mut self,
            input: crate::model::ItemsLimitConfiguration,
        ) -> Self {
            self.tree_map_group_items_limit_configuration = Some(input);
            self
        }
        /// <p>The limit on the number of groups that are displayed.</p>
        pub fn set_tree_map_group_items_limit_configuration(
            mut self,
            input: std::option::Option<crate::model::ItemsLimitConfiguration>,
        ) -> Self {
            self.tree_map_group_items_limit_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`TreeMapSortConfiguration`](crate::model::TreeMapSortConfiguration).
        pub fn build(self) -> crate::model::TreeMapSortConfiguration {
            crate::model::TreeMapSortConfiguration {
                tree_map_sort: self.tree_map_sort,
                tree_map_group_items_limit_configuration: self
                    .tree_map_group_items_limit_configuration,
            }
        }
    }
}
impl TreeMapSortConfiguration {
    /// Creates a new builder-style object to manufacture [`TreeMapSortConfiguration`](crate::model::TreeMapSortConfiguration).
    pub fn builder() -> crate::model::tree_map_sort_configuration::Builder {
        crate::model::tree_map_sort_configuration::Builder::default()
    }
}

/// <p>The field wells of a tree map.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TreeMapFieldWells {
    /// <p>The aggregated field wells of a tree map.</p>
    #[doc(hidden)]
    pub tree_map_aggregated_field_wells:
        std::option::Option<crate::model::TreeMapAggregatedFieldWells>,
}
impl TreeMapFieldWells {
    /// <p>The aggregated field wells of a tree map.</p>
    pub fn tree_map_aggregated_field_wells(
        &self,
    ) -> std::option::Option<&crate::model::TreeMapAggregatedFieldWells> {
        self.tree_map_aggregated_field_wells.as_ref()
    }
}
/// See [`TreeMapFieldWells`](crate::model::TreeMapFieldWells).
pub mod tree_map_field_wells {

    /// A builder for [`TreeMapFieldWells`](crate::model::TreeMapFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tree_map_aggregated_field_wells:
            std::option::Option<crate::model::TreeMapAggregatedFieldWells>,
    }
    impl Builder {
        /// <p>The aggregated field wells of a tree map.</p>
        pub fn tree_map_aggregated_field_wells(
            mut self,
            input: crate::model::TreeMapAggregatedFieldWells,
        ) -> Self {
            self.tree_map_aggregated_field_wells = Some(input);
            self
        }
        /// <p>The aggregated field wells of a tree map.</p>
        pub fn set_tree_map_aggregated_field_wells(
            mut self,
            input: std::option::Option<crate::model::TreeMapAggregatedFieldWells>,
        ) -> Self {
            self.tree_map_aggregated_field_wells = input;
            self
        }
        /// Consumes the builder and constructs a [`TreeMapFieldWells`](crate::model::TreeMapFieldWells).
        pub fn build(self) -> crate::model::TreeMapFieldWells {
            crate::model::TreeMapFieldWells {
                tree_map_aggregated_field_wells: self.tree_map_aggregated_field_wells,
            }
        }
    }
}
impl TreeMapFieldWells {
    /// Creates a new builder-style object to manufacture [`TreeMapFieldWells`](crate::model::TreeMapFieldWells).
    pub fn builder() -> crate::model::tree_map_field_wells::Builder {
        crate::model::tree_map_field_wells::Builder::default()
    }
}

/// <p>Aggregated field wells of a tree map.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TreeMapAggregatedFieldWells {
    /// <p>The group by field well of a tree map. Values are grouped based on group by fields.</p>
    #[doc(hidden)]
    pub groups: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The size field well of a tree map. Values are aggregated based on group by fields.</p>
    #[doc(hidden)]
    pub sizes: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    /// <p>The color field well of a tree map. Values are grouped by aggregations based on group by fields.</p>
    #[doc(hidden)]
    pub colors: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
}
impl TreeMapAggregatedFieldWells {
    /// <p>The group by field well of a tree map. Values are grouped based on group by fields.</p>
    pub fn groups(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.groups.as_deref()
    }
    /// <p>The size field well of a tree map. Values are aggregated based on group by fields.</p>
    pub fn sizes(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.sizes.as_deref()
    }
    /// <p>The color field well of a tree map. Values are grouped by aggregations based on group by fields.</p>
    pub fn colors(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.colors.as_deref()
    }
}
/// See [`TreeMapAggregatedFieldWells`](crate::model::TreeMapAggregatedFieldWells).
pub mod tree_map_aggregated_field_wells {

    /// A builder for [`TreeMapAggregatedFieldWells`](crate::model::TreeMapAggregatedFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) groups: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) sizes: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        pub(crate) colors: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    }
    impl Builder {
        /// Appends an item to `groups`.
        ///
        /// To override the contents of this collection use [`set_groups`](Self::set_groups).
        ///
        /// <p>The group by field well of a tree map. Values are grouped based on group by fields.</p>
        pub fn groups(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input);
            self.groups = Some(v);
            self
        }
        /// <p>The group by field well of a tree map. Values are grouped based on group by fields.</p>
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.groups = input;
            self
        }
        /// Appends an item to `sizes`.
        ///
        /// To override the contents of this collection use [`set_sizes`](Self::set_sizes).
        ///
        /// <p>The size field well of a tree map. Values are aggregated based on group by fields.</p>
        pub fn sizes(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.sizes.unwrap_or_default();
            v.push(input);
            self.sizes = Some(v);
            self
        }
        /// <p>The size field well of a tree map. Values are aggregated based on group by fields.</p>
        pub fn set_sizes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.sizes = input;
            self
        }
        /// Appends an item to `colors`.
        ///
        /// To override the contents of this collection use [`set_colors`](Self::set_colors).
        ///
        /// <p>The color field well of a tree map. Values are grouped by aggregations based on group by fields.</p>
        pub fn colors(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.colors.unwrap_or_default();
            v.push(input);
            self.colors = Some(v);
            self
        }
        /// <p>The color field well of a tree map. Values are grouped by aggregations based on group by fields.</p>
        pub fn set_colors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.colors = input;
            self
        }
        /// Consumes the builder and constructs a [`TreeMapAggregatedFieldWells`](crate::model::TreeMapAggregatedFieldWells).
        pub fn build(self) -> crate::model::TreeMapAggregatedFieldWells {
            crate::model::TreeMapAggregatedFieldWells {
                groups: self.groups,
                sizes: self.sizes,
                colors: self.colors,
            }
        }
    }
}
impl TreeMapAggregatedFieldWells {
    /// Creates a new builder-style object to manufacture [`TreeMapAggregatedFieldWells`](crate::model::TreeMapAggregatedFieldWells).
    pub fn builder() -> crate::model::tree_map_aggregated_field_wells::Builder {
        crate::model::tree_map_aggregated_field_wells::Builder::default()
    }
}

/// <p>A heat map.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/heat-map.html">Using heat maps</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HeatMapVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration of a heat map.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::HeatMapConfiguration>,
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    #[doc(hidden)]
    pub column_hierarchies: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
}
impl HeatMapVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration of a heat map.</p>
    pub fn chart_configuration(&self) -> std::option::Option<&crate::model::HeatMapConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    pub fn column_hierarchies(&self) -> std::option::Option<&[crate::model::ColumnHierarchy]> {
        self.column_hierarchies.as_deref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
}
/// See [`HeatMapVisual`](crate::model::HeatMapVisual).
pub mod heat_map_visual {

    /// A builder for [`HeatMapVisual`](crate::model::HeatMapVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration: std::option::Option<crate::model::HeatMapConfiguration>,
        pub(crate) column_hierarchies:
            std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration of a heat map.</p>
        pub fn chart_configuration(mut self, input: crate::model::HeatMapConfiguration) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration of a heat map.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::HeatMapConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// Appends an item to `column_hierarchies`.
        ///
        /// To override the contents of this collection use [`set_column_hierarchies`](Self::set_column_hierarchies).
        ///
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn column_hierarchies(mut self, input: crate::model::ColumnHierarchy) -> Self {
            let mut v = self.column_hierarchies.unwrap_or_default();
            v.push(input);
            self.column_hierarchies = Some(v);
            self
        }
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn set_column_hierarchies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
        ) -> Self {
            self.column_hierarchies = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Consumes the builder and constructs a [`HeatMapVisual`](crate::model::HeatMapVisual).
        pub fn build(self) -> crate::model::HeatMapVisual {
            crate::model::HeatMapVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                column_hierarchies: self.column_hierarchies,
                actions: self.actions,
            }
        }
    }
}
impl HeatMapVisual {
    /// Creates a new builder-style object to manufacture [`HeatMapVisual`](crate::model::HeatMapVisual).
    pub fn builder() -> crate::model::heat_map_visual::Builder {
        crate::model::heat_map_visual::Builder::default()
    }
}

/// <p>The configuration of a heat map.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HeatMapConfiguration {
    /// <p>The field wells of the visual.</p>
    #[doc(hidden)]
    pub field_wells: std::option::Option<crate::model::HeatMapFieldWells>,
    /// <p>The sort configuration of a heat map.</p>
    #[doc(hidden)]
    pub sort_configuration: std::option::Option<crate::model::HeatMapSortConfiguration>,
    /// <p>The label options of the row that is displayed in a <code>heat map</code>.</p>
    #[doc(hidden)]
    pub row_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The label options of the column that is displayed in a heat map.</p>
    #[doc(hidden)]
    pub column_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The color options (gradient color, point of divergence) in a heat map.</p>
    #[doc(hidden)]
    pub color_scale: std::option::Option<crate::model::ColorScale>,
    /// <p>The legend display setup of the visual.</p>
    #[doc(hidden)]
    pub legend: std::option::Option<crate::model::LegendOptions>,
    /// <p>The options that determine if visual data labels are displayed.</p>
    #[doc(hidden)]
    pub data_labels: std::option::Option<crate::model::DataLabelOptions>,
    /// <p>The tooltip display setup of the visual.</p>
    #[doc(hidden)]
    pub tooltip: std::option::Option<crate::model::TooltipOptions>,
}
impl HeatMapConfiguration {
    /// <p>The field wells of the visual.</p>
    pub fn field_wells(&self) -> std::option::Option<&crate::model::HeatMapFieldWells> {
        self.field_wells.as_ref()
    }
    /// <p>The sort configuration of a heat map.</p>
    pub fn sort_configuration(
        &self,
    ) -> std::option::Option<&crate::model::HeatMapSortConfiguration> {
        self.sort_configuration.as_ref()
    }
    /// <p>The label options of the row that is displayed in a <code>heat map</code>.</p>
    pub fn row_label_options(&self) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.row_label_options.as_ref()
    }
    /// <p>The label options of the column that is displayed in a heat map.</p>
    pub fn column_label_options(
        &self,
    ) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.column_label_options.as_ref()
    }
    /// <p>The color options (gradient color, point of divergence) in a heat map.</p>
    pub fn color_scale(&self) -> std::option::Option<&crate::model::ColorScale> {
        self.color_scale.as_ref()
    }
    /// <p>The legend display setup of the visual.</p>
    pub fn legend(&self) -> std::option::Option<&crate::model::LegendOptions> {
        self.legend.as_ref()
    }
    /// <p>The options that determine if visual data labels are displayed.</p>
    pub fn data_labels(&self) -> std::option::Option<&crate::model::DataLabelOptions> {
        self.data_labels.as_ref()
    }
    /// <p>The tooltip display setup of the visual.</p>
    pub fn tooltip(&self) -> std::option::Option<&crate::model::TooltipOptions> {
        self.tooltip.as_ref()
    }
}
/// See [`HeatMapConfiguration`](crate::model::HeatMapConfiguration).
pub mod heat_map_configuration {

    /// A builder for [`HeatMapConfiguration`](crate::model::HeatMapConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_wells: std::option::Option<crate::model::HeatMapFieldWells>,
        pub(crate) sort_configuration: std::option::Option<crate::model::HeatMapSortConfiguration>,
        pub(crate) row_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) column_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) color_scale: std::option::Option<crate::model::ColorScale>,
        pub(crate) legend: std::option::Option<crate::model::LegendOptions>,
        pub(crate) data_labels: std::option::Option<crate::model::DataLabelOptions>,
        pub(crate) tooltip: std::option::Option<crate::model::TooltipOptions>,
    }
    impl Builder {
        /// <p>The field wells of the visual.</p>
        pub fn field_wells(mut self, input: crate::model::HeatMapFieldWells) -> Self {
            self.field_wells = Some(input);
            self
        }
        /// <p>The field wells of the visual.</p>
        pub fn set_field_wells(
            mut self,
            input: std::option::Option<crate::model::HeatMapFieldWells>,
        ) -> Self {
            self.field_wells = input;
            self
        }
        /// <p>The sort configuration of a heat map.</p>
        pub fn sort_configuration(mut self, input: crate::model::HeatMapSortConfiguration) -> Self {
            self.sort_configuration = Some(input);
            self
        }
        /// <p>The sort configuration of a heat map.</p>
        pub fn set_sort_configuration(
            mut self,
            input: std::option::Option<crate::model::HeatMapSortConfiguration>,
        ) -> Self {
            self.sort_configuration = input;
            self
        }
        /// <p>The label options of the row that is displayed in a <code>heat map</code>.</p>
        pub fn row_label_options(mut self, input: crate::model::ChartAxisLabelOptions) -> Self {
            self.row_label_options = Some(input);
            self
        }
        /// <p>The label options of the row that is displayed in a <code>heat map</code>.</p>
        pub fn set_row_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.row_label_options = input;
            self
        }
        /// <p>The label options of the column that is displayed in a heat map.</p>
        pub fn column_label_options(mut self, input: crate::model::ChartAxisLabelOptions) -> Self {
            self.column_label_options = Some(input);
            self
        }
        /// <p>The label options of the column that is displayed in a heat map.</p>
        pub fn set_column_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.column_label_options = input;
            self
        }
        /// <p>The color options (gradient color, point of divergence) in a heat map.</p>
        pub fn color_scale(mut self, input: crate::model::ColorScale) -> Self {
            self.color_scale = Some(input);
            self
        }
        /// <p>The color options (gradient color, point of divergence) in a heat map.</p>
        pub fn set_color_scale(
            mut self,
            input: std::option::Option<crate::model::ColorScale>,
        ) -> Self {
            self.color_scale = input;
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn legend(mut self, input: crate::model::LegendOptions) -> Self {
            self.legend = Some(input);
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn set_legend(
            mut self,
            input: std::option::Option<crate::model::LegendOptions>,
        ) -> Self {
            self.legend = input;
            self
        }
        /// <p>The options that determine if visual data labels are displayed.</p>
        pub fn data_labels(mut self, input: crate::model::DataLabelOptions) -> Self {
            self.data_labels = Some(input);
            self
        }
        /// <p>The options that determine if visual data labels are displayed.</p>
        pub fn set_data_labels(
            mut self,
            input: std::option::Option<crate::model::DataLabelOptions>,
        ) -> Self {
            self.data_labels = input;
            self
        }
        /// <p>The tooltip display setup of the visual.</p>
        pub fn tooltip(mut self, input: crate::model::TooltipOptions) -> Self {
            self.tooltip = Some(input);
            self
        }
        /// <p>The tooltip display setup of the visual.</p>
        pub fn set_tooltip(
            mut self,
            input: std::option::Option<crate::model::TooltipOptions>,
        ) -> Self {
            self.tooltip = input;
            self
        }
        /// Consumes the builder and constructs a [`HeatMapConfiguration`](crate::model::HeatMapConfiguration).
        pub fn build(self) -> crate::model::HeatMapConfiguration {
            crate::model::HeatMapConfiguration {
                field_wells: self.field_wells,
                sort_configuration: self.sort_configuration,
                row_label_options: self.row_label_options,
                column_label_options: self.column_label_options,
                color_scale: self.color_scale,
                legend: self.legend,
                data_labels: self.data_labels,
                tooltip: self.tooltip,
            }
        }
    }
}
impl HeatMapConfiguration {
    /// Creates a new builder-style object to manufacture [`HeatMapConfiguration`](crate::model::HeatMapConfiguration).
    pub fn builder() -> crate::model::heat_map_configuration::Builder {
        crate::model::heat_map_configuration::Builder::default()
    }
}

/// <p>The sort configuration of a heat map.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HeatMapSortConfiguration {
    /// <p>The field sort configuration of the rows fields.</p>
    #[doc(hidden)]
    pub heat_map_row_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    /// <p>The column sort configuration for heat map for columns that aren't a part of a field well.</p>
    #[doc(hidden)]
    pub heat_map_column_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    /// <p>The limit on the number of rows that are displayed in a heat map.</p>
    #[doc(hidden)]
    pub heat_map_row_items_limit_configuration:
        std::option::Option<crate::model::ItemsLimitConfiguration>,
    /// <p>The limit on the number of columns that are displayed in a heat map.</p>
    #[doc(hidden)]
    pub heat_map_column_items_limit_configuration:
        std::option::Option<crate::model::ItemsLimitConfiguration>,
}
impl HeatMapSortConfiguration {
    /// <p>The field sort configuration of the rows fields.</p>
    pub fn heat_map_row_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.heat_map_row_sort.as_deref()
    }
    /// <p>The column sort configuration for heat map for columns that aren't a part of a field well.</p>
    pub fn heat_map_column_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.heat_map_column_sort.as_deref()
    }
    /// <p>The limit on the number of rows that are displayed in a heat map.</p>
    pub fn heat_map_row_items_limit_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ItemsLimitConfiguration> {
        self.heat_map_row_items_limit_configuration.as_ref()
    }
    /// <p>The limit on the number of columns that are displayed in a heat map.</p>
    pub fn heat_map_column_items_limit_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ItemsLimitConfiguration> {
        self.heat_map_column_items_limit_configuration.as_ref()
    }
}
/// See [`HeatMapSortConfiguration`](crate::model::HeatMapSortConfiguration).
pub mod heat_map_sort_configuration {

    /// A builder for [`HeatMapSortConfiguration`](crate::model::HeatMapSortConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) heat_map_row_sort:
            std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        pub(crate) heat_map_column_sort:
            std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        pub(crate) heat_map_row_items_limit_configuration:
            std::option::Option<crate::model::ItemsLimitConfiguration>,
        pub(crate) heat_map_column_items_limit_configuration:
            std::option::Option<crate::model::ItemsLimitConfiguration>,
    }
    impl Builder {
        /// Appends an item to `heat_map_row_sort`.
        ///
        /// To override the contents of this collection use [`set_heat_map_row_sort`](Self::set_heat_map_row_sort).
        ///
        /// <p>The field sort configuration of the rows fields.</p>
        pub fn heat_map_row_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.heat_map_row_sort.unwrap_or_default();
            v.push(input);
            self.heat_map_row_sort = Some(v);
            self
        }
        /// <p>The field sort configuration of the rows fields.</p>
        pub fn set_heat_map_row_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.heat_map_row_sort = input;
            self
        }
        /// Appends an item to `heat_map_column_sort`.
        ///
        /// To override the contents of this collection use [`set_heat_map_column_sort`](Self::set_heat_map_column_sort).
        ///
        /// <p>The column sort configuration for heat map for columns that aren't a part of a field well.</p>
        pub fn heat_map_column_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.heat_map_column_sort.unwrap_or_default();
            v.push(input);
            self.heat_map_column_sort = Some(v);
            self
        }
        /// <p>The column sort configuration for heat map for columns that aren't a part of a field well.</p>
        pub fn set_heat_map_column_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.heat_map_column_sort = input;
            self
        }
        /// <p>The limit on the number of rows that are displayed in a heat map.</p>
        pub fn heat_map_row_items_limit_configuration(
            mut self,
            input: crate::model::ItemsLimitConfiguration,
        ) -> Self {
            self.heat_map_row_items_limit_configuration = Some(input);
            self
        }
        /// <p>The limit on the number of rows that are displayed in a heat map.</p>
        pub fn set_heat_map_row_items_limit_configuration(
            mut self,
            input: std::option::Option<crate::model::ItemsLimitConfiguration>,
        ) -> Self {
            self.heat_map_row_items_limit_configuration = input;
            self
        }
        /// <p>The limit on the number of columns that are displayed in a heat map.</p>
        pub fn heat_map_column_items_limit_configuration(
            mut self,
            input: crate::model::ItemsLimitConfiguration,
        ) -> Self {
            self.heat_map_column_items_limit_configuration = Some(input);
            self
        }
        /// <p>The limit on the number of columns that are displayed in a heat map.</p>
        pub fn set_heat_map_column_items_limit_configuration(
            mut self,
            input: std::option::Option<crate::model::ItemsLimitConfiguration>,
        ) -> Self {
            self.heat_map_column_items_limit_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`HeatMapSortConfiguration`](crate::model::HeatMapSortConfiguration).
        pub fn build(self) -> crate::model::HeatMapSortConfiguration {
            crate::model::HeatMapSortConfiguration {
                heat_map_row_sort: self.heat_map_row_sort,
                heat_map_column_sort: self.heat_map_column_sort,
                heat_map_row_items_limit_configuration: self.heat_map_row_items_limit_configuration,
                heat_map_column_items_limit_configuration: self
                    .heat_map_column_items_limit_configuration,
            }
        }
    }
}
impl HeatMapSortConfiguration {
    /// Creates a new builder-style object to manufacture [`HeatMapSortConfiguration`](crate::model::HeatMapSortConfiguration).
    pub fn builder() -> crate::model::heat_map_sort_configuration::Builder {
        crate::model::heat_map_sort_configuration::Builder::default()
    }
}

/// <p>The field well configuration of a heat map.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HeatMapFieldWells {
    /// <p>The aggregated field wells of a heat map.</p>
    #[doc(hidden)]
    pub heat_map_aggregated_field_wells:
        std::option::Option<crate::model::HeatMapAggregatedFieldWells>,
}
impl HeatMapFieldWells {
    /// <p>The aggregated field wells of a heat map.</p>
    pub fn heat_map_aggregated_field_wells(
        &self,
    ) -> std::option::Option<&crate::model::HeatMapAggregatedFieldWells> {
        self.heat_map_aggregated_field_wells.as_ref()
    }
}
/// See [`HeatMapFieldWells`](crate::model::HeatMapFieldWells).
pub mod heat_map_field_wells {

    /// A builder for [`HeatMapFieldWells`](crate::model::HeatMapFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) heat_map_aggregated_field_wells:
            std::option::Option<crate::model::HeatMapAggregatedFieldWells>,
    }
    impl Builder {
        /// <p>The aggregated field wells of a heat map.</p>
        pub fn heat_map_aggregated_field_wells(
            mut self,
            input: crate::model::HeatMapAggregatedFieldWells,
        ) -> Self {
            self.heat_map_aggregated_field_wells = Some(input);
            self
        }
        /// <p>The aggregated field wells of a heat map.</p>
        pub fn set_heat_map_aggregated_field_wells(
            mut self,
            input: std::option::Option<crate::model::HeatMapAggregatedFieldWells>,
        ) -> Self {
            self.heat_map_aggregated_field_wells = input;
            self
        }
        /// Consumes the builder and constructs a [`HeatMapFieldWells`](crate::model::HeatMapFieldWells).
        pub fn build(self) -> crate::model::HeatMapFieldWells {
            crate::model::HeatMapFieldWells {
                heat_map_aggregated_field_wells: self.heat_map_aggregated_field_wells,
            }
        }
    }
}
impl HeatMapFieldWells {
    /// Creates a new builder-style object to manufacture [`HeatMapFieldWells`](crate::model::HeatMapFieldWells).
    pub fn builder() -> crate::model::heat_map_field_wells::Builder {
        crate::model::heat_map_field_wells::Builder::default()
    }
}

/// <p>The aggregated field wells of a heat map.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HeatMapAggregatedFieldWells {
    /// <p>The rows field well of a heat map.</p>
    #[doc(hidden)]
    pub rows: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The columns field well of a heat map.</p>
    #[doc(hidden)]
    pub columns: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The values field well of a heat map.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
}
impl HeatMapAggregatedFieldWells {
    /// <p>The rows field well of a heat map.</p>
    pub fn rows(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.rows.as_deref()
    }
    /// <p>The columns field well of a heat map.</p>
    pub fn columns(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.columns.as_deref()
    }
    /// <p>The values field well of a heat map.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.values.as_deref()
    }
}
/// See [`HeatMapAggregatedFieldWells`](crate::model::HeatMapAggregatedFieldWells).
pub mod heat_map_aggregated_field_wells {

    /// A builder for [`HeatMapAggregatedFieldWells`](crate::model::HeatMapAggregatedFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rows: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) columns: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    }
    impl Builder {
        /// Appends an item to `rows`.
        ///
        /// To override the contents of this collection use [`set_rows`](Self::set_rows).
        ///
        /// <p>The rows field well of a heat map.</p>
        pub fn rows(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.rows.unwrap_or_default();
            v.push(input);
            self.rows = Some(v);
            self
        }
        /// <p>The rows field well of a heat map.</p>
        pub fn set_rows(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.rows = input;
            self
        }
        /// Appends an item to `columns`.
        ///
        /// To override the contents of this collection use [`set_columns`](Self::set_columns).
        ///
        /// <p>The columns field well of a heat map.</p>
        pub fn columns(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.columns.unwrap_or_default();
            v.push(input);
            self.columns = Some(v);
            self
        }
        /// <p>The columns field well of a heat map.</p>
        pub fn set_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.columns = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The values field well of a heat map.</p>
        pub fn values(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>The values field well of a heat map.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`HeatMapAggregatedFieldWells`](crate::model::HeatMapAggregatedFieldWells).
        pub fn build(self) -> crate::model::HeatMapAggregatedFieldWells {
            crate::model::HeatMapAggregatedFieldWells {
                rows: self.rows,
                columns: self.columns,
                values: self.values,
            }
        }
    }
}
impl HeatMapAggregatedFieldWells {
    /// Creates a new builder-style object to manufacture [`HeatMapAggregatedFieldWells`](crate::model::HeatMapAggregatedFieldWells).
    pub fn builder() -> crate::model::heat_map_aggregated_field_wells::Builder {
        crate::model::heat_map_aggregated_field_wells::Builder::default()
    }
}

/// <p>A line chart.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/line-charts.html">Using line charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LineChartVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration of a line chart.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::LineChartConfiguration>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    #[doc(hidden)]
    pub column_hierarchies: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
}
impl LineChartVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration of a line chart.</p>
    pub fn chart_configuration(
        &self,
    ) -> std::option::Option<&crate::model::LineChartConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    pub fn column_hierarchies(&self) -> std::option::Option<&[crate::model::ColumnHierarchy]> {
        self.column_hierarchies.as_deref()
    }
}
/// See [`LineChartVisual`](crate::model::LineChartVisual).
pub mod line_chart_visual {

    /// A builder for [`LineChartVisual`](crate::model::LineChartVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration: std::option::Option<crate::model::LineChartConfiguration>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        pub(crate) column_hierarchies:
            std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration of a line chart.</p>
        pub fn chart_configuration(mut self, input: crate::model::LineChartConfiguration) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration of a line chart.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::LineChartConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Appends an item to `column_hierarchies`.
        ///
        /// To override the contents of this collection use [`set_column_hierarchies`](Self::set_column_hierarchies).
        ///
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn column_hierarchies(mut self, input: crate::model::ColumnHierarchy) -> Self {
            let mut v = self.column_hierarchies.unwrap_or_default();
            v.push(input);
            self.column_hierarchies = Some(v);
            self
        }
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn set_column_hierarchies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
        ) -> Self {
            self.column_hierarchies = input;
            self
        }
        /// Consumes the builder and constructs a [`LineChartVisual`](crate::model::LineChartVisual).
        pub fn build(self) -> crate::model::LineChartVisual {
            crate::model::LineChartVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                actions: self.actions,
                column_hierarchies: self.column_hierarchies,
            }
        }
    }
}
impl LineChartVisual {
    /// Creates a new builder-style object to manufacture [`LineChartVisual`](crate::model::LineChartVisual).
    pub fn builder() -> crate::model::line_chart_visual::Builder {
        crate::model::line_chart_visual::Builder::default()
    }
}

/// <p>The configuration of a line chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LineChartConfiguration {
    /// <p>The field well configuration of a line chart.</p>
    #[doc(hidden)]
    pub field_wells: std::option::Option<crate::model::LineChartFieldWells>,
    /// <p>The sort configuration of a line chart.</p>
    #[doc(hidden)]
    pub sort_configuration: std::option::Option<crate::model::LineChartSortConfiguration>,
    /// <p>The forecast configuration of a line chart.</p>
    #[doc(hidden)]
    pub forecast_configurations:
        std::option::Option<std::vec::Vec<crate::model::ForecastConfiguration>>,
    /// <p>Determines the type of the line chart.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::LineChartType>,
    /// <p>The small multiples setup for the visual.</p>
    #[doc(hidden)]
    pub small_multiples_options: std::option::Option<crate::model::SmallMultiplesOptions>,
    /// <p>The options that determine the presentation of the x-axis.</p>
    #[doc(hidden)]
    pub x_axis_display_options: std::option::Option<crate::model::AxisDisplayOptions>,
    /// <p>The options that determine the presentation of the x-axis label.</p>
    #[doc(hidden)]
    pub x_axis_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The series axis configuration of a line chart.</p>
    #[doc(hidden)]
    pub primary_y_axis_display_options:
        std::option::Option<crate::model::LineSeriesAxisDisplayOptions>,
    /// <p>The options that determine the presentation of the y-axis label.</p>
    #[doc(hidden)]
    pub primary_y_axis_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The series axis configuration of a line chart.</p>
    #[doc(hidden)]
    pub secondary_y_axis_display_options:
        std::option::Option<crate::model::LineSeriesAxisDisplayOptions>,
    /// <p>The options that determine the presentation of the secondary y-axis label.</p>
    #[doc(hidden)]
    pub secondary_y_axis_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The options that determine the default presentation of all line series in <code>LineChartVisual</code>.</p>
    #[doc(hidden)]
    pub default_series_settings: std::option::Option<crate::model::LineChartDefaultSeriesSettings>,
    /// <p>The series item configuration of a line chart.</p>
    #[doc(hidden)]
    pub series: std::option::Option<std::vec::Vec<crate::model::SeriesItem>>,
    /// <p>The legend configuration of a line chart.</p>
    #[doc(hidden)]
    pub legend: std::option::Option<crate::model::LegendOptions>,
    /// <p>The data label configuration of a line chart.</p>
    #[doc(hidden)]
    pub data_labels: std::option::Option<crate::model::DataLabelOptions>,
    /// <p>The reference lines configuration of a line chart.</p>
    #[doc(hidden)]
    pub reference_lines: std::option::Option<std::vec::Vec<crate::model::ReferenceLine>>,
    /// <p>The tooltip configuration of a line chart.</p>
    #[doc(hidden)]
    pub tooltip: std::option::Option<crate::model::TooltipOptions>,
    /// <p>The default configuration of a line chart's contribution analysis.</p>
    #[doc(hidden)]
    pub contribution_analysis_defaults:
        std::option::Option<std::vec::Vec<crate::model::ContributionAnalysisDefault>>,
    /// <p>The visual palette configuration of a line chart.</p>
    #[doc(hidden)]
    pub visual_palette: std::option::Option<crate::model::VisualPalette>,
}
impl LineChartConfiguration {
    /// <p>The field well configuration of a line chart.</p>
    pub fn field_wells(&self) -> std::option::Option<&crate::model::LineChartFieldWells> {
        self.field_wells.as_ref()
    }
    /// <p>The sort configuration of a line chart.</p>
    pub fn sort_configuration(
        &self,
    ) -> std::option::Option<&crate::model::LineChartSortConfiguration> {
        self.sort_configuration.as_ref()
    }
    /// <p>The forecast configuration of a line chart.</p>
    pub fn forecast_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::ForecastConfiguration]> {
        self.forecast_configurations.as_deref()
    }
    /// <p>Determines the type of the line chart.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::LineChartType> {
        self.r#type.as_ref()
    }
    /// <p>The small multiples setup for the visual.</p>
    pub fn small_multiples_options(
        &self,
    ) -> std::option::Option<&crate::model::SmallMultiplesOptions> {
        self.small_multiples_options.as_ref()
    }
    /// <p>The options that determine the presentation of the x-axis.</p>
    pub fn x_axis_display_options(&self) -> std::option::Option<&crate::model::AxisDisplayOptions> {
        self.x_axis_display_options.as_ref()
    }
    /// <p>The options that determine the presentation of the x-axis label.</p>
    pub fn x_axis_label_options(
        &self,
    ) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.x_axis_label_options.as_ref()
    }
    /// <p>The series axis configuration of a line chart.</p>
    pub fn primary_y_axis_display_options(
        &self,
    ) -> std::option::Option<&crate::model::LineSeriesAxisDisplayOptions> {
        self.primary_y_axis_display_options.as_ref()
    }
    /// <p>The options that determine the presentation of the y-axis label.</p>
    pub fn primary_y_axis_label_options(
        &self,
    ) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.primary_y_axis_label_options.as_ref()
    }
    /// <p>The series axis configuration of a line chart.</p>
    pub fn secondary_y_axis_display_options(
        &self,
    ) -> std::option::Option<&crate::model::LineSeriesAxisDisplayOptions> {
        self.secondary_y_axis_display_options.as_ref()
    }
    /// <p>The options that determine the presentation of the secondary y-axis label.</p>
    pub fn secondary_y_axis_label_options(
        &self,
    ) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.secondary_y_axis_label_options.as_ref()
    }
    /// <p>The options that determine the default presentation of all line series in <code>LineChartVisual</code>.</p>
    pub fn default_series_settings(
        &self,
    ) -> std::option::Option<&crate::model::LineChartDefaultSeriesSettings> {
        self.default_series_settings.as_ref()
    }
    /// <p>The series item configuration of a line chart.</p>
    pub fn series(&self) -> std::option::Option<&[crate::model::SeriesItem]> {
        self.series.as_deref()
    }
    /// <p>The legend configuration of a line chart.</p>
    pub fn legend(&self) -> std::option::Option<&crate::model::LegendOptions> {
        self.legend.as_ref()
    }
    /// <p>The data label configuration of a line chart.</p>
    pub fn data_labels(&self) -> std::option::Option<&crate::model::DataLabelOptions> {
        self.data_labels.as_ref()
    }
    /// <p>The reference lines configuration of a line chart.</p>
    pub fn reference_lines(&self) -> std::option::Option<&[crate::model::ReferenceLine]> {
        self.reference_lines.as_deref()
    }
    /// <p>The tooltip configuration of a line chart.</p>
    pub fn tooltip(&self) -> std::option::Option<&crate::model::TooltipOptions> {
        self.tooltip.as_ref()
    }
    /// <p>The default configuration of a line chart's contribution analysis.</p>
    pub fn contribution_analysis_defaults(
        &self,
    ) -> std::option::Option<&[crate::model::ContributionAnalysisDefault]> {
        self.contribution_analysis_defaults.as_deref()
    }
    /// <p>The visual palette configuration of a line chart.</p>
    pub fn visual_palette(&self) -> std::option::Option<&crate::model::VisualPalette> {
        self.visual_palette.as_ref()
    }
}
/// See [`LineChartConfiguration`](crate::model::LineChartConfiguration).
pub mod line_chart_configuration {

    /// A builder for [`LineChartConfiguration`](crate::model::LineChartConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_wells: std::option::Option<crate::model::LineChartFieldWells>,
        pub(crate) sort_configuration:
            std::option::Option<crate::model::LineChartSortConfiguration>,
        pub(crate) forecast_configurations:
            std::option::Option<std::vec::Vec<crate::model::ForecastConfiguration>>,
        pub(crate) r#type: std::option::Option<crate::model::LineChartType>,
        pub(crate) small_multiples_options:
            std::option::Option<crate::model::SmallMultiplesOptions>,
        pub(crate) x_axis_display_options: std::option::Option<crate::model::AxisDisplayOptions>,
        pub(crate) x_axis_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) primary_y_axis_display_options:
            std::option::Option<crate::model::LineSeriesAxisDisplayOptions>,
        pub(crate) primary_y_axis_label_options:
            std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) secondary_y_axis_display_options:
            std::option::Option<crate::model::LineSeriesAxisDisplayOptions>,
        pub(crate) secondary_y_axis_label_options:
            std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) default_series_settings:
            std::option::Option<crate::model::LineChartDefaultSeriesSettings>,
        pub(crate) series: std::option::Option<std::vec::Vec<crate::model::SeriesItem>>,
        pub(crate) legend: std::option::Option<crate::model::LegendOptions>,
        pub(crate) data_labels: std::option::Option<crate::model::DataLabelOptions>,
        pub(crate) reference_lines: std::option::Option<std::vec::Vec<crate::model::ReferenceLine>>,
        pub(crate) tooltip: std::option::Option<crate::model::TooltipOptions>,
        pub(crate) contribution_analysis_defaults:
            std::option::Option<std::vec::Vec<crate::model::ContributionAnalysisDefault>>,
        pub(crate) visual_palette: std::option::Option<crate::model::VisualPalette>,
    }
    impl Builder {
        /// <p>The field well configuration of a line chart.</p>
        pub fn field_wells(mut self, input: crate::model::LineChartFieldWells) -> Self {
            self.field_wells = Some(input);
            self
        }
        /// <p>The field well configuration of a line chart.</p>
        pub fn set_field_wells(
            mut self,
            input: std::option::Option<crate::model::LineChartFieldWells>,
        ) -> Self {
            self.field_wells = input;
            self
        }
        /// <p>The sort configuration of a line chart.</p>
        pub fn sort_configuration(
            mut self,
            input: crate::model::LineChartSortConfiguration,
        ) -> Self {
            self.sort_configuration = Some(input);
            self
        }
        /// <p>The sort configuration of a line chart.</p>
        pub fn set_sort_configuration(
            mut self,
            input: std::option::Option<crate::model::LineChartSortConfiguration>,
        ) -> Self {
            self.sort_configuration = input;
            self
        }
        /// Appends an item to `forecast_configurations`.
        ///
        /// To override the contents of this collection use [`set_forecast_configurations`](Self::set_forecast_configurations).
        ///
        /// <p>The forecast configuration of a line chart.</p>
        pub fn forecast_configurations(
            mut self,
            input: crate::model::ForecastConfiguration,
        ) -> Self {
            let mut v = self.forecast_configurations.unwrap_or_default();
            v.push(input);
            self.forecast_configurations = Some(v);
            self
        }
        /// <p>The forecast configuration of a line chart.</p>
        pub fn set_forecast_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ForecastConfiguration>>,
        ) -> Self {
            self.forecast_configurations = input;
            self
        }
        /// <p>Determines the type of the line chart.</p>
        pub fn r#type(mut self, input: crate::model::LineChartType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Determines the type of the line chart.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::LineChartType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The small multiples setup for the visual.</p>
        pub fn small_multiples_options(
            mut self,
            input: crate::model::SmallMultiplesOptions,
        ) -> Self {
            self.small_multiples_options = Some(input);
            self
        }
        /// <p>The small multiples setup for the visual.</p>
        pub fn set_small_multiples_options(
            mut self,
            input: std::option::Option<crate::model::SmallMultiplesOptions>,
        ) -> Self {
            self.small_multiples_options = input;
            self
        }
        /// <p>The options that determine the presentation of the x-axis.</p>
        pub fn x_axis_display_options(mut self, input: crate::model::AxisDisplayOptions) -> Self {
            self.x_axis_display_options = Some(input);
            self
        }
        /// <p>The options that determine the presentation of the x-axis.</p>
        pub fn set_x_axis_display_options(
            mut self,
            input: std::option::Option<crate::model::AxisDisplayOptions>,
        ) -> Self {
            self.x_axis_display_options = input;
            self
        }
        /// <p>The options that determine the presentation of the x-axis label.</p>
        pub fn x_axis_label_options(mut self, input: crate::model::ChartAxisLabelOptions) -> Self {
            self.x_axis_label_options = Some(input);
            self
        }
        /// <p>The options that determine the presentation of the x-axis label.</p>
        pub fn set_x_axis_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.x_axis_label_options = input;
            self
        }
        /// <p>The series axis configuration of a line chart.</p>
        pub fn primary_y_axis_display_options(
            mut self,
            input: crate::model::LineSeriesAxisDisplayOptions,
        ) -> Self {
            self.primary_y_axis_display_options = Some(input);
            self
        }
        /// <p>The series axis configuration of a line chart.</p>
        pub fn set_primary_y_axis_display_options(
            mut self,
            input: std::option::Option<crate::model::LineSeriesAxisDisplayOptions>,
        ) -> Self {
            self.primary_y_axis_display_options = input;
            self
        }
        /// <p>The options that determine the presentation of the y-axis label.</p>
        pub fn primary_y_axis_label_options(
            mut self,
            input: crate::model::ChartAxisLabelOptions,
        ) -> Self {
            self.primary_y_axis_label_options = Some(input);
            self
        }
        /// <p>The options that determine the presentation of the y-axis label.</p>
        pub fn set_primary_y_axis_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.primary_y_axis_label_options = input;
            self
        }
        /// <p>The series axis configuration of a line chart.</p>
        pub fn secondary_y_axis_display_options(
            mut self,
            input: crate::model::LineSeriesAxisDisplayOptions,
        ) -> Self {
            self.secondary_y_axis_display_options = Some(input);
            self
        }
        /// <p>The series axis configuration of a line chart.</p>
        pub fn set_secondary_y_axis_display_options(
            mut self,
            input: std::option::Option<crate::model::LineSeriesAxisDisplayOptions>,
        ) -> Self {
            self.secondary_y_axis_display_options = input;
            self
        }
        /// <p>The options that determine the presentation of the secondary y-axis label.</p>
        pub fn secondary_y_axis_label_options(
            mut self,
            input: crate::model::ChartAxisLabelOptions,
        ) -> Self {
            self.secondary_y_axis_label_options = Some(input);
            self
        }
        /// <p>The options that determine the presentation of the secondary y-axis label.</p>
        pub fn set_secondary_y_axis_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.secondary_y_axis_label_options = input;
            self
        }
        /// <p>The options that determine the default presentation of all line series in <code>LineChartVisual</code>.</p>
        pub fn default_series_settings(
            mut self,
            input: crate::model::LineChartDefaultSeriesSettings,
        ) -> Self {
            self.default_series_settings = Some(input);
            self
        }
        /// <p>The options that determine the default presentation of all line series in <code>LineChartVisual</code>.</p>
        pub fn set_default_series_settings(
            mut self,
            input: std::option::Option<crate::model::LineChartDefaultSeriesSettings>,
        ) -> Self {
            self.default_series_settings = input;
            self
        }
        /// Appends an item to `series`.
        ///
        /// To override the contents of this collection use [`set_series`](Self::set_series).
        ///
        /// <p>The series item configuration of a line chart.</p>
        pub fn series(mut self, input: crate::model::SeriesItem) -> Self {
            let mut v = self.series.unwrap_or_default();
            v.push(input);
            self.series = Some(v);
            self
        }
        /// <p>The series item configuration of a line chart.</p>
        pub fn set_series(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SeriesItem>>,
        ) -> Self {
            self.series = input;
            self
        }
        /// <p>The legend configuration of a line chart.</p>
        pub fn legend(mut self, input: crate::model::LegendOptions) -> Self {
            self.legend = Some(input);
            self
        }
        /// <p>The legend configuration of a line chart.</p>
        pub fn set_legend(
            mut self,
            input: std::option::Option<crate::model::LegendOptions>,
        ) -> Self {
            self.legend = input;
            self
        }
        /// <p>The data label configuration of a line chart.</p>
        pub fn data_labels(mut self, input: crate::model::DataLabelOptions) -> Self {
            self.data_labels = Some(input);
            self
        }
        /// <p>The data label configuration of a line chart.</p>
        pub fn set_data_labels(
            mut self,
            input: std::option::Option<crate::model::DataLabelOptions>,
        ) -> Self {
            self.data_labels = input;
            self
        }
        /// Appends an item to `reference_lines`.
        ///
        /// To override the contents of this collection use [`set_reference_lines`](Self::set_reference_lines).
        ///
        /// <p>The reference lines configuration of a line chart.</p>
        pub fn reference_lines(mut self, input: crate::model::ReferenceLine) -> Self {
            let mut v = self.reference_lines.unwrap_or_default();
            v.push(input);
            self.reference_lines = Some(v);
            self
        }
        /// <p>The reference lines configuration of a line chart.</p>
        pub fn set_reference_lines(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReferenceLine>>,
        ) -> Self {
            self.reference_lines = input;
            self
        }
        /// <p>The tooltip configuration of a line chart.</p>
        pub fn tooltip(mut self, input: crate::model::TooltipOptions) -> Self {
            self.tooltip = Some(input);
            self
        }
        /// <p>The tooltip configuration of a line chart.</p>
        pub fn set_tooltip(
            mut self,
            input: std::option::Option<crate::model::TooltipOptions>,
        ) -> Self {
            self.tooltip = input;
            self
        }
        /// Appends an item to `contribution_analysis_defaults`.
        ///
        /// To override the contents of this collection use [`set_contribution_analysis_defaults`](Self::set_contribution_analysis_defaults).
        ///
        /// <p>The default configuration of a line chart's contribution analysis.</p>
        pub fn contribution_analysis_defaults(
            mut self,
            input: crate::model::ContributionAnalysisDefault,
        ) -> Self {
            let mut v = self.contribution_analysis_defaults.unwrap_or_default();
            v.push(input);
            self.contribution_analysis_defaults = Some(v);
            self
        }
        /// <p>The default configuration of a line chart's contribution analysis.</p>
        pub fn set_contribution_analysis_defaults(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ContributionAnalysisDefault>>,
        ) -> Self {
            self.contribution_analysis_defaults = input;
            self
        }
        /// <p>The visual palette configuration of a line chart.</p>
        pub fn visual_palette(mut self, input: crate::model::VisualPalette) -> Self {
            self.visual_palette = Some(input);
            self
        }
        /// <p>The visual palette configuration of a line chart.</p>
        pub fn set_visual_palette(
            mut self,
            input: std::option::Option<crate::model::VisualPalette>,
        ) -> Self {
            self.visual_palette = input;
            self
        }
        /// Consumes the builder and constructs a [`LineChartConfiguration`](crate::model::LineChartConfiguration).
        pub fn build(self) -> crate::model::LineChartConfiguration {
            crate::model::LineChartConfiguration {
                field_wells: self.field_wells,
                sort_configuration: self.sort_configuration,
                forecast_configurations: self.forecast_configurations,
                r#type: self.r#type,
                small_multiples_options: self.small_multiples_options,
                x_axis_display_options: self.x_axis_display_options,
                x_axis_label_options: self.x_axis_label_options,
                primary_y_axis_display_options: self.primary_y_axis_display_options,
                primary_y_axis_label_options: self.primary_y_axis_label_options,
                secondary_y_axis_display_options: self.secondary_y_axis_display_options,
                secondary_y_axis_label_options: self.secondary_y_axis_label_options,
                default_series_settings: self.default_series_settings,
                series: self.series,
                legend: self.legend,
                data_labels: self.data_labels,
                reference_lines: self.reference_lines,
                tooltip: self.tooltip,
                contribution_analysis_defaults: self.contribution_analysis_defaults,
                visual_palette: self.visual_palette,
            }
        }
    }
}
impl LineChartConfiguration {
    /// Creates a new builder-style object to manufacture [`LineChartConfiguration`](crate::model::LineChartConfiguration).
    pub fn builder() -> crate::model::line_chart_configuration::Builder {
        crate::model::line_chart_configuration::Builder::default()
    }
}

/// <p>The contribution analysis visual display for a line, pie, or bar chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ContributionAnalysisDefault {
    /// <p>The measure field that is used in the contribution analysis.</p>
    #[doc(hidden)]
    pub measure_field_id: std::option::Option<std::string::String>,
    /// <p>The dimensions columns that are used in the contribution analysis, usually a list of <code>ColumnIdentifiers</code>.</p>
    #[doc(hidden)]
    pub contributor_dimensions: std::option::Option<std::vec::Vec<crate::model::ColumnIdentifier>>,
}
impl ContributionAnalysisDefault {
    /// <p>The measure field that is used in the contribution analysis.</p>
    pub fn measure_field_id(&self) -> std::option::Option<&str> {
        self.measure_field_id.as_deref()
    }
    /// <p>The dimensions columns that are used in the contribution analysis, usually a list of <code>ColumnIdentifiers</code>.</p>
    pub fn contributor_dimensions(&self) -> std::option::Option<&[crate::model::ColumnIdentifier]> {
        self.contributor_dimensions.as_deref()
    }
}
/// See [`ContributionAnalysisDefault`](crate::model::ContributionAnalysisDefault).
pub mod contribution_analysis_default {

    /// A builder for [`ContributionAnalysisDefault`](crate::model::ContributionAnalysisDefault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) measure_field_id: std::option::Option<std::string::String>,
        pub(crate) contributor_dimensions:
            std::option::Option<std::vec::Vec<crate::model::ColumnIdentifier>>,
    }
    impl Builder {
        /// <p>The measure field that is used in the contribution analysis.</p>
        pub fn measure_field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.measure_field_id = Some(input.into());
            self
        }
        /// <p>The measure field that is used in the contribution analysis.</p>
        pub fn set_measure_field_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.measure_field_id = input;
            self
        }
        /// Appends an item to `contributor_dimensions`.
        ///
        /// To override the contents of this collection use [`set_contributor_dimensions`](Self::set_contributor_dimensions).
        ///
        /// <p>The dimensions columns that are used in the contribution analysis, usually a list of <code>ColumnIdentifiers</code>.</p>
        pub fn contributor_dimensions(mut self, input: crate::model::ColumnIdentifier) -> Self {
            let mut v = self.contributor_dimensions.unwrap_or_default();
            v.push(input);
            self.contributor_dimensions = Some(v);
            self
        }
        /// <p>The dimensions columns that are used in the contribution analysis, usually a list of <code>ColumnIdentifiers</code>.</p>
        pub fn set_contributor_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnIdentifier>>,
        ) -> Self {
            self.contributor_dimensions = input;
            self
        }
        /// Consumes the builder and constructs a [`ContributionAnalysisDefault`](crate::model::ContributionAnalysisDefault).
        pub fn build(self) -> crate::model::ContributionAnalysisDefault {
            crate::model::ContributionAnalysisDefault {
                measure_field_id: self.measure_field_id,
                contributor_dimensions: self.contributor_dimensions,
            }
        }
    }
}
impl ContributionAnalysisDefault {
    /// Creates a new builder-style object to manufacture [`ContributionAnalysisDefault`](crate::model::ContributionAnalysisDefault).
    pub fn builder() -> crate::model::contribution_analysis_default::Builder {
        crate::model::contribution_analysis_default::Builder::default()
    }
}

/// <p>The series item configuration of a line chart.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SeriesItem {
    /// <p>The field series item configuration of a line chart.</p>
    #[doc(hidden)]
    pub field_series_item: std::option::Option<crate::model::FieldSeriesItem>,
    /// <p>The data field series item configuration of a line chart.</p>
    #[doc(hidden)]
    pub data_field_series_item: std::option::Option<crate::model::DataFieldSeriesItem>,
}
impl SeriesItem {
    /// <p>The field series item configuration of a line chart.</p>
    pub fn field_series_item(&self) -> std::option::Option<&crate::model::FieldSeriesItem> {
        self.field_series_item.as_ref()
    }
    /// <p>The data field series item configuration of a line chart.</p>
    pub fn data_field_series_item(
        &self,
    ) -> std::option::Option<&crate::model::DataFieldSeriesItem> {
        self.data_field_series_item.as_ref()
    }
}
/// See [`SeriesItem`](crate::model::SeriesItem).
pub mod series_item {

    /// A builder for [`SeriesItem`](crate::model::SeriesItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_series_item: std::option::Option<crate::model::FieldSeriesItem>,
        pub(crate) data_field_series_item: std::option::Option<crate::model::DataFieldSeriesItem>,
    }
    impl Builder {
        /// <p>The field series item configuration of a line chart.</p>
        pub fn field_series_item(mut self, input: crate::model::FieldSeriesItem) -> Self {
            self.field_series_item = Some(input);
            self
        }
        /// <p>The field series item configuration of a line chart.</p>
        pub fn set_field_series_item(
            mut self,
            input: std::option::Option<crate::model::FieldSeriesItem>,
        ) -> Self {
            self.field_series_item = input;
            self
        }
        /// <p>The data field series item configuration of a line chart.</p>
        pub fn data_field_series_item(mut self, input: crate::model::DataFieldSeriesItem) -> Self {
            self.data_field_series_item = Some(input);
            self
        }
        /// <p>The data field series item configuration of a line chart.</p>
        pub fn set_data_field_series_item(
            mut self,
            input: std::option::Option<crate::model::DataFieldSeriesItem>,
        ) -> Self {
            self.data_field_series_item = input;
            self
        }
        /// Consumes the builder and constructs a [`SeriesItem`](crate::model::SeriesItem).
        pub fn build(self) -> crate::model::SeriesItem {
            crate::model::SeriesItem {
                field_series_item: self.field_series_item,
                data_field_series_item: self.data_field_series_item,
            }
        }
    }
}
impl SeriesItem {
    /// Creates a new builder-style object to manufacture [`SeriesItem`](crate::model::SeriesItem).
    pub fn builder() -> crate::model::series_item::Builder {
        crate::model::series_item::Builder::default()
    }
}

/// <p>The data field series item configuration of a line chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataFieldSeriesItem {
    /// <p>The field ID of the field that you are setting the axis binding to.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The field value of the field that you are setting the axis binding to.</p>
    #[doc(hidden)]
    pub field_value: std::option::Option<std::string::String>,
    /// <p>The axis that you are binding the field to.</p>
    #[doc(hidden)]
    pub axis_binding: std::option::Option<crate::model::AxisBinding>,
    /// <p>The options that determine the presentation of line series associated to the field.</p>
    #[doc(hidden)]
    pub settings: std::option::Option<crate::model::LineChartSeriesSettings>,
}
impl DataFieldSeriesItem {
    /// <p>The field ID of the field that you are setting the axis binding to.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The field value of the field that you are setting the axis binding to.</p>
    pub fn field_value(&self) -> std::option::Option<&str> {
        self.field_value.as_deref()
    }
    /// <p>The axis that you are binding the field to.</p>
    pub fn axis_binding(&self) -> std::option::Option<&crate::model::AxisBinding> {
        self.axis_binding.as_ref()
    }
    /// <p>The options that determine the presentation of line series associated to the field.</p>
    pub fn settings(&self) -> std::option::Option<&crate::model::LineChartSeriesSettings> {
        self.settings.as_ref()
    }
}
impl std::fmt::Debug for DataFieldSeriesItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataFieldSeriesItem");
        formatter.field("field_id", &self.field_id);
        formatter.field("field_value", &"*** Sensitive Data Redacted ***");
        formatter.field("axis_binding", &self.axis_binding);
        formatter.field("settings", &self.settings);
        formatter.finish()
    }
}
/// See [`DataFieldSeriesItem`](crate::model::DataFieldSeriesItem).
pub mod data_field_series_item {

    /// A builder for [`DataFieldSeriesItem`](crate::model::DataFieldSeriesItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) field_value: std::option::Option<std::string::String>,
        pub(crate) axis_binding: std::option::Option<crate::model::AxisBinding>,
        pub(crate) settings: std::option::Option<crate::model::LineChartSeriesSettings>,
    }
    impl Builder {
        /// <p>The field ID of the field that you are setting the axis binding to.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The field ID of the field that you are setting the axis binding to.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The field value of the field that you are setting the axis binding to.</p>
        pub fn field_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_value = Some(input.into());
            self
        }
        /// <p>The field value of the field that you are setting the axis binding to.</p>
        pub fn set_field_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_value = input;
            self
        }
        /// <p>The axis that you are binding the field to.</p>
        pub fn axis_binding(mut self, input: crate::model::AxisBinding) -> Self {
            self.axis_binding = Some(input);
            self
        }
        /// <p>The axis that you are binding the field to.</p>
        pub fn set_axis_binding(
            mut self,
            input: std::option::Option<crate::model::AxisBinding>,
        ) -> Self {
            self.axis_binding = input;
            self
        }
        /// <p>The options that determine the presentation of line series associated to the field.</p>
        pub fn settings(mut self, input: crate::model::LineChartSeriesSettings) -> Self {
            self.settings = Some(input);
            self
        }
        /// <p>The options that determine the presentation of line series associated to the field.</p>
        pub fn set_settings(
            mut self,
            input: std::option::Option<crate::model::LineChartSeriesSettings>,
        ) -> Self {
            self.settings = input;
            self
        }
        /// Consumes the builder and constructs a [`DataFieldSeriesItem`](crate::model::DataFieldSeriesItem).
        pub fn build(self) -> crate::model::DataFieldSeriesItem {
            crate::model::DataFieldSeriesItem {
                field_id: self.field_id,
                field_value: self.field_value,
                axis_binding: self.axis_binding,
                settings: self.settings,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("field_id", &self.field_id);
            formatter.field("field_value", &"*** Sensitive Data Redacted ***");
            formatter.field("axis_binding", &self.axis_binding);
            formatter.field("settings", &self.settings);
            formatter.finish()
        }
    }
}
impl DataFieldSeriesItem {
    /// Creates a new builder-style object to manufacture [`DataFieldSeriesItem`](crate::model::DataFieldSeriesItem).
    pub fn builder() -> crate::model::data_field_series_item::Builder {
        crate::model::data_field_series_item::Builder::default()
    }
}

/// <p>The options that determine the presentation of a line series in the visual</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LineChartSeriesSettings {
    /// <p>Line styles options for a line series in <code>LineChartVisual</code>.</p>
    #[doc(hidden)]
    pub line_style_settings: std::option::Option<crate::model::LineChartLineStyleSettings>,
    /// <p>Marker styles options for a line series in <code>LineChartVisual</code>.</p>
    #[doc(hidden)]
    pub marker_style_settings: std::option::Option<crate::model::LineChartMarkerStyleSettings>,
}
impl LineChartSeriesSettings {
    /// <p>Line styles options for a line series in <code>LineChartVisual</code>.</p>
    pub fn line_style_settings(
        &self,
    ) -> std::option::Option<&crate::model::LineChartLineStyleSettings> {
        self.line_style_settings.as_ref()
    }
    /// <p>Marker styles options for a line series in <code>LineChartVisual</code>.</p>
    pub fn marker_style_settings(
        &self,
    ) -> std::option::Option<&crate::model::LineChartMarkerStyleSettings> {
        self.marker_style_settings.as_ref()
    }
}
/// See [`LineChartSeriesSettings`](crate::model::LineChartSeriesSettings).
pub mod line_chart_series_settings {

    /// A builder for [`LineChartSeriesSettings`](crate::model::LineChartSeriesSettings).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) line_style_settings:
            std::option::Option<crate::model::LineChartLineStyleSettings>,
        pub(crate) marker_style_settings:
            std::option::Option<crate::model::LineChartMarkerStyleSettings>,
    }
    impl Builder {
        /// <p>Line styles options for a line series in <code>LineChartVisual</code>.</p>
        pub fn line_style_settings(
            mut self,
            input: crate::model::LineChartLineStyleSettings,
        ) -> Self {
            self.line_style_settings = Some(input);
            self
        }
        /// <p>Line styles options for a line series in <code>LineChartVisual</code>.</p>
        pub fn set_line_style_settings(
            mut self,
            input: std::option::Option<crate::model::LineChartLineStyleSettings>,
        ) -> Self {
            self.line_style_settings = input;
            self
        }
        /// <p>Marker styles options for a line series in <code>LineChartVisual</code>.</p>
        pub fn marker_style_settings(
            mut self,
            input: crate::model::LineChartMarkerStyleSettings,
        ) -> Self {
            self.marker_style_settings = Some(input);
            self
        }
        /// <p>Marker styles options for a line series in <code>LineChartVisual</code>.</p>
        pub fn set_marker_style_settings(
            mut self,
            input: std::option::Option<crate::model::LineChartMarkerStyleSettings>,
        ) -> Self {
            self.marker_style_settings = input;
            self
        }
        /// Consumes the builder and constructs a [`LineChartSeriesSettings`](crate::model::LineChartSeriesSettings).
        pub fn build(self) -> crate::model::LineChartSeriesSettings {
            crate::model::LineChartSeriesSettings {
                line_style_settings: self.line_style_settings,
                marker_style_settings: self.marker_style_settings,
            }
        }
    }
}
impl LineChartSeriesSettings {
    /// Creates a new builder-style object to manufacture [`LineChartSeriesSettings`](crate::model::LineChartSeriesSettings).
    pub fn builder() -> crate::model::line_chart_series_settings::Builder {
        crate::model::line_chart_series_settings::Builder::default()
    }
}

/// <p>Marker styles options for a line series in <code>LineChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LineChartMarkerStyleSettings {
    /// <p>Configuration option that determines whether to show the markers in the series.</p>
    #[doc(hidden)]
    pub marker_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>Shape option for markers in the series.</p>
    /// <ul>
    /// <li> <p> <code>CIRCLE</code>: Show marker as a circle.</p> </li>
    /// <li> <p> <code>TRIANGLE</code>: Show marker as a triangle.</p> </li>
    /// <li> <p> <code>SQUARE</code>: Show marker as a square.</p> </li>
    /// <li> <p> <code>DIAMOND</code>: Show marker as a diamond.</p> </li>
    /// <li> <p> <code>ROUNDED_SQUARE</code>: Show marker as a rounded square.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub marker_shape: std::option::Option<crate::model::LineChartMarkerShape>,
    /// <p>Size of marker in the series.</p>
    #[doc(hidden)]
    pub marker_size: std::option::Option<std::string::String>,
    /// <p>Color of marker in the series.</p>
    #[doc(hidden)]
    pub marker_color: std::option::Option<std::string::String>,
}
impl LineChartMarkerStyleSettings {
    /// <p>Configuration option that determines whether to show the markers in the series.</p>
    pub fn marker_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.marker_visibility.as_ref()
    }
    /// <p>Shape option for markers in the series.</p>
    /// <ul>
    /// <li> <p> <code>CIRCLE</code>: Show marker as a circle.</p> </li>
    /// <li> <p> <code>TRIANGLE</code>: Show marker as a triangle.</p> </li>
    /// <li> <p> <code>SQUARE</code>: Show marker as a square.</p> </li>
    /// <li> <p> <code>DIAMOND</code>: Show marker as a diamond.</p> </li>
    /// <li> <p> <code>ROUNDED_SQUARE</code>: Show marker as a rounded square.</p> </li>
    /// </ul>
    pub fn marker_shape(&self) -> std::option::Option<&crate::model::LineChartMarkerShape> {
        self.marker_shape.as_ref()
    }
    /// <p>Size of marker in the series.</p>
    pub fn marker_size(&self) -> std::option::Option<&str> {
        self.marker_size.as_deref()
    }
    /// <p>Color of marker in the series.</p>
    pub fn marker_color(&self) -> std::option::Option<&str> {
        self.marker_color.as_deref()
    }
}
/// See [`LineChartMarkerStyleSettings`](crate::model::LineChartMarkerStyleSettings).
pub mod line_chart_marker_style_settings {

    /// A builder for [`LineChartMarkerStyleSettings`](crate::model::LineChartMarkerStyleSettings).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) marker_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) marker_shape: std::option::Option<crate::model::LineChartMarkerShape>,
        pub(crate) marker_size: std::option::Option<std::string::String>,
        pub(crate) marker_color: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Configuration option that determines whether to show the markers in the series.</p>
        pub fn marker_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.marker_visibility = Some(input);
            self
        }
        /// <p>Configuration option that determines whether to show the markers in the series.</p>
        pub fn set_marker_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.marker_visibility = input;
            self
        }
        /// <p>Shape option for markers in the series.</p>
        /// <ul>
        /// <li> <p> <code>CIRCLE</code>: Show marker as a circle.</p> </li>
        /// <li> <p> <code>TRIANGLE</code>: Show marker as a triangle.</p> </li>
        /// <li> <p> <code>SQUARE</code>: Show marker as a square.</p> </li>
        /// <li> <p> <code>DIAMOND</code>: Show marker as a diamond.</p> </li>
        /// <li> <p> <code>ROUNDED_SQUARE</code>: Show marker as a rounded square.</p> </li>
        /// </ul>
        pub fn marker_shape(mut self, input: crate::model::LineChartMarkerShape) -> Self {
            self.marker_shape = Some(input);
            self
        }
        /// <p>Shape option for markers in the series.</p>
        /// <ul>
        /// <li> <p> <code>CIRCLE</code>: Show marker as a circle.</p> </li>
        /// <li> <p> <code>TRIANGLE</code>: Show marker as a triangle.</p> </li>
        /// <li> <p> <code>SQUARE</code>: Show marker as a square.</p> </li>
        /// <li> <p> <code>DIAMOND</code>: Show marker as a diamond.</p> </li>
        /// <li> <p> <code>ROUNDED_SQUARE</code>: Show marker as a rounded square.</p> </li>
        /// </ul>
        pub fn set_marker_shape(
            mut self,
            input: std::option::Option<crate::model::LineChartMarkerShape>,
        ) -> Self {
            self.marker_shape = input;
            self
        }
        /// <p>Size of marker in the series.</p>
        pub fn marker_size(mut self, input: impl Into<std::string::String>) -> Self {
            self.marker_size = Some(input.into());
            self
        }
        /// <p>Size of marker in the series.</p>
        pub fn set_marker_size(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.marker_size = input;
            self
        }
        /// <p>Color of marker in the series.</p>
        pub fn marker_color(mut self, input: impl Into<std::string::String>) -> Self {
            self.marker_color = Some(input.into());
            self
        }
        /// <p>Color of marker in the series.</p>
        pub fn set_marker_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.marker_color = input;
            self
        }
        /// Consumes the builder and constructs a [`LineChartMarkerStyleSettings`](crate::model::LineChartMarkerStyleSettings).
        pub fn build(self) -> crate::model::LineChartMarkerStyleSettings {
            crate::model::LineChartMarkerStyleSettings {
                marker_visibility: self.marker_visibility,
                marker_shape: self.marker_shape,
                marker_size: self.marker_size,
                marker_color: self.marker_color,
            }
        }
    }
}
impl LineChartMarkerStyleSettings {
    /// Creates a new builder-style object to manufacture [`LineChartMarkerStyleSettings`](crate::model::LineChartMarkerStyleSettings).
    pub fn builder() -> crate::model::line_chart_marker_style_settings::Builder {
        crate::model::line_chart_marker_style_settings::Builder::default()
    }
}

/// When writing a match expression against `LineChartMarkerShape`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let linechartmarkershape = unimplemented!();
/// match linechartmarkershape {
///     LineChartMarkerShape::Circle => { /* ... */ },
///     LineChartMarkerShape::Diamond => { /* ... */ },
///     LineChartMarkerShape::RoundedSquare => { /* ... */ },
///     LineChartMarkerShape::Square => { /* ... */ },
///     LineChartMarkerShape::Triangle => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `linechartmarkershape` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LineChartMarkerShape::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LineChartMarkerShape::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LineChartMarkerShape::NewFeature` is defined.
/// Specifically, when `linechartmarkershape` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LineChartMarkerShape::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LineChartMarkerShape {
    #[allow(missing_docs)] // documentation missing in model
    Circle,
    #[allow(missing_docs)] // documentation missing in model
    Diamond,
    #[allow(missing_docs)] // documentation missing in model
    RoundedSquare,
    #[allow(missing_docs)] // documentation missing in model
    Square,
    #[allow(missing_docs)] // documentation missing in model
    Triangle,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LineChartMarkerShape {
    fn from(s: &str) -> Self {
        match s {
            "CIRCLE" => LineChartMarkerShape::Circle,
            "DIAMOND" => LineChartMarkerShape::Diamond,
            "ROUNDED_SQUARE" => LineChartMarkerShape::RoundedSquare,
            "SQUARE" => LineChartMarkerShape::Square,
            "TRIANGLE" => LineChartMarkerShape::Triangle,
            other => {
                LineChartMarkerShape::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for LineChartMarkerShape {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LineChartMarkerShape::from(s))
    }
}
impl LineChartMarkerShape {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LineChartMarkerShape::Circle => "CIRCLE",
            LineChartMarkerShape::Diamond => "DIAMOND",
            LineChartMarkerShape::RoundedSquare => "ROUNDED_SQUARE",
            LineChartMarkerShape::Square => "SQUARE",
            LineChartMarkerShape::Triangle => "TRIANGLE",
            LineChartMarkerShape::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CIRCLE", "DIAMOND", "ROUNDED_SQUARE", "SQUARE", "TRIANGLE"]
    }
}
impl AsRef<str> for LineChartMarkerShape {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Line styles options for a line series in <code>LineChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LineChartLineStyleSettings {
    /// <p>Configuration option that determines whether to show the line for the series.</p>
    #[doc(hidden)]
    pub line_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>Interpolation style for line series.</p>
    /// <ul>
    /// <li> <p> <code>LINEAR</code>: Show as default, linear style.</p> </li>
    /// <li> <p> <code>SMOOTH</code>: Show as a smooth curve.</p> </li>
    /// <li> <p> <code>STEPPED</code>: Show steps in line.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub line_interpolation: std::option::Option<crate::model::LineInterpolation>,
    /// <p>Line style for line series.</p>
    /// <ul>
    /// <li> <p> <code>SOLID</code>: Show as a solid line.</p> </li>
    /// <li> <p> <code>DOTTED</code>: Show as a dotted line.</p> </li>
    /// <li> <p> <code>DASHED</code>: Show as a dashed line.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub line_style: std::option::Option<crate::model::LineChartLineStyle>,
    /// <p>Width that determines the line thickness.</p>
    #[doc(hidden)]
    pub line_width: std::option::Option<std::string::String>,
}
impl LineChartLineStyleSettings {
    /// <p>Configuration option that determines whether to show the line for the series.</p>
    pub fn line_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.line_visibility.as_ref()
    }
    /// <p>Interpolation style for line series.</p>
    /// <ul>
    /// <li> <p> <code>LINEAR</code>: Show as default, linear style.</p> </li>
    /// <li> <p> <code>SMOOTH</code>: Show as a smooth curve.</p> </li>
    /// <li> <p> <code>STEPPED</code>: Show steps in line.</p> </li>
    /// </ul>
    pub fn line_interpolation(&self) -> std::option::Option<&crate::model::LineInterpolation> {
        self.line_interpolation.as_ref()
    }
    /// <p>Line style for line series.</p>
    /// <ul>
    /// <li> <p> <code>SOLID</code>: Show as a solid line.</p> </li>
    /// <li> <p> <code>DOTTED</code>: Show as a dotted line.</p> </li>
    /// <li> <p> <code>DASHED</code>: Show as a dashed line.</p> </li>
    /// </ul>
    pub fn line_style(&self) -> std::option::Option<&crate::model::LineChartLineStyle> {
        self.line_style.as_ref()
    }
    /// <p>Width that determines the line thickness.</p>
    pub fn line_width(&self) -> std::option::Option<&str> {
        self.line_width.as_deref()
    }
}
/// See [`LineChartLineStyleSettings`](crate::model::LineChartLineStyleSettings).
pub mod line_chart_line_style_settings {

    /// A builder for [`LineChartLineStyleSettings`](crate::model::LineChartLineStyleSettings).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) line_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) line_interpolation: std::option::Option<crate::model::LineInterpolation>,
        pub(crate) line_style: std::option::Option<crate::model::LineChartLineStyle>,
        pub(crate) line_width: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Configuration option that determines whether to show the line for the series.</p>
        pub fn line_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.line_visibility = Some(input);
            self
        }
        /// <p>Configuration option that determines whether to show the line for the series.</p>
        pub fn set_line_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.line_visibility = input;
            self
        }
        /// <p>Interpolation style for line series.</p>
        /// <ul>
        /// <li> <p> <code>LINEAR</code>: Show as default, linear style.</p> </li>
        /// <li> <p> <code>SMOOTH</code>: Show as a smooth curve.</p> </li>
        /// <li> <p> <code>STEPPED</code>: Show steps in line.</p> </li>
        /// </ul>
        pub fn line_interpolation(mut self, input: crate::model::LineInterpolation) -> Self {
            self.line_interpolation = Some(input);
            self
        }
        /// <p>Interpolation style for line series.</p>
        /// <ul>
        /// <li> <p> <code>LINEAR</code>: Show as default, linear style.</p> </li>
        /// <li> <p> <code>SMOOTH</code>: Show as a smooth curve.</p> </li>
        /// <li> <p> <code>STEPPED</code>: Show steps in line.</p> </li>
        /// </ul>
        pub fn set_line_interpolation(
            mut self,
            input: std::option::Option<crate::model::LineInterpolation>,
        ) -> Self {
            self.line_interpolation = input;
            self
        }
        /// <p>Line style for line series.</p>
        /// <ul>
        /// <li> <p> <code>SOLID</code>: Show as a solid line.</p> </li>
        /// <li> <p> <code>DOTTED</code>: Show as a dotted line.</p> </li>
        /// <li> <p> <code>DASHED</code>: Show as a dashed line.</p> </li>
        /// </ul>
        pub fn line_style(mut self, input: crate::model::LineChartLineStyle) -> Self {
            self.line_style = Some(input);
            self
        }
        /// <p>Line style for line series.</p>
        /// <ul>
        /// <li> <p> <code>SOLID</code>: Show as a solid line.</p> </li>
        /// <li> <p> <code>DOTTED</code>: Show as a dotted line.</p> </li>
        /// <li> <p> <code>DASHED</code>: Show as a dashed line.</p> </li>
        /// </ul>
        pub fn set_line_style(
            mut self,
            input: std::option::Option<crate::model::LineChartLineStyle>,
        ) -> Self {
            self.line_style = input;
            self
        }
        /// <p>Width that determines the line thickness.</p>
        pub fn line_width(mut self, input: impl Into<std::string::String>) -> Self {
            self.line_width = Some(input.into());
            self
        }
        /// <p>Width that determines the line thickness.</p>
        pub fn set_line_width(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.line_width = input;
            self
        }
        /// Consumes the builder and constructs a [`LineChartLineStyleSettings`](crate::model::LineChartLineStyleSettings).
        pub fn build(self) -> crate::model::LineChartLineStyleSettings {
            crate::model::LineChartLineStyleSettings {
                line_visibility: self.line_visibility,
                line_interpolation: self.line_interpolation,
                line_style: self.line_style,
                line_width: self.line_width,
            }
        }
    }
}
impl LineChartLineStyleSettings {
    /// Creates a new builder-style object to manufacture [`LineChartLineStyleSettings`](crate::model::LineChartLineStyleSettings).
    pub fn builder() -> crate::model::line_chart_line_style_settings::Builder {
        crate::model::line_chart_line_style_settings::Builder::default()
    }
}

/// When writing a match expression against `LineChartLineStyle`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let linechartlinestyle = unimplemented!();
/// match linechartlinestyle {
///     LineChartLineStyle::Dashed => { /* ... */ },
///     LineChartLineStyle::Dotted => { /* ... */ },
///     LineChartLineStyle::Solid => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `linechartlinestyle` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LineChartLineStyle::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LineChartLineStyle::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LineChartLineStyle::NewFeature` is defined.
/// Specifically, when `linechartlinestyle` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LineChartLineStyle::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LineChartLineStyle {
    #[allow(missing_docs)] // documentation missing in model
    Dashed,
    #[allow(missing_docs)] // documentation missing in model
    Dotted,
    #[allow(missing_docs)] // documentation missing in model
    Solid,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LineChartLineStyle {
    fn from(s: &str) -> Self {
        match s {
            "DASHED" => LineChartLineStyle::Dashed,
            "DOTTED" => LineChartLineStyle::Dotted,
            "SOLID" => LineChartLineStyle::Solid,
            other => {
                LineChartLineStyle::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for LineChartLineStyle {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LineChartLineStyle::from(s))
    }
}
impl LineChartLineStyle {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LineChartLineStyle::Dashed => "DASHED",
            LineChartLineStyle::Dotted => "DOTTED",
            LineChartLineStyle::Solid => "SOLID",
            LineChartLineStyle::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DASHED", "DOTTED", "SOLID"]
    }
}
impl AsRef<str> for LineChartLineStyle {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LineInterpolation`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let lineinterpolation = unimplemented!();
/// match lineinterpolation {
///     LineInterpolation::Linear => { /* ... */ },
///     LineInterpolation::Smooth => { /* ... */ },
///     LineInterpolation::Stepped => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lineinterpolation` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LineInterpolation::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LineInterpolation::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LineInterpolation::NewFeature` is defined.
/// Specifically, when `lineinterpolation` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LineInterpolation::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LineInterpolation {
    #[allow(missing_docs)] // documentation missing in model
    Linear,
    #[allow(missing_docs)] // documentation missing in model
    Smooth,
    #[allow(missing_docs)] // documentation missing in model
    Stepped,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LineInterpolation {
    fn from(s: &str) -> Self {
        match s {
            "LINEAR" => LineInterpolation::Linear,
            "SMOOTH" => LineInterpolation::Smooth,
            "STEPPED" => LineInterpolation::Stepped,
            other => {
                LineInterpolation::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for LineInterpolation {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LineInterpolation::from(s))
    }
}
impl LineInterpolation {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LineInterpolation::Linear => "LINEAR",
            LineInterpolation::Smooth => "SMOOTH",
            LineInterpolation::Stepped => "STEPPED",
            LineInterpolation::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LINEAR", "SMOOTH", "STEPPED"]
    }
}
impl AsRef<str> for LineInterpolation {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The field series item configuration of a line chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldSeriesItem {
    /// <p>The field ID of the field for which you are setting the axis binding.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The axis that you are binding the field to.</p>
    #[doc(hidden)]
    pub axis_binding: std::option::Option<crate::model::AxisBinding>,
    /// <p>The options that determine the presentation of line series associated to the field.</p>
    #[doc(hidden)]
    pub settings: std::option::Option<crate::model::LineChartSeriesSettings>,
}
impl FieldSeriesItem {
    /// <p>The field ID of the field for which you are setting the axis binding.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The axis that you are binding the field to.</p>
    pub fn axis_binding(&self) -> std::option::Option<&crate::model::AxisBinding> {
        self.axis_binding.as_ref()
    }
    /// <p>The options that determine the presentation of line series associated to the field.</p>
    pub fn settings(&self) -> std::option::Option<&crate::model::LineChartSeriesSettings> {
        self.settings.as_ref()
    }
}
/// See [`FieldSeriesItem`](crate::model::FieldSeriesItem).
pub mod field_series_item {

    /// A builder for [`FieldSeriesItem`](crate::model::FieldSeriesItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) axis_binding: std::option::Option<crate::model::AxisBinding>,
        pub(crate) settings: std::option::Option<crate::model::LineChartSeriesSettings>,
    }
    impl Builder {
        /// <p>The field ID of the field for which you are setting the axis binding.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The field ID of the field for which you are setting the axis binding.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The axis that you are binding the field to.</p>
        pub fn axis_binding(mut self, input: crate::model::AxisBinding) -> Self {
            self.axis_binding = Some(input);
            self
        }
        /// <p>The axis that you are binding the field to.</p>
        pub fn set_axis_binding(
            mut self,
            input: std::option::Option<crate::model::AxisBinding>,
        ) -> Self {
            self.axis_binding = input;
            self
        }
        /// <p>The options that determine the presentation of line series associated to the field.</p>
        pub fn settings(mut self, input: crate::model::LineChartSeriesSettings) -> Self {
            self.settings = Some(input);
            self
        }
        /// <p>The options that determine the presentation of line series associated to the field.</p>
        pub fn set_settings(
            mut self,
            input: std::option::Option<crate::model::LineChartSeriesSettings>,
        ) -> Self {
            self.settings = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldSeriesItem`](crate::model::FieldSeriesItem).
        pub fn build(self) -> crate::model::FieldSeriesItem {
            crate::model::FieldSeriesItem {
                field_id: self.field_id,
                axis_binding: self.axis_binding,
                settings: self.settings,
            }
        }
    }
}
impl FieldSeriesItem {
    /// Creates a new builder-style object to manufacture [`FieldSeriesItem`](crate::model::FieldSeriesItem).
    pub fn builder() -> crate::model::field_series_item::Builder {
        crate::model::field_series_item::Builder::default()
    }
}

/// <p>The options that determine the default presentation of all line series in <code>LineChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LineChartDefaultSeriesSettings {
    /// <p>The axis to which you are binding all line series to.</p>
    #[doc(hidden)]
    pub axis_binding: std::option::Option<crate::model::AxisBinding>,
    /// <p>Line styles options for all line series in the visual.</p>
    #[doc(hidden)]
    pub line_style_settings: std::option::Option<crate::model::LineChartLineStyleSettings>,
    /// <p>Marker styles options for all line series in the visual.</p>
    #[doc(hidden)]
    pub marker_style_settings: std::option::Option<crate::model::LineChartMarkerStyleSettings>,
}
impl LineChartDefaultSeriesSettings {
    /// <p>The axis to which you are binding all line series to.</p>
    pub fn axis_binding(&self) -> std::option::Option<&crate::model::AxisBinding> {
        self.axis_binding.as_ref()
    }
    /// <p>Line styles options for all line series in the visual.</p>
    pub fn line_style_settings(
        &self,
    ) -> std::option::Option<&crate::model::LineChartLineStyleSettings> {
        self.line_style_settings.as_ref()
    }
    /// <p>Marker styles options for all line series in the visual.</p>
    pub fn marker_style_settings(
        &self,
    ) -> std::option::Option<&crate::model::LineChartMarkerStyleSettings> {
        self.marker_style_settings.as_ref()
    }
}
/// See [`LineChartDefaultSeriesSettings`](crate::model::LineChartDefaultSeriesSettings).
pub mod line_chart_default_series_settings {

    /// A builder for [`LineChartDefaultSeriesSettings`](crate::model::LineChartDefaultSeriesSettings).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) axis_binding: std::option::Option<crate::model::AxisBinding>,
        pub(crate) line_style_settings:
            std::option::Option<crate::model::LineChartLineStyleSettings>,
        pub(crate) marker_style_settings:
            std::option::Option<crate::model::LineChartMarkerStyleSettings>,
    }
    impl Builder {
        /// <p>The axis to which you are binding all line series to.</p>
        pub fn axis_binding(mut self, input: crate::model::AxisBinding) -> Self {
            self.axis_binding = Some(input);
            self
        }
        /// <p>The axis to which you are binding all line series to.</p>
        pub fn set_axis_binding(
            mut self,
            input: std::option::Option<crate::model::AxisBinding>,
        ) -> Self {
            self.axis_binding = input;
            self
        }
        /// <p>Line styles options for all line series in the visual.</p>
        pub fn line_style_settings(
            mut self,
            input: crate::model::LineChartLineStyleSettings,
        ) -> Self {
            self.line_style_settings = Some(input);
            self
        }
        /// <p>Line styles options for all line series in the visual.</p>
        pub fn set_line_style_settings(
            mut self,
            input: std::option::Option<crate::model::LineChartLineStyleSettings>,
        ) -> Self {
            self.line_style_settings = input;
            self
        }
        /// <p>Marker styles options for all line series in the visual.</p>
        pub fn marker_style_settings(
            mut self,
            input: crate::model::LineChartMarkerStyleSettings,
        ) -> Self {
            self.marker_style_settings = Some(input);
            self
        }
        /// <p>Marker styles options for all line series in the visual.</p>
        pub fn set_marker_style_settings(
            mut self,
            input: std::option::Option<crate::model::LineChartMarkerStyleSettings>,
        ) -> Self {
            self.marker_style_settings = input;
            self
        }
        /// Consumes the builder and constructs a [`LineChartDefaultSeriesSettings`](crate::model::LineChartDefaultSeriesSettings).
        pub fn build(self) -> crate::model::LineChartDefaultSeriesSettings {
            crate::model::LineChartDefaultSeriesSettings {
                axis_binding: self.axis_binding,
                line_style_settings: self.line_style_settings,
                marker_style_settings: self.marker_style_settings,
            }
        }
    }
}
impl LineChartDefaultSeriesSettings {
    /// Creates a new builder-style object to manufacture [`LineChartDefaultSeriesSettings`](crate::model::LineChartDefaultSeriesSettings).
    pub fn builder() -> crate::model::line_chart_default_series_settings::Builder {
        crate::model::line_chart_default_series_settings::Builder::default()
    }
}

/// <p>The series axis configuration of a line chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LineSeriesAxisDisplayOptions {
    /// <p>The options that determine the presentation of the line series axis.</p>
    #[doc(hidden)]
    pub axis_options: std::option::Option<crate::model::AxisDisplayOptions>,
    /// <p>The configuration options that determine how missing data is treated during the rendering of a line chart.</p>
    #[doc(hidden)]
    pub missing_data_configurations:
        std::option::Option<std::vec::Vec<crate::model::MissingDataConfiguration>>,
}
impl LineSeriesAxisDisplayOptions {
    /// <p>The options that determine the presentation of the line series axis.</p>
    pub fn axis_options(&self) -> std::option::Option<&crate::model::AxisDisplayOptions> {
        self.axis_options.as_ref()
    }
    /// <p>The configuration options that determine how missing data is treated during the rendering of a line chart.</p>
    pub fn missing_data_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::MissingDataConfiguration]> {
        self.missing_data_configurations.as_deref()
    }
}
/// See [`LineSeriesAxisDisplayOptions`](crate::model::LineSeriesAxisDisplayOptions).
pub mod line_series_axis_display_options {

    /// A builder for [`LineSeriesAxisDisplayOptions`](crate::model::LineSeriesAxisDisplayOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) axis_options: std::option::Option<crate::model::AxisDisplayOptions>,
        pub(crate) missing_data_configurations:
            std::option::Option<std::vec::Vec<crate::model::MissingDataConfiguration>>,
    }
    impl Builder {
        /// <p>The options that determine the presentation of the line series axis.</p>
        pub fn axis_options(mut self, input: crate::model::AxisDisplayOptions) -> Self {
            self.axis_options = Some(input);
            self
        }
        /// <p>The options that determine the presentation of the line series axis.</p>
        pub fn set_axis_options(
            mut self,
            input: std::option::Option<crate::model::AxisDisplayOptions>,
        ) -> Self {
            self.axis_options = input;
            self
        }
        /// Appends an item to `missing_data_configurations`.
        ///
        /// To override the contents of this collection use [`set_missing_data_configurations`](Self::set_missing_data_configurations).
        ///
        /// <p>The configuration options that determine how missing data is treated during the rendering of a line chart.</p>
        pub fn missing_data_configurations(
            mut self,
            input: crate::model::MissingDataConfiguration,
        ) -> Self {
            let mut v = self.missing_data_configurations.unwrap_or_default();
            v.push(input);
            self.missing_data_configurations = Some(v);
            self
        }
        /// <p>The configuration options that determine how missing data is treated during the rendering of a line chart.</p>
        pub fn set_missing_data_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MissingDataConfiguration>>,
        ) -> Self {
            self.missing_data_configurations = input;
            self
        }
        /// Consumes the builder and constructs a [`LineSeriesAxisDisplayOptions`](crate::model::LineSeriesAxisDisplayOptions).
        pub fn build(self) -> crate::model::LineSeriesAxisDisplayOptions {
            crate::model::LineSeriesAxisDisplayOptions {
                axis_options: self.axis_options,
                missing_data_configurations: self.missing_data_configurations,
            }
        }
    }
}
impl LineSeriesAxisDisplayOptions {
    /// Creates a new builder-style object to manufacture [`LineSeriesAxisDisplayOptions`](crate::model::LineSeriesAxisDisplayOptions).
    pub fn builder() -> crate::model::line_series_axis_display_options::Builder {
        crate::model::line_series_axis_display_options::Builder::default()
    }
}

/// <p>The configuration options that determine how missing data is treated during the rendering of a line chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MissingDataConfiguration {
    /// <p>The treatment option that determines how missing data should be rendered. Choose from the following options:</p>
    /// <ul>
    /// <li> <p> <code>INTERPOLATE</code>: Interpolate missing values between the prior and the next known value.</p> </li>
    /// <li> <p> <code>SHOW_AS_ZERO</code>: Show missing values as the value <code>0</code>.</p> </li>
    /// <li> <p> <code>SHOW_AS_BLANK</code>: Display a blank space when rendering missing data.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub treatment_option: std::option::Option<crate::model::MissingDataTreatmentOption>,
}
impl MissingDataConfiguration {
    /// <p>The treatment option that determines how missing data should be rendered. Choose from the following options:</p>
    /// <ul>
    /// <li> <p> <code>INTERPOLATE</code>: Interpolate missing values between the prior and the next known value.</p> </li>
    /// <li> <p> <code>SHOW_AS_ZERO</code>: Show missing values as the value <code>0</code>.</p> </li>
    /// <li> <p> <code>SHOW_AS_BLANK</code>: Display a blank space when rendering missing data.</p> </li>
    /// </ul>
    pub fn treatment_option(
        &self,
    ) -> std::option::Option<&crate::model::MissingDataTreatmentOption> {
        self.treatment_option.as_ref()
    }
}
/// See [`MissingDataConfiguration`](crate::model::MissingDataConfiguration).
pub mod missing_data_configuration {

    /// A builder for [`MissingDataConfiguration`](crate::model::MissingDataConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) treatment_option: std::option::Option<crate::model::MissingDataTreatmentOption>,
    }
    impl Builder {
        /// <p>The treatment option that determines how missing data should be rendered. Choose from the following options:</p>
        /// <ul>
        /// <li> <p> <code>INTERPOLATE</code>: Interpolate missing values between the prior and the next known value.</p> </li>
        /// <li> <p> <code>SHOW_AS_ZERO</code>: Show missing values as the value <code>0</code>.</p> </li>
        /// <li> <p> <code>SHOW_AS_BLANK</code>: Display a blank space when rendering missing data.</p> </li>
        /// </ul>
        pub fn treatment_option(mut self, input: crate::model::MissingDataTreatmentOption) -> Self {
            self.treatment_option = Some(input);
            self
        }
        /// <p>The treatment option that determines how missing data should be rendered. Choose from the following options:</p>
        /// <ul>
        /// <li> <p> <code>INTERPOLATE</code>: Interpolate missing values between the prior and the next known value.</p> </li>
        /// <li> <p> <code>SHOW_AS_ZERO</code>: Show missing values as the value <code>0</code>.</p> </li>
        /// <li> <p> <code>SHOW_AS_BLANK</code>: Display a blank space when rendering missing data.</p> </li>
        /// </ul>
        pub fn set_treatment_option(
            mut self,
            input: std::option::Option<crate::model::MissingDataTreatmentOption>,
        ) -> Self {
            self.treatment_option = input;
            self
        }
        /// Consumes the builder and constructs a [`MissingDataConfiguration`](crate::model::MissingDataConfiguration).
        pub fn build(self) -> crate::model::MissingDataConfiguration {
            crate::model::MissingDataConfiguration {
                treatment_option: self.treatment_option,
            }
        }
    }
}
impl MissingDataConfiguration {
    /// Creates a new builder-style object to manufacture [`MissingDataConfiguration`](crate::model::MissingDataConfiguration).
    pub fn builder() -> crate::model::missing_data_configuration::Builder {
        crate::model::missing_data_configuration::Builder::default()
    }
}

/// When writing a match expression against `MissingDataTreatmentOption`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let missingdatatreatmentoption = unimplemented!();
/// match missingdatatreatmentoption {
///     MissingDataTreatmentOption::Interpolate => { /* ... */ },
///     MissingDataTreatmentOption::ShowAsBlank => { /* ... */ },
///     MissingDataTreatmentOption::ShowAsZero => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `missingdatatreatmentoption` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MissingDataTreatmentOption::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MissingDataTreatmentOption::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MissingDataTreatmentOption::NewFeature` is defined.
/// Specifically, when `missingdatatreatmentoption` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MissingDataTreatmentOption::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MissingDataTreatmentOption {
    #[allow(missing_docs)] // documentation missing in model
    Interpolate,
    #[allow(missing_docs)] // documentation missing in model
    ShowAsBlank,
    #[allow(missing_docs)] // documentation missing in model
    ShowAsZero,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MissingDataTreatmentOption {
    fn from(s: &str) -> Self {
        match s {
            "INTERPOLATE" => MissingDataTreatmentOption::Interpolate,
            "SHOW_AS_BLANK" => MissingDataTreatmentOption::ShowAsBlank,
            "SHOW_AS_ZERO" => MissingDataTreatmentOption::ShowAsZero,
            other => MissingDataTreatmentOption::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for MissingDataTreatmentOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MissingDataTreatmentOption::from(s))
    }
}
impl MissingDataTreatmentOption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MissingDataTreatmentOption::Interpolate => "INTERPOLATE",
            MissingDataTreatmentOption::ShowAsBlank => "SHOW_AS_BLANK",
            MissingDataTreatmentOption::ShowAsZero => "SHOW_AS_ZERO",
            MissingDataTreatmentOption::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INTERPOLATE", "SHOW_AS_BLANK", "SHOW_AS_ZERO"]
    }
}
impl AsRef<str> for MissingDataTreatmentOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Options that determine the layout and display options of a chart's small multiples.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SmallMultiplesOptions {
    /// <p>Sets the maximum number of visible rows to display in the grid of small multiples panels.</p>
    /// <p>The default value is <code>Auto</code>, which automatically adjusts the rows in the grid to fit the overall layout and size of the given chart.</p>
    #[doc(hidden)]
    pub max_visible_rows: std::option::Option<i64>,
    /// <p>Sets the maximum number of visible columns to display in the grid of small multiples panels.</p>
    /// <p>The default is <code>Auto</code>, which automatically adjusts the columns in the grid to fit the overall layout and size of the given chart.</p>
    #[doc(hidden)]
    pub max_visible_columns: std::option::Option<i64>,
    /// <p>Configures the display options for each small multiples panel.</p>
    #[doc(hidden)]
    pub panel_configuration: std::option::Option<crate::model::PanelConfiguration>,
}
impl SmallMultiplesOptions {
    /// <p>Sets the maximum number of visible rows to display in the grid of small multiples panels.</p>
    /// <p>The default value is <code>Auto</code>, which automatically adjusts the rows in the grid to fit the overall layout and size of the given chart.</p>
    pub fn max_visible_rows(&self) -> std::option::Option<i64> {
        self.max_visible_rows
    }
    /// <p>Sets the maximum number of visible columns to display in the grid of small multiples panels.</p>
    /// <p>The default is <code>Auto</code>, which automatically adjusts the columns in the grid to fit the overall layout and size of the given chart.</p>
    pub fn max_visible_columns(&self) -> std::option::Option<i64> {
        self.max_visible_columns
    }
    /// <p>Configures the display options for each small multiples panel.</p>
    pub fn panel_configuration(&self) -> std::option::Option<&crate::model::PanelConfiguration> {
        self.panel_configuration.as_ref()
    }
}
/// See [`SmallMultiplesOptions`](crate::model::SmallMultiplesOptions).
pub mod small_multiples_options {

    /// A builder for [`SmallMultiplesOptions`](crate::model::SmallMultiplesOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_visible_rows: std::option::Option<i64>,
        pub(crate) max_visible_columns: std::option::Option<i64>,
        pub(crate) panel_configuration: std::option::Option<crate::model::PanelConfiguration>,
    }
    impl Builder {
        /// <p>Sets the maximum number of visible rows to display in the grid of small multiples panels.</p>
        /// <p>The default value is <code>Auto</code>, which automatically adjusts the rows in the grid to fit the overall layout and size of the given chart.</p>
        pub fn max_visible_rows(mut self, input: i64) -> Self {
            self.max_visible_rows = Some(input);
            self
        }
        /// <p>Sets the maximum number of visible rows to display in the grid of small multiples panels.</p>
        /// <p>The default value is <code>Auto</code>, which automatically adjusts the rows in the grid to fit the overall layout and size of the given chart.</p>
        pub fn set_max_visible_rows(mut self, input: std::option::Option<i64>) -> Self {
            self.max_visible_rows = input;
            self
        }
        /// <p>Sets the maximum number of visible columns to display in the grid of small multiples panels.</p>
        /// <p>The default is <code>Auto</code>, which automatically adjusts the columns in the grid to fit the overall layout and size of the given chart.</p>
        pub fn max_visible_columns(mut self, input: i64) -> Self {
            self.max_visible_columns = Some(input);
            self
        }
        /// <p>Sets the maximum number of visible columns to display in the grid of small multiples panels.</p>
        /// <p>The default is <code>Auto</code>, which automatically adjusts the columns in the grid to fit the overall layout and size of the given chart.</p>
        pub fn set_max_visible_columns(mut self, input: std::option::Option<i64>) -> Self {
            self.max_visible_columns = input;
            self
        }
        /// <p>Configures the display options for each small multiples panel.</p>
        pub fn panel_configuration(mut self, input: crate::model::PanelConfiguration) -> Self {
            self.panel_configuration = Some(input);
            self
        }
        /// <p>Configures the display options for each small multiples panel.</p>
        pub fn set_panel_configuration(
            mut self,
            input: std::option::Option<crate::model::PanelConfiguration>,
        ) -> Self {
            self.panel_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`SmallMultiplesOptions`](crate::model::SmallMultiplesOptions).
        pub fn build(self) -> crate::model::SmallMultiplesOptions {
            crate::model::SmallMultiplesOptions {
                max_visible_rows: self.max_visible_rows,
                max_visible_columns: self.max_visible_columns,
                panel_configuration: self.panel_configuration,
            }
        }
    }
}
impl SmallMultiplesOptions {
    /// Creates a new builder-style object to manufacture [`SmallMultiplesOptions`](crate::model::SmallMultiplesOptions).
    pub fn builder() -> crate::model::small_multiples_options::Builder {
        crate::model::small_multiples_options::Builder::default()
    }
}

/// <p>A collection of options that configure how each panel displays in a small multiples chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PanelConfiguration {
    /// <p>Configures the title display within each small multiples panel.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::PanelTitleOptions>,
    /// <p>Determines whether or not each panel displays a border.</p>
    #[doc(hidden)]
    pub border_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>Sets the line thickness of panel borders.</p>
    #[doc(hidden)]
    pub border_thickness: std::option::Option<std::string::String>,
    /// <p>Sets the line style of panel borders.</p>
    #[doc(hidden)]
    pub border_style: std::option::Option<crate::model::PanelBorderStyle>,
    /// <p>Sets the line color of panel borders.</p>
    #[doc(hidden)]
    pub border_color: std::option::Option<std::string::String>,
    /// <p>Determines whether or not negative space between sibling panels is rendered.</p>
    #[doc(hidden)]
    pub gutter_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>Sets the total amount of negative space to display between sibling panels.</p>
    #[doc(hidden)]
    pub gutter_spacing: std::option::Option<std::string::String>,
    /// <p>Determines whether or not a background for each small multiples panel is rendered.</p>
    #[doc(hidden)]
    pub background_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>Sets the background color for each panel.</p>
    #[doc(hidden)]
    pub background_color: std::option::Option<std::string::String>,
}
impl PanelConfiguration {
    /// <p>Configures the title display within each small multiples panel.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::PanelTitleOptions> {
        self.title.as_ref()
    }
    /// <p>Determines whether or not each panel displays a border.</p>
    pub fn border_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.border_visibility.as_ref()
    }
    /// <p>Sets the line thickness of panel borders.</p>
    pub fn border_thickness(&self) -> std::option::Option<&str> {
        self.border_thickness.as_deref()
    }
    /// <p>Sets the line style of panel borders.</p>
    pub fn border_style(&self) -> std::option::Option<&crate::model::PanelBorderStyle> {
        self.border_style.as_ref()
    }
    /// <p>Sets the line color of panel borders.</p>
    pub fn border_color(&self) -> std::option::Option<&str> {
        self.border_color.as_deref()
    }
    /// <p>Determines whether or not negative space between sibling panels is rendered.</p>
    pub fn gutter_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.gutter_visibility.as_ref()
    }
    /// <p>Sets the total amount of negative space to display between sibling panels.</p>
    pub fn gutter_spacing(&self) -> std::option::Option<&str> {
        self.gutter_spacing.as_deref()
    }
    /// <p>Determines whether or not a background for each small multiples panel is rendered.</p>
    pub fn background_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.background_visibility.as_ref()
    }
    /// <p>Sets the background color for each panel.</p>
    pub fn background_color(&self) -> std::option::Option<&str> {
        self.background_color.as_deref()
    }
}
/// See [`PanelConfiguration`](crate::model::PanelConfiguration).
pub mod panel_configuration {

    /// A builder for [`PanelConfiguration`](crate::model::PanelConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) title: std::option::Option<crate::model::PanelTitleOptions>,
        pub(crate) border_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) border_thickness: std::option::Option<std::string::String>,
        pub(crate) border_style: std::option::Option<crate::model::PanelBorderStyle>,
        pub(crate) border_color: std::option::Option<std::string::String>,
        pub(crate) gutter_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) gutter_spacing: std::option::Option<std::string::String>,
        pub(crate) background_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) background_color: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Configures the title display within each small multiples panel.</p>
        pub fn title(mut self, input: crate::model::PanelTitleOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>Configures the title display within each small multiples panel.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::PanelTitleOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>Determines whether or not each panel displays a border.</p>
        pub fn border_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.border_visibility = Some(input);
            self
        }
        /// <p>Determines whether or not each panel displays a border.</p>
        pub fn set_border_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.border_visibility = input;
            self
        }
        /// <p>Sets the line thickness of panel borders.</p>
        pub fn border_thickness(mut self, input: impl Into<std::string::String>) -> Self {
            self.border_thickness = Some(input.into());
            self
        }
        /// <p>Sets the line thickness of panel borders.</p>
        pub fn set_border_thickness(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.border_thickness = input;
            self
        }
        /// <p>Sets the line style of panel borders.</p>
        pub fn border_style(mut self, input: crate::model::PanelBorderStyle) -> Self {
            self.border_style = Some(input);
            self
        }
        /// <p>Sets the line style of panel borders.</p>
        pub fn set_border_style(
            mut self,
            input: std::option::Option<crate::model::PanelBorderStyle>,
        ) -> Self {
            self.border_style = input;
            self
        }
        /// <p>Sets the line color of panel borders.</p>
        pub fn border_color(mut self, input: impl Into<std::string::String>) -> Self {
            self.border_color = Some(input.into());
            self
        }
        /// <p>Sets the line color of panel borders.</p>
        pub fn set_border_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.border_color = input;
            self
        }
        /// <p>Determines whether or not negative space between sibling panels is rendered.</p>
        pub fn gutter_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.gutter_visibility = Some(input);
            self
        }
        /// <p>Determines whether or not negative space between sibling panels is rendered.</p>
        pub fn set_gutter_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.gutter_visibility = input;
            self
        }
        /// <p>Sets the total amount of negative space to display between sibling panels.</p>
        pub fn gutter_spacing(mut self, input: impl Into<std::string::String>) -> Self {
            self.gutter_spacing = Some(input.into());
            self
        }
        /// <p>Sets the total amount of negative space to display between sibling panels.</p>
        pub fn set_gutter_spacing(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.gutter_spacing = input;
            self
        }
        /// <p>Determines whether or not a background for each small multiples panel is rendered.</p>
        pub fn background_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.background_visibility = Some(input);
            self
        }
        /// <p>Determines whether or not a background for each small multiples panel is rendered.</p>
        pub fn set_background_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.background_visibility = input;
            self
        }
        /// <p>Sets the background color for each panel.</p>
        pub fn background_color(mut self, input: impl Into<std::string::String>) -> Self {
            self.background_color = Some(input.into());
            self
        }
        /// <p>Sets the background color for each panel.</p>
        pub fn set_background_color(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.background_color = input;
            self
        }
        /// Consumes the builder and constructs a [`PanelConfiguration`](crate::model::PanelConfiguration).
        pub fn build(self) -> crate::model::PanelConfiguration {
            crate::model::PanelConfiguration {
                title: self.title,
                border_visibility: self.border_visibility,
                border_thickness: self.border_thickness,
                border_style: self.border_style,
                border_color: self.border_color,
                gutter_visibility: self.gutter_visibility,
                gutter_spacing: self.gutter_spacing,
                background_visibility: self.background_visibility,
                background_color: self.background_color,
            }
        }
    }
}
impl PanelConfiguration {
    /// Creates a new builder-style object to manufacture [`PanelConfiguration`](crate::model::PanelConfiguration).
    pub fn builder() -> crate::model::panel_configuration::Builder {
        crate::model::panel_configuration::Builder::default()
    }
}

/// When writing a match expression against `PanelBorderStyle`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let panelborderstyle = unimplemented!();
/// match panelborderstyle {
///     PanelBorderStyle::Dashed => { /* ... */ },
///     PanelBorderStyle::Dotted => { /* ... */ },
///     PanelBorderStyle::Solid => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `panelborderstyle` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PanelBorderStyle::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PanelBorderStyle::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PanelBorderStyle::NewFeature` is defined.
/// Specifically, when `panelborderstyle` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PanelBorderStyle::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PanelBorderStyle {
    #[allow(missing_docs)] // documentation missing in model
    Dashed,
    #[allow(missing_docs)] // documentation missing in model
    Dotted,
    #[allow(missing_docs)] // documentation missing in model
    Solid,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PanelBorderStyle {
    fn from(s: &str) -> Self {
        match s {
            "DASHED" => PanelBorderStyle::Dashed,
            "DOTTED" => PanelBorderStyle::Dotted,
            "SOLID" => PanelBorderStyle::Solid,
            other => PanelBorderStyle::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PanelBorderStyle {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PanelBorderStyle::from(s))
    }
}
impl PanelBorderStyle {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PanelBorderStyle::Dashed => "DASHED",
            PanelBorderStyle::Dotted => "DOTTED",
            PanelBorderStyle::Solid => "SOLID",
            PanelBorderStyle::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DASHED", "DOTTED", "SOLID"]
    }
}
impl AsRef<str> for PanelBorderStyle {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The options that determine the title styles for each small multiples panel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PanelTitleOptions {
    /// <p>Determines whether or not panel titles are displayed.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
    /// <p>Configures the display properties of the given text.</p>
    #[doc(hidden)]
    pub font_configuration: std::option::Option<crate::model::FontConfiguration>,
    /// <p>Sets the horizontal text alignment of the title within each panel.</p>
    #[doc(hidden)]
    pub horizontal_text_alignment: std::option::Option<crate::model::HorizontalTextAlignment>,
}
impl PanelTitleOptions {
    /// <p>Determines whether or not panel titles are displayed.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
    /// <p>Configures the display properties of the given text.</p>
    pub fn font_configuration(&self) -> std::option::Option<&crate::model::FontConfiguration> {
        self.font_configuration.as_ref()
    }
    /// <p>Sets the horizontal text alignment of the title within each panel.</p>
    pub fn horizontal_text_alignment(
        &self,
    ) -> std::option::Option<&crate::model::HorizontalTextAlignment> {
        self.horizontal_text_alignment.as_ref()
    }
}
/// See [`PanelTitleOptions`](crate::model::PanelTitleOptions).
pub mod panel_title_options {

    /// A builder for [`PanelTitleOptions`](crate::model::PanelTitleOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) font_configuration: std::option::Option<crate::model::FontConfiguration>,
        pub(crate) horizontal_text_alignment:
            std::option::Option<crate::model::HorizontalTextAlignment>,
    }
    impl Builder {
        /// <p>Determines whether or not panel titles are displayed.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>Determines whether or not panel titles are displayed.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// <p>Configures the display properties of the given text.</p>
        pub fn font_configuration(mut self, input: crate::model::FontConfiguration) -> Self {
            self.font_configuration = Some(input);
            self
        }
        /// <p>Configures the display properties of the given text.</p>
        pub fn set_font_configuration(
            mut self,
            input: std::option::Option<crate::model::FontConfiguration>,
        ) -> Self {
            self.font_configuration = input;
            self
        }
        /// <p>Sets the horizontal text alignment of the title within each panel.</p>
        pub fn horizontal_text_alignment(
            mut self,
            input: crate::model::HorizontalTextAlignment,
        ) -> Self {
            self.horizontal_text_alignment = Some(input);
            self
        }
        /// <p>Sets the horizontal text alignment of the title within each panel.</p>
        pub fn set_horizontal_text_alignment(
            mut self,
            input: std::option::Option<crate::model::HorizontalTextAlignment>,
        ) -> Self {
            self.horizontal_text_alignment = input;
            self
        }
        /// Consumes the builder and constructs a [`PanelTitleOptions`](crate::model::PanelTitleOptions).
        pub fn build(self) -> crate::model::PanelTitleOptions {
            crate::model::PanelTitleOptions {
                visibility: self.visibility,
                font_configuration: self.font_configuration,
                horizontal_text_alignment: self.horizontal_text_alignment,
            }
        }
    }
}
impl PanelTitleOptions {
    /// Creates a new builder-style object to manufacture [`PanelTitleOptions`](crate::model::PanelTitleOptions).
    pub fn builder() -> crate::model::panel_title_options::Builder {
        crate::model::panel_title_options::Builder::default()
    }
}

/// When writing a match expression against `HorizontalTextAlignment`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let horizontaltextalignment = unimplemented!();
/// match horizontaltextalignment {
///     HorizontalTextAlignment::Auto => { /* ... */ },
///     HorizontalTextAlignment::Center => { /* ... */ },
///     HorizontalTextAlignment::Left => { /* ... */ },
///     HorizontalTextAlignment::Right => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `horizontaltextalignment` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `HorizontalTextAlignment::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `HorizontalTextAlignment::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `HorizontalTextAlignment::NewFeature` is defined.
/// Specifically, when `horizontaltextalignment` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `HorizontalTextAlignment::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HorizontalTextAlignment {
    #[allow(missing_docs)] // documentation missing in model
    Auto,
    #[allow(missing_docs)] // documentation missing in model
    Center,
    #[allow(missing_docs)] // documentation missing in model
    Left,
    #[allow(missing_docs)] // documentation missing in model
    Right,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for HorizontalTextAlignment {
    fn from(s: &str) -> Self {
        match s {
            "AUTO" => HorizontalTextAlignment::Auto,
            "CENTER" => HorizontalTextAlignment::Center,
            "LEFT" => HorizontalTextAlignment::Left,
            "RIGHT" => HorizontalTextAlignment::Right,
            other => HorizontalTextAlignment::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for HorizontalTextAlignment {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HorizontalTextAlignment::from(s))
    }
}
impl HorizontalTextAlignment {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HorizontalTextAlignment::Auto => "AUTO",
            HorizontalTextAlignment::Center => "CENTER",
            HorizontalTextAlignment::Left => "LEFT",
            HorizontalTextAlignment::Right => "RIGHT",
            HorizontalTextAlignment::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AUTO", "CENTER", "LEFT", "RIGHT"]
    }
}
impl AsRef<str> for HorizontalTextAlignment {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LineChartType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let linecharttype = unimplemented!();
/// match linecharttype {
///     LineChartType::Area => { /* ... */ },
///     LineChartType::Line => { /* ... */ },
///     LineChartType::StackedArea => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `linecharttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LineChartType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LineChartType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LineChartType::NewFeature` is defined.
/// Specifically, when `linecharttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LineChartType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LineChartType {
    #[allow(missing_docs)] // documentation missing in model
    Area,
    #[allow(missing_docs)] // documentation missing in model
    Line,
    #[allow(missing_docs)] // documentation missing in model
    StackedArea,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LineChartType {
    fn from(s: &str) -> Self {
        match s {
            "AREA" => LineChartType::Area,
            "LINE" => LineChartType::Line,
            "STACKED_AREA" => LineChartType::StackedArea,
            other => LineChartType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LineChartType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LineChartType::from(s))
    }
}
impl LineChartType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LineChartType::Area => "AREA",
            LineChartType::Line => "LINE",
            LineChartType::StackedArea => "STACKED_AREA",
            LineChartType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AREA", "LINE", "STACKED_AREA"]
    }
}
impl AsRef<str> for LineChartType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The forecast configuration that is used in a line chart's display properties.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ForecastConfiguration {
    /// <p>The forecast properties setup of a forecast in the line chart.</p>
    #[doc(hidden)]
    pub forecast_properties: std::option::Option<crate::model::TimeBasedForecastProperties>,
    /// <p>The forecast scenario of a forecast in the line chart.</p>
    #[doc(hidden)]
    pub scenario: std::option::Option<crate::model::ForecastScenario>,
}
impl ForecastConfiguration {
    /// <p>The forecast properties setup of a forecast in the line chart.</p>
    pub fn forecast_properties(
        &self,
    ) -> std::option::Option<&crate::model::TimeBasedForecastProperties> {
        self.forecast_properties.as_ref()
    }
    /// <p>The forecast scenario of a forecast in the line chart.</p>
    pub fn scenario(&self) -> std::option::Option<&crate::model::ForecastScenario> {
        self.scenario.as_ref()
    }
}
/// See [`ForecastConfiguration`](crate::model::ForecastConfiguration).
pub mod forecast_configuration {

    /// A builder for [`ForecastConfiguration`](crate::model::ForecastConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) forecast_properties:
            std::option::Option<crate::model::TimeBasedForecastProperties>,
        pub(crate) scenario: std::option::Option<crate::model::ForecastScenario>,
    }
    impl Builder {
        /// <p>The forecast properties setup of a forecast in the line chart.</p>
        pub fn forecast_properties(
            mut self,
            input: crate::model::TimeBasedForecastProperties,
        ) -> Self {
            self.forecast_properties = Some(input);
            self
        }
        /// <p>The forecast properties setup of a forecast in the line chart.</p>
        pub fn set_forecast_properties(
            mut self,
            input: std::option::Option<crate::model::TimeBasedForecastProperties>,
        ) -> Self {
            self.forecast_properties = input;
            self
        }
        /// <p>The forecast scenario of a forecast in the line chart.</p>
        pub fn scenario(mut self, input: crate::model::ForecastScenario) -> Self {
            self.scenario = Some(input);
            self
        }
        /// <p>The forecast scenario of a forecast in the line chart.</p>
        pub fn set_scenario(
            mut self,
            input: std::option::Option<crate::model::ForecastScenario>,
        ) -> Self {
            self.scenario = input;
            self
        }
        /// Consumes the builder and constructs a [`ForecastConfiguration`](crate::model::ForecastConfiguration).
        pub fn build(self) -> crate::model::ForecastConfiguration {
            crate::model::ForecastConfiguration {
                forecast_properties: self.forecast_properties,
                scenario: self.scenario,
            }
        }
    }
}
impl ForecastConfiguration {
    /// Creates a new builder-style object to manufacture [`ForecastConfiguration`](crate::model::ForecastConfiguration).
    pub fn builder() -> crate::model::forecast_configuration::Builder {
        crate::model::forecast_configuration::Builder::default()
    }
}

/// <p>The forecast scenario of a forecast in the line chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ForecastScenario {
    /// <p>The what-if analysis forecast setup with the target date.</p>
    #[doc(hidden)]
    pub what_if_point_scenario: std::option::Option<crate::model::WhatIfPointScenario>,
    /// <p>The what-if analysis forecast setup with the date range.</p>
    #[doc(hidden)]
    pub what_if_range_scenario: std::option::Option<crate::model::WhatIfRangeScenario>,
}
impl ForecastScenario {
    /// <p>The what-if analysis forecast setup with the target date.</p>
    pub fn what_if_point_scenario(
        &self,
    ) -> std::option::Option<&crate::model::WhatIfPointScenario> {
        self.what_if_point_scenario.as_ref()
    }
    /// <p>The what-if analysis forecast setup with the date range.</p>
    pub fn what_if_range_scenario(
        &self,
    ) -> std::option::Option<&crate::model::WhatIfRangeScenario> {
        self.what_if_range_scenario.as_ref()
    }
}
/// See [`ForecastScenario`](crate::model::ForecastScenario).
pub mod forecast_scenario {

    /// A builder for [`ForecastScenario`](crate::model::ForecastScenario).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) what_if_point_scenario: std::option::Option<crate::model::WhatIfPointScenario>,
        pub(crate) what_if_range_scenario: std::option::Option<crate::model::WhatIfRangeScenario>,
    }
    impl Builder {
        /// <p>The what-if analysis forecast setup with the target date.</p>
        pub fn what_if_point_scenario(mut self, input: crate::model::WhatIfPointScenario) -> Self {
            self.what_if_point_scenario = Some(input);
            self
        }
        /// <p>The what-if analysis forecast setup with the target date.</p>
        pub fn set_what_if_point_scenario(
            mut self,
            input: std::option::Option<crate::model::WhatIfPointScenario>,
        ) -> Self {
            self.what_if_point_scenario = input;
            self
        }
        /// <p>The what-if analysis forecast setup with the date range.</p>
        pub fn what_if_range_scenario(mut self, input: crate::model::WhatIfRangeScenario) -> Self {
            self.what_if_range_scenario = Some(input);
            self
        }
        /// <p>The what-if analysis forecast setup with the date range.</p>
        pub fn set_what_if_range_scenario(
            mut self,
            input: std::option::Option<crate::model::WhatIfRangeScenario>,
        ) -> Self {
            self.what_if_range_scenario = input;
            self
        }
        /// Consumes the builder and constructs a [`ForecastScenario`](crate::model::ForecastScenario).
        pub fn build(self) -> crate::model::ForecastScenario {
            crate::model::ForecastScenario {
                what_if_point_scenario: self.what_if_point_scenario,
                what_if_range_scenario: self.what_if_range_scenario,
            }
        }
    }
}
impl ForecastScenario {
    /// Creates a new builder-style object to manufacture [`ForecastScenario`](crate::model::ForecastScenario).
    pub fn builder() -> crate::model::forecast_scenario::Builder {
        crate::model::forecast_scenario::Builder::default()
    }
}

/// <p>Provides the forecast to meet the target for a particular date range.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WhatIfRangeScenario {
    /// <p>The start date in the date range that you need the forecast results for.</p>
    #[doc(hidden)]
    pub start_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The end date in the date range that you need the forecast results for.</p>
    #[doc(hidden)]
    pub end_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The target value that you want to meet for the provided date range.</p>
    #[doc(hidden)]
    pub value: f64,
}
impl WhatIfRangeScenario {
    /// <p>The start date in the date range that you need the forecast results for.</p>
    pub fn start_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_date.as_ref()
    }
    /// <p>The end date in the date range that you need the forecast results for.</p>
    pub fn end_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_date.as_ref()
    }
    /// <p>The target value that you want to meet for the provided date range.</p>
    pub fn value(&self) -> f64 {
        self.value
    }
}
/// See [`WhatIfRangeScenario`](crate::model::WhatIfRangeScenario).
pub mod what_if_range_scenario {

    /// A builder for [`WhatIfRangeScenario`](crate::model::WhatIfRangeScenario).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The start date in the date range that you need the forecast results for.</p>
        pub fn start_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_date = Some(input);
            self
        }
        /// <p>The start date in the date range that you need the forecast results for.</p>
        pub fn set_start_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_date = input;
            self
        }
        /// <p>The end date in the date range that you need the forecast results for.</p>
        pub fn end_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_date = Some(input);
            self
        }
        /// <p>The end date in the date range that you need the forecast results for.</p>
        pub fn set_end_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_date = input;
            self
        }
        /// <p>The target value that you want to meet for the provided date range.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The target value that you want to meet for the provided date range.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`WhatIfRangeScenario`](crate::model::WhatIfRangeScenario).
        pub fn build(self) -> crate::model::WhatIfRangeScenario {
            crate::model::WhatIfRangeScenario {
                start_date: self.start_date,
                end_date: self.end_date,
                value: self.value.unwrap_or_default(),
            }
        }
    }
}
impl WhatIfRangeScenario {
    /// Creates a new builder-style object to manufacture [`WhatIfRangeScenario`](crate::model::WhatIfRangeScenario).
    pub fn builder() -> crate::model::what_if_range_scenario::Builder {
        crate::model::what_if_range_scenario::Builder::default()
    }
}

/// <p>Provides the forecast to meet the target for a particular date.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WhatIfPointScenario {
    /// <p>The date that you need the forecast results for.</p>
    #[doc(hidden)]
    pub date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The target value that you want to meet for the provided date.</p>
    #[doc(hidden)]
    pub value: f64,
}
impl WhatIfPointScenario {
    /// <p>The date that you need the forecast results for.</p>
    pub fn date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.date.as_ref()
    }
    /// <p>The target value that you want to meet for the provided date.</p>
    pub fn value(&self) -> f64 {
        self.value
    }
}
/// See [`WhatIfPointScenario`](crate::model::WhatIfPointScenario).
pub mod what_if_point_scenario {

    /// A builder for [`WhatIfPointScenario`](crate::model::WhatIfPointScenario).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The date that you need the forecast results for.</p>
        pub fn date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.date = Some(input);
            self
        }
        /// <p>The date that you need the forecast results for.</p>
        pub fn set_date(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.date = input;
            self
        }
        /// <p>The target value that you want to meet for the provided date.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The target value that you want to meet for the provided date.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`WhatIfPointScenario`](crate::model::WhatIfPointScenario).
        pub fn build(self) -> crate::model::WhatIfPointScenario {
            crate::model::WhatIfPointScenario {
                date: self.date,
                value: self.value.unwrap_or_default(),
            }
        }
    }
}
impl WhatIfPointScenario {
    /// Creates a new builder-style object to manufacture [`WhatIfPointScenario`](crate::model::WhatIfPointScenario).
    pub fn builder() -> crate::model::what_if_point_scenario::Builder {
        crate::model::what_if_point_scenario::Builder::default()
    }
}

/// <p>The forecast properties setup of a forecast in the line chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimeBasedForecastProperties {
    /// <p>The periods forward setup of a forecast computation.</p>
    #[doc(hidden)]
    pub periods_forward: std::option::Option<i32>,
    /// <p>The periods backward setup of a forecast computation.</p>
    #[doc(hidden)]
    pub periods_backward: std::option::Option<i32>,
    /// <p>The upper boundary setup of a forecast computation.</p>
    #[doc(hidden)]
    pub upper_boundary: std::option::Option<f64>,
    /// <p>The lower boundary setup of a forecast computation.</p>
    #[doc(hidden)]
    pub lower_boundary: std::option::Option<f64>,
    /// <p>The prediction interval setup of a forecast computation.</p>
    #[doc(hidden)]
    pub prediction_interval: std::option::Option<i32>,
    /// <p>The seasonality setup of a forecast computation. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>NULL</code>: The input is set to <code>NULL</code>.</p> </li>
    /// <li> <p> <code>NON_NULL</code>: The input is set to a custom value.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub seasonality: std::option::Option<i32>,
}
impl TimeBasedForecastProperties {
    /// <p>The periods forward setup of a forecast computation.</p>
    pub fn periods_forward(&self) -> std::option::Option<i32> {
        self.periods_forward
    }
    /// <p>The periods backward setup of a forecast computation.</p>
    pub fn periods_backward(&self) -> std::option::Option<i32> {
        self.periods_backward
    }
    /// <p>The upper boundary setup of a forecast computation.</p>
    pub fn upper_boundary(&self) -> std::option::Option<f64> {
        self.upper_boundary
    }
    /// <p>The lower boundary setup of a forecast computation.</p>
    pub fn lower_boundary(&self) -> std::option::Option<f64> {
        self.lower_boundary
    }
    /// <p>The prediction interval setup of a forecast computation.</p>
    pub fn prediction_interval(&self) -> std::option::Option<i32> {
        self.prediction_interval
    }
    /// <p>The seasonality setup of a forecast computation. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>NULL</code>: The input is set to <code>NULL</code>.</p> </li>
    /// <li> <p> <code>NON_NULL</code>: The input is set to a custom value.</p> </li>
    /// </ul>
    pub fn seasonality(&self) -> std::option::Option<i32> {
        self.seasonality
    }
}
/// See [`TimeBasedForecastProperties`](crate::model::TimeBasedForecastProperties).
pub mod time_based_forecast_properties {

    /// A builder for [`TimeBasedForecastProperties`](crate::model::TimeBasedForecastProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) periods_forward: std::option::Option<i32>,
        pub(crate) periods_backward: std::option::Option<i32>,
        pub(crate) upper_boundary: std::option::Option<f64>,
        pub(crate) lower_boundary: std::option::Option<f64>,
        pub(crate) prediction_interval: std::option::Option<i32>,
        pub(crate) seasonality: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The periods forward setup of a forecast computation.</p>
        pub fn periods_forward(mut self, input: i32) -> Self {
            self.periods_forward = Some(input);
            self
        }
        /// <p>The periods forward setup of a forecast computation.</p>
        pub fn set_periods_forward(mut self, input: std::option::Option<i32>) -> Self {
            self.periods_forward = input;
            self
        }
        /// <p>The periods backward setup of a forecast computation.</p>
        pub fn periods_backward(mut self, input: i32) -> Self {
            self.periods_backward = Some(input);
            self
        }
        /// <p>The periods backward setup of a forecast computation.</p>
        pub fn set_periods_backward(mut self, input: std::option::Option<i32>) -> Self {
            self.periods_backward = input;
            self
        }
        /// <p>The upper boundary setup of a forecast computation.</p>
        pub fn upper_boundary(mut self, input: f64) -> Self {
            self.upper_boundary = Some(input);
            self
        }
        /// <p>The upper boundary setup of a forecast computation.</p>
        pub fn set_upper_boundary(mut self, input: std::option::Option<f64>) -> Self {
            self.upper_boundary = input;
            self
        }
        /// <p>The lower boundary setup of a forecast computation.</p>
        pub fn lower_boundary(mut self, input: f64) -> Self {
            self.lower_boundary = Some(input);
            self
        }
        /// <p>The lower boundary setup of a forecast computation.</p>
        pub fn set_lower_boundary(mut self, input: std::option::Option<f64>) -> Self {
            self.lower_boundary = input;
            self
        }
        /// <p>The prediction interval setup of a forecast computation.</p>
        pub fn prediction_interval(mut self, input: i32) -> Self {
            self.prediction_interval = Some(input);
            self
        }
        /// <p>The prediction interval setup of a forecast computation.</p>
        pub fn set_prediction_interval(mut self, input: std::option::Option<i32>) -> Self {
            self.prediction_interval = input;
            self
        }
        /// <p>The seasonality setup of a forecast computation. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>NULL</code>: The input is set to <code>NULL</code>.</p> </li>
        /// <li> <p> <code>NON_NULL</code>: The input is set to a custom value.</p> </li>
        /// </ul>
        pub fn seasonality(mut self, input: i32) -> Self {
            self.seasonality = Some(input);
            self
        }
        /// <p>The seasonality setup of a forecast computation. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>NULL</code>: The input is set to <code>NULL</code>.</p> </li>
        /// <li> <p> <code>NON_NULL</code>: The input is set to a custom value.</p> </li>
        /// </ul>
        pub fn set_seasonality(mut self, input: std::option::Option<i32>) -> Self {
            self.seasonality = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeBasedForecastProperties`](crate::model::TimeBasedForecastProperties).
        pub fn build(self) -> crate::model::TimeBasedForecastProperties {
            crate::model::TimeBasedForecastProperties {
                periods_forward: self.periods_forward,
                periods_backward: self.periods_backward,
                upper_boundary: self.upper_boundary,
                lower_boundary: self.lower_boundary,
                prediction_interval: self.prediction_interval,
                seasonality: self.seasonality,
            }
        }
    }
}
impl TimeBasedForecastProperties {
    /// Creates a new builder-style object to manufacture [`TimeBasedForecastProperties`](crate::model::TimeBasedForecastProperties).
    pub fn builder() -> crate::model::time_based_forecast_properties::Builder {
        crate::model::time_based_forecast_properties::Builder::default()
    }
}

/// <p>The sort configuration of a line chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LineChartSortConfiguration {
    /// <p>The sort configuration of the category fields.</p>
    #[doc(hidden)]
    pub category_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    /// <p>The limit on the number of categories that are displayed in a line chart.</p>
    #[doc(hidden)]
    pub category_items_limit_configuration:
        std::option::Option<crate::model::ItemsLimitConfiguration>,
    /// <p>The limit on the number of lines that are displayed in a line chart.</p>
    #[doc(hidden)]
    pub color_items_limit_configuration: std::option::Option<crate::model::ItemsLimitConfiguration>,
    /// <p>The sort configuration of the small multiples field.</p>
    #[doc(hidden)]
    pub small_multiples_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    /// <p>The limit on the number of small multiples panels that are displayed.</p>
    #[doc(hidden)]
    pub small_multiples_limit_configuration:
        std::option::Option<crate::model::ItemsLimitConfiguration>,
}
impl LineChartSortConfiguration {
    /// <p>The sort configuration of the category fields.</p>
    pub fn category_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.category_sort.as_deref()
    }
    /// <p>The limit on the number of categories that are displayed in a line chart.</p>
    pub fn category_items_limit_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ItemsLimitConfiguration> {
        self.category_items_limit_configuration.as_ref()
    }
    /// <p>The limit on the number of lines that are displayed in a line chart.</p>
    pub fn color_items_limit_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ItemsLimitConfiguration> {
        self.color_items_limit_configuration.as_ref()
    }
    /// <p>The sort configuration of the small multiples field.</p>
    pub fn small_multiples_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.small_multiples_sort.as_deref()
    }
    /// <p>The limit on the number of small multiples panels that are displayed.</p>
    pub fn small_multiples_limit_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ItemsLimitConfiguration> {
        self.small_multiples_limit_configuration.as_ref()
    }
}
/// See [`LineChartSortConfiguration`](crate::model::LineChartSortConfiguration).
pub mod line_chart_sort_configuration {

    /// A builder for [`LineChartSortConfiguration`](crate::model::LineChartSortConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category_sort:
            std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        pub(crate) category_items_limit_configuration:
            std::option::Option<crate::model::ItemsLimitConfiguration>,
        pub(crate) color_items_limit_configuration:
            std::option::Option<crate::model::ItemsLimitConfiguration>,
        pub(crate) small_multiples_sort:
            std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        pub(crate) small_multiples_limit_configuration:
            std::option::Option<crate::model::ItemsLimitConfiguration>,
    }
    impl Builder {
        /// Appends an item to `category_sort`.
        ///
        /// To override the contents of this collection use [`set_category_sort`](Self::set_category_sort).
        ///
        /// <p>The sort configuration of the category fields.</p>
        pub fn category_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.category_sort.unwrap_or_default();
            v.push(input);
            self.category_sort = Some(v);
            self
        }
        /// <p>The sort configuration of the category fields.</p>
        pub fn set_category_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.category_sort = input;
            self
        }
        /// <p>The limit on the number of categories that are displayed in a line chart.</p>
        pub fn category_items_limit_configuration(
            mut self,
            input: crate::model::ItemsLimitConfiguration,
        ) -> Self {
            self.category_items_limit_configuration = Some(input);
            self
        }
        /// <p>The limit on the number of categories that are displayed in a line chart.</p>
        pub fn set_category_items_limit_configuration(
            mut self,
            input: std::option::Option<crate::model::ItemsLimitConfiguration>,
        ) -> Self {
            self.category_items_limit_configuration = input;
            self
        }
        /// <p>The limit on the number of lines that are displayed in a line chart.</p>
        pub fn color_items_limit_configuration(
            mut self,
            input: crate::model::ItemsLimitConfiguration,
        ) -> Self {
            self.color_items_limit_configuration = Some(input);
            self
        }
        /// <p>The limit on the number of lines that are displayed in a line chart.</p>
        pub fn set_color_items_limit_configuration(
            mut self,
            input: std::option::Option<crate::model::ItemsLimitConfiguration>,
        ) -> Self {
            self.color_items_limit_configuration = input;
            self
        }
        /// Appends an item to `small_multiples_sort`.
        ///
        /// To override the contents of this collection use [`set_small_multiples_sort`](Self::set_small_multiples_sort).
        ///
        /// <p>The sort configuration of the small multiples field.</p>
        pub fn small_multiples_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.small_multiples_sort.unwrap_or_default();
            v.push(input);
            self.small_multiples_sort = Some(v);
            self
        }
        /// <p>The sort configuration of the small multiples field.</p>
        pub fn set_small_multiples_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.small_multiples_sort = input;
            self
        }
        /// <p>The limit on the number of small multiples panels that are displayed.</p>
        pub fn small_multiples_limit_configuration(
            mut self,
            input: crate::model::ItemsLimitConfiguration,
        ) -> Self {
            self.small_multiples_limit_configuration = Some(input);
            self
        }
        /// <p>The limit on the number of small multiples panels that are displayed.</p>
        pub fn set_small_multiples_limit_configuration(
            mut self,
            input: std::option::Option<crate::model::ItemsLimitConfiguration>,
        ) -> Self {
            self.small_multiples_limit_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`LineChartSortConfiguration`](crate::model::LineChartSortConfiguration).
        pub fn build(self) -> crate::model::LineChartSortConfiguration {
            crate::model::LineChartSortConfiguration {
                category_sort: self.category_sort,
                category_items_limit_configuration: self.category_items_limit_configuration,
                color_items_limit_configuration: self.color_items_limit_configuration,
                small_multiples_sort: self.small_multiples_sort,
                small_multiples_limit_configuration: self.small_multiples_limit_configuration,
            }
        }
    }
}
impl LineChartSortConfiguration {
    /// Creates a new builder-style object to manufacture [`LineChartSortConfiguration`](crate::model::LineChartSortConfiguration).
    pub fn builder() -> crate::model::line_chart_sort_configuration::Builder {
        crate::model::line_chart_sort_configuration::Builder::default()
    }
}

/// <p>The field well configuration of a line chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LineChartFieldWells {
    /// <p>The field well configuration of a line chart.</p>
    #[doc(hidden)]
    pub line_chart_aggregated_field_wells:
        std::option::Option<crate::model::LineChartAggregatedFieldWells>,
}
impl LineChartFieldWells {
    /// <p>The field well configuration of a line chart.</p>
    pub fn line_chart_aggregated_field_wells(
        &self,
    ) -> std::option::Option<&crate::model::LineChartAggregatedFieldWells> {
        self.line_chart_aggregated_field_wells.as_ref()
    }
}
/// See [`LineChartFieldWells`](crate::model::LineChartFieldWells).
pub mod line_chart_field_wells {

    /// A builder for [`LineChartFieldWells`](crate::model::LineChartFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) line_chart_aggregated_field_wells:
            std::option::Option<crate::model::LineChartAggregatedFieldWells>,
    }
    impl Builder {
        /// <p>The field well configuration of a line chart.</p>
        pub fn line_chart_aggregated_field_wells(
            mut self,
            input: crate::model::LineChartAggregatedFieldWells,
        ) -> Self {
            self.line_chart_aggregated_field_wells = Some(input);
            self
        }
        /// <p>The field well configuration of a line chart.</p>
        pub fn set_line_chart_aggregated_field_wells(
            mut self,
            input: std::option::Option<crate::model::LineChartAggregatedFieldWells>,
        ) -> Self {
            self.line_chart_aggregated_field_wells = input;
            self
        }
        /// Consumes the builder and constructs a [`LineChartFieldWells`](crate::model::LineChartFieldWells).
        pub fn build(self) -> crate::model::LineChartFieldWells {
            crate::model::LineChartFieldWells {
                line_chart_aggregated_field_wells: self.line_chart_aggregated_field_wells,
            }
        }
    }
}
impl LineChartFieldWells {
    /// Creates a new builder-style object to manufacture [`LineChartFieldWells`](crate::model::LineChartFieldWells).
    pub fn builder() -> crate::model::line_chart_field_wells::Builder {
        crate::model::line_chart_field_wells::Builder::default()
    }
}

/// <p>The field well configuration of a line chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LineChartAggregatedFieldWells {
    /// <p>The category field wells of a line chart. Values are grouped by category fields.</p>
    #[doc(hidden)]
    pub category: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The value field wells of a line chart. Values are aggregated based on categories.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    /// <p>The color field wells of a line chart. Values are grouped by category fields.</p>
    #[doc(hidden)]
    pub colors: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The small multiples field well of a line chart.</p>
    #[doc(hidden)]
    pub small_multiples: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
}
impl LineChartAggregatedFieldWells {
    /// <p>The category field wells of a line chart. Values are grouped by category fields.</p>
    pub fn category(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.category.as_deref()
    }
    /// <p>The value field wells of a line chart. Values are aggregated based on categories.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.values.as_deref()
    }
    /// <p>The color field wells of a line chart. Values are grouped by category fields.</p>
    pub fn colors(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.colors.as_deref()
    }
    /// <p>The small multiples field well of a line chart.</p>
    pub fn small_multiples(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.small_multiples.as_deref()
    }
}
/// See [`LineChartAggregatedFieldWells`](crate::model::LineChartAggregatedFieldWells).
pub mod line_chart_aggregated_field_wells {

    /// A builder for [`LineChartAggregatedFieldWells`](crate::model::LineChartAggregatedFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        pub(crate) colors: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) small_multiples:
            std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    }
    impl Builder {
        /// Appends an item to `category`.
        ///
        /// To override the contents of this collection use [`set_category`](Self::set_category).
        ///
        /// <p>The category field wells of a line chart. Values are grouped by category fields.</p>
        pub fn category(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.category.unwrap_or_default();
            v.push(input);
            self.category = Some(v);
            self
        }
        /// <p>The category field wells of a line chart. Values are grouped by category fields.</p>
        pub fn set_category(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.category = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The value field wells of a line chart. Values are aggregated based on categories.</p>
        pub fn values(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>The value field wells of a line chart. Values are aggregated based on categories.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Appends an item to `colors`.
        ///
        /// To override the contents of this collection use [`set_colors`](Self::set_colors).
        ///
        /// <p>The color field wells of a line chart. Values are grouped by category fields.</p>
        pub fn colors(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.colors.unwrap_or_default();
            v.push(input);
            self.colors = Some(v);
            self
        }
        /// <p>The color field wells of a line chart. Values are grouped by category fields.</p>
        pub fn set_colors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.colors = input;
            self
        }
        /// Appends an item to `small_multiples`.
        ///
        /// To override the contents of this collection use [`set_small_multiples`](Self::set_small_multiples).
        ///
        /// <p>The small multiples field well of a line chart.</p>
        pub fn small_multiples(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.small_multiples.unwrap_or_default();
            v.push(input);
            self.small_multiples = Some(v);
            self
        }
        /// <p>The small multiples field well of a line chart.</p>
        pub fn set_small_multiples(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.small_multiples = input;
            self
        }
        /// Consumes the builder and constructs a [`LineChartAggregatedFieldWells`](crate::model::LineChartAggregatedFieldWells).
        pub fn build(self) -> crate::model::LineChartAggregatedFieldWells {
            crate::model::LineChartAggregatedFieldWells {
                category: self.category,
                values: self.values,
                colors: self.colors,
                small_multiples: self.small_multiples,
            }
        }
    }
}
impl LineChartAggregatedFieldWells {
    /// Creates a new builder-style object to manufacture [`LineChartAggregatedFieldWells`](crate::model::LineChartAggregatedFieldWells).
    pub fn builder() -> crate::model::line_chart_aggregated_field_wells::Builder {
        crate::model::line_chart_aggregated_field_wells::Builder::default()
    }
}

/// <p>A gauge chart.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/gauge-chart.html">Using gauge charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GaugeChartVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration of a <code>GaugeChartVisual</code>.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::GaugeChartConfiguration>,
    /// <p>The conditional formatting of a <code>GaugeChartVisual</code>.</p>
    #[doc(hidden)]
    pub conditional_formatting: std::option::Option<crate::model::GaugeChartConditionalFormatting>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
}
impl GaugeChartVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration of a <code>GaugeChartVisual</code>.</p>
    pub fn chart_configuration(
        &self,
    ) -> std::option::Option<&crate::model::GaugeChartConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The conditional formatting of a <code>GaugeChartVisual</code>.</p>
    pub fn conditional_formatting(
        &self,
    ) -> std::option::Option<&crate::model::GaugeChartConditionalFormatting> {
        self.conditional_formatting.as_ref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
}
/// See [`GaugeChartVisual`](crate::model::GaugeChartVisual).
pub mod gauge_chart_visual {

    /// A builder for [`GaugeChartVisual`](crate::model::GaugeChartVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration: std::option::Option<crate::model::GaugeChartConfiguration>,
        pub(crate) conditional_formatting:
            std::option::Option<crate::model::GaugeChartConditionalFormatting>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration of a <code>GaugeChartVisual</code>.</p>
        pub fn chart_configuration(mut self, input: crate::model::GaugeChartConfiguration) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration of a <code>GaugeChartVisual</code>.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::GaugeChartConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// <p>The conditional formatting of a <code>GaugeChartVisual</code>.</p>
        pub fn conditional_formatting(
            mut self,
            input: crate::model::GaugeChartConditionalFormatting,
        ) -> Self {
            self.conditional_formatting = Some(input);
            self
        }
        /// <p>The conditional formatting of a <code>GaugeChartVisual</code>.</p>
        pub fn set_conditional_formatting(
            mut self,
            input: std::option::Option<crate::model::GaugeChartConditionalFormatting>,
        ) -> Self {
            self.conditional_formatting = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Consumes the builder and constructs a [`GaugeChartVisual`](crate::model::GaugeChartVisual).
        pub fn build(self) -> crate::model::GaugeChartVisual {
            crate::model::GaugeChartVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                conditional_formatting: self.conditional_formatting,
                actions: self.actions,
            }
        }
    }
}
impl GaugeChartVisual {
    /// Creates a new builder-style object to manufacture [`GaugeChartVisual`](crate::model::GaugeChartVisual).
    pub fn builder() -> crate::model::gauge_chart_visual::Builder {
        crate::model::gauge_chart_visual::Builder::default()
    }
}

/// <p>The conditional formatting of a <code>GaugeChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GaugeChartConditionalFormatting {
    /// <p>Conditional formatting options of a <code>GaugeChartVisual</code>.</p>
    #[doc(hidden)]
    pub conditional_formatting_options:
        std::option::Option<std::vec::Vec<crate::model::GaugeChartConditionalFormattingOption>>,
}
impl GaugeChartConditionalFormatting {
    /// <p>Conditional formatting options of a <code>GaugeChartVisual</code>.</p>
    pub fn conditional_formatting_options(
        &self,
    ) -> std::option::Option<&[crate::model::GaugeChartConditionalFormattingOption]> {
        self.conditional_formatting_options.as_deref()
    }
}
/// See [`GaugeChartConditionalFormatting`](crate::model::GaugeChartConditionalFormatting).
pub mod gauge_chart_conditional_formatting {

    /// A builder for [`GaugeChartConditionalFormatting`](crate::model::GaugeChartConditionalFormatting).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) conditional_formatting_options:
            std::option::Option<std::vec::Vec<crate::model::GaugeChartConditionalFormattingOption>>,
    }
    impl Builder {
        /// Appends an item to `conditional_formatting_options`.
        ///
        /// To override the contents of this collection use [`set_conditional_formatting_options`](Self::set_conditional_formatting_options).
        ///
        /// <p>Conditional formatting options of a <code>GaugeChartVisual</code>.</p>
        pub fn conditional_formatting_options(
            mut self,
            input: crate::model::GaugeChartConditionalFormattingOption,
        ) -> Self {
            let mut v = self.conditional_formatting_options.unwrap_or_default();
            v.push(input);
            self.conditional_formatting_options = Some(v);
            self
        }
        /// <p>Conditional formatting options of a <code>GaugeChartVisual</code>.</p>
        pub fn set_conditional_formatting_options(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::GaugeChartConditionalFormattingOption>,
            >,
        ) -> Self {
            self.conditional_formatting_options = input;
            self
        }
        /// Consumes the builder and constructs a [`GaugeChartConditionalFormatting`](crate::model::GaugeChartConditionalFormatting).
        pub fn build(self) -> crate::model::GaugeChartConditionalFormatting {
            crate::model::GaugeChartConditionalFormatting {
                conditional_formatting_options: self.conditional_formatting_options,
            }
        }
    }
}
impl GaugeChartConditionalFormatting {
    /// Creates a new builder-style object to manufacture [`GaugeChartConditionalFormatting`](crate::model::GaugeChartConditionalFormatting).
    pub fn builder() -> crate::model::gauge_chart_conditional_formatting::Builder {
        crate::model::gauge_chart_conditional_formatting::Builder::default()
    }
}

/// <p>Conditional formatting options of a <code>GaugeChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GaugeChartConditionalFormattingOption {
    /// <p>The conditional formatting for the primary value of a <code>GaugeChartVisual</code>.</p>
    #[doc(hidden)]
    pub primary_value:
        std::option::Option<crate::model::GaugeChartPrimaryValueConditionalFormatting>,
    /// <p>The options that determine the presentation of the arc of a <code>GaugeChartVisual</code>.</p>
    #[doc(hidden)]
    pub arc: std::option::Option<crate::model::GaugeChartArcConditionalFormatting>,
}
impl GaugeChartConditionalFormattingOption {
    /// <p>The conditional formatting for the primary value of a <code>GaugeChartVisual</code>.</p>
    pub fn primary_value(
        &self,
    ) -> std::option::Option<&crate::model::GaugeChartPrimaryValueConditionalFormatting> {
        self.primary_value.as_ref()
    }
    /// <p>The options that determine the presentation of the arc of a <code>GaugeChartVisual</code>.</p>
    pub fn arc(&self) -> std::option::Option<&crate::model::GaugeChartArcConditionalFormatting> {
        self.arc.as_ref()
    }
}
/// See [`GaugeChartConditionalFormattingOption`](crate::model::GaugeChartConditionalFormattingOption).
pub mod gauge_chart_conditional_formatting_option {

    /// A builder for [`GaugeChartConditionalFormattingOption`](crate::model::GaugeChartConditionalFormattingOption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) primary_value:
            std::option::Option<crate::model::GaugeChartPrimaryValueConditionalFormatting>,
        pub(crate) arc: std::option::Option<crate::model::GaugeChartArcConditionalFormatting>,
    }
    impl Builder {
        /// <p>The conditional formatting for the primary value of a <code>GaugeChartVisual</code>.</p>
        pub fn primary_value(
            mut self,
            input: crate::model::GaugeChartPrimaryValueConditionalFormatting,
        ) -> Self {
            self.primary_value = Some(input);
            self
        }
        /// <p>The conditional formatting for the primary value of a <code>GaugeChartVisual</code>.</p>
        pub fn set_primary_value(
            mut self,
            input: std::option::Option<crate::model::GaugeChartPrimaryValueConditionalFormatting>,
        ) -> Self {
            self.primary_value = input;
            self
        }
        /// <p>The options that determine the presentation of the arc of a <code>GaugeChartVisual</code>.</p>
        pub fn arc(mut self, input: crate::model::GaugeChartArcConditionalFormatting) -> Self {
            self.arc = Some(input);
            self
        }
        /// <p>The options that determine the presentation of the arc of a <code>GaugeChartVisual</code>.</p>
        pub fn set_arc(
            mut self,
            input: std::option::Option<crate::model::GaugeChartArcConditionalFormatting>,
        ) -> Self {
            self.arc = input;
            self
        }
        /// Consumes the builder and constructs a [`GaugeChartConditionalFormattingOption`](crate::model::GaugeChartConditionalFormattingOption).
        pub fn build(self) -> crate::model::GaugeChartConditionalFormattingOption {
            crate::model::GaugeChartConditionalFormattingOption {
                primary_value: self.primary_value,
                arc: self.arc,
            }
        }
    }
}
impl GaugeChartConditionalFormattingOption {
    /// Creates a new builder-style object to manufacture [`GaugeChartConditionalFormattingOption`](crate::model::GaugeChartConditionalFormattingOption).
    pub fn builder() -> crate::model::gauge_chart_conditional_formatting_option::Builder {
        crate::model::gauge_chart_conditional_formatting_option::Builder::default()
    }
}

/// <p>The options that determine the presentation of the arc of a <code>GaugeChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GaugeChartArcConditionalFormatting {
    /// <p>The conditional formatting of the arc foreground color.</p>
    #[doc(hidden)]
    pub foreground_color: std::option::Option<crate::model::ConditionalFormattingColor>,
}
impl GaugeChartArcConditionalFormatting {
    /// <p>The conditional formatting of the arc foreground color.</p>
    pub fn foreground_color(
        &self,
    ) -> std::option::Option<&crate::model::ConditionalFormattingColor> {
        self.foreground_color.as_ref()
    }
}
/// See [`GaugeChartArcConditionalFormatting`](crate::model::GaugeChartArcConditionalFormatting).
pub mod gauge_chart_arc_conditional_formatting {

    /// A builder for [`GaugeChartArcConditionalFormatting`](crate::model::GaugeChartArcConditionalFormatting).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) foreground_color: std::option::Option<crate::model::ConditionalFormattingColor>,
    }
    impl Builder {
        /// <p>The conditional formatting of the arc foreground color.</p>
        pub fn foreground_color(mut self, input: crate::model::ConditionalFormattingColor) -> Self {
            self.foreground_color = Some(input);
            self
        }
        /// <p>The conditional formatting of the arc foreground color.</p>
        pub fn set_foreground_color(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingColor>,
        ) -> Self {
            self.foreground_color = input;
            self
        }
        /// Consumes the builder and constructs a [`GaugeChartArcConditionalFormatting`](crate::model::GaugeChartArcConditionalFormatting).
        pub fn build(self) -> crate::model::GaugeChartArcConditionalFormatting {
            crate::model::GaugeChartArcConditionalFormatting {
                foreground_color: self.foreground_color,
            }
        }
    }
}
impl GaugeChartArcConditionalFormatting {
    /// Creates a new builder-style object to manufacture [`GaugeChartArcConditionalFormatting`](crate::model::GaugeChartArcConditionalFormatting).
    pub fn builder() -> crate::model::gauge_chart_arc_conditional_formatting::Builder {
        crate::model::gauge_chart_arc_conditional_formatting::Builder::default()
    }
}

/// <p>The conditional formatting for the primary value of a <code>GaugeChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GaugeChartPrimaryValueConditionalFormatting {
    /// <p>The conditional formatting of the primary value text color.</p>
    #[doc(hidden)]
    pub text_color: std::option::Option<crate::model::ConditionalFormattingColor>,
    /// <p>The conditional formatting of the primary value icon.</p>
    #[doc(hidden)]
    pub icon: std::option::Option<crate::model::ConditionalFormattingIcon>,
}
impl GaugeChartPrimaryValueConditionalFormatting {
    /// <p>The conditional formatting of the primary value text color.</p>
    pub fn text_color(&self) -> std::option::Option<&crate::model::ConditionalFormattingColor> {
        self.text_color.as_ref()
    }
    /// <p>The conditional formatting of the primary value icon.</p>
    pub fn icon(&self) -> std::option::Option<&crate::model::ConditionalFormattingIcon> {
        self.icon.as_ref()
    }
}
/// See [`GaugeChartPrimaryValueConditionalFormatting`](crate::model::GaugeChartPrimaryValueConditionalFormatting).
pub mod gauge_chart_primary_value_conditional_formatting {

    /// A builder for [`GaugeChartPrimaryValueConditionalFormatting`](crate::model::GaugeChartPrimaryValueConditionalFormatting).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) text_color: std::option::Option<crate::model::ConditionalFormattingColor>,
        pub(crate) icon: std::option::Option<crate::model::ConditionalFormattingIcon>,
    }
    impl Builder {
        /// <p>The conditional formatting of the primary value text color.</p>
        pub fn text_color(mut self, input: crate::model::ConditionalFormattingColor) -> Self {
            self.text_color = Some(input);
            self
        }
        /// <p>The conditional formatting of the primary value text color.</p>
        pub fn set_text_color(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingColor>,
        ) -> Self {
            self.text_color = input;
            self
        }
        /// <p>The conditional formatting of the primary value icon.</p>
        pub fn icon(mut self, input: crate::model::ConditionalFormattingIcon) -> Self {
            self.icon = Some(input);
            self
        }
        /// <p>The conditional formatting of the primary value icon.</p>
        pub fn set_icon(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingIcon>,
        ) -> Self {
            self.icon = input;
            self
        }
        /// Consumes the builder and constructs a [`GaugeChartPrimaryValueConditionalFormatting`](crate::model::GaugeChartPrimaryValueConditionalFormatting).
        pub fn build(self) -> crate::model::GaugeChartPrimaryValueConditionalFormatting {
            crate::model::GaugeChartPrimaryValueConditionalFormatting {
                text_color: self.text_color,
                icon: self.icon,
            }
        }
    }
}
impl GaugeChartPrimaryValueConditionalFormatting {
    /// Creates a new builder-style object to manufacture [`GaugeChartPrimaryValueConditionalFormatting`](crate::model::GaugeChartPrimaryValueConditionalFormatting).
    pub fn builder() -> crate::model::gauge_chart_primary_value_conditional_formatting::Builder {
        crate::model::gauge_chart_primary_value_conditional_formatting::Builder::default()
    }
}

/// <p>The formatting configuration for the icon.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConditionalFormattingIcon {
    /// <p>Formatting configuration for icon set.</p>
    #[doc(hidden)]
    pub icon_set: std::option::Option<crate::model::ConditionalFormattingIconSet>,
    /// <p>Determines the custom condition for an icon set.</p>
    #[doc(hidden)]
    pub custom_condition:
        std::option::Option<crate::model::ConditionalFormattingCustomIconCondition>,
}
impl ConditionalFormattingIcon {
    /// <p>Formatting configuration for icon set.</p>
    pub fn icon_set(&self) -> std::option::Option<&crate::model::ConditionalFormattingIconSet> {
        self.icon_set.as_ref()
    }
    /// <p>Determines the custom condition for an icon set.</p>
    pub fn custom_condition(
        &self,
    ) -> std::option::Option<&crate::model::ConditionalFormattingCustomIconCondition> {
        self.custom_condition.as_ref()
    }
}
/// See [`ConditionalFormattingIcon`](crate::model::ConditionalFormattingIcon).
pub mod conditional_formatting_icon {

    /// A builder for [`ConditionalFormattingIcon`](crate::model::ConditionalFormattingIcon).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) icon_set: std::option::Option<crate::model::ConditionalFormattingIconSet>,
        pub(crate) custom_condition:
            std::option::Option<crate::model::ConditionalFormattingCustomIconCondition>,
    }
    impl Builder {
        /// <p>Formatting configuration for icon set.</p>
        pub fn icon_set(mut self, input: crate::model::ConditionalFormattingIconSet) -> Self {
            self.icon_set = Some(input);
            self
        }
        /// <p>Formatting configuration for icon set.</p>
        pub fn set_icon_set(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingIconSet>,
        ) -> Self {
            self.icon_set = input;
            self
        }
        /// <p>Determines the custom condition for an icon set.</p>
        pub fn custom_condition(
            mut self,
            input: crate::model::ConditionalFormattingCustomIconCondition,
        ) -> Self {
            self.custom_condition = Some(input);
            self
        }
        /// <p>Determines the custom condition for an icon set.</p>
        pub fn set_custom_condition(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingCustomIconCondition>,
        ) -> Self {
            self.custom_condition = input;
            self
        }
        /// Consumes the builder and constructs a [`ConditionalFormattingIcon`](crate::model::ConditionalFormattingIcon).
        pub fn build(self) -> crate::model::ConditionalFormattingIcon {
            crate::model::ConditionalFormattingIcon {
                icon_set: self.icon_set,
                custom_condition: self.custom_condition,
            }
        }
    }
}
impl ConditionalFormattingIcon {
    /// Creates a new builder-style object to manufacture [`ConditionalFormattingIcon`](crate::model::ConditionalFormattingIcon).
    pub fn builder() -> crate::model::conditional_formatting_icon::Builder {
        crate::model::conditional_formatting_icon::Builder::default()
    }
}

/// <p>Determines the custom condition for an icon set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConditionalFormattingCustomIconCondition {
    /// <p>The expression that determines the condition of the icon set.</p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::string::String>,
    /// <p>Custom icon options for an icon set.</p>
    #[doc(hidden)]
    pub icon_options: std::option::Option<crate::model::ConditionalFormattingCustomIconOptions>,
    /// <p>Determines the color of the icon.</p>
    #[doc(hidden)]
    pub color: std::option::Option<std::string::String>,
    /// <p>Determines the icon display configuration.</p>
    #[doc(hidden)]
    pub display_configuration:
        std::option::Option<crate::model::ConditionalFormattingIconDisplayConfiguration>,
}
impl ConditionalFormattingCustomIconCondition {
    /// <p>The expression that determines the condition of the icon set.</p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
    /// <p>Custom icon options for an icon set.</p>
    pub fn icon_options(
        &self,
    ) -> std::option::Option<&crate::model::ConditionalFormattingCustomIconOptions> {
        self.icon_options.as_ref()
    }
    /// <p>Determines the color of the icon.</p>
    pub fn color(&self) -> std::option::Option<&str> {
        self.color.as_deref()
    }
    /// <p>Determines the icon display configuration.</p>
    pub fn display_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ConditionalFormattingIconDisplayConfiguration> {
        self.display_configuration.as_ref()
    }
}
impl std::fmt::Debug for ConditionalFormattingCustomIconCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConditionalFormattingCustomIconCondition");
        formatter.field("expression", &"*** Sensitive Data Redacted ***");
        formatter.field("icon_options", &self.icon_options);
        formatter.field("color", &self.color);
        formatter.field("display_configuration", &self.display_configuration);
        formatter.finish()
    }
}
/// See [`ConditionalFormattingCustomIconCondition`](crate::model::ConditionalFormattingCustomIconCondition).
pub mod conditional_formatting_custom_icon_condition {

    /// A builder for [`ConditionalFormattingCustomIconCondition`](crate::model::ConditionalFormattingCustomIconCondition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) expression: std::option::Option<std::string::String>,
        pub(crate) icon_options:
            std::option::Option<crate::model::ConditionalFormattingCustomIconOptions>,
        pub(crate) color: std::option::Option<std::string::String>,
        pub(crate) display_configuration:
            std::option::Option<crate::model::ConditionalFormattingIconDisplayConfiguration>,
    }
    impl Builder {
        /// <p>The expression that determines the condition of the icon set.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>The expression that determines the condition of the icon set.</p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// <p>Custom icon options for an icon set.</p>
        pub fn icon_options(
            mut self,
            input: crate::model::ConditionalFormattingCustomIconOptions,
        ) -> Self {
            self.icon_options = Some(input);
            self
        }
        /// <p>Custom icon options for an icon set.</p>
        pub fn set_icon_options(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingCustomIconOptions>,
        ) -> Self {
            self.icon_options = input;
            self
        }
        /// <p>Determines the color of the icon.</p>
        pub fn color(mut self, input: impl Into<std::string::String>) -> Self {
            self.color = Some(input.into());
            self
        }
        /// <p>Determines the color of the icon.</p>
        pub fn set_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.color = input;
            self
        }
        /// <p>Determines the icon display configuration.</p>
        pub fn display_configuration(
            mut self,
            input: crate::model::ConditionalFormattingIconDisplayConfiguration,
        ) -> Self {
            self.display_configuration = Some(input);
            self
        }
        /// <p>Determines the icon display configuration.</p>
        pub fn set_display_configuration(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingIconDisplayConfiguration>,
        ) -> Self {
            self.display_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ConditionalFormattingCustomIconCondition`](crate::model::ConditionalFormattingCustomIconCondition).
        pub fn build(self) -> crate::model::ConditionalFormattingCustomIconCondition {
            crate::model::ConditionalFormattingCustomIconCondition {
                expression: self.expression,
                icon_options: self.icon_options,
                color: self.color,
                display_configuration: self.display_configuration,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("expression", &"*** Sensitive Data Redacted ***");
            formatter.field("icon_options", &self.icon_options);
            formatter.field("color", &self.color);
            formatter.field("display_configuration", &self.display_configuration);
            formatter.finish()
        }
    }
}
impl ConditionalFormattingCustomIconCondition {
    /// Creates a new builder-style object to manufacture [`ConditionalFormattingCustomIconCondition`](crate::model::ConditionalFormattingCustomIconCondition).
    pub fn builder() -> crate::model::conditional_formatting_custom_icon_condition::Builder {
        crate::model::conditional_formatting_custom_icon_condition::Builder::default()
    }
}

/// <p>Determines the icon display configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConditionalFormattingIconDisplayConfiguration {
    /// <p>Determines the icon display configuration.</p>
    #[doc(hidden)]
    pub icon_display_option:
        std::option::Option<crate::model::ConditionalFormattingIconDisplayOption>,
}
impl ConditionalFormattingIconDisplayConfiguration {
    /// <p>Determines the icon display configuration.</p>
    pub fn icon_display_option(
        &self,
    ) -> std::option::Option<&crate::model::ConditionalFormattingIconDisplayOption> {
        self.icon_display_option.as_ref()
    }
}
/// See [`ConditionalFormattingIconDisplayConfiguration`](crate::model::ConditionalFormattingIconDisplayConfiguration).
pub mod conditional_formatting_icon_display_configuration {

    /// A builder for [`ConditionalFormattingIconDisplayConfiguration`](crate::model::ConditionalFormattingIconDisplayConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) icon_display_option:
            std::option::Option<crate::model::ConditionalFormattingIconDisplayOption>,
    }
    impl Builder {
        /// <p>Determines the icon display configuration.</p>
        pub fn icon_display_option(
            mut self,
            input: crate::model::ConditionalFormattingIconDisplayOption,
        ) -> Self {
            self.icon_display_option = Some(input);
            self
        }
        /// <p>Determines the icon display configuration.</p>
        pub fn set_icon_display_option(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingIconDisplayOption>,
        ) -> Self {
            self.icon_display_option = input;
            self
        }
        /// Consumes the builder and constructs a [`ConditionalFormattingIconDisplayConfiguration`](crate::model::ConditionalFormattingIconDisplayConfiguration).
        pub fn build(self) -> crate::model::ConditionalFormattingIconDisplayConfiguration {
            crate::model::ConditionalFormattingIconDisplayConfiguration {
                icon_display_option: self.icon_display_option,
            }
        }
    }
}
impl ConditionalFormattingIconDisplayConfiguration {
    /// Creates a new builder-style object to manufacture [`ConditionalFormattingIconDisplayConfiguration`](crate::model::ConditionalFormattingIconDisplayConfiguration).
    pub fn builder() -> crate::model::conditional_formatting_icon_display_configuration::Builder {
        crate::model::conditional_formatting_icon_display_configuration::Builder::default()
    }
}

/// When writing a match expression against `ConditionalFormattingIconDisplayOption`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let conditionalformattingicondisplayoption = unimplemented!();
/// match conditionalformattingicondisplayoption {
///     ConditionalFormattingIconDisplayOption::IconOnly => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `conditionalformattingicondisplayoption` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConditionalFormattingIconDisplayOption::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConditionalFormattingIconDisplayOption::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConditionalFormattingIconDisplayOption::NewFeature` is defined.
/// Specifically, when `conditionalformattingicondisplayoption` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConditionalFormattingIconDisplayOption::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConditionalFormattingIconDisplayOption {
    #[allow(missing_docs)] // documentation missing in model
    IconOnly,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConditionalFormattingIconDisplayOption {
    fn from(s: &str) -> Self {
        match s {
            "ICON_ONLY" => ConditionalFormattingIconDisplayOption::IconOnly,
            other => ConditionalFormattingIconDisplayOption::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for ConditionalFormattingIconDisplayOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConditionalFormattingIconDisplayOption::from(s))
    }
}
impl ConditionalFormattingIconDisplayOption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConditionalFormattingIconDisplayOption::IconOnly => "ICON_ONLY",
            ConditionalFormattingIconDisplayOption::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ICON_ONLY"]
    }
}
impl AsRef<str> for ConditionalFormattingIconDisplayOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Custom icon options for an icon set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConditionalFormattingCustomIconOptions {
    /// <p>Determines the type of icon.</p>
    #[doc(hidden)]
    pub icon: std::option::Option<crate::model::Icon>,
    /// <p>Determines the Unicode icon type.</p>
    #[doc(hidden)]
    pub unicode_icon: std::option::Option<std::string::String>,
}
impl ConditionalFormattingCustomIconOptions {
    /// <p>Determines the type of icon.</p>
    pub fn icon(&self) -> std::option::Option<&crate::model::Icon> {
        self.icon.as_ref()
    }
    /// <p>Determines the Unicode icon type.</p>
    pub fn unicode_icon(&self) -> std::option::Option<&str> {
        self.unicode_icon.as_deref()
    }
}
/// See [`ConditionalFormattingCustomIconOptions`](crate::model::ConditionalFormattingCustomIconOptions).
pub mod conditional_formatting_custom_icon_options {

    /// A builder for [`ConditionalFormattingCustomIconOptions`](crate::model::ConditionalFormattingCustomIconOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) icon: std::option::Option<crate::model::Icon>,
        pub(crate) unicode_icon: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Determines the type of icon.</p>
        pub fn icon(mut self, input: crate::model::Icon) -> Self {
            self.icon = Some(input);
            self
        }
        /// <p>Determines the type of icon.</p>
        pub fn set_icon(mut self, input: std::option::Option<crate::model::Icon>) -> Self {
            self.icon = input;
            self
        }
        /// <p>Determines the Unicode icon type.</p>
        pub fn unicode_icon(mut self, input: impl Into<std::string::String>) -> Self {
            self.unicode_icon = Some(input.into());
            self
        }
        /// <p>Determines the Unicode icon type.</p>
        pub fn set_unicode_icon(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unicode_icon = input;
            self
        }
        /// Consumes the builder and constructs a [`ConditionalFormattingCustomIconOptions`](crate::model::ConditionalFormattingCustomIconOptions).
        pub fn build(self) -> crate::model::ConditionalFormattingCustomIconOptions {
            crate::model::ConditionalFormattingCustomIconOptions {
                icon: self.icon,
                unicode_icon: self.unicode_icon,
            }
        }
    }
}
impl ConditionalFormattingCustomIconOptions {
    /// Creates a new builder-style object to manufacture [`ConditionalFormattingCustomIconOptions`](crate::model::ConditionalFormattingCustomIconOptions).
    pub fn builder() -> crate::model::conditional_formatting_custom_icon_options::Builder {
        crate::model::conditional_formatting_custom_icon_options::Builder::default()
    }
}

/// When writing a match expression against `Icon`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let icon = unimplemented!();
/// match icon {
///     Icon::ArrowDown => { /* ... */ },
///     Icon::ArrowDownLeft => { /* ... */ },
///     Icon::ArrowDownRight => { /* ... */ },
///     Icon::ArrowLeft => { /* ... */ },
///     Icon::ArrowRight => { /* ... */ },
///     Icon::ArrowUp => { /* ... */ },
///     Icon::ArrowUpLeft => { /* ... */ },
///     Icon::ArrowUpRight => { /* ... */ },
///     Icon::CaretDown => { /* ... */ },
///     Icon::CaretUp => { /* ... */ },
///     Icon::Checkmark => { /* ... */ },
///     Icon::Circle => { /* ... */ },
///     Icon::FaceDown => { /* ... */ },
///     Icon::FaceFlat => { /* ... */ },
///     Icon::FaceUp => { /* ... */ },
///     Icon::Flag => { /* ... */ },
///     Icon::Minus => { /* ... */ },
///     Icon::OneBar => { /* ... */ },
///     Icon::Plus => { /* ... */ },
///     Icon::Square => { /* ... */ },
///     Icon::ThreeBar => { /* ... */ },
///     Icon::ThumbsDown => { /* ... */ },
///     Icon::ThumbsUp => { /* ... */ },
///     Icon::Triangle => { /* ... */ },
///     Icon::TwoBar => { /* ... */ },
///     Icon::X => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `icon` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Icon::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Icon::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Icon::NewFeature` is defined.
/// Specifically, when `icon` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Icon::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Icon {
    #[allow(missing_docs)] // documentation missing in model
    ArrowDown,
    #[allow(missing_docs)] // documentation missing in model
    ArrowDownLeft,
    #[allow(missing_docs)] // documentation missing in model
    ArrowDownRight,
    #[allow(missing_docs)] // documentation missing in model
    ArrowLeft,
    #[allow(missing_docs)] // documentation missing in model
    ArrowRight,
    #[allow(missing_docs)] // documentation missing in model
    ArrowUp,
    #[allow(missing_docs)] // documentation missing in model
    ArrowUpLeft,
    #[allow(missing_docs)] // documentation missing in model
    ArrowUpRight,
    #[allow(missing_docs)] // documentation missing in model
    CaretDown,
    #[allow(missing_docs)] // documentation missing in model
    CaretUp,
    #[allow(missing_docs)] // documentation missing in model
    Checkmark,
    #[allow(missing_docs)] // documentation missing in model
    Circle,
    #[allow(missing_docs)] // documentation missing in model
    FaceDown,
    #[allow(missing_docs)] // documentation missing in model
    FaceFlat,
    #[allow(missing_docs)] // documentation missing in model
    FaceUp,
    #[allow(missing_docs)] // documentation missing in model
    Flag,
    #[allow(missing_docs)] // documentation missing in model
    Minus,
    #[allow(missing_docs)] // documentation missing in model
    OneBar,
    #[allow(missing_docs)] // documentation missing in model
    Plus,
    #[allow(missing_docs)] // documentation missing in model
    Square,
    #[allow(missing_docs)] // documentation missing in model
    ThreeBar,
    #[allow(missing_docs)] // documentation missing in model
    ThumbsDown,
    #[allow(missing_docs)] // documentation missing in model
    ThumbsUp,
    #[allow(missing_docs)] // documentation missing in model
    Triangle,
    #[allow(missing_docs)] // documentation missing in model
    TwoBar,
    #[allow(missing_docs)] // documentation missing in model
    X,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Icon {
    fn from(s: &str) -> Self {
        match s {
            "ARROW_DOWN" => Icon::ArrowDown,
            "ARROW_DOWN_LEFT" => Icon::ArrowDownLeft,
            "ARROW_DOWN_RIGHT" => Icon::ArrowDownRight,
            "ARROW_LEFT" => Icon::ArrowLeft,
            "ARROW_RIGHT" => Icon::ArrowRight,
            "ARROW_UP" => Icon::ArrowUp,
            "ARROW_UP_LEFT" => Icon::ArrowUpLeft,
            "ARROW_UP_RIGHT" => Icon::ArrowUpRight,
            "CARET_DOWN" => Icon::CaretDown,
            "CARET_UP" => Icon::CaretUp,
            "CHECKMARK" => Icon::Checkmark,
            "CIRCLE" => Icon::Circle,
            "FACE_DOWN" => Icon::FaceDown,
            "FACE_FLAT" => Icon::FaceFlat,
            "FACE_UP" => Icon::FaceUp,
            "FLAG" => Icon::Flag,
            "MINUS" => Icon::Minus,
            "ONE_BAR" => Icon::OneBar,
            "PLUS" => Icon::Plus,
            "SQUARE" => Icon::Square,
            "THREE_BAR" => Icon::ThreeBar,
            "THUMBS_DOWN" => Icon::ThumbsDown,
            "THUMBS_UP" => Icon::ThumbsUp,
            "TRIANGLE" => Icon::Triangle,
            "TWO_BAR" => Icon::TwoBar,
            "X" => Icon::X,
            other => Icon::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Icon {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Icon::from(s))
    }
}
impl Icon {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Icon::ArrowDown => "ARROW_DOWN",
            Icon::ArrowDownLeft => "ARROW_DOWN_LEFT",
            Icon::ArrowDownRight => "ARROW_DOWN_RIGHT",
            Icon::ArrowLeft => "ARROW_LEFT",
            Icon::ArrowRight => "ARROW_RIGHT",
            Icon::ArrowUp => "ARROW_UP",
            Icon::ArrowUpLeft => "ARROW_UP_LEFT",
            Icon::ArrowUpRight => "ARROW_UP_RIGHT",
            Icon::CaretDown => "CARET_DOWN",
            Icon::CaretUp => "CARET_UP",
            Icon::Checkmark => "CHECKMARK",
            Icon::Circle => "CIRCLE",
            Icon::FaceDown => "FACE_DOWN",
            Icon::FaceFlat => "FACE_FLAT",
            Icon::FaceUp => "FACE_UP",
            Icon::Flag => "FLAG",
            Icon::Minus => "MINUS",
            Icon::OneBar => "ONE_BAR",
            Icon::Plus => "PLUS",
            Icon::Square => "SQUARE",
            Icon::ThreeBar => "THREE_BAR",
            Icon::ThumbsDown => "THUMBS_DOWN",
            Icon::ThumbsUp => "THUMBS_UP",
            Icon::Triangle => "TRIANGLE",
            Icon::TwoBar => "TWO_BAR",
            Icon::X => "X",
            Icon::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ARROW_DOWN",
            "ARROW_DOWN_LEFT",
            "ARROW_DOWN_RIGHT",
            "ARROW_LEFT",
            "ARROW_RIGHT",
            "ARROW_UP",
            "ARROW_UP_LEFT",
            "ARROW_UP_RIGHT",
            "CARET_DOWN",
            "CARET_UP",
            "CHECKMARK",
            "CIRCLE",
            "FACE_DOWN",
            "FACE_FLAT",
            "FACE_UP",
            "FLAG",
            "MINUS",
            "ONE_BAR",
            "PLUS",
            "SQUARE",
            "THREE_BAR",
            "THUMBS_DOWN",
            "THUMBS_UP",
            "TRIANGLE",
            "TWO_BAR",
            "X",
        ]
    }
}
impl AsRef<str> for Icon {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Formatting configuration for icon set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConditionalFormattingIconSet {
    /// <p>The expression that determines the formatting configuration for the icon set.</p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::string::String>,
    /// <p>Determines the icon set type.</p>
    #[doc(hidden)]
    pub icon_set_type: std::option::Option<crate::model::ConditionalFormattingIconSetType>,
}
impl ConditionalFormattingIconSet {
    /// <p>The expression that determines the formatting configuration for the icon set.</p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
    /// <p>Determines the icon set type.</p>
    pub fn icon_set_type(
        &self,
    ) -> std::option::Option<&crate::model::ConditionalFormattingIconSetType> {
        self.icon_set_type.as_ref()
    }
}
impl std::fmt::Debug for ConditionalFormattingIconSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConditionalFormattingIconSet");
        formatter.field("expression", &"*** Sensitive Data Redacted ***");
        formatter.field("icon_set_type", &self.icon_set_type);
        formatter.finish()
    }
}
/// See [`ConditionalFormattingIconSet`](crate::model::ConditionalFormattingIconSet).
pub mod conditional_formatting_icon_set {

    /// A builder for [`ConditionalFormattingIconSet`](crate::model::ConditionalFormattingIconSet).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) expression: std::option::Option<std::string::String>,
        pub(crate) icon_set_type:
            std::option::Option<crate::model::ConditionalFormattingIconSetType>,
    }
    impl Builder {
        /// <p>The expression that determines the formatting configuration for the icon set.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>The expression that determines the formatting configuration for the icon set.</p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// <p>Determines the icon set type.</p>
        pub fn icon_set_type(
            mut self,
            input: crate::model::ConditionalFormattingIconSetType,
        ) -> Self {
            self.icon_set_type = Some(input);
            self
        }
        /// <p>Determines the icon set type.</p>
        pub fn set_icon_set_type(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingIconSetType>,
        ) -> Self {
            self.icon_set_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ConditionalFormattingIconSet`](crate::model::ConditionalFormattingIconSet).
        pub fn build(self) -> crate::model::ConditionalFormattingIconSet {
            crate::model::ConditionalFormattingIconSet {
                expression: self.expression,
                icon_set_type: self.icon_set_type,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("expression", &"*** Sensitive Data Redacted ***");
            formatter.field("icon_set_type", &self.icon_set_type);
            formatter.finish()
        }
    }
}
impl ConditionalFormattingIconSet {
    /// Creates a new builder-style object to manufacture [`ConditionalFormattingIconSet`](crate::model::ConditionalFormattingIconSet).
    pub fn builder() -> crate::model::conditional_formatting_icon_set::Builder {
        crate::model::conditional_formatting_icon_set::Builder::default()
    }
}

/// When writing a match expression against `ConditionalFormattingIconSetType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let conditionalformattingiconsettype = unimplemented!();
/// match conditionalformattingiconsettype {
///     ConditionalFormattingIconSetType::Bars => { /* ... */ },
///     ConditionalFormattingIconSetType::CaretUpMinusDown => { /* ... */ },
///     ConditionalFormattingIconSetType::CheckX => { /* ... */ },
///     ConditionalFormattingIconSetType::Flags => { /* ... */ },
///     ConditionalFormattingIconSetType::FourColorArrow => { /* ... */ },
///     ConditionalFormattingIconSetType::FourGrayArrow => { /* ... */ },
///     ConditionalFormattingIconSetType::PlusMinus => { /* ... */ },
///     ConditionalFormattingIconSetType::ThreeCircle => { /* ... */ },
///     ConditionalFormattingIconSetType::ThreeColorArrow => { /* ... */ },
///     ConditionalFormattingIconSetType::ThreeGrayArrow => { /* ... */ },
///     ConditionalFormattingIconSetType::ThreeShape => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `conditionalformattingiconsettype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConditionalFormattingIconSetType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConditionalFormattingIconSetType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConditionalFormattingIconSetType::NewFeature` is defined.
/// Specifically, when `conditionalformattingiconsettype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConditionalFormattingIconSetType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConditionalFormattingIconSetType {
    #[allow(missing_docs)] // documentation missing in model
    Bars,
    #[allow(missing_docs)] // documentation missing in model
    CaretUpMinusDown,
    #[allow(missing_docs)] // documentation missing in model
    CheckX,
    #[allow(missing_docs)] // documentation missing in model
    Flags,
    #[allow(missing_docs)] // documentation missing in model
    FourColorArrow,
    #[allow(missing_docs)] // documentation missing in model
    FourGrayArrow,
    #[allow(missing_docs)] // documentation missing in model
    PlusMinus,
    #[allow(missing_docs)] // documentation missing in model
    ThreeCircle,
    #[allow(missing_docs)] // documentation missing in model
    ThreeColorArrow,
    #[allow(missing_docs)] // documentation missing in model
    ThreeGrayArrow,
    #[allow(missing_docs)] // documentation missing in model
    ThreeShape,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConditionalFormattingIconSetType {
    fn from(s: &str) -> Self {
        match s {
            "BARS" => ConditionalFormattingIconSetType::Bars,
            "CARET_UP_MINUS_DOWN" => ConditionalFormattingIconSetType::CaretUpMinusDown,
            "CHECK_X" => ConditionalFormattingIconSetType::CheckX,
            "FLAGS" => ConditionalFormattingIconSetType::Flags,
            "FOUR_COLOR_ARROW" => ConditionalFormattingIconSetType::FourColorArrow,
            "FOUR_GRAY_ARROW" => ConditionalFormattingIconSetType::FourGrayArrow,
            "PLUS_MINUS" => ConditionalFormattingIconSetType::PlusMinus,
            "THREE_CIRCLE" => ConditionalFormattingIconSetType::ThreeCircle,
            "THREE_COLOR_ARROW" => ConditionalFormattingIconSetType::ThreeColorArrow,
            "THREE_GRAY_ARROW" => ConditionalFormattingIconSetType::ThreeGrayArrow,
            "THREE_SHAPE" => ConditionalFormattingIconSetType::ThreeShape,
            other => ConditionalFormattingIconSetType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ConditionalFormattingIconSetType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConditionalFormattingIconSetType::from(s))
    }
}
impl ConditionalFormattingIconSetType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConditionalFormattingIconSetType::Bars => "BARS",
            ConditionalFormattingIconSetType::CaretUpMinusDown => "CARET_UP_MINUS_DOWN",
            ConditionalFormattingIconSetType::CheckX => "CHECK_X",
            ConditionalFormattingIconSetType::Flags => "FLAGS",
            ConditionalFormattingIconSetType::FourColorArrow => "FOUR_COLOR_ARROW",
            ConditionalFormattingIconSetType::FourGrayArrow => "FOUR_GRAY_ARROW",
            ConditionalFormattingIconSetType::PlusMinus => "PLUS_MINUS",
            ConditionalFormattingIconSetType::ThreeCircle => "THREE_CIRCLE",
            ConditionalFormattingIconSetType::ThreeColorArrow => "THREE_COLOR_ARROW",
            ConditionalFormattingIconSetType::ThreeGrayArrow => "THREE_GRAY_ARROW",
            ConditionalFormattingIconSetType::ThreeShape => "THREE_SHAPE",
            ConditionalFormattingIconSetType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BARS",
            "CARET_UP_MINUS_DOWN",
            "CHECK_X",
            "FLAGS",
            "FOUR_COLOR_ARROW",
            "FOUR_GRAY_ARROW",
            "PLUS_MINUS",
            "THREE_CIRCLE",
            "THREE_COLOR_ARROW",
            "THREE_GRAY_ARROW",
            "THREE_SHAPE",
        ]
    }
}
impl AsRef<str> for ConditionalFormattingIconSetType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration of a <code>GaugeChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GaugeChartConfiguration {
    /// <p>The field well configuration of a <code>GaugeChartVisual</code>.</p>
    #[doc(hidden)]
    pub field_wells: std::option::Option<crate::model::GaugeChartFieldWells>,
    /// <p>The options that determine the presentation of the <code>GaugeChartVisual</code>.</p>
    #[doc(hidden)]
    pub gauge_chart_options: std::option::Option<crate::model::GaugeChartOptions>,
    /// <p>The data label configuration of a <code>GaugeChartVisual</code>.</p>
    #[doc(hidden)]
    pub data_labels: std::option::Option<crate::model::DataLabelOptions>,
    /// <p>The tooltip configuration of a <code>GaugeChartVisual</code>.</p>
    #[doc(hidden)]
    pub tooltip_options: std::option::Option<crate::model::TooltipOptions>,
    /// <p>The visual palette configuration of a <code>GaugeChartVisual</code>.</p>
    #[doc(hidden)]
    pub visual_palette: std::option::Option<crate::model::VisualPalette>,
}
impl GaugeChartConfiguration {
    /// <p>The field well configuration of a <code>GaugeChartVisual</code>.</p>
    pub fn field_wells(&self) -> std::option::Option<&crate::model::GaugeChartFieldWells> {
        self.field_wells.as_ref()
    }
    /// <p>The options that determine the presentation of the <code>GaugeChartVisual</code>.</p>
    pub fn gauge_chart_options(&self) -> std::option::Option<&crate::model::GaugeChartOptions> {
        self.gauge_chart_options.as_ref()
    }
    /// <p>The data label configuration of a <code>GaugeChartVisual</code>.</p>
    pub fn data_labels(&self) -> std::option::Option<&crate::model::DataLabelOptions> {
        self.data_labels.as_ref()
    }
    /// <p>The tooltip configuration of a <code>GaugeChartVisual</code>.</p>
    pub fn tooltip_options(&self) -> std::option::Option<&crate::model::TooltipOptions> {
        self.tooltip_options.as_ref()
    }
    /// <p>The visual palette configuration of a <code>GaugeChartVisual</code>.</p>
    pub fn visual_palette(&self) -> std::option::Option<&crate::model::VisualPalette> {
        self.visual_palette.as_ref()
    }
}
/// See [`GaugeChartConfiguration`](crate::model::GaugeChartConfiguration).
pub mod gauge_chart_configuration {

    /// A builder for [`GaugeChartConfiguration`](crate::model::GaugeChartConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_wells: std::option::Option<crate::model::GaugeChartFieldWells>,
        pub(crate) gauge_chart_options: std::option::Option<crate::model::GaugeChartOptions>,
        pub(crate) data_labels: std::option::Option<crate::model::DataLabelOptions>,
        pub(crate) tooltip_options: std::option::Option<crate::model::TooltipOptions>,
        pub(crate) visual_palette: std::option::Option<crate::model::VisualPalette>,
    }
    impl Builder {
        /// <p>The field well configuration of a <code>GaugeChartVisual</code>.</p>
        pub fn field_wells(mut self, input: crate::model::GaugeChartFieldWells) -> Self {
            self.field_wells = Some(input);
            self
        }
        /// <p>The field well configuration of a <code>GaugeChartVisual</code>.</p>
        pub fn set_field_wells(
            mut self,
            input: std::option::Option<crate::model::GaugeChartFieldWells>,
        ) -> Self {
            self.field_wells = input;
            self
        }
        /// <p>The options that determine the presentation of the <code>GaugeChartVisual</code>.</p>
        pub fn gauge_chart_options(mut self, input: crate::model::GaugeChartOptions) -> Self {
            self.gauge_chart_options = Some(input);
            self
        }
        /// <p>The options that determine the presentation of the <code>GaugeChartVisual</code>.</p>
        pub fn set_gauge_chart_options(
            mut self,
            input: std::option::Option<crate::model::GaugeChartOptions>,
        ) -> Self {
            self.gauge_chart_options = input;
            self
        }
        /// <p>The data label configuration of a <code>GaugeChartVisual</code>.</p>
        pub fn data_labels(mut self, input: crate::model::DataLabelOptions) -> Self {
            self.data_labels = Some(input);
            self
        }
        /// <p>The data label configuration of a <code>GaugeChartVisual</code>.</p>
        pub fn set_data_labels(
            mut self,
            input: std::option::Option<crate::model::DataLabelOptions>,
        ) -> Self {
            self.data_labels = input;
            self
        }
        /// <p>The tooltip configuration of a <code>GaugeChartVisual</code>.</p>
        pub fn tooltip_options(mut self, input: crate::model::TooltipOptions) -> Self {
            self.tooltip_options = Some(input);
            self
        }
        /// <p>The tooltip configuration of a <code>GaugeChartVisual</code>.</p>
        pub fn set_tooltip_options(
            mut self,
            input: std::option::Option<crate::model::TooltipOptions>,
        ) -> Self {
            self.tooltip_options = input;
            self
        }
        /// <p>The visual palette configuration of a <code>GaugeChartVisual</code>.</p>
        pub fn visual_palette(mut self, input: crate::model::VisualPalette) -> Self {
            self.visual_palette = Some(input);
            self
        }
        /// <p>The visual palette configuration of a <code>GaugeChartVisual</code>.</p>
        pub fn set_visual_palette(
            mut self,
            input: std::option::Option<crate::model::VisualPalette>,
        ) -> Self {
            self.visual_palette = input;
            self
        }
        /// Consumes the builder and constructs a [`GaugeChartConfiguration`](crate::model::GaugeChartConfiguration).
        pub fn build(self) -> crate::model::GaugeChartConfiguration {
            crate::model::GaugeChartConfiguration {
                field_wells: self.field_wells,
                gauge_chart_options: self.gauge_chart_options,
                data_labels: self.data_labels,
                tooltip_options: self.tooltip_options,
                visual_palette: self.visual_palette,
            }
        }
    }
}
impl GaugeChartConfiguration {
    /// Creates a new builder-style object to manufacture [`GaugeChartConfiguration`](crate::model::GaugeChartConfiguration).
    pub fn builder() -> crate::model::gauge_chart_configuration::Builder {
        crate::model::gauge_chart_configuration::Builder::default()
    }
}

/// <p>The options that determine the presentation of the <code>GaugeChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GaugeChartOptions {
    /// <p>The options that determine the primary value display type.</p>
    #[doc(hidden)]
    pub primary_value_display_type: std::option::Option<crate::model::PrimaryValueDisplayType>,
    /// <p>The comparison configuration of a <code>GaugeChartVisual</code>.</p>
    #[doc(hidden)]
    pub comparison: std::option::Option<crate::model::ComparisonConfiguration>,
    /// <p>The arc axis configuration of a <code>GaugeChartVisual</code>.</p>
    #[doc(hidden)]
    pub arc_axis: std::option::Option<crate::model::ArcAxisConfiguration>,
    /// <p>The arc configuration of a <code>GaugeChartVisual</code>.</p>
    #[doc(hidden)]
    pub arc: std::option::Option<crate::model::ArcConfiguration>,
    /// <p>The options that determine the primary value font configuration.</p>
    #[doc(hidden)]
    pub primary_value_font_configuration: std::option::Option<crate::model::FontConfiguration>,
}
impl GaugeChartOptions {
    /// <p>The options that determine the primary value display type.</p>
    pub fn primary_value_display_type(
        &self,
    ) -> std::option::Option<&crate::model::PrimaryValueDisplayType> {
        self.primary_value_display_type.as_ref()
    }
    /// <p>The comparison configuration of a <code>GaugeChartVisual</code>.</p>
    pub fn comparison(&self) -> std::option::Option<&crate::model::ComparisonConfiguration> {
        self.comparison.as_ref()
    }
    /// <p>The arc axis configuration of a <code>GaugeChartVisual</code>.</p>
    pub fn arc_axis(&self) -> std::option::Option<&crate::model::ArcAxisConfiguration> {
        self.arc_axis.as_ref()
    }
    /// <p>The arc configuration of a <code>GaugeChartVisual</code>.</p>
    pub fn arc(&self) -> std::option::Option<&crate::model::ArcConfiguration> {
        self.arc.as_ref()
    }
    /// <p>The options that determine the primary value font configuration.</p>
    pub fn primary_value_font_configuration(
        &self,
    ) -> std::option::Option<&crate::model::FontConfiguration> {
        self.primary_value_font_configuration.as_ref()
    }
}
/// See [`GaugeChartOptions`](crate::model::GaugeChartOptions).
pub mod gauge_chart_options {

    /// A builder for [`GaugeChartOptions`](crate::model::GaugeChartOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) primary_value_display_type:
            std::option::Option<crate::model::PrimaryValueDisplayType>,
        pub(crate) comparison: std::option::Option<crate::model::ComparisonConfiguration>,
        pub(crate) arc_axis: std::option::Option<crate::model::ArcAxisConfiguration>,
        pub(crate) arc: std::option::Option<crate::model::ArcConfiguration>,
        pub(crate) primary_value_font_configuration:
            std::option::Option<crate::model::FontConfiguration>,
    }
    impl Builder {
        /// <p>The options that determine the primary value display type.</p>
        pub fn primary_value_display_type(
            mut self,
            input: crate::model::PrimaryValueDisplayType,
        ) -> Self {
            self.primary_value_display_type = Some(input);
            self
        }
        /// <p>The options that determine the primary value display type.</p>
        pub fn set_primary_value_display_type(
            mut self,
            input: std::option::Option<crate::model::PrimaryValueDisplayType>,
        ) -> Self {
            self.primary_value_display_type = input;
            self
        }
        /// <p>The comparison configuration of a <code>GaugeChartVisual</code>.</p>
        pub fn comparison(mut self, input: crate::model::ComparisonConfiguration) -> Self {
            self.comparison = Some(input);
            self
        }
        /// <p>The comparison configuration of a <code>GaugeChartVisual</code>.</p>
        pub fn set_comparison(
            mut self,
            input: std::option::Option<crate::model::ComparisonConfiguration>,
        ) -> Self {
            self.comparison = input;
            self
        }
        /// <p>The arc axis configuration of a <code>GaugeChartVisual</code>.</p>
        pub fn arc_axis(mut self, input: crate::model::ArcAxisConfiguration) -> Self {
            self.arc_axis = Some(input);
            self
        }
        /// <p>The arc axis configuration of a <code>GaugeChartVisual</code>.</p>
        pub fn set_arc_axis(
            mut self,
            input: std::option::Option<crate::model::ArcAxisConfiguration>,
        ) -> Self {
            self.arc_axis = input;
            self
        }
        /// <p>The arc configuration of a <code>GaugeChartVisual</code>.</p>
        pub fn arc(mut self, input: crate::model::ArcConfiguration) -> Self {
            self.arc = Some(input);
            self
        }
        /// <p>The arc configuration of a <code>GaugeChartVisual</code>.</p>
        pub fn set_arc(
            mut self,
            input: std::option::Option<crate::model::ArcConfiguration>,
        ) -> Self {
            self.arc = input;
            self
        }
        /// <p>The options that determine the primary value font configuration.</p>
        pub fn primary_value_font_configuration(
            mut self,
            input: crate::model::FontConfiguration,
        ) -> Self {
            self.primary_value_font_configuration = Some(input);
            self
        }
        /// <p>The options that determine the primary value font configuration.</p>
        pub fn set_primary_value_font_configuration(
            mut self,
            input: std::option::Option<crate::model::FontConfiguration>,
        ) -> Self {
            self.primary_value_font_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`GaugeChartOptions`](crate::model::GaugeChartOptions).
        pub fn build(self) -> crate::model::GaugeChartOptions {
            crate::model::GaugeChartOptions {
                primary_value_display_type: self.primary_value_display_type,
                comparison: self.comparison,
                arc_axis: self.arc_axis,
                arc: self.arc,
                primary_value_font_configuration: self.primary_value_font_configuration,
            }
        }
    }
}
impl GaugeChartOptions {
    /// Creates a new builder-style object to manufacture [`GaugeChartOptions`](crate::model::GaugeChartOptions).
    pub fn builder() -> crate::model::gauge_chart_options::Builder {
        crate::model::gauge_chart_options::Builder::default()
    }
}

/// <p>The arc configuration of a <code>GaugeChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ArcConfiguration {
    /// <p>The option that determines the arc angle of a <code>GaugeChartVisual</code>.</p>
    #[doc(hidden)]
    pub arc_angle: std::option::Option<f64>,
    /// <p>The options that determine the arc thickness of a <code>GaugeChartVisual</code>.</p>
    #[doc(hidden)]
    pub arc_thickness: std::option::Option<crate::model::ArcThicknessOptions>,
}
impl ArcConfiguration {
    /// <p>The option that determines the arc angle of a <code>GaugeChartVisual</code>.</p>
    pub fn arc_angle(&self) -> std::option::Option<f64> {
        self.arc_angle
    }
    /// <p>The options that determine the arc thickness of a <code>GaugeChartVisual</code>.</p>
    pub fn arc_thickness(&self) -> std::option::Option<&crate::model::ArcThicknessOptions> {
        self.arc_thickness.as_ref()
    }
}
/// See [`ArcConfiguration`](crate::model::ArcConfiguration).
pub mod arc_configuration {

    /// A builder for [`ArcConfiguration`](crate::model::ArcConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arc_angle: std::option::Option<f64>,
        pub(crate) arc_thickness: std::option::Option<crate::model::ArcThicknessOptions>,
    }
    impl Builder {
        /// <p>The option that determines the arc angle of a <code>GaugeChartVisual</code>.</p>
        pub fn arc_angle(mut self, input: f64) -> Self {
            self.arc_angle = Some(input);
            self
        }
        /// <p>The option that determines the arc angle of a <code>GaugeChartVisual</code>.</p>
        pub fn set_arc_angle(mut self, input: std::option::Option<f64>) -> Self {
            self.arc_angle = input;
            self
        }
        /// <p>The options that determine the arc thickness of a <code>GaugeChartVisual</code>.</p>
        pub fn arc_thickness(mut self, input: crate::model::ArcThicknessOptions) -> Self {
            self.arc_thickness = Some(input);
            self
        }
        /// <p>The options that determine the arc thickness of a <code>GaugeChartVisual</code>.</p>
        pub fn set_arc_thickness(
            mut self,
            input: std::option::Option<crate::model::ArcThicknessOptions>,
        ) -> Self {
            self.arc_thickness = input;
            self
        }
        /// Consumes the builder and constructs a [`ArcConfiguration`](crate::model::ArcConfiguration).
        pub fn build(self) -> crate::model::ArcConfiguration {
            crate::model::ArcConfiguration {
                arc_angle: self.arc_angle,
                arc_thickness: self.arc_thickness,
            }
        }
    }
}
impl ArcConfiguration {
    /// Creates a new builder-style object to manufacture [`ArcConfiguration`](crate::model::ArcConfiguration).
    pub fn builder() -> crate::model::arc_configuration::Builder {
        crate::model::arc_configuration::Builder::default()
    }
}

/// When writing a match expression against `ArcThicknessOptions`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let arcthicknessoptions = unimplemented!();
/// match arcthicknessoptions {
///     ArcThicknessOptions::Large => { /* ... */ },
///     ArcThicknessOptions::Medium => { /* ... */ },
///     ArcThicknessOptions::Small => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `arcthicknessoptions` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ArcThicknessOptions::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ArcThicknessOptions::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ArcThicknessOptions::NewFeature` is defined.
/// Specifically, when `arcthicknessoptions` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ArcThicknessOptions::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ArcThicknessOptions {
    #[allow(missing_docs)] // documentation missing in model
    Large,
    #[allow(missing_docs)] // documentation missing in model
    Medium,
    #[allow(missing_docs)] // documentation missing in model
    Small,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ArcThicknessOptions {
    fn from(s: &str) -> Self {
        match s {
            "LARGE" => ArcThicknessOptions::Large,
            "MEDIUM" => ArcThicknessOptions::Medium,
            "SMALL" => ArcThicknessOptions::Small,
            other => {
                ArcThicknessOptions::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ArcThicknessOptions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ArcThicknessOptions::from(s))
    }
}
impl ArcThicknessOptions {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ArcThicknessOptions::Large => "LARGE",
            ArcThicknessOptions::Medium => "MEDIUM",
            ArcThicknessOptions::Small => "SMALL",
            ArcThicknessOptions::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LARGE", "MEDIUM", "SMALL"]
    }
}
impl AsRef<str> for ArcThicknessOptions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The arc axis configuration of a <code>GaugeChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ArcAxisConfiguration {
    /// <p>The arc axis range of a <code>GaugeChartVisual</code>.</p>
    #[doc(hidden)]
    pub range: std::option::Option<crate::model::ArcAxisDisplayRange>,
    /// <p>The reserved range of the arc axis.</p>
    #[doc(hidden)]
    pub reserve_range: i32,
}
impl ArcAxisConfiguration {
    /// <p>The arc axis range of a <code>GaugeChartVisual</code>.</p>
    pub fn range(&self) -> std::option::Option<&crate::model::ArcAxisDisplayRange> {
        self.range.as_ref()
    }
    /// <p>The reserved range of the arc axis.</p>
    pub fn reserve_range(&self) -> i32 {
        self.reserve_range
    }
}
/// See [`ArcAxisConfiguration`](crate::model::ArcAxisConfiguration).
pub mod arc_axis_configuration {

    /// A builder for [`ArcAxisConfiguration`](crate::model::ArcAxisConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) range: std::option::Option<crate::model::ArcAxisDisplayRange>,
        pub(crate) reserve_range: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The arc axis range of a <code>GaugeChartVisual</code>.</p>
        pub fn range(mut self, input: crate::model::ArcAxisDisplayRange) -> Self {
            self.range = Some(input);
            self
        }
        /// <p>The arc axis range of a <code>GaugeChartVisual</code>.</p>
        pub fn set_range(
            mut self,
            input: std::option::Option<crate::model::ArcAxisDisplayRange>,
        ) -> Self {
            self.range = input;
            self
        }
        /// <p>The reserved range of the arc axis.</p>
        pub fn reserve_range(mut self, input: i32) -> Self {
            self.reserve_range = Some(input);
            self
        }
        /// <p>The reserved range of the arc axis.</p>
        pub fn set_reserve_range(mut self, input: std::option::Option<i32>) -> Self {
            self.reserve_range = input;
            self
        }
        /// Consumes the builder and constructs a [`ArcAxisConfiguration`](crate::model::ArcAxisConfiguration).
        pub fn build(self) -> crate::model::ArcAxisConfiguration {
            crate::model::ArcAxisConfiguration {
                range: self.range,
                reserve_range: self.reserve_range.unwrap_or_default(),
            }
        }
    }
}
impl ArcAxisConfiguration {
    /// Creates a new builder-style object to manufacture [`ArcAxisConfiguration`](crate::model::ArcAxisConfiguration).
    pub fn builder() -> crate::model::arc_axis_configuration::Builder {
        crate::model::arc_axis_configuration::Builder::default()
    }
}

/// <p>The arc axis range of a <code>GaugeChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ArcAxisDisplayRange {
    /// <p>The minimum value of the arc axis range.</p>
    #[doc(hidden)]
    pub min: std::option::Option<f64>,
    /// <p>The maximum value of the arc axis range.</p>
    #[doc(hidden)]
    pub max: std::option::Option<f64>,
}
impl ArcAxisDisplayRange {
    /// <p>The minimum value of the arc axis range.</p>
    pub fn min(&self) -> std::option::Option<f64> {
        self.min
    }
    /// <p>The maximum value of the arc axis range.</p>
    pub fn max(&self) -> std::option::Option<f64> {
        self.max
    }
}
/// See [`ArcAxisDisplayRange`](crate::model::ArcAxisDisplayRange).
pub mod arc_axis_display_range {

    /// A builder for [`ArcAxisDisplayRange`](crate::model::ArcAxisDisplayRange).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) min: std::option::Option<f64>,
        pub(crate) max: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The minimum value of the arc axis range.</p>
        pub fn min(mut self, input: f64) -> Self {
            self.min = Some(input);
            self
        }
        /// <p>The minimum value of the arc axis range.</p>
        pub fn set_min(mut self, input: std::option::Option<f64>) -> Self {
            self.min = input;
            self
        }
        /// <p>The maximum value of the arc axis range.</p>
        pub fn max(mut self, input: f64) -> Self {
            self.max = Some(input);
            self
        }
        /// <p>The maximum value of the arc axis range.</p>
        pub fn set_max(mut self, input: std::option::Option<f64>) -> Self {
            self.max = input;
            self
        }
        /// Consumes the builder and constructs a [`ArcAxisDisplayRange`](crate::model::ArcAxisDisplayRange).
        pub fn build(self) -> crate::model::ArcAxisDisplayRange {
            crate::model::ArcAxisDisplayRange {
                min: self.min,
                max: self.max,
            }
        }
    }
}
impl ArcAxisDisplayRange {
    /// Creates a new builder-style object to manufacture [`ArcAxisDisplayRange`](crate::model::ArcAxisDisplayRange).
    pub fn builder() -> crate::model::arc_axis_display_range::Builder {
        crate::model::arc_axis_display_range::Builder::default()
    }
}

/// <p>The comparison display configuration of a KPI or gauge chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComparisonConfiguration {
    /// <p>The method of the comparison. Choose from the following options:</p>
    /// <ul>
    /// <li> <p> <code>DIFFERENCE</code> </p> </li>
    /// <li> <p> <code>PERCENT_DIFFERENCE</code> </p> </li>
    /// <li> <p> <code>PERCENT</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub comparison_method: std::option::Option<crate::model::ComparisonMethod>,
    /// <p>The format of the comparison.</p>
    #[doc(hidden)]
    pub comparison_format: std::option::Option<crate::model::ComparisonFormatConfiguration>,
}
impl ComparisonConfiguration {
    /// <p>The method of the comparison. Choose from the following options:</p>
    /// <ul>
    /// <li> <p> <code>DIFFERENCE</code> </p> </li>
    /// <li> <p> <code>PERCENT_DIFFERENCE</code> </p> </li>
    /// <li> <p> <code>PERCENT</code> </p> </li>
    /// </ul>
    pub fn comparison_method(&self) -> std::option::Option<&crate::model::ComparisonMethod> {
        self.comparison_method.as_ref()
    }
    /// <p>The format of the comparison.</p>
    pub fn comparison_format(
        &self,
    ) -> std::option::Option<&crate::model::ComparisonFormatConfiguration> {
        self.comparison_format.as_ref()
    }
}
/// See [`ComparisonConfiguration`](crate::model::ComparisonConfiguration).
pub mod comparison_configuration {

    /// A builder for [`ComparisonConfiguration`](crate::model::ComparisonConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comparison_method: std::option::Option<crate::model::ComparisonMethod>,
        pub(crate) comparison_format:
            std::option::Option<crate::model::ComparisonFormatConfiguration>,
    }
    impl Builder {
        /// <p>The method of the comparison. Choose from the following options:</p>
        /// <ul>
        /// <li> <p> <code>DIFFERENCE</code> </p> </li>
        /// <li> <p> <code>PERCENT_DIFFERENCE</code> </p> </li>
        /// <li> <p> <code>PERCENT</code> </p> </li>
        /// </ul>
        pub fn comparison_method(mut self, input: crate::model::ComparisonMethod) -> Self {
            self.comparison_method = Some(input);
            self
        }
        /// <p>The method of the comparison. Choose from the following options:</p>
        /// <ul>
        /// <li> <p> <code>DIFFERENCE</code> </p> </li>
        /// <li> <p> <code>PERCENT_DIFFERENCE</code> </p> </li>
        /// <li> <p> <code>PERCENT</code> </p> </li>
        /// </ul>
        pub fn set_comparison_method(
            mut self,
            input: std::option::Option<crate::model::ComparisonMethod>,
        ) -> Self {
            self.comparison_method = input;
            self
        }
        /// <p>The format of the comparison.</p>
        pub fn comparison_format(
            mut self,
            input: crate::model::ComparisonFormatConfiguration,
        ) -> Self {
            self.comparison_format = Some(input);
            self
        }
        /// <p>The format of the comparison.</p>
        pub fn set_comparison_format(
            mut self,
            input: std::option::Option<crate::model::ComparisonFormatConfiguration>,
        ) -> Self {
            self.comparison_format = input;
            self
        }
        /// Consumes the builder and constructs a [`ComparisonConfiguration`](crate::model::ComparisonConfiguration).
        pub fn build(self) -> crate::model::ComparisonConfiguration {
            crate::model::ComparisonConfiguration {
                comparison_method: self.comparison_method,
                comparison_format: self.comparison_format,
            }
        }
    }
}
impl ComparisonConfiguration {
    /// Creates a new builder-style object to manufacture [`ComparisonConfiguration`](crate::model::ComparisonConfiguration).
    pub fn builder() -> crate::model::comparison_configuration::Builder {
        crate::model::comparison_configuration::Builder::default()
    }
}

/// <p>The format of the comparison.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComparisonFormatConfiguration {
    /// <p>The number display format.</p>
    #[doc(hidden)]
    pub number_display_format_configuration:
        std::option::Option<crate::model::NumberDisplayFormatConfiguration>,
    /// <p>The percentage display format.</p>
    #[doc(hidden)]
    pub percentage_display_format_configuration:
        std::option::Option<crate::model::PercentageDisplayFormatConfiguration>,
}
impl ComparisonFormatConfiguration {
    /// <p>The number display format.</p>
    pub fn number_display_format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NumberDisplayFormatConfiguration> {
        self.number_display_format_configuration.as_ref()
    }
    /// <p>The percentage display format.</p>
    pub fn percentage_display_format_configuration(
        &self,
    ) -> std::option::Option<&crate::model::PercentageDisplayFormatConfiguration> {
        self.percentage_display_format_configuration.as_ref()
    }
}
/// See [`ComparisonFormatConfiguration`](crate::model::ComparisonFormatConfiguration).
pub mod comparison_format_configuration {

    /// A builder for [`ComparisonFormatConfiguration`](crate::model::ComparisonFormatConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) number_display_format_configuration:
            std::option::Option<crate::model::NumberDisplayFormatConfiguration>,
        pub(crate) percentage_display_format_configuration:
            std::option::Option<crate::model::PercentageDisplayFormatConfiguration>,
    }
    impl Builder {
        /// <p>The number display format.</p>
        pub fn number_display_format_configuration(
            mut self,
            input: crate::model::NumberDisplayFormatConfiguration,
        ) -> Self {
            self.number_display_format_configuration = Some(input);
            self
        }
        /// <p>The number display format.</p>
        pub fn set_number_display_format_configuration(
            mut self,
            input: std::option::Option<crate::model::NumberDisplayFormatConfiguration>,
        ) -> Self {
            self.number_display_format_configuration = input;
            self
        }
        /// <p>The percentage display format.</p>
        pub fn percentage_display_format_configuration(
            mut self,
            input: crate::model::PercentageDisplayFormatConfiguration,
        ) -> Self {
            self.percentage_display_format_configuration = Some(input);
            self
        }
        /// <p>The percentage display format.</p>
        pub fn set_percentage_display_format_configuration(
            mut self,
            input: std::option::Option<crate::model::PercentageDisplayFormatConfiguration>,
        ) -> Self {
            self.percentage_display_format_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ComparisonFormatConfiguration`](crate::model::ComparisonFormatConfiguration).
        pub fn build(self) -> crate::model::ComparisonFormatConfiguration {
            crate::model::ComparisonFormatConfiguration {
                number_display_format_configuration: self.number_display_format_configuration,
                percentage_display_format_configuration: self
                    .percentage_display_format_configuration,
            }
        }
    }
}
impl ComparisonFormatConfiguration {
    /// Creates a new builder-style object to manufacture [`ComparisonFormatConfiguration`](crate::model::ComparisonFormatConfiguration).
    pub fn builder() -> crate::model::comparison_format_configuration::Builder {
        crate::model::comparison_format_configuration::Builder::default()
    }
}

/// When writing a match expression against `ComparisonMethod`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let comparisonmethod = unimplemented!();
/// match comparisonmethod {
///     ComparisonMethod::Difference => { /* ... */ },
///     ComparisonMethod::Percent => { /* ... */ },
///     ComparisonMethod::PercentDifference => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `comparisonmethod` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ComparisonMethod::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ComparisonMethod::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ComparisonMethod::NewFeature` is defined.
/// Specifically, when `comparisonmethod` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ComparisonMethod::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ComparisonMethod {
    #[allow(missing_docs)] // documentation missing in model
    Difference,
    #[allow(missing_docs)] // documentation missing in model
    Percent,
    #[allow(missing_docs)] // documentation missing in model
    PercentDifference,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ComparisonMethod {
    fn from(s: &str) -> Self {
        match s {
            "DIFFERENCE" => ComparisonMethod::Difference,
            "PERCENT" => ComparisonMethod::Percent,
            "PERCENT_DIFFERENCE" => ComparisonMethod::PercentDifference,
            other => ComparisonMethod::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ComparisonMethod {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ComparisonMethod::from(s))
    }
}
impl ComparisonMethod {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ComparisonMethod::Difference => "DIFFERENCE",
            ComparisonMethod::Percent => "PERCENT",
            ComparisonMethod::PercentDifference => "PERCENT_DIFFERENCE",
            ComparisonMethod::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DIFFERENCE", "PERCENT", "PERCENT_DIFFERENCE"]
    }
}
impl AsRef<str> for ComparisonMethod {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PrimaryValueDisplayType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let primaryvaluedisplaytype = unimplemented!();
/// match primaryvaluedisplaytype {
///     PrimaryValueDisplayType::Actual => { /* ... */ },
///     PrimaryValueDisplayType::Comparison => { /* ... */ },
///     PrimaryValueDisplayType::Hidden => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `primaryvaluedisplaytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PrimaryValueDisplayType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PrimaryValueDisplayType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PrimaryValueDisplayType::NewFeature` is defined.
/// Specifically, when `primaryvaluedisplaytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PrimaryValueDisplayType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PrimaryValueDisplayType {
    #[allow(missing_docs)] // documentation missing in model
    Actual,
    #[allow(missing_docs)] // documentation missing in model
    Comparison,
    #[allow(missing_docs)] // documentation missing in model
    Hidden,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PrimaryValueDisplayType {
    fn from(s: &str) -> Self {
        match s {
            "ACTUAL" => PrimaryValueDisplayType::Actual,
            "COMPARISON" => PrimaryValueDisplayType::Comparison,
            "HIDDEN" => PrimaryValueDisplayType::Hidden,
            other => PrimaryValueDisplayType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for PrimaryValueDisplayType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PrimaryValueDisplayType::from(s))
    }
}
impl PrimaryValueDisplayType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PrimaryValueDisplayType::Actual => "ACTUAL",
            PrimaryValueDisplayType::Comparison => "COMPARISON",
            PrimaryValueDisplayType::Hidden => "HIDDEN",
            PrimaryValueDisplayType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTUAL", "COMPARISON", "HIDDEN"]
    }
}
impl AsRef<str> for PrimaryValueDisplayType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The field well configuration of a <code>GaugeChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GaugeChartFieldWells {
    /// <p>The value field wells of a <code>GaugeChartVisual</code>.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    /// <p>The target value field wells of a <code>GaugeChartVisual</code>.</p>
    #[doc(hidden)]
    pub target_values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
}
impl GaugeChartFieldWells {
    /// <p>The value field wells of a <code>GaugeChartVisual</code>.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.values.as_deref()
    }
    /// <p>The target value field wells of a <code>GaugeChartVisual</code>.</p>
    pub fn target_values(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.target_values.as_deref()
    }
}
/// See [`GaugeChartFieldWells`](crate::model::GaugeChartFieldWells).
pub mod gauge_chart_field_wells {

    /// A builder for [`GaugeChartFieldWells`](crate::model::GaugeChartFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        pub(crate) target_values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    }
    impl Builder {
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The value field wells of a <code>GaugeChartVisual</code>.</p>
        pub fn values(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>The value field wells of a <code>GaugeChartVisual</code>.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Appends an item to `target_values`.
        ///
        /// To override the contents of this collection use [`set_target_values`](Self::set_target_values).
        ///
        /// <p>The target value field wells of a <code>GaugeChartVisual</code>.</p>
        pub fn target_values(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.target_values.unwrap_or_default();
            v.push(input);
            self.target_values = Some(v);
            self
        }
        /// <p>The target value field wells of a <code>GaugeChartVisual</code>.</p>
        pub fn set_target_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.target_values = input;
            self
        }
        /// Consumes the builder and constructs a [`GaugeChartFieldWells`](crate::model::GaugeChartFieldWells).
        pub fn build(self) -> crate::model::GaugeChartFieldWells {
            crate::model::GaugeChartFieldWells {
                values: self.values,
                target_values: self.target_values,
            }
        }
    }
}
impl GaugeChartFieldWells {
    /// Creates a new builder-style object to manufacture [`GaugeChartFieldWells`](crate::model::GaugeChartFieldWells).
    pub fn builder() -> crate::model::gauge_chart_field_wells::Builder {
        crate::model::gauge_chart_field_wells::Builder::default()
    }
}

/// <p>A pie or donut chart.</p>
/// <p>The <code>PieChartVisual</code> structure describes a visual that is a member of the pie chart family.</p>
/// <p>The following charts can be described by using this structure:</p>
/// <ul>
/// <li> <p>Pie charts</p> </li>
/// <li> <p>Donut charts</p> </li>
/// </ul>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/pie-chart.html">Using pie charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/donut-chart.html">Using donut charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PieChartVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration of a pie chart.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::PieChartConfiguration>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    #[doc(hidden)]
    pub column_hierarchies: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
}
impl PieChartVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration of a pie chart.</p>
    pub fn chart_configuration(&self) -> std::option::Option<&crate::model::PieChartConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    pub fn column_hierarchies(&self) -> std::option::Option<&[crate::model::ColumnHierarchy]> {
        self.column_hierarchies.as_deref()
    }
}
/// See [`PieChartVisual`](crate::model::PieChartVisual).
pub mod pie_chart_visual {

    /// A builder for [`PieChartVisual`](crate::model::PieChartVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration: std::option::Option<crate::model::PieChartConfiguration>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        pub(crate) column_hierarchies:
            std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration of a pie chart.</p>
        pub fn chart_configuration(mut self, input: crate::model::PieChartConfiguration) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration of a pie chart.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::PieChartConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Appends an item to `column_hierarchies`.
        ///
        /// To override the contents of this collection use [`set_column_hierarchies`](Self::set_column_hierarchies).
        ///
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn column_hierarchies(mut self, input: crate::model::ColumnHierarchy) -> Self {
            let mut v = self.column_hierarchies.unwrap_or_default();
            v.push(input);
            self.column_hierarchies = Some(v);
            self
        }
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn set_column_hierarchies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
        ) -> Self {
            self.column_hierarchies = input;
            self
        }
        /// Consumes the builder and constructs a [`PieChartVisual`](crate::model::PieChartVisual).
        pub fn build(self) -> crate::model::PieChartVisual {
            crate::model::PieChartVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                actions: self.actions,
                column_hierarchies: self.column_hierarchies,
            }
        }
    }
}
impl PieChartVisual {
    /// Creates a new builder-style object to manufacture [`PieChartVisual`](crate::model::PieChartVisual).
    pub fn builder() -> crate::model::pie_chart_visual::Builder {
        crate::model::pie_chart_visual::Builder::default()
    }
}

/// <p>The configuration of a pie chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PieChartConfiguration {
    /// <p>The field wells of the visual.</p>
    #[doc(hidden)]
    pub field_wells: std::option::Option<crate::model::PieChartFieldWells>,
    /// <p>The sort configuration of a pie chart.</p>
    #[doc(hidden)]
    pub sort_configuration: std::option::Option<crate::model::PieChartSortConfiguration>,
    /// <p>The options that determine the shape of the chart. This option determines whether the chart is a pie chart or a donut chart.</p>
    #[doc(hidden)]
    pub donut_options: std::option::Option<crate::model::DonutOptions>,
    /// <p>The small multiples setup for the visual.</p>
    #[doc(hidden)]
    pub small_multiples_options: std::option::Option<crate::model::SmallMultiplesOptions>,
    /// <p>The label options of the group/color that is displayed in a pie chart.</p>
    #[doc(hidden)]
    pub category_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The label options for the value that is displayed in a pie chart.</p>
    #[doc(hidden)]
    pub value_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The legend display setup of the visual.</p>
    #[doc(hidden)]
    pub legend: std::option::Option<crate::model::LegendOptions>,
    /// <p>The options that determine if visual data labels are displayed.</p>
    #[doc(hidden)]
    pub data_labels: std::option::Option<crate::model::DataLabelOptions>,
    /// <p>The tooltip display setup of the visual.</p>
    #[doc(hidden)]
    pub tooltip: std::option::Option<crate::model::TooltipOptions>,
    /// <p>The palette (chart color) display setup of the visual.</p>
    #[doc(hidden)]
    pub visual_palette: std::option::Option<crate::model::VisualPalette>,
    /// <p>The contribution analysis (anomaly configuration) setup of the visual.</p>
    #[doc(hidden)]
    pub contribution_analysis_defaults:
        std::option::Option<std::vec::Vec<crate::model::ContributionAnalysisDefault>>,
}
impl PieChartConfiguration {
    /// <p>The field wells of the visual.</p>
    pub fn field_wells(&self) -> std::option::Option<&crate::model::PieChartFieldWells> {
        self.field_wells.as_ref()
    }
    /// <p>The sort configuration of a pie chart.</p>
    pub fn sort_configuration(
        &self,
    ) -> std::option::Option<&crate::model::PieChartSortConfiguration> {
        self.sort_configuration.as_ref()
    }
    /// <p>The options that determine the shape of the chart. This option determines whether the chart is a pie chart or a donut chart.</p>
    pub fn donut_options(&self) -> std::option::Option<&crate::model::DonutOptions> {
        self.donut_options.as_ref()
    }
    /// <p>The small multiples setup for the visual.</p>
    pub fn small_multiples_options(
        &self,
    ) -> std::option::Option<&crate::model::SmallMultiplesOptions> {
        self.small_multiples_options.as_ref()
    }
    /// <p>The label options of the group/color that is displayed in a pie chart.</p>
    pub fn category_label_options(
        &self,
    ) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.category_label_options.as_ref()
    }
    /// <p>The label options for the value that is displayed in a pie chart.</p>
    pub fn value_label_options(&self) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.value_label_options.as_ref()
    }
    /// <p>The legend display setup of the visual.</p>
    pub fn legend(&self) -> std::option::Option<&crate::model::LegendOptions> {
        self.legend.as_ref()
    }
    /// <p>The options that determine if visual data labels are displayed.</p>
    pub fn data_labels(&self) -> std::option::Option<&crate::model::DataLabelOptions> {
        self.data_labels.as_ref()
    }
    /// <p>The tooltip display setup of the visual.</p>
    pub fn tooltip(&self) -> std::option::Option<&crate::model::TooltipOptions> {
        self.tooltip.as_ref()
    }
    /// <p>The palette (chart color) display setup of the visual.</p>
    pub fn visual_palette(&self) -> std::option::Option<&crate::model::VisualPalette> {
        self.visual_palette.as_ref()
    }
    /// <p>The contribution analysis (anomaly configuration) setup of the visual.</p>
    pub fn contribution_analysis_defaults(
        &self,
    ) -> std::option::Option<&[crate::model::ContributionAnalysisDefault]> {
        self.contribution_analysis_defaults.as_deref()
    }
}
/// See [`PieChartConfiguration`](crate::model::PieChartConfiguration).
pub mod pie_chart_configuration {

    /// A builder for [`PieChartConfiguration`](crate::model::PieChartConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_wells: std::option::Option<crate::model::PieChartFieldWells>,
        pub(crate) sort_configuration: std::option::Option<crate::model::PieChartSortConfiguration>,
        pub(crate) donut_options: std::option::Option<crate::model::DonutOptions>,
        pub(crate) small_multiples_options:
            std::option::Option<crate::model::SmallMultiplesOptions>,
        pub(crate) category_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) value_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) legend: std::option::Option<crate::model::LegendOptions>,
        pub(crate) data_labels: std::option::Option<crate::model::DataLabelOptions>,
        pub(crate) tooltip: std::option::Option<crate::model::TooltipOptions>,
        pub(crate) visual_palette: std::option::Option<crate::model::VisualPalette>,
        pub(crate) contribution_analysis_defaults:
            std::option::Option<std::vec::Vec<crate::model::ContributionAnalysisDefault>>,
    }
    impl Builder {
        /// <p>The field wells of the visual.</p>
        pub fn field_wells(mut self, input: crate::model::PieChartFieldWells) -> Self {
            self.field_wells = Some(input);
            self
        }
        /// <p>The field wells of the visual.</p>
        pub fn set_field_wells(
            mut self,
            input: std::option::Option<crate::model::PieChartFieldWells>,
        ) -> Self {
            self.field_wells = input;
            self
        }
        /// <p>The sort configuration of a pie chart.</p>
        pub fn sort_configuration(
            mut self,
            input: crate::model::PieChartSortConfiguration,
        ) -> Self {
            self.sort_configuration = Some(input);
            self
        }
        /// <p>The sort configuration of a pie chart.</p>
        pub fn set_sort_configuration(
            mut self,
            input: std::option::Option<crate::model::PieChartSortConfiguration>,
        ) -> Self {
            self.sort_configuration = input;
            self
        }
        /// <p>The options that determine the shape of the chart. This option determines whether the chart is a pie chart or a donut chart.</p>
        pub fn donut_options(mut self, input: crate::model::DonutOptions) -> Self {
            self.donut_options = Some(input);
            self
        }
        /// <p>The options that determine the shape of the chart. This option determines whether the chart is a pie chart or a donut chart.</p>
        pub fn set_donut_options(
            mut self,
            input: std::option::Option<crate::model::DonutOptions>,
        ) -> Self {
            self.donut_options = input;
            self
        }
        /// <p>The small multiples setup for the visual.</p>
        pub fn small_multiples_options(
            mut self,
            input: crate::model::SmallMultiplesOptions,
        ) -> Self {
            self.small_multiples_options = Some(input);
            self
        }
        /// <p>The small multiples setup for the visual.</p>
        pub fn set_small_multiples_options(
            mut self,
            input: std::option::Option<crate::model::SmallMultiplesOptions>,
        ) -> Self {
            self.small_multiples_options = input;
            self
        }
        /// <p>The label options of the group/color that is displayed in a pie chart.</p>
        pub fn category_label_options(
            mut self,
            input: crate::model::ChartAxisLabelOptions,
        ) -> Self {
            self.category_label_options = Some(input);
            self
        }
        /// <p>The label options of the group/color that is displayed in a pie chart.</p>
        pub fn set_category_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.category_label_options = input;
            self
        }
        /// <p>The label options for the value that is displayed in a pie chart.</p>
        pub fn value_label_options(mut self, input: crate::model::ChartAxisLabelOptions) -> Self {
            self.value_label_options = Some(input);
            self
        }
        /// <p>The label options for the value that is displayed in a pie chart.</p>
        pub fn set_value_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.value_label_options = input;
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn legend(mut self, input: crate::model::LegendOptions) -> Self {
            self.legend = Some(input);
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn set_legend(
            mut self,
            input: std::option::Option<crate::model::LegendOptions>,
        ) -> Self {
            self.legend = input;
            self
        }
        /// <p>The options that determine if visual data labels are displayed.</p>
        pub fn data_labels(mut self, input: crate::model::DataLabelOptions) -> Self {
            self.data_labels = Some(input);
            self
        }
        /// <p>The options that determine if visual data labels are displayed.</p>
        pub fn set_data_labels(
            mut self,
            input: std::option::Option<crate::model::DataLabelOptions>,
        ) -> Self {
            self.data_labels = input;
            self
        }
        /// <p>The tooltip display setup of the visual.</p>
        pub fn tooltip(mut self, input: crate::model::TooltipOptions) -> Self {
            self.tooltip = Some(input);
            self
        }
        /// <p>The tooltip display setup of the visual.</p>
        pub fn set_tooltip(
            mut self,
            input: std::option::Option<crate::model::TooltipOptions>,
        ) -> Self {
            self.tooltip = input;
            self
        }
        /// <p>The palette (chart color) display setup of the visual.</p>
        pub fn visual_palette(mut self, input: crate::model::VisualPalette) -> Self {
            self.visual_palette = Some(input);
            self
        }
        /// <p>The palette (chart color) display setup of the visual.</p>
        pub fn set_visual_palette(
            mut self,
            input: std::option::Option<crate::model::VisualPalette>,
        ) -> Self {
            self.visual_palette = input;
            self
        }
        /// Appends an item to `contribution_analysis_defaults`.
        ///
        /// To override the contents of this collection use [`set_contribution_analysis_defaults`](Self::set_contribution_analysis_defaults).
        ///
        /// <p>The contribution analysis (anomaly configuration) setup of the visual.</p>
        pub fn contribution_analysis_defaults(
            mut self,
            input: crate::model::ContributionAnalysisDefault,
        ) -> Self {
            let mut v = self.contribution_analysis_defaults.unwrap_or_default();
            v.push(input);
            self.contribution_analysis_defaults = Some(v);
            self
        }
        /// <p>The contribution analysis (anomaly configuration) setup of the visual.</p>
        pub fn set_contribution_analysis_defaults(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ContributionAnalysisDefault>>,
        ) -> Self {
            self.contribution_analysis_defaults = input;
            self
        }
        /// Consumes the builder and constructs a [`PieChartConfiguration`](crate::model::PieChartConfiguration).
        pub fn build(self) -> crate::model::PieChartConfiguration {
            crate::model::PieChartConfiguration {
                field_wells: self.field_wells,
                sort_configuration: self.sort_configuration,
                donut_options: self.donut_options,
                small_multiples_options: self.small_multiples_options,
                category_label_options: self.category_label_options,
                value_label_options: self.value_label_options,
                legend: self.legend,
                data_labels: self.data_labels,
                tooltip: self.tooltip,
                visual_palette: self.visual_palette,
                contribution_analysis_defaults: self.contribution_analysis_defaults,
            }
        }
    }
}
impl PieChartConfiguration {
    /// Creates a new builder-style object to manufacture [`PieChartConfiguration`](crate::model::PieChartConfiguration).
    pub fn builder() -> crate::model::pie_chart_configuration::Builder {
        crate::model::pie_chart_configuration::Builder::default()
    }
}

/// <p>The options for configuring a donut chart or pie chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DonutOptions {
    /// <p>The option for define the arc of the chart shape. Valid values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>WHOLE</code> - A pie chart</p> </li>
    /// <li> <p> <code>SMALL</code>- A small-sized donut chart</p> </li>
    /// <li> <p> <code>MEDIUM</code>- A medium-sized donut chart</p> </li>
    /// <li> <p> <code>LARGE</code>- A large-sized donut chart</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub arc_options: std::option::Option<crate::model::ArcOptions>,
    /// <p>The label options of the label that is displayed in the center of a donut chart. This option isn't available for pie charts.</p>
    #[doc(hidden)]
    pub donut_center_options: std::option::Option<crate::model::DonutCenterOptions>,
}
impl DonutOptions {
    /// <p>The option for define the arc of the chart shape. Valid values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>WHOLE</code> - A pie chart</p> </li>
    /// <li> <p> <code>SMALL</code>- A small-sized donut chart</p> </li>
    /// <li> <p> <code>MEDIUM</code>- A medium-sized donut chart</p> </li>
    /// <li> <p> <code>LARGE</code>- A large-sized donut chart</p> </li>
    /// </ul>
    pub fn arc_options(&self) -> std::option::Option<&crate::model::ArcOptions> {
        self.arc_options.as_ref()
    }
    /// <p>The label options of the label that is displayed in the center of a donut chart. This option isn't available for pie charts.</p>
    pub fn donut_center_options(&self) -> std::option::Option<&crate::model::DonutCenterOptions> {
        self.donut_center_options.as_ref()
    }
}
/// See [`DonutOptions`](crate::model::DonutOptions).
pub mod donut_options {

    /// A builder for [`DonutOptions`](crate::model::DonutOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arc_options: std::option::Option<crate::model::ArcOptions>,
        pub(crate) donut_center_options: std::option::Option<crate::model::DonutCenterOptions>,
    }
    impl Builder {
        /// <p>The option for define the arc of the chart shape. Valid values are as follows:</p>
        /// <ul>
        /// <li> <p> <code>WHOLE</code> - A pie chart</p> </li>
        /// <li> <p> <code>SMALL</code>- A small-sized donut chart</p> </li>
        /// <li> <p> <code>MEDIUM</code>- A medium-sized donut chart</p> </li>
        /// <li> <p> <code>LARGE</code>- A large-sized donut chart</p> </li>
        /// </ul>
        pub fn arc_options(mut self, input: crate::model::ArcOptions) -> Self {
            self.arc_options = Some(input);
            self
        }
        /// <p>The option for define the arc of the chart shape. Valid values are as follows:</p>
        /// <ul>
        /// <li> <p> <code>WHOLE</code> - A pie chart</p> </li>
        /// <li> <p> <code>SMALL</code>- A small-sized donut chart</p> </li>
        /// <li> <p> <code>MEDIUM</code>- A medium-sized donut chart</p> </li>
        /// <li> <p> <code>LARGE</code>- A large-sized donut chart</p> </li>
        /// </ul>
        pub fn set_arc_options(
            mut self,
            input: std::option::Option<crate::model::ArcOptions>,
        ) -> Self {
            self.arc_options = input;
            self
        }
        /// <p>The label options of the label that is displayed in the center of a donut chart. This option isn't available for pie charts.</p>
        pub fn donut_center_options(mut self, input: crate::model::DonutCenterOptions) -> Self {
            self.donut_center_options = Some(input);
            self
        }
        /// <p>The label options of the label that is displayed in the center of a donut chart. This option isn't available for pie charts.</p>
        pub fn set_donut_center_options(
            mut self,
            input: std::option::Option<crate::model::DonutCenterOptions>,
        ) -> Self {
            self.donut_center_options = input;
            self
        }
        /// Consumes the builder and constructs a [`DonutOptions`](crate::model::DonutOptions).
        pub fn build(self) -> crate::model::DonutOptions {
            crate::model::DonutOptions {
                arc_options: self.arc_options,
                donut_center_options: self.donut_center_options,
            }
        }
    }
}
impl DonutOptions {
    /// Creates a new builder-style object to manufacture [`DonutOptions`](crate::model::DonutOptions).
    pub fn builder() -> crate::model::donut_options::Builder {
        crate::model::donut_options::Builder::default()
    }
}

/// <p>The label options of the label that is displayed in the center of a donut chart. This option isn't available for pie charts.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DonutCenterOptions {
    /// <p>Determines the visibility of the label in a donut chart. In the Amazon QuickSight console, this option is called <code>'Show total'</code>.</p>
    #[doc(hidden)]
    pub label_visibility: std::option::Option<crate::model::Visibility>,
}
impl DonutCenterOptions {
    /// <p>Determines the visibility of the label in a donut chart. In the Amazon QuickSight console, this option is called <code>'Show total'</code>.</p>
    pub fn label_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.label_visibility.as_ref()
    }
}
/// See [`DonutCenterOptions`](crate::model::DonutCenterOptions).
pub mod donut_center_options {

    /// A builder for [`DonutCenterOptions`](crate::model::DonutCenterOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) label_visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>Determines the visibility of the label in a donut chart. In the Amazon QuickSight console, this option is called <code>'Show total'</code>.</p>
        pub fn label_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.label_visibility = Some(input);
            self
        }
        /// <p>Determines the visibility of the label in a donut chart. In the Amazon QuickSight console, this option is called <code>'Show total'</code>.</p>
        pub fn set_label_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.label_visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`DonutCenterOptions`](crate::model::DonutCenterOptions).
        pub fn build(self) -> crate::model::DonutCenterOptions {
            crate::model::DonutCenterOptions {
                label_visibility: self.label_visibility,
            }
        }
    }
}
impl DonutCenterOptions {
    /// Creates a new builder-style object to manufacture [`DonutCenterOptions`](crate::model::DonutCenterOptions).
    pub fn builder() -> crate::model::donut_center_options::Builder {
        crate::model::donut_center_options::Builder::default()
    }
}

/// <p>The options that determine the arc thickness of a <code>GaugeChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ArcOptions {
    /// <p>The arc thickness of a <code>GaugeChartVisual</code>.</p>
    #[doc(hidden)]
    pub arc_thickness: std::option::Option<crate::model::ArcThickness>,
}
impl ArcOptions {
    /// <p>The arc thickness of a <code>GaugeChartVisual</code>.</p>
    pub fn arc_thickness(&self) -> std::option::Option<&crate::model::ArcThickness> {
        self.arc_thickness.as_ref()
    }
}
/// See [`ArcOptions`](crate::model::ArcOptions).
pub mod arc_options {

    /// A builder for [`ArcOptions`](crate::model::ArcOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arc_thickness: std::option::Option<crate::model::ArcThickness>,
    }
    impl Builder {
        /// <p>The arc thickness of a <code>GaugeChartVisual</code>.</p>
        pub fn arc_thickness(mut self, input: crate::model::ArcThickness) -> Self {
            self.arc_thickness = Some(input);
            self
        }
        /// <p>The arc thickness of a <code>GaugeChartVisual</code>.</p>
        pub fn set_arc_thickness(
            mut self,
            input: std::option::Option<crate::model::ArcThickness>,
        ) -> Self {
            self.arc_thickness = input;
            self
        }
        /// Consumes the builder and constructs a [`ArcOptions`](crate::model::ArcOptions).
        pub fn build(self) -> crate::model::ArcOptions {
            crate::model::ArcOptions {
                arc_thickness: self.arc_thickness,
            }
        }
    }
}
impl ArcOptions {
    /// Creates a new builder-style object to manufacture [`ArcOptions`](crate::model::ArcOptions).
    pub fn builder() -> crate::model::arc_options::Builder {
        crate::model::arc_options::Builder::default()
    }
}

/// When writing a match expression against `ArcThickness`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let arcthickness = unimplemented!();
/// match arcthickness {
///     ArcThickness::Large => { /* ... */ },
///     ArcThickness::Medium => { /* ... */ },
///     ArcThickness::Small => { /* ... */ },
///     ArcThickness::Whole => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `arcthickness` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ArcThickness::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ArcThickness::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ArcThickness::NewFeature` is defined.
/// Specifically, when `arcthickness` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ArcThickness::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ArcThickness {
    #[allow(missing_docs)] // documentation missing in model
    Large,
    #[allow(missing_docs)] // documentation missing in model
    Medium,
    #[allow(missing_docs)] // documentation missing in model
    Small,
    #[allow(missing_docs)] // documentation missing in model
    Whole,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ArcThickness {
    fn from(s: &str) -> Self {
        match s {
            "LARGE" => ArcThickness::Large,
            "MEDIUM" => ArcThickness::Medium,
            "SMALL" => ArcThickness::Small,
            "WHOLE" => ArcThickness::Whole,
            other => ArcThickness::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ArcThickness {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ArcThickness::from(s))
    }
}
impl ArcThickness {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ArcThickness::Large => "LARGE",
            ArcThickness::Medium => "MEDIUM",
            ArcThickness::Small => "SMALL",
            ArcThickness::Whole => "WHOLE",
            ArcThickness::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LARGE", "MEDIUM", "SMALL", "WHOLE"]
    }
}
impl AsRef<str> for ArcThickness {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The sort configuration of a pie chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PieChartSortConfiguration {
    /// <p>The sort configuration of the category fields.</p>
    #[doc(hidden)]
    pub category_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    /// <p>The limit on the number of categories that are displayed in a pie chart.</p>
    #[doc(hidden)]
    pub category_items_limit: std::option::Option<crate::model::ItemsLimitConfiguration>,
    /// <p>The sort configuration of the small multiples field.</p>
    #[doc(hidden)]
    pub small_multiples_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    /// <p>The limit on the number of small multiples panels that are displayed.</p>
    #[doc(hidden)]
    pub small_multiples_limit_configuration:
        std::option::Option<crate::model::ItemsLimitConfiguration>,
}
impl PieChartSortConfiguration {
    /// <p>The sort configuration of the category fields.</p>
    pub fn category_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.category_sort.as_deref()
    }
    /// <p>The limit on the number of categories that are displayed in a pie chart.</p>
    pub fn category_items_limit(
        &self,
    ) -> std::option::Option<&crate::model::ItemsLimitConfiguration> {
        self.category_items_limit.as_ref()
    }
    /// <p>The sort configuration of the small multiples field.</p>
    pub fn small_multiples_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.small_multiples_sort.as_deref()
    }
    /// <p>The limit on the number of small multiples panels that are displayed.</p>
    pub fn small_multiples_limit_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ItemsLimitConfiguration> {
        self.small_multiples_limit_configuration.as_ref()
    }
}
/// See [`PieChartSortConfiguration`](crate::model::PieChartSortConfiguration).
pub mod pie_chart_sort_configuration {

    /// A builder for [`PieChartSortConfiguration`](crate::model::PieChartSortConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category_sort:
            std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        pub(crate) category_items_limit: std::option::Option<crate::model::ItemsLimitConfiguration>,
        pub(crate) small_multiples_sort:
            std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        pub(crate) small_multiples_limit_configuration:
            std::option::Option<crate::model::ItemsLimitConfiguration>,
    }
    impl Builder {
        /// Appends an item to `category_sort`.
        ///
        /// To override the contents of this collection use [`set_category_sort`](Self::set_category_sort).
        ///
        /// <p>The sort configuration of the category fields.</p>
        pub fn category_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.category_sort.unwrap_or_default();
            v.push(input);
            self.category_sort = Some(v);
            self
        }
        /// <p>The sort configuration of the category fields.</p>
        pub fn set_category_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.category_sort = input;
            self
        }
        /// <p>The limit on the number of categories that are displayed in a pie chart.</p>
        pub fn category_items_limit(
            mut self,
            input: crate::model::ItemsLimitConfiguration,
        ) -> Self {
            self.category_items_limit = Some(input);
            self
        }
        /// <p>The limit on the number of categories that are displayed in a pie chart.</p>
        pub fn set_category_items_limit(
            mut self,
            input: std::option::Option<crate::model::ItemsLimitConfiguration>,
        ) -> Self {
            self.category_items_limit = input;
            self
        }
        /// Appends an item to `small_multiples_sort`.
        ///
        /// To override the contents of this collection use [`set_small_multiples_sort`](Self::set_small_multiples_sort).
        ///
        /// <p>The sort configuration of the small multiples field.</p>
        pub fn small_multiples_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.small_multiples_sort.unwrap_or_default();
            v.push(input);
            self.small_multiples_sort = Some(v);
            self
        }
        /// <p>The sort configuration of the small multiples field.</p>
        pub fn set_small_multiples_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.small_multiples_sort = input;
            self
        }
        /// <p>The limit on the number of small multiples panels that are displayed.</p>
        pub fn small_multiples_limit_configuration(
            mut self,
            input: crate::model::ItemsLimitConfiguration,
        ) -> Self {
            self.small_multiples_limit_configuration = Some(input);
            self
        }
        /// <p>The limit on the number of small multiples panels that are displayed.</p>
        pub fn set_small_multiples_limit_configuration(
            mut self,
            input: std::option::Option<crate::model::ItemsLimitConfiguration>,
        ) -> Self {
            self.small_multiples_limit_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PieChartSortConfiguration`](crate::model::PieChartSortConfiguration).
        pub fn build(self) -> crate::model::PieChartSortConfiguration {
            crate::model::PieChartSortConfiguration {
                category_sort: self.category_sort,
                category_items_limit: self.category_items_limit,
                small_multiples_sort: self.small_multiples_sort,
                small_multiples_limit_configuration: self.small_multiples_limit_configuration,
            }
        }
    }
}
impl PieChartSortConfiguration {
    /// Creates a new builder-style object to manufacture [`PieChartSortConfiguration`](crate::model::PieChartSortConfiguration).
    pub fn builder() -> crate::model::pie_chart_sort_configuration::Builder {
        crate::model::pie_chart_sort_configuration::Builder::default()
    }
}

/// <p>The field well configuration of a pie chart.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PieChartFieldWells {
    /// <p>The field well configuration of a pie chart.</p>
    #[doc(hidden)]
    pub pie_chart_aggregated_field_wells:
        std::option::Option<crate::model::PieChartAggregatedFieldWells>,
}
impl PieChartFieldWells {
    /// <p>The field well configuration of a pie chart.</p>
    pub fn pie_chart_aggregated_field_wells(
        &self,
    ) -> std::option::Option<&crate::model::PieChartAggregatedFieldWells> {
        self.pie_chart_aggregated_field_wells.as_ref()
    }
}
/// See [`PieChartFieldWells`](crate::model::PieChartFieldWells).
pub mod pie_chart_field_wells {

    /// A builder for [`PieChartFieldWells`](crate::model::PieChartFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pie_chart_aggregated_field_wells:
            std::option::Option<crate::model::PieChartAggregatedFieldWells>,
    }
    impl Builder {
        /// <p>The field well configuration of a pie chart.</p>
        pub fn pie_chart_aggregated_field_wells(
            mut self,
            input: crate::model::PieChartAggregatedFieldWells,
        ) -> Self {
            self.pie_chart_aggregated_field_wells = Some(input);
            self
        }
        /// <p>The field well configuration of a pie chart.</p>
        pub fn set_pie_chart_aggregated_field_wells(
            mut self,
            input: std::option::Option<crate::model::PieChartAggregatedFieldWells>,
        ) -> Self {
            self.pie_chart_aggregated_field_wells = input;
            self
        }
        /// Consumes the builder and constructs a [`PieChartFieldWells`](crate::model::PieChartFieldWells).
        pub fn build(self) -> crate::model::PieChartFieldWells {
            crate::model::PieChartFieldWells {
                pie_chart_aggregated_field_wells: self.pie_chart_aggregated_field_wells,
            }
        }
    }
}
impl PieChartFieldWells {
    /// Creates a new builder-style object to manufacture [`PieChartFieldWells`](crate::model::PieChartFieldWells).
    pub fn builder() -> crate::model::pie_chart_field_wells::Builder {
        crate::model::pie_chart_field_wells::Builder::default()
    }
}

/// <p>The field well configuration of a pie chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PieChartAggregatedFieldWells {
    /// <p>The category (group/color) field wells of a pie chart.</p>
    #[doc(hidden)]
    pub category: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The value field wells of a pie chart. Values are aggregated based on categories.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    /// <p>The small multiples field well of a pie chart.</p>
    #[doc(hidden)]
    pub small_multiples: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
}
impl PieChartAggregatedFieldWells {
    /// <p>The category (group/color) field wells of a pie chart.</p>
    pub fn category(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.category.as_deref()
    }
    /// <p>The value field wells of a pie chart. Values are aggregated based on categories.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.values.as_deref()
    }
    /// <p>The small multiples field well of a pie chart.</p>
    pub fn small_multiples(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.small_multiples.as_deref()
    }
}
/// See [`PieChartAggregatedFieldWells`](crate::model::PieChartAggregatedFieldWells).
pub mod pie_chart_aggregated_field_wells {

    /// A builder for [`PieChartAggregatedFieldWells`](crate::model::PieChartAggregatedFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        pub(crate) small_multiples:
            std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    }
    impl Builder {
        /// Appends an item to `category`.
        ///
        /// To override the contents of this collection use [`set_category`](Self::set_category).
        ///
        /// <p>The category (group/color) field wells of a pie chart.</p>
        pub fn category(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.category.unwrap_or_default();
            v.push(input);
            self.category = Some(v);
            self
        }
        /// <p>The category (group/color) field wells of a pie chart.</p>
        pub fn set_category(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.category = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The value field wells of a pie chart. Values are aggregated based on categories.</p>
        pub fn values(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>The value field wells of a pie chart. Values are aggregated based on categories.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Appends an item to `small_multiples`.
        ///
        /// To override the contents of this collection use [`set_small_multiples`](Self::set_small_multiples).
        ///
        /// <p>The small multiples field well of a pie chart.</p>
        pub fn small_multiples(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.small_multiples.unwrap_or_default();
            v.push(input);
            self.small_multiples = Some(v);
            self
        }
        /// <p>The small multiples field well of a pie chart.</p>
        pub fn set_small_multiples(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.small_multiples = input;
            self
        }
        /// Consumes the builder and constructs a [`PieChartAggregatedFieldWells`](crate::model::PieChartAggregatedFieldWells).
        pub fn build(self) -> crate::model::PieChartAggregatedFieldWells {
            crate::model::PieChartAggregatedFieldWells {
                category: self.category,
                values: self.values,
                small_multiples: self.small_multiples,
            }
        }
    }
}
impl PieChartAggregatedFieldWells {
    /// Creates a new builder-style object to manufacture [`PieChartAggregatedFieldWells`](crate::model::PieChartAggregatedFieldWells).
    pub fn builder() -> crate::model::pie_chart_aggregated_field_wells::Builder {
        crate::model::pie_chart_aggregated_field_wells::Builder::default()
    }
}

/// <p>A key performance indicator (KPI).</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/kpi.html">Using KPIs</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KpiVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration of a KPI visual.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::KpiConfiguration>,
    /// <p>The conditional formatting of a KPI visual.</p>
    #[doc(hidden)]
    pub conditional_formatting: std::option::Option<crate::model::KpiConditionalFormatting>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    #[doc(hidden)]
    pub column_hierarchies: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
}
impl KpiVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration of a KPI visual.</p>
    pub fn chart_configuration(&self) -> std::option::Option<&crate::model::KpiConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The conditional formatting of a KPI visual.</p>
    pub fn conditional_formatting(
        &self,
    ) -> std::option::Option<&crate::model::KpiConditionalFormatting> {
        self.conditional_formatting.as_ref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    pub fn column_hierarchies(&self) -> std::option::Option<&[crate::model::ColumnHierarchy]> {
        self.column_hierarchies.as_deref()
    }
}
/// See [`KpiVisual`](crate::model::KpiVisual).
pub mod kpi_visual {

    /// A builder for [`KpiVisual`](crate::model::KpiVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration: std::option::Option<crate::model::KpiConfiguration>,
        pub(crate) conditional_formatting:
            std::option::Option<crate::model::KpiConditionalFormatting>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        pub(crate) column_hierarchies:
            std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration of a KPI visual.</p>
        pub fn chart_configuration(mut self, input: crate::model::KpiConfiguration) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration of a KPI visual.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::KpiConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// <p>The conditional formatting of a KPI visual.</p>
        pub fn conditional_formatting(
            mut self,
            input: crate::model::KpiConditionalFormatting,
        ) -> Self {
            self.conditional_formatting = Some(input);
            self
        }
        /// <p>The conditional formatting of a KPI visual.</p>
        pub fn set_conditional_formatting(
            mut self,
            input: std::option::Option<crate::model::KpiConditionalFormatting>,
        ) -> Self {
            self.conditional_formatting = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Appends an item to `column_hierarchies`.
        ///
        /// To override the contents of this collection use [`set_column_hierarchies`](Self::set_column_hierarchies).
        ///
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn column_hierarchies(mut self, input: crate::model::ColumnHierarchy) -> Self {
            let mut v = self.column_hierarchies.unwrap_or_default();
            v.push(input);
            self.column_hierarchies = Some(v);
            self
        }
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn set_column_hierarchies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
        ) -> Self {
            self.column_hierarchies = input;
            self
        }
        /// Consumes the builder and constructs a [`KpiVisual`](crate::model::KpiVisual).
        pub fn build(self) -> crate::model::KpiVisual {
            crate::model::KpiVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                conditional_formatting: self.conditional_formatting,
                actions: self.actions,
                column_hierarchies: self.column_hierarchies,
            }
        }
    }
}
impl KpiVisual {
    /// Creates a new builder-style object to manufacture [`KpiVisual`](crate::model::KpiVisual).
    pub fn builder() -> crate::model::kpi_visual::Builder {
        crate::model::kpi_visual::Builder::default()
    }
}

/// <p>The conditional formatting of a KPI visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KpiConditionalFormatting {
    /// <p>The conditional formatting options of a KPI visual.</p>
    #[doc(hidden)]
    pub conditional_formatting_options:
        std::option::Option<std::vec::Vec<crate::model::KpiConditionalFormattingOption>>,
}
impl KpiConditionalFormatting {
    /// <p>The conditional formatting options of a KPI visual.</p>
    pub fn conditional_formatting_options(
        &self,
    ) -> std::option::Option<&[crate::model::KpiConditionalFormattingOption]> {
        self.conditional_formatting_options.as_deref()
    }
}
/// See [`KpiConditionalFormatting`](crate::model::KpiConditionalFormatting).
pub mod kpi_conditional_formatting {

    /// A builder for [`KpiConditionalFormatting`](crate::model::KpiConditionalFormatting).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) conditional_formatting_options:
            std::option::Option<std::vec::Vec<crate::model::KpiConditionalFormattingOption>>,
    }
    impl Builder {
        /// Appends an item to `conditional_formatting_options`.
        ///
        /// To override the contents of this collection use [`set_conditional_formatting_options`](Self::set_conditional_formatting_options).
        ///
        /// <p>The conditional formatting options of a KPI visual.</p>
        pub fn conditional_formatting_options(
            mut self,
            input: crate::model::KpiConditionalFormattingOption,
        ) -> Self {
            let mut v = self.conditional_formatting_options.unwrap_or_default();
            v.push(input);
            self.conditional_formatting_options = Some(v);
            self
        }
        /// <p>The conditional formatting options of a KPI visual.</p>
        pub fn set_conditional_formatting_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::KpiConditionalFormattingOption>>,
        ) -> Self {
            self.conditional_formatting_options = input;
            self
        }
        /// Consumes the builder and constructs a [`KpiConditionalFormatting`](crate::model::KpiConditionalFormatting).
        pub fn build(self) -> crate::model::KpiConditionalFormatting {
            crate::model::KpiConditionalFormatting {
                conditional_formatting_options: self.conditional_formatting_options,
            }
        }
    }
}
impl KpiConditionalFormatting {
    /// Creates a new builder-style object to manufacture [`KpiConditionalFormatting`](crate::model::KpiConditionalFormatting).
    pub fn builder() -> crate::model::kpi_conditional_formatting::Builder {
        crate::model::kpi_conditional_formatting::Builder::default()
    }
}

/// <p>The conditional formatting options of a KPI visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KpiConditionalFormattingOption {
    /// <p>The conditional formatting for the primary value of a KPI visual.</p>
    #[doc(hidden)]
    pub primary_value: std::option::Option<crate::model::KpiPrimaryValueConditionalFormatting>,
    /// <p>The conditional formatting for the progress bar of a KPI visual.</p>
    #[doc(hidden)]
    pub progress_bar: std::option::Option<crate::model::KpiProgressBarConditionalFormatting>,
}
impl KpiConditionalFormattingOption {
    /// <p>The conditional formatting for the primary value of a KPI visual.</p>
    pub fn primary_value(
        &self,
    ) -> std::option::Option<&crate::model::KpiPrimaryValueConditionalFormatting> {
        self.primary_value.as_ref()
    }
    /// <p>The conditional formatting for the progress bar of a KPI visual.</p>
    pub fn progress_bar(
        &self,
    ) -> std::option::Option<&crate::model::KpiProgressBarConditionalFormatting> {
        self.progress_bar.as_ref()
    }
}
/// See [`KpiConditionalFormattingOption`](crate::model::KpiConditionalFormattingOption).
pub mod kpi_conditional_formatting_option {

    /// A builder for [`KpiConditionalFormattingOption`](crate::model::KpiConditionalFormattingOption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) primary_value:
            std::option::Option<crate::model::KpiPrimaryValueConditionalFormatting>,
        pub(crate) progress_bar:
            std::option::Option<crate::model::KpiProgressBarConditionalFormatting>,
    }
    impl Builder {
        /// <p>The conditional formatting for the primary value of a KPI visual.</p>
        pub fn primary_value(
            mut self,
            input: crate::model::KpiPrimaryValueConditionalFormatting,
        ) -> Self {
            self.primary_value = Some(input);
            self
        }
        /// <p>The conditional formatting for the primary value of a KPI visual.</p>
        pub fn set_primary_value(
            mut self,
            input: std::option::Option<crate::model::KpiPrimaryValueConditionalFormatting>,
        ) -> Self {
            self.primary_value = input;
            self
        }
        /// <p>The conditional formatting for the progress bar of a KPI visual.</p>
        pub fn progress_bar(
            mut self,
            input: crate::model::KpiProgressBarConditionalFormatting,
        ) -> Self {
            self.progress_bar = Some(input);
            self
        }
        /// <p>The conditional formatting for the progress bar of a KPI visual.</p>
        pub fn set_progress_bar(
            mut self,
            input: std::option::Option<crate::model::KpiProgressBarConditionalFormatting>,
        ) -> Self {
            self.progress_bar = input;
            self
        }
        /// Consumes the builder and constructs a [`KpiConditionalFormattingOption`](crate::model::KpiConditionalFormattingOption).
        pub fn build(self) -> crate::model::KpiConditionalFormattingOption {
            crate::model::KpiConditionalFormattingOption {
                primary_value: self.primary_value,
                progress_bar: self.progress_bar,
            }
        }
    }
}
impl KpiConditionalFormattingOption {
    /// Creates a new builder-style object to manufacture [`KpiConditionalFormattingOption`](crate::model::KpiConditionalFormattingOption).
    pub fn builder() -> crate::model::kpi_conditional_formatting_option::Builder {
        crate::model::kpi_conditional_formatting_option::Builder::default()
    }
}

/// <p>The conditional formatting for the progress bar of a KPI visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KpiProgressBarConditionalFormatting {
    /// <p>The conditional formatting of the progress bar's foreground color.</p>
    #[doc(hidden)]
    pub foreground_color: std::option::Option<crate::model::ConditionalFormattingColor>,
}
impl KpiProgressBarConditionalFormatting {
    /// <p>The conditional formatting of the progress bar's foreground color.</p>
    pub fn foreground_color(
        &self,
    ) -> std::option::Option<&crate::model::ConditionalFormattingColor> {
        self.foreground_color.as_ref()
    }
}
/// See [`KpiProgressBarConditionalFormatting`](crate::model::KpiProgressBarConditionalFormatting).
pub mod kpi_progress_bar_conditional_formatting {

    /// A builder for [`KpiProgressBarConditionalFormatting`](crate::model::KpiProgressBarConditionalFormatting).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) foreground_color: std::option::Option<crate::model::ConditionalFormattingColor>,
    }
    impl Builder {
        /// <p>The conditional formatting of the progress bar's foreground color.</p>
        pub fn foreground_color(mut self, input: crate::model::ConditionalFormattingColor) -> Self {
            self.foreground_color = Some(input);
            self
        }
        /// <p>The conditional formatting of the progress bar's foreground color.</p>
        pub fn set_foreground_color(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingColor>,
        ) -> Self {
            self.foreground_color = input;
            self
        }
        /// Consumes the builder and constructs a [`KpiProgressBarConditionalFormatting`](crate::model::KpiProgressBarConditionalFormatting).
        pub fn build(self) -> crate::model::KpiProgressBarConditionalFormatting {
            crate::model::KpiProgressBarConditionalFormatting {
                foreground_color: self.foreground_color,
            }
        }
    }
}
impl KpiProgressBarConditionalFormatting {
    /// Creates a new builder-style object to manufacture [`KpiProgressBarConditionalFormatting`](crate::model::KpiProgressBarConditionalFormatting).
    pub fn builder() -> crate::model::kpi_progress_bar_conditional_formatting::Builder {
        crate::model::kpi_progress_bar_conditional_formatting::Builder::default()
    }
}

/// <p>The conditional formatting for the primary value of a KPI visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KpiPrimaryValueConditionalFormatting {
    /// <p>The conditional formatting of the primary value's text color.</p>
    #[doc(hidden)]
    pub text_color: std::option::Option<crate::model::ConditionalFormattingColor>,
    /// <p>The conditional formatting of the primary value's icon.</p>
    #[doc(hidden)]
    pub icon: std::option::Option<crate::model::ConditionalFormattingIcon>,
}
impl KpiPrimaryValueConditionalFormatting {
    /// <p>The conditional formatting of the primary value's text color.</p>
    pub fn text_color(&self) -> std::option::Option<&crate::model::ConditionalFormattingColor> {
        self.text_color.as_ref()
    }
    /// <p>The conditional formatting of the primary value's icon.</p>
    pub fn icon(&self) -> std::option::Option<&crate::model::ConditionalFormattingIcon> {
        self.icon.as_ref()
    }
}
/// See [`KpiPrimaryValueConditionalFormatting`](crate::model::KpiPrimaryValueConditionalFormatting).
pub mod kpi_primary_value_conditional_formatting {

    /// A builder for [`KpiPrimaryValueConditionalFormatting`](crate::model::KpiPrimaryValueConditionalFormatting).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) text_color: std::option::Option<crate::model::ConditionalFormattingColor>,
        pub(crate) icon: std::option::Option<crate::model::ConditionalFormattingIcon>,
    }
    impl Builder {
        /// <p>The conditional formatting of the primary value's text color.</p>
        pub fn text_color(mut self, input: crate::model::ConditionalFormattingColor) -> Self {
            self.text_color = Some(input);
            self
        }
        /// <p>The conditional formatting of the primary value's text color.</p>
        pub fn set_text_color(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingColor>,
        ) -> Self {
            self.text_color = input;
            self
        }
        /// <p>The conditional formatting of the primary value's icon.</p>
        pub fn icon(mut self, input: crate::model::ConditionalFormattingIcon) -> Self {
            self.icon = Some(input);
            self
        }
        /// <p>The conditional formatting of the primary value's icon.</p>
        pub fn set_icon(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingIcon>,
        ) -> Self {
            self.icon = input;
            self
        }
        /// Consumes the builder and constructs a [`KpiPrimaryValueConditionalFormatting`](crate::model::KpiPrimaryValueConditionalFormatting).
        pub fn build(self) -> crate::model::KpiPrimaryValueConditionalFormatting {
            crate::model::KpiPrimaryValueConditionalFormatting {
                text_color: self.text_color,
                icon: self.icon,
            }
        }
    }
}
impl KpiPrimaryValueConditionalFormatting {
    /// Creates a new builder-style object to manufacture [`KpiPrimaryValueConditionalFormatting`](crate::model::KpiPrimaryValueConditionalFormatting).
    pub fn builder() -> crate::model::kpi_primary_value_conditional_formatting::Builder {
        crate::model::kpi_primary_value_conditional_formatting::Builder::default()
    }
}

/// <p>The configuration of a KPI visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KpiConfiguration {
    /// <p>The field well configuration of a KPI visual.</p>
    #[doc(hidden)]
    pub field_wells: std::option::Option<crate::model::KpiFieldWells>,
    /// <p>The sort configuration of a KPI visual.</p>
    #[doc(hidden)]
    pub sort_configuration: std::option::Option<crate::model::KpiSortConfiguration>,
    /// <p>The options that determine the presentation of a KPI visual.</p>
    #[doc(hidden)]
    pub kpi_options: std::option::Option<crate::model::KpiOptions>,
}
impl KpiConfiguration {
    /// <p>The field well configuration of a KPI visual.</p>
    pub fn field_wells(&self) -> std::option::Option<&crate::model::KpiFieldWells> {
        self.field_wells.as_ref()
    }
    /// <p>The sort configuration of a KPI visual.</p>
    pub fn sort_configuration(&self) -> std::option::Option<&crate::model::KpiSortConfiguration> {
        self.sort_configuration.as_ref()
    }
    /// <p>The options that determine the presentation of a KPI visual.</p>
    pub fn kpi_options(&self) -> std::option::Option<&crate::model::KpiOptions> {
        self.kpi_options.as_ref()
    }
}
/// See [`KpiConfiguration`](crate::model::KpiConfiguration).
pub mod kpi_configuration {

    /// A builder for [`KpiConfiguration`](crate::model::KpiConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_wells: std::option::Option<crate::model::KpiFieldWells>,
        pub(crate) sort_configuration: std::option::Option<crate::model::KpiSortConfiguration>,
        pub(crate) kpi_options: std::option::Option<crate::model::KpiOptions>,
    }
    impl Builder {
        /// <p>The field well configuration of a KPI visual.</p>
        pub fn field_wells(mut self, input: crate::model::KpiFieldWells) -> Self {
            self.field_wells = Some(input);
            self
        }
        /// <p>The field well configuration of a KPI visual.</p>
        pub fn set_field_wells(
            mut self,
            input: std::option::Option<crate::model::KpiFieldWells>,
        ) -> Self {
            self.field_wells = input;
            self
        }
        /// <p>The sort configuration of a KPI visual.</p>
        pub fn sort_configuration(mut self, input: crate::model::KpiSortConfiguration) -> Self {
            self.sort_configuration = Some(input);
            self
        }
        /// <p>The sort configuration of a KPI visual.</p>
        pub fn set_sort_configuration(
            mut self,
            input: std::option::Option<crate::model::KpiSortConfiguration>,
        ) -> Self {
            self.sort_configuration = input;
            self
        }
        /// <p>The options that determine the presentation of a KPI visual.</p>
        pub fn kpi_options(mut self, input: crate::model::KpiOptions) -> Self {
            self.kpi_options = Some(input);
            self
        }
        /// <p>The options that determine the presentation of a KPI visual.</p>
        pub fn set_kpi_options(
            mut self,
            input: std::option::Option<crate::model::KpiOptions>,
        ) -> Self {
            self.kpi_options = input;
            self
        }
        /// Consumes the builder and constructs a [`KpiConfiguration`](crate::model::KpiConfiguration).
        pub fn build(self) -> crate::model::KpiConfiguration {
            crate::model::KpiConfiguration {
                field_wells: self.field_wells,
                sort_configuration: self.sort_configuration,
                kpi_options: self.kpi_options,
            }
        }
    }
}
impl KpiConfiguration {
    /// Creates a new builder-style object to manufacture [`KpiConfiguration`](crate::model::KpiConfiguration).
    pub fn builder() -> crate::model::kpi_configuration::Builder {
        crate::model::kpi_configuration::Builder::default()
    }
}

/// <p>The options that determine the presentation of a KPI visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KpiOptions {
    /// <p>The options that determine the presentation of the progress bar of a KPI visual.</p>
    #[doc(hidden)]
    pub progress_bar: std::option::Option<crate::model::ProgressBarOptions>,
    /// <p>The options that determine the presentation of trend arrows in a KPI visual.</p>
    #[doc(hidden)]
    pub trend_arrows: std::option::Option<crate::model::TrendArrowOptions>,
    /// <p>The options that determine the presentation of the secondary value of a KPI visual.</p>
    #[doc(hidden)]
    pub secondary_value: std::option::Option<crate::model::SecondaryValueOptions>,
    /// <p>The comparison configuration of a KPI visual.</p>
    #[doc(hidden)]
    pub comparison: std::option::Option<crate::model::ComparisonConfiguration>,
    /// <p>The options that determine the primary value display type.</p>
    #[doc(hidden)]
    pub primary_value_display_type: std::option::Option<crate::model::PrimaryValueDisplayType>,
    /// <p>The options that determine the primary value font configuration.</p>
    #[doc(hidden)]
    pub primary_value_font_configuration: std::option::Option<crate::model::FontConfiguration>,
    /// <p>The options that determine the secondary value font configuration.</p>
    #[doc(hidden)]
    pub secondary_value_font_configuration: std::option::Option<crate::model::FontConfiguration>,
}
impl KpiOptions {
    /// <p>The options that determine the presentation of the progress bar of a KPI visual.</p>
    pub fn progress_bar(&self) -> std::option::Option<&crate::model::ProgressBarOptions> {
        self.progress_bar.as_ref()
    }
    /// <p>The options that determine the presentation of trend arrows in a KPI visual.</p>
    pub fn trend_arrows(&self) -> std::option::Option<&crate::model::TrendArrowOptions> {
        self.trend_arrows.as_ref()
    }
    /// <p>The options that determine the presentation of the secondary value of a KPI visual.</p>
    pub fn secondary_value(&self) -> std::option::Option<&crate::model::SecondaryValueOptions> {
        self.secondary_value.as_ref()
    }
    /// <p>The comparison configuration of a KPI visual.</p>
    pub fn comparison(&self) -> std::option::Option<&crate::model::ComparisonConfiguration> {
        self.comparison.as_ref()
    }
    /// <p>The options that determine the primary value display type.</p>
    pub fn primary_value_display_type(
        &self,
    ) -> std::option::Option<&crate::model::PrimaryValueDisplayType> {
        self.primary_value_display_type.as_ref()
    }
    /// <p>The options that determine the primary value font configuration.</p>
    pub fn primary_value_font_configuration(
        &self,
    ) -> std::option::Option<&crate::model::FontConfiguration> {
        self.primary_value_font_configuration.as_ref()
    }
    /// <p>The options that determine the secondary value font configuration.</p>
    pub fn secondary_value_font_configuration(
        &self,
    ) -> std::option::Option<&crate::model::FontConfiguration> {
        self.secondary_value_font_configuration.as_ref()
    }
}
/// See [`KpiOptions`](crate::model::KpiOptions).
pub mod kpi_options {

    /// A builder for [`KpiOptions`](crate::model::KpiOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) progress_bar: std::option::Option<crate::model::ProgressBarOptions>,
        pub(crate) trend_arrows: std::option::Option<crate::model::TrendArrowOptions>,
        pub(crate) secondary_value: std::option::Option<crate::model::SecondaryValueOptions>,
        pub(crate) comparison: std::option::Option<crate::model::ComparisonConfiguration>,
        pub(crate) primary_value_display_type:
            std::option::Option<crate::model::PrimaryValueDisplayType>,
        pub(crate) primary_value_font_configuration:
            std::option::Option<crate::model::FontConfiguration>,
        pub(crate) secondary_value_font_configuration:
            std::option::Option<crate::model::FontConfiguration>,
    }
    impl Builder {
        /// <p>The options that determine the presentation of the progress bar of a KPI visual.</p>
        pub fn progress_bar(mut self, input: crate::model::ProgressBarOptions) -> Self {
            self.progress_bar = Some(input);
            self
        }
        /// <p>The options that determine the presentation of the progress bar of a KPI visual.</p>
        pub fn set_progress_bar(
            mut self,
            input: std::option::Option<crate::model::ProgressBarOptions>,
        ) -> Self {
            self.progress_bar = input;
            self
        }
        /// <p>The options that determine the presentation of trend arrows in a KPI visual.</p>
        pub fn trend_arrows(mut self, input: crate::model::TrendArrowOptions) -> Self {
            self.trend_arrows = Some(input);
            self
        }
        /// <p>The options that determine the presentation of trend arrows in a KPI visual.</p>
        pub fn set_trend_arrows(
            mut self,
            input: std::option::Option<crate::model::TrendArrowOptions>,
        ) -> Self {
            self.trend_arrows = input;
            self
        }
        /// <p>The options that determine the presentation of the secondary value of a KPI visual.</p>
        pub fn secondary_value(mut self, input: crate::model::SecondaryValueOptions) -> Self {
            self.secondary_value = Some(input);
            self
        }
        /// <p>The options that determine the presentation of the secondary value of a KPI visual.</p>
        pub fn set_secondary_value(
            mut self,
            input: std::option::Option<crate::model::SecondaryValueOptions>,
        ) -> Self {
            self.secondary_value = input;
            self
        }
        /// <p>The comparison configuration of a KPI visual.</p>
        pub fn comparison(mut self, input: crate::model::ComparisonConfiguration) -> Self {
            self.comparison = Some(input);
            self
        }
        /// <p>The comparison configuration of a KPI visual.</p>
        pub fn set_comparison(
            mut self,
            input: std::option::Option<crate::model::ComparisonConfiguration>,
        ) -> Self {
            self.comparison = input;
            self
        }
        /// <p>The options that determine the primary value display type.</p>
        pub fn primary_value_display_type(
            mut self,
            input: crate::model::PrimaryValueDisplayType,
        ) -> Self {
            self.primary_value_display_type = Some(input);
            self
        }
        /// <p>The options that determine the primary value display type.</p>
        pub fn set_primary_value_display_type(
            mut self,
            input: std::option::Option<crate::model::PrimaryValueDisplayType>,
        ) -> Self {
            self.primary_value_display_type = input;
            self
        }
        /// <p>The options that determine the primary value font configuration.</p>
        pub fn primary_value_font_configuration(
            mut self,
            input: crate::model::FontConfiguration,
        ) -> Self {
            self.primary_value_font_configuration = Some(input);
            self
        }
        /// <p>The options that determine the primary value font configuration.</p>
        pub fn set_primary_value_font_configuration(
            mut self,
            input: std::option::Option<crate::model::FontConfiguration>,
        ) -> Self {
            self.primary_value_font_configuration = input;
            self
        }
        /// <p>The options that determine the secondary value font configuration.</p>
        pub fn secondary_value_font_configuration(
            mut self,
            input: crate::model::FontConfiguration,
        ) -> Self {
            self.secondary_value_font_configuration = Some(input);
            self
        }
        /// <p>The options that determine the secondary value font configuration.</p>
        pub fn set_secondary_value_font_configuration(
            mut self,
            input: std::option::Option<crate::model::FontConfiguration>,
        ) -> Self {
            self.secondary_value_font_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`KpiOptions`](crate::model::KpiOptions).
        pub fn build(self) -> crate::model::KpiOptions {
            crate::model::KpiOptions {
                progress_bar: self.progress_bar,
                trend_arrows: self.trend_arrows,
                secondary_value: self.secondary_value,
                comparison: self.comparison,
                primary_value_display_type: self.primary_value_display_type,
                primary_value_font_configuration: self.primary_value_font_configuration,
                secondary_value_font_configuration: self.secondary_value_font_configuration,
            }
        }
    }
}
impl KpiOptions {
    /// Creates a new builder-style object to manufacture [`KpiOptions`](crate::model::KpiOptions).
    pub fn builder() -> crate::model::kpi_options::Builder {
        crate::model::kpi_options::Builder::default()
    }
}

/// <p>The options that determine the presentation of the secondary value of a KPI visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SecondaryValueOptions {
    /// <p>Determines the visibility of the secondary value.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
}
impl SecondaryValueOptions {
    /// <p>Determines the visibility of the secondary value.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
}
/// See [`SecondaryValueOptions`](crate::model::SecondaryValueOptions).
pub mod secondary_value_options {

    /// A builder for [`SecondaryValueOptions`](crate::model::SecondaryValueOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>Determines the visibility of the secondary value.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>Determines the visibility of the secondary value.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`SecondaryValueOptions`](crate::model::SecondaryValueOptions).
        pub fn build(self) -> crate::model::SecondaryValueOptions {
            crate::model::SecondaryValueOptions {
                visibility: self.visibility,
            }
        }
    }
}
impl SecondaryValueOptions {
    /// Creates a new builder-style object to manufacture [`SecondaryValueOptions`](crate::model::SecondaryValueOptions).
    pub fn builder() -> crate::model::secondary_value_options::Builder {
        crate::model::secondary_value_options::Builder::default()
    }
}

/// <p>The options that determine the presentation of trend arrows in a KPI visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TrendArrowOptions {
    /// <p>The visibility of the trend arrows.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
}
impl TrendArrowOptions {
    /// <p>The visibility of the trend arrows.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
}
/// See [`TrendArrowOptions`](crate::model::TrendArrowOptions).
pub mod trend_arrow_options {

    /// A builder for [`TrendArrowOptions`](crate::model::TrendArrowOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>The visibility of the trend arrows.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility of the trend arrows.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`TrendArrowOptions`](crate::model::TrendArrowOptions).
        pub fn build(self) -> crate::model::TrendArrowOptions {
            crate::model::TrendArrowOptions {
                visibility: self.visibility,
            }
        }
    }
}
impl TrendArrowOptions {
    /// Creates a new builder-style object to manufacture [`TrendArrowOptions`](crate::model::TrendArrowOptions).
    pub fn builder() -> crate::model::trend_arrow_options::Builder {
        crate::model::trend_arrow_options::Builder::default()
    }
}

/// <p>The options that determine the presentation of the progress bar of a KPI visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProgressBarOptions {
    /// <p>The visibility of the progress bar.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
}
impl ProgressBarOptions {
    /// <p>The visibility of the progress bar.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
}
/// See [`ProgressBarOptions`](crate::model::ProgressBarOptions).
pub mod progress_bar_options {

    /// A builder for [`ProgressBarOptions`](crate::model::ProgressBarOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>The visibility of the progress bar.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility of the progress bar.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`ProgressBarOptions`](crate::model::ProgressBarOptions).
        pub fn build(self) -> crate::model::ProgressBarOptions {
            crate::model::ProgressBarOptions {
                visibility: self.visibility,
            }
        }
    }
}
impl ProgressBarOptions {
    /// Creates a new builder-style object to manufacture [`ProgressBarOptions`](crate::model::ProgressBarOptions).
    pub fn builder() -> crate::model::progress_bar_options::Builder {
        crate::model::progress_bar_options::Builder::default()
    }
}

/// <p>The sort configuration of a KPI visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KpiSortConfiguration {
    /// <p>The sort configuration of the trend group fields.</p>
    #[doc(hidden)]
    pub trend_group_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
}
impl KpiSortConfiguration {
    /// <p>The sort configuration of the trend group fields.</p>
    pub fn trend_group_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.trend_group_sort.as_deref()
    }
}
/// See [`KpiSortConfiguration`](crate::model::KpiSortConfiguration).
pub mod kpi_sort_configuration {

    /// A builder for [`KpiSortConfiguration`](crate::model::KpiSortConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trend_group_sort:
            std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    }
    impl Builder {
        /// Appends an item to `trend_group_sort`.
        ///
        /// To override the contents of this collection use [`set_trend_group_sort`](Self::set_trend_group_sort).
        ///
        /// <p>The sort configuration of the trend group fields.</p>
        pub fn trend_group_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.trend_group_sort.unwrap_or_default();
            v.push(input);
            self.trend_group_sort = Some(v);
            self
        }
        /// <p>The sort configuration of the trend group fields.</p>
        pub fn set_trend_group_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.trend_group_sort = input;
            self
        }
        /// Consumes the builder and constructs a [`KpiSortConfiguration`](crate::model::KpiSortConfiguration).
        pub fn build(self) -> crate::model::KpiSortConfiguration {
            crate::model::KpiSortConfiguration {
                trend_group_sort: self.trend_group_sort,
            }
        }
    }
}
impl KpiSortConfiguration {
    /// Creates a new builder-style object to manufacture [`KpiSortConfiguration`](crate::model::KpiSortConfiguration).
    pub fn builder() -> crate::model::kpi_sort_configuration::Builder {
        crate::model::kpi_sort_configuration::Builder::default()
    }
}

/// <p>The field well configuration of a KPI visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KpiFieldWells {
    /// <p>The value field wells of a KPI visual.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    /// <p>The target value field wells of a KPI visual.</p>
    #[doc(hidden)]
    pub target_values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    /// <p>The trend group field wells of a KPI visual.</p>
    #[doc(hidden)]
    pub trend_groups: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
}
impl KpiFieldWells {
    /// <p>The value field wells of a KPI visual.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.values.as_deref()
    }
    /// <p>The target value field wells of a KPI visual.</p>
    pub fn target_values(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.target_values.as_deref()
    }
    /// <p>The trend group field wells of a KPI visual.</p>
    pub fn trend_groups(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.trend_groups.as_deref()
    }
}
/// See [`KpiFieldWells`](crate::model::KpiFieldWells).
pub mod kpi_field_wells {

    /// A builder for [`KpiFieldWells`](crate::model::KpiFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        pub(crate) target_values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        pub(crate) trend_groups: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    }
    impl Builder {
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The value field wells of a KPI visual.</p>
        pub fn values(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>The value field wells of a KPI visual.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Appends an item to `target_values`.
        ///
        /// To override the contents of this collection use [`set_target_values`](Self::set_target_values).
        ///
        /// <p>The target value field wells of a KPI visual.</p>
        pub fn target_values(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.target_values.unwrap_or_default();
            v.push(input);
            self.target_values = Some(v);
            self
        }
        /// <p>The target value field wells of a KPI visual.</p>
        pub fn set_target_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.target_values = input;
            self
        }
        /// Appends an item to `trend_groups`.
        ///
        /// To override the contents of this collection use [`set_trend_groups`](Self::set_trend_groups).
        ///
        /// <p>The trend group field wells of a KPI visual.</p>
        pub fn trend_groups(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.trend_groups.unwrap_or_default();
            v.push(input);
            self.trend_groups = Some(v);
            self
        }
        /// <p>The trend group field wells of a KPI visual.</p>
        pub fn set_trend_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.trend_groups = input;
            self
        }
        /// Consumes the builder and constructs a [`KpiFieldWells`](crate::model::KpiFieldWells).
        pub fn build(self) -> crate::model::KpiFieldWells {
            crate::model::KpiFieldWells {
                values: self.values,
                target_values: self.target_values,
                trend_groups: self.trend_groups,
            }
        }
    }
}
impl KpiFieldWells {
    /// Creates a new builder-style object to manufacture [`KpiFieldWells`](crate::model::KpiFieldWells).
    pub fn builder() -> crate::model::kpi_field_wells::Builder {
        crate::model::kpi_field_wells::Builder::default()
    }
}

/// <p>A bar chart.</p>
/// <p>The <code>BarChartVisual</code> structure describes a visual that is a member of the bar chart family. The following charts can be described using this structure:</p>
/// <ul>
/// <li> <p>Horizontal bar chart</p> </li>
/// <li> <p>Vertical bar chart</p> </li>
/// <li> <p>Horizontal stacked bar chart</p> </li>
/// <li> <p>Vertical stacked bar chart</p> </li>
/// <li> <p>Horizontal stacked 100% bar chart</p> </li>
/// <li> <p>Vertical stacked 100% bar chart</p> </li>
/// </ul>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/bar-charts.html">Using bar charts</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BarChartVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration settings of the visual.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::BarChartConfiguration>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    #[doc(hidden)]
    pub column_hierarchies: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
}
impl BarChartVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration settings of the visual.</p>
    pub fn chart_configuration(&self) -> std::option::Option<&crate::model::BarChartConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
    /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
    pub fn column_hierarchies(&self) -> std::option::Option<&[crate::model::ColumnHierarchy]> {
        self.column_hierarchies.as_deref()
    }
}
/// See [`BarChartVisual`](crate::model::BarChartVisual).
pub mod bar_chart_visual {

    /// A builder for [`BarChartVisual`](crate::model::BarChartVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration: std::option::Option<crate::model::BarChartConfiguration>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        pub(crate) column_hierarchies:
            std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn chart_configuration(mut self, input: crate::model::BarChartConfiguration) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::BarChartConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Appends an item to `column_hierarchies`.
        ///
        /// To override the contents of this collection use [`set_column_hierarchies`](Self::set_column_hierarchies).
        ///
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn column_hierarchies(mut self, input: crate::model::ColumnHierarchy) -> Self {
            let mut v = self.column_hierarchies.unwrap_or_default();
            v.push(input);
            self.column_hierarchies = Some(v);
            self
        }
        /// <p>The column hierarchy that is used during drill-downs and drill-ups.</p>
        pub fn set_column_hierarchies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnHierarchy>>,
        ) -> Self {
            self.column_hierarchies = input;
            self
        }
        /// Consumes the builder and constructs a [`BarChartVisual`](crate::model::BarChartVisual).
        pub fn build(self) -> crate::model::BarChartVisual {
            crate::model::BarChartVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                actions: self.actions,
                column_hierarchies: self.column_hierarchies,
            }
        }
    }
}
impl BarChartVisual {
    /// Creates a new builder-style object to manufacture [`BarChartVisual`](crate::model::BarChartVisual).
    pub fn builder() -> crate::model::bar_chart_visual::Builder {
        crate::model::bar_chart_visual::Builder::default()
    }
}

/// <p>The configuration of a <code>BarChartVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BarChartConfiguration {
    /// <p>The field wells of the visual.</p>
    #[doc(hidden)]
    pub field_wells: std::option::Option<crate::model::BarChartFieldWells>,
    /// <p>The sort configuration of a <code>BarChartVisual</code>.</p>
    #[doc(hidden)]
    pub sort_configuration: std::option::Option<crate::model::BarChartSortConfiguration>,
    /// <p>The orientation of the bars in a bar chart visual. There are two valid values in this structure:</p>
    /// <ul>
    /// <li> <p> <code>HORIZONTAL</code>: Used for charts that have horizontal bars. Visuals that use this value are horizontal bar charts, horizontal stacked bar charts, and horizontal stacked 100% bar charts.</p> </li>
    /// <li> <p> <code>VERTICAL</code>: Used for charts that have vertical bars. Visuals that use this value are vertical bar charts, vertical stacked bar charts, and vertical stacked 100% bar charts.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub orientation: std::option::Option<crate::model::BarChartOrientation>,
    /// <p>Determines the arrangement of the bars. The orientation and arrangement of bars determine the type of bar that is used in the visual.</p>
    #[doc(hidden)]
    pub bars_arrangement: std::option::Option<crate::model::BarsArrangement>,
    /// <p>The palette (chart color) display setup of the visual.</p>
    #[doc(hidden)]
    pub visual_palette: std::option::Option<crate::model::VisualPalette>,
    /// <p>The small multiples setup for the visual.</p>
    #[doc(hidden)]
    pub small_multiples_options: std::option::Option<crate::model::SmallMultiplesOptions>,
    /// <p>The label display options (grid line, range, scale, axis step) for bar chart category.</p>
    #[doc(hidden)]
    pub category_axis: std::option::Option<crate::model::AxisDisplayOptions>,
    /// <p>The label options (label text, label visibility and sort icon visibility) for a bar chart.</p>
    #[doc(hidden)]
    pub category_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The label display options (grid line, range, scale, axis step) for a bar chart value.</p>
    #[doc(hidden)]
    pub value_axis: std::option::Option<crate::model::AxisDisplayOptions>,
    /// <p>The label options (label text, label visibility and sort icon visibility) for a bar chart value.</p>
    #[doc(hidden)]
    pub value_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The label options (label text, label visibility and sort icon visibility) for a color that is used in a bar chart.</p>
    #[doc(hidden)]
    pub color_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
    /// <p>The legend display setup of the visual.</p>
    #[doc(hidden)]
    pub legend: std::option::Option<crate::model::LegendOptions>,
    /// <p>The options that determine if visual data labels are displayed.</p>
    #[doc(hidden)]
    pub data_labels: std::option::Option<crate::model::DataLabelOptions>,
    /// <p>The tooltip display setup of the visual.</p>
    #[doc(hidden)]
    pub tooltip: std::option::Option<crate::model::TooltipOptions>,
    /// <p>The reference line setup of the visual.</p>
    #[doc(hidden)]
    pub reference_lines: std::option::Option<std::vec::Vec<crate::model::ReferenceLine>>,
    /// <p>The contribution analysis (anomaly configuration) setup of the visual.</p>
    #[doc(hidden)]
    pub contribution_analysis_defaults:
        std::option::Option<std::vec::Vec<crate::model::ContributionAnalysisDefault>>,
}
impl BarChartConfiguration {
    /// <p>The field wells of the visual.</p>
    pub fn field_wells(&self) -> std::option::Option<&crate::model::BarChartFieldWells> {
        self.field_wells.as_ref()
    }
    /// <p>The sort configuration of a <code>BarChartVisual</code>.</p>
    pub fn sort_configuration(
        &self,
    ) -> std::option::Option<&crate::model::BarChartSortConfiguration> {
        self.sort_configuration.as_ref()
    }
    /// <p>The orientation of the bars in a bar chart visual. There are two valid values in this structure:</p>
    /// <ul>
    /// <li> <p> <code>HORIZONTAL</code>: Used for charts that have horizontal bars. Visuals that use this value are horizontal bar charts, horizontal stacked bar charts, and horizontal stacked 100% bar charts.</p> </li>
    /// <li> <p> <code>VERTICAL</code>: Used for charts that have vertical bars. Visuals that use this value are vertical bar charts, vertical stacked bar charts, and vertical stacked 100% bar charts.</p> </li>
    /// </ul>
    pub fn orientation(&self) -> std::option::Option<&crate::model::BarChartOrientation> {
        self.orientation.as_ref()
    }
    /// <p>Determines the arrangement of the bars. The orientation and arrangement of bars determine the type of bar that is used in the visual.</p>
    pub fn bars_arrangement(&self) -> std::option::Option<&crate::model::BarsArrangement> {
        self.bars_arrangement.as_ref()
    }
    /// <p>The palette (chart color) display setup of the visual.</p>
    pub fn visual_palette(&self) -> std::option::Option<&crate::model::VisualPalette> {
        self.visual_palette.as_ref()
    }
    /// <p>The small multiples setup for the visual.</p>
    pub fn small_multiples_options(
        &self,
    ) -> std::option::Option<&crate::model::SmallMultiplesOptions> {
        self.small_multiples_options.as_ref()
    }
    /// <p>The label display options (grid line, range, scale, axis step) for bar chart category.</p>
    pub fn category_axis(&self) -> std::option::Option<&crate::model::AxisDisplayOptions> {
        self.category_axis.as_ref()
    }
    /// <p>The label options (label text, label visibility and sort icon visibility) for a bar chart.</p>
    pub fn category_label_options(
        &self,
    ) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.category_label_options.as_ref()
    }
    /// <p>The label display options (grid line, range, scale, axis step) for a bar chart value.</p>
    pub fn value_axis(&self) -> std::option::Option<&crate::model::AxisDisplayOptions> {
        self.value_axis.as_ref()
    }
    /// <p>The label options (label text, label visibility and sort icon visibility) for a bar chart value.</p>
    pub fn value_label_options(&self) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.value_label_options.as_ref()
    }
    /// <p>The label options (label text, label visibility and sort icon visibility) for a color that is used in a bar chart.</p>
    pub fn color_label_options(&self) -> std::option::Option<&crate::model::ChartAxisLabelOptions> {
        self.color_label_options.as_ref()
    }
    /// <p>The legend display setup of the visual.</p>
    pub fn legend(&self) -> std::option::Option<&crate::model::LegendOptions> {
        self.legend.as_ref()
    }
    /// <p>The options that determine if visual data labels are displayed.</p>
    pub fn data_labels(&self) -> std::option::Option<&crate::model::DataLabelOptions> {
        self.data_labels.as_ref()
    }
    /// <p>The tooltip display setup of the visual.</p>
    pub fn tooltip(&self) -> std::option::Option<&crate::model::TooltipOptions> {
        self.tooltip.as_ref()
    }
    /// <p>The reference line setup of the visual.</p>
    pub fn reference_lines(&self) -> std::option::Option<&[crate::model::ReferenceLine]> {
        self.reference_lines.as_deref()
    }
    /// <p>The contribution analysis (anomaly configuration) setup of the visual.</p>
    pub fn contribution_analysis_defaults(
        &self,
    ) -> std::option::Option<&[crate::model::ContributionAnalysisDefault]> {
        self.contribution_analysis_defaults.as_deref()
    }
}
/// See [`BarChartConfiguration`](crate::model::BarChartConfiguration).
pub mod bar_chart_configuration {

    /// A builder for [`BarChartConfiguration`](crate::model::BarChartConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_wells: std::option::Option<crate::model::BarChartFieldWells>,
        pub(crate) sort_configuration: std::option::Option<crate::model::BarChartSortConfiguration>,
        pub(crate) orientation: std::option::Option<crate::model::BarChartOrientation>,
        pub(crate) bars_arrangement: std::option::Option<crate::model::BarsArrangement>,
        pub(crate) visual_palette: std::option::Option<crate::model::VisualPalette>,
        pub(crate) small_multiples_options:
            std::option::Option<crate::model::SmallMultiplesOptions>,
        pub(crate) category_axis: std::option::Option<crate::model::AxisDisplayOptions>,
        pub(crate) category_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) value_axis: std::option::Option<crate::model::AxisDisplayOptions>,
        pub(crate) value_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) color_label_options: std::option::Option<crate::model::ChartAxisLabelOptions>,
        pub(crate) legend: std::option::Option<crate::model::LegendOptions>,
        pub(crate) data_labels: std::option::Option<crate::model::DataLabelOptions>,
        pub(crate) tooltip: std::option::Option<crate::model::TooltipOptions>,
        pub(crate) reference_lines: std::option::Option<std::vec::Vec<crate::model::ReferenceLine>>,
        pub(crate) contribution_analysis_defaults:
            std::option::Option<std::vec::Vec<crate::model::ContributionAnalysisDefault>>,
    }
    impl Builder {
        /// <p>The field wells of the visual.</p>
        pub fn field_wells(mut self, input: crate::model::BarChartFieldWells) -> Self {
            self.field_wells = Some(input);
            self
        }
        /// <p>The field wells of the visual.</p>
        pub fn set_field_wells(
            mut self,
            input: std::option::Option<crate::model::BarChartFieldWells>,
        ) -> Self {
            self.field_wells = input;
            self
        }
        /// <p>The sort configuration of a <code>BarChartVisual</code>.</p>
        pub fn sort_configuration(
            mut self,
            input: crate::model::BarChartSortConfiguration,
        ) -> Self {
            self.sort_configuration = Some(input);
            self
        }
        /// <p>The sort configuration of a <code>BarChartVisual</code>.</p>
        pub fn set_sort_configuration(
            mut self,
            input: std::option::Option<crate::model::BarChartSortConfiguration>,
        ) -> Self {
            self.sort_configuration = input;
            self
        }
        /// <p>The orientation of the bars in a bar chart visual. There are two valid values in this structure:</p>
        /// <ul>
        /// <li> <p> <code>HORIZONTAL</code>: Used for charts that have horizontal bars. Visuals that use this value are horizontal bar charts, horizontal stacked bar charts, and horizontal stacked 100% bar charts.</p> </li>
        /// <li> <p> <code>VERTICAL</code>: Used for charts that have vertical bars. Visuals that use this value are vertical bar charts, vertical stacked bar charts, and vertical stacked 100% bar charts.</p> </li>
        /// </ul>
        pub fn orientation(mut self, input: crate::model::BarChartOrientation) -> Self {
            self.orientation = Some(input);
            self
        }
        /// <p>The orientation of the bars in a bar chart visual. There are two valid values in this structure:</p>
        /// <ul>
        /// <li> <p> <code>HORIZONTAL</code>: Used for charts that have horizontal bars. Visuals that use this value are horizontal bar charts, horizontal stacked bar charts, and horizontal stacked 100% bar charts.</p> </li>
        /// <li> <p> <code>VERTICAL</code>: Used for charts that have vertical bars. Visuals that use this value are vertical bar charts, vertical stacked bar charts, and vertical stacked 100% bar charts.</p> </li>
        /// </ul>
        pub fn set_orientation(
            mut self,
            input: std::option::Option<crate::model::BarChartOrientation>,
        ) -> Self {
            self.orientation = input;
            self
        }
        /// <p>Determines the arrangement of the bars. The orientation and arrangement of bars determine the type of bar that is used in the visual.</p>
        pub fn bars_arrangement(mut self, input: crate::model::BarsArrangement) -> Self {
            self.bars_arrangement = Some(input);
            self
        }
        /// <p>Determines the arrangement of the bars. The orientation and arrangement of bars determine the type of bar that is used in the visual.</p>
        pub fn set_bars_arrangement(
            mut self,
            input: std::option::Option<crate::model::BarsArrangement>,
        ) -> Self {
            self.bars_arrangement = input;
            self
        }
        /// <p>The palette (chart color) display setup of the visual.</p>
        pub fn visual_palette(mut self, input: crate::model::VisualPalette) -> Self {
            self.visual_palette = Some(input);
            self
        }
        /// <p>The palette (chart color) display setup of the visual.</p>
        pub fn set_visual_palette(
            mut self,
            input: std::option::Option<crate::model::VisualPalette>,
        ) -> Self {
            self.visual_palette = input;
            self
        }
        /// <p>The small multiples setup for the visual.</p>
        pub fn small_multiples_options(
            mut self,
            input: crate::model::SmallMultiplesOptions,
        ) -> Self {
            self.small_multiples_options = Some(input);
            self
        }
        /// <p>The small multiples setup for the visual.</p>
        pub fn set_small_multiples_options(
            mut self,
            input: std::option::Option<crate::model::SmallMultiplesOptions>,
        ) -> Self {
            self.small_multiples_options = input;
            self
        }
        /// <p>The label display options (grid line, range, scale, axis step) for bar chart category.</p>
        pub fn category_axis(mut self, input: crate::model::AxisDisplayOptions) -> Self {
            self.category_axis = Some(input);
            self
        }
        /// <p>The label display options (grid line, range, scale, axis step) for bar chart category.</p>
        pub fn set_category_axis(
            mut self,
            input: std::option::Option<crate::model::AxisDisplayOptions>,
        ) -> Self {
            self.category_axis = input;
            self
        }
        /// <p>The label options (label text, label visibility and sort icon visibility) for a bar chart.</p>
        pub fn category_label_options(
            mut self,
            input: crate::model::ChartAxisLabelOptions,
        ) -> Self {
            self.category_label_options = Some(input);
            self
        }
        /// <p>The label options (label text, label visibility and sort icon visibility) for a bar chart.</p>
        pub fn set_category_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.category_label_options = input;
            self
        }
        /// <p>The label display options (grid line, range, scale, axis step) for a bar chart value.</p>
        pub fn value_axis(mut self, input: crate::model::AxisDisplayOptions) -> Self {
            self.value_axis = Some(input);
            self
        }
        /// <p>The label display options (grid line, range, scale, axis step) for a bar chart value.</p>
        pub fn set_value_axis(
            mut self,
            input: std::option::Option<crate::model::AxisDisplayOptions>,
        ) -> Self {
            self.value_axis = input;
            self
        }
        /// <p>The label options (label text, label visibility and sort icon visibility) for a bar chart value.</p>
        pub fn value_label_options(mut self, input: crate::model::ChartAxisLabelOptions) -> Self {
            self.value_label_options = Some(input);
            self
        }
        /// <p>The label options (label text, label visibility and sort icon visibility) for a bar chart value.</p>
        pub fn set_value_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.value_label_options = input;
            self
        }
        /// <p>The label options (label text, label visibility and sort icon visibility) for a color that is used in a bar chart.</p>
        pub fn color_label_options(mut self, input: crate::model::ChartAxisLabelOptions) -> Self {
            self.color_label_options = Some(input);
            self
        }
        /// <p>The label options (label text, label visibility and sort icon visibility) for a color that is used in a bar chart.</p>
        pub fn set_color_label_options(
            mut self,
            input: std::option::Option<crate::model::ChartAxisLabelOptions>,
        ) -> Self {
            self.color_label_options = input;
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn legend(mut self, input: crate::model::LegendOptions) -> Self {
            self.legend = Some(input);
            self
        }
        /// <p>The legend display setup of the visual.</p>
        pub fn set_legend(
            mut self,
            input: std::option::Option<crate::model::LegendOptions>,
        ) -> Self {
            self.legend = input;
            self
        }
        /// <p>The options that determine if visual data labels are displayed.</p>
        pub fn data_labels(mut self, input: crate::model::DataLabelOptions) -> Self {
            self.data_labels = Some(input);
            self
        }
        /// <p>The options that determine if visual data labels are displayed.</p>
        pub fn set_data_labels(
            mut self,
            input: std::option::Option<crate::model::DataLabelOptions>,
        ) -> Self {
            self.data_labels = input;
            self
        }
        /// <p>The tooltip display setup of the visual.</p>
        pub fn tooltip(mut self, input: crate::model::TooltipOptions) -> Self {
            self.tooltip = Some(input);
            self
        }
        /// <p>The tooltip display setup of the visual.</p>
        pub fn set_tooltip(
            mut self,
            input: std::option::Option<crate::model::TooltipOptions>,
        ) -> Self {
            self.tooltip = input;
            self
        }
        /// Appends an item to `reference_lines`.
        ///
        /// To override the contents of this collection use [`set_reference_lines`](Self::set_reference_lines).
        ///
        /// <p>The reference line setup of the visual.</p>
        pub fn reference_lines(mut self, input: crate::model::ReferenceLine) -> Self {
            let mut v = self.reference_lines.unwrap_or_default();
            v.push(input);
            self.reference_lines = Some(v);
            self
        }
        /// <p>The reference line setup of the visual.</p>
        pub fn set_reference_lines(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReferenceLine>>,
        ) -> Self {
            self.reference_lines = input;
            self
        }
        /// Appends an item to `contribution_analysis_defaults`.
        ///
        /// To override the contents of this collection use [`set_contribution_analysis_defaults`](Self::set_contribution_analysis_defaults).
        ///
        /// <p>The contribution analysis (anomaly configuration) setup of the visual.</p>
        pub fn contribution_analysis_defaults(
            mut self,
            input: crate::model::ContributionAnalysisDefault,
        ) -> Self {
            let mut v = self.contribution_analysis_defaults.unwrap_or_default();
            v.push(input);
            self.contribution_analysis_defaults = Some(v);
            self
        }
        /// <p>The contribution analysis (anomaly configuration) setup of the visual.</p>
        pub fn set_contribution_analysis_defaults(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ContributionAnalysisDefault>>,
        ) -> Self {
            self.contribution_analysis_defaults = input;
            self
        }
        /// Consumes the builder and constructs a [`BarChartConfiguration`](crate::model::BarChartConfiguration).
        pub fn build(self) -> crate::model::BarChartConfiguration {
            crate::model::BarChartConfiguration {
                field_wells: self.field_wells,
                sort_configuration: self.sort_configuration,
                orientation: self.orientation,
                bars_arrangement: self.bars_arrangement,
                visual_palette: self.visual_palette,
                small_multiples_options: self.small_multiples_options,
                category_axis: self.category_axis,
                category_label_options: self.category_label_options,
                value_axis: self.value_axis,
                value_label_options: self.value_label_options,
                color_label_options: self.color_label_options,
                legend: self.legend,
                data_labels: self.data_labels,
                tooltip: self.tooltip,
                reference_lines: self.reference_lines,
                contribution_analysis_defaults: self.contribution_analysis_defaults,
            }
        }
    }
}
impl BarChartConfiguration {
    /// Creates a new builder-style object to manufacture [`BarChartConfiguration`](crate::model::BarChartConfiguration).
    pub fn builder() -> crate::model::bar_chart_configuration::Builder {
        crate::model::bar_chart_configuration::Builder::default()
    }
}

/// When writing a match expression against `BarChartOrientation`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let barchartorientation = unimplemented!();
/// match barchartorientation {
///     BarChartOrientation::Horizontal => { /* ... */ },
///     BarChartOrientation::Vertical => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `barchartorientation` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BarChartOrientation::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BarChartOrientation::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BarChartOrientation::NewFeature` is defined.
/// Specifically, when `barchartorientation` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BarChartOrientation::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BarChartOrientation {
    #[allow(missing_docs)] // documentation missing in model
    Horizontal,
    #[allow(missing_docs)] // documentation missing in model
    Vertical,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BarChartOrientation {
    fn from(s: &str) -> Self {
        match s {
            "HORIZONTAL" => BarChartOrientation::Horizontal,
            "VERTICAL" => BarChartOrientation::Vertical,
            other => {
                BarChartOrientation::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for BarChartOrientation {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BarChartOrientation::from(s))
    }
}
impl BarChartOrientation {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BarChartOrientation::Horizontal => "HORIZONTAL",
            BarChartOrientation::Vertical => "VERTICAL",
            BarChartOrientation::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HORIZONTAL", "VERTICAL"]
    }
}
impl AsRef<str> for BarChartOrientation {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>sort-configuration-description</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BarChartSortConfiguration {
    /// <p>The sort configuration of category fields.</p>
    #[doc(hidden)]
    pub category_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    /// <p>The limit on the number of categories displayed in a bar chart.</p>
    #[doc(hidden)]
    pub category_items_limit: std::option::Option<crate::model::ItemsLimitConfiguration>,
    /// <p>The sort configuration of color fields in a bar chart.</p>
    #[doc(hidden)]
    pub color_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    /// <p>The limit on the number of values displayed in a bar chart.</p>
    #[doc(hidden)]
    pub color_items_limit: std::option::Option<crate::model::ItemsLimitConfiguration>,
    /// <p>The sort configuration of the small multiples field.</p>
    #[doc(hidden)]
    pub small_multiples_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    /// <p>The limit on the number of small multiples panels that are displayed.</p>
    #[doc(hidden)]
    pub small_multiples_limit_configuration:
        std::option::Option<crate::model::ItemsLimitConfiguration>,
}
impl BarChartSortConfiguration {
    /// <p>The sort configuration of category fields.</p>
    pub fn category_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.category_sort.as_deref()
    }
    /// <p>The limit on the number of categories displayed in a bar chart.</p>
    pub fn category_items_limit(
        &self,
    ) -> std::option::Option<&crate::model::ItemsLimitConfiguration> {
        self.category_items_limit.as_ref()
    }
    /// <p>The sort configuration of color fields in a bar chart.</p>
    pub fn color_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.color_sort.as_deref()
    }
    /// <p>The limit on the number of values displayed in a bar chart.</p>
    pub fn color_items_limit(&self) -> std::option::Option<&crate::model::ItemsLimitConfiguration> {
        self.color_items_limit.as_ref()
    }
    /// <p>The sort configuration of the small multiples field.</p>
    pub fn small_multiples_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.small_multiples_sort.as_deref()
    }
    /// <p>The limit on the number of small multiples panels that are displayed.</p>
    pub fn small_multiples_limit_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ItemsLimitConfiguration> {
        self.small_multiples_limit_configuration.as_ref()
    }
}
/// See [`BarChartSortConfiguration`](crate::model::BarChartSortConfiguration).
pub mod bar_chart_sort_configuration {

    /// A builder for [`BarChartSortConfiguration`](crate::model::BarChartSortConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category_sort:
            std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        pub(crate) category_items_limit: std::option::Option<crate::model::ItemsLimitConfiguration>,
        pub(crate) color_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        pub(crate) color_items_limit: std::option::Option<crate::model::ItemsLimitConfiguration>,
        pub(crate) small_multiples_sort:
            std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        pub(crate) small_multiples_limit_configuration:
            std::option::Option<crate::model::ItemsLimitConfiguration>,
    }
    impl Builder {
        /// Appends an item to `category_sort`.
        ///
        /// To override the contents of this collection use [`set_category_sort`](Self::set_category_sort).
        ///
        /// <p>The sort configuration of category fields.</p>
        pub fn category_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.category_sort.unwrap_or_default();
            v.push(input);
            self.category_sort = Some(v);
            self
        }
        /// <p>The sort configuration of category fields.</p>
        pub fn set_category_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.category_sort = input;
            self
        }
        /// <p>The limit on the number of categories displayed in a bar chart.</p>
        pub fn category_items_limit(
            mut self,
            input: crate::model::ItemsLimitConfiguration,
        ) -> Self {
            self.category_items_limit = Some(input);
            self
        }
        /// <p>The limit on the number of categories displayed in a bar chart.</p>
        pub fn set_category_items_limit(
            mut self,
            input: std::option::Option<crate::model::ItemsLimitConfiguration>,
        ) -> Self {
            self.category_items_limit = input;
            self
        }
        /// Appends an item to `color_sort`.
        ///
        /// To override the contents of this collection use [`set_color_sort`](Self::set_color_sort).
        ///
        /// <p>The sort configuration of color fields in a bar chart.</p>
        pub fn color_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.color_sort.unwrap_or_default();
            v.push(input);
            self.color_sort = Some(v);
            self
        }
        /// <p>The sort configuration of color fields in a bar chart.</p>
        pub fn set_color_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.color_sort = input;
            self
        }
        /// <p>The limit on the number of values displayed in a bar chart.</p>
        pub fn color_items_limit(mut self, input: crate::model::ItemsLimitConfiguration) -> Self {
            self.color_items_limit = Some(input);
            self
        }
        /// <p>The limit on the number of values displayed in a bar chart.</p>
        pub fn set_color_items_limit(
            mut self,
            input: std::option::Option<crate::model::ItemsLimitConfiguration>,
        ) -> Self {
            self.color_items_limit = input;
            self
        }
        /// Appends an item to `small_multiples_sort`.
        ///
        /// To override the contents of this collection use [`set_small_multiples_sort`](Self::set_small_multiples_sort).
        ///
        /// <p>The sort configuration of the small multiples field.</p>
        pub fn small_multiples_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.small_multiples_sort.unwrap_or_default();
            v.push(input);
            self.small_multiples_sort = Some(v);
            self
        }
        /// <p>The sort configuration of the small multiples field.</p>
        pub fn set_small_multiples_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.small_multiples_sort = input;
            self
        }
        /// <p>The limit on the number of small multiples panels that are displayed.</p>
        pub fn small_multiples_limit_configuration(
            mut self,
            input: crate::model::ItemsLimitConfiguration,
        ) -> Self {
            self.small_multiples_limit_configuration = Some(input);
            self
        }
        /// <p>The limit on the number of small multiples panels that are displayed.</p>
        pub fn set_small_multiples_limit_configuration(
            mut self,
            input: std::option::Option<crate::model::ItemsLimitConfiguration>,
        ) -> Self {
            self.small_multiples_limit_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`BarChartSortConfiguration`](crate::model::BarChartSortConfiguration).
        pub fn build(self) -> crate::model::BarChartSortConfiguration {
            crate::model::BarChartSortConfiguration {
                category_sort: self.category_sort,
                category_items_limit: self.category_items_limit,
                color_sort: self.color_sort,
                color_items_limit: self.color_items_limit,
                small_multiples_sort: self.small_multiples_sort,
                small_multiples_limit_configuration: self.small_multiples_limit_configuration,
            }
        }
    }
}
impl BarChartSortConfiguration {
    /// Creates a new builder-style object to manufacture [`BarChartSortConfiguration`](crate::model::BarChartSortConfiguration).
    pub fn builder() -> crate::model::bar_chart_sort_configuration::Builder {
        crate::model::bar_chart_sort_configuration::Builder::default()
    }
}

/// <p>The field wells of a <code>BarChartVisual</code>.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BarChartFieldWells {
    /// <p>The aggregated field wells of a bar chart.</p>
    #[doc(hidden)]
    pub bar_chart_aggregated_field_wells:
        std::option::Option<crate::model::BarChartAggregatedFieldWells>,
}
impl BarChartFieldWells {
    /// <p>The aggregated field wells of a bar chart.</p>
    pub fn bar_chart_aggregated_field_wells(
        &self,
    ) -> std::option::Option<&crate::model::BarChartAggregatedFieldWells> {
        self.bar_chart_aggregated_field_wells.as_ref()
    }
}
/// See [`BarChartFieldWells`](crate::model::BarChartFieldWells).
pub mod bar_chart_field_wells {

    /// A builder for [`BarChartFieldWells`](crate::model::BarChartFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bar_chart_aggregated_field_wells:
            std::option::Option<crate::model::BarChartAggregatedFieldWells>,
    }
    impl Builder {
        /// <p>The aggregated field wells of a bar chart.</p>
        pub fn bar_chart_aggregated_field_wells(
            mut self,
            input: crate::model::BarChartAggregatedFieldWells,
        ) -> Self {
            self.bar_chart_aggregated_field_wells = Some(input);
            self
        }
        /// <p>The aggregated field wells of a bar chart.</p>
        pub fn set_bar_chart_aggregated_field_wells(
            mut self,
            input: std::option::Option<crate::model::BarChartAggregatedFieldWells>,
        ) -> Self {
            self.bar_chart_aggregated_field_wells = input;
            self
        }
        /// Consumes the builder and constructs a [`BarChartFieldWells`](crate::model::BarChartFieldWells).
        pub fn build(self) -> crate::model::BarChartFieldWells {
            crate::model::BarChartFieldWells {
                bar_chart_aggregated_field_wells: self.bar_chart_aggregated_field_wells,
            }
        }
    }
}
impl BarChartFieldWells {
    /// Creates a new builder-style object to manufacture [`BarChartFieldWells`](crate::model::BarChartFieldWells).
    pub fn builder() -> crate::model::bar_chart_field_wells::Builder {
        crate::model::bar_chart_field_wells::Builder::default()
    }
}

/// <p>The aggregated field wells of a bar chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BarChartAggregatedFieldWells {
    /// <p>The category (y-axis) field well of a bar chart.</p>
    #[doc(hidden)]
    pub category: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The value field wells of a bar chart. Values are aggregated by category.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    /// <p>The color (group/color) field well of a bar chart.</p>
    #[doc(hidden)]
    pub colors: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The small multiples field well of a bar chart.</p>
    #[doc(hidden)]
    pub small_multiples: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
}
impl BarChartAggregatedFieldWells {
    /// <p>The category (y-axis) field well of a bar chart.</p>
    pub fn category(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.category.as_deref()
    }
    /// <p>The value field wells of a bar chart. Values are aggregated by category.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.values.as_deref()
    }
    /// <p>The color (group/color) field well of a bar chart.</p>
    pub fn colors(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.colors.as_deref()
    }
    /// <p>The small multiples field well of a bar chart.</p>
    pub fn small_multiples(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.small_multiples.as_deref()
    }
}
/// See [`BarChartAggregatedFieldWells`](crate::model::BarChartAggregatedFieldWells).
pub mod bar_chart_aggregated_field_wells {

    /// A builder for [`BarChartAggregatedFieldWells`](crate::model::BarChartAggregatedFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        pub(crate) colors: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) small_multiples:
            std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    }
    impl Builder {
        /// Appends an item to `category`.
        ///
        /// To override the contents of this collection use [`set_category`](Self::set_category).
        ///
        /// <p>The category (y-axis) field well of a bar chart.</p>
        pub fn category(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.category.unwrap_or_default();
            v.push(input);
            self.category = Some(v);
            self
        }
        /// <p>The category (y-axis) field well of a bar chart.</p>
        pub fn set_category(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.category = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The value field wells of a bar chart. Values are aggregated by category.</p>
        pub fn values(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>The value field wells of a bar chart. Values are aggregated by category.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Appends an item to `colors`.
        ///
        /// To override the contents of this collection use [`set_colors`](Self::set_colors).
        ///
        /// <p>The color (group/color) field well of a bar chart.</p>
        pub fn colors(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.colors.unwrap_or_default();
            v.push(input);
            self.colors = Some(v);
            self
        }
        /// <p>The color (group/color) field well of a bar chart.</p>
        pub fn set_colors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.colors = input;
            self
        }
        /// Appends an item to `small_multiples`.
        ///
        /// To override the contents of this collection use [`set_small_multiples`](Self::set_small_multiples).
        ///
        /// <p>The small multiples field well of a bar chart.</p>
        pub fn small_multiples(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.small_multiples.unwrap_or_default();
            v.push(input);
            self.small_multiples = Some(v);
            self
        }
        /// <p>The small multiples field well of a bar chart.</p>
        pub fn set_small_multiples(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.small_multiples = input;
            self
        }
        /// Consumes the builder and constructs a [`BarChartAggregatedFieldWells`](crate::model::BarChartAggregatedFieldWells).
        pub fn build(self) -> crate::model::BarChartAggregatedFieldWells {
            crate::model::BarChartAggregatedFieldWells {
                category: self.category,
                values: self.values,
                colors: self.colors,
                small_multiples: self.small_multiples,
            }
        }
    }
}
impl BarChartAggregatedFieldWells {
    /// Creates a new builder-style object to manufacture [`BarChartAggregatedFieldWells`](crate::model::BarChartAggregatedFieldWells).
    pub fn builder() -> crate::model::bar_chart_aggregated_field_wells::Builder {
        crate::model::bar_chart_aggregated_field_wells::Builder::default()
    }
}

/// <p>A pivot table.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/pivot-table.html">Using pivot tables</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PivotTableVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration settings of the visual.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::PivotTableConfiguration>,
    /// <p>The conditional formatting for a <code>PivotTableVisual</code>.</p>
    #[doc(hidden)]
    pub conditional_formatting: std::option::Option<crate::model::PivotTableConditionalFormatting>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
}
impl PivotTableVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration settings of the visual.</p>
    pub fn chart_configuration(
        &self,
    ) -> std::option::Option<&crate::model::PivotTableConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The conditional formatting for a <code>PivotTableVisual</code>.</p>
    pub fn conditional_formatting(
        &self,
    ) -> std::option::Option<&crate::model::PivotTableConditionalFormatting> {
        self.conditional_formatting.as_ref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
}
/// See [`PivotTableVisual`](crate::model::PivotTableVisual).
pub mod pivot_table_visual {

    /// A builder for [`PivotTableVisual`](crate::model::PivotTableVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration: std::option::Option<crate::model::PivotTableConfiguration>,
        pub(crate) conditional_formatting:
            std::option::Option<crate::model::PivotTableConditionalFormatting>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn chart_configuration(mut self, input: crate::model::PivotTableConfiguration) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::PivotTableConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// <p>The conditional formatting for a <code>PivotTableVisual</code>.</p>
        pub fn conditional_formatting(
            mut self,
            input: crate::model::PivotTableConditionalFormatting,
        ) -> Self {
            self.conditional_formatting = Some(input);
            self
        }
        /// <p>The conditional formatting for a <code>PivotTableVisual</code>.</p>
        pub fn set_conditional_formatting(
            mut self,
            input: std::option::Option<crate::model::PivotTableConditionalFormatting>,
        ) -> Self {
            self.conditional_formatting = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Consumes the builder and constructs a [`PivotTableVisual`](crate::model::PivotTableVisual).
        pub fn build(self) -> crate::model::PivotTableVisual {
            crate::model::PivotTableVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                conditional_formatting: self.conditional_formatting,
                actions: self.actions,
            }
        }
    }
}
impl PivotTableVisual {
    /// Creates a new builder-style object to manufacture [`PivotTableVisual`](crate::model::PivotTableVisual).
    pub fn builder() -> crate::model::pivot_table_visual::Builder {
        crate::model::pivot_table_visual::Builder::default()
    }
}

/// <p>The conditional formatting for a <code>PivotTableVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PivotTableConditionalFormatting {
    /// <p>Conditional formatting options for a <code>PivotTableVisual</code>.</p>
    #[doc(hidden)]
    pub conditional_formatting_options:
        std::option::Option<std::vec::Vec<crate::model::PivotTableConditionalFormattingOption>>,
}
impl PivotTableConditionalFormatting {
    /// <p>Conditional formatting options for a <code>PivotTableVisual</code>.</p>
    pub fn conditional_formatting_options(
        &self,
    ) -> std::option::Option<&[crate::model::PivotTableConditionalFormattingOption]> {
        self.conditional_formatting_options.as_deref()
    }
}
/// See [`PivotTableConditionalFormatting`](crate::model::PivotTableConditionalFormatting).
pub mod pivot_table_conditional_formatting {

    /// A builder for [`PivotTableConditionalFormatting`](crate::model::PivotTableConditionalFormatting).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) conditional_formatting_options:
            std::option::Option<std::vec::Vec<crate::model::PivotTableConditionalFormattingOption>>,
    }
    impl Builder {
        /// Appends an item to `conditional_formatting_options`.
        ///
        /// To override the contents of this collection use [`set_conditional_formatting_options`](Self::set_conditional_formatting_options).
        ///
        /// <p>Conditional formatting options for a <code>PivotTableVisual</code>.</p>
        pub fn conditional_formatting_options(
            mut self,
            input: crate::model::PivotTableConditionalFormattingOption,
        ) -> Self {
            let mut v = self.conditional_formatting_options.unwrap_or_default();
            v.push(input);
            self.conditional_formatting_options = Some(v);
            self
        }
        /// <p>Conditional formatting options for a <code>PivotTableVisual</code>.</p>
        pub fn set_conditional_formatting_options(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::PivotTableConditionalFormattingOption>,
            >,
        ) -> Self {
            self.conditional_formatting_options = input;
            self
        }
        /// Consumes the builder and constructs a [`PivotTableConditionalFormatting`](crate::model::PivotTableConditionalFormatting).
        pub fn build(self) -> crate::model::PivotTableConditionalFormatting {
            crate::model::PivotTableConditionalFormatting {
                conditional_formatting_options: self.conditional_formatting_options,
            }
        }
    }
}
impl PivotTableConditionalFormatting {
    /// Creates a new builder-style object to manufacture [`PivotTableConditionalFormatting`](crate::model::PivotTableConditionalFormatting).
    pub fn builder() -> crate::model::pivot_table_conditional_formatting::Builder {
        crate::model::pivot_table_conditional_formatting::Builder::default()
    }
}

/// <p>Conditional formatting options for a <code>PivotTableVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PivotTableConditionalFormattingOption {
    /// <p>The cell conditional formatting option for a pivot table.</p>
    #[doc(hidden)]
    pub cell: std::option::Option<crate::model::PivotTableCellConditionalFormatting>,
}
impl PivotTableConditionalFormattingOption {
    /// <p>The cell conditional formatting option for a pivot table.</p>
    pub fn cell(&self) -> std::option::Option<&crate::model::PivotTableCellConditionalFormatting> {
        self.cell.as_ref()
    }
}
/// See [`PivotTableConditionalFormattingOption`](crate::model::PivotTableConditionalFormattingOption).
pub mod pivot_table_conditional_formatting_option {

    /// A builder for [`PivotTableConditionalFormattingOption`](crate::model::PivotTableConditionalFormattingOption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cell: std::option::Option<crate::model::PivotTableCellConditionalFormatting>,
    }
    impl Builder {
        /// <p>The cell conditional formatting option for a pivot table.</p>
        pub fn cell(mut self, input: crate::model::PivotTableCellConditionalFormatting) -> Self {
            self.cell = Some(input);
            self
        }
        /// <p>The cell conditional formatting option for a pivot table.</p>
        pub fn set_cell(
            mut self,
            input: std::option::Option<crate::model::PivotTableCellConditionalFormatting>,
        ) -> Self {
            self.cell = input;
            self
        }
        /// Consumes the builder and constructs a [`PivotTableConditionalFormattingOption`](crate::model::PivotTableConditionalFormattingOption).
        pub fn build(self) -> crate::model::PivotTableConditionalFormattingOption {
            crate::model::PivotTableConditionalFormattingOption { cell: self.cell }
        }
    }
}
impl PivotTableConditionalFormattingOption {
    /// Creates a new builder-style object to manufacture [`PivotTableConditionalFormattingOption`](crate::model::PivotTableConditionalFormattingOption).
    pub fn builder() -> crate::model::pivot_table_conditional_formatting_option::Builder {
        crate::model::pivot_table_conditional_formatting_option::Builder::default()
    }
}

/// <p>The cell conditional formatting option for a pivot table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PivotTableCellConditionalFormatting {
    /// <p>The field ID of the cell for conditional formatting.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The text format of the cell for conditional formatting.</p>
    #[doc(hidden)]
    pub text_format: std::option::Option<crate::model::TextConditionalFormat>,
    /// <p>The scope of the cell for conditional formatting.</p>
    #[doc(hidden)]
    pub scope: std::option::Option<crate::model::PivotTableConditionalFormattingScope>,
}
impl PivotTableCellConditionalFormatting {
    /// <p>The field ID of the cell for conditional formatting.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The text format of the cell for conditional formatting.</p>
    pub fn text_format(&self) -> std::option::Option<&crate::model::TextConditionalFormat> {
        self.text_format.as_ref()
    }
    /// <p>The scope of the cell for conditional formatting.</p>
    pub fn scope(
        &self,
    ) -> std::option::Option<&crate::model::PivotTableConditionalFormattingScope> {
        self.scope.as_ref()
    }
}
/// See [`PivotTableCellConditionalFormatting`](crate::model::PivotTableCellConditionalFormatting).
pub mod pivot_table_cell_conditional_formatting {

    /// A builder for [`PivotTableCellConditionalFormatting`](crate::model::PivotTableCellConditionalFormatting).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) text_format: std::option::Option<crate::model::TextConditionalFormat>,
        pub(crate) scope: std::option::Option<crate::model::PivotTableConditionalFormattingScope>,
    }
    impl Builder {
        /// <p>The field ID of the cell for conditional formatting.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The field ID of the cell for conditional formatting.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The text format of the cell for conditional formatting.</p>
        pub fn text_format(mut self, input: crate::model::TextConditionalFormat) -> Self {
            self.text_format = Some(input);
            self
        }
        /// <p>The text format of the cell for conditional formatting.</p>
        pub fn set_text_format(
            mut self,
            input: std::option::Option<crate::model::TextConditionalFormat>,
        ) -> Self {
            self.text_format = input;
            self
        }
        /// <p>The scope of the cell for conditional formatting.</p>
        pub fn scope(mut self, input: crate::model::PivotTableConditionalFormattingScope) -> Self {
            self.scope = Some(input);
            self
        }
        /// <p>The scope of the cell for conditional formatting.</p>
        pub fn set_scope(
            mut self,
            input: std::option::Option<crate::model::PivotTableConditionalFormattingScope>,
        ) -> Self {
            self.scope = input;
            self
        }
        /// Consumes the builder and constructs a [`PivotTableCellConditionalFormatting`](crate::model::PivotTableCellConditionalFormatting).
        pub fn build(self) -> crate::model::PivotTableCellConditionalFormatting {
            crate::model::PivotTableCellConditionalFormatting {
                field_id: self.field_id,
                text_format: self.text_format,
                scope: self.scope,
            }
        }
    }
}
impl PivotTableCellConditionalFormatting {
    /// Creates a new builder-style object to manufacture [`PivotTableCellConditionalFormatting`](crate::model::PivotTableCellConditionalFormatting).
    pub fn builder() -> crate::model::pivot_table_cell_conditional_formatting::Builder {
        crate::model::pivot_table_cell_conditional_formatting::Builder::default()
    }
}

/// <p>The scope of the cell for conditional formatting.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PivotTableConditionalFormattingScope {
    /// <p>The role (field, field total, grand total) of the cell for conditional formatting.</p>
    #[doc(hidden)]
    pub role: std::option::Option<crate::model::PivotTableConditionalFormattingScopeRole>,
}
impl PivotTableConditionalFormattingScope {
    /// <p>The role (field, field total, grand total) of the cell for conditional formatting.</p>
    pub fn role(
        &self,
    ) -> std::option::Option<&crate::model::PivotTableConditionalFormattingScopeRole> {
        self.role.as_ref()
    }
}
/// See [`PivotTableConditionalFormattingScope`](crate::model::PivotTableConditionalFormattingScope).
pub mod pivot_table_conditional_formatting_scope {

    /// A builder for [`PivotTableConditionalFormattingScope`](crate::model::PivotTableConditionalFormattingScope).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role:
            std::option::Option<crate::model::PivotTableConditionalFormattingScopeRole>,
    }
    impl Builder {
        /// <p>The role (field, field total, grand total) of the cell for conditional formatting.</p>
        pub fn role(
            mut self,
            input: crate::model::PivotTableConditionalFormattingScopeRole,
        ) -> Self {
            self.role = Some(input);
            self
        }
        /// <p>The role (field, field total, grand total) of the cell for conditional formatting.</p>
        pub fn set_role(
            mut self,
            input: std::option::Option<crate::model::PivotTableConditionalFormattingScopeRole>,
        ) -> Self {
            self.role = input;
            self
        }
        /// Consumes the builder and constructs a [`PivotTableConditionalFormattingScope`](crate::model::PivotTableConditionalFormattingScope).
        pub fn build(self) -> crate::model::PivotTableConditionalFormattingScope {
            crate::model::PivotTableConditionalFormattingScope { role: self.role }
        }
    }
}
impl PivotTableConditionalFormattingScope {
    /// Creates a new builder-style object to manufacture [`PivotTableConditionalFormattingScope`](crate::model::PivotTableConditionalFormattingScope).
    pub fn builder() -> crate::model::pivot_table_conditional_formatting_scope::Builder {
        crate::model::pivot_table_conditional_formatting_scope::Builder::default()
    }
}

/// When writing a match expression against `PivotTableConditionalFormattingScopeRole`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let pivottableconditionalformattingscoperole = unimplemented!();
/// match pivottableconditionalformattingscoperole {
///     PivotTableConditionalFormattingScopeRole::Field => { /* ... */ },
///     PivotTableConditionalFormattingScopeRole::FieldTotal => { /* ... */ },
///     PivotTableConditionalFormattingScopeRole::GrandTotal => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `pivottableconditionalformattingscoperole` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PivotTableConditionalFormattingScopeRole::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PivotTableConditionalFormattingScopeRole::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PivotTableConditionalFormattingScopeRole::NewFeature` is defined.
/// Specifically, when `pivottableconditionalformattingscoperole` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PivotTableConditionalFormattingScopeRole::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PivotTableConditionalFormattingScopeRole {
    #[allow(missing_docs)] // documentation missing in model
    Field,
    #[allow(missing_docs)] // documentation missing in model
    FieldTotal,
    #[allow(missing_docs)] // documentation missing in model
    GrandTotal,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PivotTableConditionalFormattingScopeRole {
    fn from(s: &str) -> Self {
        match s {
            "FIELD" => PivotTableConditionalFormattingScopeRole::Field,
            "FIELD_TOTAL" => PivotTableConditionalFormattingScopeRole::FieldTotal,
            "GRAND_TOTAL" => PivotTableConditionalFormattingScopeRole::GrandTotal,
            other => PivotTableConditionalFormattingScopeRole::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for PivotTableConditionalFormattingScopeRole {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PivotTableConditionalFormattingScopeRole::from(s))
    }
}
impl PivotTableConditionalFormattingScopeRole {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PivotTableConditionalFormattingScopeRole::Field => "FIELD",
            PivotTableConditionalFormattingScopeRole::FieldTotal => "FIELD_TOTAL",
            PivotTableConditionalFormattingScopeRole::GrandTotal => "GRAND_TOTAL",
            PivotTableConditionalFormattingScopeRole::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FIELD", "FIELD_TOTAL", "GRAND_TOTAL"]
    }
}
impl AsRef<str> for PivotTableConditionalFormattingScopeRole {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The conditional formatting for the text.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TextConditionalFormat {
    /// <p>The conditional formatting for the text background color.</p>
    #[doc(hidden)]
    pub background_color: std::option::Option<crate::model::ConditionalFormattingColor>,
    /// <p>The conditional formatting for the text color.</p>
    #[doc(hidden)]
    pub text_color: std::option::Option<crate::model::ConditionalFormattingColor>,
    /// <p>The conditional formatting for the icon.</p>
    #[doc(hidden)]
    pub icon: std::option::Option<crate::model::ConditionalFormattingIcon>,
}
impl TextConditionalFormat {
    /// <p>The conditional formatting for the text background color.</p>
    pub fn background_color(
        &self,
    ) -> std::option::Option<&crate::model::ConditionalFormattingColor> {
        self.background_color.as_ref()
    }
    /// <p>The conditional formatting for the text color.</p>
    pub fn text_color(&self) -> std::option::Option<&crate::model::ConditionalFormattingColor> {
        self.text_color.as_ref()
    }
    /// <p>The conditional formatting for the icon.</p>
    pub fn icon(&self) -> std::option::Option<&crate::model::ConditionalFormattingIcon> {
        self.icon.as_ref()
    }
}
/// See [`TextConditionalFormat`](crate::model::TextConditionalFormat).
pub mod text_conditional_format {

    /// A builder for [`TextConditionalFormat`](crate::model::TextConditionalFormat).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) background_color: std::option::Option<crate::model::ConditionalFormattingColor>,
        pub(crate) text_color: std::option::Option<crate::model::ConditionalFormattingColor>,
        pub(crate) icon: std::option::Option<crate::model::ConditionalFormattingIcon>,
    }
    impl Builder {
        /// <p>The conditional formatting for the text background color.</p>
        pub fn background_color(mut self, input: crate::model::ConditionalFormattingColor) -> Self {
            self.background_color = Some(input);
            self
        }
        /// <p>The conditional formatting for the text background color.</p>
        pub fn set_background_color(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingColor>,
        ) -> Self {
            self.background_color = input;
            self
        }
        /// <p>The conditional formatting for the text color.</p>
        pub fn text_color(mut self, input: crate::model::ConditionalFormattingColor) -> Self {
            self.text_color = Some(input);
            self
        }
        /// <p>The conditional formatting for the text color.</p>
        pub fn set_text_color(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingColor>,
        ) -> Self {
            self.text_color = input;
            self
        }
        /// <p>The conditional formatting for the icon.</p>
        pub fn icon(mut self, input: crate::model::ConditionalFormattingIcon) -> Self {
            self.icon = Some(input);
            self
        }
        /// <p>The conditional formatting for the icon.</p>
        pub fn set_icon(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingIcon>,
        ) -> Self {
            self.icon = input;
            self
        }
        /// Consumes the builder and constructs a [`TextConditionalFormat`](crate::model::TextConditionalFormat).
        pub fn build(self) -> crate::model::TextConditionalFormat {
            crate::model::TextConditionalFormat {
                background_color: self.background_color,
                text_color: self.text_color,
                icon: self.icon,
            }
        }
    }
}
impl TextConditionalFormat {
    /// Creates a new builder-style object to manufacture [`TextConditionalFormat`](crate::model::TextConditionalFormat).
    pub fn builder() -> crate::model::text_conditional_format::Builder {
        crate::model::text_conditional_format::Builder::default()
    }
}

/// <p>The configuration for a <code>PivotTableVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PivotTableConfiguration {
    /// <p>The field wells of the visual.</p>
    #[doc(hidden)]
    pub field_wells: std::option::Option<crate::model::PivotTableFieldWells>,
    /// <p>The sort configuration for a <code>PivotTableVisual</code>.</p>
    #[doc(hidden)]
    pub sort_configuration: std::option::Option<crate::model::PivotTableSortConfiguration>,
    /// <p>The table options for a pivot table visual.</p>
    #[doc(hidden)]
    pub table_options: std::option::Option<crate::model::PivotTableOptions>,
    /// <p>The total options for a pivot table visual.</p>
    #[doc(hidden)]
    pub total_options: std::option::Option<crate::model::PivotTableTotalOptions>,
    /// <p>The field options for a pivot table visual.</p>
    #[doc(hidden)]
    pub field_options: std::option::Option<crate::model::PivotTableFieldOptions>,
    /// <p>The paginated report options for a pivot table visual.</p>
    #[doc(hidden)]
    pub paginated_report_options:
        std::option::Option<crate::model::PivotTablePaginatedReportOptions>,
}
impl PivotTableConfiguration {
    /// <p>The field wells of the visual.</p>
    pub fn field_wells(&self) -> std::option::Option<&crate::model::PivotTableFieldWells> {
        self.field_wells.as_ref()
    }
    /// <p>The sort configuration for a <code>PivotTableVisual</code>.</p>
    pub fn sort_configuration(
        &self,
    ) -> std::option::Option<&crate::model::PivotTableSortConfiguration> {
        self.sort_configuration.as_ref()
    }
    /// <p>The table options for a pivot table visual.</p>
    pub fn table_options(&self) -> std::option::Option<&crate::model::PivotTableOptions> {
        self.table_options.as_ref()
    }
    /// <p>The total options for a pivot table visual.</p>
    pub fn total_options(&self) -> std::option::Option<&crate::model::PivotTableTotalOptions> {
        self.total_options.as_ref()
    }
    /// <p>The field options for a pivot table visual.</p>
    pub fn field_options(&self) -> std::option::Option<&crate::model::PivotTableFieldOptions> {
        self.field_options.as_ref()
    }
    /// <p>The paginated report options for a pivot table visual.</p>
    pub fn paginated_report_options(
        &self,
    ) -> std::option::Option<&crate::model::PivotTablePaginatedReportOptions> {
        self.paginated_report_options.as_ref()
    }
}
/// See [`PivotTableConfiguration`](crate::model::PivotTableConfiguration).
pub mod pivot_table_configuration {

    /// A builder for [`PivotTableConfiguration`](crate::model::PivotTableConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_wells: std::option::Option<crate::model::PivotTableFieldWells>,
        pub(crate) sort_configuration:
            std::option::Option<crate::model::PivotTableSortConfiguration>,
        pub(crate) table_options: std::option::Option<crate::model::PivotTableOptions>,
        pub(crate) total_options: std::option::Option<crate::model::PivotTableTotalOptions>,
        pub(crate) field_options: std::option::Option<crate::model::PivotTableFieldOptions>,
        pub(crate) paginated_report_options:
            std::option::Option<crate::model::PivotTablePaginatedReportOptions>,
    }
    impl Builder {
        /// <p>The field wells of the visual.</p>
        pub fn field_wells(mut self, input: crate::model::PivotTableFieldWells) -> Self {
            self.field_wells = Some(input);
            self
        }
        /// <p>The field wells of the visual.</p>
        pub fn set_field_wells(
            mut self,
            input: std::option::Option<crate::model::PivotTableFieldWells>,
        ) -> Self {
            self.field_wells = input;
            self
        }
        /// <p>The sort configuration for a <code>PivotTableVisual</code>.</p>
        pub fn sort_configuration(
            mut self,
            input: crate::model::PivotTableSortConfiguration,
        ) -> Self {
            self.sort_configuration = Some(input);
            self
        }
        /// <p>The sort configuration for a <code>PivotTableVisual</code>.</p>
        pub fn set_sort_configuration(
            mut self,
            input: std::option::Option<crate::model::PivotTableSortConfiguration>,
        ) -> Self {
            self.sort_configuration = input;
            self
        }
        /// <p>The table options for a pivot table visual.</p>
        pub fn table_options(mut self, input: crate::model::PivotTableOptions) -> Self {
            self.table_options = Some(input);
            self
        }
        /// <p>The table options for a pivot table visual.</p>
        pub fn set_table_options(
            mut self,
            input: std::option::Option<crate::model::PivotTableOptions>,
        ) -> Self {
            self.table_options = input;
            self
        }
        /// <p>The total options for a pivot table visual.</p>
        pub fn total_options(mut self, input: crate::model::PivotTableTotalOptions) -> Self {
            self.total_options = Some(input);
            self
        }
        /// <p>The total options for a pivot table visual.</p>
        pub fn set_total_options(
            mut self,
            input: std::option::Option<crate::model::PivotTableTotalOptions>,
        ) -> Self {
            self.total_options = input;
            self
        }
        /// <p>The field options for a pivot table visual.</p>
        pub fn field_options(mut self, input: crate::model::PivotTableFieldOptions) -> Self {
            self.field_options = Some(input);
            self
        }
        /// <p>The field options for a pivot table visual.</p>
        pub fn set_field_options(
            mut self,
            input: std::option::Option<crate::model::PivotTableFieldOptions>,
        ) -> Self {
            self.field_options = input;
            self
        }
        /// <p>The paginated report options for a pivot table visual.</p>
        pub fn paginated_report_options(
            mut self,
            input: crate::model::PivotTablePaginatedReportOptions,
        ) -> Self {
            self.paginated_report_options = Some(input);
            self
        }
        /// <p>The paginated report options for a pivot table visual.</p>
        pub fn set_paginated_report_options(
            mut self,
            input: std::option::Option<crate::model::PivotTablePaginatedReportOptions>,
        ) -> Self {
            self.paginated_report_options = input;
            self
        }
        /// Consumes the builder and constructs a [`PivotTableConfiguration`](crate::model::PivotTableConfiguration).
        pub fn build(self) -> crate::model::PivotTableConfiguration {
            crate::model::PivotTableConfiguration {
                field_wells: self.field_wells,
                sort_configuration: self.sort_configuration,
                table_options: self.table_options,
                total_options: self.total_options,
                field_options: self.field_options,
                paginated_report_options: self.paginated_report_options,
            }
        }
    }
}
impl PivotTableConfiguration {
    /// Creates a new builder-style object to manufacture [`PivotTableConfiguration`](crate::model::PivotTableConfiguration).
    pub fn builder() -> crate::model::pivot_table_configuration::Builder {
        crate::model::pivot_table_configuration::Builder::default()
    }
}

/// <p>The paginated report options for a pivot table visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PivotTablePaginatedReportOptions {
    /// <p>The visibility of the printing table overflow across pages.</p>
    #[doc(hidden)]
    pub vertical_overflow_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The visibility of the repeating header rows on each page.</p>
    #[doc(hidden)]
    pub overflow_column_header_visibility: std::option::Option<crate::model::Visibility>,
}
impl PivotTablePaginatedReportOptions {
    /// <p>The visibility of the printing table overflow across pages.</p>
    pub fn vertical_overflow_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.vertical_overflow_visibility.as_ref()
    }
    /// <p>The visibility of the repeating header rows on each page.</p>
    pub fn overflow_column_header_visibility(
        &self,
    ) -> std::option::Option<&crate::model::Visibility> {
        self.overflow_column_header_visibility.as_ref()
    }
}
/// See [`PivotTablePaginatedReportOptions`](crate::model::PivotTablePaginatedReportOptions).
pub mod pivot_table_paginated_report_options {

    /// A builder for [`PivotTablePaginatedReportOptions`](crate::model::PivotTablePaginatedReportOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vertical_overflow_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) overflow_column_header_visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>The visibility of the printing table overflow across pages.</p>
        pub fn vertical_overflow_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.vertical_overflow_visibility = Some(input);
            self
        }
        /// <p>The visibility of the printing table overflow across pages.</p>
        pub fn set_vertical_overflow_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.vertical_overflow_visibility = input;
            self
        }
        /// <p>The visibility of the repeating header rows on each page.</p>
        pub fn overflow_column_header_visibility(
            mut self,
            input: crate::model::Visibility,
        ) -> Self {
            self.overflow_column_header_visibility = Some(input);
            self
        }
        /// <p>The visibility of the repeating header rows on each page.</p>
        pub fn set_overflow_column_header_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.overflow_column_header_visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`PivotTablePaginatedReportOptions`](crate::model::PivotTablePaginatedReportOptions).
        pub fn build(self) -> crate::model::PivotTablePaginatedReportOptions {
            crate::model::PivotTablePaginatedReportOptions {
                vertical_overflow_visibility: self.vertical_overflow_visibility,
                overflow_column_header_visibility: self.overflow_column_header_visibility,
            }
        }
    }
}
impl PivotTablePaginatedReportOptions {
    /// Creates a new builder-style object to manufacture [`PivotTablePaginatedReportOptions`](crate::model::PivotTablePaginatedReportOptions).
    pub fn builder() -> crate::model::pivot_table_paginated_report_options::Builder {
        crate::model::pivot_table_paginated_report_options::Builder::default()
    }
}

/// <p>The field options for a pivot table visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PivotTableFieldOptions {
    /// <p>The selected field options for the pivot table field options.</p>
    #[doc(hidden)]
    pub selected_field_options:
        std::option::Option<std::vec::Vec<crate::model::PivotTableFieldOption>>,
    /// <p>The data path options for the pivot table field options.</p>
    #[doc(hidden)]
    pub data_path_options:
        std::option::Option<std::vec::Vec<crate::model::PivotTableDataPathOption>>,
}
impl PivotTableFieldOptions {
    /// <p>The selected field options for the pivot table field options.</p>
    pub fn selected_field_options(
        &self,
    ) -> std::option::Option<&[crate::model::PivotTableFieldOption]> {
        self.selected_field_options.as_deref()
    }
    /// <p>The data path options for the pivot table field options.</p>
    pub fn data_path_options(
        &self,
    ) -> std::option::Option<&[crate::model::PivotTableDataPathOption]> {
        self.data_path_options.as_deref()
    }
}
/// See [`PivotTableFieldOptions`](crate::model::PivotTableFieldOptions).
pub mod pivot_table_field_options {

    /// A builder for [`PivotTableFieldOptions`](crate::model::PivotTableFieldOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) selected_field_options:
            std::option::Option<std::vec::Vec<crate::model::PivotTableFieldOption>>,
        pub(crate) data_path_options:
            std::option::Option<std::vec::Vec<crate::model::PivotTableDataPathOption>>,
    }
    impl Builder {
        /// Appends an item to `selected_field_options`.
        ///
        /// To override the contents of this collection use [`set_selected_field_options`](Self::set_selected_field_options).
        ///
        /// <p>The selected field options for the pivot table field options.</p>
        pub fn selected_field_options(
            mut self,
            input: crate::model::PivotTableFieldOption,
        ) -> Self {
            let mut v = self.selected_field_options.unwrap_or_default();
            v.push(input);
            self.selected_field_options = Some(v);
            self
        }
        /// <p>The selected field options for the pivot table field options.</p>
        pub fn set_selected_field_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PivotTableFieldOption>>,
        ) -> Self {
            self.selected_field_options = input;
            self
        }
        /// Appends an item to `data_path_options`.
        ///
        /// To override the contents of this collection use [`set_data_path_options`](Self::set_data_path_options).
        ///
        /// <p>The data path options for the pivot table field options.</p>
        pub fn data_path_options(mut self, input: crate::model::PivotTableDataPathOption) -> Self {
            let mut v = self.data_path_options.unwrap_or_default();
            v.push(input);
            self.data_path_options = Some(v);
            self
        }
        /// <p>The data path options for the pivot table field options.</p>
        pub fn set_data_path_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PivotTableDataPathOption>>,
        ) -> Self {
            self.data_path_options = input;
            self
        }
        /// Consumes the builder and constructs a [`PivotTableFieldOptions`](crate::model::PivotTableFieldOptions).
        pub fn build(self) -> crate::model::PivotTableFieldOptions {
            crate::model::PivotTableFieldOptions {
                selected_field_options: self.selected_field_options,
                data_path_options: self.data_path_options,
            }
        }
    }
}
impl PivotTableFieldOptions {
    /// Creates a new builder-style object to manufacture [`PivotTableFieldOptions`](crate::model::PivotTableFieldOptions).
    pub fn builder() -> crate::model::pivot_table_field_options::Builder {
        crate::model::pivot_table_field_options::Builder::default()
    }
}

/// <p>The data path options for the pivot table field options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PivotTableDataPathOption {
    /// <p>The list of data path values for the data path options.</p>
    #[doc(hidden)]
    pub data_path_list: std::option::Option<std::vec::Vec<crate::model::DataPathValue>>,
    /// <p>The width of the data path option.</p>
    #[doc(hidden)]
    pub width: std::option::Option<std::string::String>,
}
impl PivotTableDataPathOption {
    /// <p>The list of data path values for the data path options.</p>
    pub fn data_path_list(&self) -> std::option::Option<&[crate::model::DataPathValue]> {
        self.data_path_list.as_deref()
    }
    /// <p>The width of the data path option.</p>
    pub fn width(&self) -> std::option::Option<&str> {
        self.width.as_deref()
    }
}
/// See [`PivotTableDataPathOption`](crate::model::PivotTableDataPathOption).
pub mod pivot_table_data_path_option {

    /// A builder for [`PivotTableDataPathOption`](crate::model::PivotTableDataPathOption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_path_list: std::option::Option<std::vec::Vec<crate::model::DataPathValue>>,
        pub(crate) width: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `data_path_list`.
        ///
        /// To override the contents of this collection use [`set_data_path_list`](Self::set_data_path_list).
        ///
        /// <p>The list of data path values for the data path options.</p>
        pub fn data_path_list(mut self, input: crate::model::DataPathValue) -> Self {
            let mut v = self.data_path_list.unwrap_or_default();
            v.push(input);
            self.data_path_list = Some(v);
            self
        }
        /// <p>The list of data path values for the data path options.</p>
        pub fn set_data_path_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataPathValue>>,
        ) -> Self {
            self.data_path_list = input;
            self
        }
        /// <p>The width of the data path option.</p>
        pub fn width(mut self, input: impl Into<std::string::String>) -> Self {
            self.width = Some(input.into());
            self
        }
        /// <p>The width of the data path option.</p>
        pub fn set_width(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.width = input;
            self
        }
        /// Consumes the builder and constructs a [`PivotTableDataPathOption`](crate::model::PivotTableDataPathOption).
        pub fn build(self) -> crate::model::PivotTableDataPathOption {
            crate::model::PivotTableDataPathOption {
                data_path_list: self.data_path_list,
                width: self.width,
            }
        }
    }
}
impl PivotTableDataPathOption {
    /// Creates a new builder-style object to manufacture [`PivotTableDataPathOption`](crate::model::PivotTableDataPathOption).
    pub fn builder() -> crate::model::pivot_table_data_path_option::Builder {
        crate::model::pivot_table_data_path_option::Builder::default()
    }
}

/// <p>The selected field options for the pivot table field options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PivotTableFieldOption {
    /// <p>The field ID of the pivot table field.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The custom label of the pivot table field.</p>
    #[doc(hidden)]
    pub custom_label: std::option::Option<std::string::String>,
    /// <p>The visibility of the pivot table field.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
}
impl PivotTableFieldOption {
    /// <p>The field ID of the pivot table field.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The custom label of the pivot table field.</p>
    pub fn custom_label(&self) -> std::option::Option<&str> {
        self.custom_label.as_deref()
    }
    /// <p>The visibility of the pivot table field.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
}
/// See [`PivotTableFieldOption`](crate::model::PivotTableFieldOption).
pub mod pivot_table_field_option {

    /// A builder for [`PivotTableFieldOption`](crate::model::PivotTableFieldOption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) custom_label: std::option::Option<std::string::String>,
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>The field ID of the pivot table field.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The field ID of the pivot table field.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The custom label of the pivot table field.</p>
        pub fn custom_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_label = Some(input.into());
            self
        }
        /// <p>The custom label of the pivot table field.</p>
        pub fn set_custom_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.custom_label = input;
            self
        }
        /// <p>The visibility of the pivot table field.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility of the pivot table field.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`PivotTableFieldOption`](crate::model::PivotTableFieldOption).
        pub fn build(self) -> crate::model::PivotTableFieldOption {
            crate::model::PivotTableFieldOption {
                field_id: self.field_id,
                custom_label: self.custom_label,
                visibility: self.visibility,
            }
        }
    }
}
impl PivotTableFieldOption {
    /// Creates a new builder-style object to manufacture [`PivotTableFieldOption`](crate::model::PivotTableFieldOption).
    pub fn builder() -> crate::model::pivot_table_field_option::Builder {
        crate::model::pivot_table_field_option::Builder::default()
    }
}

/// <p>The total options for a pivot table visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PivotTableTotalOptions {
    /// <p>The row subtotal options.</p>
    #[doc(hidden)]
    pub row_subtotal_options: std::option::Option<crate::model::SubtotalOptions>,
    /// <p>The column subtotal options.</p>
    #[doc(hidden)]
    pub column_subtotal_options: std::option::Option<crate::model::SubtotalOptions>,
    /// <p>The row total options.</p>
    #[doc(hidden)]
    pub row_total_options: std::option::Option<crate::model::PivotTotalOptions>,
    /// <p>The column total options.</p>
    #[doc(hidden)]
    pub column_total_options: std::option::Option<crate::model::PivotTotalOptions>,
}
impl PivotTableTotalOptions {
    /// <p>The row subtotal options.</p>
    pub fn row_subtotal_options(&self) -> std::option::Option<&crate::model::SubtotalOptions> {
        self.row_subtotal_options.as_ref()
    }
    /// <p>The column subtotal options.</p>
    pub fn column_subtotal_options(&self) -> std::option::Option<&crate::model::SubtotalOptions> {
        self.column_subtotal_options.as_ref()
    }
    /// <p>The row total options.</p>
    pub fn row_total_options(&self) -> std::option::Option<&crate::model::PivotTotalOptions> {
        self.row_total_options.as_ref()
    }
    /// <p>The column total options.</p>
    pub fn column_total_options(&self) -> std::option::Option<&crate::model::PivotTotalOptions> {
        self.column_total_options.as_ref()
    }
}
/// See [`PivotTableTotalOptions`](crate::model::PivotTableTotalOptions).
pub mod pivot_table_total_options {

    /// A builder for [`PivotTableTotalOptions`](crate::model::PivotTableTotalOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) row_subtotal_options: std::option::Option<crate::model::SubtotalOptions>,
        pub(crate) column_subtotal_options: std::option::Option<crate::model::SubtotalOptions>,
        pub(crate) row_total_options: std::option::Option<crate::model::PivotTotalOptions>,
        pub(crate) column_total_options: std::option::Option<crate::model::PivotTotalOptions>,
    }
    impl Builder {
        /// <p>The row subtotal options.</p>
        pub fn row_subtotal_options(mut self, input: crate::model::SubtotalOptions) -> Self {
            self.row_subtotal_options = Some(input);
            self
        }
        /// <p>The row subtotal options.</p>
        pub fn set_row_subtotal_options(
            mut self,
            input: std::option::Option<crate::model::SubtotalOptions>,
        ) -> Self {
            self.row_subtotal_options = input;
            self
        }
        /// <p>The column subtotal options.</p>
        pub fn column_subtotal_options(mut self, input: crate::model::SubtotalOptions) -> Self {
            self.column_subtotal_options = Some(input);
            self
        }
        /// <p>The column subtotal options.</p>
        pub fn set_column_subtotal_options(
            mut self,
            input: std::option::Option<crate::model::SubtotalOptions>,
        ) -> Self {
            self.column_subtotal_options = input;
            self
        }
        /// <p>The row total options.</p>
        pub fn row_total_options(mut self, input: crate::model::PivotTotalOptions) -> Self {
            self.row_total_options = Some(input);
            self
        }
        /// <p>The row total options.</p>
        pub fn set_row_total_options(
            mut self,
            input: std::option::Option<crate::model::PivotTotalOptions>,
        ) -> Self {
            self.row_total_options = input;
            self
        }
        /// <p>The column total options.</p>
        pub fn column_total_options(mut self, input: crate::model::PivotTotalOptions) -> Self {
            self.column_total_options = Some(input);
            self
        }
        /// <p>The column total options.</p>
        pub fn set_column_total_options(
            mut self,
            input: std::option::Option<crate::model::PivotTotalOptions>,
        ) -> Self {
            self.column_total_options = input;
            self
        }
        /// Consumes the builder and constructs a [`PivotTableTotalOptions`](crate::model::PivotTableTotalOptions).
        pub fn build(self) -> crate::model::PivotTableTotalOptions {
            crate::model::PivotTableTotalOptions {
                row_subtotal_options: self.row_subtotal_options,
                column_subtotal_options: self.column_subtotal_options,
                row_total_options: self.row_total_options,
                column_total_options: self.column_total_options,
            }
        }
    }
}
impl PivotTableTotalOptions {
    /// Creates a new builder-style object to manufacture [`PivotTableTotalOptions`](crate::model::PivotTableTotalOptions).
    pub fn builder() -> crate::model::pivot_table_total_options::Builder {
        crate::model::pivot_table_total_options::Builder::default()
    }
}

/// <p>The optional configuration of totals cells in a <code>PivotTableVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PivotTotalOptions {
    /// <p>The visibility configuration for the total cells.</p>
    #[doc(hidden)]
    pub totals_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The placement (start, end) for the total cells.</p>
    #[doc(hidden)]
    pub placement: std::option::Option<crate::model::TableTotalsPlacement>,
    /// <p>The scroll status (pinned, scrolled) for the total cells.</p>
    #[doc(hidden)]
    pub scroll_status: std::option::Option<crate::model::TableTotalsScrollStatus>,
    /// <p>The custom label string for the total cells.</p>
    #[doc(hidden)]
    pub custom_label: std::option::Option<std::string::String>,
    /// <p>The cell styling options for the total cells.</p>
    #[doc(hidden)]
    pub total_cell_style: std::option::Option<crate::model::TableCellStyle>,
    /// <p>The cell styling options for the totals of value cells.</p>
    #[doc(hidden)]
    pub value_cell_style: std::option::Option<crate::model::TableCellStyle>,
    /// <p>The cell styling options for the total of header cells.</p>
    #[doc(hidden)]
    pub metric_header_cell_style: std::option::Option<crate::model::TableCellStyle>,
}
impl PivotTotalOptions {
    /// <p>The visibility configuration for the total cells.</p>
    pub fn totals_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.totals_visibility.as_ref()
    }
    /// <p>The placement (start, end) for the total cells.</p>
    pub fn placement(&self) -> std::option::Option<&crate::model::TableTotalsPlacement> {
        self.placement.as_ref()
    }
    /// <p>The scroll status (pinned, scrolled) for the total cells.</p>
    pub fn scroll_status(&self) -> std::option::Option<&crate::model::TableTotalsScrollStatus> {
        self.scroll_status.as_ref()
    }
    /// <p>The custom label string for the total cells.</p>
    pub fn custom_label(&self) -> std::option::Option<&str> {
        self.custom_label.as_deref()
    }
    /// <p>The cell styling options for the total cells.</p>
    pub fn total_cell_style(&self) -> std::option::Option<&crate::model::TableCellStyle> {
        self.total_cell_style.as_ref()
    }
    /// <p>The cell styling options for the totals of value cells.</p>
    pub fn value_cell_style(&self) -> std::option::Option<&crate::model::TableCellStyle> {
        self.value_cell_style.as_ref()
    }
    /// <p>The cell styling options for the total of header cells.</p>
    pub fn metric_header_cell_style(&self) -> std::option::Option<&crate::model::TableCellStyle> {
        self.metric_header_cell_style.as_ref()
    }
}
/// See [`PivotTotalOptions`](crate::model::PivotTotalOptions).
pub mod pivot_total_options {

    /// A builder for [`PivotTotalOptions`](crate::model::PivotTotalOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) totals_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) placement: std::option::Option<crate::model::TableTotalsPlacement>,
        pub(crate) scroll_status: std::option::Option<crate::model::TableTotalsScrollStatus>,
        pub(crate) custom_label: std::option::Option<std::string::String>,
        pub(crate) total_cell_style: std::option::Option<crate::model::TableCellStyle>,
        pub(crate) value_cell_style: std::option::Option<crate::model::TableCellStyle>,
        pub(crate) metric_header_cell_style: std::option::Option<crate::model::TableCellStyle>,
    }
    impl Builder {
        /// <p>The visibility configuration for the total cells.</p>
        pub fn totals_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.totals_visibility = Some(input);
            self
        }
        /// <p>The visibility configuration for the total cells.</p>
        pub fn set_totals_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.totals_visibility = input;
            self
        }
        /// <p>The placement (start, end) for the total cells.</p>
        pub fn placement(mut self, input: crate::model::TableTotalsPlacement) -> Self {
            self.placement = Some(input);
            self
        }
        /// <p>The placement (start, end) for the total cells.</p>
        pub fn set_placement(
            mut self,
            input: std::option::Option<crate::model::TableTotalsPlacement>,
        ) -> Self {
            self.placement = input;
            self
        }
        /// <p>The scroll status (pinned, scrolled) for the total cells.</p>
        pub fn scroll_status(mut self, input: crate::model::TableTotalsScrollStatus) -> Self {
            self.scroll_status = Some(input);
            self
        }
        /// <p>The scroll status (pinned, scrolled) for the total cells.</p>
        pub fn set_scroll_status(
            mut self,
            input: std::option::Option<crate::model::TableTotalsScrollStatus>,
        ) -> Self {
            self.scroll_status = input;
            self
        }
        /// <p>The custom label string for the total cells.</p>
        pub fn custom_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_label = Some(input.into());
            self
        }
        /// <p>The custom label string for the total cells.</p>
        pub fn set_custom_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.custom_label = input;
            self
        }
        /// <p>The cell styling options for the total cells.</p>
        pub fn total_cell_style(mut self, input: crate::model::TableCellStyle) -> Self {
            self.total_cell_style = Some(input);
            self
        }
        /// <p>The cell styling options for the total cells.</p>
        pub fn set_total_cell_style(
            mut self,
            input: std::option::Option<crate::model::TableCellStyle>,
        ) -> Self {
            self.total_cell_style = input;
            self
        }
        /// <p>The cell styling options for the totals of value cells.</p>
        pub fn value_cell_style(mut self, input: crate::model::TableCellStyle) -> Self {
            self.value_cell_style = Some(input);
            self
        }
        /// <p>The cell styling options for the totals of value cells.</p>
        pub fn set_value_cell_style(
            mut self,
            input: std::option::Option<crate::model::TableCellStyle>,
        ) -> Self {
            self.value_cell_style = input;
            self
        }
        /// <p>The cell styling options for the total of header cells.</p>
        pub fn metric_header_cell_style(mut self, input: crate::model::TableCellStyle) -> Self {
            self.metric_header_cell_style = Some(input);
            self
        }
        /// <p>The cell styling options for the total of header cells.</p>
        pub fn set_metric_header_cell_style(
            mut self,
            input: std::option::Option<crate::model::TableCellStyle>,
        ) -> Self {
            self.metric_header_cell_style = input;
            self
        }
        /// Consumes the builder and constructs a [`PivotTotalOptions`](crate::model::PivotTotalOptions).
        pub fn build(self) -> crate::model::PivotTotalOptions {
            crate::model::PivotTotalOptions {
                totals_visibility: self.totals_visibility,
                placement: self.placement,
                scroll_status: self.scroll_status,
                custom_label: self.custom_label,
                total_cell_style: self.total_cell_style,
                value_cell_style: self.value_cell_style,
                metric_header_cell_style: self.metric_header_cell_style,
            }
        }
    }
}
impl PivotTotalOptions {
    /// Creates a new builder-style object to manufacture [`PivotTotalOptions`](crate::model::PivotTotalOptions).
    pub fn builder() -> crate::model::pivot_total_options::Builder {
        crate::model::pivot_total_options::Builder::default()
    }
}

/// <p>The table cell style for a cell in pivot table or table visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableCellStyle {
    /// <p>The visibility of the table cells.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The font configuration of the table cells.</p>
    #[doc(hidden)]
    pub font_configuration: std::option::Option<crate::model::FontConfiguration>,
    /// <p>The text wrap (none, wrap) for the table cells.</p>
    #[doc(hidden)]
    pub text_wrap: std::option::Option<crate::model::TextWrap>,
    /// <p>The horizontal text alignment (left, center, right, auto) for the table cells.</p>
    #[doc(hidden)]
    pub horizontal_text_alignment: std::option::Option<crate::model::HorizontalTextAlignment>,
    /// <p>The vertical text alignment (top, middle, bottom) for the table cells.</p>
    #[doc(hidden)]
    pub vertical_text_alignment: std::option::Option<crate::model::VerticalTextAlignment>,
    /// <p>The background color for the table cells.</p>
    #[doc(hidden)]
    pub background_color: std::option::Option<std::string::String>,
    /// <p>The height color for the table cells.</p>
    #[doc(hidden)]
    pub height: std::option::Option<i32>,
    /// <p>The borders for the table cells.</p>
    #[doc(hidden)]
    pub border: std::option::Option<crate::model::GlobalTableBorderOptions>,
}
impl TableCellStyle {
    /// <p>The visibility of the table cells.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
    /// <p>The font configuration of the table cells.</p>
    pub fn font_configuration(&self) -> std::option::Option<&crate::model::FontConfiguration> {
        self.font_configuration.as_ref()
    }
    /// <p>The text wrap (none, wrap) for the table cells.</p>
    pub fn text_wrap(&self) -> std::option::Option<&crate::model::TextWrap> {
        self.text_wrap.as_ref()
    }
    /// <p>The horizontal text alignment (left, center, right, auto) for the table cells.</p>
    pub fn horizontal_text_alignment(
        &self,
    ) -> std::option::Option<&crate::model::HorizontalTextAlignment> {
        self.horizontal_text_alignment.as_ref()
    }
    /// <p>The vertical text alignment (top, middle, bottom) for the table cells.</p>
    pub fn vertical_text_alignment(
        &self,
    ) -> std::option::Option<&crate::model::VerticalTextAlignment> {
        self.vertical_text_alignment.as_ref()
    }
    /// <p>The background color for the table cells.</p>
    pub fn background_color(&self) -> std::option::Option<&str> {
        self.background_color.as_deref()
    }
    /// <p>The height color for the table cells.</p>
    pub fn height(&self) -> std::option::Option<i32> {
        self.height
    }
    /// <p>The borders for the table cells.</p>
    pub fn border(&self) -> std::option::Option<&crate::model::GlobalTableBorderOptions> {
        self.border.as_ref()
    }
}
/// See [`TableCellStyle`](crate::model::TableCellStyle).
pub mod table_cell_style {

    /// A builder for [`TableCellStyle`](crate::model::TableCellStyle).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) font_configuration: std::option::Option<crate::model::FontConfiguration>,
        pub(crate) text_wrap: std::option::Option<crate::model::TextWrap>,
        pub(crate) horizontal_text_alignment:
            std::option::Option<crate::model::HorizontalTextAlignment>,
        pub(crate) vertical_text_alignment:
            std::option::Option<crate::model::VerticalTextAlignment>,
        pub(crate) background_color: std::option::Option<std::string::String>,
        pub(crate) height: std::option::Option<i32>,
        pub(crate) border: std::option::Option<crate::model::GlobalTableBorderOptions>,
    }
    impl Builder {
        /// <p>The visibility of the table cells.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility of the table cells.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// <p>The font configuration of the table cells.</p>
        pub fn font_configuration(mut self, input: crate::model::FontConfiguration) -> Self {
            self.font_configuration = Some(input);
            self
        }
        /// <p>The font configuration of the table cells.</p>
        pub fn set_font_configuration(
            mut self,
            input: std::option::Option<crate::model::FontConfiguration>,
        ) -> Self {
            self.font_configuration = input;
            self
        }
        /// <p>The text wrap (none, wrap) for the table cells.</p>
        pub fn text_wrap(mut self, input: crate::model::TextWrap) -> Self {
            self.text_wrap = Some(input);
            self
        }
        /// <p>The text wrap (none, wrap) for the table cells.</p>
        pub fn set_text_wrap(mut self, input: std::option::Option<crate::model::TextWrap>) -> Self {
            self.text_wrap = input;
            self
        }
        /// <p>The horizontal text alignment (left, center, right, auto) for the table cells.</p>
        pub fn horizontal_text_alignment(
            mut self,
            input: crate::model::HorizontalTextAlignment,
        ) -> Self {
            self.horizontal_text_alignment = Some(input);
            self
        }
        /// <p>The horizontal text alignment (left, center, right, auto) for the table cells.</p>
        pub fn set_horizontal_text_alignment(
            mut self,
            input: std::option::Option<crate::model::HorizontalTextAlignment>,
        ) -> Self {
            self.horizontal_text_alignment = input;
            self
        }
        /// <p>The vertical text alignment (top, middle, bottom) for the table cells.</p>
        pub fn vertical_text_alignment(
            mut self,
            input: crate::model::VerticalTextAlignment,
        ) -> Self {
            self.vertical_text_alignment = Some(input);
            self
        }
        /// <p>The vertical text alignment (top, middle, bottom) for the table cells.</p>
        pub fn set_vertical_text_alignment(
            mut self,
            input: std::option::Option<crate::model::VerticalTextAlignment>,
        ) -> Self {
            self.vertical_text_alignment = input;
            self
        }
        /// <p>The background color for the table cells.</p>
        pub fn background_color(mut self, input: impl Into<std::string::String>) -> Self {
            self.background_color = Some(input.into());
            self
        }
        /// <p>The background color for the table cells.</p>
        pub fn set_background_color(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.background_color = input;
            self
        }
        /// <p>The height color for the table cells.</p>
        pub fn height(mut self, input: i32) -> Self {
            self.height = Some(input);
            self
        }
        /// <p>The height color for the table cells.</p>
        pub fn set_height(mut self, input: std::option::Option<i32>) -> Self {
            self.height = input;
            self
        }
        /// <p>The borders for the table cells.</p>
        pub fn border(mut self, input: crate::model::GlobalTableBorderOptions) -> Self {
            self.border = Some(input);
            self
        }
        /// <p>The borders for the table cells.</p>
        pub fn set_border(
            mut self,
            input: std::option::Option<crate::model::GlobalTableBorderOptions>,
        ) -> Self {
            self.border = input;
            self
        }
        /// Consumes the builder and constructs a [`TableCellStyle`](crate::model::TableCellStyle).
        pub fn build(self) -> crate::model::TableCellStyle {
            crate::model::TableCellStyle {
                visibility: self.visibility,
                font_configuration: self.font_configuration,
                text_wrap: self.text_wrap,
                horizontal_text_alignment: self.horizontal_text_alignment,
                vertical_text_alignment: self.vertical_text_alignment,
                background_color: self.background_color,
                height: self.height,
                border: self.border,
            }
        }
    }
}
impl TableCellStyle {
    /// Creates a new builder-style object to manufacture [`TableCellStyle`](crate::model::TableCellStyle).
    pub fn builder() -> crate::model::table_cell_style::Builder {
        crate::model::table_cell_style::Builder::default()
    }
}

/// <p>Determines the border options for a table visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GlobalTableBorderOptions {
    /// <p>Determines the options for uniform border.</p>
    #[doc(hidden)]
    pub uniform_border: std::option::Option<crate::model::TableBorderOptions>,
    /// <p>Determines the options for side specific border.</p>
    #[doc(hidden)]
    pub side_specific_border: std::option::Option<crate::model::TableSideBorderOptions>,
}
impl GlobalTableBorderOptions {
    /// <p>Determines the options for uniform border.</p>
    pub fn uniform_border(&self) -> std::option::Option<&crate::model::TableBorderOptions> {
        self.uniform_border.as_ref()
    }
    /// <p>Determines the options for side specific border.</p>
    pub fn side_specific_border(
        &self,
    ) -> std::option::Option<&crate::model::TableSideBorderOptions> {
        self.side_specific_border.as_ref()
    }
}
/// See [`GlobalTableBorderOptions`](crate::model::GlobalTableBorderOptions).
pub mod global_table_border_options {

    /// A builder for [`GlobalTableBorderOptions`](crate::model::GlobalTableBorderOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) uniform_border: std::option::Option<crate::model::TableBorderOptions>,
        pub(crate) side_specific_border: std::option::Option<crate::model::TableSideBorderOptions>,
    }
    impl Builder {
        /// <p>Determines the options for uniform border.</p>
        pub fn uniform_border(mut self, input: crate::model::TableBorderOptions) -> Self {
            self.uniform_border = Some(input);
            self
        }
        /// <p>Determines the options for uniform border.</p>
        pub fn set_uniform_border(
            mut self,
            input: std::option::Option<crate::model::TableBorderOptions>,
        ) -> Self {
            self.uniform_border = input;
            self
        }
        /// <p>Determines the options for side specific border.</p>
        pub fn side_specific_border(mut self, input: crate::model::TableSideBorderOptions) -> Self {
            self.side_specific_border = Some(input);
            self
        }
        /// <p>Determines the options for side specific border.</p>
        pub fn set_side_specific_border(
            mut self,
            input: std::option::Option<crate::model::TableSideBorderOptions>,
        ) -> Self {
            self.side_specific_border = input;
            self
        }
        /// Consumes the builder and constructs a [`GlobalTableBorderOptions`](crate::model::GlobalTableBorderOptions).
        pub fn build(self) -> crate::model::GlobalTableBorderOptions {
            crate::model::GlobalTableBorderOptions {
                uniform_border: self.uniform_border,
                side_specific_border: self.side_specific_border,
            }
        }
    }
}
impl GlobalTableBorderOptions {
    /// Creates a new builder-style object to manufacture [`GlobalTableBorderOptions`](crate::model::GlobalTableBorderOptions).
    pub fn builder() -> crate::model::global_table_border_options::Builder {
        crate::model::global_table_border_options::Builder::default()
    }
}

/// <p>The side border options for a table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableSideBorderOptions {
    /// <p>The table border options of the inner vertical border.</p>
    #[doc(hidden)]
    pub inner_vertical: std::option::Option<crate::model::TableBorderOptions>,
    /// <p>The table border options of the inner horizontal border.</p>
    #[doc(hidden)]
    pub inner_horizontal: std::option::Option<crate::model::TableBorderOptions>,
    /// <p>The table border options of the left border.</p>
    #[doc(hidden)]
    pub left: std::option::Option<crate::model::TableBorderOptions>,
    /// <p>The table border options of the right border.</p>
    #[doc(hidden)]
    pub right: std::option::Option<crate::model::TableBorderOptions>,
    /// <p>The table border options of the top border.</p>
    #[doc(hidden)]
    pub top: std::option::Option<crate::model::TableBorderOptions>,
    /// <p>The table border options of the bottom border.</p>
    #[doc(hidden)]
    pub bottom: std::option::Option<crate::model::TableBorderOptions>,
}
impl TableSideBorderOptions {
    /// <p>The table border options of the inner vertical border.</p>
    pub fn inner_vertical(&self) -> std::option::Option<&crate::model::TableBorderOptions> {
        self.inner_vertical.as_ref()
    }
    /// <p>The table border options of the inner horizontal border.</p>
    pub fn inner_horizontal(&self) -> std::option::Option<&crate::model::TableBorderOptions> {
        self.inner_horizontal.as_ref()
    }
    /// <p>The table border options of the left border.</p>
    pub fn left(&self) -> std::option::Option<&crate::model::TableBorderOptions> {
        self.left.as_ref()
    }
    /// <p>The table border options of the right border.</p>
    pub fn right(&self) -> std::option::Option<&crate::model::TableBorderOptions> {
        self.right.as_ref()
    }
    /// <p>The table border options of the top border.</p>
    pub fn top(&self) -> std::option::Option<&crate::model::TableBorderOptions> {
        self.top.as_ref()
    }
    /// <p>The table border options of the bottom border.</p>
    pub fn bottom(&self) -> std::option::Option<&crate::model::TableBorderOptions> {
        self.bottom.as_ref()
    }
}
/// See [`TableSideBorderOptions`](crate::model::TableSideBorderOptions).
pub mod table_side_border_options {

    /// A builder for [`TableSideBorderOptions`](crate::model::TableSideBorderOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) inner_vertical: std::option::Option<crate::model::TableBorderOptions>,
        pub(crate) inner_horizontal: std::option::Option<crate::model::TableBorderOptions>,
        pub(crate) left: std::option::Option<crate::model::TableBorderOptions>,
        pub(crate) right: std::option::Option<crate::model::TableBorderOptions>,
        pub(crate) top: std::option::Option<crate::model::TableBorderOptions>,
        pub(crate) bottom: std::option::Option<crate::model::TableBorderOptions>,
    }
    impl Builder {
        /// <p>The table border options of the inner vertical border.</p>
        pub fn inner_vertical(mut self, input: crate::model::TableBorderOptions) -> Self {
            self.inner_vertical = Some(input);
            self
        }
        /// <p>The table border options of the inner vertical border.</p>
        pub fn set_inner_vertical(
            mut self,
            input: std::option::Option<crate::model::TableBorderOptions>,
        ) -> Self {
            self.inner_vertical = input;
            self
        }
        /// <p>The table border options of the inner horizontal border.</p>
        pub fn inner_horizontal(mut self, input: crate::model::TableBorderOptions) -> Self {
            self.inner_horizontal = Some(input);
            self
        }
        /// <p>The table border options of the inner horizontal border.</p>
        pub fn set_inner_horizontal(
            mut self,
            input: std::option::Option<crate::model::TableBorderOptions>,
        ) -> Self {
            self.inner_horizontal = input;
            self
        }
        /// <p>The table border options of the left border.</p>
        pub fn left(mut self, input: crate::model::TableBorderOptions) -> Self {
            self.left = Some(input);
            self
        }
        /// <p>The table border options of the left border.</p>
        pub fn set_left(
            mut self,
            input: std::option::Option<crate::model::TableBorderOptions>,
        ) -> Self {
            self.left = input;
            self
        }
        /// <p>The table border options of the right border.</p>
        pub fn right(mut self, input: crate::model::TableBorderOptions) -> Self {
            self.right = Some(input);
            self
        }
        /// <p>The table border options of the right border.</p>
        pub fn set_right(
            mut self,
            input: std::option::Option<crate::model::TableBorderOptions>,
        ) -> Self {
            self.right = input;
            self
        }
        /// <p>The table border options of the top border.</p>
        pub fn top(mut self, input: crate::model::TableBorderOptions) -> Self {
            self.top = Some(input);
            self
        }
        /// <p>The table border options of the top border.</p>
        pub fn set_top(
            mut self,
            input: std::option::Option<crate::model::TableBorderOptions>,
        ) -> Self {
            self.top = input;
            self
        }
        /// <p>The table border options of the bottom border.</p>
        pub fn bottom(mut self, input: crate::model::TableBorderOptions) -> Self {
            self.bottom = Some(input);
            self
        }
        /// <p>The table border options of the bottom border.</p>
        pub fn set_bottom(
            mut self,
            input: std::option::Option<crate::model::TableBorderOptions>,
        ) -> Self {
            self.bottom = input;
            self
        }
        /// Consumes the builder and constructs a [`TableSideBorderOptions`](crate::model::TableSideBorderOptions).
        pub fn build(self) -> crate::model::TableSideBorderOptions {
            crate::model::TableSideBorderOptions {
                inner_vertical: self.inner_vertical,
                inner_horizontal: self.inner_horizontal,
                left: self.left,
                right: self.right,
                top: self.top,
                bottom: self.bottom,
            }
        }
    }
}
impl TableSideBorderOptions {
    /// Creates a new builder-style object to manufacture [`TableSideBorderOptions`](crate::model::TableSideBorderOptions).
    pub fn builder() -> crate::model::table_side_border_options::Builder {
        crate::model::table_side_border_options::Builder::default()
    }
}

/// <p>The border options for a table border.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableBorderOptions {
    /// <p>The color of a table border.</p>
    #[doc(hidden)]
    pub color: std::option::Option<std::string::String>,
    /// <p>The thickness of a table border.</p>
    #[doc(hidden)]
    pub thickness: std::option::Option<i32>,
    /// <p>The style (none, solid) of a table border.</p>
    #[doc(hidden)]
    pub style: std::option::Option<crate::model::TableBorderStyle>,
}
impl TableBorderOptions {
    /// <p>The color of a table border.</p>
    pub fn color(&self) -> std::option::Option<&str> {
        self.color.as_deref()
    }
    /// <p>The thickness of a table border.</p>
    pub fn thickness(&self) -> std::option::Option<i32> {
        self.thickness
    }
    /// <p>The style (none, solid) of a table border.</p>
    pub fn style(&self) -> std::option::Option<&crate::model::TableBorderStyle> {
        self.style.as_ref()
    }
}
/// See [`TableBorderOptions`](crate::model::TableBorderOptions).
pub mod table_border_options {

    /// A builder for [`TableBorderOptions`](crate::model::TableBorderOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) color: std::option::Option<std::string::String>,
        pub(crate) thickness: std::option::Option<i32>,
        pub(crate) style: std::option::Option<crate::model::TableBorderStyle>,
    }
    impl Builder {
        /// <p>The color of a table border.</p>
        pub fn color(mut self, input: impl Into<std::string::String>) -> Self {
            self.color = Some(input.into());
            self
        }
        /// <p>The color of a table border.</p>
        pub fn set_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.color = input;
            self
        }
        /// <p>The thickness of a table border.</p>
        pub fn thickness(mut self, input: i32) -> Self {
            self.thickness = Some(input);
            self
        }
        /// <p>The thickness of a table border.</p>
        pub fn set_thickness(mut self, input: std::option::Option<i32>) -> Self {
            self.thickness = input;
            self
        }
        /// <p>The style (none, solid) of a table border.</p>
        pub fn style(mut self, input: crate::model::TableBorderStyle) -> Self {
            self.style = Some(input);
            self
        }
        /// <p>The style (none, solid) of a table border.</p>
        pub fn set_style(
            mut self,
            input: std::option::Option<crate::model::TableBorderStyle>,
        ) -> Self {
            self.style = input;
            self
        }
        /// Consumes the builder and constructs a [`TableBorderOptions`](crate::model::TableBorderOptions).
        pub fn build(self) -> crate::model::TableBorderOptions {
            crate::model::TableBorderOptions {
                color: self.color,
                thickness: self.thickness,
                style: self.style,
            }
        }
    }
}
impl TableBorderOptions {
    /// Creates a new builder-style object to manufacture [`TableBorderOptions`](crate::model::TableBorderOptions).
    pub fn builder() -> crate::model::table_border_options::Builder {
        crate::model::table_border_options::Builder::default()
    }
}

/// When writing a match expression against `TableBorderStyle`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let tableborderstyle = unimplemented!();
/// match tableborderstyle {
///     TableBorderStyle::None => { /* ... */ },
///     TableBorderStyle::Solid => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `tableborderstyle` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TableBorderStyle::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TableBorderStyle::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TableBorderStyle::NewFeature` is defined.
/// Specifically, when `tableborderstyle` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TableBorderStyle::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TableBorderStyle {
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Solid,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TableBorderStyle {
    fn from(s: &str) -> Self {
        match s {
            "NONE" => TableBorderStyle::None,
            "SOLID" => TableBorderStyle::Solid,
            other => TableBorderStyle::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TableBorderStyle {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TableBorderStyle::from(s))
    }
}
impl TableBorderStyle {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TableBorderStyle::None => "NONE",
            TableBorderStyle::Solid => "SOLID",
            TableBorderStyle::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NONE", "SOLID"]
    }
}
impl AsRef<str> for TableBorderStyle {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `VerticalTextAlignment`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let verticaltextalignment = unimplemented!();
/// match verticaltextalignment {
///     VerticalTextAlignment::Bottom => { /* ... */ },
///     VerticalTextAlignment::Middle => { /* ... */ },
///     VerticalTextAlignment::Top => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `verticaltextalignment` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VerticalTextAlignment::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VerticalTextAlignment::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VerticalTextAlignment::NewFeature` is defined.
/// Specifically, when `verticaltextalignment` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VerticalTextAlignment::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VerticalTextAlignment {
    #[allow(missing_docs)] // documentation missing in model
    Bottom,
    #[allow(missing_docs)] // documentation missing in model
    Middle,
    #[allow(missing_docs)] // documentation missing in model
    Top,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VerticalTextAlignment {
    fn from(s: &str) -> Self {
        match s {
            "BOTTOM" => VerticalTextAlignment::Bottom,
            "MIDDLE" => VerticalTextAlignment::Middle,
            "TOP" => VerticalTextAlignment::Top,
            other => {
                VerticalTextAlignment::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for VerticalTextAlignment {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VerticalTextAlignment::from(s))
    }
}
impl VerticalTextAlignment {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VerticalTextAlignment::Bottom => "BOTTOM",
            VerticalTextAlignment::Middle => "MIDDLE",
            VerticalTextAlignment::Top => "TOP",
            VerticalTextAlignment::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BOTTOM", "MIDDLE", "TOP"]
    }
}
impl AsRef<str> for VerticalTextAlignment {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TextWrap`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let textwrap = unimplemented!();
/// match textwrap {
///     TextWrap::None => { /* ... */ },
///     TextWrap::Wrap => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `textwrap` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TextWrap::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TextWrap::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TextWrap::NewFeature` is defined.
/// Specifically, when `textwrap` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TextWrap::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TextWrap {
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Wrap,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TextWrap {
    fn from(s: &str) -> Self {
        match s {
            "NONE" => TextWrap::None,
            "WRAP" => TextWrap::Wrap,
            other => TextWrap::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TextWrap {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TextWrap::from(s))
    }
}
impl TextWrap {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TextWrap::None => "NONE",
            TextWrap::Wrap => "WRAP",
            TextWrap::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NONE", "WRAP"]
    }
}
impl AsRef<str> for TextWrap {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TableTotalsScrollStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let tabletotalsscrollstatus = unimplemented!();
/// match tabletotalsscrollstatus {
///     TableTotalsScrollStatus::Pinned => { /* ... */ },
///     TableTotalsScrollStatus::Scrolled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `tabletotalsscrollstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TableTotalsScrollStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TableTotalsScrollStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TableTotalsScrollStatus::NewFeature` is defined.
/// Specifically, when `tabletotalsscrollstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TableTotalsScrollStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TableTotalsScrollStatus {
    #[allow(missing_docs)] // documentation missing in model
    Pinned,
    #[allow(missing_docs)] // documentation missing in model
    Scrolled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TableTotalsScrollStatus {
    fn from(s: &str) -> Self {
        match s {
            "PINNED" => TableTotalsScrollStatus::Pinned,
            "SCROLLED" => TableTotalsScrollStatus::Scrolled,
            other => TableTotalsScrollStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for TableTotalsScrollStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TableTotalsScrollStatus::from(s))
    }
}
impl TableTotalsScrollStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TableTotalsScrollStatus::Pinned => "PINNED",
            TableTotalsScrollStatus::Scrolled => "SCROLLED",
            TableTotalsScrollStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PINNED", "SCROLLED"]
    }
}
impl AsRef<str> for TableTotalsScrollStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TableTotalsPlacement`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let tabletotalsplacement = unimplemented!();
/// match tabletotalsplacement {
///     TableTotalsPlacement::End => { /* ... */ },
///     TableTotalsPlacement::Start => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `tabletotalsplacement` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TableTotalsPlacement::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TableTotalsPlacement::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TableTotalsPlacement::NewFeature` is defined.
/// Specifically, when `tabletotalsplacement` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TableTotalsPlacement::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TableTotalsPlacement {
    #[allow(missing_docs)] // documentation missing in model
    End,
    #[allow(missing_docs)] // documentation missing in model
    Start,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TableTotalsPlacement {
    fn from(s: &str) -> Self {
        match s {
            "END" => TableTotalsPlacement::End,
            "START" => TableTotalsPlacement::Start,
            other => {
                TableTotalsPlacement::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TableTotalsPlacement {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TableTotalsPlacement::from(s))
    }
}
impl TableTotalsPlacement {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TableTotalsPlacement::End => "END",
            TableTotalsPlacement::Start => "START",
            TableTotalsPlacement::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["END", "START"]
    }
}
impl AsRef<str> for TableTotalsPlacement {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The subtotal options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SubtotalOptions {
    /// <p>The visibility configuration for the subtotal cells.</p>
    #[doc(hidden)]
    pub totals_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The custom label string for the subtotal cells.</p>
    #[doc(hidden)]
    pub custom_label: std::option::Option<std::string::String>,
    /// <p>The field level (all, custom, last) for the subtotal cells.</p>
    #[doc(hidden)]
    pub field_level: std::option::Option<crate::model::PivotTableSubtotalLevel>,
    /// <p>The optional configuration of subtotal cells.</p>
    #[doc(hidden)]
    pub field_level_options:
        std::option::Option<std::vec::Vec<crate::model::PivotTableFieldSubtotalOptions>>,
    /// <p>The cell styling options for the subtotal cells.</p>
    #[doc(hidden)]
    pub total_cell_style: std::option::Option<crate::model::TableCellStyle>,
    /// <p>The cell styling options for the subtotals of value cells.</p>
    #[doc(hidden)]
    pub value_cell_style: std::option::Option<crate::model::TableCellStyle>,
    /// <p>The cell styling options for the subtotals of header cells.</p>
    #[doc(hidden)]
    pub metric_header_cell_style: std::option::Option<crate::model::TableCellStyle>,
}
impl SubtotalOptions {
    /// <p>The visibility configuration for the subtotal cells.</p>
    pub fn totals_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.totals_visibility.as_ref()
    }
    /// <p>The custom label string for the subtotal cells.</p>
    pub fn custom_label(&self) -> std::option::Option<&str> {
        self.custom_label.as_deref()
    }
    /// <p>The field level (all, custom, last) for the subtotal cells.</p>
    pub fn field_level(&self) -> std::option::Option<&crate::model::PivotTableSubtotalLevel> {
        self.field_level.as_ref()
    }
    /// <p>The optional configuration of subtotal cells.</p>
    pub fn field_level_options(
        &self,
    ) -> std::option::Option<&[crate::model::PivotTableFieldSubtotalOptions]> {
        self.field_level_options.as_deref()
    }
    /// <p>The cell styling options for the subtotal cells.</p>
    pub fn total_cell_style(&self) -> std::option::Option<&crate::model::TableCellStyle> {
        self.total_cell_style.as_ref()
    }
    /// <p>The cell styling options for the subtotals of value cells.</p>
    pub fn value_cell_style(&self) -> std::option::Option<&crate::model::TableCellStyle> {
        self.value_cell_style.as_ref()
    }
    /// <p>The cell styling options for the subtotals of header cells.</p>
    pub fn metric_header_cell_style(&self) -> std::option::Option<&crate::model::TableCellStyle> {
        self.metric_header_cell_style.as_ref()
    }
}
/// See [`SubtotalOptions`](crate::model::SubtotalOptions).
pub mod subtotal_options {

    /// A builder for [`SubtotalOptions`](crate::model::SubtotalOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) totals_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) custom_label: std::option::Option<std::string::String>,
        pub(crate) field_level: std::option::Option<crate::model::PivotTableSubtotalLevel>,
        pub(crate) field_level_options:
            std::option::Option<std::vec::Vec<crate::model::PivotTableFieldSubtotalOptions>>,
        pub(crate) total_cell_style: std::option::Option<crate::model::TableCellStyle>,
        pub(crate) value_cell_style: std::option::Option<crate::model::TableCellStyle>,
        pub(crate) metric_header_cell_style: std::option::Option<crate::model::TableCellStyle>,
    }
    impl Builder {
        /// <p>The visibility configuration for the subtotal cells.</p>
        pub fn totals_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.totals_visibility = Some(input);
            self
        }
        /// <p>The visibility configuration for the subtotal cells.</p>
        pub fn set_totals_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.totals_visibility = input;
            self
        }
        /// <p>The custom label string for the subtotal cells.</p>
        pub fn custom_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_label = Some(input.into());
            self
        }
        /// <p>The custom label string for the subtotal cells.</p>
        pub fn set_custom_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.custom_label = input;
            self
        }
        /// <p>The field level (all, custom, last) for the subtotal cells.</p>
        pub fn field_level(mut self, input: crate::model::PivotTableSubtotalLevel) -> Self {
            self.field_level = Some(input);
            self
        }
        /// <p>The field level (all, custom, last) for the subtotal cells.</p>
        pub fn set_field_level(
            mut self,
            input: std::option::Option<crate::model::PivotTableSubtotalLevel>,
        ) -> Self {
            self.field_level = input;
            self
        }
        /// Appends an item to `field_level_options`.
        ///
        /// To override the contents of this collection use [`set_field_level_options`](Self::set_field_level_options).
        ///
        /// <p>The optional configuration of subtotal cells.</p>
        pub fn field_level_options(
            mut self,
            input: crate::model::PivotTableFieldSubtotalOptions,
        ) -> Self {
            let mut v = self.field_level_options.unwrap_or_default();
            v.push(input);
            self.field_level_options = Some(v);
            self
        }
        /// <p>The optional configuration of subtotal cells.</p>
        pub fn set_field_level_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PivotTableFieldSubtotalOptions>>,
        ) -> Self {
            self.field_level_options = input;
            self
        }
        /// <p>The cell styling options for the subtotal cells.</p>
        pub fn total_cell_style(mut self, input: crate::model::TableCellStyle) -> Self {
            self.total_cell_style = Some(input);
            self
        }
        /// <p>The cell styling options for the subtotal cells.</p>
        pub fn set_total_cell_style(
            mut self,
            input: std::option::Option<crate::model::TableCellStyle>,
        ) -> Self {
            self.total_cell_style = input;
            self
        }
        /// <p>The cell styling options for the subtotals of value cells.</p>
        pub fn value_cell_style(mut self, input: crate::model::TableCellStyle) -> Self {
            self.value_cell_style = Some(input);
            self
        }
        /// <p>The cell styling options for the subtotals of value cells.</p>
        pub fn set_value_cell_style(
            mut self,
            input: std::option::Option<crate::model::TableCellStyle>,
        ) -> Self {
            self.value_cell_style = input;
            self
        }
        /// <p>The cell styling options for the subtotals of header cells.</p>
        pub fn metric_header_cell_style(mut self, input: crate::model::TableCellStyle) -> Self {
            self.metric_header_cell_style = Some(input);
            self
        }
        /// <p>The cell styling options for the subtotals of header cells.</p>
        pub fn set_metric_header_cell_style(
            mut self,
            input: std::option::Option<crate::model::TableCellStyle>,
        ) -> Self {
            self.metric_header_cell_style = input;
            self
        }
        /// Consumes the builder and constructs a [`SubtotalOptions`](crate::model::SubtotalOptions).
        pub fn build(self) -> crate::model::SubtotalOptions {
            crate::model::SubtotalOptions {
                totals_visibility: self.totals_visibility,
                custom_label: self.custom_label,
                field_level: self.field_level,
                field_level_options: self.field_level_options,
                total_cell_style: self.total_cell_style,
                value_cell_style: self.value_cell_style,
                metric_header_cell_style: self.metric_header_cell_style,
            }
        }
    }
}
impl SubtotalOptions {
    /// Creates a new builder-style object to manufacture [`SubtotalOptions`](crate::model::SubtotalOptions).
    pub fn builder() -> crate::model::subtotal_options::Builder {
        crate::model::subtotal_options::Builder::default()
    }
}

/// <p>The optional configuration of subtotals cells.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PivotTableFieldSubtotalOptions {
    /// <p>The field ID of the subtotal options.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
}
impl PivotTableFieldSubtotalOptions {
    /// <p>The field ID of the subtotal options.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
}
/// See [`PivotTableFieldSubtotalOptions`](crate::model::PivotTableFieldSubtotalOptions).
pub mod pivot_table_field_subtotal_options {

    /// A builder for [`PivotTableFieldSubtotalOptions`](crate::model::PivotTableFieldSubtotalOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The field ID of the subtotal options.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The field ID of the subtotal options.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PivotTableFieldSubtotalOptions`](crate::model::PivotTableFieldSubtotalOptions).
        pub fn build(self) -> crate::model::PivotTableFieldSubtotalOptions {
            crate::model::PivotTableFieldSubtotalOptions {
                field_id: self.field_id,
            }
        }
    }
}
impl PivotTableFieldSubtotalOptions {
    /// Creates a new builder-style object to manufacture [`PivotTableFieldSubtotalOptions`](crate::model::PivotTableFieldSubtotalOptions).
    pub fn builder() -> crate::model::pivot_table_field_subtotal_options::Builder {
        crate::model::pivot_table_field_subtotal_options::Builder::default()
    }
}

/// When writing a match expression against `PivotTableSubtotalLevel`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let pivottablesubtotallevel = unimplemented!();
/// match pivottablesubtotallevel {
///     PivotTableSubtotalLevel::All => { /* ... */ },
///     PivotTableSubtotalLevel::Custom => { /* ... */ },
///     PivotTableSubtotalLevel::Last => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `pivottablesubtotallevel` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PivotTableSubtotalLevel::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PivotTableSubtotalLevel::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PivotTableSubtotalLevel::NewFeature` is defined.
/// Specifically, when `pivottablesubtotallevel` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PivotTableSubtotalLevel::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PivotTableSubtotalLevel {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Custom,
    #[allow(missing_docs)] // documentation missing in model
    Last,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PivotTableSubtotalLevel {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => PivotTableSubtotalLevel::All,
            "CUSTOM" => PivotTableSubtotalLevel::Custom,
            "LAST" => PivotTableSubtotalLevel::Last,
            other => PivotTableSubtotalLevel::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for PivotTableSubtotalLevel {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PivotTableSubtotalLevel::from(s))
    }
}
impl PivotTableSubtotalLevel {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PivotTableSubtotalLevel::All => "ALL",
            PivotTableSubtotalLevel::Custom => "CUSTOM",
            PivotTableSubtotalLevel::Last => "LAST",
            PivotTableSubtotalLevel::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL", "CUSTOM", "LAST"]
    }
}
impl AsRef<str> for PivotTableSubtotalLevel {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The table options for a pivot table visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PivotTableOptions {
    /// <p>The metric placement (row, column) options.</p>
    #[doc(hidden)]
    pub metric_placement: std::option::Option<crate::model::PivotTableMetricPlacement>,
    /// <p>The visibility of the single metric options.</p>
    #[doc(hidden)]
    pub single_metric_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The visibility of the column names.</p>
    #[doc(hidden)]
    pub column_names_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>Determines the visibility of the pivot table.</p>
    #[doc(hidden)]
    pub toggle_buttons_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The table cell style of the column header.</p>
    #[doc(hidden)]
    pub column_header_style: std::option::Option<crate::model::TableCellStyle>,
    /// <p>The table cell style of the row headers.</p>
    #[doc(hidden)]
    pub row_header_style: std::option::Option<crate::model::TableCellStyle>,
    /// <p>The table cell style of cells.</p>
    #[doc(hidden)]
    pub cell_style: std::option::Option<crate::model::TableCellStyle>,
    /// <p>The table cell style of row field names.</p>
    #[doc(hidden)]
    pub row_field_names_style: std::option::Option<crate::model::TableCellStyle>,
    /// <p>The row alternate color options (widget status, row alternate colors).</p>
    #[doc(hidden)]
    pub row_alternate_color_options: std::option::Option<crate::model::RowAlternateColorOptions>,
}
impl PivotTableOptions {
    /// <p>The metric placement (row, column) options.</p>
    pub fn metric_placement(
        &self,
    ) -> std::option::Option<&crate::model::PivotTableMetricPlacement> {
        self.metric_placement.as_ref()
    }
    /// <p>The visibility of the single metric options.</p>
    pub fn single_metric_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.single_metric_visibility.as_ref()
    }
    /// <p>The visibility of the column names.</p>
    pub fn column_names_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.column_names_visibility.as_ref()
    }
    /// <p>Determines the visibility of the pivot table.</p>
    pub fn toggle_buttons_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.toggle_buttons_visibility.as_ref()
    }
    /// <p>The table cell style of the column header.</p>
    pub fn column_header_style(&self) -> std::option::Option<&crate::model::TableCellStyle> {
        self.column_header_style.as_ref()
    }
    /// <p>The table cell style of the row headers.</p>
    pub fn row_header_style(&self) -> std::option::Option<&crate::model::TableCellStyle> {
        self.row_header_style.as_ref()
    }
    /// <p>The table cell style of cells.</p>
    pub fn cell_style(&self) -> std::option::Option<&crate::model::TableCellStyle> {
        self.cell_style.as_ref()
    }
    /// <p>The table cell style of row field names.</p>
    pub fn row_field_names_style(&self) -> std::option::Option<&crate::model::TableCellStyle> {
        self.row_field_names_style.as_ref()
    }
    /// <p>The row alternate color options (widget status, row alternate colors).</p>
    pub fn row_alternate_color_options(
        &self,
    ) -> std::option::Option<&crate::model::RowAlternateColorOptions> {
        self.row_alternate_color_options.as_ref()
    }
}
/// See [`PivotTableOptions`](crate::model::PivotTableOptions).
pub mod pivot_table_options {

    /// A builder for [`PivotTableOptions`](crate::model::PivotTableOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_placement: std::option::Option<crate::model::PivotTableMetricPlacement>,
        pub(crate) single_metric_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) column_names_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) toggle_buttons_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) column_header_style: std::option::Option<crate::model::TableCellStyle>,
        pub(crate) row_header_style: std::option::Option<crate::model::TableCellStyle>,
        pub(crate) cell_style: std::option::Option<crate::model::TableCellStyle>,
        pub(crate) row_field_names_style: std::option::Option<crate::model::TableCellStyle>,
        pub(crate) row_alternate_color_options:
            std::option::Option<crate::model::RowAlternateColorOptions>,
    }
    impl Builder {
        /// <p>The metric placement (row, column) options.</p>
        pub fn metric_placement(mut self, input: crate::model::PivotTableMetricPlacement) -> Self {
            self.metric_placement = Some(input);
            self
        }
        /// <p>The metric placement (row, column) options.</p>
        pub fn set_metric_placement(
            mut self,
            input: std::option::Option<crate::model::PivotTableMetricPlacement>,
        ) -> Self {
            self.metric_placement = input;
            self
        }
        /// <p>The visibility of the single metric options.</p>
        pub fn single_metric_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.single_metric_visibility = Some(input);
            self
        }
        /// <p>The visibility of the single metric options.</p>
        pub fn set_single_metric_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.single_metric_visibility = input;
            self
        }
        /// <p>The visibility of the column names.</p>
        pub fn column_names_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.column_names_visibility = Some(input);
            self
        }
        /// <p>The visibility of the column names.</p>
        pub fn set_column_names_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.column_names_visibility = input;
            self
        }
        /// <p>Determines the visibility of the pivot table.</p>
        pub fn toggle_buttons_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.toggle_buttons_visibility = Some(input);
            self
        }
        /// <p>Determines the visibility of the pivot table.</p>
        pub fn set_toggle_buttons_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.toggle_buttons_visibility = input;
            self
        }
        /// <p>The table cell style of the column header.</p>
        pub fn column_header_style(mut self, input: crate::model::TableCellStyle) -> Self {
            self.column_header_style = Some(input);
            self
        }
        /// <p>The table cell style of the column header.</p>
        pub fn set_column_header_style(
            mut self,
            input: std::option::Option<crate::model::TableCellStyle>,
        ) -> Self {
            self.column_header_style = input;
            self
        }
        /// <p>The table cell style of the row headers.</p>
        pub fn row_header_style(mut self, input: crate::model::TableCellStyle) -> Self {
            self.row_header_style = Some(input);
            self
        }
        /// <p>The table cell style of the row headers.</p>
        pub fn set_row_header_style(
            mut self,
            input: std::option::Option<crate::model::TableCellStyle>,
        ) -> Self {
            self.row_header_style = input;
            self
        }
        /// <p>The table cell style of cells.</p>
        pub fn cell_style(mut self, input: crate::model::TableCellStyle) -> Self {
            self.cell_style = Some(input);
            self
        }
        /// <p>The table cell style of cells.</p>
        pub fn set_cell_style(
            mut self,
            input: std::option::Option<crate::model::TableCellStyle>,
        ) -> Self {
            self.cell_style = input;
            self
        }
        /// <p>The table cell style of row field names.</p>
        pub fn row_field_names_style(mut self, input: crate::model::TableCellStyle) -> Self {
            self.row_field_names_style = Some(input);
            self
        }
        /// <p>The table cell style of row field names.</p>
        pub fn set_row_field_names_style(
            mut self,
            input: std::option::Option<crate::model::TableCellStyle>,
        ) -> Self {
            self.row_field_names_style = input;
            self
        }
        /// <p>The row alternate color options (widget status, row alternate colors).</p>
        pub fn row_alternate_color_options(
            mut self,
            input: crate::model::RowAlternateColorOptions,
        ) -> Self {
            self.row_alternate_color_options = Some(input);
            self
        }
        /// <p>The row alternate color options (widget status, row alternate colors).</p>
        pub fn set_row_alternate_color_options(
            mut self,
            input: std::option::Option<crate::model::RowAlternateColorOptions>,
        ) -> Self {
            self.row_alternate_color_options = input;
            self
        }
        /// Consumes the builder and constructs a [`PivotTableOptions`](crate::model::PivotTableOptions).
        pub fn build(self) -> crate::model::PivotTableOptions {
            crate::model::PivotTableOptions {
                metric_placement: self.metric_placement,
                single_metric_visibility: self.single_metric_visibility,
                column_names_visibility: self.column_names_visibility,
                toggle_buttons_visibility: self.toggle_buttons_visibility,
                column_header_style: self.column_header_style,
                row_header_style: self.row_header_style,
                cell_style: self.cell_style,
                row_field_names_style: self.row_field_names_style,
                row_alternate_color_options: self.row_alternate_color_options,
            }
        }
    }
}
impl PivotTableOptions {
    /// Creates a new builder-style object to manufacture [`PivotTableOptions`](crate::model::PivotTableOptions).
    pub fn builder() -> crate::model::pivot_table_options::Builder {
        crate::model::pivot_table_options::Builder::default()
    }
}

/// <p>Determines the row alternate color options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RowAlternateColorOptions {
    /// <p>Determines the widget status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::WidgetStatus>,
    /// <p>Determines the list of row alternate colors.</p>
    #[doc(hidden)]
    pub row_alternate_colors: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl RowAlternateColorOptions {
    /// <p>Determines the widget status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::WidgetStatus> {
        self.status.as_ref()
    }
    /// <p>Determines the list of row alternate colors.</p>
    pub fn row_alternate_colors(&self) -> std::option::Option<&[std::string::String]> {
        self.row_alternate_colors.as_deref()
    }
}
/// See [`RowAlternateColorOptions`](crate::model::RowAlternateColorOptions).
pub mod row_alternate_color_options {

    /// A builder for [`RowAlternateColorOptions`](crate::model::RowAlternateColorOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::WidgetStatus>,
        pub(crate) row_alternate_colors: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Determines the widget status.</p>
        pub fn status(mut self, input: crate::model::WidgetStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Determines the widget status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::WidgetStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `row_alternate_colors`.
        ///
        /// To override the contents of this collection use [`set_row_alternate_colors`](Self::set_row_alternate_colors).
        ///
        /// <p>Determines the list of row alternate colors.</p>
        pub fn row_alternate_colors(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.row_alternate_colors.unwrap_or_default();
            v.push(input.into());
            self.row_alternate_colors = Some(v);
            self
        }
        /// <p>Determines the list of row alternate colors.</p>
        pub fn set_row_alternate_colors(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.row_alternate_colors = input;
            self
        }
        /// Consumes the builder and constructs a [`RowAlternateColorOptions`](crate::model::RowAlternateColorOptions).
        pub fn build(self) -> crate::model::RowAlternateColorOptions {
            crate::model::RowAlternateColorOptions {
                status: self.status,
                row_alternate_colors: self.row_alternate_colors,
            }
        }
    }
}
impl RowAlternateColorOptions {
    /// Creates a new builder-style object to manufacture [`RowAlternateColorOptions`](crate::model::RowAlternateColorOptions).
    pub fn builder() -> crate::model::row_alternate_color_options::Builder {
        crate::model::row_alternate_color_options::Builder::default()
    }
}

/// When writing a match expression against `PivotTableMetricPlacement`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let pivottablemetricplacement = unimplemented!();
/// match pivottablemetricplacement {
///     PivotTableMetricPlacement::Column => { /* ... */ },
///     PivotTableMetricPlacement::Row => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `pivottablemetricplacement` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PivotTableMetricPlacement::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PivotTableMetricPlacement::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PivotTableMetricPlacement::NewFeature` is defined.
/// Specifically, when `pivottablemetricplacement` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PivotTableMetricPlacement::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PivotTableMetricPlacement {
    #[allow(missing_docs)] // documentation missing in model
    Column,
    #[allow(missing_docs)] // documentation missing in model
    Row,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PivotTableMetricPlacement {
    fn from(s: &str) -> Self {
        match s {
            "COLUMN" => PivotTableMetricPlacement::Column,
            "ROW" => PivotTableMetricPlacement::Row,
            other => PivotTableMetricPlacement::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for PivotTableMetricPlacement {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PivotTableMetricPlacement::from(s))
    }
}
impl PivotTableMetricPlacement {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PivotTableMetricPlacement::Column => "COLUMN",
            PivotTableMetricPlacement::Row => "ROW",
            PivotTableMetricPlacement::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COLUMN", "ROW"]
    }
}
impl AsRef<str> for PivotTableMetricPlacement {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The sort configuration for a <code>PivotTableVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PivotTableSortConfiguration {
    /// <p>The field sort options for a pivot table sort configuration.</p>
    #[doc(hidden)]
    pub field_sort_options: std::option::Option<std::vec::Vec<crate::model::PivotFieldSortOptions>>,
}
impl PivotTableSortConfiguration {
    /// <p>The field sort options for a pivot table sort configuration.</p>
    pub fn field_sort_options(
        &self,
    ) -> std::option::Option<&[crate::model::PivotFieldSortOptions]> {
        self.field_sort_options.as_deref()
    }
}
/// See [`PivotTableSortConfiguration`](crate::model::PivotTableSortConfiguration).
pub mod pivot_table_sort_configuration {

    /// A builder for [`PivotTableSortConfiguration`](crate::model::PivotTableSortConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_sort_options:
            std::option::Option<std::vec::Vec<crate::model::PivotFieldSortOptions>>,
    }
    impl Builder {
        /// Appends an item to `field_sort_options`.
        ///
        /// To override the contents of this collection use [`set_field_sort_options`](Self::set_field_sort_options).
        ///
        /// <p>The field sort options for a pivot table sort configuration.</p>
        pub fn field_sort_options(mut self, input: crate::model::PivotFieldSortOptions) -> Self {
            let mut v = self.field_sort_options.unwrap_or_default();
            v.push(input);
            self.field_sort_options = Some(v);
            self
        }
        /// <p>The field sort options for a pivot table sort configuration.</p>
        pub fn set_field_sort_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PivotFieldSortOptions>>,
        ) -> Self {
            self.field_sort_options = input;
            self
        }
        /// Consumes the builder and constructs a [`PivotTableSortConfiguration`](crate::model::PivotTableSortConfiguration).
        pub fn build(self) -> crate::model::PivotTableSortConfiguration {
            crate::model::PivotTableSortConfiguration {
                field_sort_options: self.field_sort_options,
            }
        }
    }
}
impl PivotTableSortConfiguration {
    /// Creates a new builder-style object to manufacture [`PivotTableSortConfiguration`](crate::model::PivotTableSortConfiguration).
    pub fn builder() -> crate::model::pivot_table_sort_configuration::Builder {
        crate::model::pivot_table_sort_configuration::Builder::default()
    }
}

/// <p>The field sort options for a pivot table sort configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PivotFieldSortOptions {
    /// <p>The field ID for the field sort options.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The sort by field for the field sort options.</p>
    #[doc(hidden)]
    pub sort_by: std::option::Option<crate::model::PivotTableSortBy>,
}
impl PivotFieldSortOptions {
    /// <p>The field ID for the field sort options.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The sort by field for the field sort options.</p>
    pub fn sort_by(&self) -> std::option::Option<&crate::model::PivotTableSortBy> {
        self.sort_by.as_ref()
    }
}
/// See [`PivotFieldSortOptions`](crate::model::PivotFieldSortOptions).
pub mod pivot_field_sort_options {

    /// A builder for [`PivotFieldSortOptions`](crate::model::PivotFieldSortOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) sort_by: std::option::Option<crate::model::PivotTableSortBy>,
    }
    impl Builder {
        /// <p>The field ID for the field sort options.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The field ID for the field sort options.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The sort by field for the field sort options.</p>
        pub fn sort_by(mut self, input: crate::model::PivotTableSortBy) -> Self {
            self.sort_by = Some(input);
            self
        }
        /// <p>The sort by field for the field sort options.</p>
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::PivotTableSortBy>,
        ) -> Self {
            self.sort_by = input;
            self
        }
        /// Consumes the builder and constructs a [`PivotFieldSortOptions`](crate::model::PivotFieldSortOptions).
        pub fn build(self) -> crate::model::PivotFieldSortOptions {
            crate::model::PivotFieldSortOptions {
                field_id: self.field_id,
                sort_by: self.sort_by,
            }
        }
    }
}
impl PivotFieldSortOptions {
    /// Creates a new builder-style object to manufacture [`PivotFieldSortOptions`](crate::model::PivotFieldSortOptions).
    pub fn builder() -> crate::model::pivot_field_sort_options::Builder {
        crate::model::pivot_field_sort_options::Builder::default()
    }
}

/// <p>The sort by field for the field sort options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PivotTableSortBy {
    /// <p>The field sort (field id, direction) for the pivot table sort by options.</p>
    #[doc(hidden)]
    pub field: std::option::Option<crate::model::FieldSort>,
    /// <p>The column sort (field id, direction) for the pivot table sort by options.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnSort>,
    /// <p>The data path sort (data path value, direction) for the pivot table sort by options.</p>
    #[doc(hidden)]
    pub data_path: std::option::Option<crate::model::DataPathSort>,
}
impl PivotTableSortBy {
    /// <p>The field sort (field id, direction) for the pivot table sort by options.</p>
    pub fn field(&self) -> std::option::Option<&crate::model::FieldSort> {
        self.field.as_ref()
    }
    /// <p>The column sort (field id, direction) for the pivot table sort by options.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnSort> {
        self.column.as_ref()
    }
    /// <p>The data path sort (data path value, direction) for the pivot table sort by options.</p>
    pub fn data_path(&self) -> std::option::Option<&crate::model::DataPathSort> {
        self.data_path.as_ref()
    }
}
/// See [`PivotTableSortBy`](crate::model::PivotTableSortBy).
pub mod pivot_table_sort_by {

    /// A builder for [`PivotTableSortBy`](crate::model::PivotTableSortBy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field: std::option::Option<crate::model::FieldSort>,
        pub(crate) column: std::option::Option<crate::model::ColumnSort>,
        pub(crate) data_path: std::option::Option<crate::model::DataPathSort>,
    }
    impl Builder {
        /// <p>The field sort (field id, direction) for the pivot table sort by options.</p>
        pub fn field(mut self, input: crate::model::FieldSort) -> Self {
            self.field = Some(input);
            self
        }
        /// <p>The field sort (field id, direction) for the pivot table sort by options.</p>
        pub fn set_field(mut self, input: std::option::Option<crate::model::FieldSort>) -> Self {
            self.field = input;
            self
        }
        /// <p>The column sort (field id, direction) for the pivot table sort by options.</p>
        pub fn column(mut self, input: crate::model::ColumnSort) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column sort (field id, direction) for the pivot table sort by options.</p>
        pub fn set_column(mut self, input: std::option::Option<crate::model::ColumnSort>) -> Self {
            self.column = input;
            self
        }
        /// <p>The data path sort (data path value, direction) for the pivot table sort by options.</p>
        pub fn data_path(mut self, input: crate::model::DataPathSort) -> Self {
            self.data_path = Some(input);
            self
        }
        /// <p>The data path sort (data path value, direction) for the pivot table sort by options.</p>
        pub fn set_data_path(
            mut self,
            input: std::option::Option<crate::model::DataPathSort>,
        ) -> Self {
            self.data_path = input;
            self
        }
        /// Consumes the builder and constructs a [`PivotTableSortBy`](crate::model::PivotTableSortBy).
        pub fn build(self) -> crate::model::PivotTableSortBy {
            crate::model::PivotTableSortBy {
                field: self.field,
                column: self.column,
                data_path: self.data_path,
            }
        }
    }
}
impl PivotTableSortBy {
    /// Creates a new builder-style object to manufacture [`PivotTableSortBy`](crate::model::PivotTableSortBy).
    pub fn builder() -> crate::model::pivot_table_sort_by::Builder {
        crate::model::pivot_table_sort_by::Builder::default()
    }
}

/// <p>Allows data paths to be sorted by a specific data value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataPathSort {
    /// <p>Determines the sort direction.</p>
    #[doc(hidden)]
    pub direction: std::option::Option<crate::model::SortDirection>,
    /// <p>The list of data paths that need to be sorted.</p>
    #[doc(hidden)]
    pub sort_paths: std::option::Option<std::vec::Vec<crate::model::DataPathValue>>,
}
impl DataPathSort {
    /// <p>Determines the sort direction.</p>
    pub fn direction(&self) -> std::option::Option<&crate::model::SortDirection> {
        self.direction.as_ref()
    }
    /// <p>The list of data paths that need to be sorted.</p>
    pub fn sort_paths(&self) -> std::option::Option<&[crate::model::DataPathValue]> {
        self.sort_paths.as_deref()
    }
}
/// See [`DataPathSort`](crate::model::DataPathSort).
pub mod data_path_sort {

    /// A builder for [`DataPathSort`](crate::model::DataPathSort).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) direction: std::option::Option<crate::model::SortDirection>,
        pub(crate) sort_paths: std::option::Option<std::vec::Vec<crate::model::DataPathValue>>,
    }
    impl Builder {
        /// <p>Determines the sort direction.</p>
        pub fn direction(mut self, input: crate::model::SortDirection) -> Self {
            self.direction = Some(input);
            self
        }
        /// <p>Determines the sort direction.</p>
        pub fn set_direction(
            mut self,
            input: std::option::Option<crate::model::SortDirection>,
        ) -> Self {
            self.direction = input;
            self
        }
        /// Appends an item to `sort_paths`.
        ///
        /// To override the contents of this collection use [`set_sort_paths`](Self::set_sort_paths).
        ///
        /// <p>The list of data paths that need to be sorted.</p>
        pub fn sort_paths(mut self, input: crate::model::DataPathValue) -> Self {
            let mut v = self.sort_paths.unwrap_or_default();
            v.push(input);
            self.sort_paths = Some(v);
            self
        }
        /// <p>The list of data paths that need to be sorted.</p>
        pub fn set_sort_paths(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataPathValue>>,
        ) -> Self {
            self.sort_paths = input;
            self
        }
        /// Consumes the builder and constructs a [`DataPathSort`](crate::model::DataPathSort).
        pub fn build(self) -> crate::model::DataPathSort {
            crate::model::DataPathSort {
                direction: self.direction,
                sort_paths: self.sort_paths,
            }
        }
    }
}
impl DataPathSort {
    /// Creates a new builder-style object to manufacture [`DataPathSort`](crate::model::DataPathSort).
    pub fn builder() -> crate::model::data_path_sort::Builder {
        crate::model::data_path_sort::Builder::default()
    }
}

/// <p>The field wells for a pivot table visual.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PivotTableFieldWells {
    /// <p>The aggregated field well for the pivot table.</p>
    #[doc(hidden)]
    pub pivot_table_aggregated_field_wells:
        std::option::Option<crate::model::PivotTableAggregatedFieldWells>,
}
impl PivotTableFieldWells {
    /// <p>The aggregated field well for the pivot table.</p>
    pub fn pivot_table_aggregated_field_wells(
        &self,
    ) -> std::option::Option<&crate::model::PivotTableAggregatedFieldWells> {
        self.pivot_table_aggregated_field_wells.as_ref()
    }
}
/// See [`PivotTableFieldWells`](crate::model::PivotTableFieldWells).
pub mod pivot_table_field_wells {

    /// A builder for [`PivotTableFieldWells`](crate::model::PivotTableFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pivot_table_aggregated_field_wells:
            std::option::Option<crate::model::PivotTableAggregatedFieldWells>,
    }
    impl Builder {
        /// <p>The aggregated field well for the pivot table.</p>
        pub fn pivot_table_aggregated_field_wells(
            mut self,
            input: crate::model::PivotTableAggregatedFieldWells,
        ) -> Self {
            self.pivot_table_aggregated_field_wells = Some(input);
            self
        }
        /// <p>The aggregated field well for the pivot table.</p>
        pub fn set_pivot_table_aggregated_field_wells(
            mut self,
            input: std::option::Option<crate::model::PivotTableAggregatedFieldWells>,
        ) -> Self {
            self.pivot_table_aggregated_field_wells = input;
            self
        }
        /// Consumes the builder and constructs a [`PivotTableFieldWells`](crate::model::PivotTableFieldWells).
        pub fn build(self) -> crate::model::PivotTableFieldWells {
            crate::model::PivotTableFieldWells {
                pivot_table_aggregated_field_wells: self.pivot_table_aggregated_field_wells,
            }
        }
    }
}
impl PivotTableFieldWells {
    /// Creates a new builder-style object to manufacture [`PivotTableFieldWells`](crate::model::PivotTableFieldWells).
    pub fn builder() -> crate::model::pivot_table_field_wells::Builder {
        crate::model::pivot_table_field_wells::Builder::default()
    }
}

/// <p>The aggregated field well for the pivot table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PivotTableAggregatedFieldWells {
    /// <p>The rows field well for a pivot table. Values are grouped by rows fields.</p>
    #[doc(hidden)]
    pub rows: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The columns field well for a pivot table. Values are grouped by columns fields.</p>
    #[doc(hidden)]
    pub columns: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The values field well for a pivot table. Values are aggregated based on rows and columns fields.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
}
impl PivotTableAggregatedFieldWells {
    /// <p>The rows field well for a pivot table. Values are grouped by rows fields.</p>
    pub fn rows(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.rows.as_deref()
    }
    /// <p>The columns field well for a pivot table. Values are grouped by columns fields.</p>
    pub fn columns(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.columns.as_deref()
    }
    /// <p>The values field well for a pivot table. Values are aggregated based on rows and columns fields.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.values.as_deref()
    }
}
/// See [`PivotTableAggregatedFieldWells`](crate::model::PivotTableAggregatedFieldWells).
pub mod pivot_table_aggregated_field_wells {

    /// A builder for [`PivotTableAggregatedFieldWells`](crate::model::PivotTableAggregatedFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rows: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) columns: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    }
    impl Builder {
        /// Appends an item to `rows`.
        ///
        /// To override the contents of this collection use [`set_rows`](Self::set_rows).
        ///
        /// <p>The rows field well for a pivot table. Values are grouped by rows fields.</p>
        pub fn rows(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.rows.unwrap_or_default();
            v.push(input);
            self.rows = Some(v);
            self
        }
        /// <p>The rows field well for a pivot table. Values are grouped by rows fields.</p>
        pub fn set_rows(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.rows = input;
            self
        }
        /// Appends an item to `columns`.
        ///
        /// To override the contents of this collection use [`set_columns`](Self::set_columns).
        ///
        /// <p>The columns field well for a pivot table. Values are grouped by columns fields.</p>
        pub fn columns(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.columns.unwrap_or_default();
            v.push(input);
            self.columns = Some(v);
            self
        }
        /// <p>The columns field well for a pivot table. Values are grouped by columns fields.</p>
        pub fn set_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.columns = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The values field well for a pivot table. Values are aggregated based on rows and columns fields.</p>
        pub fn values(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>The values field well for a pivot table. Values are aggregated based on rows and columns fields.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`PivotTableAggregatedFieldWells`](crate::model::PivotTableAggregatedFieldWells).
        pub fn build(self) -> crate::model::PivotTableAggregatedFieldWells {
            crate::model::PivotTableAggregatedFieldWells {
                rows: self.rows,
                columns: self.columns,
                values: self.values,
            }
        }
    }
}
impl PivotTableAggregatedFieldWells {
    /// Creates a new builder-style object to manufacture [`PivotTableAggregatedFieldWells`](crate::model::PivotTableAggregatedFieldWells).
    pub fn builder() -> crate::model::pivot_table_aggregated_field_wells::Builder {
        crate::model::pivot_table_aggregated_field_wells::Builder::default()
    }
}

/// <p>A table visual.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/tabular.html">Using tables as visuals</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
    /// <p>The title that is displayed on the visual.</p>
    #[doc(hidden)]
    pub title: std::option::Option<crate::model::VisualTitleLabelOptions>,
    /// <p>The subtitle that is displayed on the visual.</p>
    #[doc(hidden)]
    pub subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
    /// <p>The configuration settings of the visual.</p>
    #[doc(hidden)]
    pub chart_configuration: std::option::Option<crate::model::TableConfiguration>,
    /// <p>The conditional formatting for a <code>PivotTableVisual</code>.</p>
    #[doc(hidden)]
    pub conditional_formatting: std::option::Option<crate::model::TableConditionalFormatting>,
    /// <p>The list of custom actions that are configured for a visual.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
}
impl TableVisual {
    /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
    /// <p>The title that is displayed on the visual.</p>
    pub fn title(&self) -> std::option::Option<&crate::model::VisualTitleLabelOptions> {
        self.title.as_ref()
    }
    /// <p>The subtitle that is displayed on the visual.</p>
    pub fn subtitle(&self) -> std::option::Option<&crate::model::VisualSubtitleLabelOptions> {
        self.subtitle.as_ref()
    }
    /// <p>The configuration settings of the visual.</p>
    pub fn chart_configuration(&self) -> std::option::Option<&crate::model::TableConfiguration> {
        self.chart_configuration.as_ref()
    }
    /// <p>The conditional formatting for a <code>PivotTableVisual</code>.</p>
    pub fn conditional_formatting(
        &self,
    ) -> std::option::Option<&crate::model::TableConditionalFormatting> {
        self.conditional_formatting.as_ref()
    }
    /// <p>The list of custom actions that are configured for a visual.</p>
    pub fn actions(&self) -> std::option::Option<&[crate::model::VisualCustomAction]> {
        self.actions.as_deref()
    }
}
/// See [`TableVisual`](crate::model::TableVisual).
pub mod table_visual {

    /// A builder for [`TableVisual`](crate::model::TableVisual).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visual_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<crate::model::VisualTitleLabelOptions>,
        pub(crate) subtitle: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        pub(crate) chart_configuration: std::option::Option<crate::model::TableConfiguration>,
        pub(crate) conditional_formatting:
            std::option::Option<crate::model::TableConditionalFormatting>,
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
    }
    impl Builder {
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn title(mut self, input: crate::model::VisualTitleLabelOptions) -> Self {
            self.title = Some(input);
            self
        }
        /// <p>The title that is displayed on the visual.</p>
        pub fn set_title(
            mut self,
            input: std::option::Option<crate::model::VisualTitleLabelOptions>,
        ) -> Self {
            self.title = input;
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn subtitle(mut self, input: crate::model::VisualSubtitleLabelOptions) -> Self {
            self.subtitle = Some(input);
            self
        }
        /// <p>The subtitle that is displayed on the visual.</p>
        pub fn set_subtitle(
            mut self,
            input: std::option::Option<crate::model::VisualSubtitleLabelOptions>,
        ) -> Self {
            self.subtitle = input;
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn chart_configuration(mut self, input: crate::model::TableConfiguration) -> Self {
            self.chart_configuration = Some(input);
            self
        }
        /// <p>The configuration settings of the visual.</p>
        pub fn set_chart_configuration(
            mut self,
            input: std::option::Option<crate::model::TableConfiguration>,
        ) -> Self {
            self.chart_configuration = input;
            self
        }
        /// <p>The conditional formatting for a <code>PivotTableVisual</code>.</p>
        pub fn conditional_formatting(
            mut self,
            input: crate::model::TableConditionalFormatting,
        ) -> Self {
            self.conditional_formatting = Some(input);
            self
        }
        /// <p>The conditional formatting for a <code>PivotTableVisual</code>.</p>
        pub fn set_conditional_formatting(
            mut self,
            input: std::option::Option<crate::model::TableConditionalFormatting>,
        ) -> Self {
            self.conditional_formatting = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn actions(mut self, input: crate::model::VisualCustomAction) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input);
            self.actions = Some(v);
            self
        }
        /// <p>The list of custom actions that are configured for a visual.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VisualCustomAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Consumes the builder and constructs a [`TableVisual`](crate::model::TableVisual).
        pub fn build(self) -> crate::model::TableVisual {
            crate::model::TableVisual {
                visual_id: self.visual_id,
                title: self.title,
                subtitle: self.subtitle,
                chart_configuration: self.chart_configuration,
                conditional_formatting: self.conditional_formatting,
                actions: self.actions,
            }
        }
    }
}
impl TableVisual {
    /// Creates a new builder-style object to manufacture [`TableVisual`](crate::model::TableVisual).
    pub fn builder() -> crate::model::table_visual::Builder {
        crate::model::table_visual::Builder::default()
    }
}

/// <p>The conditional formatting for a <code>PivotTableVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableConditionalFormatting {
    /// <p>Conditional formatting options for a <code>PivotTableVisual</code>.</p>
    #[doc(hidden)]
    pub conditional_formatting_options:
        std::option::Option<std::vec::Vec<crate::model::TableConditionalFormattingOption>>,
}
impl TableConditionalFormatting {
    /// <p>Conditional formatting options for a <code>PivotTableVisual</code>.</p>
    pub fn conditional_formatting_options(
        &self,
    ) -> std::option::Option<&[crate::model::TableConditionalFormattingOption]> {
        self.conditional_formatting_options.as_deref()
    }
}
/// See [`TableConditionalFormatting`](crate::model::TableConditionalFormatting).
pub mod table_conditional_formatting {

    /// A builder for [`TableConditionalFormatting`](crate::model::TableConditionalFormatting).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) conditional_formatting_options:
            std::option::Option<std::vec::Vec<crate::model::TableConditionalFormattingOption>>,
    }
    impl Builder {
        /// Appends an item to `conditional_formatting_options`.
        ///
        /// To override the contents of this collection use [`set_conditional_formatting_options`](Self::set_conditional_formatting_options).
        ///
        /// <p>Conditional formatting options for a <code>PivotTableVisual</code>.</p>
        pub fn conditional_formatting_options(
            mut self,
            input: crate::model::TableConditionalFormattingOption,
        ) -> Self {
            let mut v = self.conditional_formatting_options.unwrap_or_default();
            v.push(input);
            self.conditional_formatting_options = Some(v);
            self
        }
        /// <p>Conditional formatting options for a <code>PivotTableVisual</code>.</p>
        pub fn set_conditional_formatting_options(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::TableConditionalFormattingOption>,
            >,
        ) -> Self {
            self.conditional_formatting_options = input;
            self
        }
        /// Consumes the builder and constructs a [`TableConditionalFormatting`](crate::model::TableConditionalFormatting).
        pub fn build(self) -> crate::model::TableConditionalFormatting {
            crate::model::TableConditionalFormatting {
                conditional_formatting_options: self.conditional_formatting_options,
            }
        }
    }
}
impl TableConditionalFormatting {
    /// Creates a new builder-style object to manufacture [`TableConditionalFormatting`](crate::model::TableConditionalFormatting).
    pub fn builder() -> crate::model::table_conditional_formatting::Builder {
        crate::model::table_conditional_formatting::Builder::default()
    }
}

/// <p>Conditional formatting options for a <code>PivotTableVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableConditionalFormattingOption {
    /// <p>The cell conditional formatting option for a table.</p>
    #[doc(hidden)]
    pub cell: std::option::Option<crate::model::TableCellConditionalFormatting>,
    /// <p>The row conditional formatting option for a table.</p>
    #[doc(hidden)]
    pub row: std::option::Option<crate::model::TableRowConditionalFormatting>,
}
impl TableConditionalFormattingOption {
    /// <p>The cell conditional formatting option for a table.</p>
    pub fn cell(&self) -> std::option::Option<&crate::model::TableCellConditionalFormatting> {
        self.cell.as_ref()
    }
    /// <p>The row conditional formatting option for a table.</p>
    pub fn row(&self) -> std::option::Option<&crate::model::TableRowConditionalFormatting> {
        self.row.as_ref()
    }
}
/// See [`TableConditionalFormattingOption`](crate::model::TableConditionalFormattingOption).
pub mod table_conditional_formatting_option {

    /// A builder for [`TableConditionalFormattingOption`](crate::model::TableConditionalFormattingOption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cell: std::option::Option<crate::model::TableCellConditionalFormatting>,
        pub(crate) row: std::option::Option<crate::model::TableRowConditionalFormatting>,
    }
    impl Builder {
        /// <p>The cell conditional formatting option for a table.</p>
        pub fn cell(mut self, input: crate::model::TableCellConditionalFormatting) -> Self {
            self.cell = Some(input);
            self
        }
        /// <p>The cell conditional formatting option for a table.</p>
        pub fn set_cell(
            mut self,
            input: std::option::Option<crate::model::TableCellConditionalFormatting>,
        ) -> Self {
            self.cell = input;
            self
        }
        /// <p>The row conditional formatting option for a table.</p>
        pub fn row(mut self, input: crate::model::TableRowConditionalFormatting) -> Self {
            self.row = Some(input);
            self
        }
        /// <p>The row conditional formatting option for a table.</p>
        pub fn set_row(
            mut self,
            input: std::option::Option<crate::model::TableRowConditionalFormatting>,
        ) -> Self {
            self.row = input;
            self
        }
        /// Consumes the builder and constructs a [`TableConditionalFormattingOption`](crate::model::TableConditionalFormattingOption).
        pub fn build(self) -> crate::model::TableConditionalFormattingOption {
            crate::model::TableConditionalFormattingOption {
                cell: self.cell,
                row: self.row,
            }
        }
    }
}
impl TableConditionalFormattingOption {
    /// Creates a new builder-style object to manufacture [`TableConditionalFormattingOption`](crate::model::TableConditionalFormattingOption).
    pub fn builder() -> crate::model::table_conditional_formatting_option::Builder {
        crate::model::table_conditional_formatting_option::Builder::default()
    }
}

/// <p>The conditional formatting of a table row.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableRowConditionalFormatting {
    /// <p>The conditional formatting color (solid, gradient) of the background for a table row.</p>
    #[doc(hidden)]
    pub background_color: std::option::Option<crate::model::ConditionalFormattingColor>,
    /// <p>The conditional formatting color (solid, gradient) of the text for a table row.</p>
    #[doc(hidden)]
    pub text_color: std::option::Option<crate::model::ConditionalFormattingColor>,
}
impl TableRowConditionalFormatting {
    /// <p>The conditional formatting color (solid, gradient) of the background for a table row.</p>
    pub fn background_color(
        &self,
    ) -> std::option::Option<&crate::model::ConditionalFormattingColor> {
        self.background_color.as_ref()
    }
    /// <p>The conditional formatting color (solid, gradient) of the text for a table row.</p>
    pub fn text_color(&self) -> std::option::Option<&crate::model::ConditionalFormattingColor> {
        self.text_color.as_ref()
    }
}
/// See [`TableRowConditionalFormatting`](crate::model::TableRowConditionalFormatting).
pub mod table_row_conditional_formatting {

    /// A builder for [`TableRowConditionalFormatting`](crate::model::TableRowConditionalFormatting).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) background_color: std::option::Option<crate::model::ConditionalFormattingColor>,
        pub(crate) text_color: std::option::Option<crate::model::ConditionalFormattingColor>,
    }
    impl Builder {
        /// <p>The conditional formatting color (solid, gradient) of the background for a table row.</p>
        pub fn background_color(mut self, input: crate::model::ConditionalFormattingColor) -> Self {
            self.background_color = Some(input);
            self
        }
        /// <p>The conditional formatting color (solid, gradient) of the background for a table row.</p>
        pub fn set_background_color(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingColor>,
        ) -> Self {
            self.background_color = input;
            self
        }
        /// <p>The conditional formatting color (solid, gradient) of the text for a table row.</p>
        pub fn text_color(mut self, input: crate::model::ConditionalFormattingColor) -> Self {
            self.text_color = Some(input);
            self
        }
        /// <p>The conditional formatting color (solid, gradient) of the text for a table row.</p>
        pub fn set_text_color(
            mut self,
            input: std::option::Option<crate::model::ConditionalFormattingColor>,
        ) -> Self {
            self.text_color = input;
            self
        }
        /// Consumes the builder and constructs a [`TableRowConditionalFormatting`](crate::model::TableRowConditionalFormatting).
        pub fn build(self) -> crate::model::TableRowConditionalFormatting {
            crate::model::TableRowConditionalFormatting {
                background_color: self.background_color,
                text_color: self.text_color,
            }
        }
    }
}
impl TableRowConditionalFormatting {
    /// Creates a new builder-style object to manufacture [`TableRowConditionalFormatting`](crate::model::TableRowConditionalFormatting).
    pub fn builder() -> crate::model::table_row_conditional_formatting::Builder {
        crate::model::table_row_conditional_formatting::Builder::default()
    }
}

/// <p>The cell conditional formatting option for a table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableCellConditionalFormatting {
    /// <p>The field ID of the cell for conditional formatting.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The text format of the cell for conditional formatting.</p>
    #[doc(hidden)]
    pub text_format: std::option::Option<crate::model::TextConditionalFormat>,
}
impl TableCellConditionalFormatting {
    /// <p>The field ID of the cell for conditional formatting.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The text format of the cell for conditional formatting.</p>
    pub fn text_format(&self) -> std::option::Option<&crate::model::TextConditionalFormat> {
        self.text_format.as_ref()
    }
}
/// See [`TableCellConditionalFormatting`](crate::model::TableCellConditionalFormatting).
pub mod table_cell_conditional_formatting {

    /// A builder for [`TableCellConditionalFormatting`](crate::model::TableCellConditionalFormatting).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) text_format: std::option::Option<crate::model::TextConditionalFormat>,
    }
    impl Builder {
        /// <p>The field ID of the cell for conditional formatting.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The field ID of the cell for conditional formatting.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The text format of the cell for conditional formatting.</p>
        pub fn text_format(mut self, input: crate::model::TextConditionalFormat) -> Self {
            self.text_format = Some(input);
            self
        }
        /// <p>The text format of the cell for conditional formatting.</p>
        pub fn set_text_format(
            mut self,
            input: std::option::Option<crate::model::TextConditionalFormat>,
        ) -> Self {
            self.text_format = input;
            self
        }
        /// Consumes the builder and constructs a [`TableCellConditionalFormatting`](crate::model::TableCellConditionalFormatting).
        pub fn build(self) -> crate::model::TableCellConditionalFormatting {
            crate::model::TableCellConditionalFormatting {
                field_id: self.field_id,
                text_format: self.text_format,
            }
        }
    }
}
impl TableCellConditionalFormatting {
    /// Creates a new builder-style object to manufacture [`TableCellConditionalFormatting`](crate::model::TableCellConditionalFormatting).
    pub fn builder() -> crate::model::table_cell_conditional_formatting::Builder {
        crate::model::table_cell_conditional_formatting::Builder::default()
    }
}

/// <p>The configuration for a <code>TableVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableConfiguration {
    /// <p>The field wells of the visual.</p>
    #[doc(hidden)]
    pub field_wells: std::option::Option<crate::model::TableFieldWells>,
    /// <p>The sort configuration for a <code>TableVisual</code>.</p>
    #[doc(hidden)]
    pub sort_configuration: std::option::Option<crate::model::TableSortConfiguration>,
    /// <p>The table options for a table visual.</p>
    #[doc(hidden)]
    pub table_options: std::option::Option<crate::model::TableOptions>,
    /// <p>The total options for a table visual.</p>
    #[doc(hidden)]
    pub total_options: std::option::Option<crate::model::TotalOptions>,
    /// <p>The field options for a table visual.</p>
    #[doc(hidden)]
    pub field_options: std::option::Option<crate::model::TableFieldOptions>,
    /// <p>The paginated report options for a table visual.</p>
    #[doc(hidden)]
    pub paginated_report_options: std::option::Option<crate::model::TablePaginatedReportOptions>,
    /// <p>A collection of inline visualizations to display within a chart.</p>
    #[doc(hidden)]
    pub table_inline_visualizations:
        std::option::Option<std::vec::Vec<crate::model::TableInlineVisualization>>,
}
impl TableConfiguration {
    /// <p>The field wells of the visual.</p>
    pub fn field_wells(&self) -> std::option::Option<&crate::model::TableFieldWells> {
        self.field_wells.as_ref()
    }
    /// <p>The sort configuration for a <code>TableVisual</code>.</p>
    pub fn sort_configuration(&self) -> std::option::Option<&crate::model::TableSortConfiguration> {
        self.sort_configuration.as_ref()
    }
    /// <p>The table options for a table visual.</p>
    pub fn table_options(&self) -> std::option::Option<&crate::model::TableOptions> {
        self.table_options.as_ref()
    }
    /// <p>The total options for a table visual.</p>
    pub fn total_options(&self) -> std::option::Option<&crate::model::TotalOptions> {
        self.total_options.as_ref()
    }
    /// <p>The field options for a table visual.</p>
    pub fn field_options(&self) -> std::option::Option<&crate::model::TableFieldOptions> {
        self.field_options.as_ref()
    }
    /// <p>The paginated report options for a table visual.</p>
    pub fn paginated_report_options(
        &self,
    ) -> std::option::Option<&crate::model::TablePaginatedReportOptions> {
        self.paginated_report_options.as_ref()
    }
    /// <p>A collection of inline visualizations to display within a chart.</p>
    pub fn table_inline_visualizations(
        &self,
    ) -> std::option::Option<&[crate::model::TableInlineVisualization]> {
        self.table_inline_visualizations.as_deref()
    }
}
/// See [`TableConfiguration`](crate::model::TableConfiguration).
pub mod table_configuration {

    /// A builder for [`TableConfiguration`](crate::model::TableConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_wells: std::option::Option<crate::model::TableFieldWells>,
        pub(crate) sort_configuration: std::option::Option<crate::model::TableSortConfiguration>,
        pub(crate) table_options: std::option::Option<crate::model::TableOptions>,
        pub(crate) total_options: std::option::Option<crate::model::TotalOptions>,
        pub(crate) field_options: std::option::Option<crate::model::TableFieldOptions>,
        pub(crate) paginated_report_options:
            std::option::Option<crate::model::TablePaginatedReportOptions>,
        pub(crate) table_inline_visualizations:
            std::option::Option<std::vec::Vec<crate::model::TableInlineVisualization>>,
    }
    impl Builder {
        /// <p>The field wells of the visual.</p>
        pub fn field_wells(mut self, input: crate::model::TableFieldWells) -> Self {
            self.field_wells = Some(input);
            self
        }
        /// <p>The field wells of the visual.</p>
        pub fn set_field_wells(
            mut self,
            input: std::option::Option<crate::model::TableFieldWells>,
        ) -> Self {
            self.field_wells = input;
            self
        }
        /// <p>The sort configuration for a <code>TableVisual</code>.</p>
        pub fn sort_configuration(mut self, input: crate::model::TableSortConfiguration) -> Self {
            self.sort_configuration = Some(input);
            self
        }
        /// <p>The sort configuration for a <code>TableVisual</code>.</p>
        pub fn set_sort_configuration(
            mut self,
            input: std::option::Option<crate::model::TableSortConfiguration>,
        ) -> Self {
            self.sort_configuration = input;
            self
        }
        /// <p>The table options for a table visual.</p>
        pub fn table_options(mut self, input: crate::model::TableOptions) -> Self {
            self.table_options = Some(input);
            self
        }
        /// <p>The table options for a table visual.</p>
        pub fn set_table_options(
            mut self,
            input: std::option::Option<crate::model::TableOptions>,
        ) -> Self {
            self.table_options = input;
            self
        }
        /// <p>The total options for a table visual.</p>
        pub fn total_options(mut self, input: crate::model::TotalOptions) -> Self {
            self.total_options = Some(input);
            self
        }
        /// <p>The total options for a table visual.</p>
        pub fn set_total_options(
            mut self,
            input: std::option::Option<crate::model::TotalOptions>,
        ) -> Self {
            self.total_options = input;
            self
        }
        /// <p>The field options for a table visual.</p>
        pub fn field_options(mut self, input: crate::model::TableFieldOptions) -> Self {
            self.field_options = Some(input);
            self
        }
        /// <p>The field options for a table visual.</p>
        pub fn set_field_options(
            mut self,
            input: std::option::Option<crate::model::TableFieldOptions>,
        ) -> Self {
            self.field_options = input;
            self
        }
        /// <p>The paginated report options for a table visual.</p>
        pub fn paginated_report_options(
            mut self,
            input: crate::model::TablePaginatedReportOptions,
        ) -> Self {
            self.paginated_report_options = Some(input);
            self
        }
        /// <p>The paginated report options for a table visual.</p>
        pub fn set_paginated_report_options(
            mut self,
            input: std::option::Option<crate::model::TablePaginatedReportOptions>,
        ) -> Self {
            self.paginated_report_options = input;
            self
        }
        /// Appends an item to `table_inline_visualizations`.
        ///
        /// To override the contents of this collection use [`set_table_inline_visualizations`](Self::set_table_inline_visualizations).
        ///
        /// <p>A collection of inline visualizations to display within a chart.</p>
        pub fn table_inline_visualizations(
            mut self,
            input: crate::model::TableInlineVisualization,
        ) -> Self {
            let mut v = self.table_inline_visualizations.unwrap_or_default();
            v.push(input);
            self.table_inline_visualizations = Some(v);
            self
        }
        /// <p>A collection of inline visualizations to display within a chart.</p>
        pub fn set_table_inline_visualizations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TableInlineVisualization>>,
        ) -> Self {
            self.table_inline_visualizations = input;
            self
        }
        /// Consumes the builder and constructs a [`TableConfiguration`](crate::model::TableConfiguration).
        pub fn build(self) -> crate::model::TableConfiguration {
            crate::model::TableConfiguration {
                field_wells: self.field_wells,
                sort_configuration: self.sort_configuration,
                table_options: self.table_options,
                total_options: self.total_options,
                field_options: self.field_options,
                paginated_report_options: self.paginated_report_options,
                table_inline_visualizations: self.table_inline_visualizations,
            }
        }
    }
}
impl TableConfiguration {
    /// Creates a new builder-style object to manufacture [`TableConfiguration`](crate::model::TableConfiguration).
    pub fn builder() -> crate::model::table_configuration::Builder {
        crate::model::table_configuration::Builder::default()
    }
}

/// <p>The inline visualization of a specific type to display within a chart.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableInlineVisualization {
    /// <p>The configuration of the inline visualization of the data bars within a chart.</p>
    #[doc(hidden)]
    pub data_bars: std::option::Option<crate::model::DataBarsOptions>,
}
impl TableInlineVisualization {
    /// <p>The configuration of the inline visualization of the data bars within a chart.</p>
    pub fn data_bars(&self) -> std::option::Option<&crate::model::DataBarsOptions> {
        self.data_bars.as_ref()
    }
}
/// See [`TableInlineVisualization`](crate::model::TableInlineVisualization).
pub mod table_inline_visualization {

    /// A builder for [`TableInlineVisualization`](crate::model::TableInlineVisualization).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_bars: std::option::Option<crate::model::DataBarsOptions>,
    }
    impl Builder {
        /// <p>The configuration of the inline visualization of the data bars within a chart.</p>
        pub fn data_bars(mut self, input: crate::model::DataBarsOptions) -> Self {
            self.data_bars = Some(input);
            self
        }
        /// <p>The configuration of the inline visualization of the data bars within a chart.</p>
        pub fn set_data_bars(
            mut self,
            input: std::option::Option<crate::model::DataBarsOptions>,
        ) -> Self {
            self.data_bars = input;
            self
        }
        /// Consumes the builder and constructs a [`TableInlineVisualization`](crate::model::TableInlineVisualization).
        pub fn build(self) -> crate::model::TableInlineVisualization {
            crate::model::TableInlineVisualization {
                data_bars: self.data_bars,
            }
        }
    }
}
impl TableInlineVisualization {
    /// Creates a new builder-style object to manufacture [`TableInlineVisualization`](crate::model::TableInlineVisualization).
    pub fn builder() -> crate::model::table_inline_visualization::Builder {
        crate::model::table_inline_visualization::Builder::default()
    }
}

/// <p>The options for data bars.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataBarsOptions {
    /// <p>The field ID for the data bars options.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The color of the positive data bar.</p>
    #[doc(hidden)]
    pub positive_color: std::option::Option<std::string::String>,
    /// <p>The color of the negative data bar.</p>
    #[doc(hidden)]
    pub negative_color: std::option::Option<std::string::String>,
}
impl DataBarsOptions {
    /// <p>The field ID for the data bars options.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The color of the positive data bar.</p>
    pub fn positive_color(&self) -> std::option::Option<&str> {
        self.positive_color.as_deref()
    }
    /// <p>The color of the negative data bar.</p>
    pub fn negative_color(&self) -> std::option::Option<&str> {
        self.negative_color.as_deref()
    }
}
/// See [`DataBarsOptions`](crate::model::DataBarsOptions).
pub mod data_bars_options {

    /// A builder for [`DataBarsOptions`](crate::model::DataBarsOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) positive_color: std::option::Option<std::string::String>,
        pub(crate) negative_color: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The field ID for the data bars options.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The field ID for the data bars options.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The color of the positive data bar.</p>
        pub fn positive_color(mut self, input: impl Into<std::string::String>) -> Self {
            self.positive_color = Some(input.into());
            self
        }
        /// <p>The color of the positive data bar.</p>
        pub fn set_positive_color(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.positive_color = input;
            self
        }
        /// <p>The color of the negative data bar.</p>
        pub fn negative_color(mut self, input: impl Into<std::string::String>) -> Self {
            self.negative_color = Some(input.into());
            self
        }
        /// <p>The color of the negative data bar.</p>
        pub fn set_negative_color(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.negative_color = input;
            self
        }
        /// Consumes the builder and constructs a [`DataBarsOptions`](crate::model::DataBarsOptions).
        pub fn build(self) -> crate::model::DataBarsOptions {
            crate::model::DataBarsOptions {
                field_id: self.field_id,
                positive_color: self.positive_color,
                negative_color: self.negative_color,
            }
        }
    }
}
impl DataBarsOptions {
    /// Creates a new builder-style object to manufacture [`DataBarsOptions`](crate::model::DataBarsOptions).
    pub fn builder() -> crate::model::data_bars_options::Builder {
        crate::model::data_bars_options::Builder::default()
    }
}

/// <p>The paginated report options for a table visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TablePaginatedReportOptions {
    /// <p>The visibility of printing table overflow across pages.</p>
    #[doc(hidden)]
    pub vertical_overflow_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The visibility of repeating header rows on each page.</p>
    #[doc(hidden)]
    pub overflow_column_header_visibility: std::option::Option<crate::model::Visibility>,
}
impl TablePaginatedReportOptions {
    /// <p>The visibility of printing table overflow across pages.</p>
    pub fn vertical_overflow_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.vertical_overflow_visibility.as_ref()
    }
    /// <p>The visibility of repeating header rows on each page.</p>
    pub fn overflow_column_header_visibility(
        &self,
    ) -> std::option::Option<&crate::model::Visibility> {
        self.overflow_column_header_visibility.as_ref()
    }
}
/// See [`TablePaginatedReportOptions`](crate::model::TablePaginatedReportOptions).
pub mod table_paginated_report_options {

    /// A builder for [`TablePaginatedReportOptions`](crate::model::TablePaginatedReportOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vertical_overflow_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) overflow_column_header_visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>The visibility of printing table overflow across pages.</p>
        pub fn vertical_overflow_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.vertical_overflow_visibility = Some(input);
            self
        }
        /// <p>The visibility of printing table overflow across pages.</p>
        pub fn set_vertical_overflow_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.vertical_overflow_visibility = input;
            self
        }
        /// <p>The visibility of repeating header rows on each page.</p>
        pub fn overflow_column_header_visibility(
            mut self,
            input: crate::model::Visibility,
        ) -> Self {
            self.overflow_column_header_visibility = Some(input);
            self
        }
        /// <p>The visibility of repeating header rows on each page.</p>
        pub fn set_overflow_column_header_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.overflow_column_header_visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`TablePaginatedReportOptions`](crate::model::TablePaginatedReportOptions).
        pub fn build(self) -> crate::model::TablePaginatedReportOptions {
            crate::model::TablePaginatedReportOptions {
                vertical_overflow_visibility: self.vertical_overflow_visibility,
                overflow_column_header_visibility: self.overflow_column_header_visibility,
            }
        }
    }
}
impl TablePaginatedReportOptions {
    /// Creates a new builder-style object to manufacture [`TablePaginatedReportOptions`](crate::model::TablePaginatedReportOptions).
    pub fn builder() -> crate::model::table_paginated_report_options::Builder {
        crate::model::table_paginated_report_options::Builder::default()
    }
}

/// <p>The field options for a table visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableFieldOptions {
    /// <p>The selected field options for the table field options.</p>
    #[doc(hidden)]
    pub selected_field_options: std::option::Option<std::vec::Vec<crate::model::TableFieldOption>>,
    /// <p>The order of field IDs of the field options for a table visual.</p>
    #[doc(hidden)]
    pub order: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl TableFieldOptions {
    /// <p>The selected field options for the table field options.</p>
    pub fn selected_field_options(&self) -> std::option::Option<&[crate::model::TableFieldOption]> {
        self.selected_field_options.as_deref()
    }
    /// <p>The order of field IDs of the field options for a table visual.</p>
    pub fn order(&self) -> std::option::Option<&[std::string::String]> {
        self.order.as_deref()
    }
}
/// See [`TableFieldOptions`](crate::model::TableFieldOptions).
pub mod table_field_options {

    /// A builder for [`TableFieldOptions`](crate::model::TableFieldOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) selected_field_options:
            std::option::Option<std::vec::Vec<crate::model::TableFieldOption>>,
        pub(crate) order: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `selected_field_options`.
        ///
        /// To override the contents of this collection use [`set_selected_field_options`](Self::set_selected_field_options).
        ///
        /// <p>The selected field options for the table field options.</p>
        pub fn selected_field_options(mut self, input: crate::model::TableFieldOption) -> Self {
            let mut v = self.selected_field_options.unwrap_or_default();
            v.push(input);
            self.selected_field_options = Some(v);
            self
        }
        /// <p>The selected field options for the table field options.</p>
        pub fn set_selected_field_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TableFieldOption>>,
        ) -> Self {
            self.selected_field_options = input;
            self
        }
        /// Appends an item to `order`.
        ///
        /// To override the contents of this collection use [`set_order`](Self::set_order).
        ///
        /// <p>The order of field IDs of the field options for a table visual.</p>
        pub fn order(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.order.unwrap_or_default();
            v.push(input.into());
            self.order = Some(v);
            self
        }
        /// <p>The order of field IDs of the field options for a table visual.</p>
        pub fn set_order(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.order = input;
            self
        }
        /// Consumes the builder and constructs a [`TableFieldOptions`](crate::model::TableFieldOptions).
        pub fn build(self) -> crate::model::TableFieldOptions {
            crate::model::TableFieldOptions {
                selected_field_options: self.selected_field_options,
                order: self.order,
            }
        }
    }
}
impl TableFieldOptions {
    /// Creates a new builder-style object to manufacture [`TableFieldOptions`](crate::model::TableFieldOptions).
    pub fn builder() -> crate::model::table_field_options::Builder {
        crate::model::table_field_options::Builder::default()
    }
}

/// <p>The options for a table field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableFieldOption {
    /// <p>The field ID for a table field.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The width for a table field.</p>
    #[doc(hidden)]
    pub width: std::option::Option<std::string::String>,
    /// <p>The custom label for a table field.</p>
    #[doc(hidden)]
    pub custom_label: std::option::Option<std::string::String>,
    /// <p>The visibility of a table field.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The URL configuration for a table field.</p>
    #[doc(hidden)]
    pub url_styling: std::option::Option<crate::model::TableFieldUrlConfiguration>,
}
impl TableFieldOption {
    /// <p>The field ID for a table field.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The width for a table field.</p>
    pub fn width(&self) -> std::option::Option<&str> {
        self.width.as_deref()
    }
    /// <p>The custom label for a table field.</p>
    pub fn custom_label(&self) -> std::option::Option<&str> {
        self.custom_label.as_deref()
    }
    /// <p>The visibility of a table field.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
    /// <p>The URL configuration for a table field.</p>
    pub fn url_styling(&self) -> std::option::Option<&crate::model::TableFieldUrlConfiguration> {
        self.url_styling.as_ref()
    }
}
/// See [`TableFieldOption`](crate::model::TableFieldOption).
pub mod table_field_option {

    /// A builder for [`TableFieldOption`](crate::model::TableFieldOption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) width: std::option::Option<std::string::String>,
        pub(crate) custom_label: std::option::Option<std::string::String>,
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) url_styling: std::option::Option<crate::model::TableFieldUrlConfiguration>,
    }
    impl Builder {
        /// <p>The field ID for a table field.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The field ID for a table field.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The width for a table field.</p>
        pub fn width(mut self, input: impl Into<std::string::String>) -> Self {
            self.width = Some(input.into());
            self
        }
        /// <p>The width for a table field.</p>
        pub fn set_width(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.width = input;
            self
        }
        /// <p>The custom label for a table field.</p>
        pub fn custom_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_label = Some(input.into());
            self
        }
        /// <p>The custom label for a table field.</p>
        pub fn set_custom_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.custom_label = input;
            self
        }
        /// <p>The visibility of a table field.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility of a table field.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// <p>The URL configuration for a table field.</p>
        pub fn url_styling(mut self, input: crate::model::TableFieldUrlConfiguration) -> Self {
            self.url_styling = Some(input);
            self
        }
        /// <p>The URL configuration for a table field.</p>
        pub fn set_url_styling(
            mut self,
            input: std::option::Option<crate::model::TableFieldUrlConfiguration>,
        ) -> Self {
            self.url_styling = input;
            self
        }
        /// Consumes the builder and constructs a [`TableFieldOption`](crate::model::TableFieldOption).
        pub fn build(self) -> crate::model::TableFieldOption {
            crate::model::TableFieldOption {
                field_id: self.field_id,
                width: self.width,
                custom_label: self.custom_label,
                visibility: self.visibility,
                url_styling: self.url_styling,
            }
        }
    }
}
impl TableFieldOption {
    /// Creates a new builder-style object to manufacture [`TableFieldOption`](crate::model::TableFieldOption).
    pub fn builder() -> crate::model::table_field_option::Builder {
        crate::model::table_field_option::Builder::default()
    }
}

/// <p>The URL configuration for a table field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableFieldUrlConfiguration {
    /// <p>The link configuration of a table field URL.</p>
    #[doc(hidden)]
    pub link_configuration: std::option::Option<crate::model::TableFieldLinkConfiguration>,
    /// <p>The image configuration of a table field URL.</p>
    #[doc(hidden)]
    pub image_configuration: std::option::Option<crate::model::TableFieldImageConfiguration>,
}
impl TableFieldUrlConfiguration {
    /// <p>The link configuration of a table field URL.</p>
    pub fn link_configuration(
        &self,
    ) -> std::option::Option<&crate::model::TableFieldLinkConfiguration> {
        self.link_configuration.as_ref()
    }
    /// <p>The image configuration of a table field URL.</p>
    pub fn image_configuration(
        &self,
    ) -> std::option::Option<&crate::model::TableFieldImageConfiguration> {
        self.image_configuration.as_ref()
    }
}
/// See [`TableFieldUrlConfiguration`](crate::model::TableFieldUrlConfiguration).
pub mod table_field_url_configuration {

    /// A builder for [`TableFieldUrlConfiguration`](crate::model::TableFieldUrlConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) link_configuration:
            std::option::Option<crate::model::TableFieldLinkConfiguration>,
        pub(crate) image_configuration:
            std::option::Option<crate::model::TableFieldImageConfiguration>,
    }
    impl Builder {
        /// <p>The link configuration of a table field URL.</p>
        pub fn link_configuration(
            mut self,
            input: crate::model::TableFieldLinkConfiguration,
        ) -> Self {
            self.link_configuration = Some(input);
            self
        }
        /// <p>The link configuration of a table field URL.</p>
        pub fn set_link_configuration(
            mut self,
            input: std::option::Option<crate::model::TableFieldLinkConfiguration>,
        ) -> Self {
            self.link_configuration = input;
            self
        }
        /// <p>The image configuration of a table field URL.</p>
        pub fn image_configuration(
            mut self,
            input: crate::model::TableFieldImageConfiguration,
        ) -> Self {
            self.image_configuration = Some(input);
            self
        }
        /// <p>The image configuration of a table field URL.</p>
        pub fn set_image_configuration(
            mut self,
            input: std::option::Option<crate::model::TableFieldImageConfiguration>,
        ) -> Self {
            self.image_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`TableFieldUrlConfiguration`](crate::model::TableFieldUrlConfiguration).
        pub fn build(self) -> crate::model::TableFieldUrlConfiguration {
            crate::model::TableFieldUrlConfiguration {
                link_configuration: self.link_configuration,
                image_configuration: self.image_configuration,
            }
        }
    }
}
impl TableFieldUrlConfiguration {
    /// Creates a new builder-style object to manufacture [`TableFieldUrlConfiguration`](crate::model::TableFieldUrlConfiguration).
    pub fn builder() -> crate::model::table_field_url_configuration::Builder {
        crate::model::table_field_url_configuration::Builder::default()
    }
}

/// <p>The image configuration of a table field URL.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableFieldImageConfiguration {
    /// <p>The sizing options for the table image configuration.</p>
    #[doc(hidden)]
    pub sizing_options: std::option::Option<crate::model::TableCellImageSizingConfiguration>,
}
impl TableFieldImageConfiguration {
    /// <p>The sizing options for the table image configuration.</p>
    pub fn sizing_options(
        &self,
    ) -> std::option::Option<&crate::model::TableCellImageSizingConfiguration> {
        self.sizing_options.as_ref()
    }
}
/// See [`TableFieldImageConfiguration`](crate::model::TableFieldImageConfiguration).
pub mod table_field_image_configuration {

    /// A builder for [`TableFieldImageConfiguration`](crate::model::TableFieldImageConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sizing_options:
            std::option::Option<crate::model::TableCellImageSizingConfiguration>,
    }
    impl Builder {
        /// <p>The sizing options for the table image configuration.</p>
        pub fn sizing_options(
            mut self,
            input: crate::model::TableCellImageSizingConfiguration,
        ) -> Self {
            self.sizing_options = Some(input);
            self
        }
        /// <p>The sizing options for the table image configuration.</p>
        pub fn set_sizing_options(
            mut self,
            input: std::option::Option<crate::model::TableCellImageSizingConfiguration>,
        ) -> Self {
            self.sizing_options = input;
            self
        }
        /// Consumes the builder and constructs a [`TableFieldImageConfiguration`](crate::model::TableFieldImageConfiguration).
        pub fn build(self) -> crate::model::TableFieldImageConfiguration {
            crate::model::TableFieldImageConfiguration {
                sizing_options: self.sizing_options,
            }
        }
    }
}
impl TableFieldImageConfiguration {
    /// Creates a new builder-style object to manufacture [`TableFieldImageConfiguration`](crate::model::TableFieldImageConfiguration).
    pub fn builder() -> crate::model::table_field_image_configuration::Builder {
        crate::model::table_field_image_configuration::Builder::default()
    }
}

/// <p>The sizing options for the table image configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableCellImageSizingConfiguration {
    /// <p>The cell scaling configuration of the sizing options for the table image configuration.</p>
    #[doc(hidden)]
    pub table_cell_image_scaling_configuration:
        std::option::Option<crate::model::TableCellImageScalingConfiguration>,
}
impl TableCellImageSizingConfiguration {
    /// <p>The cell scaling configuration of the sizing options for the table image configuration.</p>
    pub fn table_cell_image_scaling_configuration(
        &self,
    ) -> std::option::Option<&crate::model::TableCellImageScalingConfiguration> {
        self.table_cell_image_scaling_configuration.as_ref()
    }
}
/// See [`TableCellImageSizingConfiguration`](crate::model::TableCellImageSizingConfiguration).
pub mod table_cell_image_sizing_configuration {

    /// A builder for [`TableCellImageSizingConfiguration`](crate::model::TableCellImageSizingConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_cell_image_scaling_configuration:
            std::option::Option<crate::model::TableCellImageScalingConfiguration>,
    }
    impl Builder {
        /// <p>The cell scaling configuration of the sizing options for the table image configuration.</p>
        pub fn table_cell_image_scaling_configuration(
            mut self,
            input: crate::model::TableCellImageScalingConfiguration,
        ) -> Self {
            self.table_cell_image_scaling_configuration = Some(input);
            self
        }
        /// <p>The cell scaling configuration of the sizing options for the table image configuration.</p>
        pub fn set_table_cell_image_scaling_configuration(
            mut self,
            input: std::option::Option<crate::model::TableCellImageScalingConfiguration>,
        ) -> Self {
            self.table_cell_image_scaling_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`TableCellImageSizingConfiguration`](crate::model::TableCellImageSizingConfiguration).
        pub fn build(self) -> crate::model::TableCellImageSizingConfiguration {
            crate::model::TableCellImageSizingConfiguration {
                table_cell_image_scaling_configuration: self.table_cell_image_scaling_configuration,
            }
        }
    }
}
impl TableCellImageSizingConfiguration {
    /// Creates a new builder-style object to manufacture [`TableCellImageSizingConfiguration`](crate::model::TableCellImageSizingConfiguration).
    pub fn builder() -> crate::model::table_cell_image_sizing_configuration::Builder {
        crate::model::table_cell_image_sizing_configuration::Builder::default()
    }
}

/// When writing a match expression against `TableCellImageScalingConfiguration`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let tablecellimagescalingconfiguration = unimplemented!();
/// match tablecellimagescalingconfiguration {
///     TableCellImageScalingConfiguration::DoNotScale => { /* ... */ },
///     TableCellImageScalingConfiguration::FitToCellHeight => { /* ... */ },
///     TableCellImageScalingConfiguration::FitToCellWidth => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `tablecellimagescalingconfiguration` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TableCellImageScalingConfiguration::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TableCellImageScalingConfiguration::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TableCellImageScalingConfiguration::NewFeature` is defined.
/// Specifically, when `tablecellimagescalingconfiguration` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TableCellImageScalingConfiguration::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TableCellImageScalingConfiguration {
    #[allow(missing_docs)] // documentation missing in model
    DoNotScale,
    #[allow(missing_docs)] // documentation missing in model
    FitToCellHeight,
    #[allow(missing_docs)] // documentation missing in model
    FitToCellWidth,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TableCellImageScalingConfiguration {
    fn from(s: &str) -> Self {
        match s {
            "DO_NOT_SCALE" => TableCellImageScalingConfiguration::DoNotScale,
            "FIT_TO_CELL_HEIGHT" => TableCellImageScalingConfiguration::FitToCellHeight,
            "FIT_TO_CELL_WIDTH" => TableCellImageScalingConfiguration::FitToCellWidth,
            other => TableCellImageScalingConfiguration::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for TableCellImageScalingConfiguration {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TableCellImageScalingConfiguration::from(s))
    }
}
impl TableCellImageScalingConfiguration {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TableCellImageScalingConfiguration::DoNotScale => "DO_NOT_SCALE",
            TableCellImageScalingConfiguration::FitToCellHeight => "FIT_TO_CELL_HEIGHT",
            TableCellImageScalingConfiguration::FitToCellWidth => "FIT_TO_CELL_WIDTH",
            TableCellImageScalingConfiguration::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DO_NOT_SCALE", "FIT_TO_CELL_HEIGHT", "FIT_TO_CELL_WIDTH"]
    }
}
impl AsRef<str> for TableCellImageScalingConfiguration {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The link configuration of a table field URL.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableFieldLinkConfiguration {
    /// <p>The URL target (new tab, new window, same tab) for the table link configuration.</p>
    #[doc(hidden)]
    pub target: std::option::Option<crate::model::UrlTargetConfiguration>,
    /// <p>The URL content (text, icon) for the table link configuration.</p>
    #[doc(hidden)]
    pub content: std::option::Option<crate::model::TableFieldLinkContentConfiguration>,
}
impl TableFieldLinkConfiguration {
    /// <p>The URL target (new tab, new window, same tab) for the table link configuration.</p>
    pub fn target(&self) -> std::option::Option<&crate::model::UrlTargetConfiguration> {
        self.target.as_ref()
    }
    /// <p>The URL content (text, icon) for the table link configuration.</p>
    pub fn content(
        &self,
    ) -> std::option::Option<&crate::model::TableFieldLinkContentConfiguration> {
        self.content.as_ref()
    }
}
/// See [`TableFieldLinkConfiguration`](crate::model::TableFieldLinkConfiguration).
pub mod table_field_link_configuration {

    /// A builder for [`TableFieldLinkConfiguration`](crate::model::TableFieldLinkConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target: std::option::Option<crate::model::UrlTargetConfiguration>,
        pub(crate) content: std::option::Option<crate::model::TableFieldLinkContentConfiguration>,
    }
    impl Builder {
        /// <p>The URL target (new tab, new window, same tab) for the table link configuration.</p>
        pub fn target(mut self, input: crate::model::UrlTargetConfiguration) -> Self {
            self.target = Some(input);
            self
        }
        /// <p>The URL target (new tab, new window, same tab) for the table link configuration.</p>
        pub fn set_target(
            mut self,
            input: std::option::Option<crate::model::UrlTargetConfiguration>,
        ) -> Self {
            self.target = input;
            self
        }
        /// <p>The URL content (text, icon) for the table link configuration.</p>
        pub fn content(mut self, input: crate::model::TableFieldLinkContentConfiguration) -> Self {
            self.content = Some(input);
            self
        }
        /// <p>The URL content (text, icon) for the table link configuration.</p>
        pub fn set_content(
            mut self,
            input: std::option::Option<crate::model::TableFieldLinkContentConfiguration>,
        ) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`TableFieldLinkConfiguration`](crate::model::TableFieldLinkConfiguration).
        pub fn build(self) -> crate::model::TableFieldLinkConfiguration {
            crate::model::TableFieldLinkConfiguration {
                target: self.target,
                content: self.content,
            }
        }
    }
}
impl TableFieldLinkConfiguration {
    /// Creates a new builder-style object to manufacture [`TableFieldLinkConfiguration`](crate::model::TableFieldLinkConfiguration).
    pub fn builder() -> crate::model::table_field_link_configuration::Builder {
        crate::model::table_field_link_configuration::Builder::default()
    }
}

/// <p>The URL content (text, icon) for the table link configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableFieldLinkContentConfiguration {
    /// <p>The custom text content (value, font configuration) for the table link content configuration.</p>
    #[doc(hidden)]
    pub custom_text_content: std::option::Option<crate::model::TableFieldCustomTextContent>,
    /// <p>The custom icon content for the table link content configuration.</p>
    #[doc(hidden)]
    pub custom_icon_content: std::option::Option<crate::model::TableFieldCustomIconContent>,
}
impl TableFieldLinkContentConfiguration {
    /// <p>The custom text content (value, font configuration) for the table link content configuration.</p>
    pub fn custom_text_content(
        &self,
    ) -> std::option::Option<&crate::model::TableFieldCustomTextContent> {
        self.custom_text_content.as_ref()
    }
    /// <p>The custom icon content for the table link content configuration.</p>
    pub fn custom_icon_content(
        &self,
    ) -> std::option::Option<&crate::model::TableFieldCustomIconContent> {
        self.custom_icon_content.as_ref()
    }
}
/// See [`TableFieldLinkContentConfiguration`](crate::model::TableFieldLinkContentConfiguration).
pub mod table_field_link_content_configuration {

    /// A builder for [`TableFieldLinkContentConfiguration`](crate::model::TableFieldLinkContentConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) custom_text_content:
            std::option::Option<crate::model::TableFieldCustomTextContent>,
        pub(crate) custom_icon_content:
            std::option::Option<crate::model::TableFieldCustomIconContent>,
    }
    impl Builder {
        /// <p>The custom text content (value, font configuration) for the table link content configuration.</p>
        pub fn custom_text_content(
            mut self,
            input: crate::model::TableFieldCustomTextContent,
        ) -> Self {
            self.custom_text_content = Some(input);
            self
        }
        /// <p>The custom text content (value, font configuration) for the table link content configuration.</p>
        pub fn set_custom_text_content(
            mut self,
            input: std::option::Option<crate::model::TableFieldCustomTextContent>,
        ) -> Self {
            self.custom_text_content = input;
            self
        }
        /// <p>The custom icon content for the table link content configuration.</p>
        pub fn custom_icon_content(
            mut self,
            input: crate::model::TableFieldCustomIconContent,
        ) -> Self {
            self.custom_icon_content = Some(input);
            self
        }
        /// <p>The custom icon content for the table link content configuration.</p>
        pub fn set_custom_icon_content(
            mut self,
            input: std::option::Option<crate::model::TableFieldCustomIconContent>,
        ) -> Self {
            self.custom_icon_content = input;
            self
        }
        /// Consumes the builder and constructs a [`TableFieldLinkContentConfiguration`](crate::model::TableFieldLinkContentConfiguration).
        pub fn build(self) -> crate::model::TableFieldLinkContentConfiguration {
            crate::model::TableFieldLinkContentConfiguration {
                custom_text_content: self.custom_text_content,
                custom_icon_content: self.custom_icon_content,
            }
        }
    }
}
impl TableFieldLinkContentConfiguration {
    /// Creates a new builder-style object to manufacture [`TableFieldLinkContentConfiguration`](crate::model::TableFieldLinkContentConfiguration).
    pub fn builder() -> crate::model::table_field_link_content_configuration::Builder {
        crate::model::table_field_link_content_configuration::Builder::default()
    }
}

/// <p>The custom icon content for the table link content configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableFieldCustomIconContent {
    /// <p>The icon set type (link) of the custom icon content for table URL link content.</p>
    #[doc(hidden)]
    pub icon: std::option::Option<crate::model::TableFieldIconSetType>,
}
impl TableFieldCustomIconContent {
    /// <p>The icon set type (link) of the custom icon content for table URL link content.</p>
    pub fn icon(&self) -> std::option::Option<&crate::model::TableFieldIconSetType> {
        self.icon.as_ref()
    }
}
/// See [`TableFieldCustomIconContent`](crate::model::TableFieldCustomIconContent).
pub mod table_field_custom_icon_content {

    /// A builder for [`TableFieldCustomIconContent`](crate::model::TableFieldCustomIconContent).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) icon: std::option::Option<crate::model::TableFieldIconSetType>,
    }
    impl Builder {
        /// <p>The icon set type (link) of the custom icon content for table URL link content.</p>
        pub fn icon(mut self, input: crate::model::TableFieldIconSetType) -> Self {
            self.icon = Some(input);
            self
        }
        /// <p>The icon set type (link) of the custom icon content for table URL link content.</p>
        pub fn set_icon(
            mut self,
            input: std::option::Option<crate::model::TableFieldIconSetType>,
        ) -> Self {
            self.icon = input;
            self
        }
        /// Consumes the builder and constructs a [`TableFieldCustomIconContent`](crate::model::TableFieldCustomIconContent).
        pub fn build(self) -> crate::model::TableFieldCustomIconContent {
            crate::model::TableFieldCustomIconContent { icon: self.icon }
        }
    }
}
impl TableFieldCustomIconContent {
    /// Creates a new builder-style object to manufacture [`TableFieldCustomIconContent`](crate::model::TableFieldCustomIconContent).
    pub fn builder() -> crate::model::table_field_custom_icon_content::Builder {
        crate::model::table_field_custom_icon_content::Builder::default()
    }
}

/// When writing a match expression against `TableFieldIconSetType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let tablefieldiconsettype = unimplemented!();
/// match tablefieldiconsettype {
///     TableFieldIconSetType::Link => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `tablefieldiconsettype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TableFieldIconSetType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TableFieldIconSetType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TableFieldIconSetType::NewFeature` is defined.
/// Specifically, when `tablefieldiconsettype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TableFieldIconSetType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TableFieldIconSetType {
    #[allow(missing_docs)] // documentation missing in model
    Link,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TableFieldIconSetType {
    fn from(s: &str) -> Self {
        match s {
            "LINK" => TableFieldIconSetType::Link,
            other => {
                TableFieldIconSetType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TableFieldIconSetType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TableFieldIconSetType::from(s))
    }
}
impl TableFieldIconSetType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TableFieldIconSetType::Link => "LINK",
            TableFieldIconSetType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LINK"]
    }
}
impl AsRef<str> for TableFieldIconSetType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The custom text content (value, font configuration) for the table link content configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableFieldCustomTextContent {
    /// <p>The string value of the custom text content for the table URL link content.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>The font configuration of the custom text content for the table URL link content.</p>
    #[doc(hidden)]
    pub font_configuration: std::option::Option<crate::model::FontConfiguration>,
}
impl TableFieldCustomTextContent {
    /// <p>The string value of the custom text content for the table URL link content.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>The font configuration of the custom text content for the table URL link content.</p>
    pub fn font_configuration(&self) -> std::option::Option<&crate::model::FontConfiguration> {
        self.font_configuration.as_ref()
    }
}
/// See [`TableFieldCustomTextContent`](crate::model::TableFieldCustomTextContent).
pub mod table_field_custom_text_content {

    /// A builder for [`TableFieldCustomTextContent`](crate::model::TableFieldCustomTextContent).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) font_configuration: std::option::Option<crate::model::FontConfiguration>,
    }
    impl Builder {
        /// <p>The string value of the custom text content for the table URL link content.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The string value of the custom text content for the table URL link content.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The font configuration of the custom text content for the table URL link content.</p>
        pub fn font_configuration(mut self, input: crate::model::FontConfiguration) -> Self {
            self.font_configuration = Some(input);
            self
        }
        /// <p>The font configuration of the custom text content for the table URL link content.</p>
        pub fn set_font_configuration(
            mut self,
            input: std::option::Option<crate::model::FontConfiguration>,
        ) -> Self {
            self.font_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`TableFieldCustomTextContent`](crate::model::TableFieldCustomTextContent).
        pub fn build(self) -> crate::model::TableFieldCustomTextContent {
            crate::model::TableFieldCustomTextContent {
                value: self.value,
                font_configuration: self.font_configuration,
            }
        }
    }
}
impl TableFieldCustomTextContent {
    /// Creates a new builder-style object to manufacture [`TableFieldCustomTextContent`](crate::model::TableFieldCustomTextContent).
    pub fn builder() -> crate::model::table_field_custom_text_content::Builder {
        crate::model::table_field_custom_text_content::Builder::default()
    }
}

/// <p>The total options for a table visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TotalOptions {
    /// <p>The visibility configuration for the total cells.</p>
    #[doc(hidden)]
    pub totals_visibility: std::option::Option<crate::model::Visibility>,
    /// <p>The placement (start, end) for the total cells.</p>
    #[doc(hidden)]
    pub placement: std::option::Option<crate::model::TableTotalsPlacement>,
    /// <p>The scroll status (pinned, scrolled) for the total cells.</p>
    #[doc(hidden)]
    pub scroll_status: std::option::Option<crate::model::TableTotalsScrollStatus>,
    /// <p>The custom label string for the total cells.</p>
    #[doc(hidden)]
    pub custom_label: std::option::Option<std::string::String>,
    /// <p>Cell styling options for the total cells.</p>
    #[doc(hidden)]
    pub total_cell_style: std::option::Option<crate::model::TableCellStyle>,
}
impl TotalOptions {
    /// <p>The visibility configuration for the total cells.</p>
    pub fn totals_visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.totals_visibility.as_ref()
    }
    /// <p>The placement (start, end) for the total cells.</p>
    pub fn placement(&self) -> std::option::Option<&crate::model::TableTotalsPlacement> {
        self.placement.as_ref()
    }
    /// <p>The scroll status (pinned, scrolled) for the total cells.</p>
    pub fn scroll_status(&self) -> std::option::Option<&crate::model::TableTotalsScrollStatus> {
        self.scroll_status.as_ref()
    }
    /// <p>The custom label string for the total cells.</p>
    pub fn custom_label(&self) -> std::option::Option<&str> {
        self.custom_label.as_deref()
    }
    /// <p>Cell styling options for the total cells.</p>
    pub fn total_cell_style(&self) -> std::option::Option<&crate::model::TableCellStyle> {
        self.total_cell_style.as_ref()
    }
}
/// See [`TotalOptions`](crate::model::TotalOptions).
pub mod total_options {

    /// A builder for [`TotalOptions`](crate::model::TotalOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) totals_visibility: std::option::Option<crate::model::Visibility>,
        pub(crate) placement: std::option::Option<crate::model::TableTotalsPlacement>,
        pub(crate) scroll_status: std::option::Option<crate::model::TableTotalsScrollStatus>,
        pub(crate) custom_label: std::option::Option<std::string::String>,
        pub(crate) total_cell_style: std::option::Option<crate::model::TableCellStyle>,
    }
    impl Builder {
        /// <p>The visibility configuration for the total cells.</p>
        pub fn totals_visibility(mut self, input: crate::model::Visibility) -> Self {
            self.totals_visibility = Some(input);
            self
        }
        /// <p>The visibility configuration for the total cells.</p>
        pub fn set_totals_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.totals_visibility = input;
            self
        }
        /// <p>The placement (start, end) for the total cells.</p>
        pub fn placement(mut self, input: crate::model::TableTotalsPlacement) -> Self {
            self.placement = Some(input);
            self
        }
        /// <p>The placement (start, end) for the total cells.</p>
        pub fn set_placement(
            mut self,
            input: std::option::Option<crate::model::TableTotalsPlacement>,
        ) -> Self {
            self.placement = input;
            self
        }
        /// <p>The scroll status (pinned, scrolled) for the total cells.</p>
        pub fn scroll_status(mut self, input: crate::model::TableTotalsScrollStatus) -> Self {
            self.scroll_status = Some(input);
            self
        }
        /// <p>The scroll status (pinned, scrolled) for the total cells.</p>
        pub fn set_scroll_status(
            mut self,
            input: std::option::Option<crate::model::TableTotalsScrollStatus>,
        ) -> Self {
            self.scroll_status = input;
            self
        }
        /// <p>The custom label string for the total cells.</p>
        pub fn custom_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_label = Some(input.into());
            self
        }
        /// <p>The custom label string for the total cells.</p>
        pub fn set_custom_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.custom_label = input;
            self
        }
        /// <p>Cell styling options for the total cells.</p>
        pub fn total_cell_style(mut self, input: crate::model::TableCellStyle) -> Self {
            self.total_cell_style = Some(input);
            self
        }
        /// <p>Cell styling options for the total cells.</p>
        pub fn set_total_cell_style(
            mut self,
            input: std::option::Option<crate::model::TableCellStyle>,
        ) -> Self {
            self.total_cell_style = input;
            self
        }
        /// Consumes the builder and constructs a [`TotalOptions`](crate::model::TotalOptions).
        pub fn build(self) -> crate::model::TotalOptions {
            crate::model::TotalOptions {
                totals_visibility: self.totals_visibility,
                placement: self.placement,
                scroll_status: self.scroll_status,
                custom_label: self.custom_label,
                total_cell_style: self.total_cell_style,
            }
        }
    }
}
impl TotalOptions {
    /// Creates a new builder-style object to manufacture [`TotalOptions`](crate::model::TotalOptions).
    pub fn builder() -> crate::model::total_options::Builder {
        crate::model::total_options::Builder::default()
    }
}

/// <p>The table options for a table visual.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableOptions {
    /// <p>The orientation (vertical, horizontal) for a table.</p>
    #[doc(hidden)]
    pub orientation: std::option::Option<crate::model::TableOrientation>,
    /// <p>The table cell style of a table header.</p>
    #[doc(hidden)]
    pub header_style: std::option::Option<crate::model::TableCellStyle>,
    /// <p>The table cell style of table cells.</p>
    #[doc(hidden)]
    pub cell_style: std::option::Option<crate::model::TableCellStyle>,
    /// <p>The row alternate color options (widget status, row alternate colors) for a table.</p>
    #[doc(hidden)]
    pub row_alternate_color_options: std::option::Option<crate::model::RowAlternateColorOptions>,
}
impl TableOptions {
    /// <p>The orientation (vertical, horizontal) for a table.</p>
    pub fn orientation(&self) -> std::option::Option<&crate::model::TableOrientation> {
        self.orientation.as_ref()
    }
    /// <p>The table cell style of a table header.</p>
    pub fn header_style(&self) -> std::option::Option<&crate::model::TableCellStyle> {
        self.header_style.as_ref()
    }
    /// <p>The table cell style of table cells.</p>
    pub fn cell_style(&self) -> std::option::Option<&crate::model::TableCellStyle> {
        self.cell_style.as_ref()
    }
    /// <p>The row alternate color options (widget status, row alternate colors) for a table.</p>
    pub fn row_alternate_color_options(
        &self,
    ) -> std::option::Option<&crate::model::RowAlternateColorOptions> {
        self.row_alternate_color_options.as_ref()
    }
}
/// See [`TableOptions`](crate::model::TableOptions).
pub mod table_options {

    /// A builder for [`TableOptions`](crate::model::TableOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) orientation: std::option::Option<crate::model::TableOrientation>,
        pub(crate) header_style: std::option::Option<crate::model::TableCellStyle>,
        pub(crate) cell_style: std::option::Option<crate::model::TableCellStyle>,
        pub(crate) row_alternate_color_options:
            std::option::Option<crate::model::RowAlternateColorOptions>,
    }
    impl Builder {
        /// <p>The orientation (vertical, horizontal) for a table.</p>
        pub fn orientation(mut self, input: crate::model::TableOrientation) -> Self {
            self.orientation = Some(input);
            self
        }
        /// <p>The orientation (vertical, horizontal) for a table.</p>
        pub fn set_orientation(
            mut self,
            input: std::option::Option<crate::model::TableOrientation>,
        ) -> Self {
            self.orientation = input;
            self
        }
        /// <p>The table cell style of a table header.</p>
        pub fn header_style(mut self, input: crate::model::TableCellStyle) -> Self {
            self.header_style = Some(input);
            self
        }
        /// <p>The table cell style of a table header.</p>
        pub fn set_header_style(
            mut self,
            input: std::option::Option<crate::model::TableCellStyle>,
        ) -> Self {
            self.header_style = input;
            self
        }
        /// <p>The table cell style of table cells.</p>
        pub fn cell_style(mut self, input: crate::model::TableCellStyle) -> Self {
            self.cell_style = Some(input);
            self
        }
        /// <p>The table cell style of table cells.</p>
        pub fn set_cell_style(
            mut self,
            input: std::option::Option<crate::model::TableCellStyle>,
        ) -> Self {
            self.cell_style = input;
            self
        }
        /// <p>The row alternate color options (widget status, row alternate colors) for a table.</p>
        pub fn row_alternate_color_options(
            mut self,
            input: crate::model::RowAlternateColorOptions,
        ) -> Self {
            self.row_alternate_color_options = Some(input);
            self
        }
        /// <p>The row alternate color options (widget status, row alternate colors) for a table.</p>
        pub fn set_row_alternate_color_options(
            mut self,
            input: std::option::Option<crate::model::RowAlternateColorOptions>,
        ) -> Self {
            self.row_alternate_color_options = input;
            self
        }
        /// Consumes the builder and constructs a [`TableOptions`](crate::model::TableOptions).
        pub fn build(self) -> crate::model::TableOptions {
            crate::model::TableOptions {
                orientation: self.orientation,
                header_style: self.header_style,
                cell_style: self.cell_style,
                row_alternate_color_options: self.row_alternate_color_options,
            }
        }
    }
}
impl TableOptions {
    /// Creates a new builder-style object to manufacture [`TableOptions`](crate::model::TableOptions).
    pub fn builder() -> crate::model::table_options::Builder {
        crate::model::table_options::Builder::default()
    }
}

/// When writing a match expression against `TableOrientation`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let tableorientation = unimplemented!();
/// match tableorientation {
///     TableOrientation::Horizontal => { /* ... */ },
///     TableOrientation::Vertical => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `tableorientation` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TableOrientation::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TableOrientation::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TableOrientation::NewFeature` is defined.
/// Specifically, when `tableorientation` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TableOrientation::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TableOrientation {
    #[allow(missing_docs)] // documentation missing in model
    Horizontal,
    #[allow(missing_docs)] // documentation missing in model
    Vertical,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TableOrientation {
    fn from(s: &str) -> Self {
        match s {
            "HORIZONTAL" => TableOrientation::Horizontal,
            "VERTICAL" => TableOrientation::Vertical,
            other => TableOrientation::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TableOrientation {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TableOrientation::from(s))
    }
}
impl TableOrientation {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TableOrientation::Horizontal => "HORIZONTAL",
            TableOrientation::Vertical => "VERTICAL",
            TableOrientation::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HORIZONTAL", "VERTICAL"]
    }
}
impl AsRef<str> for TableOrientation {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The sort configuration for a <code>TableVisual</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableSortConfiguration {
    /// <p>The field sort options for rows in the table.</p>
    #[doc(hidden)]
    pub row_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
    /// <p>The pagination configuration (page size, page number) for the table.</p>
    #[doc(hidden)]
    pub pagination_configuration: std::option::Option<crate::model::PaginationConfiguration>,
}
impl TableSortConfiguration {
    /// <p>The field sort options for rows in the table.</p>
    pub fn row_sort(&self) -> std::option::Option<&[crate::model::FieldSortOptions]> {
        self.row_sort.as_deref()
    }
    /// <p>The pagination configuration (page size, page number) for the table.</p>
    pub fn pagination_configuration(
        &self,
    ) -> std::option::Option<&crate::model::PaginationConfiguration> {
        self.pagination_configuration.as_ref()
    }
}
/// See [`TableSortConfiguration`](crate::model::TableSortConfiguration).
pub mod table_sort_configuration {

    /// A builder for [`TableSortConfiguration`](crate::model::TableSortConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) row_sort: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        pub(crate) pagination_configuration:
            std::option::Option<crate::model::PaginationConfiguration>,
    }
    impl Builder {
        /// Appends an item to `row_sort`.
        ///
        /// To override the contents of this collection use [`set_row_sort`](Self::set_row_sort).
        ///
        /// <p>The field sort options for rows in the table.</p>
        pub fn row_sort(mut self, input: crate::model::FieldSortOptions) -> Self {
            let mut v = self.row_sort.unwrap_or_default();
            v.push(input);
            self.row_sort = Some(v);
            self
        }
        /// <p>The field sort options for rows in the table.</p>
        pub fn set_row_sort(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldSortOptions>>,
        ) -> Self {
            self.row_sort = input;
            self
        }
        /// <p>The pagination configuration (page size, page number) for the table.</p>
        pub fn pagination_configuration(
            mut self,
            input: crate::model::PaginationConfiguration,
        ) -> Self {
            self.pagination_configuration = Some(input);
            self
        }
        /// <p>The pagination configuration (page size, page number) for the table.</p>
        pub fn set_pagination_configuration(
            mut self,
            input: std::option::Option<crate::model::PaginationConfiguration>,
        ) -> Self {
            self.pagination_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`TableSortConfiguration`](crate::model::TableSortConfiguration).
        pub fn build(self) -> crate::model::TableSortConfiguration {
            crate::model::TableSortConfiguration {
                row_sort: self.row_sort,
                pagination_configuration: self.pagination_configuration,
            }
        }
    }
}
impl TableSortConfiguration {
    /// Creates a new builder-style object to manufacture [`TableSortConfiguration`](crate::model::TableSortConfiguration).
    pub fn builder() -> crate::model::table_sort_configuration::Builder {
        crate::model::table_sort_configuration::Builder::default()
    }
}

/// <p>The field wells for a table visual.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableFieldWells {
    /// <p>The aggregated field well for the table.</p>
    #[doc(hidden)]
    pub table_aggregated_field_wells: std::option::Option<crate::model::TableAggregatedFieldWells>,
    /// <p>The unaggregated field well for the table.</p>
    #[doc(hidden)]
    pub table_unaggregated_field_wells:
        std::option::Option<crate::model::TableUnaggregatedFieldWells>,
}
impl TableFieldWells {
    /// <p>The aggregated field well for the table.</p>
    pub fn table_aggregated_field_wells(
        &self,
    ) -> std::option::Option<&crate::model::TableAggregatedFieldWells> {
        self.table_aggregated_field_wells.as_ref()
    }
    /// <p>The unaggregated field well for the table.</p>
    pub fn table_unaggregated_field_wells(
        &self,
    ) -> std::option::Option<&crate::model::TableUnaggregatedFieldWells> {
        self.table_unaggregated_field_wells.as_ref()
    }
}
/// See [`TableFieldWells`](crate::model::TableFieldWells).
pub mod table_field_wells {

    /// A builder for [`TableFieldWells`](crate::model::TableFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_aggregated_field_wells:
            std::option::Option<crate::model::TableAggregatedFieldWells>,
        pub(crate) table_unaggregated_field_wells:
            std::option::Option<crate::model::TableUnaggregatedFieldWells>,
    }
    impl Builder {
        /// <p>The aggregated field well for the table.</p>
        pub fn table_aggregated_field_wells(
            mut self,
            input: crate::model::TableAggregatedFieldWells,
        ) -> Self {
            self.table_aggregated_field_wells = Some(input);
            self
        }
        /// <p>The aggregated field well for the table.</p>
        pub fn set_table_aggregated_field_wells(
            mut self,
            input: std::option::Option<crate::model::TableAggregatedFieldWells>,
        ) -> Self {
            self.table_aggregated_field_wells = input;
            self
        }
        /// <p>The unaggregated field well for the table.</p>
        pub fn table_unaggregated_field_wells(
            mut self,
            input: crate::model::TableUnaggregatedFieldWells,
        ) -> Self {
            self.table_unaggregated_field_wells = Some(input);
            self
        }
        /// <p>The unaggregated field well for the table.</p>
        pub fn set_table_unaggregated_field_wells(
            mut self,
            input: std::option::Option<crate::model::TableUnaggregatedFieldWells>,
        ) -> Self {
            self.table_unaggregated_field_wells = input;
            self
        }
        /// Consumes the builder and constructs a [`TableFieldWells`](crate::model::TableFieldWells).
        pub fn build(self) -> crate::model::TableFieldWells {
            crate::model::TableFieldWells {
                table_aggregated_field_wells: self.table_aggregated_field_wells,
                table_unaggregated_field_wells: self.table_unaggregated_field_wells,
            }
        }
    }
}
impl TableFieldWells {
    /// Creates a new builder-style object to manufacture [`TableFieldWells`](crate::model::TableFieldWells).
    pub fn builder() -> crate::model::table_field_wells::Builder {
        crate::model::table_field_wells::Builder::default()
    }
}

/// <p>The unaggregated field well for the table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableUnaggregatedFieldWells {
    /// <p>The values field well for a pivot table. Values are unaggregated for an unaggregated table.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::UnaggregatedField>>,
}
impl TableUnaggregatedFieldWells {
    /// <p>The values field well for a pivot table. Values are unaggregated for an unaggregated table.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::UnaggregatedField]> {
        self.values.as_deref()
    }
}
/// See [`TableUnaggregatedFieldWells`](crate::model::TableUnaggregatedFieldWells).
pub mod table_unaggregated_field_wells {

    /// A builder for [`TableUnaggregatedFieldWells`](crate::model::TableUnaggregatedFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::UnaggregatedField>>,
    }
    impl Builder {
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The values field well for a pivot table. Values are unaggregated for an unaggregated table.</p>
        pub fn values(mut self, input: crate::model::UnaggregatedField) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>The values field well for a pivot table. Values are unaggregated for an unaggregated table.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UnaggregatedField>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`TableUnaggregatedFieldWells`](crate::model::TableUnaggregatedFieldWells).
        pub fn build(self) -> crate::model::TableUnaggregatedFieldWells {
            crate::model::TableUnaggregatedFieldWells {
                values: self.values,
            }
        }
    }
}
impl TableUnaggregatedFieldWells {
    /// Creates a new builder-style object to manufacture [`TableUnaggregatedFieldWells`](crate::model::TableUnaggregatedFieldWells).
    pub fn builder() -> crate::model::table_unaggregated_field_wells::Builder {
        crate::model::table_unaggregated_field_wells::Builder::default()
    }
}

/// <p>The unaggregated field for a table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnaggregatedField {
    /// <p>The custom field ID.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The column that is used in the <code>UnaggregatedField</code>.</p>
    #[doc(hidden)]
    pub column: std::option::Option<crate::model::ColumnIdentifier>,
    /// <p>The format configuration of the field.</p>
    #[doc(hidden)]
    pub format_configuration: std::option::Option<crate::model::FormatConfiguration>,
}
impl UnaggregatedField {
    /// <p>The custom field ID.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The column that is used in the <code>UnaggregatedField</code>.</p>
    pub fn column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column.as_ref()
    }
    /// <p>The format configuration of the field.</p>
    pub fn format_configuration(&self) -> std::option::Option<&crate::model::FormatConfiguration> {
        self.format_configuration.as_ref()
    }
}
/// See [`UnaggregatedField`](crate::model::UnaggregatedField).
pub mod unaggregated_field {

    /// A builder for [`UnaggregatedField`](crate::model::UnaggregatedField).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) column: std::option::Option<crate::model::ColumnIdentifier>,
        pub(crate) format_configuration: std::option::Option<crate::model::FormatConfiguration>,
    }
    impl Builder {
        /// <p>The custom field ID.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The custom field ID.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The column that is used in the <code>UnaggregatedField</code>.</p>
        pub fn column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column = Some(input);
            self
        }
        /// <p>The column that is used in the <code>UnaggregatedField</code>.</p>
        pub fn set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column = input;
            self
        }
        /// <p>The format configuration of the field.</p>
        pub fn format_configuration(mut self, input: crate::model::FormatConfiguration) -> Self {
            self.format_configuration = Some(input);
            self
        }
        /// <p>The format configuration of the field.</p>
        pub fn set_format_configuration(
            mut self,
            input: std::option::Option<crate::model::FormatConfiguration>,
        ) -> Self {
            self.format_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`UnaggregatedField`](crate::model::UnaggregatedField).
        pub fn build(self) -> crate::model::UnaggregatedField {
            crate::model::UnaggregatedField {
                field_id: self.field_id,
                column: self.column,
                format_configuration: self.format_configuration,
            }
        }
    }
}
impl UnaggregatedField {
    /// Creates a new builder-style object to manufacture [`UnaggregatedField`](crate::model::UnaggregatedField).
    pub fn builder() -> crate::model::unaggregated_field::Builder {
        crate::model::unaggregated_field::Builder::default()
    }
}

/// <p>The aggregated field well for the table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableAggregatedFieldWells {
    /// <p>The group by field well for a pivot table. Values are grouped by group by fields.</p>
    #[doc(hidden)]
    pub group_by: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
    /// <p>The values field well for a pivot table. Values are aggregated based on group by fields.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
}
impl TableAggregatedFieldWells {
    /// <p>The group by field well for a pivot table. Values are grouped by group by fields.</p>
    pub fn group_by(&self) -> std::option::Option<&[crate::model::DimensionField]> {
        self.group_by.as_deref()
    }
    /// <p>The values field well for a pivot table. Values are aggregated based on group by fields.</p>
    pub fn values(&self) -> std::option::Option<&[crate::model::MeasureField]> {
        self.values.as_deref()
    }
}
/// See [`TableAggregatedFieldWells`](crate::model::TableAggregatedFieldWells).
pub mod table_aggregated_field_wells {

    /// A builder for [`TableAggregatedFieldWells`](crate::model::TableAggregatedFieldWells).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_by: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
    }
    impl Builder {
        /// Appends an item to `group_by`.
        ///
        /// To override the contents of this collection use [`set_group_by`](Self::set_group_by).
        ///
        /// <p>The group by field well for a pivot table. Values are grouped by group by fields.</p>
        pub fn group_by(mut self, input: crate::model::DimensionField) -> Self {
            let mut v = self.group_by.unwrap_or_default();
            v.push(input);
            self.group_by = Some(v);
            self
        }
        /// <p>The group by field well for a pivot table. Values are grouped by group by fields.</p>
        pub fn set_group_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionField>>,
        ) -> Self {
            self.group_by = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The values field well for a pivot table. Values are aggregated based on group by fields.</p>
        pub fn values(mut self, input: crate::model::MeasureField) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>The values field well for a pivot table. Values are aggregated based on group by fields.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MeasureField>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`TableAggregatedFieldWells`](crate::model::TableAggregatedFieldWells).
        pub fn build(self) -> crate::model::TableAggregatedFieldWells {
            crate::model::TableAggregatedFieldWells {
                group_by: self.group_by,
                values: self.values,
            }
        }
    }
}
impl TableAggregatedFieldWells {
    /// Creates a new builder-style object to manufacture [`TableAggregatedFieldWells`](crate::model::TableAggregatedFieldWells).
    pub fn builder() -> crate::model::table_aggregated_field_wells::Builder {
        crate::model::table_aggregated_field_wells::Builder::default()
    }
}

/// <p>The control of a filter that is used to interact with a dashboard or an analysis.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterControl {
    /// <p>A control from a date filter that is used to specify date and time.</p>
    #[doc(hidden)]
    pub date_time_picker: std::option::Option<crate::model::FilterDateTimePickerControl>,
    /// <p>A control to display a list of buttons or boxes. This is used to select either a single value or multiple values.</p>
    #[doc(hidden)]
    pub list: std::option::Option<crate::model::FilterListControl>,
    /// <p>A control to display a dropdown list with buttons that are used to select a single value.</p>
    #[doc(hidden)]
    pub dropdown: std::option::Option<crate::model::FilterDropDownControl>,
    /// <p>A control to display a text box that is used to enter a single entry.</p>
    #[doc(hidden)]
    pub text_field: std::option::Option<crate::model::FilterTextFieldControl>,
    /// <p>A control to display a text box that is used to enter multiple entries.</p>
    #[doc(hidden)]
    pub text_area: std::option::Option<crate::model::FilterTextAreaControl>,
    /// <p>A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.</p>
    #[doc(hidden)]
    pub slider: std::option::Option<crate::model::FilterSliderControl>,
    /// <p>A control from a date filter that is used to specify the relative date.</p>
    #[doc(hidden)]
    pub relative_date_time: std::option::Option<crate::model::FilterRelativeDateTimeControl>,
}
impl FilterControl {
    /// <p>A control from a date filter that is used to specify date and time.</p>
    pub fn date_time_picker(
        &self,
    ) -> std::option::Option<&crate::model::FilterDateTimePickerControl> {
        self.date_time_picker.as_ref()
    }
    /// <p>A control to display a list of buttons or boxes. This is used to select either a single value or multiple values.</p>
    pub fn list(&self) -> std::option::Option<&crate::model::FilterListControl> {
        self.list.as_ref()
    }
    /// <p>A control to display a dropdown list with buttons that are used to select a single value.</p>
    pub fn dropdown(&self) -> std::option::Option<&crate::model::FilterDropDownControl> {
        self.dropdown.as_ref()
    }
    /// <p>A control to display a text box that is used to enter a single entry.</p>
    pub fn text_field(&self) -> std::option::Option<&crate::model::FilterTextFieldControl> {
        self.text_field.as_ref()
    }
    /// <p>A control to display a text box that is used to enter multiple entries.</p>
    pub fn text_area(&self) -> std::option::Option<&crate::model::FilterTextAreaControl> {
        self.text_area.as_ref()
    }
    /// <p>A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.</p>
    pub fn slider(&self) -> std::option::Option<&crate::model::FilterSliderControl> {
        self.slider.as_ref()
    }
    /// <p>A control from a date filter that is used to specify the relative date.</p>
    pub fn relative_date_time(
        &self,
    ) -> std::option::Option<&crate::model::FilterRelativeDateTimeControl> {
        self.relative_date_time.as_ref()
    }
}
/// See [`FilterControl`](crate::model::FilterControl).
pub mod filter_control {

    /// A builder for [`FilterControl`](crate::model::FilterControl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) date_time_picker: std::option::Option<crate::model::FilterDateTimePickerControl>,
        pub(crate) list: std::option::Option<crate::model::FilterListControl>,
        pub(crate) dropdown: std::option::Option<crate::model::FilterDropDownControl>,
        pub(crate) text_field: std::option::Option<crate::model::FilterTextFieldControl>,
        pub(crate) text_area: std::option::Option<crate::model::FilterTextAreaControl>,
        pub(crate) slider: std::option::Option<crate::model::FilterSliderControl>,
        pub(crate) relative_date_time:
            std::option::Option<crate::model::FilterRelativeDateTimeControl>,
    }
    impl Builder {
        /// <p>A control from a date filter that is used to specify date and time.</p>
        pub fn date_time_picker(
            mut self,
            input: crate::model::FilterDateTimePickerControl,
        ) -> Self {
            self.date_time_picker = Some(input);
            self
        }
        /// <p>A control from a date filter that is used to specify date and time.</p>
        pub fn set_date_time_picker(
            mut self,
            input: std::option::Option<crate::model::FilterDateTimePickerControl>,
        ) -> Self {
            self.date_time_picker = input;
            self
        }
        /// <p>A control to display a list of buttons or boxes. This is used to select either a single value or multiple values.</p>
        pub fn list(mut self, input: crate::model::FilterListControl) -> Self {
            self.list = Some(input);
            self
        }
        /// <p>A control to display a list of buttons or boxes. This is used to select either a single value or multiple values.</p>
        pub fn set_list(
            mut self,
            input: std::option::Option<crate::model::FilterListControl>,
        ) -> Self {
            self.list = input;
            self
        }
        /// <p>A control to display a dropdown list with buttons that are used to select a single value.</p>
        pub fn dropdown(mut self, input: crate::model::FilterDropDownControl) -> Self {
            self.dropdown = Some(input);
            self
        }
        /// <p>A control to display a dropdown list with buttons that are used to select a single value.</p>
        pub fn set_dropdown(
            mut self,
            input: std::option::Option<crate::model::FilterDropDownControl>,
        ) -> Self {
            self.dropdown = input;
            self
        }
        /// <p>A control to display a text box that is used to enter a single entry.</p>
        pub fn text_field(mut self, input: crate::model::FilterTextFieldControl) -> Self {
            self.text_field = Some(input);
            self
        }
        /// <p>A control to display a text box that is used to enter a single entry.</p>
        pub fn set_text_field(
            mut self,
            input: std::option::Option<crate::model::FilterTextFieldControl>,
        ) -> Self {
            self.text_field = input;
            self
        }
        /// <p>A control to display a text box that is used to enter multiple entries.</p>
        pub fn text_area(mut self, input: crate::model::FilterTextAreaControl) -> Self {
            self.text_area = Some(input);
            self
        }
        /// <p>A control to display a text box that is used to enter multiple entries.</p>
        pub fn set_text_area(
            mut self,
            input: std::option::Option<crate::model::FilterTextAreaControl>,
        ) -> Self {
            self.text_area = input;
            self
        }
        /// <p>A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.</p>
        pub fn slider(mut self, input: crate::model::FilterSliderControl) -> Self {
            self.slider = Some(input);
            self
        }
        /// <p>A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.</p>
        pub fn set_slider(
            mut self,
            input: std::option::Option<crate::model::FilterSliderControl>,
        ) -> Self {
            self.slider = input;
            self
        }
        /// <p>A control from a date filter that is used to specify the relative date.</p>
        pub fn relative_date_time(
            mut self,
            input: crate::model::FilterRelativeDateTimeControl,
        ) -> Self {
            self.relative_date_time = Some(input);
            self
        }
        /// <p>A control from a date filter that is used to specify the relative date.</p>
        pub fn set_relative_date_time(
            mut self,
            input: std::option::Option<crate::model::FilterRelativeDateTimeControl>,
        ) -> Self {
            self.relative_date_time = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterControl`](crate::model::FilterControl).
        pub fn build(self) -> crate::model::FilterControl {
            crate::model::FilterControl {
                date_time_picker: self.date_time_picker,
                list: self.list,
                dropdown: self.dropdown,
                text_field: self.text_field,
                text_area: self.text_area,
                slider: self.slider,
                relative_date_time: self.relative_date_time,
            }
        }
    }
}
impl FilterControl {
    /// Creates a new builder-style object to manufacture [`FilterControl`](crate::model::FilterControl).
    pub fn builder() -> crate::model::filter_control::Builder {
        crate::model::filter_control::Builder::default()
    }
}

/// <p>A control from a date filter that is used to specify the relative date.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterRelativeDateTimeControl {
    /// <p>The ID of the <code>FilterTextAreaControl</code>.</p>
    #[doc(hidden)]
    pub filter_control_id: std::option::Option<std::string::String>,
    /// <p>The title of the <code>FilterTextAreaControl</code>.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The source filter ID of the <code>FilterTextAreaControl</code>.</p>
    #[doc(hidden)]
    pub source_filter_id: std::option::Option<std::string::String>,
    /// <p>The display options of a control.</p>
    #[doc(hidden)]
    pub display_options: std::option::Option<crate::model::RelativeDateTimeControlDisplayOptions>,
}
impl FilterRelativeDateTimeControl {
    /// <p>The ID of the <code>FilterTextAreaControl</code>.</p>
    pub fn filter_control_id(&self) -> std::option::Option<&str> {
        self.filter_control_id.as_deref()
    }
    /// <p>The title of the <code>FilterTextAreaControl</code>.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The source filter ID of the <code>FilterTextAreaControl</code>.</p>
    pub fn source_filter_id(&self) -> std::option::Option<&str> {
        self.source_filter_id.as_deref()
    }
    /// <p>The display options of a control.</p>
    pub fn display_options(
        &self,
    ) -> std::option::Option<&crate::model::RelativeDateTimeControlDisplayOptions> {
        self.display_options.as_ref()
    }
}
/// See [`FilterRelativeDateTimeControl`](crate::model::FilterRelativeDateTimeControl).
pub mod filter_relative_date_time_control {

    /// A builder for [`FilterRelativeDateTimeControl`](crate::model::FilterRelativeDateTimeControl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_control_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) source_filter_id: std::option::Option<std::string::String>,
        pub(crate) display_options:
            std::option::Option<crate::model::RelativeDateTimeControlDisplayOptions>,
    }
    impl Builder {
        /// <p>The ID of the <code>FilterTextAreaControl</code>.</p>
        pub fn filter_control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_control_id = Some(input.into());
            self
        }
        /// <p>The ID of the <code>FilterTextAreaControl</code>.</p>
        pub fn set_filter_control_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filter_control_id = input;
            self
        }
        /// <p>The title of the <code>FilterTextAreaControl</code>.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the <code>FilterTextAreaControl</code>.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The source filter ID of the <code>FilterTextAreaControl</code>.</p>
        pub fn source_filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_filter_id = Some(input.into());
            self
        }
        /// <p>The source filter ID of the <code>FilterTextAreaControl</code>.</p>
        pub fn set_source_filter_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_filter_id = input;
            self
        }
        /// <p>The display options of a control.</p>
        pub fn display_options(
            mut self,
            input: crate::model::RelativeDateTimeControlDisplayOptions,
        ) -> Self {
            self.display_options = Some(input);
            self
        }
        /// <p>The display options of a control.</p>
        pub fn set_display_options(
            mut self,
            input: std::option::Option<crate::model::RelativeDateTimeControlDisplayOptions>,
        ) -> Self {
            self.display_options = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterRelativeDateTimeControl`](crate::model::FilterRelativeDateTimeControl).
        pub fn build(self) -> crate::model::FilterRelativeDateTimeControl {
            crate::model::FilterRelativeDateTimeControl {
                filter_control_id: self.filter_control_id,
                title: self.title,
                source_filter_id: self.source_filter_id,
                display_options: self.display_options,
            }
        }
    }
}
impl FilterRelativeDateTimeControl {
    /// Creates a new builder-style object to manufacture [`FilterRelativeDateTimeControl`](crate::model::FilterRelativeDateTimeControl).
    pub fn builder() -> crate::model::filter_relative_date_time_control::Builder {
        crate::model::filter_relative_date_time_control::Builder::default()
    }
}

/// <p>The display options of a control.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RelativeDateTimeControlDisplayOptions {
    /// <p>The options to configure the title visibility, name, and font size.</p>
    #[doc(hidden)]
    pub title_options: std::option::Option<crate::model::LabelOptions>,
    /// <p>Customize how dates are formatted in controls.</p>
    #[doc(hidden)]
    pub date_time_format: std::option::Option<std::string::String>,
}
impl RelativeDateTimeControlDisplayOptions {
    /// <p>The options to configure the title visibility, name, and font size.</p>
    pub fn title_options(&self) -> std::option::Option<&crate::model::LabelOptions> {
        self.title_options.as_ref()
    }
    /// <p>Customize how dates are formatted in controls.</p>
    pub fn date_time_format(&self) -> std::option::Option<&str> {
        self.date_time_format.as_deref()
    }
}
/// See [`RelativeDateTimeControlDisplayOptions`](crate::model::RelativeDateTimeControlDisplayOptions).
pub mod relative_date_time_control_display_options {

    /// A builder for [`RelativeDateTimeControlDisplayOptions`](crate::model::RelativeDateTimeControlDisplayOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) title_options: std::option::Option<crate::model::LabelOptions>,
        pub(crate) date_time_format: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The options to configure the title visibility, name, and font size.</p>
        pub fn title_options(mut self, input: crate::model::LabelOptions) -> Self {
            self.title_options = Some(input);
            self
        }
        /// <p>The options to configure the title visibility, name, and font size.</p>
        pub fn set_title_options(
            mut self,
            input: std::option::Option<crate::model::LabelOptions>,
        ) -> Self {
            self.title_options = input;
            self
        }
        /// <p>Customize how dates are formatted in controls.</p>
        pub fn date_time_format(mut self, input: impl Into<std::string::String>) -> Self {
            self.date_time_format = Some(input.into());
            self
        }
        /// <p>Customize how dates are formatted in controls.</p>
        pub fn set_date_time_format(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.date_time_format = input;
            self
        }
        /// Consumes the builder and constructs a [`RelativeDateTimeControlDisplayOptions`](crate::model::RelativeDateTimeControlDisplayOptions).
        pub fn build(self) -> crate::model::RelativeDateTimeControlDisplayOptions {
            crate::model::RelativeDateTimeControlDisplayOptions {
                title_options: self.title_options,
                date_time_format: self.date_time_format,
            }
        }
    }
}
impl RelativeDateTimeControlDisplayOptions {
    /// Creates a new builder-style object to manufacture [`RelativeDateTimeControlDisplayOptions`](crate::model::RelativeDateTimeControlDisplayOptions).
    pub fn builder() -> crate::model::relative_date_time_control_display_options::Builder {
        crate::model::relative_date_time_control_display_options::Builder::default()
    }
}

/// <p>A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterSliderControl {
    /// <p>The ID of the <code>FilterSliderControl</code>.</p>
    #[doc(hidden)]
    pub filter_control_id: std::option::Option<std::string::String>,
    /// <p>The title of the <code>FilterSliderControl</code>.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The source filter ID of the <code>FilterSliderControl</code>.</p>
    #[doc(hidden)]
    pub source_filter_id: std::option::Option<std::string::String>,
    /// <p>The display options of a control.</p>
    #[doc(hidden)]
    pub display_options: std::option::Option<crate::model::SliderControlDisplayOptions>,
    /// <p>The type of <code>FilterSliderControl</code>. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>SINGLE_POINT</code>: Filter against(equals) a single data point.</p> </li>
    /// <li> <p> <code>RANGE</code>: Filter data that is in a specified range.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::SheetControlSliderType>,
    /// <p>The smaller value that is displayed at the left of the slider.</p>
    #[doc(hidden)]
    pub maximum_value: f64,
    /// <p>The larger value that is displayed at the right of the slider.</p>
    #[doc(hidden)]
    pub minimum_value: f64,
    /// <p>The number of increments that the slider bar is divided into.</p>
    #[doc(hidden)]
    pub step_size: f64,
}
impl FilterSliderControl {
    /// <p>The ID of the <code>FilterSliderControl</code>.</p>
    pub fn filter_control_id(&self) -> std::option::Option<&str> {
        self.filter_control_id.as_deref()
    }
    /// <p>The title of the <code>FilterSliderControl</code>.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The source filter ID of the <code>FilterSliderControl</code>.</p>
    pub fn source_filter_id(&self) -> std::option::Option<&str> {
        self.source_filter_id.as_deref()
    }
    /// <p>The display options of a control.</p>
    pub fn display_options(
        &self,
    ) -> std::option::Option<&crate::model::SliderControlDisplayOptions> {
        self.display_options.as_ref()
    }
    /// <p>The type of <code>FilterSliderControl</code>. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>SINGLE_POINT</code>: Filter against(equals) a single data point.</p> </li>
    /// <li> <p> <code>RANGE</code>: Filter data that is in a specified range.</p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&crate::model::SheetControlSliderType> {
        self.r#type.as_ref()
    }
    /// <p>The smaller value that is displayed at the left of the slider.</p>
    pub fn maximum_value(&self) -> f64 {
        self.maximum_value
    }
    /// <p>The larger value that is displayed at the right of the slider.</p>
    pub fn minimum_value(&self) -> f64 {
        self.minimum_value
    }
    /// <p>The number of increments that the slider bar is divided into.</p>
    pub fn step_size(&self) -> f64 {
        self.step_size
    }
}
/// See [`FilterSliderControl`](crate::model::FilterSliderControl).
pub mod filter_slider_control {

    /// A builder for [`FilterSliderControl`](crate::model::FilterSliderControl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_control_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) source_filter_id: std::option::Option<std::string::String>,
        pub(crate) display_options: std::option::Option<crate::model::SliderControlDisplayOptions>,
        pub(crate) r#type: std::option::Option<crate::model::SheetControlSliderType>,
        pub(crate) maximum_value: std::option::Option<f64>,
        pub(crate) minimum_value: std::option::Option<f64>,
        pub(crate) step_size: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The ID of the <code>FilterSliderControl</code>.</p>
        pub fn filter_control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_control_id = Some(input.into());
            self
        }
        /// <p>The ID of the <code>FilterSliderControl</code>.</p>
        pub fn set_filter_control_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filter_control_id = input;
            self
        }
        /// <p>The title of the <code>FilterSliderControl</code>.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the <code>FilterSliderControl</code>.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The source filter ID of the <code>FilterSliderControl</code>.</p>
        pub fn source_filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_filter_id = Some(input.into());
            self
        }
        /// <p>The source filter ID of the <code>FilterSliderControl</code>.</p>
        pub fn set_source_filter_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_filter_id = input;
            self
        }
        /// <p>The display options of a control.</p>
        pub fn display_options(mut self, input: crate::model::SliderControlDisplayOptions) -> Self {
            self.display_options = Some(input);
            self
        }
        /// <p>The display options of a control.</p>
        pub fn set_display_options(
            mut self,
            input: std::option::Option<crate::model::SliderControlDisplayOptions>,
        ) -> Self {
            self.display_options = input;
            self
        }
        /// <p>The type of <code>FilterSliderControl</code>. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>SINGLE_POINT</code>: Filter against(equals) a single data point.</p> </li>
        /// <li> <p> <code>RANGE</code>: Filter data that is in a specified range.</p> </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::SheetControlSliderType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of <code>FilterSliderControl</code>. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>SINGLE_POINT</code>: Filter against(equals) a single data point.</p> </li>
        /// <li> <p> <code>RANGE</code>: Filter data that is in a specified range.</p> </li>
        /// </ul>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::SheetControlSliderType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The smaller value that is displayed at the left of the slider.</p>
        pub fn maximum_value(mut self, input: f64) -> Self {
            self.maximum_value = Some(input);
            self
        }
        /// <p>The smaller value that is displayed at the left of the slider.</p>
        pub fn set_maximum_value(mut self, input: std::option::Option<f64>) -> Self {
            self.maximum_value = input;
            self
        }
        /// <p>The larger value that is displayed at the right of the slider.</p>
        pub fn minimum_value(mut self, input: f64) -> Self {
            self.minimum_value = Some(input);
            self
        }
        /// <p>The larger value that is displayed at the right of the slider.</p>
        pub fn set_minimum_value(mut self, input: std::option::Option<f64>) -> Self {
            self.minimum_value = input;
            self
        }
        /// <p>The number of increments that the slider bar is divided into.</p>
        pub fn step_size(mut self, input: f64) -> Self {
            self.step_size = Some(input);
            self
        }
        /// <p>The number of increments that the slider bar is divided into.</p>
        pub fn set_step_size(mut self, input: std::option::Option<f64>) -> Self {
            self.step_size = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterSliderControl`](crate::model::FilterSliderControl).
        pub fn build(self) -> crate::model::FilterSliderControl {
            crate::model::FilterSliderControl {
                filter_control_id: self.filter_control_id,
                title: self.title,
                source_filter_id: self.source_filter_id,
                display_options: self.display_options,
                r#type: self.r#type,
                maximum_value: self.maximum_value.unwrap_or_default(),
                minimum_value: self.minimum_value.unwrap_or_default(),
                step_size: self.step_size.unwrap_or_default(),
            }
        }
    }
}
impl FilterSliderControl {
    /// Creates a new builder-style object to manufacture [`FilterSliderControl`](crate::model::FilterSliderControl).
    pub fn builder() -> crate::model::filter_slider_control::Builder {
        crate::model::filter_slider_control::Builder::default()
    }
}

/// When writing a match expression against `SheetControlSliderType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sheetcontrolslidertype = unimplemented!();
/// match sheetcontrolslidertype {
///     SheetControlSliderType::Range => { /* ... */ },
///     SheetControlSliderType::SinglePoint => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sheetcontrolslidertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SheetControlSliderType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SheetControlSliderType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SheetControlSliderType::NewFeature` is defined.
/// Specifically, when `sheetcontrolslidertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SheetControlSliderType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SheetControlSliderType {
    #[allow(missing_docs)] // documentation missing in model
    Range,
    #[allow(missing_docs)] // documentation missing in model
    SinglePoint,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SheetControlSliderType {
    fn from(s: &str) -> Self {
        match s {
            "RANGE" => SheetControlSliderType::Range,
            "SINGLE_POINT" => SheetControlSliderType::SinglePoint,
            other => {
                SheetControlSliderType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SheetControlSliderType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SheetControlSliderType::from(s))
    }
}
impl SheetControlSliderType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SheetControlSliderType::Range => "RANGE",
            SheetControlSliderType::SinglePoint => "SINGLE_POINT",
            SheetControlSliderType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["RANGE", "SINGLE_POINT"]
    }
}
impl AsRef<str> for SheetControlSliderType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The display options of a control.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SliderControlDisplayOptions {
    /// <p>The options to configure the title visibility, name, and font size.</p>
    #[doc(hidden)]
    pub title_options: std::option::Option<crate::model::LabelOptions>,
}
impl SliderControlDisplayOptions {
    /// <p>The options to configure the title visibility, name, and font size.</p>
    pub fn title_options(&self) -> std::option::Option<&crate::model::LabelOptions> {
        self.title_options.as_ref()
    }
}
/// See [`SliderControlDisplayOptions`](crate::model::SliderControlDisplayOptions).
pub mod slider_control_display_options {

    /// A builder for [`SliderControlDisplayOptions`](crate::model::SliderControlDisplayOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) title_options: std::option::Option<crate::model::LabelOptions>,
    }
    impl Builder {
        /// <p>The options to configure the title visibility, name, and font size.</p>
        pub fn title_options(mut self, input: crate::model::LabelOptions) -> Self {
            self.title_options = Some(input);
            self
        }
        /// <p>The options to configure the title visibility, name, and font size.</p>
        pub fn set_title_options(
            mut self,
            input: std::option::Option<crate::model::LabelOptions>,
        ) -> Self {
            self.title_options = input;
            self
        }
        /// Consumes the builder and constructs a [`SliderControlDisplayOptions`](crate::model::SliderControlDisplayOptions).
        pub fn build(self) -> crate::model::SliderControlDisplayOptions {
            crate::model::SliderControlDisplayOptions {
                title_options: self.title_options,
            }
        }
    }
}
impl SliderControlDisplayOptions {
    /// Creates a new builder-style object to manufacture [`SliderControlDisplayOptions`](crate::model::SliderControlDisplayOptions).
    pub fn builder() -> crate::model::slider_control_display_options::Builder {
        crate::model::slider_control_display_options::Builder::default()
    }
}

/// <p>A control to display a text box that is used to enter multiple entries.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterTextAreaControl {
    /// <p>The ID of the <code>FilterTextAreaControl</code>.</p>
    #[doc(hidden)]
    pub filter_control_id: std::option::Option<std::string::String>,
    /// <p>The title of the <code>FilterTextAreaControl</code>.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The source filter ID of the <code>FilterTextAreaControl</code>.</p>
    #[doc(hidden)]
    pub source_filter_id: std::option::Option<std::string::String>,
    /// <p>The delimiter that is used to separate the lines in text.</p>
    #[doc(hidden)]
    pub delimiter: std::option::Option<std::string::String>,
    /// <p>The display options of a control.</p>
    #[doc(hidden)]
    pub display_options: std::option::Option<crate::model::TextAreaControlDisplayOptions>,
}
impl FilterTextAreaControl {
    /// <p>The ID of the <code>FilterTextAreaControl</code>.</p>
    pub fn filter_control_id(&self) -> std::option::Option<&str> {
        self.filter_control_id.as_deref()
    }
    /// <p>The title of the <code>FilterTextAreaControl</code>.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The source filter ID of the <code>FilterTextAreaControl</code>.</p>
    pub fn source_filter_id(&self) -> std::option::Option<&str> {
        self.source_filter_id.as_deref()
    }
    /// <p>The delimiter that is used to separate the lines in text.</p>
    pub fn delimiter(&self) -> std::option::Option<&str> {
        self.delimiter.as_deref()
    }
    /// <p>The display options of a control.</p>
    pub fn display_options(
        &self,
    ) -> std::option::Option<&crate::model::TextAreaControlDisplayOptions> {
        self.display_options.as_ref()
    }
}
/// See [`FilterTextAreaControl`](crate::model::FilterTextAreaControl).
pub mod filter_text_area_control {

    /// A builder for [`FilterTextAreaControl`](crate::model::FilterTextAreaControl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_control_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) source_filter_id: std::option::Option<std::string::String>,
        pub(crate) delimiter: std::option::Option<std::string::String>,
        pub(crate) display_options:
            std::option::Option<crate::model::TextAreaControlDisplayOptions>,
    }
    impl Builder {
        /// <p>The ID of the <code>FilterTextAreaControl</code>.</p>
        pub fn filter_control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_control_id = Some(input.into());
            self
        }
        /// <p>The ID of the <code>FilterTextAreaControl</code>.</p>
        pub fn set_filter_control_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filter_control_id = input;
            self
        }
        /// <p>The title of the <code>FilterTextAreaControl</code>.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the <code>FilterTextAreaControl</code>.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The source filter ID of the <code>FilterTextAreaControl</code>.</p>
        pub fn source_filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_filter_id = Some(input.into());
            self
        }
        /// <p>The source filter ID of the <code>FilterTextAreaControl</code>.</p>
        pub fn set_source_filter_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_filter_id = input;
            self
        }
        /// <p>The delimiter that is used to separate the lines in text.</p>
        pub fn delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.delimiter = Some(input.into());
            self
        }
        /// <p>The delimiter that is used to separate the lines in text.</p>
        pub fn set_delimiter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.delimiter = input;
            self
        }
        /// <p>The display options of a control.</p>
        pub fn display_options(
            mut self,
            input: crate::model::TextAreaControlDisplayOptions,
        ) -> Self {
            self.display_options = Some(input);
            self
        }
        /// <p>The display options of a control.</p>
        pub fn set_display_options(
            mut self,
            input: std::option::Option<crate::model::TextAreaControlDisplayOptions>,
        ) -> Self {
            self.display_options = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterTextAreaControl`](crate::model::FilterTextAreaControl).
        pub fn build(self) -> crate::model::FilterTextAreaControl {
            crate::model::FilterTextAreaControl {
                filter_control_id: self.filter_control_id,
                title: self.title,
                source_filter_id: self.source_filter_id,
                delimiter: self.delimiter,
                display_options: self.display_options,
            }
        }
    }
}
impl FilterTextAreaControl {
    /// Creates a new builder-style object to manufacture [`FilterTextAreaControl`](crate::model::FilterTextAreaControl).
    pub fn builder() -> crate::model::filter_text_area_control::Builder {
        crate::model::filter_text_area_control::Builder::default()
    }
}

/// <p>The display options of a control.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TextAreaControlDisplayOptions {
    /// <p>The options to configure the title visibility, name, and font size.</p>
    #[doc(hidden)]
    pub title_options: std::option::Option<crate::model::LabelOptions>,
    /// <p>The configuration of the placeholder options in a text area control.</p>
    #[doc(hidden)]
    pub placeholder_options: std::option::Option<crate::model::TextControlPlaceholderOptions>,
}
impl TextAreaControlDisplayOptions {
    /// <p>The options to configure the title visibility, name, and font size.</p>
    pub fn title_options(&self) -> std::option::Option<&crate::model::LabelOptions> {
        self.title_options.as_ref()
    }
    /// <p>The configuration of the placeholder options in a text area control.</p>
    pub fn placeholder_options(
        &self,
    ) -> std::option::Option<&crate::model::TextControlPlaceholderOptions> {
        self.placeholder_options.as_ref()
    }
}
/// See [`TextAreaControlDisplayOptions`](crate::model::TextAreaControlDisplayOptions).
pub mod text_area_control_display_options {

    /// A builder for [`TextAreaControlDisplayOptions`](crate::model::TextAreaControlDisplayOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) title_options: std::option::Option<crate::model::LabelOptions>,
        pub(crate) placeholder_options:
            std::option::Option<crate::model::TextControlPlaceholderOptions>,
    }
    impl Builder {
        /// <p>The options to configure the title visibility, name, and font size.</p>
        pub fn title_options(mut self, input: crate::model::LabelOptions) -> Self {
            self.title_options = Some(input);
            self
        }
        /// <p>The options to configure the title visibility, name, and font size.</p>
        pub fn set_title_options(
            mut self,
            input: std::option::Option<crate::model::LabelOptions>,
        ) -> Self {
            self.title_options = input;
            self
        }
        /// <p>The configuration of the placeholder options in a text area control.</p>
        pub fn placeholder_options(
            mut self,
            input: crate::model::TextControlPlaceholderOptions,
        ) -> Self {
            self.placeholder_options = Some(input);
            self
        }
        /// <p>The configuration of the placeholder options in a text area control.</p>
        pub fn set_placeholder_options(
            mut self,
            input: std::option::Option<crate::model::TextControlPlaceholderOptions>,
        ) -> Self {
            self.placeholder_options = input;
            self
        }
        /// Consumes the builder and constructs a [`TextAreaControlDisplayOptions`](crate::model::TextAreaControlDisplayOptions).
        pub fn build(self) -> crate::model::TextAreaControlDisplayOptions {
            crate::model::TextAreaControlDisplayOptions {
                title_options: self.title_options,
                placeholder_options: self.placeholder_options,
            }
        }
    }
}
impl TextAreaControlDisplayOptions {
    /// Creates a new builder-style object to manufacture [`TextAreaControlDisplayOptions`](crate::model::TextAreaControlDisplayOptions).
    pub fn builder() -> crate::model::text_area_control_display_options::Builder {
        crate::model::text_area_control_display_options::Builder::default()
    }
}

/// <p>The configuration of the placeholder options in a text control.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TextControlPlaceholderOptions {
    /// <p>The visibility configuration of the placeholder options in a text control.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
}
impl TextControlPlaceholderOptions {
    /// <p>The visibility configuration of the placeholder options in a text control.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
}
/// See [`TextControlPlaceholderOptions`](crate::model::TextControlPlaceholderOptions).
pub mod text_control_placeholder_options {

    /// A builder for [`TextControlPlaceholderOptions`](crate::model::TextControlPlaceholderOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>The visibility configuration of the placeholder options in a text control.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility configuration of the placeholder options in a text control.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`TextControlPlaceholderOptions`](crate::model::TextControlPlaceholderOptions).
        pub fn build(self) -> crate::model::TextControlPlaceholderOptions {
            crate::model::TextControlPlaceholderOptions {
                visibility: self.visibility,
            }
        }
    }
}
impl TextControlPlaceholderOptions {
    /// Creates a new builder-style object to manufacture [`TextControlPlaceholderOptions`](crate::model::TextControlPlaceholderOptions).
    pub fn builder() -> crate::model::text_control_placeholder_options::Builder {
        crate::model::text_control_placeholder_options::Builder::default()
    }
}

/// <p>A control to display a text box that is used to enter a single entry.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterTextFieldControl {
    /// <p>The ID of the <code>FilterTextFieldControl</code>.</p>
    #[doc(hidden)]
    pub filter_control_id: std::option::Option<std::string::String>,
    /// <p>The title of the <code>FilterTextFieldControl</code>.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The source filter ID of the <code>FilterTextFieldControl</code>.</p>
    #[doc(hidden)]
    pub source_filter_id: std::option::Option<std::string::String>,
    /// <p>The display options of a control.</p>
    #[doc(hidden)]
    pub display_options: std::option::Option<crate::model::TextFieldControlDisplayOptions>,
}
impl FilterTextFieldControl {
    /// <p>The ID of the <code>FilterTextFieldControl</code>.</p>
    pub fn filter_control_id(&self) -> std::option::Option<&str> {
        self.filter_control_id.as_deref()
    }
    /// <p>The title of the <code>FilterTextFieldControl</code>.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The source filter ID of the <code>FilterTextFieldControl</code>.</p>
    pub fn source_filter_id(&self) -> std::option::Option<&str> {
        self.source_filter_id.as_deref()
    }
    /// <p>The display options of a control.</p>
    pub fn display_options(
        &self,
    ) -> std::option::Option<&crate::model::TextFieldControlDisplayOptions> {
        self.display_options.as_ref()
    }
}
/// See [`FilterTextFieldControl`](crate::model::FilterTextFieldControl).
pub mod filter_text_field_control {

    /// A builder for [`FilterTextFieldControl`](crate::model::FilterTextFieldControl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_control_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) source_filter_id: std::option::Option<std::string::String>,
        pub(crate) display_options:
            std::option::Option<crate::model::TextFieldControlDisplayOptions>,
    }
    impl Builder {
        /// <p>The ID of the <code>FilterTextFieldControl</code>.</p>
        pub fn filter_control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_control_id = Some(input.into());
            self
        }
        /// <p>The ID of the <code>FilterTextFieldControl</code>.</p>
        pub fn set_filter_control_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filter_control_id = input;
            self
        }
        /// <p>The title of the <code>FilterTextFieldControl</code>.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the <code>FilterTextFieldControl</code>.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The source filter ID of the <code>FilterTextFieldControl</code>.</p>
        pub fn source_filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_filter_id = Some(input.into());
            self
        }
        /// <p>The source filter ID of the <code>FilterTextFieldControl</code>.</p>
        pub fn set_source_filter_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_filter_id = input;
            self
        }
        /// <p>The display options of a control.</p>
        pub fn display_options(
            mut self,
            input: crate::model::TextFieldControlDisplayOptions,
        ) -> Self {
            self.display_options = Some(input);
            self
        }
        /// <p>The display options of a control.</p>
        pub fn set_display_options(
            mut self,
            input: std::option::Option<crate::model::TextFieldControlDisplayOptions>,
        ) -> Self {
            self.display_options = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterTextFieldControl`](crate::model::FilterTextFieldControl).
        pub fn build(self) -> crate::model::FilterTextFieldControl {
            crate::model::FilterTextFieldControl {
                filter_control_id: self.filter_control_id,
                title: self.title,
                source_filter_id: self.source_filter_id,
                display_options: self.display_options,
            }
        }
    }
}
impl FilterTextFieldControl {
    /// Creates a new builder-style object to manufacture [`FilterTextFieldControl`](crate::model::FilterTextFieldControl).
    pub fn builder() -> crate::model::filter_text_field_control::Builder {
        crate::model::filter_text_field_control::Builder::default()
    }
}

/// <p>The display options of a control.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TextFieldControlDisplayOptions {
    /// <p>The options to configure the title visibility, name, and font size.</p>
    #[doc(hidden)]
    pub title_options: std::option::Option<crate::model::LabelOptions>,
    /// <p>The configuration of the placeholder options in a text field control.</p>
    #[doc(hidden)]
    pub placeholder_options: std::option::Option<crate::model::TextControlPlaceholderOptions>,
}
impl TextFieldControlDisplayOptions {
    /// <p>The options to configure the title visibility, name, and font size.</p>
    pub fn title_options(&self) -> std::option::Option<&crate::model::LabelOptions> {
        self.title_options.as_ref()
    }
    /// <p>The configuration of the placeholder options in a text field control.</p>
    pub fn placeholder_options(
        &self,
    ) -> std::option::Option<&crate::model::TextControlPlaceholderOptions> {
        self.placeholder_options.as_ref()
    }
}
/// See [`TextFieldControlDisplayOptions`](crate::model::TextFieldControlDisplayOptions).
pub mod text_field_control_display_options {

    /// A builder for [`TextFieldControlDisplayOptions`](crate::model::TextFieldControlDisplayOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) title_options: std::option::Option<crate::model::LabelOptions>,
        pub(crate) placeholder_options:
            std::option::Option<crate::model::TextControlPlaceholderOptions>,
    }
    impl Builder {
        /// <p>The options to configure the title visibility, name, and font size.</p>
        pub fn title_options(mut self, input: crate::model::LabelOptions) -> Self {
            self.title_options = Some(input);
            self
        }
        /// <p>The options to configure the title visibility, name, and font size.</p>
        pub fn set_title_options(
            mut self,
            input: std::option::Option<crate::model::LabelOptions>,
        ) -> Self {
            self.title_options = input;
            self
        }
        /// <p>The configuration of the placeholder options in a text field control.</p>
        pub fn placeholder_options(
            mut self,
            input: crate::model::TextControlPlaceholderOptions,
        ) -> Self {
            self.placeholder_options = Some(input);
            self
        }
        /// <p>The configuration of the placeholder options in a text field control.</p>
        pub fn set_placeholder_options(
            mut self,
            input: std::option::Option<crate::model::TextControlPlaceholderOptions>,
        ) -> Self {
            self.placeholder_options = input;
            self
        }
        /// Consumes the builder and constructs a [`TextFieldControlDisplayOptions`](crate::model::TextFieldControlDisplayOptions).
        pub fn build(self) -> crate::model::TextFieldControlDisplayOptions {
            crate::model::TextFieldControlDisplayOptions {
                title_options: self.title_options,
                placeholder_options: self.placeholder_options,
            }
        }
    }
}
impl TextFieldControlDisplayOptions {
    /// Creates a new builder-style object to manufacture [`TextFieldControlDisplayOptions`](crate::model::TextFieldControlDisplayOptions).
    pub fn builder() -> crate::model::text_field_control_display_options::Builder {
        crate::model::text_field_control_display_options::Builder::default()
    }
}

/// <p>A control to display a dropdown list with buttons that are used to select a single value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterDropDownControl {
    /// <p>The ID of the <code>FilterDropDownControl</code>.</p>
    #[doc(hidden)]
    pub filter_control_id: std::option::Option<std::string::String>,
    /// <p>The title of the <code>FilterDropDownControl</code>.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The source filter ID of the <code>FilterDropDownControl</code>.</p>
    #[doc(hidden)]
    pub source_filter_id: std::option::Option<std::string::String>,
    /// <p>The display options of the <code>FilterDropDownControl</code>.</p>
    #[doc(hidden)]
    pub display_options: std::option::Option<crate::model::DropDownControlDisplayOptions>,
    /// <p>The type of the <code>FilterDropDownControl</code>. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>MULTI_SELECT</code>: The user can select multiple entries from a dropdown menu.</p> </li>
    /// <li> <p> <code>SINGLE_SELECT</code>: The user can select a single entry from a dropdown menu.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::SheetControlListType>,
    /// <p>A list of selectable values that are used in a control.</p>
    #[doc(hidden)]
    pub selectable_values: std::option::Option<crate::model::FilterSelectableValues>,
    /// <p>The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.</p>
    #[doc(hidden)]
    pub cascading_control_configuration:
        std::option::Option<crate::model::CascadingControlConfiguration>,
}
impl FilterDropDownControl {
    /// <p>The ID of the <code>FilterDropDownControl</code>.</p>
    pub fn filter_control_id(&self) -> std::option::Option<&str> {
        self.filter_control_id.as_deref()
    }
    /// <p>The title of the <code>FilterDropDownControl</code>.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The source filter ID of the <code>FilterDropDownControl</code>.</p>
    pub fn source_filter_id(&self) -> std::option::Option<&str> {
        self.source_filter_id.as_deref()
    }
    /// <p>The display options of the <code>FilterDropDownControl</code>.</p>
    pub fn display_options(
        &self,
    ) -> std::option::Option<&crate::model::DropDownControlDisplayOptions> {
        self.display_options.as_ref()
    }
    /// <p>The type of the <code>FilterDropDownControl</code>. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>MULTI_SELECT</code>: The user can select multiple entries from a dropdown menu.</p> </li>
    /// <li> <p> <code>SINGLE_SELECT</code>: The user can select a single entry from a dropdown menu.</p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&crate::model::SheetControlListType> {
        self.r#type.as_ref()
    }
    /// <p>A list of selectable values that are used in a control.</p>
    pub fn selectable_values(&self) -> std::option::Option<&crate::model::FilterSelectableValues> {
        self.selectable_values.as_ref()
    }
    /// <p>The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.</p>
    pub fn cascading_control_configuration(
        &self,
    ) -> std::option::Option<&crate::model::CascadingControlConfiguration> {
        self.cascading_control_configuration.as_ref()
    }
}
/// See [`FilterDropDownControl`](crate::model::FilterDropDownControl).
pub mod filter_drop_down_control {

    /// A builder for [`FilterDropDownControl`](crate::model::FilterDropDownControl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_control_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) source_filter_id: std::option::Option<std::string::String>,
        pub(crate) display_options:
            std::option::Option<crate::model::DropDownControlDisplayOptions>,
        pub(crate) r#type: std::option::Option<crate::model::SheetControlListType>,
        pub(crate) selectable_values: std::option::Option<crate::model::FilterSelectableValues>,
        pub(crate) cascading_control_configuration:
            std::option::Option<crate::model::CascadingControlConfiguration>,
    }
    impl Builder {
        /// <p>The ID of the <code>FilterDropDownControl</code>.</p>
        pub fn filter_control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_control_id = Some(input.into());
            self
        }
        /// <p>The ID of the <code>FilterDropDownControl</code>.</p>
        pub fn set_filter_control_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filter_control_id = input;
            self
        }
        /// <p>The title of the <code>FilterDropDownControl</code>.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the <code>FilterDropDownControl</code>.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The source filter ID of the <code>FilterDropDownControl</code>.</p>
        pub fn source_filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_filter_id = Some(input.into());
            self
        }
        /// <p>The source filter ID of the <code>FilterDropDownControl</code>.</p>
        pub fn set_source_filter_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_filter_id = input;
            self
        }
        /// <p>The display options of the <code>FilterDropDownControl</code>.</p>
        pub fn display_options(
            mut self,
            input: crate::model::DropDownControlDisplayOptions,
        ) -> Self {
            self.display_options = Some(input);
            self
        }
        /// <p>The display options of the <code>FilterDropDownControl</code>.</p>
        pub fn set_display_options(
            mut self,
            input: std::option::Option<crate::model::DropDownControlDisplayOptions>,
        ) -> Self {
            self.display_options = input;
            self
        }
        /// <p>The type of the <code>FilterDropDownControl</code>. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>MULTI_SELECT</code>: The user can select multiple entries from a dropdown menu.</p> </li>
        /// <li> <p> <code>SINGLE_SELECT</code>: The user can select a single entry from a dropdown menu.</p> </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::SheetControlListType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the <code>FilterDropDownControl</code>. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>MULTI_SELECT</code>: The user can select multiple entries from a dropdown menu.</p> </li>
        /// <li> <p> <code>SINGLE_SELECT</code>: The user can select a single entry from a dropdown menu.</p> </li>
        /// </ul>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::SheetControlListType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>A list of selectable values that are used in a control.</p>
        pub fn selectable_values(mut self, input: crate::model::FilterSelectableValues) -> Self {
            self.selectable_values = Some(input);
            self
        }
        /// <p>A list of selectable values that are used in a control.</p>
        pub fn set_selectable_values(
            mut self,
            input: std::option::Option<crate::model::FilterSelectableValues>,
        ) -> Self {
            self.selectable_values = input;
            self
        }
        /// <p>The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.</p>
        pub fn cascading_control_configuration(
            mut self,
            input: crate::model::CascadingControlConfiguration,
        ) -> Self {
            self.cascading_control_configuration = Some(input);
            self
        }
        /// <p>The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.</p>
        pub fn set_cascading_control_configuration(
            mut self,
            input: std::option::Option<crate::model::CascadingControlConfiguration>,
        ) -> Self {
            self.cascading_control_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterDropDownControl`](crate::model::FilterDropDownControl).
        pub fn build(self) -> crate::model::FilterDropDownControl {
            crate::model::FilterDropDownControl {
                filter_control_id: self.filter_control_id,
                title: self.title,
                source_filter_id: self.source_filter_id,
                display_options: self.display_options,
                r#type: self.r#type,
                selectable_values: self.selectable_values,
                cascading_control_configuration: self.cascading_control_configuration,
            }
        }
    }
}
impl FilterDropDownControl {
    /// Creates a new builder-style object to manufacture [`FilterDropDownControl`](crate::model::FilterDropDownControl).
    pub fn builder() -> crate::model::filter_drop_down_control::Builder {
        crate::model::filter_drop_down_control::Builder::default()
    }
}

/// <p>The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CascadingControlConfiguration {
    /// <p>A list of source controls that determine the values that are used in the current control.</p>
    #[doc(hidden)]
    pub source_controls: std::option::Option<std::vec::Vec<crate::model::CascadingControlSource>>,
}
impl CascadingControlConfiguration {
    /// <p>A list of source controls that determine the values that are used in the current control.</p>
    pub fn source_controls(&self) -> std::option::Option<&[crate::model::CascadingControlSource]> {
        self.source_controls.as_deref()
    }
}
/// See [`CascadingControlConfiguration`](crate::model::CascadingControlConfiguration).
pub mod cascading_control_configuration {

    /// A builder for [`CascadingControlConfiguration`](crate::model::CascadingControlConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_controls:
            std::option::Option<std::vec::Vec<crate::model::CascadingControlSource>>,
    }
    impl Builder {
        /// Appends an item to `source_controls`.
        ///
        /// To override the contents of this collection use [`set_source_controls`](Self::set_source_controls).
        ///
        /// <p>A list of source controls that determine the values that are used in the current control.</p>
        pub fn source_controls(mut self, input: crate::model::CascadingControlSource) -> Self {
            let mut v = self.source_controls.unwrap_or_default();
            v.push(input);
            self.source_controls = Some(v);
            self
        }
        /// <p>A list of source controls that determine the values that are used in the current control.</p>
        pub fn set_source_controls(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CascadingControlSource>>,
        ) -> Self {
            self.source_controls = input;
            self
        }
        /// Consumes the builder and constructs a [`CascadingControlConfiguration`](crate::model::CascadingControlConfiguration).
        pub fn build(self) -> crate::model::CascadingControlConfiguration {
            crate::model::CascadingControlConfiguration {
                source_controls: self.source_controls,
            }
        }
    }
}
impl CascadingControlConfiguration {
    /// Creates a new builder-style object to manufacture [`CascadingControlConfiguration`](crate::model::CascadingControlConfiguration).
    pub fn builder() -> crate::model::cascading_control_configuration::Builder {
        crate::model::cascading_control_configuration::Builder::default()
    }
}

/// <p>The source controls that are used in a <code>CascadingControlConfiguration</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CascadingControlSource {
    /// <p>The source sheet control ID of a <code>CascadingControlSource</code>.</p>
    #[doc(hidden)]
    pub source_sheet_control_id: std::option::Option<std::string::String>,
    /// <p>The column identifier that determines which column to look up for the source sheet control.</p>
    #[doc(hidden)]
    pub column_to_match: std::option::Option<crate::model::ColumnIdentifier>,
}
impl CascadingControlSource {
    /// <p>The source sheet control ID of a <code>CascadingControlSource</code>.</p>
    pub fn source_sheet_control_id(&self) -> std::option::Option<&str> {
        self.source_sheet_control_id.as_deref()
    }
    /// <p>The column identifier that determines which column to look up for the source sheet control.</p>
    pub fn column_to_match(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.column_to_match.as_ref()
    }
}
/// See [`CascadingControlSource`](crate::model::CascadingControlSource).
pub mod cascading_control_source {

    /// A builder for [`CascadingControlSource`](crate::model::CascadingControlSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_sheet_control_id: std::option::Option<std::string::String>,
        pub(crate) column_to_match: std::option::Option<crate::model::ColumnIdentifier>,
    }
    impl Builder {
        /// <p>The source sheet control ID of a <code>CascadingControlSource</code>.</p>
        pub fn source_sheet_control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_sheet_control_id = Some(input.into());
            self
        }
        /// <p>The source sheet control ID of a <code>CascadingControlSource</code>.</p>
        pub fn set_source_sheet_control_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_sheet_control_id = input;
            self
        }
        /// <p>The column identifier that determines which column to look up for the source sheet control.</p>
        pub fn column_to_match(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.column_to_match = Some(input);
            self
        }
        /// <p>The column identifier that determines which column to look up for the source sheet control.</p>
        pub fn set_column_to_match(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.column_to_match = input;
            self
        }
        /// Consumes the builder and constructs a [`CascadingControlSource`](crate::model::CascadingControlSource).
        pub fn build(self) -> crate::model::CascadingControlSource {
            crate::model::CascadingControlSource {
                source_sheet_control_id: self.source_sheet_control_id,
                column_to_match: self.column_to_match,
            }
        }
    }
}
impl CascadingControlSource {
    /// Creates a new builder-style object to manufacture [`CascadingControlSource`](crate::model::CascadingControlSource).
    pub fn builder() -> crate::model::cascading_control_source::Builder {
        crate::model::cascading_control_source::Builder::default()
    }
}

/// <p>A list of selectable values that are used in a control.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterSelectableValues {
    /// <p>The values that are used in the <code>FilterSelectableValues</code>.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl FilterSelectableValues {
    /// <p>The values that are used in the <code>FilterSelectableValues</code>.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
/// See [`FilterSelectableValues`](crate::model::FilterSelectableValues).
pub mod filter_selectable_values {

    /// A builder for [`FilterSelectableValues`](crate::model::FilterSelectableValues).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The values that are used in the <code>FilterSelectableValues</code>.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>The values that are used in the <code>FilterSelectableValues</code>.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterSelectableValues`](crate::model::FilterSelectableValues).
        pub fn build(self) -> crate::model::FilterSelectableValues {
            crate::model::FilterSelectableValues {
                values: self.values,
            }
        }
    }
}
impl FilterSelectableValues {
    /// Creates a new builder-style object to manufacture [`FilterSelectableValues`](crate::model::FilterSelectableValues).
    pub fn builder() -> crate::model::filter_selectable_values::Builder {
        crate::model::filter_selectable_values::Builder::default()
    }
}

/// When writing a match expression against `SheetControlListType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sheetcontrollisttype = unimplemented!();
/// match sheetcontrollisttype {
///     SheetControlListType::MultiSelect => { /* ... */ },
///     SheetControlListType::SingleSelect => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sheetcontrollisttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SheetControlListType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SheetControlListType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SheetControlListType::NewFeature` is defined.
/// Specifically, when `sheetcontrollisttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SheetControlListType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SheetControlListType {
    #[allow(missing_docs)] // documentation missing in model
    MultiSelect,
    #[allow(missing_docs)] // documentation missing in model
    SingleSelect,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SheetControlListType {
    fn from(s: &str) -> Self {
        match s {
            "MULTI_SELECT" => SheetControlListType::MultiSelect,
            "SINGLE_SELECT" => SheetControlListType::SingleSelect,
            other => {
                SheetControlListType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SheetControlListType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SheetControlListType::from(s))
    }
}
impl SheetControlListType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SheetControlListType::MultiSelect => "MULTI_SELECT",
            SheetControlListType::SingleSelect => "SINGLE_SELECT",
            SheetControlListType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["MULTI_SELECT", "SINGLE_SELECT"]
    }
}
impl AsRef<str> for SheetControlListType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The display options of a control.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DropDownControlDisplayOptions {
    /// <p>The configuration of the <code>Select all</code> options in a dropdown control.</p>
    #[doc(hidden)]
    pub select_all_options: std::option::Option<crate::model::ListControlSelectAllOptions>,
    /// <p>The options to configure the title visibility, name, and font size.</p>
    #[doc(hidden)]
    pub title_options: std::option::Option<crate::model::LabelOptions>,
}
impl DropDownControlDisplayOptions {
    /// <p>The configuration of the <code>Select all</code> options in a dropdown control.</p>
    pub fn select_all_options(
        &self,
    ) -> std::option::Option<&crate::model::ListControlSelectAllOptions> {
        self.select_all_options.as_ref()
    }
    /// <p>The options to configure the title visibility, name, and font size.</p>
    pub fn title_options(&self) -> std::option::Option<&crate::model::LabelOptions> {
        self.title_options.as_ref()
    }
}
/// See [`DropDownControlDisplayOptions`](crate::model::DropDownControlDisplayOptions).
pub mod drop_down_control_display_options {

    /// A builder for [`DropDownControlDisplayOptions`](crate::model::DropDownControlDisplayOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) select_all_options:
            std::option::Option<crate::model::ListControlSelectAllOptions>,
        pub(crate) title_options: std::option::Option<crate::model::LabelOptions>,
    }
    impl Builder {
        /// <p>The configuration of the <code>Select all</code> options in a dropdown control.</p>
        pub fn select_all_options(
            mut self,
            input: crate::model::ListControlSelectAllOptions,
        ) -> Self {
            self.select_all_options = Some(input);
            self
        }
        /// <p>The configuration of the <code>Select all</code> options in a dropdown control.</p>
        pub fn set_select_all_options(
            mut self,
            input: std::option::Option<crate::model::ListControlSelectAllOptions>,
        ) -> Self {
            self.select_all_options = input;
            self
        }
        /// <p>The options to configure the title visibility, name, and font size.</p>
        pub fn title_options(mut self, input: crate::model::LabelOptions) -> Self {
            self.title_options = Some(input);
            self
        }
        /// <p>The options to configure the title visibility, name, and font size.</p>
        pub fn set_title_options(
            mut self,
            input: std::option::Option<crate::model::LabelOptions>,
        ) -> Self {
            self.title_options = input;
            self
        }
        /// Consumes the builder and constructs a [`DropDownControlDisplayOptions`](crate::model::DropDownControlDisplayOptions).
        pub fn build(self) -> crate::model::DropDownControlDisplayOptions {
            crate::model::DropDownControlDisplayOptions {
                select_all_options: self.select_all_options,
                title_options: self.title_options,
            }
        }
    }
}
impl DropDownControlDisplayOptions {
    /// Creates a new builder-style object to manufacture [`DropDownControlDisplayOptions`](crate::model::DropDownControlDisplayOptions).
    pub fn builder() -> crate::model::drop_down_control_display_options::Builder {
        crate::model::drop_down_control_display_options::Builder::default()
    }
}

/// <p>The configuration of the <code>Select all</code> options in a list control.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListControlSelectAllOptions {
    /// <p>The visibility configuration of the <code>Select all</code> options in a list control.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
}
impl ListControlSelectAllOptions {
    /// <p>The visibility configuration of the <code>Select all</code> options in a list control.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
}
/// See [`ListControlSelectAllOptions`](crate::model::ListControlSelectAllOptions).
pub mod list_control_select_all_options {

    /// A builder for [`ListControlSelectAllOptions`](crate::model::ListControlSelectAllOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>The visibility configuration of the <code>Select all</code> options in a list control.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility configuration of the <code>Select all</code> options in a list control.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`ListControlSelectAllOptions`](crate::model::ListControlSelectAllOptions).
        pub fn build(self) -> crate::model::ListControlSelectAllOptions {
            crate::model::ListControlSelectAllOptions {
                visibility: self.visibility,
            }
        }
    }
}
impl ListControlSelectAllOptions {
    /// Creates a new builder-style object to manufacture [`ListControlSelectAllOptions`](crate::model::ListControlSelectAllOptions).
    pub fn builder() -> crate::model::list_control_select_all_options::Builder {
        crate::model::list_control_select_all_options::Builder::default()
    }
}

/// <p>A control to display a list of buttons or boxes. This is used to select either a single value or multiple values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterListControl {
    /// <p>The ID of the <code>FilterListControl</code>.</p>
    #[doc(hidden)]
    pub filter_control_id: std::option::Option<std::string::String>,
    /// <p>The title of the <code>FilterListControl</code>.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The source filter ID of the <code>FilterListControl</code>.</p>
    #[doc(hidden)]
    pub source_filter_id: std::option::Option<std::string::String>,
    /// <p>The display options of a control.</p>
    #[doc(hidden)]
    pub display_options: std::option::Option<crate::model::ListControlDisplayOptions>,
    /// <p>The type of <code>FilterListControl</code>. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>MULTI_SELECT</code>: The user can select multiple entries from the list.</p> </li>
    /// <li> <p> <code>SINGLE_SELECT</code>: The user can select a single entry from the list.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::SheetControlListType>,
    /// <p>A list of selectable values that are used in a control.</p>
    #[doc(hidden)]
    pub selectable_values: std::option::Option<crate::model::FilterSelectableValues>,
    /// <p>The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.</p>
    #[doc(hidden)]
    pub cascading_control_configuration:
        std::option::Option<crate::model::CascadingControlConfiguration>,
}
impl FilterListControl {
    /// <p>The ID of the <code>FilterListControl</code>.</p>
    pub fn filter_control_id(&self) -> std::option::Option<&str> {
        self.filter_control_id.as_deref()
    }
    /// <p>The title of the <code>FilterListControl</code>.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The source filter ID of the <code>FilterListControl</code>.</p>
    pub fn source_filter_id(&self) -> std::option::Option<&str> {
        self.source_filter_id.as_deref()
    }
    /// <p>The display options of a control.</p>
    pub fn display_options(&self) -> std::option::Option<&crate::model::ListControlDisplayOptions> {
        self.display_options.as_ref()
    }
    /// <p>The type of <code>FilterListControl</code>. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>MULTI_SELECT</code>: The user can select multiple entries from the list.</p> </li>
    /// <li> <p> <code>SINGLE_SELECT</code>: The user can select a single entry from the list.</p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&crate::model::SheetControlListType> {
        self.r#type.as_ref()
    }
    /// <p>A list of selectable values that are used in a control.</p>
    pub fn selectable_values(&self) -> std::option::Option<&crate::model::FilterSelectableValues> {
        self.selectable_values.as_ref()
    }
    /// <p>The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.</p>
    pub fn cascading_control_configuration(
        &self,
    ) -> std::option::Option<&crate::model::CascadingControlConfiguration> {
        self.cascading_control_configuration.as_ref()
    }
}
/// See [`FilterListControl`](crate::model::FilterListControl).
pub mod filter_list_control {

    /// A builder for [`FilterListControl`](crate::model::FilterListControl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_control_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) source_filter_id: std::option::Option<std::string::String>,
        pub(crate) display_options: std::option::Option<crate::model::ListControlDisplayOptions>,
        pub(crate) r#type: std::option::Option<crate::model::SheetControlListType>,
        pub(crate) selectable_values: std::option::Option<crate::model::FilterSelectableValues>,
        pub(crate) cascading_control_configuration:
            std::option::Option<crate::model::CascadingControlConfiguration>,
    }
    impl Builder {
        /// <p>The ID of the <code>FilterListControl</code>.</p>
        pub fn filter_control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_control_id = Some(input.into());
            self
        }
        /// <p>The ID of the <code>FilterListControl</code>.</p>
        pub fn set_filter_control_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filter_control_id = input;
            self
        }
        /// <p>The title of the <code>FilterListControl</code>.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the <code>FilterListControl</code>.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The source filter ID of the <code>FilterListControl</code>.</p>
        pub fn source_filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_filter_id = Some(input.into());
            self
        }
        /// <p>The source filter ID of the <code>FilterListControl</code>.</p>
        pub fn set_source_filter_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_filter_id = input;
            self
        }
        /// <p>The display options of a control.</p>
        pub fn display_options(mut self, input: crate::model::ListControlDisplayOptions) -> Self {
            self.display_options = Some(input);
            self
        }
        /// <p>The display options of a control.</p>
        pub fn set_display_options(
            mut self,
            input: std::option::Option<crate::model::ListControlDisplayOptions>,
        ) -> Self {
            self.display_options = input;
            self
        }
        /// <p>The type of <code>FilterListControl</code>. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>MULTI_SELECT</code>: The user can select multiple entries from the list.</p> </li>
        /// <li> <p> <code>SINGLE_SELECT</code>: The user can select a single entry from the list.</p> </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::SheetControlListType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of <code>FilterListControl</code>. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>MULTI_SELECT</code>: The user can select multiple entries from the list.</p> </li>
        /// <li> <p> <code>SINGLE_SELECT</code>: The user can select a single entry from the list.</p> </li>
        /// </ul>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::SheetControlListType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>A list of selectable values that are used in a control.</p>
        pub fn selectable_values(mut self, input: crate::model::FilterSelectableValues) -> Self {
            self.selectable_values = Some(input);
            self
        }
        /// <p>A list of selectable values that are used in a control.</p>
        pub fn set_selectable_values(
            mut self,
            input: std::option::Option<crate::model::FilterSelectableValues>,
        ) -> Self {
            self.selectable_values = input;
            self
        }
        /// <p>The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.</p>
        pub fn cascading_control_configuration(
            mut self,
            input: crate::model::CascadingControlConfiguration,
        ) -> Self {
            self.cascading_control_configuration = Some(input);
            self
        }
        /// <p>The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.</p>
        pub fn set_cascading_control_configuration(
            mut self,
            input: std::option::Option<crate::model::CascadingControlConfiguration>,
        ) -> Self {
            self.cascading_control_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterListControl`](crate::model::FilterListControl).
        pub fn build(self) -> crate::model::FilterListControl {
            crate::model::FilterListControl {
                filter_control_id: self.filter_control_id,
                title: self.title,
                source_filter_id: self.source_filter_id,
                display_options: self.display_options,
                r#type: self.r#type,
                selectable_values: self.selectable_values,
                cascading_control_configuration: self.cascading_control_configuration,
            }
        }
    }
}
impl FilterListControl {
    /// Creates a new builder-style object to manufacture [`FilterListControl`](crate::model::FilterListControl).
    pub fn builder() -> crate::model::filter_list_control::Builder {
        crate::model::filter_list_control::Builder::default()
    }
}

/// <p>The display options of a control.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListControlDisplayOptions {
    /// <p>The configuration of the search options in a list control.</p>
    #[doc(hidden)]
    pub search_options: std::option::Option<crate::model::ListControlSearchOptions>,
    /// <p>The configuration of the <code>Select all</code> options in a list control.</p>
    #[doc(hidden)]
    pub select_all_options: std::option::Option<crate::model::ListControlSelectAllOptions>,
    /// <p>The options to configure the title visibility, name, and font size.</p>
    #[doc(hidden)]
    pub title_options: std::option::Option<crate::model::LabelOptions>,
}
impl ListControlDisplayOptions {
    /// <p>The configuration of the search options in a list control.</p>
    pub fn search_options(&self) -> std::option::Option<&crate::model::ListControlSearchOptions> {
        self.search_options.as_ref()
    }
    /// <p>The configuration of the <code>Select all</code> options in a list control.</p>
    pub fn select_all_options(
        &self,
    ) -> std::option::Option<&crate::model::ListControlSelectAllOptions> {
        self.select_all_options.as_ref()
    }
    /// <p>The options to configure the title visibility, name, and font size.</p>
    pub fn title_options(&self) -> std::option::Option<&crate::model::LabelOptions> {
        self.title_options.as_ref()
    }
}
/// See [`ListControlDisplayOptions`](crate::model::ListControlDisplayOptions).
pub mod list_control_display_options {

    /// A builder for [`ListControlDisplayOptions`](crate::model::ListControlDisplayOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) search_options: std::option::Option<crate::model::ListControlSearchOptions>,
        pub(crate) select_all_options:
            std::option::Option<crate::model::ListControlSelectAllOptions>,
        pub(crate) title_options: std::option::Option<crate::model::LabelOptions>,
    }
    impl Builder {
        /// <p>The configuration of the search options in a list control.</p>
        pub fn search_options(mut self, input: crate::model::ListControlSearchOptions) -> Self {
            self.search_options = Some(input);
            self
        }
        /// <p>The configuration of the search options in a list control.</p>
        pub fn set_search_options(
            mut self,
            input: std::option::Option<crate::model::ListControlSearchOptions>,
        ) -> Self {
            self.search_options = input;
            self
        }
        /// <p>The configuration of the <code>Select all</code> options in a list control.</p>
        pub fn select_all_options(
            mut self,
            input: crate::model::ListControlSelectAllOptions,
        ) -> Self {
            self.select_all_options = Some(input);
            self
        }
        /// <p>The configuration of the <code>Select all</code> options in a list control.</p>
        pub fn set_select_all_options(
            mut self,
            input: std::option::Option<crate::model::ListControlSelectAllOptions>,
        ) -> Self {
            self.select_all_options = input;
            self
        }
        /// <p>The options to configure the title visibility, name, and font size.</p>
        pub fn title_options(mut self, input: crate::model::LabelOptions) -> Self {
            self.title_options = Some(input);
            self
        }
        /// <p>The options to configure the title visibility, name, and font size.</p>
        pub fn set_title_options(
            mut self,
            input: std::option::Option<crate::model::LabelOptions>,
        ) -> Self {
            self.title_options = input;
            self
        }
        /// Consumes the builder and constructs a [`ListControlDisplayOptions`](crate::model::ListControlDisplayOptions).
        pub fn build(self) -> crate::model::ListControlDisplayOptions {
            crate::model::ListControlDisplayOptions {
                search_options: self.search_options,
                select_all_options: self.select_all_options,
                title_options: self.title_options,
            }
        }
    }
}
impl ListControlDisplayOptions {
    /// Creates a new builder-style object to manufacture [`ListControlDisplayOptions`](crate::model::ListControlDisplayOptions).
    pub fn builder() -> crate::model::list_control_display_options::Builder {
        crate::model::list_control_display_options::Builder::default()
    }
}

/// <p>The configuration of the search options in a list control.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListControlSearchOptions {
    /// <p>The visibility configuration of the search options in a list control.</p>
    #[doc(hidden)]
    pub visibility: std::option::Option<crate::model::Visibility>,
}
impl ListControlSearchOptions {
    /// <p>The visibility configuration of the search options in a list control.</p>
    pub fn visibility(&self) -> std::option::Option<&crate::model::Visibility> {
        self.visibility.as_ref()
    }
}
/// See [`ListControlSearchOptions`](crate::model::ListControlSearchOptions).
pub mod list_control_search_options {

    /// A builder for [`ListControlSearchOptions`](crate::model::ListControlSearchOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility: std::option::Option<crate::model::Visibility>,
    }
    impl Builder {
        /// <p>The visibility configuration of the search options in a list control.</p>
        pub fn visibility(mut self, input: crate::model::Visibility) -> Self {
            self.visibility = Some(input);
            self
        }
        /// <p>The visibility configuration of the search options in a list control.</p>
        pub fn set_visibility(
            mut self,
            input: std::option::Option<crate::model::Visibility>,
        ) -> Self {
            self.visibility = input;
            self
        }
        /// Consumes the builder and constructs a [`ListControlSearchOptions`](crate::model::ListControlSearchOptions).
        pub fn build(self) -> crate::model::ListControlSearchOptions {
            crate::model::ListControlSearchOptions {
                visibility: self.visibility,
            }
        }
    }
}
impl ListControlSearchOptions {
    /// Creates a new builder-style object to manufacture [`ListControlSearchOptions`](crate::model::ListControlSearchOptions).
    pub fn builder() -> crate::model::list_control_search_options::Builder {
        crate::model::list_control_search_options::Builder::default()
    }
}

/// <p>A control from a date filter that is used to specify date and time.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterDateTimePickerControl {
    /// <p>The ID of the <code>FilterDateTimePickerControl</code>.</p>
    #[doc(hidden)]
    pub filter_control_id: std::option::Option<std::string::String>,
    /// <p>The title of the <code>FilterDateTimePickerControl</code>.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The source filter ID of the <code>FilterDateTimePickerControl</code>.</p>
    #[doc(hidden)]
    pub source_filter_id: std::option::Option<std::string::String>,
    /// <p>The display options of a control.</p>
    #[doc(hidden)]
    pub display_options: std::option::Option<crate::model::DateTimePickerControlDisplayOptions>,
    /// <p>The date time picker type of a <code>FilterDateTimePickerControl</code>. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>SINGLE_VALUED</code>: The filter condition is a fixed date.</p> </li>
    /// <li> <p> <code>DATE_RANGE</code>: The filter condition is a date time range.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::SheetControlDateTimePickerType>,
}
impl FilterDateTimePickerControl {
    /// <p>The ID of the <code>FilterDateTimePickerControl</code>.</p>
    pub fn filter_control_id(&self) -> std::option::Option<&str> {
        self.filter_control_id.as_deref()
    }
    /// <p>The title of the <code>FilterDateTimePickerControl</code>.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The source filter ID of the <code>FilterDateTimePickerControl</code>.</p>
    pub fn source_filter_id(&self) -> std::option::Option<&str> {
        self.source_filter_id.as_deref()
    }
    /// <p>The display options of a control.</p>
    pub fn display_options(
        &self,
    ) -> std::option::Option<&crate::model::DateTimePickerControlDisplayOptions> {
        self.display_options.as_ref()
    }
    /// <p>The date time picker type of a <code>FilterDateTimePickerControl</code>. Choose one of the following options:</p>
    /// <ul>
    /// <li> <p> <code>SINGLE_VALUED</code>: The filter condition is a fixed date.</p> </li>
    /// <li> <p> <code>DATE_RANGE</code>: The filter condition is a date time range.</p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&crate::model::SheetControlDateTimePickerType> {
        self.r#type.as_ref()
    }
}
/// See [`FilterDateTimePickerControl`](crate::model::FilterDateTimePickerControl).
pub mod filter_date_time_picker_control {

    /// A builder for [`FilterDateTimePickerControl`](crate::model::FilterDateTimePickerControl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_control_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) source_filter_id: std::option::Option<std::string::String>,
        pub(crate) display_options:
            std::option::Option<crate::model::DateTimePickerControlDisplayOptions>,
        pub(crate) r#type: std::option::Option<crate::model::SheetControlDateTimePickerType>,
    }
    impl Builder {
        /// <p>The ID of the <code>FilterDateTimePickerControl</code>.</p>
        pub fn filter_control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_control_id = Some(input.into());
            self
        }
        /// <p>The ID of the <code>FilterDateTimePickerControl</code>.</p>
        pub fn set_filter_control_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filter_control_id = input;
            self
        }
        /// <p>The title of the <code>FilterDateTimePickerControl</code>.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the <code>FilterDateTimePickerControl</code>.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The source filter ID of the <code>FilterDateTimePickerControl</code>.</p>
        pub fn source_filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_filter_id = Some(input.into());
            self
        }
        /// <p>The source filter ID of the <code>FilterDateTimePickerControl</code>.</p>
        pub fn set_source_filter_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_filter_id = input;
            self
        }
        /// <p>The display options of a control.</p>
        pub fn display_options(
            mut self,
            input: crate::model::DateTimePickerControlDisplayOptions,
        ) -> Self {
            self.display_options = Some(input);
            self
        }
        /// <p>The display options of a control.</p>
        pub fn set_display_options(
            mut self,
            input: std::option::Option<crate::model::DateTimePickerControlDisplayOptions>,
        ) -> Self {
            self.display_options = input;
            self
        }
        /// <p>The date time picker type of a <code>FilterDateTimePickerControl</code>. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>SINGLE_VALUED</code>: The filter condition is a fixed date.</p> </li>
        /// <li> <p> <code>DATE_RANGE</code>: The filter condition is a date time range.</p> </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::SheetControlDateTimePickerType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The date time picker type of a <code>FilterDateTimePickerControl</code>. Choose one of the following options:</p>
        /// <ul>
        /// <li> <p> <code>SINGLE_VALUED</code>: The filter condition is a fixed date.</p> </li>
        /// <li> <p> <code>DATE_RANGE</code>: The filter condition is a date time range.</p> </li>
        /// </ul>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::SheetControlDateTimePickerType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterDateTimePickerControl`](crate::model::FilterDateTimePickerControl).
        pub fn build(self) -> crate::model::FilterDateTimePickerControl {
            crate::model::FilterDateTimePickerControl {
                filter_control_id: self.filter_control_id,
                title: self.title,
                source_filter_id: self.source_filter_id,
                display_options: self.display_options,
                r#type: self.r#type,
            }
        }
    }
}
impl FilterDateTimePickerControl {
    /// Creates a new builder-style object to manufacture [`FilterDateTimePickerControl`](crate::model::FilterDateTimePickerControl).
    pub fn builder() -> crate::model::filter_date_time_picker_control::Builder {
        crate::model::filter_date_time_picker_control::Builder::default()
    }
}

/// When writing a match expression against `SheetControlDateTimePickerType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sheetcontroldatetimepickertype = unimplemented!();
/// match sheetcontroldatetimepickertype {
///     SheetControlDateTimePickerType::DateRange => { /* ... */ },
///     SheetControlDateTimePickerType::SingleValued => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sheetcontroldatetimepickertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SheetControlDateTimePickerType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SheetControlDateTimePickerType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SheetControlDateTimePickerType::NewFeature` is defined.
/// Specifically, when `sheetcontroldatetimepickertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SheetControlDateTimePickerType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SheetControlDateTimePickerType {
    #[allow(missing_docs)] // documentation missing in model
    DateRange,
    #[allow(missing_docs)] // documentation missing in model
    SingleValued,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SheetControlDateTimePickerType {
    fn from(s: &str) -> Self {
        match s {
            "DATE_RANGE" => SheetControlDateTimePickerType::DateRange,
            "SINGLE_VALUED" => SheetControlDateTimePickerType::SingleValued,
            other => SheetControlDateTimePickerType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for SheetControlDateTimePickerType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SheetControlDateTimePickerType::from(s))
    }
}
impl SheetControlDateTimePickerType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SheetControlDateTimePickerType::DateRange => "DATE_RANGE",
            SheetControlDateTimePickerType::SingleValued => "SINGLE_VALUED",
            SheetControlDateTimePickerType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DATE_RANGE", "SINGLE_VALUED"]
    }
}
impl AsRef<str> for SheetControlDateTimePickerType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The display options of a control.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DateTimePickerControlDisplayOptions {
    /// <p>The options to configure the title visibility, name, and font size.</p>
    #[doc(hidden)]
    pub title_options: std::option::Option<crate::model::LabelOptions>,
    /// <p>Customize how dates are formatted in controls.</p>
    #[doc(hidden)]
    pub date_time_format: std::option::Option<std::string::String>,
}
impl DateTimePickerControlDisplayOptions {
    /// <p>The options to configure the title visibility, name, and font size.</p>
    pub fn title_options(&self) -> std::option::Option<&crate::model::LabelOptions> {
        self.title_options.as_ref()
    }
    /// <p>Customize how dates are formatted in controls.</p>
    pub fn date_time_format(&self) -> std::option::Option<&str> {
        self.date_time_format.as_deref()
    }
}
/// See [`DateTimePickerControlDisplayOptions`](crate::model::DateTimePickerControlDisplayOptions).
pub mod date_time_picker_control_display_options {

    /// A builder for [`DateTimePickerControlDisplayOptions`](crate::model::DateTimePickerControlDisplayOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) title_options: std::option::Option<crate::model::LabelOptions>,
        pub(crate) date_time_format: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The options to configure the title visibility, name, and font size.</p>
        pub fn title_options(mut self, input: crate::model::LabelOptions) -> Self {
            self.title_options = Some(input);
            self
        }
        /// <p>The options to configure the title visibility, name, and font size.</p>
        pub fn set_title_options(
            mut self,
            input: std::option::Option<crate::model::LabelOptions>,
        ) -> Self {
            self.title_options = input;
            self
        }
        /// <p>Customize how dates are formatted in controls.</p>
        pub fn date_time_format(mut self, input: impl Into<std::string::String>) -> Self {
            self.date_time_format = Some(input.into());
            self
        }
        /// <p>Customize how dates are formatted in controls.</p>
        pub fn set_date_time_format(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.date_time_format = input;
            self
        }
        /// Consumes the builder and constructs a [`DateTimePickerControlDisplayOptions`](crate::model::DateTimePickerControlDisplayOptions).
        pub fn build(self) -> crate::model::DateTimePickerControlDisplayOptions {
            crate::model::DateTimePickerControlDisplayOptions {
                title_options: self.title_options,
                date_time_format: self.date_time_format,
            }
        }
    }
}
impl DateTimePickerControlDisplayOptions {
    /// Creates a new builder-style object to manufacture [`DateTimePickerControlDisplayOptions`](crate::model::DateTimePickerControlDisplayOptions).
    pub fn builder() -> crate::model::date_time_picker_control_display_options::Builder {
        crate::model::date_time_picker_control_display_options::Builder::default()
    }
}

/// <p>The control of a parameter that users can interact with in a dashboard or an analysis.</p>
/// <p>This is a union type structure. For this structure to be valid, only one of the attributes can be defined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParameterControl {
    /// <p>A control from a date parameter that specifies date and time.</p>
    #[doc(hidden)]
    pub date_time_picker: std::option::Option<crate::model::ParameterDateTimePickerControl>,
    /// <p>A control to display a list with buttons or boxes that are used to select either a single value or multiple values.</p>
    #[doc(hidden)]
    pub list: std::option::Option<crate::model::ParameterListControl>,
    /// <p>A control to display a dropdown list with buttons that are used to select a single value.</p>
    #[doc(hidden)]
    pub dropdown: std::option::Option<crate::model::ParameterDropDownControl>,
    /// <p>A control to display a text box that is used to enter a single entry.</p>
    #[doc(hidden)]
    pub text_field: std::option::Option<crate::model::ParameterTextFieldControl>,
    /// <p>A control to display a text box that is used to enter multiple entries.</p>
    #[doc(hidden)]
    pub text_area: std::option::Option<crate::model::ParameterTextAreaControl>,
    /// <p>A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.</p>
    #[doc(hidden)]
    pub slider: std::option::Option<crate::model::ParameterSliderControl>,
}
impl ParameterControl {
    /// <p>A control from a date parameter that specifies date and time.</p>
    pub fn date_time_picker(
        &self,
    ) -> std::option::Option<&crate::model::ParameterDateTimePickerControl> {
        self.date_time_picker.as_ref()
    }
    /// <p>A control to display a list with buttons or boxes that are used to select either a single value or multiple values.</p>
    pub fn list(&self) -> std::option::Option<&crate::model::ParameterListControl> {
        self.list.as_ref()
    }
    /// <p>A control to display a dropdown list with buttons that are used to select a single value.</p>
    pub fn dropdown(&self) -> std::option::Option<&crate::model::ParameterDropDownControl> {
        self.dropdown.as_ref()
    }
    /// <p>A control to display a text box that is used to enter a single entry.</p>
    pub fn text_field(&self) -> std::option::Option<&crate::model::ParameterTextFieldControl> {
        self.text_field.as_ref()
    }
    /// <p>A control to display a text box that is used to enter multiple entries.</p>
    pub fn text_area(&self) -> std::option::Option<&crate::model::ParameterTextAreaControl> {
        self.text_area.as_ref()
    }
    /// <p>A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.</p>
    pub fn slider(&self) -> std::option::Option<&crate::model::ParameterSliderControl> {
        self.slider.as_ref()
    }
}
/// See [`ParameterControl`](crate::model::ParameterControl).
pub mod parameter_control {

    /// A builder for [`ParameterControl`](crate::model::ParameterControl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) date_time_picker:
            std::option::Option<crate::model::ParameterDateTimePickerControl>,
        pub(crate) list: std::option::Option<crate::model::ParameterListControl>,
        pub(crate) dropdown: std::option::Option<crate::model::ParameterDropDownControl>,
        pub(crate) text_field: std::option::Option<crate::model::ParameterTextFieldControl>,
        pub(crate) text_area: std::option::Option<crate::model::ParameterTextAreaControl>,
        pub(crate) slider: std::option::Option<crate::model::ParameterSliderControl>,
    }
    impl Builder {
        /// <p>A control from a date parameter that specifies date and time.</p>
        pub fn date_time_picker(
            mut self,
            input: crate::model::ParameterDateTimePickerControl,
        ) -> Self {
            self.date_time_picker = Some(input);
            self
        }
        /// <p>A control from a date parameter that specifies date and time.</p>
        pub fn set_date_time_picker(
            mut self,
            input: std::option::Option<crate::model::ParameterDateTimePickerControl>,
        ) -> Self {
            self.date_time_picker = input;
            self
        }
        /// <p>A control to display a list with buttons or boxes that are used to select either a single value or multiple values.</p>
        pub fn list(mut self, input: crate::model::ParameterListControl) -> Self {
            self.list = Some(input);
            self
        }
        /// <p>A control to display a list with buttons or boxes that are used to select either a single value or multiple values.</p>
        pub fn set_list(
            mut self,
            input: std::option::Option<crate::model::ParameterListControl>,
        ) -> Self {
            self.list = input;
            self
        }
        /// <p>A control to display a dropdown list with buttons that are used to select a single value.</p>
        pub fn dropdown(mut self, input: crate::model::ParameterDropDownControl) -> Self {
            self.dropdown = Some(input);
            self
        }
        /// <p>A control to display a dropdown list with buttons that are used to select a single value.</p>
        pub fn set_dropdown(
            mut self,
            input: std::option::Option<crate::model::ParameterDropDownControl>,
        ) -> Self {
            self.dropdown = input;
            self
        }
        /// <p>A control to display a text box that is used to enter a single entry.</p>
        pub fn text_field(mut self, input: crate::model::ParameterTextFieldControl) -> Self {
            self.text_field = Some(input);
            self
        }
        /// <p>A control to display a text box that is used to enter a single entry.</p>
        pub fn set_text_field(
            mut self,
            input: std::option::Option<crate::model::ParameterTextFieldControl>,
        ) -> Self {
            self.text_field = input;
            self
        }
        /// <p>A control to display a text box that is used to enter multiple entries.</p>
        pub fn text_area(mut self, input: crate::model::ParameterTextAreaControl) -> Self {
            self.text_area = Some(input);
            self
        }
        /// <p>A control to display a text box that is used to enter multiple entries.</p>
        pub fn set_text_area(
            mut self,
            input: std::option::Option<crate::model::ParameterTextAreaControl>,
        ) -> Self {
            self.text_area = input;
            self
        }
        /// <p>A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.</p>
        pub fn slider(mut self, input: crate::model::ParameterSliderControl) -> Self {
            self.slider = Some(input);
            self
        }
        /// <p>A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.</p>
        pub fn set_slider(
            mut self,
            input: std::option::Option<crate::model::ParameterSliderControl>,
        ) -> Self {
            self.slider = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterControl`](crate::model::ParameterControl).
        pub fn build(self) -> crate::model::ParameterControl {
            crate::model::ParameterControl {
                date_time_picker: self.date_time_picker,
                list: self.list,
                dropdown: self.dropdown,
                text_field: self.text_field,
                text_area: self.text_area,
                slider: self.slider,
            }
        }
    }
}
impl ParameterControl {
    /// Creates a new builder-style object to manufacture [`ParameterControl`](crate::model::ParameterControl).
    pub fn builder() -> crate::model::parameter_control::Builder {
        crate::model::parameter_control::Builder::default()
    }
}

/// <p>A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParameterSliderControl {
    /// <p>The ID of the <code>ParameterSliderControl</code>.</p>
    #[doc(hidden)]
    pub parameter_control_id: std::option::Option<std::string::String>,
    /// <p>The title of the <code>ParameterSliderControl</code>.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The source parameter name of the <code>ParameterSliderControl</code>.</p>
    #[doc(hidden)]
    pub source_parameter_name: std::option::Option<std::string::String>,
    /// <p>The display options of a control.</p>
    #[doc(hidden)]
    pub display_options: std::option::Option<crate::model::SliderControlDisplayOptions>,
    /// <p>The smaller value that is displayed at the left of the slider.</p>
    #[doc(hidden)]
    pub maximum_value: f64,
    /// <p>The larger value that is displayed at the right of the slider.</p>
    #[doc(hidden)]
    pub minimum_value: f64,
    /// <p>The number of increments that the slider bar is divided into.</p>
    #[doc(hidden)]
    pub step_size: f64,
}
impl ParameterSliderControl {
    /// <p>The ID of the <code>ParameterSliderControl</code>.</p>
    pub fn parameter_control_id(&self) -> std::option::Option<&str> {
        self.parameter_control_id.as_deref()
    }
    /// <p>The title of the <code>ParameterSliderControl</code>.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The source parameter name of the <code>ParameterSliderControl</code>.</p>
    pub fn source_parameter_name(&self) -> std::option::Option<&str> {
        self.source_parameter_name.as_deref()
    }
    /// <p>The display options of a control.</p>
    pub fn display_options(
        &self,
    ) -> std::option::Option<&crate::model::SliderControlDisplayOptions> {
        self.display_options.as_ref()
    }
    /// <p>The smaller value that is displayed at the left of the slider.</p>
    pub fn maximum_value(&self) -> f64 {
        self.maximum_value
    }
    /// <p>The larger value that is displayed at the right of the slider.</p>
    pub fn minimum_value(&self) -> f64 {
        self.minimum_value
    }
    /// <p>The number of increments that the slider bar is divided into.</p>
    pub fn step_size(&self) -> f64 {
        self.step_size
    }
}
/// See [`ParameterSliderControl`](crate::model::ParameterSliderControl).
pub mod parameter_slider_control {

    /// A builder for [`ParameterSliderControl`](crate::model::ParameterSliderControl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_control_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) source_parameter_name: std::option::Option<std::string::String>,
        pub(crate) display_options: std::option::Option<crate::model::SliderControlDisplayOptions>,
        pub(crate) maximum_value: std::option::Option<f64>,
        pub(crate) minimum_value: std::option::Option<f64>,
        pub(crate) step_size: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The ID of the <code>ParameterSliderControl</code>.</p>
        pub fn parameter_control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_control_id = Some(input.into());
            self
        }
        /// <p>The ID of the <code>ParameterSliderControl</code>.</p>
        pub fn set_parameter_control_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_control_id = input;
            self
        }
        /// <p>The title of the <code>ParameterSliderControl</code>.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the <code>ParameterSliderControl</code>.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The source parameter name of the <code>ParameterSliderControl</code>.</p>
        pub fn source_parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_parameter_name = Some(input.into());
            self
        }
        /// <p>The source parameter name of the <code>ParameterSliderControl</code>.</p>
        pub fn set_source_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_parameter_name = input;
            self
        }
        /// <p>The display options of a control.</p>
        pub fn display_options(mut self, input: crate::model::SliderControlDisplayOptions) -> Self {
            self.display_options = Some(input);
            self
        }
        /// <p>The display options of a control.</p>
        pub fn set_display_options(
            mut self,
            input: std::option::Option<crate::model::SliderControlDisplayOptions>,
        ) -> Self {
            self.display_options = input;
            self
        }
        /// <p>The smaller value that is displayed at the left of the slider.</p>
        pub fn maximum_value(mut self, input: f64) -> Self {
            self.maximum_value = Some(input);
            self
        }
        /// <p>The smaller value that is displayed at the left of the slider.</p>
        pub fn set_maximum_value(mut self, input: std::option::Option<f64>) -> Self {
            self.maximum_value = input;
            self
        }
        /// <p>The larger value that is displayed at the right of the slider.</p>
        pub fn minimum_value(mut self, input: f64) -> Self {
            self.minimum_value = Some(input);
            self
        }
        /// <p>The larger value that is displayed at the right of the slider.</p>
        pub fn set_minimum_value(mut self, input: std::option::Option<f64>) -> Self {
            self.minimum_value = input;
            self
        }
        /// <p>The number of increments that the slider bar is divided into.</p>
        pub fn step_size(mut self, input: f64) -> Self {
            self.step_size = Some(input);
            self
        }
        /// <p>The number of increments that the slider bar is divided into.</p>
        pub fn set_step_size(mut self, input: std::option::Option<f64>) -> Self {
            self.step_size = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterSliderControl`](crate::model::ParameterSliderControl).
        pub fn build(self) -> crate::model::ParameterSliderControl {
            crate::model::ParameterSliderControl {
                parameter_control_id: self.parameter_control_id,
                title: self.title,
                source_parameter_name: self.source_parameter_name,
                display_options: self.display_options,
                maximum_value: self.maximum_value.unwrap_or_default(),
                minimum_value: self.minimum_value.unwrap_or_default(),
                step_size: self.step_size.unwrap_or_default(),
            }
        }
    }
}
impl ParameterSliderControl {
    /// Creates a new builder-style object to manufacture [`ParameterSliderControl`](crate::model::ParameterSliderControl).
    pub fn builder() -> crate::model::parameter_slider_control::Builder {
        crate::model::parameter_slider_control::Builder::default()
    }
}

/// <p>A control to display a text box that is used to enter multiple entries.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParameterTextAreaControl {
    /// <p>The ID of the <code>ParameterTextAreaControl</code>.</p>
    #[doc(hidden)]
    pub parameter_control_id: std::option::Option<std::string::String>,
    /// <p>The title of the <code>ParameterTextAreaControl</code>.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The source parameter name of the <code>ParameterTextAreaControl</code>.</p>
    #[doc(hidden)]
    pub source_parameter_name: std::option::Option<std::string::String>,
    /// <p>The delimiter that is used to separate the lines in text.</p>
    #[doc(hidden)]
    pub delimiter: std::option::Option<std::string::String>,
    /// <p>The display options of a control.</p>
    #[doc(hidden)]
    pub display_options: std::option::Option<crate::model::TextAreaControlDisplayOptions>,
}
impl ParameterTextAreaControl {
    /// <p>The ID of the <code>ParameterTextAreaControl</code>.</p>
    pub fn parameter_control_id(&self) -> std::option::Option<&str> {
        self.parameter_control_id.as_deref()
    }
    /// <p>The title of the <code>ParameterTextAreaControl</code>.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The source parameter name of the <code>ParameterTextAreaControl</code>.</p>
    pub fn source_parameter_name(&self) -> std::option::Option<&str> {
        self.source_parameter_name.as_deref()
    }
    /// <p>The delimiter that is used to separate the lines in text.</p>
    pub fn delimiter(&self) -> std::option::Option<&str> {
        self.delimiter.as_deref()
    }
    /// <p>The display options of a control.</p>
    pub fn display_options(
        &self,
    ) -> std::option::Option<&crate::model::TextAreaControlDisplayOptions> {
        self.display_options.as_ref()
    }
}
/// See [`ParameterTextAreaControl`](crate::model::ParameterTextAreaControl).
pub mod parameter_text_area_control {

    /// A builder for [`ParameterTextAreaControl`](crate::model::ParameterTextAreaControl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_control_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) source_parameter_name: std::option::Option<std::string::String>,
        pub(crate) delimiter: std::option::Option<std::string::String>,
        pub(crate) display_options:
            std::option::Option<crate::model::TextAreaControlDisplayOptions>,
    }
    impl Builder {
        /// <p>The ID of the <code>ParameterTextAreaControl</code>.</p>
        pub fn parameter_control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_control_id = Some(input.into());
            self
        }
        /// <p>The ID of the <code>ParameterTextAreaControl</code>.</p>
        pub fn set_parameter_control_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_control_id = input;
            self
        }
        /// <p>The title of the <code>ParameterTextAreaControl</code>.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the <code>ParameterTextAreaControl</code>.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The source parameter name of the <code>ParameterTextAreaControl</code>.</p>
        pub fn source_parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_parameter_name = Some(input.into());
            self
        }
        /// <p>The source parameter name of the <code>ParameterTextAreaControl</code>.</p>
        pub fn set_source_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_parameter_name = input;
            self
        }
        /// <p>The delimiter that is used to separate the lines in text.</p>
        pub fn delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.delimiter = Some(input.into());
            self
        }
        /// <p>The delimiter that is used to separate the lines in text.</p>
        pub fn set_delimiter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.delimiter = input;
            self
        }
        /// <p>The display options of a control.</p>
        pub fn display_options(
            mut self,
            input: crate::model::TextAreaControlDisplayOptions,
        ) -> Self {
            self.display_options = Some(input);
            self
        }
        /// <p>The display options of a control.</p>
        pub fn set_display_options(
            mut self,
            input: std::option::Option<crate::model::TextAreaControlDisplayOptions>,
        ) -> Self {
            self.display_options = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterTextAreaControl`](crate::model::ParameterTextAreaControl).
        pub fn build(self) -> crate::model::ParameterTextAreaControl {
            crate::model::ParameterTextAreaControl {
                parameter_control_id: self.parameter_control_id,
                title: self.title,
                source_parameter_name: self.source_parameter_name,
                delimiter: self.delimiter,
                display_options: self.display_options,
            }
        }
    }
}
impl ParameterTextAreaControl {
    /// Creates a new builder-style object to manufacture [`ParameterTextAreaControl`](crate::model::ParameterTextAreaControl).
    pub fn builder() -> crate::model::parameter_text_area_control::Builder {
        crate::model::parameter_text_area_control::Builder::default()
    }
}

/// <p>A control to display a text box that is used to enter a single entry.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParameterTextFieldControl {
    /// <p>The ID of the <code>ParameterTextFieldControl</code>.</p>
    #[doc(hidden)]
    pub parameter_control_id: std::option::Option<std::string::String>,
    /// <p>The title of the <code>ParameterTextFieldControl</code>.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The source parameter name of the <code>ParameterTextFieldControl</code>.</p>
    #[doc(hidden)]
    pub source_parameter_name: std::option::Option<std::string::String>,
    /// <p>The display options of a control.</p>
    #[doc(hidden)]
    pub display_options: std::option::Option<crate::model::TextFieldControlDisplayOptions>,
}
impl ParameterTextFieldControl {
    /// <p>The ID of the <code>ParameterTextFieldControl</code>.</p>
    pub fn parameter_control_id(&self) -> std::option::Option<&str> {
        self.parameter_control_id.as_deref()
    }
    /// <p>The title of the <code>ParameterTextFieldControl</code>.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The source parameter name of the <code>ParameterTextFieldControl</code>.</p>
    pub fn source_parameter_name(&self) -> std::option::Option<&str> {
        self.source_parameter_name.as_deref()
    }
    /// <p>The display options of a control.</p>
    pub fn display_options(
        &self,
    ) -> std::option::Option<&crate::model::TextFieldControlDisplayOptions> {
        self.display_options.as_ref()
    }
}
/// See [`ParameterTextFieldControl`](crate::model::ParameterTextFieldControl).
pub mod parameter_text_field_control {

    /// A builder for [`ParameterTextFieldControl`](crate::model::ParameterTextFieldControl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_control_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) source_parameter_name: std::option::Option<std::string::String>,
        pub(crate) display_options:
            std::option::Option<crate::model::TextFieldControlDisplayOptions>,
    }
    impl Builder {
        /// <p>The ID of the <code>ParameterTextFieldControl</code>.</p>
        pub fn parameter_control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_control_id = Some(input.into());
            self
        }
        /// <p>The ID of the <code>ParameterTextFieldControl</code>.</p>
        pub fn set_parameter_control_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_control_id = input;
            self
        }
        /// <p>The title of the <code>ParameterTextFieldControl</code>.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the <code>ParameterTextFieldControl</code>.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The source parameter name of the <code>ParameterTextFieldControl</code>.</p>
        pub fn source_parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_parameter_name = Some(input.into());
            self
        }
        /// <p>The source parameter name of the <code>ParameterTextFieldControl</code>.</p>
        pub fn set_source_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_parameter_name = input;
            self
        }
        /// <p>The display options of a control.</p>
        pub fn display_options(
            mut self,
            input: crate::model::TextFieldControlDisplayOptions,
        ) -> Self {
            self.display_options = Some(input);
            self
        }
        /// <p>The display options of a control.</p>
        pub fn set_display_options(
            mut self,
            input: std::option::Option<crate::model::TextFieldControlDisplayOptions>,
        ) -> Self {
            self.display_options = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterTextFieldControl`](crate::model::ParameterTextFieldControl).
        pub fn build(self) -> crate::model::ParameterTextFieldControl {
            crate::model::ParameterTextFieldControl {
                parameter_control_id: self.parameter_control_id,
                title: self.title,
                source_parameter_name: self.source_parameter_name,
                display_options: self.display_options,
            }
        }
    }
}
impl ParameterTextFieldControl {
    /// Creates a new builder-style object to manufacture [`ParameterTextFieldControl`](crate::model::ParameterTextFieldControl).
    pub fn builder() -> crate::model::parameter_text_field_control::Builder {
        crate::model::parameter_text_field_control::Builder::default()
    }
}

/// <p>A control to display a dropdown list with buttons that are used to select a single value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParameterDropDownControl {
    /// <p>The ID of the <code>ParameterDropDownControl</code>.</p>
    #[doc(hidden)]
    pub parameter_control_id: std::option::Option<std::string::String>,
    /// <p>The title of the <code>ParameterDropDownControl</code>.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The source parameter name of the <code>ParameterDropDownControl</code>.</p>
    #[doc(hidden)]
    pub source_parameter_name: std::option::Option<std::string::String>,
    /// <p>The display options of a control.</p>
    #[doc(hidden)]
    pub display_options: std::option::Option<crate::model::DropDownControlDisplayOptions>,
    /// <p>The type parameter name of the <code>ParameterDropDownControl</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::SheetControlListType>,
    /// <p>A list of selectable values that are used in a control.</p>
    #[doc(hidden)]
    pub selectable_values: std::option::Option<crate::model::ParameterSelectableValues>,
    /// <p>The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.</p>
    #[doc(hidden)]
    pub cascading_control_configuration:
        std::option::Option<crate::model::CascadingControlConfiguration>,
}
impl ParameterDropDownControl {
    /// <p>The ID of the <code>ParameterDropDownControl</code>.</p>
    pub fn parameter_control_id(&self) -> std::option::Option<&str> {
        self.parameter_control_id.as_deref()
    }
    /// <p>The title of the <code>ParameterDropDownControl</code>.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The source parameter name of the <code>ParameterDropDownControl</code>.</p>
    pub fn source_parameter_name(&self) -> std::option::Option<&str> {
        self.source_parameter_name.as_deref()
    }
    /// <p>The display options of a control.</p>
    pub fn display_options(
        &self,
    ) -> std::option::Option<&crate::model::DropDownControlDisplayOptions> {
        self.display_options.as_ref()
    }
    /// <p>The type parameter name of the <code>ParameterDropDownControl</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::SheetControlListType> {
        self.r#type.as_ref()
    }
    /// <p>A list of selectable values that are used in a control.</p>
    pub fn selectable_values(
        &self,
    ) -> std::option::Option<&crate::model::ParameterSelectableValues> {
        self.selectable_values.as_ref()
    }
    /// <p>The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.</p>
    pub fn cascading_control_configuration(
        &self,
    ) -> std::option::Option<&crate::model::CascadingControlConfiguration> {
        self.cascading_control_configuration.as_ref()
    }
}
/// See [`ParameterDropDownControl`](crate::model::ParameterDropDownControl).
pub mod parameter_drop_down_control {

    /// A builder for [`ParameterDropDownControl`](crate::model::ParameterDropDownControl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_control_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) source_parameter_name: std::option::Option<std::string::String>,
        pub(crate) display_options:
            std::option::Option<crate::model::DropDownControlDisplayOptions>,
        pub(crate) r#type: std::option::Option<crate::model::SheetControlListType>,
        pub(crate) selectable_values: std::option::Option<crate::model::ParameterSelectableValues>,
        pub(crate) cascading_control_configuration:
            std::option::Option<crate::model::CascadingControlConfiguration>,
    }
    impl Builder {
        /// <p>The ID of the <code>ParameterDropDownControl</code>.</p>
        pub fn parameter_control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_control_id = Some(input.into());
            self
        }
        /// <p>The ID of the <code>ParameterDropDownControl</code>.</p>
        pub fn set_parameter_control_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_control_id = input;
            self
        }
        /// <p>The title of the <code>ParameterDropDownControl</code>.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the <code>ParameterDropDownControl</code>.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The source parameter name of the <code>ParameterDropDownControl</code>.</p>
        pub fn source_parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_parameter_name = Some(input.into());
            self
        }
        /// <p>The source parameter name of the <code>ParameterDropDownControl</code>.</p>
        pub fn set_source_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_parameter_name = input;
            self
        }
        /// <p>The display options of a control.</p>
        pub fn display_options(
            mut self,
            input: crate::model::DropDownControlDisplayOptions,
        ) -> Self {
            self.display_options = Some(input);
            self
        }
        /// <p>The display options of a control.</p>
        pub fn set_display_options(
            mut self,
            input: std::option::Option<crate::model::DropDownControlDisplayOptions>,
        ) -> Self {
            self.display_options = input;
            self
        }
        /// <p>The type parameter name of the <code>ParameterDropDownControl</code>.</p>
        pub fn r#type(mut self, input: crate::model::SheetControlListType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type parameter name of the <code>ParameterDropDownControl</code>.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::SheetControlListType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>A list of selectable values that are used in a control.</p>
        pub fn selectable_values(mut self, input: crate::model::ParameterSelectableValues) -> Self {
            self.selectable_values = Some(input);
            self
        }
        /// <p>A list of selectable values that are used in a control.</p>
        pub fn set_selectable_values(
            mut self,
            input: std::option::Option<crate::model::ParameterSelectableValues>,
        ) -> Self {
            self.selectable_values = input;
            self
        }
        /// <p>The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.</p>
        pub fn cascading_control_configuration(
            mut self,
            input: crate::model::CascadingControlConfiguration,
        ) -> Self {
            self.cascading_control_configuration = Some(input);
            self
        }
        /// <p>The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.</p>
        pub fn set_cascading_control_configuration(
            mut self,
            input: std::option::Option<crate::model::CascadingControlConfiguration>,
        ) -> Self {
            self.cascading_control_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterDropDownControl`](crate::model::ParameterDropDownControl).
        pub fn build(self) -> crate::model::ParameterDropDownControl {
            crate::model::ParameterDropDownControl {
                parameter_control_id: self.parameter_control_id,
                title: self.title,
                source_parameter_name: self.source_parameter_name,
                display_options: self.display_options,
                r#type: self.r#type,
                selectable_values: self.selectable_values,
                cascading_control_configuration: self.cascading_control_configuration,
            }
        }
    }
}
impl ParameterDropDownControl {
    /// Creates a new builder-style object to manufacture [`ParameterDropDownControl`](crate::model::ParameterDropDownControl).
    pub fn builder() -> crate::model::parameter_drop_down_control::Builder {
        crate::model::parameter_drop_down_control::Builder::default()
    }
}

/// <p>A list of selectable values that are used in a control.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParameterSelectableValues {
    /// <p>The values that are used in <code>ParameterSelectableValues</code>.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The column identifier that fetches values from the data set.</p>
    #[doc(hidden)]
    pub link_to_data_set_column: std::option::Option<crate::model::ColumnIdentifier>,
}
impl ParameterSelectableValues {
    /// <p>The values that are used in <code>ParameterSelectableValues</code>.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
    /// <p>The column identifier that fetches values from the data set.</p>
    pub fn link_to_data_set_column(&self) -> std::option::Option<&crate::model::ColumnIdentifier> {
        self.link_to_data_set_column.as_ref()
    }
}
/// See [`ParameterSelectableValues`](crate::model::ParameterSelectableValues).
pub mod parameter_selectable_values {

    /// A builder for [`ParameterSelectableValues`](crate::model::ParameterSelectableValues).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) link_to_data_set_column: std::option::Option<crate::model::ColumnIdentifier>,
    }
    impl Builder {
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The values that are used in <code>ParameterSelectableValues</code>.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>The values that are used in <code>ParameterSelectableValues</code>.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// <p>The column identifier that fetches values from the data set.</p>
        pub fn link_to_data_set_column(mut self, input: crate::model::ColumnIdentifier) -> Self {
            self.link_to_data_set_column = Some(input);
            self
        }
        /// <p>The column identifier that fetches values from the data set.</p>
        pub fn set_link_to_data_set_column(
            mut self,
            input: std::option::Option<crate::model::ColumnIdentifier>,
        ) -> Self {
            self.link_to_data_set_column = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterSelectableValues`](crate::model::ParameterSelectableValues).
        pub fn build(self) -> crate::model::ParameterSelectableValues {
            crate::model::ParameterSelectableValues {
                values: self.values,
                link_to_data_set_column: self.link_to_data_set_column,
            }
        }
    }
}
impl ParameterSelectableValues {
    /// Creates a new builder-style object to manufacture [`ParameterSelectableValues`](crate::model::ParameterSelectableValues).
    pub fn builder() -> crate::model::parameter_selectable_values::Builder {
        crate::model::parameter_selectable_values::Builder::default()
    }
}

/// <p>A control to display a list with buttons or boxes that are used to select either a single value or multiple values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParameterListControl {
    /// <p>The ID of the <code>ParameterListControl</code>.</p>
    #[doc(hidden)]
    pub parameter_control_id: std::option::Option<std::string::String>,
    /// <p>The title of the <code>ParameterListControl</code>.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The source parameter name of the <code>ParameterListControl</code>.</p>
    #[doc(hidden)]
    pub source_parameter_name: std::option::Option<std::string::String>,
    /// <p>The display options of a control.</p>
    #[doc(hidden)]
    pub display_options: std::option::Option<crate::model::ListControlDisplayOptions>,
    /// <p>The type of <code>ParameterListControl</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::SheetControlListType>,
    /// <p>A list of selectable values that are used in a control.</p>
    #[doc(hidden)]
    pub selectable_values: std::option::Option<crate::model::ParameterSelectableValues>,
    /// <p>The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.</p>
    #[doc(hidden)]
    pub cascading_control_configuration:
        std::option::Option<crate::model::CascadingControlConfiguration>,
}
impl ParameterListControl {
    /// <p>The ID of the <code>ParameterListControl</code>.</p>
    pub fn parameter_control_id(&self) -> std::option::Option<&str> {
        self.parameter_control_id.as_deref()
    }
    /// <p>The title of the <code>ParameterListControl</code>.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The source parameter name of the <code>ParameterListControl</code>.</p>
    pub fn source_parameter_name(&self) -> std::option::Option<&str> {
        self.source_parameter_name.as_deref()
    }
    /// <p>The display options of a control.</p>
    pub fn display_options(&self) -> std::option::Option<&crate::model::ListControlDisplayOptions> {
        self.display_options.as_ref()
    }
    /// <p>The type of <code>ParameterListControl</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::SheetControlListType> {
        self.r#type.as_ref()
    }
    /// <p>A list of selectable values that are used in a control.</p>
    pub fn selectable_values(
        &self,
    ) -> std::option::Option<&crate::model::ParameterSelectableValues> {
        self.selectable_values.as_ref()
    }
    /// <p>The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.</p>
    pub fn cascading_control_configuration(
        &self,
    ) -> std::option::Option<&crate::model::CascadingControlConfiguration> {
        self.cascading_control_configuration.as_ref()
    }
}
/// See [`ParameterListControl`](crate::model::ParameterListControl).
pub mod parameter_list_control {

    /// A builder for [`ParameterListControl`](crate::model::ParameterListControl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_control_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) source_parameter_name: std::option::Option<std::string::String>,
        pub(crate) display_options: std::option::Option<crate::model::ListControlDisplayOptions>,
        pub(crate) r#type: std::option::Option<crate::model::SheetControlListType>,
        pub(crate) selectable_values: std::option::Option<crate::model::ParameterSelectableValues>,
        pub(crate) cascading_control_configuration:
            std::option::Option<crate::model::CascadingControlConfiguration>,
    }
    impl Builder {
        /// <p>The ID of the <code>ParameterListControl</code>.</p>
        pub fn parameter_control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_control_id = Some(input.into());
            self
        }
        /// <p>The ID of the <code>ParameterListControl</code>.</p>
        pub fn set_parameter_control_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_control_id = input;
            self
        }
        /// <p>The title of the <code>ParameterListControl</code>.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the <code>ParameterListControl</code>.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The source parameter name of the <code>ParameterListControl</code>.</p>
        pub fn source_parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_parameter_name = Some(input.into());
            self
        }
        /// <p>The source parameter name of the <code>ParameterListControl</code>.</p>
        pub fn set_source_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_parameter_name = input;
            self
        }
        /// <p>The display options of a control.</p>
        pub fn display_options(mut self, input: crate::model::ListControlDisplayOptions) -> Self {
            self.display_options = Some(input);
            self
        }
        /// <p>The display options of a control.</p>
        pub fn set_display_options(
            mut self,
            input: std::option::Option<crate::model::ListControlDisplayOptions>,
        ) -> Self {
            self.display_options = input;
            self
        }
        /// <p>The type of <code>ParameterListControl</code>.</p>
        pub fn r#type(mut self, input: crate::model::SheetControlListType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of <code>ParameterListControl</code>.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::SheetControlListType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>A list of selectable values that are used in a control.</p>
        pub fn selectable_values(mut self, input: crate::model::ParameterSelectableValues) -> Self {
            self.selectable_values = Some(input);
            self
        }
        /// <p>A list of selectable values that are used in a control.</p>
        pub fn set_selectable_values(
            mut self,
            input: std::option::Option<crate::model::ParameterSelectableValues>,
        ) -> Self {
            self.selectable_values = input;
            self
        }
        /// <p>The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.</p>
        pub fn cascading_control_configuration(
            mut self,
            input: crate::model::CascadingControlConfiguration,
        ) -> Self {
            self.cascading_control_configuration = Some(input);
            self
        }
        /// <p>The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.</p>
        pub fn set_cascading_control_configuration(
            mut self,
            input: std::option::Option<crate::model::CascadingControlConfiguration>,
        ) -> Self {
            self.cascading_control_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterListControl`](crate::model::ParameterListControl).
        pub fn build(self) -> crate::model::ParameterListControl {
            crate::model::ParameterListControl {
                parameter_control_id: self.parameter_control_id,
                title: self.title,
                source_parameter_name: self.source_parameter_name,
                display_options: self.display_options,
                r#type: self.r#type,
                selectable_values: self.selectable_values,
                cascading_control_configuration: self.cascading_control_configuration,
            }
        }
    }
}
impl ParameterListControl {
    /// Creates a new builder-style object to manufacture [`ParameterListControl`](crate::model::ParameterListControl).
    pub fn builder() -> crate::model::parameter_list_control::Builder {
        crate::model::parameter_list_control::Builder::default()
    }
}

/// <p>A control from a date parameter that specifies date and time.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParameterDateTimePickerControl {
    /// <p>The ID of the <code>ParameterDateTimePickerControl</code>.</p>
    #[doc(hidden)]
    pub parameter_control_id: std::option::Option<std::string::String>,
    /// <p>The title of the <code>ParameterDateTimePickerControl</code>.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The name of the <code>ParameterDateTimePickerControl</code>.</p>
    #[doc(hidden)]
    pub source_parameter_name: std::option::Option<std::string::String>,
    /// <p>The display options of a control.</p>
    #[doc(hidden)]
    pub display_options: std::option::Option<crate::model::DateTimePickerControlDisplayOptions>,
}
impl ParameterDateTimePickerControl {
    /// <p>The ID of the <code>ParameterDateTimePickerControl</code>.</p>
    pub fn parameter_control_id(&self) -> std::option::Option<&str> {
        self.parameter_control_id.as_deref()
    }
    /// <p>The title of the <code>ParameterDateTimePickerControl</code>.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The name of the <code>ParameterDateTimePickerControl</code>.</p>
    pub fn source_parameter_name(&self) -> std::option::Option<&str> {
        self.source_parameter_name.as_deref()
    }
    /// <p>The display options of a control.</p>
    pub fn display_options(
        &self,
    ) -> std::option::Option<&crate::model::DateTimePickerControlDisplayOptions> {
        self.display_options.as_ref()
    }
}
/// See [`ParameterDateTimePickerControl`](crate::model::ParameterDateTimePickerControl).
pub mod parameter_date_time_picker_control {

    /// A builder for [`ParameterDateTimePickerControl`](crate::model::ParameterDateTimePickerControl).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_control_id: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) source_parameter_name: std::option::Option<std::string::String>,
        pub(crate) display_options:
            std::option::Option<crate::model::DateTimePickerControlDisplayOptions>,
    }
    impl Builder {
        /// <p>The ID of the <code>ParameterDateTimePickerControl</code>.</p>
        pub fn parameter_control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_control_id = Some(input.into());
            self
        }
        /// <p>The ID of the <code>ParameterDateTimePickerControl</code>.</p>
        pub fn set_parameter_control_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_control_id = input;
            self
        }
        /// <p>The title of the <code>ParameterDateTimePickerControl</code>.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title of the <code>ParameterDateTimePickerControl</code>.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The name of the <code>ParameterDateTimePickerControl</code>.</p>
        pub fn source_parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_parameter_name = Some(input.into());
            self
        }
        /// <p>The name of the <code>ParameterDateTimePickerControl</code>.</p>
        pub fn set_source_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_parameter_name = input;
            self
        }
        /// <p>The display options of a control.</p>
        pub fn display_options(
            mut self,
            input: crate::model::DateTimePickerControlDisplayOptions,
        ) -> Self {
            self.display_options = Some(input);
            self
        }
        /// <p>The display options of a control.</p>
        pub fn set_display_options(
            mut self,
            input: std::option::Option<crate::model::DateTimePickerControlDisplayOptions>,
        ) -> Self {
            self.display_options = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterDateTimePickerControl`](crate::model::ParameterDateTimePickerControl).
        pub fn build(self) -> crate::model::ParameterDateTimePickerControl {
            crate::model::ParameterDateTimePickerControl {
                parameter_control_id: self.parameter_control_id,
                title: self.title,
                source_parameter_name: self.source_parameter_name,
                display_options: self.display_options,
            }
        }
    }
}
impl ParameterDateTimePickerControl {
    /// Creates a new builder-style object to manufacture [`ParameterDateTimePickerControl`](crate::model::ParameterDateTimePickerControl).
    pub fn builder() -> crate::model::parameter_date_time_picker_control::Builder {
        crate::model::parameter_date_time_picker_control::Builder::default()
    }
}

/// <p>Dataset configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSetConfiguration {
    /// <p>Placeholder.</p>
    #[doc(hidden)]
    pub placeholder: std::option::Option<std::string::String>,
    /// <p>Dataset schema.</p>
    #[doc(hidden)]
    pub data_set_schema: std::option::Option<crate::model::DataSetSchema>,
    /// <p>A structure containing the list of column group schemas.</p>
    #[doc(hidden)]
    pub column_group_schema_list:
        std::option::Option<std::vec::Vec<crate::model::ColumnGroupSchema>>,
}
impl DataSetConfiguration {
    /// <p>Placeholder.</p>
    pub fn placeholder(&self) -> std::option::Option<&str> {
        self.placeholder.as_deref()
    }
    /// <p>Dataset schema.</p>
    pub fn data_set_schema(&self) -> std::option::Option<&crate::model::DataSetSchema> {
        self.data_set_schema.as_ref()
    }
    /// <p>A structure containing the list of column group schemas.</p>
    pub fn column_group_schema_list(
        &self,
    ) -> std::option::Option<&[crate::model::ColumnGroupSchema]> {
        self.column_group_schema_list.as_deref()
    }
}
/// See [`DataSetConfiguration`](crate::model::DataSetConfiguration).
pub mod data_set_configuration {

    /// A builder for [`DataSetConfiguration`](crate::model::DataSetConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) placeholder: std::option::Option<std::string::String>,
        pub(crate) data_set_schema: std::option::Option<crate::model::DataSetSchema>,
        pub(crate) column_group_schema_list:
            std::option::Option<std::vec::Vec<crate::model::ColumnGroupSchema>>,
    }
    impl Builder {
        /// <p>Placeholder.</p>
        pub fn placeholder(mut self, input: impl Into<std::string::String>) -> Self {
            self.placeholder = Some(input.into());
            self
        }
        /// <p>Placeholder.</p>
        pub fn set_placeholder(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.placeholder = input;
            self
        }
        /// <p>Dataset schema.</p>
        pub fn data_set_schema(mut self, input: crate::model::DataSetSchema) -> Self {
            self.data_set_schema = Some(input);
            self
        }
        /// <p>Dataset schema.</p>
        pub fn set_data_set_schema(
            mut self,
            input: std::option::Option<crate::model::DataSetSchema>,
        ) -> Self {
            self.data_set_schema = input;
            self
        }
        /// Appends an item to `column_group_schema_list`.
        ///
        /// To override the contents of this collection use [`set_column_group_schema_list`](Self::set_column_group_schema_list).
        ///
        /// <p>A structure containing the list of column group schemas.</p>
        pub fn column_group_schema_list(mut self, input: crate::model::ColumnGroupSchema) -> Self {
            let mut v = self.column_group_schema_list.unwrap_or_default();
            v.push(input);
            self.column_group_schema_list = Some(v);
            self
        }
        /// <p>A structure containing the list of column group schemas.</p>
        pub fn set_column_group_schema_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnGroupSchema>>,
        ) -> Self {
            self.column_group_schema_list = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSetConfiguration`](crate::model::DataSetConfiguration).
        pub fn build(self) -> crate::model::DataSetConfiguration {
            crate::model::DataSetConfiguration {
                placeholder: self.placeholder,
                data_set_schema: self.data_set_schema,
                column_group_schema_list: self.column_group_schema_list,
            }
        }
    }
}
impl DataSetConfiguration {
    /// Creates a new builder-style object to manufacture [`DataSetConfiguration`](crate::model::DataSetConfiguration).
    pub fn builder() -> crate::model::data_set_configuration::Builder {
        crate::model::data_set_configuration::Builder::default()
    }
}

/// <p>The column group schema.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnGroupSchema {
    /// <p>The name of the column group schema.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A structure containing the list of schemas for column group columns.</p>
    #[doc(hidden)]
    pub column_group_column_schema_list:
        std::option::Option<std::vec::Vec<crate::model::ColumnGroupColumnSchema>>,
}
impl ColumnGroupSchema {
    /// <p>The name of the column group schema.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A structure containing the list of schemas for column group columns.</p>
    pub fn column_group_column_schema_list(
        &self,
    ) -> std::option::Option<&[crate::model::ColumnGroupColumnSchema]> {
        self.column_group_column_schema_list.as_deref()
    }
}
/// See [`ColumnGroupSchema`](crate::model::ColumnGroupSchema).
pub mod column_group_schema {

    /// A builder for [`ColumnGroupSchema`](crate::model::ColumnGroupSchema).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) column_group_column_schema_list:
            std::option::Option<std::vec::Vec<crate::model::ColumnGroupColumnSchema>>,
    }
    impl Builder {
        /// <p>The name of the column group schema.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the column group schema.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `column_group_column_schema_list`.
        ///
        /// To override the contents of this collection use [`set_column_group_column_schema_list`](Self::set_column_group_column_schema_list).
        ///
        /// <p>A structure containing the list of schemas for column group columns.</p>
        pub fn column_group_column_schema_list(
            mut self,
            input: crate::model::ColumnGroupColumnSchema,
        ) -> Self {
            let mut v = self.column_group_column_schema_list.unwrap_or_default();
            v.push(input);
            self.column_group_column_schema_list = Some(v);
            self
        }
        /// <p>A structure containing the list of schemas for column group columns.</p>
        pub fn set_column_group_column_schema_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnGroupColumnSchema>>,
        ) -> Self {
            self.column_group_column_schema_list = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnGroupSchema`](crate::model::ColumnGroupSchema).
        pub fn build(self) -> crate::model::ColumnGroupSchema {
            crate::model::ColumnGroupSchema {
                name: self.name,
                column_group_column_schema_list: self.column_group_column_schema_list,
            }
        }
    }
}
impl ColumnGroupSchema {
    /// Creates a new builder-style object to manufacture [`ColumnGroupSchema`](crate::model::ColumnGroupSchema).
    pub fn builder() -> crate::model::column_group_schema::Builder {
        crate::model::column_group_schema::Builder::default()
    }
}

/// <p>A structure describing the name, data type, and geographic role of the columns.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnGroupColumnSchema {
    /// <p>The name of the column group's column schema.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl ColumnGroupColumnSchema {
    /// <p>The name of the column group's column schema.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`ColumnGroupColumnSchema`](crate::model::ColumnGroupColumnSchema).
pub mod column_group_column_schema {

    /// A builder for [`ColumnGroupColumnSchema`](crate::model::ColumnGroupColumnSchema).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the column group's column schema.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the column group's column schema.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnGroupColumnSchema`](crate::model::ColumnGroupColumnSchema).
        pub fn build(self) -> crate::model::ColumnGroupColumnSchema {
            crate::model::ColumnGroupColumnSchema { name: self.name }
        }
    }
}
impl ColumnGroupColumnSchema {
    /// Creates a new builder-style object to manufacture [`ColumnGroupColumnSchema`](crate::model::ColumnGroupColumnSchema).
    pub fn builder() -> crate::model::column_group_column_schema::Builder {
        crate::model::column_group_column_schema::Builder::default()
    }
}

/// <p>Dataset schema.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSetSchema {
    /// <p>A structure containing the list of column schemas.</p>
    #[doc(hidden)]
    pub column_schema_list: std::option::Option<std::vec::Vec<crate::model::ColumnSchema>>,
}
impl DataSetSchema {
    /// <p>A structure containing the list of column schemas.</p>
    pub fn column_schema_list(&self) -> std::option::Option<&[crate::model::ColumnSchema]> {
        self.column_schema_list.as_deref()
    }
}
/// See [`DataSetSchema`](crate::model::DataSetSchema).
pub mod data_set_schema {

    /// A builder for [`DataSetSchema`](crate::model::DataSetSchema).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column_schema_list:
            std::option::Option<std::vec::Vec<crate::model::ColumnSchema>>,
    }
    impl Builder {
        /// Appends an item to `column_schema_list`.
        ///
        /// To override the contents of this collection use [`set_column_schema_list`](Self::set_column_schema_list).
        ///
        /// <p>A structure containing the list of column schemas.</p>
        pub fn column_schema_list(mut self, input: crate::model::ColumnSchema) -> Self {
            let mut v = self.column_schema_list.unwrap_or_default();
            v.push(input);
            self.column_schema_list = Some(v);
            self
        }
        /// <p>A structure containing the list of column schemas.</p>
        pub fn set_column_schema_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnSchema>>,
        ) -> Self {
            self.column_schema_list = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSetSchema`](crate::model::DataSetSchema).
        pub fn build(self) -> crate::model::DataSetSchema {
            crate::model::DataSetSchema {
                column_schema_list: self.column_schema_list,
            }
        }
    }
}
impl DataSetSchema {
    /// Creates a new builder-style object to manufacture [`DataSetSchema`](crate::model::DataSetSchema).
    pub fn builder() -> crate::model::data_set_schema::Builder {
        crate::model::data_set_schema::Builder::default()
    }
}

/// <p>The column schema.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnSchema {
    /// <p>The name of the column schema.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data type of the column schema.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<std::string::String>,
    /// <p>The geographic role of the column schema.</p>
    #[doc(hidden)]
    pub geographic_role: std::option::Option<std::string::String>,
}
impl ColumnSchema {
    /// <p>The name of the column schema.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data type of the column schema.</p>
    pub fn data_type(&self) -> std::option::Option<&str> {
        self.data_type.as_deref()
    }
    /// <p>The geographic role of the column schema.</p>
    pub fn geographic_role(&self) -> std::option::Option<&str> {
        self.geographic_role.as_deref()
    }
}
/// See [`ColumnSchema`](crate::model::ColumnSchema).
pub mod column_schema {

    /// A builder for [`ColumnSchema`](crate::model::ColumnSchema).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<std::string::String>,
        pub(crate) geographic_role: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the column schema.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the column schema.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The data type of the column schema.</p>
        pub fn data_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_type = Some(input.into());
            self
        }
        /// <p>The data type of the column schema.</p>
        pub fn set_data_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_type = input;
            self
        }
        /// <p>The geographic role of the column schema.</p>
        pub fn geographic_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.geographic_role = Some(input.into());
            self
        }
        /// <p>The geographic role of the column schema.</p>
        pub fn set_geographic_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.geographic_role = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnSchema`](crate::model::ColumnSchema).
        pub fn build(self) -> crate::model::ColumnSchema {
            crate::model::ColumnSchema {
                name: self.name,
                data_type: self.data_type,
                geographic_role: self.geographic_role,
            }
        }
    }
}
impl ColumnSchema {
    /// Creates a new builder-style object to manufacture [`ColumnSchema`](crate::model::ColumnSchema).
    pub fn builder() -> crate::model::column_schema::Builder {
        crate::model::column_schema::Builder::default()
    }
}

/// <p>The source entity of the template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TemplateSourceEntity {
    /// <p>The source analysis, if it is based on an analysis.</p>
    #[doc(hidden)]
    pub source_analysis: std::option::Option<crate::model::TemplateSourceAnalysis>,
    /// <p>The source template, if it is based on an template.</p>
    #[doc(hidden)]
    pub source_template: std::option::Option<crate::model::TemplateSourceTemplate>,
}
impl TemplateSourceEntity {
    /// <p>The source analysis, if it is based on an analysis.</p>
    pub fn source_analysis(&self) -> std::option::Option<&crate::model::TemplateSourceAnalysis> {
        self.source_analysis.as_ref()
    }
    /// <p>The source template, if it is based on an template.</p>
    pub fn source_template(&self) -> std::option::Option<&crate::model::TemplateSourceTemplate> {
        self.source_template.as_ref()
    }
}
/// See [`TemplateSourceEntity`](crate::model::TemplateSourceEntity).
pub mod template_source_entity {

    /// A builder for [`TemplateSourceEntity`](crate::model::TemplateSourceEntity).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_analysis: std::option::Option<crate::model::TemplateSourceAnalysis>,
        pub(crate) source_template: std::option::Option<crate::model::TemplateSourceTemplate>,
    }
    impl Builder {
        /// <p>The source analysis, if it is based on an analysis.</p>
        pub fn source_analysis(mut self, input: crate::model::TemplateSourceAnalysis) -> Self {
            self.source_analysis = Some(input);
            self
        }
        /// <p>The source analysis, if it is based on an analysis.</p>
        pub fn set_source_analysis(
            mut self,
            input: std::option::Option<crate::model::TemplateSourceAnalysis>,
        ) -> Self {
            self.source_analysis = input;
            self
        }
        /// <p>The source template, if it is based on an template.</p>
        pub fn source_template(mut self, input: crate::model::TemplateSourceTemplate) -> Self {
            self.source_template = Some(input);
            self
        }
        /// <p>The source template, if it is based on an template.</p>
        pub fn set_source_template(
            mut self,
            input: std::option::Option<crate::model::TemplateSourceTemplate>,
        ) -> Self {
            self.source_template = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateSourceEntity`](crate::model::TemplateSourceEntity).
        pub fn build(self) -> crate::model::TemplateSourceEntity {
            crate::model::TemplateSourceEntity {
                source_analysis: self.source_analysis,
                source_template: self.source_template,
            }
        }
    }
}
impl TemplateSourceEntity {
    /// Creates a new builder-style object to manufacture [`TemplateSourceEntity`](crate::model::TemplateSourceEntity).
    pub fn builder() -> crate::model::template_source_entity::Builder {
        crate::model::template_source_entity::Builder::default()
    }
}

/// <p>The source template of the template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TemplateSourceTemplate {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl TemplateSourceTemplate {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
/// See [`TemplateSourceTemplate`](crate::model::TemplateSourceTemplate).
pub mod template_source_template {

    /// A builder for [`TemplateSourceTemplate`](crate::model::TemplateSourceTemplate).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateSourceTemplate`](crate::model::TemplateSourceTemplate).
        pub fn build(self) -> crate::model::TemplateSourceTemplate {
            crate::model::TemplateSourceTemplate { arn: self.arn }
        }
    }
}
impl TemplateSourceTemplate {
    /// Creates a new builder-style object to manufacture [`TemplateSourceTemplate`](crate::model::TemplateSourceTemplate).
    pub fn builder() -> crate::model::template_source_template::Builder {
        crate::model::template_source_template::Builder::default()
    }
}

/// <p>The source analysis of the template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TemplateSourceAnalysis {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>A structure containing information about the dataset references used as placeholders in the template.</p>
    #[doc(hidden)]
    pub data_set_references: std::option::Option<std::vec::Vec<crate::model::DataSetReference>>,
}
impl TemplateSourceAnalysis {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>A structure containing information about the dataset references used as placeholders in the template.</p>
    pub fn data_set_references(&self) -> std::option::Option<&[crate::model::DataSetReference]> {
        self.data_set_references.as_deref()
    }
}
/// See [`TemplateSourceAnalysis`](crate::model::TemplateSourceAnalysis).
pub mod template_source_analysis {

    /// A builder for [`TemplateSourceAnalysis`](crate::model::TemplateSourceAnalysis).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) data_set_references:
            std::option::Option<std::vec::Vec<crate::model::DataSetReference>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Appends an item to `data_set_references`.
        ///
        /// To override the contents of this collection use [`set_data_set_references`](Self::set_data_set_references).
        ///
        /// <p>A structure containing information about the dataset references used as placeholders in the template.</p>
        pub fn data_set_references(mut self, input: crate::model::DataSetReference) -> Self {
            let mut v = self.data_set_references.unwrap_or_default();
            v.push(input);
            self.data_set_references = Some(v);
            self
        }
        /// <p>A structure containing information about the dataset references used as placeholders in the template.</p>
        pub fn set_data_set_references(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSetReference>>,
        ) -> Self {
            self.data_set_references = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateSourceAnalysis`](crate::model::TemplateSourceAnalysis).
        pub fn build(self) -> crate::model::TemplateSourceAnalysis {
            crate::model::TemplateSourceAnalysis {
                arn: self.arn,
                data_set_references: self.data_set_references,
            }
        }
    }
}
impl TemplateSourceAnalysis {
    /// Creates a new builder-style object to manufacture [`TemplateSourceAnalysis`](crate::model::TemplateSourceAnalysis).
    pub fn builder() -> crate::model::template_source_analysis::Builder {
        crate::model::template_source_analysis::Builder::default()
    }
}

/// <p>Dataset reference.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSetReference {
    /// <p>Dataset placeholder.</p>
    #[doc(hidden)]
    pub data_set_placeholder: std::option::Option<std::string::String>,
    /// <p>Dataset Amazon Resource Name (ARN).</p>
    #[doc(hidden)]
    pub data_set_arn: std::option::Option<std::string::String>,
}
impl DataSetReference {
    /// <p>Dataset placeholder.</p>
    pub fn data_set_placeholder(&self) -> std::option::Option<&str> {
        self.data_set_placeholder.as_deref()
    }
    /// <p>Dataset Amazon Resource Name (ARN).</p>
    pub fn data_set_arn(&self) -> std::option::Option<&str> {
        self.data_set_arn.as_deref()
    }
}
/// See [`DataSetReference`](crate::model::DataSetReference).
pub mod data_set_reference {

    /// A builder for [`DataSetReference`](crate::model::DataSetReference).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_set_placeholder: std::option::Option<std::string::String>,
        pub(crate) data_set_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Dataset placeholder.</p>
        pub fn data_set_placeholder(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_set_placeholder = Some(input.into());
            self
        }
        /// <p>Dataset placeholder.</p>
        pub fn set_data_set_placeholder(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_set_placeholder = input;
            self
        }
        /// <p>Dataset Amazon Resource Name (ARN).</p>
        pub fn data_set_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_set_arn = Some(input.into());
            self
        }
        /// <p>Dataset Amazon Resource Name (ARN).</p>
        pub fn set_data_set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_set_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSetReference`](crate::model::DataSetReference).
        pub fn build(self) -> crate::model::DataSetReference {
            crate::model::DataSetReference {
                data_set_placeholder: self.data_set_placeholder,
                data_set_arn: self.data_set_arn,
            }
        }
    }
}
impl DataSetReference {
    /// Creates a new builder-style object to manufacture [`DataSetReference`](crate::model::DataSetReference).
    pub fn builder() -> crate::model::data_set_reference::Builder {
        crate::model::data_set_reference::Builder::default()
    }
}

/// When writing a match expression against `AssignmentStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let assignmentstatus = unimplemented!();
/// match assignmentstatus {
///     AssignmentStatus::Disabled => { /* ... */ },
///     AssignmentStatus::Draft => { /* ... */ },
///     AssignmentStatus::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `assignmentstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AssignmentStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AssignmentStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AssignmentStatus::NewFeature` is defined.
/// Specifically, when `assignmentstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AssignmentStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssignmentStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Draft,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AssignmentStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => AssignmentStatus::Disabled,
            "DRAFT" => AssignmentStatus::Draft,
            "ENABLED" => AssignmentStatus::Enabled,
            other => AssignmentStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AssignmentStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssignmentStatus::from(s))
    }
}
impl AssignmentStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AssignmentStatus::Disabled => "DISABLED",
            AssignmentStatus::Draft => "DRAFT",
            AssignmentStatus::Enabled => "ENABLED",
            AssignmentStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "DRAFT", "ENABLED"]
    }
}
impl AsRef<str> for AssignmentStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A <i>group</i> in Amazon QuickSight consists of a set of users. You can use groups to make it easier to manage access and security. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Group {
    /// <p>The Amazon Resource Name (ARN) for the group.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the group.</p>
    #[doc(hidden)]
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The group description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The principal ID of the group.</p>
    #[doc(hidden)]
    pub principal_id: std::option::Option<std::string::String>,
}
impl Group {
    /// <p>The Amazon Resource Name (ARN) for the group.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the group.</p>
    pub fn group_name(&self) -> std::option::Option<&str> {
        self.group_name.as_deref()
    }
    /// <p>The group description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The principal ID of the group.</p>
    pub fn principal_id(&self) -> std::option::Option<&str> {
        self.principal_id.as_deref()
    }
}
/// See [`Group`](crate::model::Group).
pub mod group {

    /// A builder for [`Group`](crate::model::Group).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) principal_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for the group.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the group.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the group.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        /// <p>The name of the group.</p>
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The group description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The group description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The principal ID of the group.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_id = Some(input.into());
            self
        }
        /// <p>The principal ID of the group.</p>
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal_id = input;
            self
        }
        /// Consumes the builder and constructs a [`Group`](crate::model::Group).
        pub fn build(self) -> crate::model::Group {
            crate::model::Group {
                arn: self.arn,
                group_name: self.group_name,
                description: self.description,
                principal_id: self.principal_id,
            }
        }
    }
}
impl Group {
    /// Creates a new builder-style object to manufacture [`Group`](crate::model::Group).
    pub fn builder() -> crate::model::group::Builder {
        crate::model::group::Builder::default()
    }
}

/// <p>Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SslProperties {
    /// <p>A Boolean option to control whether SSL should be disabled.</p>
    #[doc(hidden)]
    pub disable_ssl: bool,
}
impl SslProperties {
    /// <p>A Boolean option to control whether SSL should be disabled.</p>
    pub fn disable_ssl(&self) -> bool {
        self.disable_ssl
    }
}
/// See [`SslProperties`](crate::model::SslProperties).
pub mod ssl_properties {

    /// A builder for [`SslProperties`](crate::model::SslProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) disable_ssl: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>A Boolean option to control whether SSL should be disabled.</p>
        pub fn disable_ssl(mut self, input: bool) -> Self {
            self.disable_ssl = Some(input);
            self
        }
        /// <p>A Boolean option to control whether SSL should be disabled.</p>
        pub fn set_disable_ssl(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_ssl = input;
            self
        }
        /// Consumes the builder and constructs a [`SslProperties`](crate::model::SslProperties).
        pub fn build(self) -> crate::model::SslProperties {
            crate::model::SslProperties {
                disable_ssl: self.disable_ssl.unwrap_or_default(),
            }
        }
    }
}
impl SslProperties {
    /// Creates a new builder-style object to manufacture [`SslProperties`](crate::model::SslProperties).
    pub fn builder() -> crate::model::ssl_properties::Builder {
        crate::model::ssl_properties::Builder::default()
    }
}

/// <p>VPC connection properties.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VpcConnectionProperties {
    /// <p>The Amazon Resource Name (ARN) for the VPC connection.</p>
    #[doc(hidden)]
    pub vpc_connection_arn: std::option::Option<std::string::String>,
}
impl VpcConnectionProperties {
    /// <p>The Amazon Resource Name (ARN) for the VPC connection.</p>
    pub fn vpc_connection_arn(&self) -> std::option::Option<&str> {
        self.vpc_connection_arn.as_deref()
    }
}
/// See [`VpcConnectionProperties`](crate::model::VpcConnectionProperties).
pub mod vpc_connection_properties {

    /// A builder for [`VpcConnectionProperties`](crate::model::VpcConnectionProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_connection_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for the VPC connection.</p>
        pub fn vpc_connection_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_connection_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the VPC connection.</p>
        pub fn set_vpc_connection_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_connection_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcConnectionProperties`](crate::model::VpcConnectionProperties).
        pub fn build(self) -> crate::model::VpcConnectionProperties {
            crate::model::VpcConnectionProperties {
                vpc_connection_arn: self.vpc_connection_arn,
            }
        }
    }
}
impl VpcConnectionProperties {
    /// Creates a new builder-style object to manufacture [`VpcConnectionProperties`](crate::model::VpcConnectionProperties).
    pub fn builder() -> crate::model::vpc_connection_properties::Builder {
        crate::model::vpc_connection_properties::Builder::default()
    }
}

/// <p>Data source credentials. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataSourceCredentials {
    /// <p>Credential pair. For more information, see <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_CredentialPair.html">CredentialPair</a> </code>.</p>
    #[doc(hidden)]
    pub credential_pair: std::option::Option<crate::model::CredentialPair>,
    /// <p>The Amazon Resource Name (ARN) of a data source that has the credential pair that you want to use. When <code>CopySourceArn</code> is not null, the credential pair from the data source in the ARN is used as the credentials for the <code>DataSourceCredentials</code> structure.</p>
    #[doc(hidden)]
    pub copy_source_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.</p>
    #[doc(hidden)]
    pub secret_arn: std::option::Option<std::string::String>,
}
impl DataSourceCredentials {
    /// <p>Credential pair. For more information, see <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_CredentialPair.html">CredentialPair</a> </code>.</p>
    pub fn credential_pair(&self) -> std::option::Option<&crate::model::CredentialPair> {
        self.credential_pair.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of a data source that has the credential pair that you want to use. When <code>CopySourceArn</code> is not null, the credential pair from the data source in the ARN is used as the credentials for the <code>DataSourceCredentials</code> structure.</p>
    pub fn copy_source_arn(&self) -> std::option::Option<&str> {
        self.copy_source_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.</p>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
}
impl std::fmt::Debug for DataSourceCredentials {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataSourceCredentials");
        formatter.field("credential_pair", &"*** Sensitive Data Redacted ***");
        formatter.field("copy_source_arn", &"*** Sensitive Data Redacted ***");
        formatter.field("secret_arn", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`DataSourceCredentials`](crate::model::DataSourceCredentials).
pub mod data_source_credentials {

    /// A builder for [`DataSourceCredentials`](crate::model::DataSourceCredentials).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) credential_pair: std::option::Option<crate::model::CredentialPair>,
        pub(crate) copy_source_arn: std::option::Option<std::string::String>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Credential pair. For more information, see <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_CredentialPair.html">CredentialPair</a> </code>.</p>
        pub fn credential_pair(mut self, input: crate::model::CredentialPair) -> Self {
            self.credential_pair = Some(input);
            self
        }
        /// <p>Credential pair. For more information, see <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_CredentialPair.html">CredentialPair</a> </code>.</p>
        pub fn set_credential_pair(
            mut self,
            input: std::option::Option<crate::model::CredentialPair>,
        ) -> Self {
            self.credential_pair = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a data source that has the credential pair that you want to use. When <code>CopySourceArn</code> is not null, the credential pair from the data source in the ARN is used as the credentials for the <code>DataSourceCredentials</code> structure.</p>
        pub fn copy_source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.copy_source_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a data source that has the credential pair that you want to use. When <code>CopySourceArn</code> is not null, the credential pair from the data source in the ARN is used as the credentials for the <code>DataSourceCredentials</code> structure.</p>
        pub fn set_copy_source_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.copy_source_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.</p>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.</p>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSourceCredentials`](crate::model::DataSourceCredentials).
        pub fn build(self) -> crate::model::DataSourceCredentials {
            crate::model::DataSourceCredentials {
                credential_pair: self.credential_pair,
                copy_source_arn: self.copy_source_arn,
                secret_arn: self.secret_arn,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("credential_pair", &"*** Sensitive Data Redacted ***");
            formatter.field("copy_source_arn", &"*** Sensitive Data Redacted ***");
            formatter.field("secret_arn", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl DataSourceCredentials {
    /// Creates a new builder-style object to manufacture [`DataSourceCredentials`](crate::model::DataSourceCredentials).
    pub fn builder() -> crate::model::data_source_credentials::Builder {
        crate::model::data_source_credentials::Builder::default()
    }
}

/// <p>The combination of user name and password that are used as credentials.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CredentialPair {
    /// <p>User name.</p>
    #[doc(hidden)]
    pub username: std::option::Option<std::string::String>,
    /// <p>Password.</p>
    #[doc(hidden)]
    pub password: std::option::Option<std::string::String>,
    /// <p>A set of alternate data source parameters that you want to share for these credentials. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the <code>DataSourceParameters</code> structure that's in the request with the structures in the <code>AlternateDataSourceParameters</code> allow list. If the structures are an exact match, the request is allowed to use the new data source with the existing credentials. If the <code>AlternateDataSourceParameters</code> list is null, the <code>DataSourceParameters</code> originally used with these <code>Credentials</code> is automatically allowed.</p>
    #[doc(hidden)]
    pub alternate_data_source_parameters:
        std::option::Option<std::vec::Vec<crate::model::DataSourceParameters>>,
}
impl CredentialPair {
    /// <p>User name.</p>
    pub fn username(&self) -> std::option::Option<&str> {
        self.username.as_deref()
    }
    /// <p>Password.</p>
    pub fn password(&self) -> std::option::Option<&str> {
        self.password.as_deref()
    }
    /// <p>A set of alternate data source parameters that you want to share for these credentials. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the <code>DataSourceParameters</code> structure that's in the request with the structures in the <code>AlternateDataSourceParameters</code> allow list. If the structures are an exact match, the request is allowed to use the new data source with the existing credentials. If the <code>AlternateDataSourceParameters</code> list is null, the <code>DataSourceParameters</code> originally used with these <code>Credentials</code> is automatically allowed.</p>
    pub fn alternate_data_source_parameters(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceParameters]> {
        self.alternate_data_source_parameters.as_deref()
    }
}
/// See [`CredentialPair`](crate::model::CredentialPair).
pub mod credential_pair {

    /// A builder for [`CredentialPair`](crate::model::CredentialPair).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) username: std::option::Option<std::string::String>,
        pub(crate) password: std::option::Option<std::string::String>,
        pub(crate) alternate_data_source_parameters:
            std::option::Option<std::vec::Vec<crate::model::DataSourceParameters>>,
    }
    impl Builder {
        /// <p>User name.</p>
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.username = Some(input.into());
            self
        }
        /// <p>User name.</p>
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.username = input;
            self
        }
        /// <p>Password.</p>
        pub fn password(mut self, input: impl Into<std::string::String>) -> Self {
            self.password = Some(input.into());
            self
        }
        /// <p>Password.</p>
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.password = input;
            self
        }
        /// Appends an item to `alternate_data_source_parameters`.
        ///
        /// To override the contents of this collection use [`set_alternate_data_source_parameters`](Self::set_alternate_data_source_parameters).
        ///
        /// <p>A set of alternate data source parameters that you want to share for these credentials. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the <code>DataSourceParameters</code> structure that's in the request with the structures in the <code>AlternateDataSourceParameters</code> allow list. If the structures are an exact match, the request is allowed to use the new data source with the existing credentials. If the <code>AlternateDataSourceParameters</code> list is null, the <code>DataSourceParameters</code> originally used with these <code>Credentials</code> is automatically allowed.</p>
        pub fn alternate_data_source_parameters(
            mut self,
            input: crate::model::DataSourceParameters,
        ) -> Self {
            let mut v = self.alternate_data_source_parameters.unwrap_or_default();
            v.push(input);
            self.alternate_data_source_parameters = Some(v);
            self
        }
        /// <p>A set of alternate data source parameters that you want to share for these credentials. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the <code>DataSourceParameters</code> structure that's in the request with the structures in the <code>AlternateDataSourceParameters</code> allow list. If the structures are an exact match, the request is allowed to use the new data source with the existing credentials. If the <code>AlternateDataSourceParameters</code> list is null, the <code>DataSourceParameters</code> originally used with these <code>Credentials</code> is automatically allowed.</p>
        pub fn set_alternate_data_source_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceParameters>>,
        ) -> Self {
            self.alternate_data_source_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`CredentialPair`](crate::model::CredentialPair).
        pub fn build(self) -> crate::model::CredentialPair {
            crate::model::CredentialPair {
                username: self.username,
                password: self.password,
                alternate_data_source_parameters: self.alternate_data_source_parameters,
            }
        }
    }
}
impl CredentialPair {
    /// Creates a new builder-style object to manufacture [`CredentialPair`](crate::model::CredentialPair).
    pub fn builder() -> crate::model::credential_pair::Builder {
        crate::model::credential_pair::Builder::default()
    }
}

/// <p>The parameters that Amazon QuickSight uses to connect to your underlying data source. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum DataSourceParameters {
    /// <p>The parameters for OpenSearch.</p>
    AmazonElasticsearchParameters(crate::model::AmazonElasticsearchParameters),
    /// <p>The parameters for OpenSearch.</p>
    AmazonOpenSearchParameters(crate::model::AmazonOpenSearchParameters),
    /// <p>The parameters for Amazon Athena.</p>
    AthenaParameters(crate::model::AthenaParameters),
    /// <p>The parameters for Amazon Aurora MySQL.</p>
    AuroraParameters(crate::model::AuroraParameters),
    /// <p>The parameters for Amazon Aurora.</p>
    AuroraPostgreSqlParameters(crate::model::AuroraPostgreSqlParameters),
    /// <p>The parameters for IoT Analytics.</p>
    AwsIotAnalyticsParameters(crate::model::AwsIotAnalyticsParameters),
    /// <p>The required parameters that are needed to connect to a Databricks data source.</p>
    DatabricksParameters(crate::model::DatabricksParameters),
    /// <p>The parameters for Exasol.</p>
    ExasolParameters(crate::model::ExasolParameters),
    /// <p>The parameters for Jira.</p>
    JiraParameters(crate::model::JiraParameters),
    /// <p>The parameters for MariaDB.</p>
    MariaDbParameters(crate::model::MariaDbParameters),
    /// <p>The parameters for MySQL.</p>
    MySqlParameters(crate::model::MySqlParameters),
    /// <p>The parameters for Oracle.</p>
    OracleParameters(crate::model::OracleParameters),
    /// <p>The parameters for PostgreSQL.</p>
    PostgreSqlParameters(crate::model::PostgreSqlParameters),
    /// <p>The parameters for Presto.</p>
    PrestoParameters(crate::model::PrestoParameters),
    /// <p>The parameters for Amazon RDS.</p>
    RdsParameters(crate::model::RdsParameters),
    /// <p>The parameters for Amazon Redshift.</p>
    RedshiftParameters(crate::model::RedshiftParameters),
    /// <p>The parameters for S3.</p>
    S3Parameters(crate::model::S3Parameters),
    /// <p>The parameters for ServiceNow.</p>
    ServiceNowParameters(crate::model::ServiceNowParameters),
    /// <p>The parameters for Snowflake.</p>
    SnowflakeParameters(crate::model::SnowflakeParameters),
    /// <p>The parameters for Spark.</p>
    SparkParameters(crate::model::SparkParameters),
    /// <p>The parameters for SQL Server.</p>
    SqlServerParameters(crate::model::SqlServerParameters),
    /// <p>The parameters for Teradata.</p>
    TeradataParameters(crate::model::TeradataParameters),
    /// <p>The parameters for Twitter.</p>
    TwitterParameters(crate::model::TwitterParameters),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl DataSourceParameters {
    /// Tries to convert the enum instance into [`AmazonElasticsearchParameters`](crate::model::DataSourceParameters::AmazonElasticsearchParameters), extracting the inner [`AmazonElasticsearchParameters`](crate::model::AmazonElasticsearchParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_amazon_elasticsearch_parameters(
        &self,
    ) -> std::result::Result<&crate::model::AmazonElasticsearchParameters, &Self> {
        if let DataSourceParameters::AmazonElasticsearchParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`AmazonElasticsearchParameters`](crate::model::DataSourceParameters::AmazonElasticsearchParameters).
    pub fn is_amazon_elasticsearch_parameters(&self) -> bool {
        self.as_amazon_elasticsearch_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`AmazonOpenSearchParameters`](crate::model::DataSourceParameters::AmazonOpenSearchParameters), extracting the inner [`AmazonOpenSearchParameters`](crate::model::AmazonOpenSearchParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_amazon_open_search_parameters(
        &self,
    ) -> std::result::Result<&crate::model::AmazonOpenSearchParameters, &Self> {
        if let DataSourceParameters::AmazonOpenSearchParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`AmazonOpenSearchParameters`](crate::model::DataSourceParameters::AmazonOpenSearchParameters).
    pub fn is_amazon_open_search_parameters(&self) -> bool {
        self.as_amazon_open_search_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`AthenaParameters`](crate::model::DataSourceParameters::AthenaParameters), extracting the inner [`AthenaParameters`](crate::model::AthenaParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_athena_parameters(
        &self,
    ) -> std::result::Result<&crate::model::AthenaParameters, &Self> {
        if let DataSourceParameters::AthenaParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`AthenaParameters`](crate::model::DataSourceParameters::AthenaParameters).
    pub fn is_athena_parameters(&self) -> bool {
        self.as_athena_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`AuroraParameters`](crate::model::DataSourceParameters::AuroraParameters), extracting the inner [`AuroraParameters`](crate::model::AuroraParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_aurora_parameters(
        &self,
    ) -> std::result::Result<&crate::model::AuroraParameters, &Self> {
        if let DataSourceParameters::AuroraParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`AuroraParameters`](crate::model::DataSourceParameters::AuroraParameters).
    pub fn is_aurora_parameters(&self) -> bool {
        self.as_aurora_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`AuroraPostgreSqlParameters`](crate::model::DataSourceParameters::AuroraPostgreSqlParameters), extracting the inner [`AuroraPostgreSqlParameters`](crate::model::AuroraPostgreSqlParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_aurora_postgre_sql_parameters(
        &self,
    ) -> std::result::Result<&crate::model::AuroraPostgreSqlParameters, &Self> {
        if let DataSourceParameters::AuroraPostgreSqlParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`AuroraPostgreSqlParameters`](crate::model::DataSourceParameters::AuroraPostgreSqlParameters).
    pub fn is_aurora_postgre_sql_parameters(&self) -> bool {
        self.as_aurora_postgre_sql_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`AwsIotAnalyticsParameters`](crate::model::DataSourceParameters::AwsIotAnalyticsParameters), extracting the inner [`AwsIotAnalyticsParameters`](crate::model::AwsIotAnalyticsParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_aws_iot_analytics_parameters(
        &self,
    ) -> std::result::Result<&crate::model::AwsIotAnalyticsParameters, &Self> {
        if let DataSourceParameters::AwsIotAnalyticsParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`AwsIotAnalyticsParameters`](crate::model::DataSourceParameters::AwsIotAnalyticsParameters).
    pub fn is_aws_iot_analytics_parameters(&self) -> bool {
        self.as_aws_iot_analytics_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`DatabricksParameters`](crate::model::DataSourceParameters::DatabricksParameters), extracting the inner [`DatabricksParameters`](crate::model::DatabricksParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_databricks_parameters(
        &self,
    ) -> std::result::Result<&crate::model::DatabricksParameters, &Self> {
        if let DataSourceParameters::DatabricksParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`DatabricksParameters`](crate::model::DataSourceParameters::DatabricksParameters).
    pub fn is_databricks_parameters(&self) -> bool {
        self.as_databricks_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`ExasolParameters`](crate::model::DataSourceParameters::ExasolParameters), extracting the inner [`ExasolParameters`](crate::model::ExasolParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_exasol_parameters(
        &self,
    ) -> std::result::Result<&crate::model::ExasolParameters, &Self> {
        if let DataSourceParameters::ExasolParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ExasolParameters`](crate::model::DataSourceParameters::ExasolParameters).
    pub fn is_exasol_parameters(&self) -> bool {
        self.as_exasol_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`JiraParameters`](crate::model::DataSourceParameters::JiraParameters), extracting the inner [`JiraParameters`](crate::model::JiraParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_jira_parameters(&self) -> std::result::Result<&crate::model::JiraParameters, &Self> {
        if let DataSourceParameters::JiraParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`JiraParameters`](crate::model::DataSourceParameters::JiraParameters).
    pub fn is_jira_parameters(&self) -> bool {
        self.as_jira_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`MariaDbParameters`](crate::model::DataSourceParameters::MariaDbParameters), extracting the inner [`MariaDbParameters`](crate::model::MariaDbParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_maria_db_parameters(
        &self,
    ) -> std::result::Result<&crate::model::MariaDbParameters, &Self> {
        if let DataSourceParameters::MariaDbParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`MariaDbParameters`](crate::model::DataSourceParameters::MariaDbParameters).
    pub fn is_maria_db_parameters(&self) -> bool {
        self.as_maria_db_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`MySqlParameters`](crate::model::DataSourceParameters::MySqlParameters), extracting the inner [`MySqlParameters`](crate::model::MySqlParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_my_sql_parameters(
        &self,
    ) -> std::result::Result<&crate::model::MySqlParameters, &Self> {
        if let DataSourceParameters::MySqlParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`MySqlParameters`](crate::model::DataSourceParameters::MySqlParameters).
    pub fn is_my_sql_parameters(&self) -> bool {
        self.as_my_sql_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`OracleParameters`](crate::model::DataSourceParameters::OracleParameters), extracting the inner [`OracleParameters`](crate::model::OracleParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_oracle_parameters(
        &self,
    ) -> std::result::Result<&crate::model::OracleParameters, &Self> {
        if let DataSourceParameters::OracleParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`OracleParameters`](crate::model::DataSourceParameters::OracleParameters).
    pub fn is_oracle_parameters(&self) -> bool {
        self.as_oracle_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`PostgreSqlParameters`](crate::model::DataSourceParameters::PostgreSqlParameters), extracting the inner [`PostgreSqlParameters`](crate::model::PostgreSqlParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_postgre_sql_parameters(
        &self,
    ) -> std::result::Result<&crate::model::PostgreSqlParameters, &Self> {
        if let DataSourceParameters::PostgreSqlParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`PostgreSqlParameters`](crate::model::DataSourceParameters::PostgreSqlParameters).
    pub fn is_postgre_sql_parameters(&self) -> bool {
        self.as_postgre_sql_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`PrestoParameters`](crate::model::DataSourceParameters::PrestoParameters), extracting the inner [`PrestoParameters`](crate::model::PrestoParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_presto_parameters(
        &self,
    ) -> std::result::Result<&crate::model::PrestoParameters, &Self> {
        if let DataSourceParameters::PrestoParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`PrestoParameters`](crate::model::DataSourceParameters::PrestoParameters).
    pub fn is_presto_parameters(&self) -> bool {
        self.as_presto_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`RdsParameters`](crate::model::DataSourceParameters::RdsParameters), extracting the inner [`RdsParameters`](crate::model::RdsParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_rds_parameters(&self) -> std::result::Result<&crate::model::RdsParameters, &Self> {
        if let DataSourceParameters::RdsParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`RdsParameters`](crate::model::DataSourceParameters::RdsParameters).
    pub fn is_rds_parameters(&self) -> bool {
        self.as_rds_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`RedshiftParameters`](crate::model::DataSourceParameters::RedshiftParameters), extracting the inner [`RedshiftParameters`](crate::model::RedshiftParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_redshift_parameters(
        &self,
    ) -> std::result::Result<&crate::model::RedshiftParameters, &Self> {
        if let DataSourceParameters::RedshiftParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`RedshiftParameters`](crate::model::DataSourceParameters::RedshiftParameters).
    pub fn is_redshift_parameters(&self) -> bool {
        self.as_redshift_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`S3Parameters`](crate::model::DataSourceParameters::S3Parameters), extracting the inner [`S3Parameters`](crate::model::S3Parameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_s3_parameters(&self) -> std::result::Result<&crate::model::S3Parameters, &Self> {
        if let DataSourceParameters::S3Parameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`S3Parameters`](crate::model::DataSourceParameters::S3Parameters).
    pub fn is_s3_parameters(&self) -> bool {
        self.as_s3_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`ServiceNowParameters`](crate::model::DataSourceParameters::ServiceNowParameters), extracting the inner [`ServiceNowParameters`](crate::model::ServiceNowParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_service_now_parameters(
        &self,
    ) -> std::result::Result<&crate::model::ServiceNowParameters, &Self> {
        if let DataSourceParameters::ServiceNowParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ServiceNowParameters`](crate::model::DataSourceParameters::ServiceNowParameters).
    pub fn is_service_now_parameters(&self) -> bool {
        self.as_service_now_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`SnowflakeParameters`](crate::model::DataSourceParameters::SnowflakeParameters), extracting the inner [`SnowflakeParameters`](crate::model::SnowflakeParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_snowflake_parameters(
        &self,
    ) -> std::result::Result<&crate::model::SnowflakeParameters, &Self> {
        if let DataSourceParameters::SnowflakeParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`SnowflakeParameters`](crate::model::DataSourceParameters::SnowflakeParameters).
    pub fn is_snowflake_parameters(&self) -> bool {
        self.as_snowflake_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`SparkParameters`](crate::model::DataSourceParameters::SparkParameters), extracting the inner [`SparkParameters`](crate::model::SparkParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_spark_parameters(
        &self,
    ) -> std::result::Result<&crate::model::SparkParameters, &Self> {
        if let DataSourceParameters::SparkParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`SparkParameters`](crate::model::DataSourceParameters::SparkParameters).
    pub fn is_spark_parameters(&self) -> bool {
        self.as_spark_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`SqlServerParameters`](crate::model::DataSourceParameters::SqlServerParameters), extracting the inner [`SqlServerParameters`](crate::model::SqlServerParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_sql_server_parameters(
        &self,
    ) -> std::result::Result<&crate::model::SqlServerParameters, &Self> {
        if let DataSourceParameters::SqlServerParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`SqlServerParameters`](crate::model::DataSourceParameters::SqlServerParameters).
    pub fn is_sql_server_parameters(&self) -> bool {
        self.as_sql_server_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`TeradataParameters`](crate::model::DataSourceParameters::TeradataParameters), extracting the inner [`TeradataParameters`](crate::model::TeradataParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_teradata_parameters(
        &self,
    ) -> std::result::Result<&crate::model::TeradataParameters, &Self> {
        if let DataSourceParameters::TeradataParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`TeradataParameters`](crate::model::DataSourceParameters::TeradataParameters).
    pub fn is_teradata_parameters(&self) -> bool {
        self.as_teradata_parameters().is_ok()
    }
    /// Tries to convert the enum instance into [`TwitterParameters`](crate::model::DataSourceParameters::TwitterParameters), extracting the inner [`TwitterParameters`](crate::model::TwitterParameters).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_twitter_parameters(
        &self,
    ) -> std::result::Result<&crate::model::TwitterParameters, &Self> {
        if let DataSourceParameters::TwitterParameters(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`TwitterParameters`](crate::model::DataSourceParameters::TwitterParameters).
    pub fn is_twitter_parameters(&self) -> bool {
        self.as_twitter_parameters().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>The required parameters that are needed to connect to a Databricks data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DatabricksParameters {
    /// <p>The host name of the Databricks data source.</p>
    #[doc(hidden)]
    pub host: std::option::Option<std::string::String>,
    /// <p>The port for the Databricks data source.</p>
    #[doc(hidden)]
    pub port: i32,
    /// <p>The HTTP path of the Databricks data source.</p>
    #[doc(hidden)]
    pub sql_endpoint_path: std::option::Option<std::string::String>,
}
impl DatabricksParameters {
    /// <p>The host name of the Databricks data source.</p>
    pub fn host(&self) -> std::option::Option<&str> {
        self.host.as_deref()
    }
    /// <p>The port for the Databricks data source.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
    /// <p>The HTTP path of the Databricks data source.</p>
    pub fn sql_endpoint_path(&self) -> std::option::Option<&str> {
        self.sql_endpoint_path.as_deref()
    }
}
/// See [`DatabricksParameters`](crate::model::DatabricksParameters).
pub mod databricks_parameters {

    /// A builder for [`DatabricksParameters`](crate::model::DatabricksParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) sql_endpoint_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The host name of the Databricks data source.</p>
        pub fn host(mut self, input: impl Into<std::string::String>) -> Self {
            self.host = Some(input.into());
            self
        }
        /// <p>The host name of the Databricks data source.</p>
        pub fn set_host(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host = input;
            self
        }
        /// <p>The port for the Databricks data source.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The port for the Databricks data source.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>The HTTP path of the Databricks data source.</p>
        pub fn sql_endpoint_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.sql_endpoint_path = Some(input.into());
            self
        }
        /// <p>The HTTP path of the Databricks data source.</p>
        pub fn set_sql_endpoint_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sql_endpoint_path = input;
            self
        }
        /// Consumes the builder and constructs a [`DatabricksParameters`](crate::model::DatabricksParameters).
        pub fn build(self) -> crate::model::DatabricksParameters {
            crate::model::DatabricksParameters {
                host: self.host,
                port: self.port.unwrap_or_default(),
                sql_endpoint_path: self.sql_endpoint_path,
            }
        }
    }
}
impl DatabricksParameters {
    /// Creates a new builder-style object to manufacture [`DatabricksParameters`](crate::model::DatabricksParameters).
    pub fn builder() -> crate::model::databricks_parameters::Builder {
        crate::model::databricks_parameters::Builder::default()
    }
}

/// <p>The required parameters for connecting to an Exasol data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExasolParameters {
    /// <p>The hostname or IP address of the Exasol data source.</p>
    #[doc(hidden)]
    pub host: std::option::Option<std::string::String>,
    /// <p>The port for the Exasol data source.</p>
    #[doc(hidden)]
    pub port: i32,
}
impl ExasolParameters {
    /// <p>The hostname or IP address of the Exasol data source.</p>
    pub fn host(&self) -> std::option::Option<&str> {
        self.host.as_deref()
    }
    /// <p>The port for the Exasol data source.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
}
/// See [`ExasolParameters`](crate::model::ExasolParameters).
pub mod exasol_parameters {

    /// A builder for [`ExasolParameters`](crate::model::ExasolParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The hostname or IP address of the Exasol data source.</p>
        pub fn host(mut self, input: impl Into<std::string::String>) -> Self {
            self.host = Some(input.into());
            self
        }
        /// <p>The hostname or IP address of the Exasol data source.</p>
        pub fn set_host(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host = input;
            self
        }
        /// <p>The port for the Exasol data source.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The port for the Exasol data source.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// Consumes the builder and constructs a [`ExasolParameters`](crate::model::ExasolParameters).
        pub fn build(self) -> crate::model::ExasolParameters {
            crate::model::ExasolParameters {
                host: self.host,
                port: self.port.unwrap_or_default(),
            }
        }
    }
}
impl ExasolParameters {
    /// Creates a new builder-style object to manufacture [`ExasolParameters`](crate::model::ExasolParameters).
    pub fn builder() -> crate::model::exasol_parameters::Builder {
        crate::model::exasol_parameters::Builder::default()
    }
}

/// <p>The parameters for OpenSearch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AmazonOpenSearchParameters {
    /// <p>The OpenSearch domain.</p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
}
impl AmazonOpenSearchParameters {
    /// <p>The OpenSearch domain.</p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
}
/// See [`AmazonOpenSearchParameters`](crate::model::AmazonOpenSearchParameters).
pub mod amazon_open_search_parameters {

    /// A builder for [`AmazonOpenSearchParameters`](crate::model::AmazonOpenSearchParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The OpenSearch domain.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The OpenSearch domain.</p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// Consumes the builder and constructs a [`AmazonOpenSearchParameters`](crate::model::AmazonOpenSearchParameters).
        pub fn build(self) -> crate::model::AmazonOpenSearchParameters {
            crate::model::AmazonOpenSearchParameters {
                domain: self.domain,
            }
        }
    }
}
impl AmazonOpenSearchParameters {
    /// Creates a new builder-style object to manufacture [`AmazonOpenSearchParameters`](crate::model::AmazonOpenSearchParameters).
    pub fn builder() -> crate::model::amazon_open_search_parameters::Builder {
        crate::model::amazon_open_search_parameters::Builder::default()
    }
}

/// <p>The parameters for Twitter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TwitterParameters {
    /// <p>Twitter query string.</p>
    #[doc(hidden)]
    pub query: std::option::Option<std::string::String>,
    /// <p>Maximum number of rows to query Twitter.</p>
    #[doc(hidden)]
    pub max_rows: i32,
}
impl TwitterParameters {
    /// <p>Twitter query string.</p>
    pub fn query(&self) -> std::option::Option<&str> {
        self.query.as_deref()
    }
    /// <p>Maximum number of rows to query Twitter.</p>
    pub fn max_rows(&self) -> i32 {
        self.max_rows
    }
}
/// See [`TwitterParameters`](crate::model::TwitterParameters).
pub mod twitter_parameters {

    /// A builder for [`TwitterParameters`](crate::model::TwitterParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) query: std::option::Option<std::string::String>,
        pub(crate) max_rows: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Twitter query string.</p>
        pub fn query(mut self, input: impl Into<std::string::String>) -> Self {
            self.query = Some(input.into());
            self
        }
        /// <p>Twitter query string.</p>
        pub fn set_query(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query = input;
            self
        }
        /// <p>Maximum number of rows to query Twitter.</p>
        pub fn max_rows(mut self, input: i32) -> Self {
            self.max_rows = Some(input);
            self
        }
        /// <p>Maximum number of rows to query Twitter.</p>
        pub fn set_max_rows(mut self, input: std::option::Option<i32>) -> Self {
            self.max_rows = input;
            self
        }
        /// Consumes the builder and constructs a [`TwitterParameters`](crate::model::TwitterParameters).
        pub fn build(self) -> crate::model::TwitterParameters {
            crate::model::TwitterParameters {
                query: self.query,
                max_rows: self.max_rows.unwrap_or_default(),
            }
        }
    }
}
impl TwitterParameters {
    /// Creates a new builder-style object to manufacture [`TwitterParameters`](crate::model::TwitterParameters).
    pub fn builder() -> crate::model::twitter_parameters::Builder {
        crate::model::twitter_parameters::Builder::default()
    }
}

/// <p>The parameters for Teradata.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TeradataParameters {
    /// <p>Host.</p>
    #[doc(hidden)]
    pub host: std::option::Option<std::string::String>,
    /// <p>Port.</p>
    #[doc(hidden)]
    pub port: i32,
    /// <p>Database.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
}
impl TeradataParameters {
    /// <p>Host.</p>
    pub fn host(&self) -> std::option::Option<&str> {
        self.host.as_deref()
    }
    /// <p>Port.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
    /// <p>Database.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
}
/// See [`TeradataParameters`](crate::model::TeradataParameters).
pub mod teradata_parameters {

    /// A builder for [`TeradataParameters`](crate::model::TeradataParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) database: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Host.</p>
        pub fn host(mut self, input: impl Into<std::string::String>) -> Self {
            self.host = Some(input.into());
            self
        }
        /// <p>Host.</p>
        pub fn set_host(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host = input;
            self
        }
        /// <p>Port.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>Port.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>Database.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>Database.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// Consumes the builder and constructs a [`TeradataParameters`](crate::model::TeradataParameters).
        pub fn build(self) -> crate::model::TeradataParameters {
            crate::model::TeradataParameters {
                host: self.host,
                port: self.port.unwrap_or_default(),
                database: self.database,
            }
        }
    }
}
impl TeradataParameters {
    /// Creates a new builder-style object to manufacture [`TeradataParameters`](crate::model::TeradataParameters).
    pub fn builder() -> crate::model::teradata_parameters::Builder {
        crate::model::teradata_parameters::Builder::default()
    }
}

/// <p>The parameters for SQL Server.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SqlServerParameters {
    /// <p>Host.</p>
    #[doc(hidden)]
    pub host: std::option::Option<std::string::String>,
    /// <p>Port.</p>
    #[doc(hidden)]
    pub port: i32,
    /// <p>Database.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
}
impl SqlServerParameters {
    /// <p>Host.</p>
    pub fn host(&self) -> std::option::Option<&str> {
        self.host.as_deref()
    }
    /// <p>Port.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
    /// <p>Database.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
}
/// See [`SqlServerParameters`](crate::model::SqlServerParameters).
pub mod sql_server_parameters {

    /// A builder for [`SqlServerParameters`](crate::model::SqlServerParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) database: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Host.</p>
        pub fn host(mut self, input: impl Into<std::string::String>) -> Self {
            self.host = Some(input.into());
            self
        }
        /// <p>Host.</p>
        pub fn set_host(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host = input;
            self
        }
        /// <p>Port.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>Port.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>Database.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>Database.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// Consumes the builder and constructs a [`SqlServerParameters`](crate::model::SqlServerParameters).
        pub fn build(self) -> crate::model::SqlServerParameters {
            crate::model::SqlServerParameters {
                host: self.host,
                port: self.port.unwrap_or_default(),
                database: self.database,
            }
        }
    }
}
impl SqlServerParameters {
    /// Creates a new builder-style object to manufacture [`SqlServerParameters`](crate::model::SqlServerParameters).
    pub fn builder() -> crate::model::sql_server_parameters::Builder {
        crate::model::sql_server_parameters::Builder::default()
    }
}

/// <p>The parameters for Spark.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SparkParameters {
    /// <p>Host.</p>
    #[doc(hidden)]
    pub host: std::option::Option<std::string::String>,
    /// <p>Port.</p>
    #[doc(hidden)]
    pub port: i32,
}
impl SparkParameters {
    /// <p>Host.</p>
    pub fn host(&self) -> std::option::Option<&str> {
        self.host.as_deref()
    }
    /// <p>Port.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
}
/// See [`SparkParameters`](crate::model::SparkParameters).
pub mod spark_parameters {

    /// A builder for [`SparkParameters`](crate::model::SparkParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Host.</p>
        pub fn host(mut self, input: impl Into<std::string::String>) -> Self {
            self.host = Some(input.into());
            self
        }
        /// <p>Host.</p>
        pub fn set_host(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host = input;
            self
        }
        /// <p>Port.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>Port.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// Consumes the builder and constructs a [`SparkParameters`](crate::model::SparkParameters).
        pub fn build(self) -> crate::model::SparkParameters {
            crate::model::SparkParameters {
                host: self.host,
                port: self.port.unwrap_or_default(),
            }
        }
    }
}
impl SparkParameters {
    /// Creates a new builder-style object to manufacture [`SparkParameters`](crate::model::SparkParameters).
    pub fn builder() -> crate::model::spark_parameters::Builder {
        crate::model::spark_parameters::Builder::default()
    }
}

/// <p>The parameters for Snowflake.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnowflakeParameters {
    /// <p>Host.</p>
    #[doc(hidden)]
    pub host: std::option::Option<std::string::String>,
    /// <p>Database.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>Warehouse.</p>
    #[doc(hidden)]
    pub warehouse: std::option::Option<std::string::String>,
}
impl SnowflakeParameters {
    /// <p>Host.</p>
    pub fn host(&self) -> std::option::Option<&str> {
        self.host.as_deref()
    }
    /// <p>Database.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>Warehouse.</p>
    pub fn warehouse(&self) -> std::option::Option<&str> {
        self.warehouse.as_deref()
    }
}
/// See [`SnowflakeParameters`](crate::model::SnowflakeParameters).
pub mod snowflake_parameters {

    /// A builder for [`SnowflakeParameters`](crate::model::SnowflakeParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) warehouse: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Host.</p>
        pub fn host(mut self, input: impl Into<std::string::String>) -> Self {
            self.host = Some(input.into());
            self
        }
        /// <p>Host.</p>
        pub fn set_host(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host = input;
            self
        }
        /// <p>Database.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>Database.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>Warehouse.</p>
        pub fn warehouse(mut self, input: impl Into<std::string::String>) -> Self {
            self.warehouse = Some(input.into());
            self
        }
        /// <p>Warehouse.</p>
        pub fn set_warehouse(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.warehouse = input;
            self
        }
        /// Consumes the builder and constructs a [`SnowflakeParameters`](crate::model::SnowflakeParameters).
        pub fn build(self) -> crate::model::SnowflakeParameters {
            crate::model::SnowflakeParameters {
                host: self.host,
                database: self.database,
                warehouse: self.warehouse,
            }
        }
    }
}
impl SnowflakeParameters {
    /// Creates a new builder-style object to manufacture [`SnowflakeParameters`](crate::model::SnowflakeParameters).
    pub fn builder() -> crate::model::snowflake_parameters::Builder {
        crate::model::snowflake_parameters::Builder::default()
    }
}

/// <p>The parameters for ServiceNow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceNowParameters {
    /// <p>URL of the base site.</p>
    #[doc(hidden)]
    pub site_base_url: std::option::Option<std::string::String>,
}
impl ServiceNowParameters {
    /// <p>URL of the base site.</p>
    pub fn site_base_url(&self) -> std::option::Option<&str> {
        self.site_base_url.as_deref()
    }
}
/// See [`ServiceNowParameters`](crate::model::ServiceNowParameters).
pub mod service_now_parameters {

    /// A builder for [`ServiceNowParameters`](crate::model::ServiceNowParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) site_base_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>URL of the base site.</p>
        pub fn site_base_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_base_url = Some(input.into());
            self
        }
        /// <p>URL of the base site.</p>
        pub fn set_site_base_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.site_base_url = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceNowParameters`](crate::model::ServiceNowParameters).
        pub fn build(self) -> crate::model::ServiceNowParameters {
            crate::model::ServiceNowParameters {
                site_base_url: self.site_base_url,
            }
        }
    }
}
impl ServiceNowParameters {
    /// Creates a new builder-style object to manufacture [`ServiceNowParameters`](crate::model::ServiceNowParameters).
    pub fn builder() -> crate::model::service_now_parameters::Builder {
        crate::model::service_now_parameters::Builder::default()
    }
}

/// <p>The parameters for S3.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3Parameters {
    /// <p>Location of the Amazon S3 manifest file. This is NULL if the manifest file was uploaded into Amazon QuickSight.</p>
    #[doc(hidden)]
    pub manifest_file_location: std::option::Option<crate::model::ManifestFileLocation>,
}
impl S3Parameters {
    /// <p>Location of the Amazon S3 manifest file. This is NULL if the manifest file was uploaded into Amazon QuickSight.</p>
    pub fn manifest_file_location(
        &self,
    ) -> std::option::Option<&crate::model::ManifestFileLocation> {
        self.manifest_file_location.as_ref()
    }
}
/// See [`S3Parameters`](crate::model::S3Parameters).
pub mod s3_parameters {

    /// A builder for [`S3Parameters`](crate::model::S3Parameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) manifest_file_location: std::option::Option<crate::model::ManifestFileLocation>,
    }
    impl Builder {
        /// <p>Location of the Amazon S3 manifest file. This is NULL if the manifest file was uploaded into Amazon QuickSight.</p>
        pub fn manifest_file_location(mut self, input: crate::model::ManifestFileLocation) -> Self {
            self.manifest_file_location = Some(input);
            self
        }
        /// <p>Location of the Amazon S3 manifest file. This is NULL if the manifest file was uploaded into Amazon QuickSight.</p>
        pub fn set_manifest_file_location(
            mut self,
            input: std::option::Option<crate::model::ManifestFileLocation>,
        ) -> Self {
            self.manifest_file_location = input;
            self
        }
        /// Consumes the builder and constructs a [`S3Parameters`](crate::model::S3Parameters).
        pub fn build(self) -> crate::model::S3Parameters {
            crate::model::S3Parameters {
                manifest_file_location: self.manifest_file_location,
            }
        }
    }
}
impl S3Parameters {
    /// Creates a new builder-style object to manufacture [`S3Parameters`](crate::model::S3Parameters).
    pub fn builder() -> crate::model::s3_parameters::Builder {
        crate::model::s3_parameters::Builder::default()
    }
}

/// <p>Amazon S3 manifest file location.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ManifestFileLocation {
    /// <p>Amazon S3 bucket.</p>
    #[doc(hidden)]
    pub bucket: std::option::Option<std::string::String>,
    /// <p>Amazon S3 key that identifies an object.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
}
impl ManifestFileLocation {
    /// <p>Amazon S3 bucket.</p>
    pub fn bucket(&self) -> std::option::Option<&str> {
        self.bucket.as_deref()
    }
    /// <p>Amazon S3 key that identifies an object.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
}
/// See [`ManifestFileLocation`](crate::model::ManifestFileLocation).
pub mod manifest_file_location {

    /// A builder for [`ManifestFileLocation`](crate::model::ManifestFileLocation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Amazon S3 bucket.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        /// <p>Amazon S3 bucket.</p>
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>Amazon S3 key that identifies an object.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>Amazon S3 key that identifies an object.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// Consumes the builder and constructs a [`ManifestFileLocation`](crate::model::ManifestFileLocation).
        pub fn build(self) -> crate::model::ManifestFileLocation {
            crate::model::ManifestFileLocation {
                bucket: self.bucket,
                key: self.key,
            }
        }
    }
}
impl ManifestFileLocation {
    /// Creates a new builder-style object to manufacture [`ManifestFileLocation`](crate::model::ManifestFileLocation).
    pub fn builder() -> crate::model::manifest_file_location::Builder {
        crate::model::manifest_file_location::Builder::default()
    }
}

/// <p>The parameters for Amazon Redshift. The <code>ClusterId</code> field can be blank if <code>Host</code> and <code>Port</code> are both set. The <code>Host</code> and <code>Port</code> fields can be blank if the <code>ClusterId</code> field is set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RedshiftParameters {
    /// <p>Host. This field can be blank if <code>ClusterId</code> is provided.</p>
    #[doc(hidden)]
    pub host: std::option::Option<std::string::String>,
    /// <p>Port. This field can be blank if the <code>ClusterId</code> is provided.</p>
    #[doc(hidden)]
    pub port: i32,
    /// <p>Database.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
    /// <p>Cluster ID. This field can be blank if the <code>Host</code> and <code>Port</code> are provided.</p>
    #[doc(hidden)]
    pub cluster_id: std::option::Option<std::string::String>,
}
impl RedshiftParameters {
    /// <p>Host. This field can be blank if <code>ClusterId</code> is provided.</p>
    pub fn host(&self) -> std::option::Option<&str> {
        self.host.as_deref()
    }
    /// <p>Port. This field can be blank if the <code>ClusterId</code> is provided.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
    /// <p>Database.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>Cluster ID. This field can be blank if the <code>Host</code> and <code>Port</code> are provided.</p>
    pub fn cluster_id(&self) -> std::option::Option<&str> {
        self.cluster_id.as_deref()
    }
}
/// See [`RedshiftParameters`](crate::model::RedshiftParameters).
pub mod redshift_parameters {

    /// A builder for [`RedshiftParameters`](crate::model::RedshiftParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) cluster_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Host. This field can be blank if <code>ClusterId</code> is provided.</p>
        pub fn host(mut self, input: impl Into<std::string::String>) -> Self {
            self.host = Some(input.into());
            self
        }
        /// <p>Host. This field can be blank if <code>ClusterId</code> is provided.</p>
        pub fn set_host(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host = input;
            self
        }
        /// <p>Port. This field can be blank if the <code>ClusterId</code> is provided.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>Port. This field can be blank if the <code>ClusterId</code> is provided.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>Database.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>Database.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>Cluster ID. This field can be blank if the <code>Host</code> and <code>Port</code> are provided.</p>
        pub fn cluster_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_id = Some(input.into());
            self
        }
        /// <p>Cluster ID. This field can be blank if the <code>Host</code> and <code>Port</code> are provided.</p>
        pub fn set_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RedshiftParameters`](crate::model::RedshiftParameters).
        pub fn build(self) -> crate::model::RedshiftParameters {
            crate::model::RedshiftParameters {
                host: self.host,
                port: self.port.unwrap_or_default(),
                database: self.database,
                cluster_id: self.cluster_id,
            }
        }
    }
}
impl RedshiftParameters {
    /// Creates a new builder-style object to manufacture [`RedshiftParameters`](crate::model::RedshiftParameters).
    pub fn builder() -> crate::model::redshift_parameters::Builder {
        crate::model::redshift_parameters::Builder::default()
    }
}

/// <p>The parameters for Amazon RDS.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RdsParameters {
    /// <p>Instance ID.</p>
    #[doc(hidden)]
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>Database.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
}
impl RdsParameters {
    /// <p>Instance ID.</p>
    pub fn instance_id(&self) -> std::option::Option<&str> {
        self.instance_id.as_deref()
    }
    /// <p>Database.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
}
/// See [`RdsParameters`](crate::model::RdsParameters).
pub mod rds_parameters {

    /// A builder for [`RdsParameters`](crate::model::RdsParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Instance ID.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        /// <p>Instance ID.</p>
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>Database.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>Database.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// Consumes the builder and constructs a [`RdsParameters`](crate::model::RdsParameters).
        pub fn build(self) -> crate::model::RdsParameters {
            crate::model::RdsParameters {
                instance_id: self.instance_id,
                database: self.database,
            }
        }
    }
}
impl RdsParameters {
    /// Creates a new builder-style object to manufacture [`RdsParameters`](crate::model::RdsParameters).
    pub fn builder() -> crate::model::rds_parameters::Builder {
        crate::model::rds_parameters::Builder::default()
    }
}

/// <p>The parameters for Presto.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PrestoParameters {
    /// <p>Host.</p>
    #[doc(hidden)]
    pub host: std::option::Option<std::string::String>,
    /// <p>Port.</p>
    #[doc(hidden)]
    pub port: i32,
    /// <p>Catalog.</p>
    #[doc(hidden)]
    pub catalog: std::option::Option<std::string::String>,
}
impl PrestoParameters {
    /// <p>Host.</p>
    pub fn host(&self) -> std::option::Option<&str> {
        self.host.as_deref()
    }
    /// <p>Port.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
    /// <p>Catalog.</p>
    pub fn catalog(&self) -> std::option::Option<&str> {
        self.catalog.as_deref()
    }
}
/// See [`PrestoParameters`](crate::model::PrestoParameters).
pub mod presto_parameters {

    /// A builder for [`PrestoParameters`](crate::model::PrestoParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) catalog: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Host.</p>
        pub fn host(mut self, input: impl Into<std::string::String>) -> Self {
            self.host = Some(input.into());
            self
        }
        /// <p>Host.</p>
        pub fn set_host(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host = input;
            self
        }
        /// <p>Port.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>Port.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>Catalog.</p>
        pub fn catalog(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog = Some(input.into());
            self
        }
        /// <p>Catalog.</p>
        pub fn set_catalog(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog = input;
            self
        }
        /// Consumes the builder and constructs a [`PrestoParameters`](crate::model::PrestoParameters).
        pub fn build(self) -> crate::model::PrestoParameters {
            crate::model::PrestoParameters {
                host: self.host,
                port: self.port.unwrap_or_default(),
                catalog: self.catalog,
            }
        }
    }
}
impl PrestoParameters {
    /// Creates a new builder-style object to manufacture [`PrestoParameters`](crate::model::PrestoParameters).
    pub fn builder() -> crate::model::presto_parameters::Builder {
        crate::model::presto_parameters::Builder::default()
    }
}

/// <p>The parameters for PostgreSQL.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PostgreSqlParameters {
    /// <p>Host.</p>
    #[doc(hidden)]
    pub host: std::option::Option<std::string::String>,
    /// <p>Port.</p>
    #[doc(hidden)]
    pub port: i32,
    /// <p>Database.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
}
impl PostgreSqlParameters {
    /// <p>Host.</p>
    pub fn host(&self) -> std::option::Option<&str> {
        self.host.as_deref()
    }
    /// <p>Port.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
    /// <p>Database.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
}
/// See [`PostgreSqlParameters`](crate::model::PostgreSqlParameters).
pub mod postgre_sql_parameters {

    /// A builder for [`PostgreSqlParameters`](crate::model::PostgreSqlParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) database: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Host.</p>
        pub fn host(mut self, input: impl Into<std::string::String>) -> Self {
            self.host = Some(input.into());
            self
        }
        /// <p>Host.</p>
        pub fn set_host(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host = input;
            self
        }
        /// <p>Port.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>Port.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>Database.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>Database.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// Consumes the builder and constructs a [`PostgreSqlParameters`](crate::model::PostgreSqlParameters).
        pub fn build(self) -> crate::model::PostgreSqlParameters {
            crate::model::PostgreSqlParameters {
                host: self.host,
                port: self.port.unwrap_or_default(),
                database: self.database,
            }
        }
    }
}
impl PostgreSqlParameters {
    /// Creates a new builder-style object to manufacture [`PostgreSqlParameters`](crate::model::PostgreSqlParameters).
    pub fn builder() -> crate::model::postgre_sql_parameters::Builder {
        crate::model::postgre_sql_parameters::Builder::default()
    }
}

/// <p>The parameters for Oracle.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OracleParameters {
    /// <p>An Oracle host.</p>
    #[doc(hidden)]
    pub host: std::option::Option<std::string::String>,
    /// <p>Port.</p>
    #[doc(hidden)]
    pub port: i32,
    /// <p>Database.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
}
impl OracleParameters {
    /// <p>An Oracle host.</p>
    pub fn host(&self) -> std::option::Option<&str> {
        self.host.as_deref()
    }
    /// <p>Port.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
    /// <p>Database.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
}
/// See [`OracleParameters`](crate::model::OracleParameters).
pub mod oracle_parameters {

    /// A builder for [`OracleParameters`](crate::model::OracleParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) database: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An Oracle host.</p>
        pub fn host(mut self, input: impl Into<std::string::String>) -> Self {
            self.host = Some(input.into());
            self
        }
        /// <p>An Oracle host.</p>
        pub fn set_host(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host = input;
            self
        }
        /// <p>Port.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>Port.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>Database.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>Database.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// Consumes the builder and constructs a [`OracleParameters`](crate::model::OracleParameters).
        pub fn build(self) -> crate::model::OracleParameters {
            crate::model::OracleParameters {
                host: self.host,
                port: self.port.unwrap_or_default(),
                database: self.database,
            }
        }
    }
}
impl OracleParameters {
    /// Creates a new builder-style object to manufacture [`OracleParameters`](crate::model::OracleParameters).
    pub fn builder() -> crate::model::oracle_parameters::Builder {
        crate::model::oracle_parameters::Builder::default()
    }
}

/// <p>The parameters for MySQL.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MySqlParameters {
    /// <p>Host.</p>
    #[doc(hidden)]
    pub host: std::option::Option<std::string::String>,
    /// <p>Port.</p>
    #[doc(hidden)]
    pub port: i32,
    /// <p>Database.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
}
impl MySqlParameters {
    /// <p>Host.</p>
    pub fn host(&self) -> std::option::Option<&str> {
        self.host.as_deref()
    }
    /// <p>Port.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
    /// <p>Database.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
}
/// See [`MySqlParameters`](crate::model::MySqlParameters).
pub mod my_sql_parameters {

    /// A builder for [`MySqlParameters`](crate::model::MySqlParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) database: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Host.</p>
        pub fn host(mut self, input: impl Into<std::string::String>) -> Self {
            self.host = Some(input.into());
            self
        }
        /// <p>Host.</p>
        pub fn set_host(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host = input;
            self
        }
        /// <p>Port.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>Port.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>Database.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>Database.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// Consumes the builder and constructs a [`MySqlParameters`](crate::model::MySqlParameters).
        pub fn build(self) -> crate::model::MySqlParameters {
            crate::model::MySqlParameters {
                host: self.host,
                port: self.port.unwrap_or_default(),
                database: self.database,
            }
        }
    }
}
impl MySqlParameters {
    /// Creates a new builder-style object to manufacture [`MySqlParameters`](crate::model::MySqlParameters).
    pub fn builder() -> crate::model::my_sql_parameters::Builder {
        crate::model::my_sql_parameters::Builder::default()
    }
}

/// <p>The parameters for MariaDB.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MariaDbParameters {
    /// <p>Host.</p>
    #[doc(hidden)]
    pub host: std::option::Option<std::string::String>,
    /// <p>Port.</p>
    #[doc(hidden)]
    pub port: i32,
    /// <p>Database.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
}
impl MariaDbParameters {
    /// <p>Host.</p>
    pub fn host(&self) -> std::option::Option<&str> {
        self.host.as_deref()
    }
    /// <p>Port.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
    /// <p>Database.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
}
/// See [`MariaDbParameters`](crate::model::MariaDbParameters).
pub mod maria_db_parameters {

    /// A builder for [`MariaDbParameters`](crate::model::MariaDbParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) database: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Host.</p>
        pub fn host(mut self, input: impl Into<std::string::String>) -> Self {
            self.host = Some(input.into());
            self
        }
        /// <p>Host.</p>
        pub fn set_host(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host = input;
            self
        }
        /// <p>Port.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>Port.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>Database.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>Database.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// Consumes the builder and constructs a [`MariaDbParameters`](crate::model::MariaDbParameters).
        pub fn build(self) -> crate::model::MariaDbParameters {
            crate::model::MariaDbParameters {
                host: self.host,
                port: self.port.unwrap_or_default(),
                database: self.database,
            }
        }
    }
}
impl MariaDbParameters {
    /// Creates a new builder-style object to manufacture [`MariaDbParameters`](crate::model::MariaDbParameters).
    pub fn builder() -> crate::model::maria_db_parameters::Builder {
        crate::model::maria_db_parameters::Builder::default()
    }
}

/// <p>The parameters for Jira.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JiraParameters {
    /// <p>The base URL of the Jira site.</p>
    #[doc(hidden)]
    pub site_base_url: std::option::Option<std::string::String>,
}
impl JiraParameters {
    /// <p>The base URL of the Jira site.</p>
    pub fn site_base_url(&self) -> std::option::Option<&str> {
        self.site_base_url.as_deref()
    }
}
/// See [`JiraParameters`](crate::model::JiraParameters).
pub mod jira_parameters {

    /// A builder for [`JiraParameters`](crate::model::JiraParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) site_base_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The base URL of the Jira site.</p>
        pub fn site_base_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_base_url = Some(input.into());
            self
        }
        /// <p>The base URL of the Jira site.</p>
        pub fn set_site_base_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.site_base_url = input;
            self
        }
        /// Consumes the builder and constructs a [`JiraParameters`](crate::model::JiraParameters).
        pub fn build(self) -> crate::model::JiraParameters {
            crate::model::JiraParameters {
                site_base_url: self.site_base_url,
            }
        }
    }
}
impl JiraParameters {
    /// Creates a new builder-style object to manufacture [`JiraParameters`](crate::model::JiraParameters).
    pub fn builder() -> crate::model::jira_parameters::Builder {
        crate::model::jira_parameters::Builder::default()
    }
}

/// <p>The parameters for IoT Analytics.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AwsIotAnalyticsParameters {
    /// <p>Dataset name.</p>
    #[doc(hidden)]
    pub data_set_name: std::option::Option<std::string::String>,
}
impl AwsIotAnalyticsParameters {
    /// <p>Dataset name.</p>
    pub fn data_set_name(&self) -> std::option::Option<&str> {
        self.data_set_name.as_deref()
    }
}
/// See [`AwsIotAnalyticsParameters`](crate::model::AwsIotAnalyticsParameters).
pub mod aws_iot_analytics_parameters {

    /// A builder for [`AwsIotAnalyticsParameters`](crate::model::AwsIotAnalyticsParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_set_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Dataset name.</p>
        pub fn data_set_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_set_name = Some(input.into());
            self
        }
        /// <p>Dataset name.</p>
        pub fn set_data_set_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_set_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsIotAnalyticsParameters`](crate::model::AwsIotAnalyticsParameters).
        pub fn build(self) -> crate::model::AwsIotAnalyticsParameters {
            crate::model::AwsIotAnalyticsParameters {
                data_set_name: self.data_set_name,
            }
        }
    }
}
impl AwsIotAnalyticsParameters {
    /// Creates a new builder-style object to manufacture [`AwsIotAnalyticsParameters`](crate::model::AwsIotAnalyticsParameters).
    pub fn builder() -> crate::model::aws_iot_analytics_parameters::Builder {
        crate::model::aws_iot_analytics_parameters::Builder::default()
    }
}

/// <p>Parameters for Amazon Aurora PostgreSQL-Compatible Edition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AuroraPostgreSqlParameters {
    /// <p>The Amazon Aurora PostgreSQL-Compatible host to connect to.</p>
    #[doc(hidden)]
    pub host: std::option::Option<std::string::String>,
    /// <p>The port that Amazon Aurora PostgreSQL is listening on.</p>
    #[doc(hidden)]
    pub port: i32,
    /// <p>The Amazon Aurora PostgreSQL database to connect to.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
}
impl AuroraPostgreSqlParameters {
    /// <p>The Amazon Aurora PostgreSQL-Compatible host to connect to.</p>
    pub fn host(&self) -> std::option::Option<&str> {
        self.host.as_deref()
    }
    /// <p>The port that Amazon Aurora PostgreSQL is listening on.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
    /// <p>The Amazon Aurora PostgreSQL database to connect to.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
}
/// See [`AuroraPostgreSqlParameters`](crate::model::AuroraPostgreSqlParameters).
pub mod aurora_postgre_sql_parameters {

    /// A builder for [`AuroraPostgreSqlParameters`](crate::model::AuroraPostgreSqlParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) database: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Aurora PostgreSQL-Compatible host to connect to.</p>
        pub fn host(mut self, input: impl Into<std::string::String>) -> Self {
            self.host = Some(input.into());
            self
        }
        /// <p>The Amazon Aurora PostgreSQL-Compatible host to connect to.</p>
        pub fn set_host(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host = input;
            self
        }
        /// <p>The port that Amazon Aurora PostgreSQL is listening on.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The port that Amazon Aurora PostgreSQL is listening on.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>The Amazon Aurora PostgreSQL database to connect to.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>The Amazon Aurora PostgreSQL database to connect to.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// Consumes the builder and constructs a [`AuroraPostgreSqlParameters`](crate::model::AuroraPostgreSqlParameters).
        pub fn build(self) -> crate::model::AuroraPostgreSqlParameters {
            crate::model::AuroraPostgreSqlParameters {
                host: self.host,
                port: self.port.unwrap_or_default(),
                database: self.database,
            }
        }
    }
}
impl AuroraPostgreSqlParameters {
    /// Creates a new builder-style object to manufacture [`AuroraPostgreSqlParameters`](crate::model::AuroraPostgreSqlParameters).
    pub fn builder() -> crate::model::aurora_postgre_sql_parameters::Builder {
        crate::model::aurora_postgre_sql_parameters::Builder::default()
    }
}

/// <p>Parameters for Amazon Aurora.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AuroraParameters {
    /// <p>Host.</p>
    #[doc(hidden)]
    pub host: std::option::Option<std::string::String>,
    /// <p>Port.</p>
    #[doc(hidden)]
    pub port: i32,
    /// <p>Database.</p>
    #[doc(hidden)]
    pub database: std::option::Option<std::string::String>,
}
impl AuroraParameters {
    /// <p>Host.</p>
    pub fn host(&self) -> std::option::Option<&str> {
        self.host.as_deref()
    }
    /// <p>Port.</p>
    pub fn port(&self) -> i32 {
        self.port
    }
    /// <p>Database.</p>
    pub fn database(&self) -> std::option::Option<&str> {
        self.database.as_deref()
    }
}
/// See [`AuroraParameters`](crate::model::AuroraParameters).
pub mod aurora_parameters {

    /// A builder for [`AuroraParameters`](crate::model::AuroraParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) database: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Host.</p>
        pub fn host(mut self, input: impl Into<std::string::String>) -> Self {
            self.host = Some(input.into());
            self
        }
        /// <p>Host.</p>
        pub fn set_host(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host = input;
            self
        }
        /// <p>Port.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>Port.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>Database.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        /// <p>Database.</p>
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// Consumes the builder and constructs a [`AuroraParameters`](crate::model::AuroraParameters).
        pub fn build(self) -> crate::model::AuroraParameters {
            crate::model::AuroraParameters {
                host: self.host,
                port: self.port.unwrap_or_default(),
                database: self.database,
            }
        }
    }
}
impl AuroraParameters {
    /// Creates a new builder-style object to manufacture [`AuroraParameters`](crate::model::AuroraParameters).
    pub fn builder() -> crate::model::aurora_parameters::Builder {
        crate::model::aurora_parameters::Builder::default()
    }
}

/// <p>Parameters for Amazon Athena.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AthenaParameters {
    /// <p>The workgroup that Amazon Athena uses.</p>
    #[doc(hidden)]
    pub work_group: std::option::Option<std::string::String>,
    /// <p>Use the <code>RoleArn</code> structure to override an account-wide role for a specific Athena data source. For example, say an account administrator has turned off all Athena access with an account-wide role. The administrator can then use <code>RoleArn</code> to bypass the account-wide role and allow Athena access for the single Athena data source that is specified in the structure, even if the account-wide role forbidding Athena access is still active.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
}
impl AthenaParameters {
    /// <p>The workgroup that Amazon Athena uses.</p>
    pub fn work_group(&self) -> std::option::Option<&str> {
        self.work_group.as_deref()
    }
    /// <p>Use the <code>RoleArn</code> structure to override an account-wide role for a specific Athena data source. For example, say an account administrator has turned off all Athena access with an account-wide role. The administrator can then use <code>RoleArn</code> to bypass the account-wide role and allow Athena access for the single Athena data source that is specified in the structure, even if the account-wide role forbidding Athena access is still active.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
/// See [`AthenaParameters`](crate::model::AthenaParameters).
pub mod athena_parameters {

    /// A builder for [`AthenaParameters`](crate::model::AthenaParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) work_group: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The workgroup that Amazon Athena uses.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.work_group = Some(input.into());
            self
        }
        /// <p>The workgroup that Amazon Athena uses.</p>
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.work_group = input;
            self
        }
        /// <p>Use the <code>RoleArn</code> structure to override an account-wide role for a specific Athena data source. For example, say an account administrator has turned off all Athena access with an account-wide role. The administrator can then use <code>RoleArn</code> to bypass the account-wide role and allow Athena access for the single Athena data source that is specified in the structure, even if the account-wide role forbidding Athena access is still active.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>Use the <code>RoleArn</code> structure to override an account-wide role for a specific Athena data source. For example, say an account administrator has turned off all Athena access with an account-wide role. The administrator can then use <code>RoleArn</code> to bypass the account-wide role and allow Athena access for the single Athena data source that is specified in the structure, even if the account-wide role forbidding Athena access is still active.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AthenaParameters`](crate::model::AthenaParameters).
        pub fn build(self) -> crate::model::AthenaParameters {
            crate::model::AthenaParameters {
                work_group: self.work_group,
                role_arn: self.role_arn,
            }
        }
    }
}
impl AthenaParameters {
    /// Creates a new builder-style object to manufacture [`AthenaParameters`](crate::model::AthenaParameters).
    pub fn builder() -> crate::model::athena_parameters::Builder {
        crate::model::athena_parameters::Builder::default()
    }
}

/// <p>The parameters for OpenSearch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AmazonElasticsearchParameters {
    /// <p>The OpenSearch domain.</p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
}
impl AmazonElasticsearchParameters {
    /// <p>The OpenSearch domain.</p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
}
/// See [`AmazonElasticsearchParameters`](crate::model::AmazonElasticsearchParameters).
pub mod amazon_elasticsearch_parameters {

    /// A builder for [`AmazonElasticsearchParameters`](crate::model::AmazonElasticsearchParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The OpenSearch domain.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The OpenSearch domain.</p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// Consumes the builder and constructs a [`AmazonElasticsearchParameters`](crate::model::AmazonElasticsearchParameters).
        pub fn build(self) -> crate::model::AmazonElasticsearchParameters {
            crate::model::AmazonElasticsearchParameters {
                domain: self.domain,
            }
        }
    }
}
impl AmazonElasticsearchParameters {
    /// Creates a new builder-style object to manufacture [`AmazonElasticsearchParameters`](crate::model::AmazonElasticsearchParameters).
    pub fn builder() -> crate::model::amazon_elasticsearch_parameters::Builder {
        crate::model::amazon_elasticsearch_parameters::Builder::default()
    }
}

/// <p>The usage configuration to apply to child datasets that reference this dataset as a source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSetUsageConfiguration {
    /// <p>An option that controls whether a child dataset of a direct query can use this dataset as a source.</p>
    #[doc(hidden)]
    pub disable_use_as_direct_query_source: bool,
    /// <p>An option that controls whether a child dataset that's stored in QuickSight can use this dataset as a source.</p>
    #[doc(hidden)]
    pub disable_use_as_imported_source: bool,
}
impl DataSetUsageConfiguration {
    /// <p>An option that controls whether a child dataset of a direct query can use this dataset as a source.</p>
    pub fn disable_use_as_direct_query_source(&self) -> bool {
        self.disable_use_as_direct_query_source
    }
    /// <p>An option that controls whether a child dataset that's stored in QuickSight can use this dataset as a source.</p>
    pub fn disable_use_as_imported_source(&self) -> bool {
        self.disable_use_as_imported_source
    }
}
/// See [`DataSetUsageConfiguration`](crate::model::DataSetUsageConfiguration).
pub mod data_set_usage_configuration {

    /// A builder for [`DataSetUsageConfiguration`](crate::model::DataSetUsageConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) disable_use_as_direct_query_source: std::option::Option<bool>,
        pub(crate) disable_use_as_imported_source: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>An option that controls whether a child dataset of a direct query can use this dataset as a source.</p>
        pub fn disable_use_as_direct_query_source(mut self, input: bool) -> Self {
            self.disable_use_as_direct_query_source = Some(input);
            self
        }
        /// <p>An option that controls whether a child dataset of a direct query can use this dataset as a source.</p>
        pub fn set_disable_use_as_direct_query_source(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.disable_use_as_direct_query_source = input;
            self
        }
        /// <p>An option that controls whether a child dataset that's stored in QuickSight can use this dataset as a source.</p>
        pub fn disable_use_as_imported_source(mut self, input: bool) -> Self {
            self.disable_use_as_imported_source = Some(input);
            self
        }
        /// <p>An option that controls whether a child dataset that's stored in QuickSight can use this dataset as a source.</p>
        pub fn set_disable_use_as_imported_source(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.disable_use_as_imported_source = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSetUsageConfiguration`](crate::model::DataSetUsageConfiguration).
        pub fn build(self) -> crate::model::DataSetUsageConfiguration {
            crate::model::DataSetUsageConfiguration {
                disable_use_as_direct_query_source: self
                    .disable_use_as_direct_query_source
                    .unwrap_or_default(),
                disable_use_as_imported_source: self
                    .disable_use_as_imported_source
                    .unwrap_or_default(),
            }
        }
    }
}
impl DataSetUsageConfiguration {
    /// Creates a new builder-style object to manufacture [`DataSetUsageConfiguration`](crate::model::DataSetUsageConfiguration).
    pub fn builder() -> crate::model::data_set_usage_configuration::Builder {
        crate::model::data_set_usage_configuration::Builder::default()
    }
}

/// <p>A rule defined to grant access on one or more restricted columns. Each dataset can have multiple rules. To create a restricted column, you add it to one or more rules. Each rule must contain at least one column and at least one user or group. To be able to see a restricted column, a user or group needs to be added to a rule for that column.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnLevelPermissionRule {
    /// <p>An array of Amazon Resource Names (ARNs) for Amazon QuickSight users or groups.</p>
    #[doc(hidden)]
    pub principals: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of column names.</p>
    #[doc(hidden)]
    pub column_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ColumnLevelPermissionRule {
    /// <p>An array of Amazon Resource Names (ARNs) for Amazon QuickSight users or groups.</p>
    pub fn principals(&self) -> std::option::Option<&[std::string::String]> {
        self.principals.as_deref()
    }
    /// <p>An array of column names.</p>
    pub fn column_names(&self) -> std::option::Option<&[std::string::String]> {
        self.column_names.as_deref()
    }
}
/// See [`ColumnLevelPermissionRule`](crate::model::ColumnLevelPermissionRule).
pub mod column_level_permission_rule {

    /// A builder for [`ColumnLevelPermissionRule`](crate::model::ColumnLevelPermissionRule).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) principals: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) column_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `principals`.
        ///
        /// To override the contents of this collection use [`set_principals`](Self::set_principals).
        ///
        /// <p>An array of Amazon Resource Names (ARNs) for Amazon QuickSight users or groups.</p>
        pub fn principals(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.principals.unwrap_or_default();
            v.push(input.into());
            self.principals = Some(v);
            self
        }
        /// <p>An array of Amazon Resource Names (ARNs) for Amazon QuickSight users or groups.</p>
        pub fn set_principals(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.principals = input;
            self
        }
        /// Appends an item to `column_names`.
        ///
        /// To override the contents of this collection use [`set_column_names`](Self::set_column_names).
        ///
        /// <p>An array of column names.</p>
        pub fn column_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.column_names.unwrap_or_default();
            v.push(input.into());
            self.column_names = Some(v);
            self
        }
        /// <p>An array of column names.</p>
        pub fn set_column_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.column_names = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnLevelPermissionRule`](crate::model::ColumnLevelPermissionRule).
        pub fn build(self) -> crate::model::ColumnLevelPermissionRule {
            crate::model::ColumnLevelPermissionRule {
                principals: self.principals,
                column_names: self.column_names,
            }
        }
    }
}
impl ColumnLevelPermissionRule {
    /// Creates a new builder-style object to manufacture [`ColumnLevelPermissionRule`](crate::model::ColumnLevelPermissionRule).
    pub fn builder() -> crate::model::column_level_permission_rule::Builder {
        crate::model::column_level_permission_rule::Builder::default()
    }
}

/// <p>The configuration of tags on a dataset to set row-level security. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RowLevelPermissionTagConfiguration {
    /// <p>The status of row-level security tags. If enabled, the status is <code>ENABLED</code>. If disabled, the status is <code>DISABLED</code>.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::Status>,
    /// <p>A set of rules associated with row-level security, such as the tag names and columns that they are assigned to.</p>
    #[doc(hidden)]
    pub tag_rules: std::option::Option<std::vec::Vec<crate::model::RowLevelPermissionTagRule>>,
}
impl RowLevelPermissionTagConfiguration {
    /// <p>The status of row-level security tags. If enabled, the status is <code>ENABLED</code>. If disabled, the status is <code>DISABLED</code>.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::Status> {
        self.status.as_ref()
    }
    /// <p>A set of rules associated with row-level security, such as the tag names and columns that they are assigned to.</p>
    pub fn tag_rules(&self) -> std::option::Option<&[crate::model::RowLevelPermissionTagRule]> {
        self.tag_rules.as_deref()
    }
}
/// See [`RowLevelPermissionTagConfiguration`](crate::model::RowLevelPermissionTagConfiguration).
pub mod row_level_permission_tag_configuration {

    /// A builder for [`RowLevelPermissionTagConfiguration`](crate::model::RowLevelPermissionTagConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::Status>,
        pub(crate) tag_rules:
            std::option::Option<std::vec::Vec<crate::model::RowLevelPermissionTagRule>>,
    }
    impl Builder {
        /// <p>The status of row-level security tags. If enabled, the status is <code>ENABLED</code>. If disabled, the status is <code>DISABLED</code>.</p>
        pub fn status(mut self, input: crate::model::Status) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of row-level security tags. If enabled, the status is <code>ENABLED</code>. If disabled, the status is <code>DISABLED</code>.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::Status>) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `tag_rules`.
        ///
        /// To override the contents of this collection use [`set_tag_rules`](Self::set_tag_rules).
        ///
        /// <p>A set of rules associated with row-level security, such as the tag names and columns that they are assigned to.</p>
        pub fn tag_rules(mut self, input: crate::model::RowLevelPermissionTagRule) -> Self {
            let mut v = self.tag_rules.unwrap_or_default();
            v.push(input);
            self.tag_rules = Some(v);
            self
        }
        /// <p>A set of rules associated with row-level security, such as the tag names and columns that they are assigned to.</p>
        pub fn set_tag_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RowLevelPermissionTagRule>>,
        ) -> Self {
            self.tag_rules = input;
            self
        }
        /// Consumes the builder and constructs a [`RowLevelPermissionTagConfiguration`](crate::model::RowLevelPermissionTagConfiguration).
        pub fn build(self) -> crate::model::RowLevelPermissionTagConfiguration {
            crate::model::RowLevelPermissionTagConfiguration {
                status: self.status,
                tag_rules: self.tag_rules,
            }
        }
    }
}
impl RowLevelPermissionTagConfiguration {
    /// Creates a new builder-style object to manufacture [`RowLevelPermissionTagConfiguration`](crate::model::RowLevelPermissionTagConfiguration).
    pub fn builder() -> crate::model::row_level_permission_tag_configuration::Builder {
        crate::model::row_level_permission_tag_configuration::Builder::default()
    }
}

/// <p>A set of rules associated with a tag.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RowLevelPermissionTagRule {
    /// <p>The unique key for a tag.</p>
    #[doc(hidden)]
    pub tag_key: std::option::Option<std::string::String>,
    /// <p>The column name that a tag key is assigned to.</p>
    #[doc(hidden)]
    pub column_name: std::option::Option<std::string::String>,
    /// <p>A string that you want to use to delimit the values when you pass the values at run time. For example, you can delimit the values with a comma.</p>
    #[doc(hidden)]
    pub tag_multi_value_delimiter: std::option::Option<std::string::String>,
    /// <p>A string that you want to use to filter by all the values in a column in the dataset and donâ€™t want to list the values one by one. For example, you can use an asterisk as your match all value.</p>
    #[doc(hidden)]
    pub match_all_value: std::option::Option<std::string::String>,
}
impl RowLevelPermissionTagRule {
    /// <p>The unique key for a tag.</p>
    pub fn tag_key(&self) -> std::option::Option<&str> {
        self.tag_key.as_deref()
    }
    /// <p>The column name that a tag key is assigned to.</p>
    pub fn column_name(&self) -> std::option::Option<&str> {
        self.column_name.as_deref()
    }
    /// <p>A string that you want to use to delimit the values when you pass the values at run time. For example, you can delimit the values with a comma.</p>
    pub fn tag_multi_value_delimiter(&self) -> std::option::Option<&str> {
        self.tag_multi_value_delimiter.as_deref()
    }
    /// <p>A string that you want to use to filter by all the values in a column in the dataset and donâ€™t want to list the values one by one. For example, you can use an asterisk as your match all value.</p>
    pub fn match_all_value(&self) -> std::option::Option<&str> {
        self.match_all_value.as_deref()
    }
}
impl std::fmt::Debug for RowLevelPermissionTagRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RowLevelPermissionTagRule");
        formatter.field("tag_key", &self.tag_key);
        formatter.field("column_name", &self.column_name);
        formatter.field("tag_multi_value_delimiter", &self.tag_multi_value_delimiter);
        formatter.field("match_all_value", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`RowLevelPermissionTagRule`](crate::model::RowLevelPermissionTagRule).
pub mod row_level_permission_tag_rule {

    /// A builder for [`RowLevelPermissionTagRule`](crate::model::RowLevelPermissionTagRule).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) tag_key: std::option::Option<std::string::String>,
        pub(crate) column_name: std::option::Option<std::string::String>,
        pub(crate) tag_multi_value_delimiter: std::option::Option<std::string::String>,
        pub(crate) match_all_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique key for a tag.</p>
        pub fn tag_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_key = Some(input.into());
            self
        }
        /// <p>The unique key for a tag.</p>
        pub fn set_tag_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tag_key = input;
            self
        }
        /// <p>The column name that a tag key is assigned to.</p>
        pub fn column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.column_name = Some(input.into());
            self
        }
        /// <p>The column name that a tag key is assigned to.</p>
        pub fn set_column_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.column_name = input;
            self
        }
        /// <p>A string that you want to use to delimit the values when you pass the values at run time. For example, you can delimit the values with a comma.</p>
        pub fn tag_multi_value_delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_multi_value_delimiter = Some(input.into());
            self
        }
        /// <p>A string that you want to use to delimit the values when you pass the values at run time. For example, you can delimit the values with a comma.</p>
        pub fn set_tag_multi_value_delimiter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tag_multi_value_delimiter = input;
            self
        }
        /// <p>A string that you want to use to filter by all the values in a column in the dataset and donâ€™t want to list the values one by one. For example, you can use an asterisk as your match all value.</p>
        pub fn match_all_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.match_all_value = Some(input.into());
            self
        }
        /// <p>A string that you want to use to filter by all the values in a column in the dataset and donâ€™t want to list the values one by one. For example, you can use an asterisk as your match all value.</p>
        pub fn set_match_all_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.match_all_value = input;
            self
        }
        /// Consumes the builder and constructs a [`RowLevelPermissionTagRule`](crate::model::RowLevelPermissionTagRule).
        pub fn build(self) -> crate::model::RowLevelPermissionTagRule {
            crate::model::RowLevelPermissionTagRule {
                tag_key: self.tag_key,
                column_name: self.column_name,
                tag_multi_value_delimiter: self.tag_multi_value_delimiter,
                match_all_value: self.match_all_value,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("tag_key", &self.tag_key);
            formatter.field("column_name", &self.column_name);
            formatter.field("tag_multi_value_delimiter", &self.tag_multi_value_delimiter);
            formatter.field("match_all_value", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl RowLevelPermissionTagRule {
    /// Creates a new builder-style object to manufacture [`RowLevelPermissionTagRule`](crate::model::RowLevelPermissionTagRule).
    pub fn builder() -> crate::model::row_level_permission_tag_rule::Builder {
        crate::model::row_level_permission_tag_rule::Builder::default()
    }
}

/// When writing a match expression against `Status`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let status = unimplemented!();
/// match status {
///     Status::Disabled => { /* ... */ },
///     Status::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `status` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Status::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Status::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Status::NewFeature` is defined.
/// Specifically, when `status` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Status::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Status {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Status {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => Status::Disabled,
            "ENABLED" => Status::Enabled,
            other => Status::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Status {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Status::from(s))
    }
}
impl Status {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Status::Disabled => "DISABLED",
            Status::Enabled => "ENABLED",
            Status::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for Status {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a dataset that contains permissions for row-level security (RLS). The permissions dataset maps fields to users or groups. For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/restrict-access-to-a-data-set-using-row-level-security.html">Using Row-Level Security (RLS) to Restrict Access to a Dataset</a> in the <i>Amazon QuickSight User Guide</i>.</p>
/// <p>The option to deny permissions by setting <code>PermissionPolicy</code> to <code>DENY_ACCESS</code> is not supported for new RLS datasets.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RowLevelPermissionDataSet {
    /// <p>The namespace associated with the dataset that contains permissions for RLS.</p>
    #[doc(hidden)]
    pub namespace: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the dataset that contains permissions for RLS.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The type of permissions to use when interpreting the permissions for RLS. <code>DENY_ACCESS</code> is included for backward compatibility only.</p>
    #[doc(hidden)]
    pub permission_policy: std::option::Option<crate::model::RowLevelPermissionPolicy>,
    /// <p>The user or group rules associated with the dataset that contains permissions for RLS.</p>
    /// <p>By default, <code>FormatVersion</code> is <code>VERSION_1</code>. When <code>FormatVersion</code> is <code>VERSION_1</code>, <code>UserName</code> and <code>GroupName</code> are required. When <code>FormatVersion</code> is <code>VERSION_2</code>, <code>UserARN</code> and <code>GroupARN</code> are required, and <code>Namespace</code> must not exist.</p>
    #[doc(hidden)]
    pub format_version: std::option::Option<crate::model::RowLevelPermissionFormatVersion>,
    /// <p>The status of the row-level security permission dataset. If enabled, the status is <code>ENABLED</code>. If disabled, the status is <code>DISABLED</code>.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::Status>,
}
impl RowLevelPermissionDataSet {
    /// <p>The namespace associated with the dataset that contains permissions for RLS.</p>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the dataset that contains permissions for RLS.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The type of permissions to use when interpreting the permissions for RLS. <code>DENY_ACCESS</code> is included for backward compatibility only.</p>
    pub fn permission_policy(
        &self,
    ) -> std::option::Option<&crate::model::RowLevelPermissionPolicy> {
        self.permission_policy.as_ref()
    }
    /// <p>The user or group rules associated with the dataset that contains permissions for RLS.</p>
    /// <p>By default, <code>FormatVersion</code> is <code>VERSION_1</code>. When <code>FormatVersion</code> is <code>VERSION_1</code>, <code>UserName</code> and <code>GroupName</code> are required. When <code>FormatVersion</code> is <code>VERSION_2</code>, <code>UserARN</code> and <code>GroupARN</code> are required, and <code>Namespace</code> must not exist.</p>
    pub fn format_version(
        &self,
    ) -> std::option::Option<&crate::model::RowLevelPermissionFormatVersion> {
        self.format_version.as_ref()
    }
    /// <p>The status of the row-level security permission dataset. If enabled, the status is <code>ENABLED</code>. If disabled, the status is <code>DISABLED</code>.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::Status> {
        self.status.as_ref()
    }
}
/// See [`RowLevelPermissionDataSet`](crate::model::RowLevelPermissionDataSet).
pub mod row_level_permission_data_set {

    /// A builder for [`RowLevelPermissionDataSet`](crate::model::RowLevelPermissionDataSet).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) permission_policy: std::option::Option<crate::model::RowLevelPermissionPolicy>,
        pub(crate) format_version:
            std::option::Option<crate::model::RowLevelPermissionFormatVersion>,
        pub(crate) status: std::option::Option<crate::model::Status>,
    }
    impl Builder {
        /// <p>The namespace associated with the dataset that contains permissions for RLS.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace associated with the dataset that contains permissions for RLS.</p>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the dataset that contains permissions for RLS.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the dataset that contains permissions for RLS.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The type of permissions to use when interpreting the permissions for RLS. <code>DENY_ACCESS</code> is included for backward compatibility only.</p>
        pub fn permission_policy(mut self, input: crate::model::RowLevelPermissionPolicy) -> Self {
            self.permission_policy = Some(input);
            self
        }
        /// <p>The type of permissions to use when interpreting the permissions for RLS. <code>DENY_ACCESS</code> is included for backward compatibility only.</p>
        pub fn set_permission_policy(
            mut self,
            input: std::option::Option<crate::model::RowLevelPermissionPolicy>,
        ) -> Self {
            self.permission_policy = input;
            self
        }
        /// <p>The user or group rules associated with the dataset that contains permissions for RLS.</p>
        /// <p>By default, <code>FormatVersion</code> is <code>VERSION_1</code>. When <code>FormatVersion</code> is <code>VERSION_1</code>, <code>UserName</code> and <code>GroupName</code> are required. When <code>FormatVersion</code> is <code>VERSION_2</code>, <code>UserARN</code> and <code>GroupARN</code> are required, and <code>Namespace</code> must not exist.</p>
        pub fn format_version(
            mut self,
            input: crate::model::RowLevelPermissionFormatVersion,
        ) -> Self {
            self.format_version = Some(input);
            self
        }
        /// <p>The user or group rules associated with the dataset that contains permissions for RLS.</p>
        /// <p>By default, <code>FormatVersion</code> is <code>VERSION_1</code>. When <code>FormatVersion</code> is <code>VERSION_1</code>, <code>UserName</code> and <code>GroupName</code> are required. When <code>FormatVersion</code> is <code>VERSION_2</code>, <code>UserARN</code> and <code>GroupARN</code> are required, and <code>Namespace</code> must not exist.</p>
        pub fn set_format_version(
            mut self,
            input: std::option::Option<crate::model::RowLevelPermissionFormatVersion>,
        ) -> Self {
            self.format_version = input;
            self
        }
        /// <p>The status of the row-level security permission dataset. If enabled, the status is <code>ENABLED</code>. If disabled, the status is <code>DISABLED</code>.</p>
        pub fn status(mut self, input: crate::model::Status) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the row-level security permission dataset. If enabled, the status is <code>ENABLED</code>. If disabled, the status is <code>DISABLED</code>.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::Status>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`RowLevelPermissionDataSet`](crate::model::RowLevelPermissionDataSet).
        pub fn build(self) -> crate::model::RowLevelPermissionDataSet {
            crate::model::RowLevelPermissionDataSet {
                namespace: self.namespace,
                arn: self.arn,
                permission_policy: self.permission_policy,
                format_version: self.format_version,
                status: self.status,
            }
        }
    }
}
impl RowLevelPermissionDataSet {
    /// Creates a new builder-style object to manufacture [`RowLevelPermissionDataSet`](crate::model::RowLevelPermissionDataSet).
    pub fn builder() -> crate::model::row_level_permission_data_set::Builder {
        crate::model::row_level_permission_data_set::Builder::default()
    }
}

/// When writing a match expression against `RowLevelPermissionFormatVersion`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let rowlevelpermissionformatversion = unimplemented!();
/// match rowlevelpermissionformatversion {
///     RowLevelPermissionFormatVersion::Version1 => { /* ... */ },
///     RowLevelPermissionFormatVersion::Version2 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `rowlevelpermissionformatversion` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RowLevelPermissionFormatVersion::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RowLevelPermissionFormatVersion::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RowLevelPermissionFormatVersion::NewFeature` is defined.
/// Specifically, when `rowlevelpermissionformatversion` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RowLevelPermissionFormatVersion::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RowLevelPermissionFormatVersion {
    #[allow(missing_docs)] // documentation missing in model
    Version1,
    #[allow(missing_docs)] // documentation missing in model
    Version2,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RowLevelPermissionFormatVersion {
    fn from(s: &str) -> Self {
        match s {
            "VERSION_1" => RowLevelPermissionFormatVersion::Version1,
            "VERSION_2" => RowLevelPermissionFormatVersion::Version2,
            other => RowLevelPermissionFormatVersion::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for RowLevelPermissionFormatVersion {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RowLevelPermissionFormatVersion::from(s))
    }
}
impl RowLevelPermissionFormatVersion {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RowLevelPermissionFormatVersion::Version1 => "VERSION_1",
            RowLevelPermissionFormatVersion::Version2 => "VERSION_2",
            RowLevelPermissionFormatVersion::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["VERSION_1", "VERSION_2"]
    }
}
impl AsRef<str> for RowLevelPermissionFormatVersion {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RowLevelPermissionPolicy`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let rowlevelpermissionpolicy = unimplemented!();
/// match rowlevelpermissionpolicy {
///     RowLevelPermissionPolicy::DenyAccess => { /* ... */ },
///     RowLevelPermissionPolicy::GrantAccess => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `rowlevelpermissionpolicy` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RowLevelPermissionPolicy::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RowLevelPermissionPolicy::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RowLevelPermissionPolicy::NewFeature` is defined.
/// Specifically, when `rowlevelpermissionpolicy` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RowLevelPermissionPolicy::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RowLevelPermissionPolicy {
    #[allow(missing_docs)] // documentation missing in model
    DenyAccess,
    #[allow(missing_docs)] // documentation missing in model
    GrantAccess,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RowLevelPermissionPolicy {
    fn from(s: &str) -> Self {
        match s {
            "DENY_ACCESS" => RowLevelPermissionPolicy::DenyAccess,
            "GRANT_ACCESS" => RowLevelPermissionPolicy::GrantAccess,
            other => RowLevelPermissionPolicy::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for RowLevelPermissionPolicy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RowLevelPermissionPolicy::from(s))
    }
}
impl RowLevelPermissionPolicy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RowLevelPermissionPolicy::DenyAccess => "DENY_ACCESS",
            RowLevelPermissionPolicy::GrantAccess => "GRANT_ACCESS",
            RowLevelPermissionPolicy::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DENY_ACCESS", "GRANT_ACCESS"]
    }
}
impl AsRef<str> for RowLevelPermissionPolicy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A FieldFolder element is a folder that contains fields and nested subfolders.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldFolder {
    /// <p>The description for a field folder.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>A folder has a list of columns. A column can only be in one folder.</p>
    #[doc(hidden)]
    pub columns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl FieldFolder {
    /// <p>The description for a field folder.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>A folder has a list of columns. A column can only be in one folder.</p>
    pub fn columns(&self) -> std::option::Option<&[std::string::String]> {
        self.columns.as_deref()
    }
}
/// See [`FieldFolder`](crate::model::FieldFolder).
pub mod field_folder {

    /// A builder for [`FieldFolder`](crate::model::FieldFolder).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) columns: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The description for a field folder.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description for a field folder.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `columns`.
        ///
        /// To override the contents of this collection use [`set_columns`](Self::set_columns).
        ///
        /// <p>A folder has a list of columns. A column can only be in one folder.</p>
        pub fn columns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.columns.unwrap_or_default();
            v.push(input.into());
            self.columns = Some(v);
            self
        }
        /// <p>A folder has a list of columns. A column can only be in one folder.</p>
        pub fn set_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.columns = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldFolder`](crate::model::FieldFolder).
        pub fn build(self) -> crate::model::FieldFolder {
            crate::model::FieldFolder {
                description: self.description,
                columns: self.columns,
            }
        }
    }
}
impl FieldFolder {
    /// Creates a new builder-style object to manufacture [`FieldFolder`](crate::model::FieldFolder).
    pub fn builder() -> crate::model::field_folder::Builder {
        crate::model::field_folder::Builder::default()
    }
}

/// <p>Groupings of columns that work together in certain Amazon QuickSight features. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnGroup {
    /// <p>Geospatial column group that denotes a hierarchy.</p>
    #[doc(hidden)]
    pub geo_spatial_column_group: std::option::Option<crate::model::GeoSpatialColumnGroup>,
}
impl ColumnGroup {
    /// <p>Geospatial column group that denotes a hierarchy.</p>
    pub fn geo_spatial_column_group(
        &self,
    ) -> std::option::Option<&crate::model::GeoSpatialColumnGroup> {
        self.geo_spatial_column_group.as_ref()
    }
}
/// See [`ColumnGroup`](crate::model::ColumnGroup).
pub mod column_group {

    /// A builder for [`ColumnGroup`](crate::model::ColumnGroup).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) geo_spatial_column_group:
            std::option::Option<crate::model::GeoSpatialColumnGroup>,
    }
    impl Builder {
        /// <p>Geospatial column group that denotes a hierarchy.</p>
        pub fn geo_spatial_column_group(
            mut self,
            input: crate::model::GeoSpatialColumnGroup,
        ) -> Self {
            self.geo_spatial_column_group = Some(input);
            self
        }
        /// <p>Geospatial column group that denotes a hierarchy.</p>
        pub fn set_geo_spatial_column_group(
            mut self,
            input: std::option::Option<crate::model::GeoSpatialColumnGroup>,
        ) -> Self {
            self.geo_spatial_column_group = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnGroup`](crate::model::ColumnGroup).
        pub fn build(self) -> crate::model::ColumnGroup {
            crate::model::ColumnGroup {
                geo_spatial_column_group: self.geo_spatial_column_group,
            }
        }
    }
}
impl ColumnGroup {
    /// Creates a new builder-style object to manufacture [`ColumnGroup`](crate::model::ColumnGroup).
    pub fn builder() -> crate::model::column_group::Builder {
        crate::model::column_group::Builder::default()
    }
}

/// <p>Geospatial column group that denotes a hierarchy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GeoSpatialColumnGroup {
    /// <p>A display name for the hierarchy.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Country code.</p>
    #[doc(hidden)]
    pub country_code: std::option::Option<crate::model::GeoSpatialCountryCode>,
    /// <p>Columns in this hierarchy.</p>
    #[doc(hidden)]
    pub columns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl GeoSpatialColumnGroup {
    /// <p>A display name for the hierarchy.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Country code.</p>
    pub fn country_code(&self) -> std::option::Option<&crate::model::GeoSpatialCountryCode> {
        self.country_code.as_ref()
    }
    /// <p>Columns in this hierarchy.</p>
    pub fn columns(&self) -> std::option::Option<&[std::string::String]> {
        self.columns.as_deref()
    }
}
/// See [`GeoSpatialColumnGroup`](crate::model::GeoSpatialColumnGroup).
pub mod geo_spatial_column_group {

    /// A builder for [`GeoSpatialColumnGroup`](crate::model::GeoSpatialColumnGroup).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) country_code: std::option::Option<crate::model::GeoSpatialCountryCode>,
        pub(crate) columns: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>A display name for the hierarchy.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A display name for the hierarchy.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Country code.</p>
        pub fn country_code(mut self, input: crate::model::GeoSpatialCountryCode) -> Self {
            self.country_code = Some(input);
            self
        }
        /// <p>Country code.</p>
        pub fn set_country_code(
            mut self,
            input: std::option::Option<crate::model::GeoSpatialCountryCode>,
        ) -> Self {
            self.country_code = input;
            self
        }
        /// Appends an item to `columns`.
        ///
        /// To override the contents of this collection use [`set_columns`](Self::set_columns).
        ///
        /// <p>Columns in this hierarchy.</p>
        pub fn columns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.columns.unwrap_or_default();
            v.push(input.into());
            self.columns = Some(v);
            self
        }
        /// <p>Columns in this hierarchy.</p>
        pub fn set_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.columns = input;
            self
        }
        /// Consumes the builder and constructs a [`GeoSpatialColumnGroup`](crate::model::GeoSpatialColumnGroup).
        pub fn build(self) -> crate::model::GeoSpatialColumnGroup {
            crate::model::GeoSpatialColumnGroup {
                name: self.name,
                country_code: self.country_code,
                columns: self.columns,
            }
        }
    }
}
impl GeoSpatialColumnGroup {
    /// Creates a new builder-style object to manufacture [`GeoSpatialColumnGroup`](crate::model::GeoSpatialColumnGroup).
    pub fn builder() -> crate::model::geo_spatial_column_group::Builder {
        crate::model::geo_spatial_column_group::Builder::default()
    }
}

/// When writing a match expression against `GeoSpatialCountryCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let geospatialcountrycode = unimplemented!();
/// match geospatialcountrycode {
///     GeoSpatialCountryCode::Us => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `geospatialcountrycode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `GeoSpatialCountryCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `GeoSpatialCountryCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `GeoSpatialCountryCode::NewFeature` is defined.
/// Specifically, when `geospatialcountrycode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `GeoSpatialCountryCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GeoSpatialCountryCode {
    #[allow(missing_docs)] // documentation missing in model
    Us,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for GeoSpatialCountryCode {
    fn from(s: &str) -> Self {
        match s {
            "US" => GeoSpatialCountryCode::Us,
            other => {
                GeoSpatialCountryCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for GeoSpatialCountryCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(GeoSpatialCountryCode::from(s))
    }
}
impl GeoSpatialCountryCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            GeoSpatialCountryCode::Us => "US",
            GeoSpatialCountryCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["US"]
    }
}
impl AsRef<str> for GeoSpatialCountryCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DataSetImportMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datasetimportmode = unimplemented!();
/// match datasetimportmode {
///     DataSetImportMode::DirectQuery => { /* ... */ },
///     DataSetImportMode::Spice => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datasetimportmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataSetImportMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataSetImportMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataSetImportMode::NewFeature` is defined.
/// Specifically, when `datasetimportmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataSetImportMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataSetImportMode {
    #[allow(missing_docs)] // documentation missing in model
    DirectQuery,
    #[allow(missing_docs)] // documentation missing in model
    Spice,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataSetImportMode {
    fn from(s: &str) -> Self {
        match s {
            "DIRECT_QUERY" => DataSetImportMode::DirectQuery,
            "SPICE" => DataSetImportMode::Spice,
            other => {
                DataSetImportMode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DataSetImportMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataSetImportMode::from(s))
    }
}
impl DataSetImportMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataSetImportMode::DirectQuery => "DIRECT_QUERY",
            DataSetImportMode::Spice => "SPICE",
            DataSetImportMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DIRECT_QUERY", "SPICE"]
    }
}
impl AsRef<str> for DataSetImportMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A <i>logical table</i> is a unit that joins and that data transformations operate on. A logical table has a source, which can be either a physical table or result of a join. When a logical table points to a physical table, the logical table acts as a mutable copy of that physical table through transform operations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LogicalTable {
    /// <p>A display name for the logical table.</p>
    #[doc(hidden)]
    pub alias: std::option::Option<std::string::String>,
    /// <p>Transform operations that act on this logical table. For this structure to be valid, only one of the attributes can be non-null. </p>
    #[doc(hidden)]
    pub data_transforms: std::option::Option<std::vec::Vec<crate::model::TransformOperation>>,
    /// <p>Source of this logical table.</p>
    #[doc(hidden)]
    pub source: std::option::Option<crate::model::LogicalTableSource>,
}
impl LogicalTable {
    /// <p>A display name for the logical table.</p>
    pub fn alias(&self) -> std::option::Option<&str> {
        self.alias.as_deref()
    }
    /// <p>Transform operations that act on this logical table. For this structure to be valid, only one of the attributes can be non-null. </p>
    pub fn data_transforms(&self) -> std::option::Option<&[crate::model::TransformOperation]> {
        self.data_transforms.as_deref()
    }
    /// <p>Source of this logical table.</p>
    pub fn source(&self) -> std::option::Option<&crate::model::LogicalTableSource> {
        self.source.as_ref()
    }
}
/// See [`LogicalTable`](crate::model::LogicalTable).
pub mod logical_table {

    /// A builder for [`LogicalTable`](crate::model::LogicalTable).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alias: std::option::Option<std::string::String>,
        pub(crate) data_transforms:
            std::option::Option<std::vec::Vec<crate::model::TransformOperation>>,
        pub(crate) source: std::option::Option<crate::model::LogicalTableSource>,
    }
    impl Builder {
        /// <p>A display name for the logical table.</p>
        pub fn alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias = Some(input.into());
            self
        }
        /// <p>A display name for the logical table.</p>
        pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias = input;
            self
        }
        /// Appends an item to `data_transforms`.
        ///
        /// To override the contents of this collection use [`set_data_transforms`](Self::set_data_transforms).
        ///
        /// <p>Transform operations that act on this logical table. For this structure to be valid, only one of the attributes can be non-null. </p>
        pub fn data_transforms(mut self, input: crate::model::TransformOperation) -> Self {
            let mut v = self.data_transforms.unwrap_or_default();
            v.push(input);
            self.data_transforms = Some(v);
            self
        }
        /// <p>Transform operations that act on this logical table. For this structure to be valid, only one of the attributes can be non-null. </p>
        pub fn set_data_transforms(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TransformOperation>>,
        ) -> Self {
            self.data_transforms = input;
            self
        }
        /// <p>Source of this logical table.</p>
        pub fn source(mut self, input: crate::model::LogicalTableSource) -> Self {
            self.source = Some(input);
            self
        }
        /// <p>Source of this logical table.</p>
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::LogicalTableSource>,
        ) -> Self {
            self.source = input;
            self
        }
        /// Consumes the builder and constructs a [`LogicalTable`](crate::model::LogicalTable).
        pub fn build(self) -> crate::model::LogicalTable {
            crate::model::LogicalTable {
                alias: self.alias,
                data_transforms: self.data_transforms,
                source: self.source,
            }
        }
    }
}
impl LogicalTable {
    /// Creates a new builder-style object to manufacture [`LogicalTable`](crate::model::LogicalTable).
    pub fn builder() -> crate::model::logical_table::Builder {
        crate::model::logical_table::Builder::default()
    }
}

/// <p>Information about the source of a logical table. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LogicalTableSource {
    /// <p>Specifies the result of a join of two logical tables.</p>
    #[doc(hidden)]
    pub join_instruction: std::option::Option<crate::model::JoinInstruction>,
    /// <p>Physical table ID.</p>
    #[doc(hidden)]
    pub physical_table_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Number (ARN) of the parent dataset.</p>
    #[doc(hidden)]
    pub data_set_arn: std::option::Option<std::string::String>,
}
impl LogicalTableSource {
    /// <p>Specifies the result of a join of two logical tables.</p>
    pub fn join_instruction(&self) -> std::option::Option<&crate::model::JoinInstruction> {
        self.join_instruction.as_ref()
    }
    /// <p>Physical table ID.</p>
    pub fn physical_table_id(&self) -> std::option::Option<&str> {
        self.physical_table_id.as_deref()
    }
    /// <p>The Amazon Resource Number (ARN) of the parent dataset.</p>
    pub fn data_set_arn(&self) -> std::option::Option<&str> {
        self.data_set_arn.as_deref()
    }
}
/// See [`LogicalTableSource`](crate::model::LogicalTableSource).
pub mod logical_table_source {

    /// A builder for [`LogicalTableSource`](crate::model::LogicalTableSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) join_instruction: std::option::Option<crate::model::JoinInstruction>,
        pub(crate) physical_table_id: std::option::Option<std::string::String>,
        pub(crate) data_set_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the result of a join of two logical tables.</p>
        pub fn join_instruction(mut self, input: crate::model::JoinInstruction) -> Self {
            self.join_instruction = Some(input);
            self
        }
        /// <p>Specifies the result of a join of two logical tables.</p>
        pub fn set_join_instruction(
            mut self,
            input: std::option::Option<crate::model::JoinInstruction>,
        ) -> Self {
            self.join_instruction = input;
            self
        }
        /// <p>Physical table ID.</p>
        pub fn physical_table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.physical_table_id = Some(input.into());
            self
        }
        /// <p>Physical table ID.</p>
        pub fn set_physical_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.physical_table_id = input;
            self
        }
        /// <p>The Amazon Resource Number (ARN) of the parent dataset.</p>
        pub fn data_set_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_set_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Number (ARN) of the parent dataset.</p>
        pub fn set_data_set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_set_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LogicalTableSource`](crate::model::LogicalTableSource).
        pub fn build(self) -> crate::model::LogicalTableSource {
            crate::model::LogicalTableSource {
                join_instruction: self.join_instruction,
                physical_table_id: self.physical_table_id,
                data_set_arn: self.data_set_arn,
            }
        }
    }
}
impl LogicalTableSource {
    /// Creates a new builder-style object to manufacture [`LogicalTableSource`](crate::model::LogicalTableSource).
    pub fn builder() -> crate::model::logical_table_source::Builder {
        crate::model::logical_table_source::Builder::default()
    }
}

/// <p>The instructions associated with a join. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JoinInstruction {
    /// <p>The operand on the left side of a join.</p>
    #[doc(hidden)]
    pub left_operand: std::option::Option<std::string::String>,
    /// <p>The operand on the right side of a join.</p>
    #[doc(hidden)]
    pub right_operand: std::option::Option<std::string::String>,
    /// <p>Join key properties of the left operand.</p>
    #[doc(hidden)]
    pub left_join_key_properties: std::option::Option<crate::model::JoinKeyProperties>,
    /// <p>Join key properties of the right operand.</p>
    #[doc(hidden)]
    pub right_join_key_properties: std::option::Option<crate::model::JoinKeyProperties>,
    /// <p>The type of join that it is.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::JoinType>,
    /// <p>The join instructions provided in the <code>ON</code> clause of a join.</p>
    #[doc(hidden)]
    pub on_clause: std::option::Option<std::string::String>,
}
impl JoinInstruction {
    /// <p>The operand on the left side of a join.</p>
    pub fn left_operand(&self) -> std::option::Option<&str> {
        self.left_operand.as_deref()
    }
    /// <p>The operand on the right side of a join.</p>
    pub fn right_operand(&self) -> std::option::Option<&str> {
        self.right_operand.as_deref()
    }
    /// <p>Join key properties of the left operand.</p>
    pub fn left_join_key_properties(
        &self,
    ) -> std::option::Option<&crate::model::JoinKeyProperties> {
        self.left_join_key_properties.as_ref()
    }
    /// <p>Join key properties of the right operand.</p>
    pub fn right_join_key_properties(
        &self,
    ) -> std::option::Option<&crate::model::JoinKeyProperties> {
        self.right_join_key_properties.as_ref()
    }
    /// <p>The type of join that it is.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::JoinType> {
        self.r#type.as_ref()
    }
    /// <p>The join instructions provided in the <code>ON</code> clause of a join.</p>
    pub fn on_clause(&self) -> std::option::Option<&str> {
        self.on_clause.as_deref()
    }
}
/// See [`JoinInstruction`](crate::model::JoinInstruction).
pub mod join_instruction {

    /// A builder for [`JoinInstruction`](crate::model::JoinInstruction).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) left_operand: std::option::Option<std::string::String>,
        pub(crate) right_operand: std::option::Option<std::string::String>,
        pub(crate) left_join_key_properties: std::option::Option<crate::model::JoinKeyProperties>,
        pub(crate) right_join_key_properties: std::option::Option<crate::model::JoinKeyProperties>,
        pub(crate) r#type: std::option::Option<crate::model::JoinType>,
        pub(crate) on_clause: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The operand on the left side of a join.</p>
        pub fn left_operand(mut self, input: impl Into<std::string::String>) -> Self {
            self.left_operand = Some(input.into());
            self
        }
        /// <p>The operand on the left side of a join.</p>
        pub fn set_left_operand(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.left_operand = input;
            self
        }
        /// <p>The operand on the right side of a join.</p>
        pub fn right_operand(mut self, input: impl Into<std::string::String>) -> Self {
            self.right_operand = Some(input.into());
            self
        }
        /// <p>The operand on the right side of a join.</p>
        pub fn set_right_operand(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.right_operand = input;
            self
        }
        /// <p>Join key properties of the left operand.</p>
        pub fn left_join_key_properties(mut self, input: crate::model::JoinKeyProperties) -> Self {
            self.left_join_key_properties = Some(input);
            self
        }
        /// <p>Join key properties of the left operand.</p>
        pub fn set_left_join_key_properties(
            mut self,
            input: std::option::Option<crate::model::JoinKeyProperties>,
        ) -> Self {
            self.left_join_key_properties = input;
            self
        }
        /// <p>Join key properties of the right operand.</p>
        pub fn right_join_key_properties(mut self, input: crate::model::JoinKeyProperties) -> Self {
            self.right_join_key_properties = Some(input);
            self
        }
        /// <p>Join key properties of the right operand.</p>
        pub fn set_right_join_key_properties(
            mut self,
            input: std::option::Option<crate::model::JoinKeyProperties>,
        ) -> Self {
            self.right_join_key_properties = input;
            self
        }
        /// <p>The type of join that it is.</p>
        pub fn r#type(mut self, input: crate::model::JoinType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of join that it is.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::JoinType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The join instructions provided in the <code>ON</code> clause of a join.</p>
        pub fn on_clause(mut self, input: impl Into<std::string::String>) -> Self {
            self.on_clause = Some(input.into());
            self
        }
        /// <p>The join instructions provided in the <code>ON</code> clause of a join.</p>
        pub fn set_on_clause(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.on_clause = input;
            self
        }
        /// Consumes the builder and constructs a [`JoinInstruction`](crate::model::JoinInstruction).
        pub fn build(self) -> crate::model::JoinInstruction {
            crate::model::JoinInstruction {
                left_operand: self.left_operand,
                right_operand: self.right_operand,
                left_join_key_properties: self.left_join_key_properties,
                right_join_key_properties: self.right_join_key_properties,
                r#type: self.r#type,
                on_clause: self.on_clause,
            }
        }
    }
}
impl JoinInstruction {
    /// Creates a new builder-style object to manufacture [`JoinInstruction`](crate::model::JoinInstruction).
    pub fn builder() -> crate::model::join_instruction::Builder {
        crate::model::join_instruction::Builder::default()
    }
}

/// When writing a match expression against `JoinType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let jointype = unimplemented!();
/// match jointype {
///     JoinType::Inner => { /* ... */ },
///     JoinType::Left => { /* ... */ },
///     JoinType::Outer => { /* ... */ },
///     JoinType::Right => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `jointype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `JoinType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `JoinType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `JoinType::NewFeature` is defined.
/// Specifically, when `jointype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `JoinType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JoinType {
    #[allow(missing_docs)] // documentation missing in model
    Inner,
    #[allow(missing_docs)] // documentation missing in model
    Left,
    #[allow(missing_docs)] // documentation missing in model
    Outer,
    #[allow(missing_docs)] // documentation missing in model
    Right,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for JoinType {
    fn from(s: &str) -> Self {
        match s {
            "INNER" => JoinType::Inner,
            "LEFT" => JoinType::Left,
            "OUTER" => JoinType::Outer,
            "RIGHT" => JoinType::Right,
            other => JoinType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for JoinType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JoinType::from(s))
    }
}
impl JoinType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JoinType::Inner => "INNER",
            JoinType::Left => "LEFT",
            JoinType::Outer => "OUTER",
            JoinType::Right => "RIGHT",
            JoinType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INNER", "LEFT", "OUTER", "RIGHT"]
    }
}
impl AsRef<str> for JoinType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Properties associated with the columns participating in a join.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JoinKeyProperties {
    /// <p>A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.</p>
    #[doc(hidden)]
    pub unique_key: std::option::Option<bool>,
}
impl JoinKeyProperties {
    /// <p>A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.</p>
    pub fn unique_key(&self) -> std::option::Option<bool> {
        self.unique_key
    }
}
/// See [`JoinKeyProperties`](crate::model::JoinKeyProperties).
pub mod join_key_properties {

    /// A builder for [`JoinKeyProperties`](crate::model::JoinKeyProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) unique_key: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.</p>
        pub fn unique_key(mut self, input: bool) -> Self {
            self.unique_key = Some(input);
            self
        }
        /// <p>A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.</p>
        pub fn set_unique_key(mut self, input: std::option::Option<bool>) -> Self {
            self.unique_key = input;
            self
        }
        /// Consumes the builder and constructs a [`JoinKeyProperties`](crate::model::JoinKeyProperties).
        pub fn build(self) -> crate::model::JoinKeyProperties {
            crate::model::JoinKeyProperties {
                unique_key: self.unique_key,
            }
        }
    }
}
impl JoinKeyProperties {
    /// Creates a new builder-style object to manufacture [`JoinKeyProperties`](crate::model::JoinKeyProperties).
    pub fn builder() -> crate::model::join_key_properties::Builder {
        crate::model::join_key_properties::Builder::default()
    }
}

/// <p>A data transformation on a logical table. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum TransformOperation {
    /// <p>A transform operation that casts a column to a different type.</p>
    CastColumnTypeOperation(crate::model::CastColumnTypeOperation),
    /// <p>An operation that creates calculated columns. Columns created in one such operation form a lexical closure.</p>
    CreateColumnsOperation(crate::model::CreateColumnsOperation),
    /// <p>An operation that filters rows based on some condition.</p>
    FilterOperation(crate::model::FilterOperation),
    /// <p>An operation that projects columns. Operations that come after a projection can only refer to projected columns.</p>
    ProjectOperation(crate::model::ProjectOperation),
    /// <p>An operation that renames a column.</p>
    RenameColumnOperation(crate::model::RenameColumnOperation),
    /// <p>An operation that tags a column with additional information.</p>
    TagColumnOperation(crate::model::TagColumnOperation),
    /// <p>A transform operation that removes tags associated with a column.</p>
    UntagColumnOperation(crate::model::UntagColumnOperation),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl TransformOperation {
    /// Tries to convert the enum instance into [`CastColumnTypeOperation`](crate::model::TransformOperation::CastColumnTypeOperation), extracting the inner [`CastColumnTypeOperation`](crate::model::CastColumnTypeOperation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_cast_column_type_operation(
        &self,
    ) -> std::result::Result<&crate::model::CastColumnTypeOperation, &Self> {
        if let TransformOperation::CastColumnTypeOperation(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`CastColumnTypeOperation`](crate::model::TransformOperation::CastColumnTypeOperation).
    pub fn is_cast_column_type_operation(&self) -> bool {
        self.as_cast_column_type_operation().is_ok()
    }
    /// Tries to convert the enum instance into [`CreateColumnsOperation`](crate::model::TransformOperation::CreateColumnsOperation), extracting the inner [`CreateColumnsOperation`](crate::model::CreateColumnsOperation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_create_columns_operation(
        &self,
    ) -> std::result::Result<&crate::model::CreateColumnsOperation, &Self> {
        if let TransformOperation::CreateColumnsOperation(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`CreateColumnsOperation`](crate::model::TransformOperation::CreateColumnsOperation).
    pub fn is_create_columns_operation(&self) -> bool {
        self.as_create_columns_operation().is_ok()
    }
    /// Tries to convert the enum instance into [`FilterOperation`](crate::model::TransformOperation::FilterOperation), extracting the inner [`FilterOperation`](crate::model::FilterOperation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_filter_operation(
        &self,
    ) -> std::result::Result<&crate::model::FilterOperation, &Self> {
        if let TransformOperation::FilterOperation(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`FilterOperation`](crate::model::TransformOperation::FilterOperation).
    pub fn is_filter_operation(&self) -> bool {
        self.as_filter_operation().is_ok()
    }
    /// Tries to convert the enum instance into [`ProjectOperation`](crate::model::TransformOperation::ProjectOperation), extracting the inner [`ProjectOperation`](crate::model::ProjectOperation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_project_operation(
        &self,
    ) -> std::result::Result<&crate::model::ProjectOperation, &Self> {
        if let TransformOperation::ProjectOperation(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ProjectOperation`](crate::model::TransformOperation::ProjectOperation).
    pub fn is_project_operation(&self) -> bool {
        self.as_project_operation().is_ok()
    }
    /// Tries to convert the enum instance into [`RenameColumnOperation`](crate::model::TransformOperation::RenameColumnOperation), extracting the inner [`RenameColumnOperation`](crate::model::RenameColumnOperation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_rename_column_operation(
        &self,
    ) -> std::result::Result<&crate::model::RenameColumnOperation, &Self> {
        if let TransformOperation::RenameColumnOperation(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`RenameColumnOperation`](crate::model::TransformOperation::RenameColumnOperation).
    pub fn is_rename_column_operation(&self) -> bool {
        self.as_rename_column_operation().is_ok()
    }
    /// Tries to convert the enum instance into [`TagColumnOperation`](crate::model::TransformOperation::TagColumnOperation), extracting the inner [`TagColumnOperation`](crate::model::TagColumnOperation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_tag_column_operation(
        &self,
    ) -> std::result::Result<&crate::model::TagColumnOperation, &Self> {
        if let TransformOperation::TagColumnOperation(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`TagColumnOperation`](crate::model::TransformOperation::TagColumnOperation).
    pub fn is_tag_column_operation(&self) -> bool {
        self.as_tag_column_operation().is_ok()
    }
    /// Tries to convert the enum instance into [`UntagColumnOperation`](crate::model::TransformOperation::UntagColumnOperation), extracting the inner [`UntagColumnOperation`](crate::model::UntagColumnOperation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_untag_column_operation(
        &self,
    ) -> std::result::Result<&crate::model::UntagColumnOperation, &Self> {
        if let TransformOperation::UntagColumnOperation(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`UntagColumnOperation`](crate::model::TransformOperation::UntagColumnOperation).
    pub fn is_untag_column_operation(&self) -> bool {
        self.as_untag_column_operation().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>A transform operation that removes tags associated with a column.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UntagColumnOperation {
    /// <p>The column that this operation acts on.</p>
    #[doc(hidden)]
    pub column_name: std::option::Option<std::string::String>,
    /// <p>The column tags to remove from this column.</p>
    #[doc(hidden)]
    pub tag_names: std::option::Option<std::vec::Vec<crate::model::ColumnTagName>>,
}
impl UntagColumnOperation {
    /// <p>The column that this operation acts on.</p>
    pub fn column_name(&self) -> std::option::Option<&str> {
        self.column_name.as_deref()
    }
    /// <p>The column tags to remove from this column.</p>
    pub fn tag_names(&self) -> std::option::Option<&[crate::model::ColumnTagName]> {
        self.tag_names.as_deref()
    }
}
/// See [`UntagColumnOperation`](crate::model::UntagColumnOperation).
pub mod untag_column_operation {

    /// A builder for [`UntagColumnOperation`](crate::model::UntagColumnOperation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column_name: std::option::Option<std::string::String>,
        pub(crate) tag_names: std::option::Option<std::vec::Vec<crate::model::ColumnTagName>>,
    }
    impl Builder {
        /// <p>The column that this operation acts on.</p>
        pub fn column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.column_name = Some(input.into());
            self
        }
        /// <p>The column that this operation acts on.</p>
        pub fn set_column_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.column_name = input;
            self
        }
        /// Appends an item to `tag_names`.
        ///
        /// To override the contents of this collection use [`set_tag_names`](Self::set_tag_names).
        ///
        /// <p>The column tags to remove from this column.</p>
        pub fn tag_names(mut self, input: crate::model::ColumnTagName) -> Self {
            let mut v = self.tag_names.unwrap_or_default();
            v.push(input);
            self.tag_names = Some(v);
            self
        }
        /// <p>The column tags to remove from this column.</p>
        pub fn set_tag_names(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnTagName>>,
        ) -> Self {
            self.tag_names = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagColumnOperation`](crate::model::UntagColumnOperation).
        pub fn build(self) -> crate::model::UntagColumnOperation {
            crate::model::UntagColumnOperation {
                column_name: self.column_name,
                tag_names: self.tag_names,
            }
        }
    }
}
impl UntagColumnOperation {
    /// Creates a new builder-style object to manufacture [`UntagColumnOperation`](crate::model::UntagColumnOperation).
    pub fn builder() -> crate::model::untag_column_operation::Builder {
        crate::model::untag_column_operation::Builder::default()
    }
}

/// When writing a match expression against `ColumnTagName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let columntagname = unimplemented!();
/// match columntagname {
///     ColumnTagName::ColumnDescription => { /* ... */ },
///     ColumnTagName::ColumnGeographicRole => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `columntagname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ColumnTagName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ColumnTagName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ColumnTagName::NewFeature` is defined.
/// Specifically, when `columntagname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ColumnTagName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ColumnTagName {
    #[allow(missing_docs)] // documentation missing in model
    ColumnDescription,
    #[allow(missing_docs)] // documentation missing in model
    ColumnGeographicRole,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ColumnTagName {
    fn from(s: &str) -> Self {
        match s {
            "COLUMN_DESCRIPTION" => ColumnTagName::ColumnDescription,
            "COLUMN_GEOGRAPHIC_ROLE" => ColumnTagName::ColumnGeographicRole,
            other => ColumnTagName::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ColumnTagName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ColumnTagName::from(s))
    }
}
impl ColumnTagName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ColumnTagName::ColumnDescription => "COLUMN_DESCRIPTION",
            ColumnTagName::ColumnGeographicRole => "COLUMN_GEOGRAPHIC_ROLE",
            ColumnTagName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COLUMN_DESCRIPTION", "COLUMN_GEOGRAPHIC_ROLE"]
    }
}
impl AsRef<str> for ColumnTagName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A transform operation that tags a column with additional information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagColumnOperation {
    /// <p>The column that this operation acts on.</p>
    #[doc(hidden)]
    pub column_name: std::option::Option<std::string::String>,
    /// <p>The dataset column tag, currently only used for geospatial type tagging.</p> <note>
    /// <p>This is not tags for the Amazon Web Services tagging feature.</p>
    /// </note>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::ColumnTag>>,
}
impl TagColumnOperation {
    /// <p>The column that this operation acts on.</p>
    pub fn column_name(&self) -> std::option::Option<&str> {
        self.column_name.as_deref()
    }
    /// <p>The dataset column tag, currently only used for geospatial type tagging.</p> <note>
    /// <p>This is not tags for the Amazon Web Services tagging feature.</p>
    /// </note>
    pub fn tags(&self) -> std::option::Option<&[crate::model::ColumnTag]> {
        self.tags.as_deref()
    }
}
/// See [`TagColumnOperation`](crate::model::TagColumnOperation).
pub mod tag_column_operation {

    /// A builder for [`TagColumnOperation`](crate::model::TagColumnOperation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::ColumnTag>>,
    }
    impl Builder {
        /// <p>The column that this operation acts on.</p>
        pub fn column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.column_name = Some(input.into());
            self
        }
        /// <p>The column that this operation acts on.</p>
        pub fn set_column_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.column_name = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The dataset column tag, currently only used for geospatial type tagging.</p> <note>
        /// <p>This is not tags for the Amazon Web Services tagging feature.</p>
        /// </note>
        pub fn tags(mut self, input: crate::model::ColumnTag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The dataset column tag, currently only used for geospatial type tagging.</p> <note>
        /// <p>This is not tags for the Amazon Web Services tagging feature.</p>
        /// </note>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnTag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagColumnOperation`](crate::model::TagColumnOperation).
        pub fn build(self) -> crate::model::TagColumnOperation {
            crate::model::TagColumnOperation {
                column_name: self.column_name,
                tags: self.tags,
            }
        }
    }
}
impl TagColumnOperation {
    /// Creates a new builder-style object to manufacture [`TagColumnOperation`](crate::model::TagColumnOperation).
    pub fn builder() -> crate::model::tag_column_operation::Builder {
        crate::model::tag_column_operation::Builder::default()
    }
}

/// <p>A tag for a column in a <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_TagColumnOperation.html">TagColumnOperation</a> </code> structure. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnTag {
    /// <p>A geospatial role for a column.</p>
    #[doc(hidden)]
    pub column_geographic_role: std::option::Option<crate::model::GeoSpatialDataRole>,
    /// <p>A description for a column.</p>
    #[doc(hidden)]
    pub column_description: std::option::Option<crate::model::ColumnDescription>,
}
impl ColumnTag {
    /// <p>A geospatial role for a column.</p>
    pub fn column_geographic_role(&self) -> std::option::Option<&crate::model::GeoSpatialDataRole> {
        self.column_geographic_role.as_ref()
    }
    /// <p>A description for a column.</p>
    pub fn column_description(&self) -> std::option::Option<&crate::model::ColumnDescription> {
        self.column_description.as_ref()
    }
}
/// See [`ColumnTag`](crate::model::ColumnTag).
pub mod column_tag {

    /// A builder for [`ColumnTag`](crate::model::ColumnTag).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column_geographic_role: std::option::Option<crate::model::GeoSpatialDataRole>,
        pub(crate) column_description: std::option::Option<crate::model::ColumnDescription>,
    }
    impl Builder {
        /// <p>A geospatial role for a column.</p>
        pub fn column_geographic_role(mut self, input: crate::model::GeoSpatialDataRole) -> Self {
            self.column_geographic_role = Some(input);
            self
        }
        /// <p>A geospatial role for a column.</p>
        pub fn set_column_geographic_role(
            mut self,
            input: std::option::Option<crate::model::GeoSpatialDataRole>,
        ) -> Self {
            self.column_geographic_role = input;
            self
        }
        /// <p>A description for a column.</p>
        pub fn column_description(mut self, input: crate::model::ColumnDescription) -> Self {
            self.column_description = Some(input);
            self
        }
        /// <p>A description for a column.</p>
        pub fn set_column_description(
            mut self,
            input: std::option::Option<crate::model::ColumnDescription>,
        ) -> Self {
            self.column_description = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnTag`](crate::model::ColumnTag).
        pub fn build(self) -> crate::model::ColumnTag {
            crate::model::ColumnTag {
                column_geographic_role: self.column_geographic_role,
                column_description: self.column_description,
            }
        }
    }
}
impl ColumnTag {
    /// Creates a new builder-style object to manufacture [`ColumnTag`](crate::model::ColumnTag).
    pub fn builder() -> crate::model::column_tag::Builder {
        crate::model::column_tag::Builder::default()
    }
}

/// <p>Metadata that contains a description for a column.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnDescription {
    /// <p>The text of a description for a column.</p>
    #[doc(hidden)]
    pub text: std::option::Option<std::string::String>,
}
impl ColumnDescription {
    /// <p>The text of a description for a column.</p>
    pub fn text(&self) -> std::option::Option<&str> {
        self.text.as_deref()
    }
}
/// See [`ColumnDescription`](crate::model::ColumnDescription).
pub mod column_description {

    /// A builder for [`ColumnDescription`](crate::model::ColumnDescription).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) text: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The text of a description for a column.</p>
        pub fn text(mut self, input: impl Into<std::string::String>) -> Self {
            self.text = Some(input.into());
            self
        }
        /// <p>The text of a description for a column.</p>
        pub fn set_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnDescription`](crate::model::ColumnDescription).
        pub fn build(self) -> crate::model::ColumnDescription {
            crate::model::ColumnDescription { text: self.text }
        }
    }
}
impl ColumnDescription {
    /// Creates a new builder-style object to manufacture [`ColumnDescription`](crate::model::ColumnDescription).
    pub fn builder() -> crate::model::column_description::Builder {
        crate::model::column_description::Builder::default()
    }
}

/// When writing a match expression against `GeoSpatialDataRole`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let geospatialdatarole = unimplemented!();
/// match geospatialdatarole {
///     GeoSpatialDataRole::City => { /* ... */ },
///     GeoSpatialDataRole::Country => { /* ... */ },
///     GeoSpatialDataRole::County => { /* ... */ },
///     GeoSpatialDataRole::Latitude => { /* ... */ },
///     GeoSpatialDataRole::Longitude => { /* ... */ },
///     GeoSpatialDataRole::Postcode => { /* ... */ },
///     GeoSpatialDataRole::State => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `geospatialdatarole` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `GeoSpatialDataRole::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `GeoSpatialDataRole::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `GeoSpatialDataRole::NewFeature` is defined.
/// Specifically, when `geospatialdatarole` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `GeoSpatialDataRole::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GeoSpatialDataRole {
    #[allow(missing_docs)] // documentation missing in model
    City,
    #[allow(missing_docs)] // documentation missing in model
    Country,
    #[allow(missing_docs)] // documentation missing in model
    County,
    #[allow(missing_docs)] // documentation missing in model
    Latitude,
    #[allow(missing_docs)] // documentation missing in model
    Longitude,
    #[allow(missing_docs)] // documentation missing in model
    Postcode,
    #[allow(missing_docs)] // documentation missing in model
    State,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for GeoSpatialDataRole {
    fn from(s: &str) -> Self {
        match s {
            "CITY" => GeoSpatialDataRole::City,
            "COUNTRY" => GeoSpatialDataRole::Country,
            "COUNTY" => GeoSpatialDataRole::County,
            "LATITUDE" => GeoSpatialDataRole::Latitude,
            "LONGITUDE" => GeoSpatialDataRole::Longitude,
            "POSTCODE" => GeoSpatialDataRole::Postcode,
            "STATE" => GeoSpatialDataRole::State,
            other => {
                GeoSpatialDataRole::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for GeoSpatialDataRole {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(GeoSpatialDataRole::from(s))
    }
}
impl GeoSpatialDataRole {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            GeoSpatialDataRole::City => "CITY",
            GeoSpatialDataRole::Country => "COUNTRY",
            GeoSpatialDataRole::County => "COUNTY",
            GeoSpatialDataRole::Latitude => "LATITUDE",
            GeoSpatialDataRole::Longitude => "LONGITUDE",
            GeoSpatialDataRole::Postcode => "POSTCODE",
            GeoSpatialDataRole::State => "STATE",
            GeoSpatialDataRole::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CITY",
            "COUNTRY",
            "COUNTY",
            "LATITUDE",
            "LONGITUDE",
            "POSTCODE",
            "STATE",
        ]
    }
}
impl AsRef<str> for GeoSpatialDataRole {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A transform operation that casts a column to a different type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CastColumnTypeOperation {
    /// <p>Column name.</p>
    #[doc(hidden)]
    pub column_name: std::option::Option<std::string::String>,
    /// <p>New column data type.</p>
    #[doc(hidden)]
    pub new_column_type: std::option::Option<crate::model::ColumnDataType>,
    /// <p>When casting a column from string to datetime type, you can supply a string in a format supported by Amazon QuickSight to denote the source data format.</p>
    #[doc(hidden)]
    pub format: std::option::Option<std::string::String>,
}
impl CastColumnTypeOperation {
    /// <p>Column name.</p>
    pub fn column_name(&self) -> std::option::Option<&str> {
        self.column_name.as_deref()
    }
    /// <p>New column data type.</p>
    pub fn new_column_type(&self) -> std::option::Option<&crate::model::ColumnDataType> {
        self.new_column_type.as_ref()
    }
    /// <p>When casting a column from string to datetime type, you can supply a string in a format supported by Amazon QuickSight to denote the source data format.</p>
    pub fn format(&self) -> std::option::Option<&str> {
        self.format.as_deref()
    }
}
/// See [`CastColumnTypeOperation`](crate::model::CastColumnTypeOperation).
pub mod cast_column_type_operation {

    /// A builder for [`CastColumnTypeOperation`](crate::model::CastColumnTypeOperation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column_name: std::option::Option<std::string::String>,
        pub(crate) new_column_type: std::option::Option<crate::model::ColumnDataType>,
        pub(crate) format: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Column name.</p>
        pub fn column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.column_name = Some(input.into());
            self
        }
        /// <p>Column name.</p>
        pub fn set_column_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.column_name = input;
            self
        }
        /// <p>New column data type.</p>
        pub fn new_column_type(mut self, input: crate::model::ColumnDataType) -> Self {
            self.new_column_type = Some(input);
            self
        }
        /// <p>New column data type.</p>
        pub fn set_new_column_type(
            mut self,
            input: std::option::Option<crate::model::ColumnDataType>,
        ) -> Self {
            self.new_column_type = input;
            self
        }
        /// <p>When casting a column from string to datetime type, you can supply a string in a format supported by Amazon QuickSight to denote the source data format.</p>
        pub fn format(mut self, input: impl Into<std::string::String>) -> Self {
            self.format = Some(input.into());
            self
        }
        /// <p>When casting a column from string to datetime type, you can supply a string in a format supported by Amazon QuickSight to denote the source data format.</p>
        pub fn set_format(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.format = input;
            self
        }
        /// Consumes the builder and constructs a [`CastColumnTypeOperation`](crate::model::CastColumnTypeOperation).
        pub fn build(self) -> crate::model::CastColumnTypeOperation {
            crate::model::CastColumnTypeOperation {
                column_name: self.column_name,
                new_column_type: self.new_column_type,
                format: self.format,
            }
        }
    }
}
impl CastColumnTypeOperation {
    /// Creates a new builder-style object to manufacture [`CastColumnTypeOperation`](crate::model::CastColumnTypeOperation).
    pub fn builder() -> crate::model::cast_column_type_operation::Builder {
        crate::model::cast_column_type_operation::Builder::default()
    }
}

/// When writing a match expression against `ColumnDataType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let columndatatype = unimplemented!();
/// match columndatatype {
///     ColumnDataType::Datetime => { /* ... */ },
///     ColumnDataType::Decimal => { /* ... */ },
///     ColumnDataType::Integer => { /* ... */ },
///     ColumnDataType::String => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `columndatatype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ColumnDataType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ColumnDataType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ColumnDataType::NewFeature` is defined.
/// Specifically, when `columndatatype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ColumnDataType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ColumnDataType {
    #[allow(missing_docs)] // documentation missing in model
    Datetime,
    #[allow(missing_docs)] // documentation missing in model
    Decimal,
    #[allow(missing_docs)] // documentation missing in model
    Integer,
    #[allow(missing_docs)] // documentation missing in model
    String,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ColumnDataType {
    fn from(s: &str) -> Self {
        match s {
            "DATETIME" => ColumnDataType::Datetime,
            "DECIMAL" => ColumnDataType::Decimal,
            "INTEGER" => ColumnDataType::Integer,
            "STRING" => ColumnDataType::String,
            other => ColumnDataType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ColumnDataType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ColumnDataType::from(s))
    }
}
impl ColumnDataType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ColumnDataType::Datetime => "DATETIME",
            ColumnDataType::Decimal => "DECIMAL",
            ColumnDataType::Integer => "INTEGER",
            ColumnDataType::String => "STRING",
            ColumnDataType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DATETIME", "DECIMAL", "INTEGER", "STRING"]
    }
}
impl AsRef<str> for ColumnDataType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A transform operation that renames a column.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RenameColumnOperation {
    /// <p>The name of the column to be renamed.</p>
    #[doc(hidden)]
    pub column_name: std::option::Option<std::string::String>,
    /// <p>The new name for the column.</p>
    #[doc(hidden)]
    pub new_column_name: std::option::Option<std::string::String>,
}
impl RenameColumnOperation {
    /// <p>The name of the column to be renamed.</p>
    pub fn column_name(&self) -> std::option::Option<&str> {
        self.column_name.as_deref()
    }
    /// <p>The new name for the column.</p>
    pub fn new_column_name(&self) -> std::option::Option<&str> {
        self.new_column_name.as_deref()
    }
}
/// See [`RenameColumnOperation`](crate::model::RenameColumnOperation).
pub mod rename_column_operation {

    /// A builder for [`RenameColumnOperation`](crate::model::RenameColumnOperation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column_name: std::option::Option<std::string::String>,
        pub(crate) new_column_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the column to be renamed.</p>
        pub fn column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.column_name = Some(input.into());
            self
        }
        /// <p>The name of the column to be renamed.</p>
        pub fn set_column_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.column_name = input;
            self
        }
        /// <p>The new name for the column.</p>
        pub fn new_column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.new_column_name = Some(input.into());
            self
        }
        /// <p>The new name for the column.</p>
        pub fn set_new_column_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.new_column_name = input;
            self
        }
        /// Consumes the builder and constructs a [`RenameColumnOperation`](crate::model::RenameColumnOperation).
        pub fn build(self) -> crate::model::RenameColumnOperation {
            crate::model::RenameColumnOperation {
                column_name: self.column_name,
                new_column_name: self.new_column_name,
            }
        }
    }
}
impl RenameColumnOperation {
    /// Creates a new builder-style object to manufacture [`RenameColumnOperation`](crate::model::RenameColumnOperation).
    pub fn builder() -> crate::model::rename_column_operation::Builder {
        crate::model::rename_column_operation::Builder::default()
    }
}

/// <p>A transform operation that creates calculated columns. Columns created in one such operation form a lexical closure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateColumnsOperation {
    /// <p>Calculated columns to create.</p>
    #[doc(hidden)]
    pub columns: std::option::Option<std::vec::Vec<crate::model::CalculatedColumn>>,
}
impl CreateColumnsOperation {
    /// <p>Calculated columns to create.</p>
    pub fn columns(&self) -> std::option::Option<&[crate::model::CalculatedColumn]> {
        self.columns.as_deref()
    }
}
/// See [`CreateColumnsOperation`](crate::model::CreateColumnsOperation).
pub mod create_columns_operation {

    /// A builder for [`CreateColumnsOperation`](crate::model::CreateColumnsOperation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) columns: std::option::Option<std::vec::Vec<crate::model::CalculatedColumn>>,
    }
    impl Builder {
        /// Appends an item to `columns`.
        ///
        /// To override the contents of this collection use [`set_columns`](Self::set_columns).
        ///
        /// <p>Calculated columns to create.</p>
        pub fn columns(mut self, input: crate::model::CalculatedColumn) -> Self {
            let mut v = self.columns.unwrap_or_default();
            v.push(input);
            self.columns = Some(v);
            self
        }
        /// <p>Calculated columns to create.</p>
        pub fn set_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CalculatedColumn>>,
        ) -> Self {
            self.columns = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateColumnsOperation`](crate::model::CreateColumnsOperation).
        pub fn build(self) -> crate::model::CreateColumnsOperation {
            crate::model::CreateColumnsOperation {
                columns: self.columns,
            }
        }
    }
}
impl CreateColumnsOperation {
    /// Creates a new builder-style object to manufacture [`CreateColumnsOperation`](crate::model::CreateColumnsOperation).
    pub fn builder() -> crate::model::create_columns_operation::Builder {
        crate::model::create_columns_operation::Builder::default()
    }
}

/// <p>A calculated column for a dataset.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CalculatedColumn {
    /// <p>Column name.</p>
    #[doc(hidden)]
    pub column_name: std::option::Option<std::string::String>,
    /// <p>A unique ID to identify a calculated column. During a dataset update, if the column ID of a calculated column matches that of an existing calculated column, Amazon QuickSight preserves the existing calculated column.</p>
    #[doc(hidden)]
    pub column_id: std::option::Option<std::string::String>,
    /// <p>An expression that defines the calculated column.</p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::string::String>,
}
impl CalculatedColumn {
    /// <p>Column name.</p>
    pub fn column_name(&self) -> std::option::Option<&str> {
        self.column_name.as_deref()
    }
    /// <p>A unique ID to identify a calculated column. During a dataset update, if the column ID of a calculated column matches that of an existing calculated column, Amazon QuickSight preserves the existing calculated column.</p>
    pub fn column_id(&self) -> std::option::Option<&str> {
        self.column_id.as_deref()
    }
    /// <p>An expression that defines the calculated column.</p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
}
impl std::fmt::Debug for CalculatedColumn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CalculatedColumn");
        formatter.field("column_name", &self.column_name);
        formatter.field("column_id", &self.column_id);
        formatter.field("expression", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`CalculatedColumn`](crate::model::CalculatedColumn).
pub mod calculated_column {

    /// A builder for [`CalculatedColumn`](crate::model::CalculatedColumn).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) column_name: std::option::Option<std::string::String>,
        pub(crate) column_id: std::option::Option<std::string::String>,
        pub(crate) expression: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Column name.</p>
        pub fn column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.column_name = Some(input.into());
            self
        }
        /// <p>Column name.</p>
        pub fn set_column_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.column_name = input;
            self
        }
        /// <p>A unique ID to identify a calculated column. During a dataset update, if the column ID of a calculated column matches that of an existing calculated column, Amazon QuickSight preserves the existing calculated column.</p>
        pub fn column_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.column_id = Some(input.into());
            self
        }
        /// <p>A unique ID to identify a calculated column. During a dataset update, if the column ID of a calculated column matches that of an existing calculated column, Amazon QuickSight preserves the existing calculated column.</p>
        pub fn set_column_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.column_id = input;
            self
        }
        /// <p>An expression that defines the calculated column.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>An expression that defines the calculated column.</p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// Consumes the builder and constructs a [`CalculatedColumn`](crate::model::CalculatedColumn).
        pub fn build(self) -> crate::model::CalculatedColumn {
            crate::model::CalculatedColumn {
                column_name: self.column_name,
                column_id: self.column_id,
                expression: self.expression,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("column_name", &self.column_name);
            formatter.field("column_id", &self.column_id);
            formatter.field("expression", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl CalculatedColumn {
    /// Creates a new builder-style object to manufacture [`CalculatedColumn`](crate::model::CalculatedColumn).
    pub fn builder() -> crate::model::calculated_column::Builder {
        crate::model::calculated_column::Builder::default()
    }
}

/// <p>A transform operation that filters rows based on a condition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FilterOperation {
    /// <p>An expression that must evaluate to a Boolean value. Rows for which the expression evaluates to true are kept in the dataset.</p>
    #[doc(hidden)]
    pub condition_expression: std::option::Option<std::string::String>,
}
impl FilterOperation {
    /// <p>An expression that must evaluate to a Boolean value. Rows for which the expression evaluates to true are kept in the dataset.</p>
    pub fn condition_expression(&self) -> std::option::Option<&str> {
        self.condition_expression.as_deref()
    }
}
impl std::fmt::Debug for FilterOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FilterOperation");
        formatter.field("condition_expression", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`FilterOperation`](crate::model::FilterOperation).
pub mod filter_operation {

    /// A builder for [`FilterOperation`](crate::model::FilterOperation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) condition_expression: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An expression that must evaluate to a Boolean value. Rows for which the expression evaluates to true are kept in the dataset.</p>
        pub fn condition_expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.condition_expression = Some(input.into());
            self
        }
        /// <p>An expression that must evaluate to a Boolean value. Rows for which the expression evaluates to true are kept in the dataset.</p>
        pub fn set_condition_expression(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.condition_expression = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterOperation`](crate::model::FilterOperation).
        pub fn build(self) -> crate::model::FilterOperation {
            crate::model::FilterOperation {
                condition_expression: self.condition_expression,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("condition_expression", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl FilterOperation {
    /// Creates a new builder-style object to manufacture [`FilterOperation`](crate::model::FilterOperation).
    pub fn builder() -> crate::model::filter_operation::Builder {
        crate::model::filter_operation::Builder::default()
    }
}

/// <p>A transform operation that projects columns. Operations that come after a projection can only refer to projected columns.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProjectOperation {
    /// <p>Projected columns.</p>
    #[doc(hidden)]
    pub projected_columns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ProjectOperation {
    /// <p>Projected columns.</p>
    pub fn projected_columns(&self) -> std::option::Option<&[std::string::String]> {
        self.projected_columns.as_deref()
    }
}
/// See [`ProjectOperation`](crate::model::ProjectOperation).
pub mod project_operation {

    /// A builder for [`ProjectOperation`](crate::model::ProjectOperation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) projected_columns: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `projected_columns`.
        ///
        /// To override the contents of this collection use [`set_projected_columns`](Self::set_projected_columns).
        ///
        /// <p>Projected columns.</p>
        pub fn projected_columns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.projected_columns.unwrap_or_default();
            v.push(input.into());
            self.projected_columns = Some(v);
            self
        }
        /// <p>Projected columns.</p>
        pub fn set_projected_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.projected_columns = input;
            self
        }
        /// Consumes the builder and constructs a [`ProjectOperation`](crate::model::ProjectOperation).
        pub fn build(self) -> crate::model::ProjectOperation {
            crate::model::ProjectOperation {
                projected_columns: self.projected_columns,
            }
        }
    }
}
impl ProjectOperation {
    /// Creates a new builder-style object to manufacture [`ProjectOperation`](crate::model::ProjectOperation).
    pub fn builder() -> crate::model::project_operation::Builder {
        crate::model::project_operation::Builder::default()
    }
}

/// <p>A view of a data source that contains information about the shape of the data in the underlying source. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum PhysicalTable {
    /// <p>A physical table type built from the results of the custom SQL query.</p>
    CustomSql(crate::model::CustomSql),
    /// <p>A physical table type for relational data sources.</p>
    RelationalTable(crate::model::RelationalTable),
    /// <p>A physical table type for as S3 data source.</p>
    S3Source(crate::model::S3Source),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl PhysicalTable {
    /// Tries to convert the enum instance into [`CustomSql`](crate::model::PhysicalTable::CustomSql), extracting the inner [`CustomSql`](crate::model::CustomSql).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_custom_sql(&self) -> std::result::Result<&crate::model::CustomSql, &Self> {
        if let PhysicalTable::CustomSql(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`CustomSql`](crate::model::PhysicalTable::CustomSql).
    pub fn is_custom_sql(&self) -> bool {
        self.as_custom_sql().is_ok()
    }
    /// Tries to convert the enum instance into [`RelationalTable`](crate::model::PhysicalTable::RelationalTable), extracting the inner [`RelationalTable`](crate::model::RelationalTable).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_relational_table(
        &self,
    ) -> std::result::Result<&crate::model::RelationalTable, &Self> {
        if let PhysicalTable::RelationalTable(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`RelationalTable`](crate::model::PhysicalTable::RelationalTable).
    pub fn is_relational_table(&self) -> bool {
        self.as_relational_table().is_ok()
    }
    /// Tries to convert the enum instance into [`S3Source`](crate::model::PhysicalTable::S3Source), extracting the inner [`S3Source`](crate::model::S3Source).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_s3_source(&self) -> std::result::Result<&crate::model::S3Source, &Self> {
        if let PhysicalTable::S3Source(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`S3Source`](crate::model::PhysicalTable::S3Source).
    pub fn is_s3_source(&self) -> bool {
        self.as_s3_source().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>A physical table type for an S3 data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3Source {
    /// <p>The Amazon Resource Name (ARN) for the data source.</p>
    #[doc(hidden)]
    pub data_source_arn: std::option::Option<std::string::String>,
    /// <p>Information about the format for the S3 source file or files.</p>
    #[doc(hidden)]
    pub upload_settings: std::option::Option<crate::model::UploadSettings>,
    /// <p>A physical table type for an S3 data source.</p> <note>
    /// <p>For files that aren't JSON, only <code>STRING</code> data types are supported in input columns.</p>
    /// </note>
    #[doc(hidden)]
    pub input_columns: std::option::Option<std::vec::Vec<crate::model::InputColumn>>,
}
impl S3Source {
    /// <p>The Amazon Resource Name (ARN) for the data source.</p>
    pub fn data_source_arn(&self) -> std::option::Option<&str> {
        self.data_source_arn.as_deref()
    }
    /// <p>Information about the format for the S3 source file or files.</p>
    pub fn upload_settings(&self) -> std::option::Option<&crate::model::UploadSettings> {
        self.upload_settings.as_ref()
    }
    /// <p>A physical table type for an S3 data source.</p> <note>
    /// <p>For files that aren't JSON, only <code>STRING</code> data types are supported in input columns.</p>
    /// </note>
    pub fn input_columns(&self) -> std::option::Option<&[crate::model::InputColumn]> {
        self.input_columns.as_deref()
    }
}
/// See [`S3Source`](crate::model::S3Source).
pub mod s3_source {

    /// A builder for [`S3Source`](crate::model::S3Source).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source_arn: std::option::Option<std::string::String>,
        pub(crate) upload_settings: std::option::Option<crate::model::UploadSettings>,
        pub(crate) input_columns: std::option::Option<std::vec::Vec<crate::model::InputColumn>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for the data source.</p>
        pub fn data_source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_source_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the data source.</p>
        pub fn set_data_source_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_source_arn = input;
            self
        }
        /// <p>Information about the format for the S3 source file or files.</p>
        pub fn upload_settings(mut self, input: crate::model::UploadSettings) -> Self {
            self.upload_settings = Some(input);
            self
        }
        /// <p>Information about the format for the S3 source file or files.</p>
        pub fn set_upload_settings(
            mut self,
            input: std::option::Option<crate::model::UploadSettings>,
        ) -> Self {
            self.upload_settings = input;
            self
        }
        /// Appends an item to `input_columns`.
        ///
        /// To override the contents of this collection use [`set_input_columns`](Self::set_input_columns).
        ///
        /// <p>A physical table type for an S3 data source.</p> <note>
        /// <p>For files that aren't JSON, only <code>STRING</code> data types are supported in input columns.</p>
        /// </note>
        pub fn input_columns(mut self, input: crate::model::InputColumn) -> Self {
            let mut v = self.input_columns.unwrap_or_default();
            v.push(input);
            self.input_columns = Some(v);
            self
        }
        /// <p>A physical table type for an S3 data source.</p> <note>
        /// <p>For files that aren't JSON, only <code>STRING</code> data types are supported in input columns.</p>
        /// </note>
        pub fn set_input_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InputColumn>>,
        ) -> Self {
            self.input_columns = input;
            self
        }
        /// Consumes the builder and constructs a [`S3Source`](crate::model::S3Source).
        pub fn build(self) -> crate::model::S3Source {
            crate::model::S3Source {
                data_source_arn: self.data_source_arn,
                upload_settings: self.upload_settings,
                input_columns: self.input_columns,
            }
        }
    }
}
impl S3Source {
    /// Creates a new builder-style object to manufacture [`S3Source`](crate::model::S3Source).
    pub fn builder() -> crate::model::s3_source::Builder {
        crate::model::s3_source::Builder::default()
    }
}

/// <p>Metadata for a column that is used as the input of a transform operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InputColumn {
    /// <p>The name of this column in the underlying data source.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data type of the column.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::InputColumnDataType>,
}
impl InputColumn {
    /// <p>The name of this column in the underlying data source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data type of the column.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::InputColumnDataType> {
        self.r#type.as_ref()
    }
}
/// See [`InputColumn`](crate::model::InputColumn).
pub mod input_column {

    /// A builder for [`InputColumn`](crate::model::InputColumn).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::InputColumnDataType>,
    }
    impl Builder {
        /// <p>The name of this column in the underlying data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of this column in the underlying data source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The data type of the column.</p>
        pub fn r#type(mut self, input: crate::model::InputColumnDataType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The data type of the column.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::InputColumnDataType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`InputColumn`](crate::model::InputColumn).
        pub fn build(self) -> crate::model::InputColumn {
            crate::model::InputColumn {
                name: self.name,
                r#type: self.r#type,
            }
        }
    }
}
impl InputColumn {
    /// Creates a new builder-style object to manufacture [`InputColumn`](crate::model::InputColumn).
    pub fn builder() -> crate::model::input_column::Builder {
        crate::model::input_column::Builder::default()
    }
}

/// When writing a match expression against `InputColumnDataType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let inputcolumndatatype = unimplemented!();
/// match inputcolumndatatype {
///     InputColumnDataType::Bit => { /* ... */ },
///     InputColumnDataType::Boolean => { /* ... */ },
///     InputColumnDataType::Datetime => { /* ... */ },
///     InputColumnDataType::Decimal => { /* ... */ },
///     InputColumnDataType::Integer => { /* ... */ },
///     InputColumnDataType::Json => { /* ... */ },
///     InputColumnDataType::String => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `inputcolumndatatype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InputColumnDataType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InputColumnDataType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InputColumnDataType::NewFeature` is defined.
/// Specifically, when `inputcolumndatatype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InputColumnDataType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InputColumnDataType {
    #[allow(missing_docs)] // documentation missing in model
    Bit,
    #[allow(missing_docs)] // documentation missing in model
    Boolean,
    #[allow(missing_docs)] // documentation missing in model
    Datetime,
    #[allow(missing_docs)] // documentation missing in model
    Decimal,
    #[allow(missing_docs)] // documentation missing in model
    Integer,
    #[allow(missing_docs)] // documentation missing in model
    Json,
    #[allow(missing_docs)] // documentation missing in model
    String,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for InputColumnDataType {
    fn from(s: &str) -> Self {
        match s {
            "BIT" => InputColumnDataType::Bit,
            "BOOLEAN" => InputColumnDataType::Boolean,
            "DATETIME" => InputColumnDataType::Datetime,
            "DECIMAL" => InputColumnDataType::Decimal,
            "INTEGER" => InputColumnDataType::Integer,
            "JSON" => InputColumnDataType::Json,
            "STRING" => InputColumnDataType::String,
            other => {
                InputColumnDataType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for InputColumnDataType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InputColumnDataType::from(s))
    }
}
impl InputColumnDataType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InputColumnDataType::Bit => "BIT",
            InputColumnDataType::Boolean => "BOOLEAN",
            InputColumnDataType::Datetime => "DATETIME",
            InputColumnDataType::Decimal => "DECIMAL",
            InputColumnDataType::Integer => "INTEGER",
            InputColumnDataType::Json => "JSON",
            InputColumnDataType::String => "STRING",
            InputColumnDataType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BIT", "BOOLEAN", "DATETIME", "DECIMAL", "INTEGER", "JSON", "STRING",
        ]
    }
}
impl AsRef<str> for InputColumnDataType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the format for a source file or files.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UploadSettings {
    /// <p>File format.</p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::FileFormat>,
    /// <p>A row number to start reading data from.</p>
    #[doc(hidden)]
    pub start_from_row: std::option::Option<i32>,
    /// <p>Whether the file has a header row, or the files each have a header row.</p>
    #[doc(hidden)]
    pub contains_header: std::option::Option<bool>,
    /// <p>Text qualifier.</p>
    #[doc(hidden)]
    pub text_qualifier: std::option::Option<crate::model::TextQualifier>,
    /// <p>The delimiter between values in the file.</p>
    #[doc(hidden)]
    pub delimiter: std::option::Option<std::string::String>,
}
impl UploadSettings {
    /// <p>File format.</p>
    pub fn format(&self) -> std::option::Option<&crate::model::FileFormat> {
        self.format.as_ref()
    }
    /// <p>A row number to start reading data from.</p>
    pub fn start_from_row(&self) -> std::option::Option<i32> {
        self.start_from_row
    }
    /// <p>Whether the file has a header row, or the files each have a header row.</p>
    pub fn contains_header(&self) -> std::option::Option<bool> {
        self.contains_header
    }
    /// <p>Text qualifier.</p>
    pub fn text_qualifier(&self) -> std::option::Option<&crate::model::TextQualifier> {
        self.text_qualifier.as_ref()
    }
    /// <p>The delimiter between values in the file.</p>
    pub fn delimiter(&self) -> std::option::Option<&str> {
        self.delimiter.as_deref()
    }
}
/// See [`UploadSettings`](crate::model::UploadSettings).
pub mod upload_settings {

    /// A builder for [`UploadSettings`](crate::model::UploadSettings).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) format: std::option::Option<crate::model::FileFormat>,
        pub(crate) start_from_row: std::option::Option<i32>,
        pub(crate) contains_header: std::option::Option<bool>,
        pub(crate) text_qualifier: std::option::Option<crate::model::TextQualifier>,
        pub(crate) delimiter: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>File format.</p>
        pub fn format(mut self, input: crate::model::FileFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p>File format.</p>
        pub fn set_format(mut self, input: std::option::Option<crate::model::FileFormat>) -> Self {
            self.format = input;
            self
        }
        /// <p>A row number to start reading data from.</p>
        pub fn start_from_row(mut self, input: i32) -> Self {
            self.start_from_row = Some(input);
            self
        }
        /// <p>A row number to start reading data from.</p>
        pub fn set_start_from_row(mut self, input: std::option::Option<i32>) -> Self {
            self.start_from_row = input;
            self
        }
        /// <p>Whether the file has a header row, or the files each have a header row.</p>
        pub fn contains_header(mut self, input: bool) -> Self {
            self.contains_header = Some(input);
            self
        }
        /// <p>Whether the file has a header row, or the files each have a header row.</p>
        pub fn set_contains_header(mut self, input: std::option::Option<bool>) -> Self {
            self.contains_header = input;
            self
        }
        /// <p>Text qualifier.</p>
        pub fn text_qualifier(mut self, input: crate::model::TextQualifier) -> Self {
            self.text_qualifier = Some(input);
            self
        }
        /// <p>Text qualifier.</p>
        pub fn set_text_qualifier(
            mut self,
            input: std::option::Option<crate::model::TextQualifier>,
        ) -> Self {
            self.text_qualifier = input;
            self
        }
        /// <p>The delimiter between values in the file.</p>
        pub fn delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.delimiter = Some(input.into());
            self
        }
        /// <p>The delimiter between values in the file.</p>
        pub fn set_delimiter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.delimiter = input;
            self
        }
        /// Consumes the builder and constructs a [`UploadSettings`](crate::model::UploadSettings).
        pub fn build(self) -> crate::model::UploadSettings {
            crate::model::UploadSettings {
                format: self.format,
                start_from_row: self.start_from_row,
                contains_header: self.contains_header,
                text_qualifier: self.text_qualifier,
                delimiter: self.delimiter,
            }
        }
    }
}
impl UploadSettings {
    /// Creates a new builder-style object to manufacture [`UploadSettings`](crate::model::UploadSettings).
    pub fn builder() -> crate::model::upload_settings::Builder {
        crate::model::upload_settings::Builder::default()
    }
}

/// When writing a match expression against `TextQualifier`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let textqualifier = unimplemented!();
/// match textqualifier {
///     TextQualifier::DoubleQuote => { /* ... */ },
///     TextQualifier::SingleQuote => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `textqualifier` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TextQualifier::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TextQualifier::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TextQualifier::NewFeature` is defined.
/// Specifically, when `textqualifier` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TextQualifier::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TextQualifier {
    #[allow(missing_docs)] // documentation missing in model
    DoubleQuote,
    #[allow(missing_docs)] // documentation missing in model
    SingleQuote,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TextQualifier {
    fn from(s: &str) -> Self {
        match s {
            "DOUBLE_QUOTE" => TextQualifier::DoubleQuote,
            "SINGLE_QUOTE" => TextQualifier::SingleQuote,
            other => TextQualifier::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TextQualifier {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TextQualifier::from(s))
    }
}
impl TextQualifier {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TextQualifier::DoubleQuote => "DOUBLE_QUOTE",
            TextQualifier::SingleQuote => "SINGLE_QUOTE",
            TextQualifier::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DOUBLE_QUOTE", "SINGLE_QUOTE"]
    }
}
impl AsRef<str> for TextQualifier {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `FileFormat`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let fileformat = unimplemented!();
/// match fileformat {
///     FileFormat::Clf => { /* ... */ },
///     FileFormat::Csv => { /* ... */ },
///     FileFormat::Elf => { /* ... */ },
///     FileFormat::Json => { /* ... */ },
///     FileFormat::Tsv => { /* ... */ },
///     FileFormat::Xlsx => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `fileformat` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FileFormat::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FileFormat::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FileFormat::NewFeature` is defined.
/// Specifically, when `fileformat` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FileFormat::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FileFormat {
    #[allow(missing_docs)] // documentation missing in model
    Clf,
    #[allow(missing_docs)] // documentation missing in model
    Csv,
    #[allow(missing_docs)] // documentation missing in model
    Elf,
    #[allow(missing_docs)] // documentation missing in model
    Json,
    #[allow(missing_docs)] // documentation missing in model
    Tsv,
    #[allow(missing_docs)] // documentation missing in model
    Xlsx,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FileFormat {
    fn from(s: &str) -> Self {
        match s {
            "CLF" => FileFormat::Clf,
            "CSV" => FileFormat::Csv,
            "ELF" => FileFormat::Elf,
            "JSON" => FileFormat::Json,
            "TSV" => FileFormat::Tsv,
            "XLSX" => FileFormat::Xlsx,
            other => FileFormat::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FileFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FileFormat::from(s))
    }
}
impl FileFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FileFormat::Clf => "CLF",
            FileFormat::Csv => "CSV",
            FileFormat::Elf => "ELF",
            FileFormat::Json => "JSON",
            FileFormat::Tsv => "TSV",
            FileFormat::Xlsx => "XLSX",
            FileFormat::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CLF", "CSV", "ELF", "JSON", "TSV", "XLSX"]
    }
}
impl AsRef<str> for FileFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A physical table type built from the results of the custom SQL query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomSql {
    /// <p>The Amazon Resource Name (ARN) of the data source.</p>
    #[doc(hidden)]
    pub data_source_arn: std::option::Option<std::string::String>,
    /// <p>A display name for the SQL query result.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The SQL query.</p>
    #[doc(hidden)]
    pub sql_query: std::option::Option<std::string::String>,
    /// <p>The column schema from the SQL query result set.</p>
    #[doc(hidden)]
    pub columns: std::option::Option<std::vec::Vec<crate::model::InputColumn>>,
}
impl CustomSql {
    /// <p>The Amazon Resource Name (ARN) of the data source.</p>
    pub fn data_source_arn(&self) -> std::option::Option<&str> {
        self.data_source_arn.as_deref()
    }
    /// <p>A display name for the SQL query result.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The SQL query.</p>
    pub fn sql_query(&self) -> std::option::Option<&str> {
        self.sql_query.as_deref()
    }
    /// <p>The column schema from the SQL query result set.</p>
    pub fn columns(&self) -> std::option::Option<&[crate::model::InputColumn]> {
        self.columns.as_deref()
    }
}
/// See [`CustomSql`](crate::model::CustomSql).
pub mod custom_sql {

    /// A builder for [`CustomSql`](crate::model::CustomSql).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) sql_query: std::option::Option<std::string::String>,
        pub(crate) columns: std::option::Option<std::vec::Vec<crate::model::InputColumn>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the data source.</p>
        pub fn data_source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_source_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the data source.</p>
        pub fn set_data_source_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_source_arn = input;
            self
        }
        /// <p>A display name for the SQL query result.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A display name for the SQL query result.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The SQL query.</p>
        pub fn sql_query(mut self, input: impl Into<std::string::String>) -> Self {
            self.sql_query = Some(input.into());
            self
        }
        /// <p>The SQL query.</p>
        pub fn set_sql_query(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sql_query = input;
            self
        }
        /// Appends an item to `columns`.
        ///
        /// To override the contents of this collection use [`set_columns`](Self::set_columns).
        ///
        /// <p>The column schema from the SQL query result set.</p>
        pub fn columns(mut self, input: crate::model::InputColumn) -> Self {
            let mut v = self.columns.unwrap_or_default();
            v.push(input);
            self.columns = Some(v);
            self
        }
        /// <p>The column schema from the SQL query result set.</p>
        pub fn set_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InputColumn>>,
        ) -> Self {
            self.columns = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomSql`](crate::model::CustomSql).
        pub fn build(self) -> crate::model::CustomSql {
            crate::model::CustomSql {
                data_source_arn: self.data_source_arn,
                name: self.name,
                sql_query: self.sql_query,
                columns: self.columns,
            }
        }
    }
}
impl CustomSql {
    /// Creates a new builder-style object to manufacture [`CustomSql`](crate::model::CustomSql).
    pub fn builder() -> crate::model::custom_sql::Builder {
        crate::model::custom_sql::Builder::default()
    }
}

/// <p>A physical table type for relational data sources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RelationalTable {
    /// <p>The Amazon Resource Name (ARN) for the data source.</p>
    #[doc(hidden)]
    pub data_source_arn: std::option::Option<std::string::String>,
    /// <p>The catalog associated with a table.</p>
    #[doc(hidden)]
    pub catalog: std::option::Option<std::string::String>,
    /// <p>The schema name. This name applies to certain relational database engines.</p>
    #[doc(hidden)]
    pub schema: std::option::Option<std::string::String>,
    /// <p>The name of the relational table.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The column schema of the table.</p>
    #[doc(hidden)]
    pub input_columns: std::option::Option<std::vec::Vec<crate::model::InputColumn>>,
}
impl RelationalTable {
    /// <p>The Amazon Resource Name (ARN) for the data source.</p>
    pub fn data_source_arn(&self) -> std::option::Option<&str> {
        self.data_source_arn.as_deref()
    }
    /// <p>The catalog associated with a table.</p>
    pub fn catalog(&self) -> std::option::Option<&str> {
        self.catalog.as_deref()
    }
    /// <p>The schema name. This name applies to certain relational database engines.</p>
    pub fn schema(&self) -> std::option::Option<&str> {
        self.schema.as_deref()
    }
    /// <p>The name of the relational table.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The column schema of the table.</p>
    pub fn input_columns(&self) -> std::option::Option<&[crate::model::InputColumn]> {
        self.input_columns.as_deref()
    }
}
/// See [`RelationalTable`](crate::model::RelationalTable).
pub mod relational_table {

    /// A builder for [`RelationalTable`](crate::model::RelationalTable).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source_arn: std::option::Option<std::string::String>,
        pub(crate) catalog: std::option::Option<std::string::String>,
        pub(crate) schema: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) input_columns: std::option::Option<std::vec::Vec<crate::model::InputColumn>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for the data source.</p>
        pub fn data_source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_source_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the data source.</p>
        pub fn set_data_source_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_source_arn = input;
            self
        }
        /// <p>The catalog associated with a table.</p>
        pub fn catalog(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog = Some(input.into());
            self
        }
        /// <p>The catalog associated with a table.</p>
        pub fn set_catalog(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog = input;
            self
        }
        /// <p>The schema name. This name applies to certain relational database engines.</p>
        pub fn schema(mut self, input: impl Into<std::string::String>) -> Self {
            self.schema = Some(input.into());
            self
        }
        /// <p>The schema name. This name applies to certain relational database engines.</p>
        pub fn set_schema(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.schema = input;
            self
        }
        /// <p>The name of the relational table.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the relational table.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `input_columns`.
        ///
        /// To override the contents of this collection use [`set_input_columns`](Self::set_input_columns).
        ///
        /// <p>The column schema of the table.</p>
        pub fn input_columns(mut self, input: crate::model::InputColumn) -> Self {
            let mut v = self.input_columns.unwrap_or_default();
            v.push(input);
            self.input_columns = Some(v);
            self
        }
        /// <p>The column schema of the table.</p>
        pub fn set_input_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InputColumn>>,
        ) -> Self {
            self.input_columns = input;
            self
        }
        /// Consumes the builder and constructs a [`RelationalTable`](crate::model::RelationalTable).
        pub fn build(self) -> crate::model::RelationalTable {
            crate::model::RelationalTable {
                data_source_arn: self.data_source_arn,
                catalog: self.catalog,
                schema: self.schema,
                name: self.name,
                input_columns: self.input_columns,
            }
        }
    }
}
impl RelationalTable {
    /// Creates a new builder-style object to manufacture [`RelationalTable`](crate::model::RelationalTable).
    pub fn builder() -> crate::model::relational_table::Builder {
        crate::model::relational_table::Builder::default()
    }
}

/// <p>A structure that contains the configuration of a shareable link to the dashboard.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LinkSharingConfiguration {
    /// <p>A structure that contains the permissions of a shareable link.</p>
    #[doc(hidden)]
    pub permissions: std::option::Option<std::vec::Vec<crate::model::ResourcePermission>>,
}
impl LinkSharingConfiguration {
    /// <p>A structure that contains the permissions of a shareable link.</p>
    pub fn permissions(&self) -> std::option::Option<&[crate::model::ResourcePermission]> {
        self.permissions.as_deref()
    }
}
/// See [`LinkSharingConfiguration`](crate::model::LinkSharingConfiguration).
pub mod link_sharing_configuration {

    /// A builder for [`LinkSharingConfiguration`](crate::model::LinkSharingConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) permissions:
            std::option::Option<std::vec::Vec<crate::model::ResourcePermission>>,
    }
    impl Builder {
        /// Appends an item to `permissions`.
        ///
        /// To override the contents of this collection use [`set_permissions`](Self::set_permissions).
        ///
        /// <p>A structure that contains the permissions of a shareable link.</p>
        pub fn permissions(mut self, input: crate::model::ResourcePermission) -> Self {
            let mut v = self.permissions.unwrap_or_default();
            v.push(input);
            self.permissions = Some(v);
            self
        }
        /// <p>A structure that contains the permissions of a shareable link.</p>
        pub fn set_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourcePermission>>,
        ) -> Self {
            self.permissions = input;
            self
        }
        /// Consumes the builder and constructs a [`LinkSharingConfiguration`](crate::model::LinkSharingConfiguration).
        pub fn build(self) -> crate::model::LinkSharingConfiguration {
            crate::model::LinkSharingConfiguration {
                permissions: self.permissions,
            }
        }
    }
}
impl LinkSharingConfiguration {
    /// Creates a new builder-style object to manufacture [`LinkSharingConfiguration`](crate::model::LinkSharingConfiguration).
    pub fn builder() -> crate::model::link_sharing_configuration::Builder {
        crate::model::link_sharing_configuration::Builder::default()
    }
}

/// <p>The contents of a dashboard.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DashboardVersionDefinition {
    /// <p>An array of dataset identifier declarations. With this mapping,you can use dataset identifiers instead of dataset Amazon Resource Names (ARNs) throughout the dashboard's sub-structures.</p>
    #[doc(hidden)]
    pub data_set_identifier_declarations:
        std::option::Option<std::vec::Vec<crate::model::DataSetIdentifierDeclaration>>,
    /// <p>An array of sheet definitions for a dashboard.</p>
    #[doc(hidden)]
    pub sheets: std::option::Option<std::vec::Vec<crate::model::SheetDefinition>>,
    /// <p>An array of calculated field definitions for the dashboard.</p>
    #[doc(hidden)]
    pub calculated_fields: std::option::Option<std::vec::Vec<crate::model::CalculatedField>>,
    /// <p>The parameter declarations for a dashboard. Parameters are named variables that can transfer a value for use by an action or an object.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html">Parameters in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub parameter_declarations:
        std::option::Option<std::vec::Vec<crate::model::ParameterDeclaration>>,
    /// <p>The filter definitions for a dashboard.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/adding-a-filter.html">Filtering Data in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub filter_groups: std::option::Option<std::vec::Vec<crate::model::FilterGroup>>,
    /// <p>An array of dashboard-level column configurations. Column configurations are used to set the default formatting for a column that is used throughout a dashboard. </p>
    #[doc(hidden)]
    pub column_configurations:
        std::option::Option<std::vec::Vec<crate::model::ColumnConfiguration>>,
    /// <p>The configuration for default analysis settings.</p>
    #[doc(hidden)]
    pub analysis_defaults: std::option::Option<crate::model::AnalysisDefaults>,
}
impl DashboardVersionDefinition {
    /// <p>An array of dataset identifier declarations. With this mapping,you can use dataset identifiers instead of dataset Amazon Resource Names (ARNs) throughout the dashboard's sub-structures.</p>
    pub fn data_set_identifier_declarations(
        &self,
    ) -> std::option::Option<&[crate::model::DataSetIdentifierDeclaration]> {
        self.data_set_identifier_declarations.as_deref()
    }
    /// <p>An array of sheet definitions for a dashboard.</p>
    pub fn sheets(&self) -> std::option::Option<&[crate::model::SheetDefinition]> {
        self.sheets.as_deref()
    }
    /// <p>An array of calculated field definitions for the dashboard.</p>
    pub fn calculated_fields(&self) -> std::option::Option<&[crate::model::CalculatedField]> {
        self.calculated_fields.as_deref()
    }
    /// <p>The parameter declarations for a dashboard. Parameters are named variables that can transfer a value for use by an action or an object.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html">Parameters in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn parameter_declarations(
        &self,
    ) -> std::option::Option<&[crate::model::ParameterDeclaration]> {
        self.parameter_declarations.as_deref()
    }
    /// <p>The filter definitions for a dashboard.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/adding-a-filter.html">Filtering Data in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn filter_groups(&self) -> std::option::Option<&[crate::model::FilterGroup]> {
        self.filter_groups.as_deref()
    }
    /// <p>An array of dashboard-level column configurations. Column configurations are used to set the default formatting for a column that is used throughout a dashboard. </p>
    pub fn column_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::ColumnConfiguration]> {
        self.column_configurations.as_deref()
    }
    /// <p>The configuration for default analysis settings.</p>
    pub fn analysis_defaults(&self) -> std::option::Option<&crate::model::AnalysisDefaults> {
        self.analysis_defaults.as_ref()
    }
}
/// See [`DashboardVersionDefinition`](crate::model::DashboardVersionDefinition).
pub mod dashboard_version_definition {

    /// A builder for [`DashboardVersionDefinition`](crate::model::DashboardVersionDefinition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_set_identifier_declarations:
            std::option::Option<std::vec::Vec<crate::model::DataSetIdentifierDeclaration>>,
        pub(crate) sheets: std::option::Option<std::vec::Vec<crate::model::SheetDefinition>>,
        pub(crate) calculated_fields:
            std::option::Option<std::vec::Vec<crate::model::CalculatedField>>,
        pub(crate) parameter_declarations:
            std::option::Option<std::vec::Vec<crate::model::ParameterDeclaration>>,
        pub(crate) filter_groups: std::option::Option<std::vec::Vec<crate::model::FilterGroup>>,
        pub(crate) column_configurations:
            std::option::Option<std::vec::Vec<crate::model::ColumnConfiguration>>,
        pub(crate) analysis_defaults: std::option::Option<crate::model::AnalysisDefaults>,
    }
    impl Builder {
        /// Appends an item to `data_set_identifier_declarations`.
        ///
        /// To override the contents of this collection use [`set_data_set_identifier_declarations`](Self::set_data_set_identifier_declarations).
        ///
        /// <p>An array of dataset identifier declarations. With this mapping,you can use dataset identifiers instead of dataset Amazon Resource Names (ARNs) throughout the dashboard's sub-structures.</p>
        pub fn data_set_identifier_declarations(
            mut self,
            input: crate::model::DataSetIdentifierDeclaration,
        ) -> Self {
            let mut v = self.data_set_identifier_declarations.unwrap_or_default();
            v.push(input);
            self.data_set_identifier_declarations = Some(v);
            self
        }
        /// <p>An array of dataset identifier declarations. With this mapping,you can use dataset identifiers instead of dataset Amazon Resource Names (ARNs) throughout the dashboard's sub-structures.</p>
        pub fn set_data_set_identifier_declarations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSetIdentifierDeclaration>>,
        ) -> Self {
            self.data_set_identifier_declarations = input;
            self
        }
        /// Appends an item to `sheets`.
        ///
        /// To override the contents of this collection use [`set_sheets`](Self::set_sheets).
        ///
        /// <p>An array of sheet definitions for a dashboard.</p>
        pub fn sheets(mut self, input: crate::model::SheetDefinition) -> Self {
            let mut v = self.sheets.unwrap_or_default();
            v.push(input);
            self.sheets = Some(v);
            self
        }
        /// <p>An array of sheet definitions for a dashboard.</p>
        pub fn set_sheets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SheetDefinition>>,
        ) -> Self {
            self.sheets = input;
            self
        }
        /// Appends an item to `calculated_fields`.
        ///
        /// To override the contents of this collection use [`set_calculated_fields`](Self::set_calculated_fields).
        ///
        /// <p>An array of calculated field definitions for the dashboard.</p>
        pub fn calculated_fields(mut self, input: crate::model::CalculatedField) -> Self {
            let mut v = self.calculated_fields.unwrap_or_default();
            v.push(input);
            self.calculated_fields = Some(v);
            self
        }
        /// <p>An array of calculated field definitions for the dashboard.</p>
        pub fn set_calculated_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CalculatedField>>,
        ) -> Self {
            self.calculated_fields = input;
            self
        }
        /// Appends an item to `parameter_declarations`.
        ///
        /// To override the contents of this collection use [`set_parameter_declarations`](Self::set_parameter_declarations).
        ///
        /// <p>The parameter declarations for a dashboard. Parameters are named variables that can transfer a value for use by an action or an object.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html">Parameters in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn parameter_declarations(mut self, input: crate::model::ParameterDeclaration) -> Self {
            let mut v = self.parameter_declarations.unwrap_or_default();
            v.push(input);
            self.parameter_declarations = Some(v);
            self
        }
        /// <p>The parameter declarations for a dashboard. Parameters are named variables that can transfer a value for use by an action or an object.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html">Parameters in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_parameter_declarations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ParameterDeclaration>>,
        ) -> Self {
            self.parameter_declarations = input;
            self
        }
        /// Appends an item to `filter_groups`.
        ///
        /// To override the contents of this collection use [`set_filter_groups`](Self::set_filter_groups).
        ///
        /// <p>The filter definitions for a dashboard.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/adding-a-filter.html">Filtering Data in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn filter_groups(mut self, input: crate::model::FilterGroup) -> Self {
            let mut v = self.filter_groups.unwrap_or_default();
            v.push(input);
            self.filter_groups = Some(v);
            self
        }
        /// <p>The filter definitions for a dashboard.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/adding-a-filter.html">Filtering Data in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_filter_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FilterGroup>>,
        ) -> Self {
            self.filter_groups = input;
            self
        }
        /// Appends an item to `column_configurations`.
        ///
        /// To override the contents of this collection use [`set_column_configurations`](Self::set_column_configurations).
        ///
        /// <p>An array of dashboard-level column configurations. Column configurations are used to set the default formatting for a column that is used throughout a dashboard. </p>
        pub fn column_configurations(mut self, input: crate::model::ColumnConfiguration) -> Self {
            let mut v = self.column_configurations.unwrap_or_default();
            v.push(input);
            self.column_configurations = Some(v);
            self
        }
        /// <p>An array of dashboard-level column configurations. Column configurations are used to set the default formatting for a column that is used throughout a dashboard. </p>
        pub fn set_column_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnConfiguration>>,
        ) -> Self {
            self.column_configurations = input;
            self
        }
        /// <p>The configuration for default analysis settings.</p>
        pub fn analysis_defaults(mut self, input: crate::model::AnalysisDefaults) -> Self {
            self.analysis_defaults = Some(input);
            self
        }
        /// <p>The configuration for default analysis settings.</p>
        pub fn set_analysis_defaults(
            mut self,
            input: std::option::Option<crate::model::AnalysisDefaults>,
        ) -> Self {
            self.analysis_defaults = input;
            self
        }
        /// Consumes the builder and constructs a [`DashboardVersionDefinition`](crate::model::DashboardVersionDefinition).
        pub fn build(self) -> crate::model::DashboardVersionDefinition {
            crate::model::DashboardVersionDefinition {
                data_set_identifier_declarations: self.data_set_identifier_declarations,
                sheets: self.sheets,
                calculated_fields: self.calculated_fields,
                parameter_declarations: self.parameter_declarations,
                filter_groups: self.filter_groups,
                column_configurations: self.column_configurations,
                analysis_defaults: self.analysis_defaults,
            }
        }
    }
}
impl DashboardVersionDefinition {
    /// Creates a new builder-style object to manufacture [`DashboardVersionDefinition`](crate::model::DashboardVersionDefinition).
    pub fn builder() -> crate::model::dashboard_version_definition::Builder {
        crate::model::dashboard_version_definition::Builder::default()
    }
}

/// <p>A data set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSetIdentifierDeclaration {
    /// <p>The identifier of the data set, typically the data set's name.</p>
    #[doc(hidden)]
    pub identifier: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the data set.</p>
    #[doc(hidden)]
    pub data_set_arn: std::option::Option<std::string::String>,
}
impl DataSetIdentifierDeclaration {
    /// <p>The identifier of the data set, typically the data set's name.</p>
    pub fn identifier(&self) -> std::option::Option<&str> {
        self.identifier.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the data set.</p>
    pub fn data_set_arn(&self) -> std::option::Option<&str> {
        self.data_set_arn.as_deref()
    }
}
/// See [`DataSetIdentifierDeclaration`](crate::model::DataSetIdentifierDeclaration).
pub mod data_set_identifier_declaration {

    /// A builder for [`DataSetIdentifierDeclaration`](crate::model::DataSetIdentifierDeclaration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identifier: std::option::Option<std::string::String>,
        pub(crate) data_set_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the data set, typically the data set's name.</p>
        pub fn identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.identifier = Some(input.into());
            self
        }
        /// <p>The identifier of the data set, typically the data set's name.</p>
        pub fn set_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identifier = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the data set.</p>
        pub fn data_set_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_set_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the data set.</p>
        pub fn set_data_set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_set_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSetIdentifierDeclaration`](crate::model::DataSetIdentifierDeclaration).
        pub fn build(self) -> crate::model::DataSetIdentifierDeclaration {
            crate::model::DataSetIdentifierDeclaration {
                identifier: self.identifier,
                data_set_arn: self.data_set_arn,
            }
        }
    }
}
impl DataSetIdentifierDeclaration {
    /// Creates a new builder-style object to manufacture [`DataSetIdentifierDeclaration`](crate::model::DataSetIdentifierDeclaration).
    pub fn builder() -> crate::model::data_set_identifier_declaration::Builder {
        crate::model::data_set_identifier_declaration::Builder::default()
    }
}

/// <p>Dashboard publish options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DashboardPublishOptions {
    /// <p>Ad hoc (one-time) filtering option.</p>
    #[doc(hidden)]
    pub ad_hoc_filtering_option: std::option::Option<crate::model::AdHocFilteringOption>,
    /// <p>Export to .csv option.</p>
    #[doc(hidden)]
    pub export_to_csv_option: std::option::Option<crate::model::ExportToCsvOption>,
    /// <p>Sheet controls option.</p>
    #[doc(hidden)]
    pub sheet_controls_option: std::option::Option<crate::model::SheetControlsOption>,
    /// <p></p>
    #[doc(hidden)]
    pub visual_publish_options: std::option::Option<crate::model::DashboardVisualPublishOptions>,
}
impl DashboardPublishOptions {
    /// <p>Ad hoc (one-time) filtering option.</p>
    pub fn ad_hoc_filtering_option(
        &self,
    ) -> std::option::Option<&crate::model::AdHocFilteringOption> {
        self.ad_hoc_filtering_option.as_ref()
    }
    /// <p>Export to .csv option.</p>
    pub fn export_to_csv_option(&self) -> std::option::Option<&crate::model::ExportToCsvOption> {
        self.export_to_csv_option.as_ref()
    }
    /// <p>Sheet controls option.</p>
    pub fn sheet_controls_option(&self) -> std::option::Option<&crate::model::SheetControlsOption> {
        self.sheet_controls_option.as_ref()
    }
    /// <p></p>
    pub fn visual_publish_options(
        &self,
    ) -> std::option::Option<&crate::model::DashboardVisualPublishOptions> {
        self.visual_publish_options.as_ref()
    }
}
/// See [`DashboardPublishOptions`](crate::model::DashboardPublishOptions).
pub mod dashboard_publish_options {

    /// A builder for [`DashboardPublishOptions`](crate::model::DashboardPublishOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ad_hoc_filtering_option: std::option::Option<crate::model::AdHocFilteringOption>,
        pub(crate) export_to_csv_option: std::option::Option<crate::model::ExportToCsvOption>,
        pub(crate) sheet_controls_option: std::option::Option<crate::model::SheetControlsOption>,
        pub(crate) visual_publish_options:
            std::option::Option<crate::model::DashboardVisualPublishOptions>,
    }
    impl Builder {
        /// <p>Ad hoc (one-time) filtering option.</p>
        pub fn ad_hoc_filtering_option(
            mut self,
            input: crate::model::AdHocFilteringOption,
        ) -> Self {
            self.ad_hoc_filtering_option = Some(input);
            self
        }
        /// <p>Ad hoc (one-time) filtering option.</p>
        pub fn set_ad_hoc_filtering_option(
            mut self,
            input: std::option::Option<crate::model::AdHocFilteringOption>,
        ) -> Self {
            self.ad_hoc_filtering_option = input;
            self
        }
        /// <p>Export to .csv option.</p>
        pub fn export_to_csv_option(mut self, input: crate::model::ExportToCsvOption) -> Self {
            self.export_to_csv_option = Some(input);
            self
        }
        /// <p>Export to .csv option.</p>
        pub fn set_export_to_csv_option(
            mut self,
            input: std::option::Option<crate::model::ExportToCsvOption>,
        ) -> Self {
            self.export_to_csv_option = input;
            self
        }
        /// <p>Sheet controls option.</p>
        pub fn sheet_controls_option(mut self, input: crate::model::SheetControlsOption) -> Self {
            self.sheet_controls_option = Some(input);
            self
        }
        /// <p>Sheet controls option.</p>
        pub fn set_sheet_controls_option(
            mut self,
            input: std::option::Option<crate::model::SheetControlsOption>,
        ) -> Self {
            self.sheet_controls_option = input;
            self
        }
        /// <p></p>
        pub fn visual_publish_options(
            mut self,
            input: crate::model::DashboardVisualPublishOptions,
        ) -> Self {
            self.visual_publish_options = Some(input);
            self
        }
        /// <p></p>
        pub fn set_visual_publish_options(
            mut self,
            input: std::option::Option<crate::model::DashboardVisualPublishOptions>,
        ) -> Self {
            self.visual_publish_options = input;
            self
        }
        /// Consumes the builder and constructs a [`DashboardPublishOptions`](crate::model::DashboardPublishOptions).
        pub fn build(self) -> crate::model::DashboardPublishOptions {
            crate::model::DashboardPublishOptions {
                ad_hoc_filtering_option: self.ad_hoc_filtering_option,
                export_to_csv_option: self.export_to_csv_option,
                sheet_controls_option: self.sheet_controls_option,
                visual_publish_options: self.visual_publish_options,
            }
        }
    }
}
impl DashboardPublishOptions {
    /// Creates a new builder-style object to manufacture [`DashboardPublishOptions`](crate::model::DashboardPublishOptions).
    pub fn builder() -> crate::model::dashboard_publish_options::Builder {
        crate::model::dashboard_publish_options::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DashboardVisualPublishOptions {
    /// <p></p>
    #[doc(hidden)]
    pub export_hidden_fields_option: std::option::Option<crate::model::ExportHiddenFieldsOption>,
}
impl DashboardVisualPublishOptions {
    /// <p></p>
    pub fn export_hidden_fields_option(
        &self,
    ) -> std::option::Option<&crate::model::ExportHiddenFieldsOption> {
        self.export_hidden_fields_option.as_ref()
    }
}
/// See [`DashboardVisualPublishOptions`](crate::model::DashboardVisualPublishOptions).
pub mod dashboard_visual_publish_options {

    /// A builder for [`DashboardVisualPublishOptions`](crate::model::DashboardVisualPublishOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) export_hidden_fields_option:
            std::option::Option<crate::model::ExportHiddenFieldsOption>,
    }
    impl Builder {
        /// <p></p>
        pub fn export_hidden_fields_option(
            mut self,
            input: crate::model::ExportHiddenFieldsOption,
        ) -> Self {
            self.export_hidden_fields_option = Some(input);
            self
        }
        /// <p></p>
        pub fn set_export_hidden_fields_option(
            mut self,
            input: std::option::Option<crate::model::ExportHiddenFieldsOption>,
        ) -> Self {
            self.export_hidden_fields_option = input;
            self
        }
        /// Consumes the builder and constructs a [`DashboardVisualPublishOptions`](crate::model::DashboardVisualPublishOptions).
        pub fn build(self) -> crate::model::DashboardVisualPublishOptions {
            crate::model::DashboardVisualPublishOptions {
                export_hidden_fields_option: self.export_hidden_fields_option,
            }
        }
    }
}
impl DashboardVisualPublishOptions {
    /// Creates a new builder-style object to manufacture [`DashboardVisualPublishOptions`](crate::model::DashboardVisualPublishOptions).
    pub fn builder() -> crate::model::dashboard_visual_publish_options::Builder {
        crate::model::dashboard_visual_publish_options::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExportHiddenFieldsOption {
    /// <p></p>
    #[doc(hidden)]
    pub availability_status: std::option::Option<crate::model::DashboardBehavior>,
}
impl ExportHiddenFieldsOption {
    /// <p></p>
    pub fn availability_status(&self) -> std::option::Option<&crate::model::DashboardBehavior> {
        self.availability_status.as_ref()
    }
}
/// See [`ExportHiddenFieldsOption`](crate::model::ExportHiddenFieldsOption).
pub mod export_hidden_fields_option {

    /// A builder for [`ExportHiddenFieldsOption`](crate::model::ExportHiddenFieldsOption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_status: std::option::Option<crate::model::DashboardBehavior>,
    }
    impl Builder {
        /// <p></p>
        pub fn availability_status(mut self, input: crate::model::DashboardBehavior) -> Self {
            self.availability_status = Some(input);
            self
        }
        /// <p></p>
        pub fn set_availability_status(
            mut self,
            input: std::option::Option<crate::model::DashboardBehavior>,
        ) -> Self {
            self.availability_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportHiddenFieldsOption`](crate::model::ExportHiddenFieldsOption).
        pub fn build(self) -> crate::model::ExportHiddenFieldsOption {
            crate::model::ExportHiddenFieldsOption {
                availability_status: self.availability_status,
            }
        }
    }
}
impl ExportHiddenFieldsOption {
    /// Creates a new builder-style object to manufacture [`ExportHiddenFieldsOption`](crate::model::ExportHiddenFieldsOption).
    pub fn builder() -> crate::model::export_hidden_fields_option::Builder {
        crate::model::export_hidden_fields_option::Builder::default()
    }
}

/// When writing a match expression against `DashboardBehavior`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let dashboardbehavior = unimplemented!();
/// match dashboardbehavior {
///     DashboardBehavior::Disabled => { /* ... */ },
///     DashboardBehavior::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `dashboardbehavior` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DashboardBehavior::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DashboardBehavior::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DashboardBehavior::NewFeature` is defined.
/// Specifically, when `dashboardbehavior` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DashboardBehavior::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DashboardBehavior {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DashboardBehavior {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => DashboardBehavior::Disabled,
            "ENABLED" => DashboardBehavior::Enabled,
            other => {
                DashboardBehavior::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DashboardBehavior {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DashboardBehavior::from(s))
    }
}
impl DashboardBehavior {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DashboardBehavior::Disabled => "DISABLED",
            DashboardBehavior::Enabled => "ENABLED",
            DashboardBehavior::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for DashboardBehavior {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Sheet controls option.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SheetControlsOption {
    /// <p>Visibility state.</p>
    #[doc(hidden)]
    pub visibility_state: std::option::Option<crate::model::DashboardUiState>,
}
impl SheetControlsOption {
    /// <p>Visibility state.</p>
    pub fn visibility_state(&self) -> std::option::Option<&crate::model::DashboardUiState> {
        self.visibility_state.as_ref()
    }
}
/// See [`SheetControlsOption`](crate::model::SheetControlsOption).
pub mod sheet_controls_option {

    /// A builder for [`SheetControlsOption`](crate::model::SheetControlsOption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) visibility_state: std::option::Option<crate::model::DashboardUiState>,
    }
    impl Builder {
        /// <p>Visibility state.</p>
        pub fn visibility_state(mut self, input: crate::model::DashboardUiState) -> Self {
            self.visibility_state = Some(input);
            self
        }
        /// <p>Visibility state.</p>
        pub fn set_visibility_state(
            mut self,
            input: std::option::Option<crate::model::DashboardUiState>,
        ) -> Self {
            self.visibility_state = input;
            self
        }
        /// Consumes the builder and constructs a [`SheetControlsOption`](crate::model::SheetControlsOption).
        pub fn build(self) -> crate::model::SheetControlsOption {
            crate::model::SheetControlsOption {
                visibility_state: self.visibility_state,
            }
        }
    }
}
impl SheetControlsOption {
    /// Creates a new builder-style object to manufacture [`SheetControlsOption`](crate::model::SheetControlsOption).
    pub fn builder() -> crate::model::sheet_controls_option::Builder {
        crate::model::sheet_controls_option::Builder::default()
    }
}

/// When writing a match expression against `DashboardUiState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let dashboarduistate = unimplemented!();
/// match dashboarduistate {
///     DashboardUiState::Collapsed => { /* ... */ },
///     DashboardUiState::Expanded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `dashboarduistate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DashboardUiState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DashboardUiState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DashboardUiState::NewFeature` is defined.
/// Specifically, when `dashboarduistate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DashboardUiState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DashboardUiState {
    #[allow(missing_docs)] // documentation missing in model
    Collapsed,
    #[allow(missing_docs)] // documentation missing in model
    Expanded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DashboardUiState {
    fn from(s: &str) -> Self {
        match s {
            "COLLAPSED" => DashboardUiState::Collapsed,
            "EXPANDED" => DashboardUiState::Expanded,
            other => DashboardUiState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DashboardUiState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DashboardUiState::from(s))
    }
}
impl DashboardUiState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DashboardUiState::Collapsed => "COLLAPSED",
            DashboardUiState::Expanded => "EXPANDED",
            DashboardUiState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COLLAPSED", "EXPANDED"]
    }
}
impl AsRef<str> for DashboardUiState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Export to .csv option.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExportToCsvOption {
    /// <p>Availability status.</p>
    #[doc(hidden)]
    pub availability_status: std::option::Option<crate::model::DashboardBehavior>,
}
impl ExportToCsvOption {
    /// <p>Availability status.</p>
    pub fn availability_status(&self) -> std::option::Option<&crate::model::DashboardBehavior> {
        self.availability_status.as_ref()
    }
}
/// See [`ExportToCsvOption`](crate::model::ExportToCsvOption).
pub mod export_to_csv_option {

    /// A builder for [`ExportToCsvOption`](crate::model::ExportToCsvOption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_status: std::option::Option<crate::model::DashboardBehavior>,
    }
    impl Builder {
        /// <p>Availability status.</p>
        pub fn availability_status(mut self, input: crate::model::DashboardBehavior) -> Self {
            self.availability_status = Some(input);
            self
        }
        /// <p>Availability status.</p>
        pub fn set_availability_status(
            mut self,
            input: std::option::Option<crate::model::DashboardBehavior>,
        ) -> Self {
            self.availability_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportToCsvOption`](crate::model::ExportToCsvOption).
        pub fn build(self) -> crate::model::ExportToCsvOption {
            crate::model::ExportToCsvOption {
                availability_status: self.availability_status,
            }
        }
    }
}
impl ExportToCsvOption {
    /// Creates a new builder-style object to manufacture [`ExportToCsvOption`](crate::model::ExportToCsvOption).
    pub fn builder() -> crate::model::export_to_csv_option::Builder {
        crate::model::export_to_csv_option::Builder::default()
    }
}

/// <p>An ad hoc (one-time) filtering option.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AdHocFilteringOption {
    /// <p>Availability status.</p>
    #[doc(hidden)]
    pub availability_status: std::option::Option<crate::model::DashboardBehavior>,
}
impl AdHocFilteringOption {
    /// <p>Availability status.</p>
    pub fn availability_status(&self) -> std::option::Option<&crate::model::DashboardBehavior> {
        self.availability_status.as_ref()
    }
}
/// See [`AdHocFilteringOption`](crate::model::AdHocFilteringOption).
pub mod ad_hoc_filtering_option {

    /// A builder for [`AdHocFilteringOption`](crate::model::AdHocFilteringOption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_status: std::option::Option<crate::model::DashboardBehavior>,
    }
    impl Builder {
        /// <p>Availability status.</p>
        pub fn availability_status(mut self, input: crate::model::DashboardBehavior) -> Self {
            self.availability_status = Some(input);
            self
        }
        /// <p>Availability status.</p>
        pub fn set_availability_status(
            mut self,
            input: std::option::Option<crate::model::DashboardBehavior>,
        ) -> Self {
            self.availability_status = input;
            self
        }
        /// Consumes the builder and constructs a [`AdHocFilteringOption`](crate::model::AdHocFilteringOption).
        pub fn build(self) -> crate::model::AdHocFilteringOption {
            crate::model::AdHocFilteringOption {
                availability_status: self.availability_status,
            }
        }
    }
}
impl AdHocFilteringOption {
    /// Creates a new builder-style object to manufacture [`AdHocFilteringOption`](crate::model::AdHocFilteringOption).
    pub fn builder() -> crate::model::ad_hoc_filtering_option::Builder {
        crate::model::ad_hoc_filtering_option::Builder::default()
    }
}

/// <p>A list of Amazon QuickSight parameters and the list's override values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Parameters {
    /// <p>The parameters that have a data type of string.</p>
    #[doc(hidden)]
    pub string_parameters: std::option::Option<std::vec::Vec<crate::model::StringParameter>>,
    /// <p>The parameters that have a data type of integer.</p>
    #[doc(hidden)]
    pub integer_parameters: std::option::Option<std::vec::Vec<crate::model::IntegerParameter>>,
    /// <p>The parameters that have a data type of decimal.</p>
    #[doc(hidden)]
    pub decimal_parameters: std::option::Option<std::vec::Vec<crate::model::DecimalParameter>>,
    /// <p>The parameters that have a data type of date-time.</p>
    #[doc(hidden)]
    pub date_time_parameters: std::option::Option<std::vec::Vec<crate::model::DateTimeParameter>>,
}
impl Parameters {
    /// <p>The parameters that have a data type of string.</p>
    pub fn string_parameters(&self) -> std::option::Option<&[crate::model::StringParameter]> {
        self.string_parameters.as_deref()
    }
    /// <p>The parameters that have a data type of integer.</p>
    pub fn integer_parameters(&self) -> std::option::Option<&[crate::model::IntegerParameter]> {
        self.integer_parameters.as_deref()
    }
    /// <p>The parameters that have a data type of decimal.</p>
    pub fn decimal_parameters(&self) -> std::option::Option<&[crate::model::DecimalParameter]> {
        self.decimal_parameters.as_deref()
    }
    /// <p>The parameters that have a data type of date-time.</p>
    pub fn date_time_parameters(&self) -> std::option::Option<&[crate::model::DateTimeParameter]> {
        self.date_time_parameters.as_deref()
    }
}
/// See [`Parameters`](crate::model::Parameters).
pub mod parameters {

    /// A builder for [`Parameters`](crate::model::Parameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) string_parameters:
            std::option::Option<std::vec::Vec<crate::model::StringParameter>>,
        pub(crate) integer_parameters:
            std::option::Option<std::vec::Vec<crate::model::IntegerParameter>>,
        pub(crate) decimal_parameters:
            std::option::Option<std::vec::Vec<crate::model::DecimalParameter>>,
        pub(crate) date_time_parameters:
            std::option::Option<std::vec::Vec<crate::model::DateTimeParameter>>,
    }
    impl Builder {
        /// Appends an item to `string_parameters`.
        ///
        /// To override the contents of this collection use [`set_string_parameters`](Self::set_string_parameters).
        ///
        /// <p>The parameters that have a data type of string.</p>
        pub fn string_parameters(mut self, input: crate::model::StringParameter) -> Self {
            let mut v = self.string_parameters.unwrap_or_default();
            v.push(input);
            self.string_parameters = Some(v);
            self
        }
        /// <p>The parameters that have a data type of string.</p>
        pub fn set_string_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StringParameter>>,
        ) -> Self {
            self.string_parameters = input;
            self
        }
        /// Appends an item to `integer_parameters`.
        ///
        /// To override the contents of this collection use [`set_integer_parameters`](Self::set_integer_parameters).
        ///
        /// <p>The parameters that have a data type of integer.</p>
        pub fn integer_parameters(mut self, input: crate::model::IntegerParameter) -> Self {
            let mut v = self.integer_parameters.unwrap_or_default();
            v.push(input);
            self.integer_parameters = Some(v);
            self
        }
        /// <p>The parameters that have a data type of integer.</p>
        pub fn set_integer_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IntegerParameter>>,
        ) -> Self {
            self.integer_parameters = input;
            self
        }
        /// Appends an item to `decimal_parameters`.
        ///
        /// To override the contents of this collection use [`set_decimal_parameters`](Self::set_decimal_parameters).
        ///
        /// <p>The parameters that have a data type of decimal.</p>
        pub fn decimal_parameters(mut self, input: crate::model::DecimalParameter) -> Self {
            let mut v = self.decimal_parameters.unwrap_or_default();
            v.push(input);
            self.decimal_parameters = Some(v);
            self
        }
        /// <p>The parameters that have a data type of decimal.</p>
        pub fn set_decimal_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DecimalParameter>>,
        ) -> Self {
            self.decimal_parameters = input;
            self
        }
        /// Appends an item to `date_time_parameters`.
        ///
        /// To override the contents of this collection use [`set_date_time_parameters`](Self::set_date_time_parameters).
        ///
        /// <p>The parameters that have a data type of date-time.</p>
        pub fn date_time_parameters(mut self, input: crate::model::DateTimeParameter) -> Self {
            let mut v = self.date_time_parameters.unwrap_or_default();
            v.push(input);
            self.date_time_parameters = Some(v);
            self
        }
        /// <p>The parameters that have a data type of date-time.</p>
        pub fn set_date_time_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DateTimeParameter>>,
        ) -> Self {
            self.date_time_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`Parameters`](crate::model::Parameters).
        pub fn build(self) -> crate::model::Parameters {
            crate::model::Parameters {
                string_parameters: self.string_parameters,
                integer_parameters: self.integer_parameters,
                decimal_parameters: self.decimal_parameters,
                date_time_parameters: self.date_time_parameters,
            }
        }
    }
}
impl Parameters {
    /// Creates a new builder-style object to manufacture [`Parameters`](crate::model::Parameters).
    pub fn builder() -> crate::model::parameters::Builder {
        crate::model::parameters::Builder::default()
    }
}

/// <p>A date-time parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DateTimeParameter {
    /// <p>A display name for the date-time parameter.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The values for the date-time parameter.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<aws_smithy_types::DateTime>>,
}
impl DateTimeParameter {
    /// <p>A display name for the date-time parameter.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The values for the date-time parameter.</p>
    pub fn values(&self) -> std::option::Option<&[aws_smithy_types::DateTime]> {
        self.values.as_deref()
    }
}
/// See [`DateTimeParameter`](crate::model::DateTimeParameter).
pub mod date_time_parameter {

    /// A builder for [`DateTimeParameter`](crate::model::DateTimeParameter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<aws_smithy_types::DateTime>>,
    }
    impl Builder {
        /// <p>A display name for the date-time parameter.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A display name for the date-time parameter.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The values for the date-time parameter.</p>
        pub fn values(mut self, input: aws_smithy_types::DateTime) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>The values for the date-time parameter.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<aws_smithy_types::DateTime>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`DateTimeParameter`](crate::model::DateTimeParameter).
        pub fn build(self) -> crate::model::DateTimeParameter {
            crate::model::DateTimeParameter {
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl DateTimeParameter {
    /// Creates a new builder-style object to manufacture [`DateTimeParameter`](crate::model::DateTimeParameter).
    pub fn builder() -> crate::model::date_time_parameter::Builder {
        crate::model::date_time_parameter::Builder::default()
    }
}

/// <p>A decimal parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DecimalParameter {
    /// <p>A display name for the decimal parameter.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The values for the decimal parameter.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<f64>>,
}
impl DecimalParameter {
    /// <p>A display name for the decimal parameter.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The values for the decimal parameter.</p>
    pub fn values(&self) -> std::option::Option<&[f64]> {
        self.values.as_deref()
    }
}
/// See [`DecimalParameter`](crate::model::DecimalParameter).
pub mod decimal_parameter {

    /// A builder for [`DecimalParameter`](crate::model::DecimalParameter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<f64>>,
    }
    impl Builder {
        /// <p>A display name for the decimal parameter.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A display name for the decimal parameter.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The values for the decimal parameter.</p>
        pub fn values(mut self, input: f64) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>The values for the decimal parameter.</p>
        pub fn set_values(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`DecimalParameter`](crate::model::DecimalParameter).
        pub fn build(self) -> crate::model::DecimalParameter {
            crate::model::DecimalParameter {
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl DecimalParameter {
    /// Creates a new builder-style object to manufacture [`DecimalParameter`](crate::model::DecimalParameter).
    pub fn builder() -> crate::model::decimal_parameter::Builder {
        crate::model::decimal_parameter::Builder::default()
    }
}

/// <p>An integer parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IntegerParameter {
    /// <p>The name of the integer parameter.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The values for the integer parameter.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<i64>>,
}
impl IntegerParameter {
    /// <p>The name of the integer parameter.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The values for the integer parameter.</p>
    pub fn values(&self) -> std::option::Option<&[i64]> {
        self.values.as_deref()
    }
}
/// See [`IntegerParameter`](crate::model::IntegerParameter).
pub mod integer_parameter {

    /// A builder for [`IntegerParameter`](crate::model::IntegerParameter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<i64>>,
    }
    impl Builder {
        /// <p>The name of the integer parameter.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the integer parameter.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The values for the integer parameter.</p>
        pub fn values(mut self, input: i64) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input);
            self.values = Some(v);
            self
        }
        /// <p>The values for the integer parameter.</p>
        pub fn set_values(mut self, input: std::option::Option<std::vec::Vec<i64>>) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`IntegerParameter`](crate::model::IntegerParameter).
        pub fn build(self) -> crate::model::IntegerParameter {
            crate::model::IntegerParameter {
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl IntegerParameter {
    /// Creates a new builder-style object to manufacture [`IntegerParameter`](crate::model::IntegerParameter).
    pub fn builder() -> crate::model::integer_parameter::Builder {
        crate::model::integer_parameter::Builder::default()
    }
}

/// <p>A string parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StringParameter {
    /// <p>A display name for a string parameter.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The values of a string parameter.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl StringParameter {
    /// <p>A display name for a string parameter.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The values of a string parameter.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
/// See [`StringParameter`](crate::model::StringParameter).
pub mod string_parameter {

    /// A builder for [`StringParameter`](crate::model::StringParameter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>A display name for a string parameter.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A display name for a string parameter.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The values of a string parameter.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>The values of a string parameter.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`StringParameter`](crate::model::StringParameter).
        pub fn build(self) -> crate::model::StringParameter {
            crate::model::StringParameter {
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl StringParameter {
    /// Creates a new builder-style object to manufacture [`StringParameter`](crate::model::StringParameter).
    pub fn builder() -> crate::model::string_parameter::Builder {
        crate::model::string_parameter::Builder::default()
    }
}

/// <p>Dashboard source entity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DashboardSourceEntity {
    /// <p>Source template.</p>
    #[doc(hidden)]
    pub source_template: std::option::Option<crate::model::DashboardSourceTemplate>,
}
impl DashboardSourceEntity {
    /// <p>Source template.</p>
    pub fn source_template(&self) -> std::option::Option<&crate::model::DashboardSourceTemplate> {
        self.source_template.as_ref()
    }
}
/// See [`DashboardSourceEntity`](crate::model::DashboardSourceEntity).
pub mod dashboard_source_entity {

    /// A builder for [`DashboardSourceEntity`](crate::model::DashboardSourceEntity).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_template: std::option::Option<crate::model::DashboardSourceTemplate>,
    }
    impl Builder {
        /// <p>Source template.</p>
        pub fn source_template(mut self, input: crate::model::DashboardSourceTemplate) -> Self {
            self.source_template = Some(input);
            self
        }
        /// <p>Source template.</p>
        pub fn set_source_template(
            mut self,
            input: std::option::Option<crate::model::DashboardSourceTemplate>,
        ) -> Self {
            self.source_template = input;
            self
        }
        /// Consumes the builder and constructs a [`DashboardSourceEntity`](crate::model::DashboardSourceEntity).
        pub fn build(self) -> crate::model::DashboardSourceEntity {
            crate::model::DashboardSourceEntity {
                source_template: self.source_template,
            }
        }
    }
}
impl DashboardSourceEntity {
    /// Creates a new builder-style object to manufacture [`DashboardSourceEntity`](crate::model::DashboardSourceEntity).
    pub fn builder() -> crate::model::dashboard_source_entity::Builder {
        crate::model::dashboard_source_entity::Builder::default()
    }
}

/// <p>Dashboard source template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DashboardSourceTemplate {
    /// <p>Dataset references.</p>
    #[doc(hidden)]
    pub data_set_references: std::option::Option<std::vec::Vec<crate::model::DataSetReference>>,
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl DashboardSourceTemplate {
    /// <p>Dataset references.</p>
    pub fn data_set_references(&self) -> std::option::Option<&[crate::model::DataSetReference]> {
        self.data_set_references.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
/// See [`DashboardSourceTemplate`](crate::model::DashboardSourceTemplate).
pub mod dashboard_source_template {

    /// A builder for [`DashboardSourceTemplate`](crate::model::DashboardSourceTemplate).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_set_references:
            std::option::Option<std::vec::Vec<crate::model::DataSetReference>>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `data_set_references`.
        ///
        /// To override the contents of this collection use [`set_data_set_references`](Self::set_data_set_references).
        ///
        /// <p>Dataset references.</p>
        pub fn data_set_references(mut self, input: crate::model::DataSetReference) -> Self {
            let mut v = self.data_set_references.unwrap_or_default();
            v.push(input);
            self.data_set_references = Some(v);
            self
        }
        /// <p>Dataset references.</p>
        pub fn set_data_set_references(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSetReference>>,
        ) -> Self {
            self.data_set_references = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DashboardSourceTemplate`](crate::model::DashboardSourceTemplate).
        pub fn build(self) -> crate::model::DashboardSourceTemplate {
            crate::model::DashboardSourceTemplate {
                data_set_references: self.data_set_references,
                arn: self.arn,
            }
        }
    }
}
impl DashboardSourceTemplate {
    /// Creates a new builder-style object to manufacture [`DashboardSourceTemplate`](crate::model::DashboardSourceTemplate).
    pub fn builder() -> crate::model::dashboard_source_template::Builder {
        crate::model::dashboard_source_template::Builder::default()
    }
}

/// <p>The definition of an analysis.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnalysisDefinition {
    /// <p>An array of dataset identifier declarations. This mapping allows the usage of dataset identifiers instead of dataset ARNs throughout analysis sub-structures.</p>
    #[doc(hidden)]
    pub data_set_identifier_declarations:
        std::option::Option<std::vec::Vec<crate::model::DataSetIdentifierDeclaration>>,
    /// <p>An array of sheet definitions for an analysis. Each <code>SheetDefinition</code> provides detailed information about a sheet within this analysis.</p>
    #[doc(hidden)]
    pub sheets: std::option::Option<std::vec::Vec<crate::model::SheetDefinition>>,
    /// <p>An array of calculated field definitions for the analysis.</p>
    #[doc(hidden)]
    pub calculated_fields: std::option::Option<std::vec::Vec<crate::model::CalculatedField>>,
    /// <p>An array of parameter declarations for an analysis.</p>
    /// <p>Parameters are named variables that can transfer a value for use by an action or an object.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html">Parameters in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub parameter_declarations:
        std::option::Option<std::vec::Vec<crate::model::ParameterDeclaration>>,
    /// <p>Filter definitions for an analysis.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/adding-a-filter.html">Filtering Data in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub filter_groups: std::option::Option<std::vec::Vec<crate::model::FilterGroup>>,
    /// <p> An array of analysis-level column configurations. Column configurations can be used to set default formatting for a column to be used throughout an analysis. </p>
    #[doc(hidden)]
    pub column_configurations:
        std::option::Option<std::vec::Vec<crate::model::ColumnConfiguration>>,
    /// <p>The configuration for default analysis settings.</p>
    #[doc(hidden)]
    pub analysis_defaults: std::option::Option<crate::model::AnalysisDefaults>,
}
impl AnalysisDefinition {
    /// <p>An array of dataset identifier declarations. This mapping allows the usage of dataset identifiers instead of dataset ARNs throughout analysis sub-structures.</p>
    pub fn data_set_identifier_declarations(
        &self,
    ) -> std::option::Option<&[crate::model::DataSetIdentifierDeclaration]> {
        self.data_set_identifier_declarations.as_deref()
    }
    /// <p>An array of sheet definitions for an analysis. Each <code>SheetDefinition</code> provides detailed information about a sheet within this analysis.</p>
    pub fn sheets(&self) -> std::option::Option<&[crate::model::SheetDefinition]> {
        self.sheets.as_deref()
    }
    /// <p>An array of calculated field definitions for the analysis.</p>
    pub fn calculated_fields(&self) -> std::option::Option<&[crate::model::CalculatedField]> {
        self.calculated_fields.as_deref()
    }
    /// <p>An array of parameter declarations for an analysis.</p>
    /// <p>Parameters are named variables that can transfer a value for use by an action or an object.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html">Parameters in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn parameter_declarations(
        &self,
    ) -> std::option::Option<&[crate::model::ParameterDeclaration]> {
        self.parameter_declarations.as_deref()
    }
    /// <p>Filter definitions for an analysis.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/adding-a-filter.html">Filtering Data in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn filter_groups(&self) -> std::option::Option<&[crate::model::FilterGroup]> {
        self.filter_groups.as_deref()
    }
    /// <p> An array of analysis-level column configurations. Column configurations can be used to set default formatting for a column to be used throughout an analysis. </p>
    pub fn column_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::ColumnConfiguration]> {
        self.column_configurations.as_deref()
    }
    /// <p>The configuration for default analysis settings.</p>
    pub fn analysis_defaults(&self) -> std::option::Option<&crate::model::AnalysisDefaults> {
        self.analysis_defaults.as_ref()
    }
}
/// See [`AnalysisDefinition`](crate::model::AnalysisDefinition).
pub mod analysis_definition {

    /// A builder for [`AnalysisDefinition`](crate::model::AnalysisDefinition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_set_identifier_declarations:
            std::option::Option<std::vec::Vec<crate::model::DataSetIdentifierDeclaration>>,
        pub(crate) sheets: std::option::Option<std::vec::Vec<crate::model::SheetDefinition>>,
        pub(crate) calculated_fields:
            std::option::Option<std::vec::Vec<crate::model::CalculatedField>>,
        pub(crate) parameter_declarations:
            std::option::Option<std::vec::Vec<crate::model::ParameterDeclaration>>,
        pub(crate) filter_groups: std::option::Option<std::vec::Vec<crate::model::FilterGroup>>,
        pub(crate) column_configurations:
            std::option::Option<std::vec::Vec<crate::model::ColumnConfiguration>>,
        pub(crate) analysis_defaults: std::option::Option<crate::model::AnalysisDefaults>,
    }
    impl Builder {
        /// Appends an item to `data_set_identifier_declarations`.
        ///
        /// To override the contents of this collection use [`set_data_set_identifier_declarations`](Self::set_data_set_identifier_declarations).
        ///
        /// <p>An array of dataset identifier declarations. This mapping allows the usage of dataset identifiers instead of dataset ARNs throughout analysis sub-structures.</p>
        pub fn data_set_identifier_declarations(
            mut self,
            input: crate::model::DataSetIdentifierDeclaration,
        ) -> Self {
            let mut v = self.data_set_identifier_declarations.unwrap_or_default();
            v.push(input);
            self.data_set_identifier_declarations = Some(v);
            self
        }
        /// <p>An array of dataset identifier declarations. This mapping allows the usage of dataset identifiers instead of dataset ARNs throughout analysis sub-structures.</p>
        pub fn set_data_set_identifier_declarations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSetIdentifierDeclaration>>,
        ) -> Self {
            self.data_set_identifier_declarations = input;
            self
        }
        /// Appends an item to `sheets`.
        ///
        /// To override the contents of this collection use [`set_sheets`](Self::set_sheets).
        ///
        /// <p>An array of sheet definitions for an analysis. Each <code>SheetDefinition</code> provides detailed information about a sheet within this analysis.</p>
        pub fn sheets(mut self, input: crate::model::SheetDefinition) -> Self {
            let mut v = self.sheets.unwrap_or_default();
            v.push(input);
            self.sheets = Some(v);
            self
        }
        /// <p>An array of sheet definitions for an analysis. Each <code>SheetDefinition</code> provides detailed information about a sheet within this analysis.</p>
        pub fn set_sheets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SheetDefinition>>,
        ) -> Self {
            self.sheets = input;
            self
        }
        /// Appends an item to `calculated_fields`.
        ///
        /// To override the contents of this collection use [`set_calculated_fields`](Self::set_calculated_fields).
        ///
        /// <p>An array of calculated field definitions for the analysis.</p>
        pub fn calculated_fields(mut self, input: crate::model::CalculatedField) -> Self {
            let mut v = self.calculated_fields.unwrap_or_default();
            v.push(input);
            self.calculated_fields = Some(v);
            self
        }
        /// <p>An array of calculated field definitions for the analysis.</p>
        pub fn set_calculated_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CalculatedField>>,
        ) -> Self {
            self.calculated_fields = input;
            self
        }
        /// Appends an item to `parameter_declarations`.
        ///
        /// To override the contents of this collection use [`set_parameter_declarations`](Self::set_parameter_declarations).
        ///
        /// <p>An array of parameter declarations for an analysis.</p>
        /// <p>Parameters are named variables that can transfer a value for use by an action or an object.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html">Parameters in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn parameter_declarations(mut self, input: crate::model::ParameterDeclaration) -> Self {
            let mut v = self.parameter_declarations.unwrap_or_default();
            v.push(input);
            self.parameter_declarations = Some(v);
            self
        }
        /// <p>An array of parameter declarations for an analysis.</p>
        /// <p>Parameters are named variables that can transfer a value for use by an action or an object.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html">Parameters in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_parameter_declarations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ParameterDeclaration>>,
        ) -> Self {
            self.parameter_declarations = input;
            self
        }
        /// Appends an item to `filter_groups`.
        ///
        /// To override the contents of this collection use [`set_filter_groups`](Self::set_filter_groups).
        ///
        /// <p>Filter definitions for an analysis.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/adding-a-filter.html">Filtering Data in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn filter_groups(mut self, input: crate::model::FilterGroup) -> Self {
            let mut v = self.filter_groups.unwrap_or_default();
            v.push(input);
            self.filter_groups = Some(v);
            self
        }
        /// <p>Filter definitions for an analysis.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/adding-a-filter.html">Filtering Data in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_filter_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FilterGroup>>,
        ) -> Self {
            self.filter_groups = input;
            self
        }
        /// Appends an item to `column_configurations`.
        ///
        /// To override the contents of this collection use [`set_column_configurations`](Self::set_column_configurations).
        ///
        /// <p> An array of analysis-level column configurations. Column configurations can be used to set default formatting for a column to be used throughout an analysis. </p>
        pub fn column_configurations(mut self, input: crate::model::ColumnConfiguration) -> Self {
            let mut v = self.column_configurations.unwrap_or_default();
            v.push(input);
            self.column_configurations = Some(v);
            self
        }
        /// <p> An array of analysis-level column configurations. Column configurations can be used to set default formatting for a column to be used throughout an analysis. </p>
        pub fn set_column_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnConfiguration>>,
        ) -> Self {
            self.column_configurations = input;
            self
        }
        /// <p>The configuration for default analysis settings.</p>
        pub fn analysis_defaults(mut self, input: crate::model::AnalysisDefaults) -> Self {
            self.analysis_defaults = Some(input);
            self
        }
        /// <p>The configuration for default analysis settings.</p>
        pub fn set_analysis_defaults(
            mut self,
            input: std::option::Option<crate::model::AnalysisDefaults>,
        ) -> Self {
            self.analysis_defaults = input;
            self
        }
        /// Consumes the builder and constructs a [`AnalysisDefinition`](crate::model::AnalysisDefinition).
        pub fn build(self) -> crate::model::AnalysisDefinition {
            crate::model::AnalysisDefinition {
                data_set_identifier_declarations: self.data_set_identifier_declarations,
                sheets: self.sheets,
                calculated_fields: self.calculated_fields,
                parameter_declarations: self.parameter_declarations,
                filter_groups: self.filter_groups,
                column_configurations: self.column_configurations,
                analysis_defaults: self.analysis_defaults,
            }
        }
    }
}
impl AnalysisDefinition {
    /// Creates a new builder-style object to manufacture [`AnalysisDefinition`](crate::model::AnalysisDefinition).
    pub fn builder() -> crate::model::analysis_definition::Builder {
        crate::model::analysis_definition::Builder::default()
    }
}

/// <p>The source entity of an analysis.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnalysisSourceEntity {
    /// <p>The source template for the source entity of the analysis.</p>
    #[doc(hidden)]
    pub source_template: std::option::Option<crate::model::AnalysisSourceTemplate>,
}
impl AnalysisSourceEntity {
    /// <p>The source template for the source entity of the analysis.</p>
    pub fn source_template(&self) -> std::option::Option<&crate::model::AnalysisSourceTemplate> {
        self.source_template.as_ref()
    }
}
/// See [`AnalysisSourceEntity`](crate::model::AnalysisSourceEntity).
pub mod analysis_source_entity {

    /// A builder for [`AnalysisSourceEntity`](crate::model::AnalysisSourceEntity).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_template: std::option::Option<crate::model::AnalysisSourceTemplate>,
    }
    impl Builder {
        /// <p>The source template for the source entity of the analysis.</p>
        pub fn source_template(mut self, input: crate::model::AnalysisSourceTemplate) -> Self {
            self.source_template = Some(input);
            self
        }
        /// <p>The source template for the source entity of the analysis.</p>
        pub fn set_source_template(
            mut self,
            input: std::option::Option<crate::model::AnalysisSourceTemplate>,
        ) -> Self {
            self.source_template = input;
            self
        }
        /// Consumes the builder and constructs a [`AnalysisSourceEntity`](crate::model::AnalysisSourceEntity).
        pub fn build(self) -> crate::model::AnalysisSourceEntity {
            crate::model::AnalysisSourceEntity {
                source_template: self.source_template,
            }
        }
    }
}
impl AnalysisSourceEntity {
    /// Creates a new builder-style object to manufacture [`AnalysisSourceEntity`](crate::model::AnalysisSourceEntity).
    pub fn builder() -> crate::model::analysis_source_entity::Builder {
        crate::model::analysis_source_entity::Builder::default()
    }
}

/// <p>The source template of an analysis.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnalysisSourceTemplate {
    /// <p>The dataset references of the source template of an analysis.</p>
    #[doc(hidden)]
    pub data_set_references: std::option::Option<std::vec::Vec<crate::model::DataSetReference>>,
    /// <p>The Amazon Resource Name (ARN) of the source template of an analysis.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl AnalysisSourceTemplate {
    /// <p>The dataset references of the source template of an analysis.</p>
    pub fn data_set_references(&self) -> std::option::Option<&[crate::model::DataSetReference]> {
        self.data_set_references.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the source template of an analysis.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
/// See [`AnalysisSourceTemplate`](crate::model::AnalysisSourceTemplate).
pub mod analysis_source_template {

    /// A builder for [`AnalysisSourceTemplate`](crate::model::AnalysisSourceTemplate).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_set_references:
            std::option::Option<std::vec::Vec<crate::model::DataSetReference>>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `data_set_references`.
        ///
        /// To override the contents of this collection use [`set_data_set_references`](Self::set_data_set_references).
        ///
        /// <p>The dataset references of the source template of an analysis.</p>
        pub fn data_set_references(mut self, input: crate::model::DataSetReference) -> Self {
            let mut v = self.data_set_references.unwrap_or_default();
            v.push(input);
            self.data_set_references = Some(v);
            self
        }
        /// <p>The dataset references of the source template of an analysis.</p>
        pub fn set_data_set_references(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSetReference>>,
        ) -> Self {
            self.data_set_references = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the source template of an analysis.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the source template of an analysis.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AnalysisSourceTemplate`](crate::model::AnalysisSourceTemplate).
        pub fn build(self) -> crate::model::AnalysisSourceTemplate {
            crate::model::AnalysisSourceTemplate {
                data_set_references: self.data_set_references,
                arn: self.arn,
            }
        }
    }
}
impl AnalysisSourceTemplate {
    /// Creates a new builder-style object to manufacture [`AnalysisSourceTemplate`](crate::model::AnalysisSourceTemplate).
    pub fn builder() -> crate::model::analysis_source_template::Builder {
        crate::model::analysis_source_template::Builder::default()
    }
}

/// <p>The Amazon QuickSight customizations associated with your Amazon Web Services account or a QuickSight namespace in a specific Amazon Web Services Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccountCustomization {
    /// <p>The default theme for this Amazon QuickSight subscription.</p>
    #[doc(hidden)]
    pub default_theme: std::option::Option<std::string::String>,
    /// <p>The default email customization template.</p>
    #[doc(hidden)]
    pub default_email_customization_template: std::option::Option<std::string::String>,
}
impl AccountCustomization {
    /// <p>The default theme for this Amazon QuickSight subscription.</p>
    pub fn default_theme(&self) -> std::option::Option<&str> {
        self.default_theme.as_deref()
    }
    /// <p>The default email customization template.</p>
    pub fn default_email_customization_template(&self) -> std::option::Option<&str> {
        self.default_email_customization_template.as_deref()
    }
}
/// See [`AccountCustomization`](crate::model::AccountCustomization).
pub mod account_customization {

    /// A builder for [`AccountCustomization`](crate::model::AccountCustomization).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) default_theme: std::option::Option<std::string::String>,
        pub(crate) default_email_customization_template: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The default theme for this Amazon QuickSight subscription.</p>
        pub fn default_theme(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_theme = Some(input.into());
            self
        }
        /// <p>The default theme for this Amazon QuickSight subscription.</p>
        pub fn set_default_theme(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_theme = input;
            self
        }
        /// <p>The default email customization template.</p>
        pub fn default_email_customization_template(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.default_email_customization_template = Some(input.into());
            self
        }
        /// <p>The default email customization template.</p>
        pub fn set_default_email_customization_template(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_email_customization_template = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountCustomization`](crate::model::AccountCustomization).
        pub fn build(self) -> crate::model::AccountCustomization {
            crate::model::AccountCustomization {
                default_theme: self.default_theme,
                default_email_customization_template: self.default_email_customization_template,
            }
        }
    }
}
impl AccountCustomization {
    /// Creates a new builder-style object to manufacture [`AccountCustomization`](crate::model::AccountCustomization).
    pub fn builder() -> crate::model::account_customization::Builder {
        crate::model::account_customization::Builder::default()
    }
}

/// <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tag {
    /// <p>Tag key.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>Tag value.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>Tag key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>Tag value.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Tag key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>Tag key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Tag value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>Tag value.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>A <code>GroupSearchFilter</code> object that you want to apply to your search.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GroupSearchFilter {
    /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StartsWith"</code>. Currently, the only supported operator is <code>StartsWith</code>.</p>
    #[doc(hidden)]
    pub operator: std::option::Option<crate::model::GroupFilterOperator>,
    /// <p>The name of the value that you want to use as a filter, for example <code>"Name": "GROUP_NAME"</code>. Currently, the only supported name is <code>GROUP_NAME</code>.</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::GroupFilterAttribute>,
    /// <p>The value of the named item, in this case <code>GROUP_NAME</code>, that you want to use as a filter.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl GroupSearchFilter {
    /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StartsWith"</code>. Currently, the only supported operator is <code>StartsWith</code>.</p>
    pub fn operator(&self) -> std::option::Option<&crate::model::GroupFilterOperator> {
        self.operator.as_ref()
    }
    /// <p>The name of the value that you want to use as a filter, for example <code>"Name": "GROUP_NAME"</code>. Currently, the only supported name is <code>GROUP_NAME</code>.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::GroupFilterAttribute> {
        self.name.as_ref()
    }
    /// <p>The value of the named item, in this case <code>GROUP_NAME</code>, that you want to use as a filter.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`GroupSearchFilter`](crate::model::GroupSearchFilter).
pub mod group_search_filter {

    /// A builder for [`GroupSearchFilter`](crate::model::GroupSearchFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) operator: std::option::Option<crate::model::GroupFilterOperator>,
        pub(crate) name: std::option::Option<crate::model::GroupFilterAttribute>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StartsWith"</code>. Currently, the only supported operator is <code>StartsWith</code>.</p>
        pub fn operator(mut self, input: crate::model::GroupFilterOperator) -> Self {
            self.operator = Some(input);
            self
        }
        /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StartsWith"</code>. Currently, the only supported operator is <code>StartsWith</code>.</p>
        pub fn set_operator(
            mut self,
            input: std::option::Option<crate::model::GroupFilterOperator>,
        ) -> Self {
            self.operator = input;
            self
        }
        /// <p>The name of the value that you want to use as a filter, for example <code>"Name": "GROUP_NAME"</code>. Currently, the only supported name is <code>GROUP_NAME</code>.</p>
        pub fn name(mut self, input: crate::model::GroupFilterAttribute) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the value that you want to use as a filter, for example <code>"Name": "GROUP_NAME"</code>. Currently, the only supported name is <code>GROUP_NAME</code>.</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::GroupFilterAttribute>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of the named item, in this case <code>GROUP_NAME</code>, that you want to use as a filter.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the named item, in this case <code>GROUP_NAME</code>, that you want to use as a filter.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`GroupSearchFilter`](crate::model::GroupSearchFilter).
        pub fn build(self) -> crate::model::GroupSearchFilter {
            crate::model::GroupSearchFilter {
                operator: self.operator,
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl GroupSearchFilter {
    /// Creates a new builder-style object to manufacture [`GroupSearchFilter`](crate::model::GroupSearchFilter).
    pub fn builder() -> crate::model::group_search_filter::Builder {
        crate::model::group_search_filter::Builder::default()
    }
}

/// When writing a match expression against `GroupFilterAttribute`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let groupfilterattribute = unimplemented!();
/// match groupfilterattribute {
///     GroupFilterAttribute::GroupName => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `groupfilterattribute` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `GroupFilterAttribute::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `GroupFilterAttribute::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `GroupFilterAttribute::NewFeature` is defined.
/// Specifically, when `groupfilterattribute` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `GroupFilterAttribute::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GroupFilterAttribute {
    #[allow(missing_docs)] // documentation missing in model
    GroupName,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for GroupFilterAttribute {
    fn from(s: &str) -> Self {
        match s {
            "GROUP_NAME" => GroupFilterAttribute::GroupName,
            other => {
                GroupFilterAttribute::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for GroupFilterAttribute {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(GroupFilterAttribute::from(s))
    }
}
impl GroupFilterAttribute {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            GroupFilterAttribute::GroupName => "GROUP_NAME",
            GroupFilterAttribute::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["GROUP_NAME"]
    }
}
impl AsRef<str> for GroupFilterAttribute {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `GroupFilterOperator`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let groupfilteroperator = unimplemented!();
/// match groupfilteroperator {
///     GroupFilterOperator::StartsWith => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `groupfilteroperator` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `GroupFilterOperator::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `GroupFilterOperator::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `GroupFilterOperator::NewFeature` is defined.
/// Specifically, when `groupfilteroperator` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `GroupFilterOperator::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GroupFilterOperator {
    #[allow(missing_docs)] // documentation missing in model
    StartsWith,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for GroupFilterOperator {
    fn from(s: &str) -> Self {
        match s {
            "StartsWith" => GroupFilterOperator::StartsWith,
            other => {
                GroupFilterOperator::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for GroupFilterOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(GroupFilterOperator::from(s))
    }
}
impl GroupFilterOperator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            GroupFilterOperator::StartsWith => "StartsWith",
            GroupFilterOperator::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["StartsWith"]
    }
}
impl AsRef<str> for GroupFilterOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A summary of information about an existing Amazon QuickSight folder. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FolderSummary {
    /// <p>The Amazon Resource Name (ARN) of the folder.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ID of the folder.</p>
    #[doc(hidden)]
    pub folder_id: std::option::Option<std::string::String>,
    /// <p>The display name of the folder.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of folder.</p>
    #[doc(hidden)]
    pub folder_type: std::option::Option<crate::model::FolderType>,
    /// <p>The time that the folder was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the folder was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl FolderSummary {
    /// <p>The Amazon Resource Name (ARN) of the folder.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The ID of the folder.</p>
    pub fn folder_id(&self) -> std::option::Option<&str> {
        self.folder_id.as_deref()
    }
    /// <p>The display name of the folder.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of folder.</p>
    pub fn folder_type(&self) -> std::option::Option<&crate::model::FolderType> {
        self.folder_type.as_ref()
    }
    /// <p>The time that the folder was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The time that the folder was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
}
/// See [`FolderSummary`](crate::model::FolderSummary).
pub mod folder_summary {

    /// A builder for [`FolderSummary`](crate::model::FolderSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) folder_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) folder_type: std::option::Option<crate::model::FolderType>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the folder.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the folder.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ID of the folder.</p>
        pub fn folder_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.folder_id = Some(input.into());
            self
        }
        /// <p>The ID of the folder.</p>
        pub fn set_folder_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.folder_id = input;
            self
        }
        /// <p>The display name of the folder.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The display name of the folder.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of folder.</p>
        pub fn folder_type(mut self, input: crate::model::FolderType) -> Self {
            self.folder_type = Some(input);
            self
        }
        /// <p>The type of folder.</p>
        pub fn set_folder_type(
            mut self,
            input: std::option::Option<crate::model::FolderType>,
        ) -> Self {
            self.folder_type = input;
            self
        }
        /// <p>The time that the folder was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The time that the folder was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The time that the folder was last updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The time that the folder was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// Consumes the builder and constructs a [`FolderSummary`](crate::model::FolderSummary).
        pub fn build(self) -> crate::model::FolderSummary {
            crate::model::FolderSummary {
                arn: self.arn,
                folder_id: self.folder_id,
                name: self.name,
                folder_type: self.folder_type,
                created_time: self.created_time,
                last_updated_time: self.last_updated_time,
            }
        }
    }
}
impl FolderSummary {
    /// Creates a new builder-style object to manufacture [`FolderSummary`](crate::model::FolderSummary).
    pub fn builder() -> crate::model::folder_summary::Builder {
        crate::model::folder_summary::Builder::default()
    }
}

/// When writing a match expression against `FolderType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let foldertype = unimplemented!();
/// match foldertype {
///     FolderType::Shared => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `foldertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FolderType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FolderType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FolderType::NewFeature` is defined.
/// Specifically, when `foldertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FolderType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FolderType {
    #[allow(missing_docs)] // documentation missing in model
    Shared,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FolderType {
    fn from(s: &str) -> Self {
        match s {
            "SHARED" => FolderType::Shared,
            other => FolderType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FolderType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FolderType::from(s))
    }
}
impl FolderType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FolderType::Shared => "SHARED",
            FolderType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SHARED"]
    }
}
impl AsRef<str> for FolderType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A filter to use to search an Amazon QuickSight folder.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FolderSearchFilter {
    /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
    /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose folders you want to search in the <code>"Value"</code> field. For example, <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
    /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the folders you are searching for. For example, <code>"Name":"FOLDER_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>FOLDER_NAME</code>.</p>
    #[doc(hidden)]
    pub operator: std::option::Option<crate::model::FilterOperator>,
    /// <p>The name of a value that you want to use in the filter. For example, <code>"Name": "QUICKSIGHT_OWNER"</code>.</p>
    /// <p>Valid values are defined as follows:</p>
    /// <ul>
    /// <li> <p> <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as one of the folder's owners or viewers are returned. Implicit permissions from folders or groups are considered.</p> </li>
    /// <li> <p> <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners of the folders are returned. Implicit permissions from folders or groups are considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as the only owner of the folder are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners of the folders are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners or viewers of the folders are returned. Implicit permissions from folders or groups are not considered. </p> </li>
    /// <li> <p> <code>FOLDER_NAME</code>: Any folders whose names have a substring match to this value will be returned.</p> </li>
    /// <li> <p> <code>PARENT_FOLDER_ARN</code>: Provide an ARN of a folder, and any folders that are directly under that parent folder are returned. If you choose to use this option and leave the value blank, all root-level folders in the account are returned. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::FolderFilterAttribute>,
    /// <p>The value of the named item (in this example, <code>PARENT_FOLDER_ARN</code>), that you want to use as a filter. For example, <code>"Value": "arn:aws:quicksight:us-east-1:1:folder/folderId"</code>.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl FolderSearchFilter {
    /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
    /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose folders you want to search in the <code>"Value"</code> field. For example, <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
    /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the folders you are searching for. For example, <code>"Name":"FOLDER_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>FOLDER_NAME</code>.</p>
    pub fn operator(&self) -> std::option::Option<&crate::model::FilterOperator> {
        self.operator.as_ref()
    }
    /// <p>The name of a value that you want to use in the filter. For example, <code>"Name": "QUICKSIGHT_OWNER"</code>.</p>
    /// <p>Valid values are defined as follows:</p>
    /// <ul>
    /// <li> <p> <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as one of the folder's owners or viewers are returned. Implicit permissions from folders or groups are considered.</p> </li>
    /// <li> <p> <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners of the folders are returned. Implicit permissions from folders or groups are considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as the only owner of the folder are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners of the folders are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners or viewers of the folders are returned. Implicit permissions from folders or groups are not considered. </p> </li>
    /// <li> <p> <code>FOLDER_NAME</code>: Any folders whose names have a substring match to this value will be returned.</p> </li>
    /// <li> <p> <code>PARENT_FOLDER_ARN</code>: Provide an ARN of a folder, and any folders that are directly under that parent folder are returned. If you choose to use this option and leave the value blank, all root-level folders in the account are returned. </p> </li>
    /// </ul>
    pub fn name(&self) -> std::option::Option<&crate::model::FolderFilterAttribute> {
        self.name.as_ref()
    }
    /// <p>The value of the named item (in this example, <code>PARENT_FOLDER_ARN</code>), that you want to use as a filter. For example, <code>"Value": "arn:aws:quicksight:us-east-1:1:folder/folderId"</code>.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`FolderSearchFilter`](crate::model::FolderSearchFilter).
pub mod folder_search_filter {

    /// A builder for [`FolderSearchFilter`](crate::model::FolderSearchFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) operator: std::option::Option<crate::model::FilterOperator>,
        pub(crate) name: std::option::Option<crate::model::FolderFilterAttribute>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
        /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose folders you want to search in the <code>"Value"</code> field. For example, <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
        /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the folders you are searching for. For example, <code>"Name":"FOLDER_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>FOLDER_NAME</code>.</p>
        pub fn operator(mut self, input: crate::model::FilterOperator) -> Self {
            self.operator = Some(input);
            self
        }
        /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
        /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose folders you want to search in the <code>"Value"</code> field. For example, <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
        /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the folders you are searching for. For example, <code>"Name":"FOLDER_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>FOLDER_NAME</code>.</p>
        pub fn set_operator(
            mut self,
            input: std::option::Option<crate::model::FilterOperator>,
        ) -> Self {
            self.operator = input;
            self
        }
        /// <p>The name of a value that you want to use in the filter. For example, <code>"Name": "QUICKSIGHT_OWNER"</code>.</p>
        /// <p>Valid values are defined as follows:</p>
        /// <ul>
        /// <li> <p> <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as one of the folder's owners or viewers are returned. Implicit permissions from folders or groups are considered.</p> </li>
        /// <li> <p> <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners of the folders are returned. Implicit permissions from folders or groups are considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as the only owner of the folder are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners of the folders are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners or viewers of the folders are returned. Implicit permissions from folders or groups are not considered. </p> </li>
        /// <li> <p> <code>FOLDER_NAME</code>: Any folders whose names have a substring match to this value will be returned.</p> </li>
        /// <li> <p> <code>PARENT_FOLDER_ARN</code>: Provide an ARN of a folder, and any folders that are directly under that parent folder are returned. If you choose to use this option and leave the value blank, all root-level folders in the account are returned. </p> </li>
        /// </ul>
        pub fn name(mut self, input: crate::model::FolderFilterAttribute) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of a value that you want to use in the filter. For example, <code>"Name": "QUICKSIGHT_OWNER"</code>.</p>
        /// <p>Valid values are defined as follows:</p>
        /// <ul>
        /// <li> <p> <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as one of the folder's owners or viewers are returned. Implicit permissions from folders or groups are considered.</p> </li>
        /// <li> <p> <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners of the folders are returned. Implicit permissions from folders or groups are considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as the only owner of the folder are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners of the folders are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners or viewers of the folders are returned. Implicit permissions from folders or groups are not considered. </p> </li>
        /// <li> <p> <code>FOLDER_NAME</code>: Any folders whose names have a substring match to this value will be returned.</p> </li>
        /// <li> <p> <code>PARENT_FOLDER_ARN</code>: Provide an ARN of a folder, and any folders that are directly under that parent folder are returned. If you choose to use this option and leave the value blank, all root-level folders in the account are returned. </p> </li>
        /// </ul>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::FolderFilterAttribute>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of the named item (in this example, <code>PARENT_FOLDER_ARN</code>), that you want to use as a filter. For example, <code>"Value": "arn:aws:quicksight:us-east-1:1:folder/folderId"</code>.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the named item (in this example, <code>PARENT_FOLDER_ARN</code>), that you want to use as a filter. For example, <code>"Value": "arn:aws:quicksight:us-east-1:1:folder/folderId"</code>.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`FolderSearchFilter`](crate::model::FolderSearchFilter).
        pub fn build(self) -> crate::model::FolderSearchFilter {
            crate::model::FolderSearchFilter {
                operator: self.operator,
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl FolderSearchFilter {
    /// Creates a new builder-style object to manufacture [`FolderSearchFilter`](crate::model::FolderSearchFilter).
    pub fn builder() -> crate::model::folder_search_filter::Builder {
        crate::model::folder_search_filter::Builder::default()
    }
}

/// When writing a match expression against `FolderFilterAttribute`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let folderfilterattribute = unimplemented!();
/// match folderfilterattribute {
///     FolderFilterAttribute::DirectQuicksightOwner => { /* ... */ },
///     FolderFilterAttribute::DirectQuicksightSoleOwner => { /* ... */ },
///     FolderFilterAttribute::DirectQuicksightViewerOrOwner => { /* ... */ },
///     FolderFilterAttribute::FolderName => { /* ... */ },
///     FolderFilterAttribute::ParentFolderArn => { /* ... */ },
///     FolderFilterAttribute::QuicksightOwner => { /* ... */ },
///     FolderFilterAttribute::QuicksightViewerOrOwner => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `folderfilterattribute` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FolderFilterAttribute::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FolderFilterAttribute::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FolderFilterAttribute::NewFeature` is defined.
/// Specifically, when `folderfilterattribute` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FolderFilterAttribute::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FolderFilterAttribute {
    #[allow(missing_docs)] // documentation missing in model
    DirectQuicksightOwner,
    #[allow(missing_docs)] // documentation missing in model
    DirectQuicksightSoleOwner,
    #[allow(missing_docs)] // documentation missing in model
    DirectQuicksightViewerOrOwner,
    #[allow(missing_docs)] // documentation missing in model
    FolderName,
    #[allow(missing_docs)] // documentation missing in model
    ParentFolderArn,
    #[allow(missing_docs)] // documentation missing in model
    QuicksightOwner,
    #[allow(missing_docs)] // documentation missing in model
    QuicksightViewerOrOwner,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FolderFilterAttribute {
    fn from(s: &str) -> Self {
        match s {
            "DIRECT_QUICKSIGHT_OWNER" => FolderFilterAttribute::DirectQuicksightOwner,
            "DIRECT_QUICKSIGHT_SOLE_OWNER" => FolderFilterAttribute::DirectQuicksightSoleOwner,
            "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER" => {
                FolderFilterAttribute::DirectQuicksightViewerOrOwner
            }
            "FOLDER_NAME" => FolderFilterAttribute::FolderName,
            "PARENT_FOLDER_ARN" => FolderFilterAttribute::ParentFolderArn,
            "QUICKSIGHT_OWNER" => FolderFilterAttribute::QuicksightOwner,
            "QUICKSIGHT_VIEWER_OR_OWNER" => FolderFilterAttribute::QuicksightViewerOrOwner,
            other => {
                FolderFilterAttribute::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for FolderFilterAttribute {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FolderFilterAttribute::from(s))
    }
}
impl FolderFilterAttribute {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FolderFilterAttribute::DirectQuicksightOwner => "DIRECT_QUICKSIGHT_OWNER",
            FolderFilterAttribute::DirectQuicksightSoleOwner => "DIRECT_QUICKSIGHT_SOLE_OWNER",
            FolderFilterAttribute::DirectQuicksightViewerOrOwner => {
                "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
            }
            FolderFilterAttribute::FolderName => "FOLDER_NAME",
            FolderFilterAttribute::ParentFolderArn => "PARENT_FOLDER_ARN",
            FolderFilterAttribute::QuicksightOwner => "QUICKSIGHT_OWNER",
            FolderFilterAttribute::QuicksightViewerOrOwner => "QUICKSIGHT_VIEWER_OR_OWNER",
            FolderFilterAttribute::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DIRECT_QUICKSIGHT_OWNER",
            "DIRECT_QUICKSIGHT_SOLE_OWNER",
            "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER",
            "FOLDER_NAME",
            "PARENT_FOLDER_ARN",
            "QUICKSIGHT_OWNER",
            "QUICKSIGHT_VIEWER_OR_OWNER",
        ]
    }
}
impl AsRef<str> for FolderFilterAttribute {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `FilterOperator`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let filteroperator = unimplemented!();
/// match filteroperator {
///     FilterOperator::StringEquals => { /* ... */ },
///     FilterOperator::StringLike => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `filteroperator` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FilterOperator::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FilterOperator::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FilterOperator::NewFeature` is defined.
/// Specifically, when `filteroperator` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FilterOperator::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FilterOperator {
    #[allow(missing_docs)] // documentation missing in model
    StringEquals,
    #[allow(missing_docs)] // documentation missing in model
    StringLike,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FilterOperator {
    fn from(s: &str) -> Self {
        match s {
            "StringEquals" => FilterOperator::StringEquals,
            "StringLike" => FilterOperator::StringLike,
            other => FilterOperator::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FilterOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FilterOperator::from(s))
    }
}
impl FilterOperator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FilterOperator::StringEquals => "StringEquals",
            FilterOperator::StringLike => "StringLike",
            FilterOperator::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["StringEquals", "StringLike"]
    }
}
impl AsRef<str> for FilterOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A <code>DataSourceSummary</code> object that returns a summary of a data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSourceSummary {
    /// <p>The arn of the datasource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The unique ID of the data source.</p>
    #[doc(hidden)]
    pub data_source_id: std::option::Option<std::string::String>,
    /// <p>The name of the data source.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of the data source.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::DataSourceType>,
    /// <p>The date and time that the data source was created. This value is expressed in MM-DD-YYYY HH:MM:SS format.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time the data source was last updated. This value is expressed in MM-DD-YYYY HH:MM:SS format.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl DataSourceSummary {
    /// <p>The arn of the datasource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The unique ID of the data source.</p>
    pub fn data_source_id(&self) -> std::option::Option<&str> {
        self.data_source_id.as_deref()
    }
    /// <p>The name of the data source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of the data source.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::DataSourceType> {
        self.r#type.as_ref()
    }
    /// <p>The date and time that the data source was created. This value is expressed in MM-DD-YYYY HH:MM:SS format.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The date and time the data source was last updated. This value is expressed in MM-DD-YYYY HH:MM:SS format.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
}
/// See [`DataSourceSummary`](crate::model::DataSourceSummary).
pub mod data_source_summary {

    /// A builder for [`DataSourceSummary`](crate::model::DataSourceSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) data_source_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::DataSourceType>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The arn of the datasource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The arn of the datasource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The unique ID of the data source.</p>
        pub fn data_source_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_source_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the data source.</p>
        pub fn set_data_source_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_source_id = input;
            self
        }
        /// <p>The name of the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the data source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of the data source.</p>
        pub fn r#type(mut self, input: crate::model::DataSourceType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the data source.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DataSourceType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The date and time that the data source was created. This value is expressed in MM-DD-YYYY HH:MM:SS format.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The date and time that the data source was created. This value is expressed in MM-DD-YYYY HH:MM:SS format.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The date and time the data source was last updated. This value is expressed in MM-DD-YYYY HH:MM:SS format.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The date and time the data source was last updated. This value is expressed in MM-DD-YYYY HH:MM:SS format.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSourceSummary`](crate::model::DataSourceSummary).
        pub fn build(self) -> crate::model::DataSourceSummary {
            crate::model::DataSourceSummary {
                arn: self.arn,
                data_source_id: self.data_source_id,
                name: self.name,
                r#type: self.r#type,
                created_time: self.created_time,
                last_updated_time: self.last_updated_time,
            }
        }
    }
}
impl DataSourceSummary {
    /// Creates a new builder-style object to manufacture [`DataSourceSummary`](crate::model::DataSourceSummary).
    pub fn builder() -> crate::model::data_source_summary::Builder {
        crate::model::data_source_summary::Builder::default()
    }
}

/// When writing a match expression against `DataSourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datasourcetype = unimplemented!();
/// match datasourcetype {
///     DataSourceType::AdobeAnalytics => { /* ... */ },
///     DataSourceType::AmazonElasticsearch => { /* ... */ },
///     DataSourceType::AmazonOpensearch => { /* ... */ },
///     DataSourceType::Athena => { /* ... */ },
///     DataSourceType::Aurora => { /* ... */ },
///     DataSourceType::AuroraPostgresql => { /* ... */ },
///     DataSourceType::AwsIotAnalytics => { /* ... */ },
///     DataSourceType::Databricks => { /* ... */ },
///     DataSourceType::Exasol => { /* ... */ },
///     DataSourceType::Github => { /* ... */ },
///     DataSourceType::Jira => { /* ... */ },
///     DataSourceType::Mariadb => { /* ... */ },
///     DataSourceType::Mysql => { /* ... */ },
///     DataSourceType::Oracle => { /* ... */ },
///     DataSourceType::Postgresql => { /* ... */ },
///     DataSourceType::Presto => { /* ... */ },
///     DataSourceType::Redshift => { /* ... */ },
///     DataSourceType::S3 => { /* ... */ },
///     DataSourceType::Salesforce => { /* ... */ },
///     DataSourceType::Servicenow => { /* ... */ },
///     DataSourceType::Snowflake => { /* ... */ },
///     DataSourceType::Spark => { /* ... */ },
///     DataSourceType::Sqlserver => { /* ... */ },
///     DataSourceType::Teradata => { /* ... */ },
///     DataSourceType::Timestream => { /* ... */ },
///     DataSourceType::Twitter => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datasourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataSourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataSourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataSourceType::NewFeature` is defined.
/// Specifically, when `datasourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataSourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataSourceType {
    #[allow(missing_docs)] // documentation missing in model
    AdobeAnalytics,
    #[allow(missing_docs)] // documentation missing in model
    AmazonElasticsearch,
    #[allow(missing_docs)] // documentation missing in model
    AmazonOpensearch,
    #[allow(missing_docs)] // documentation missing in model
    Athena,
    #[allow(missing_docs)] // documentation missing in model
    Aurora,
    #[allow(missing_docs)] // documentation missing in model
    AuroraPostgresql,
    #[allow(missing_docs)] // documentation missing in model
    AwsIotAnalytics,
    #[allow(missing_docs)] // documentation missing in model
    Databricks,
    #[allow(missing_docs)] // documentation missing in model
    Exasol,
    #[allow(missing_docs)] // documentation missing in model
    Github,
    #[allow(missing_docs)] // documentation missing in model
    Jira,
    #[allow(missing_docs)] // documentation missing in model
    Mariadb,
    #[allow(missing_docs)] // documentation missing in model
    Mysql,
    #[allow(missing_docs)] // documentation missing in model
    Oracle,
    #[allow(missing_docs)] // documentation missing in model
    Postgresql,
    #[allow(missing_docs)] // documentation missing in model
    Presto,
    #[allow(missing_docs)] // documentation missing in model
    Redshift,
    #[allow(missing_docs)] // documentation missing in model
    S3,
    #[allow(missing_docs)] // documentation missing in model
    Salesforce,
    #[allow(missing_docs)] // documentation missing in model
    Servicenow,
    #[allow(missing_docs)] // documentation missing in model
    Snowflake,
    #[allow(missing_docs)] // documentation missing in model
    Spark,
    #[allow(missing_docs)] // documentation missing in model
    Sqlserver,
    #[allow(missing_docs)] // documentation missing in model
    Teradata,
    #[allow(missing_docs)] // documentation missing in model
    Timestream,
    #[allow(missing_docs)] // documentation missing in model
    Twitter,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataSourceType {
    fn from(s: &str) -> Self {
        match s {
            "ADOBE_ANALYTICS" => DataSourceType::AdobeAnalytics,
            "AMAZON_ELASTICSEARCH" => DataSourceType::AmazonElasticsearch,
            "AMAZON_OPENSEARCH" => DataSourceType::AmazonOpensearch,
            "ATHENA" => DataSourceType::Athena,
            "AURORA" => DataSourceType::Aurora,
            "AURORA_POSTGRESQL" => DataSourceType::AuroraPostgresql,
            "AWS_IOT_ANALYTICS" => DataSourceType::AwsIotAnalytics,
            "DATABRICKS" => DataSourceType::Databricks,
            "EXASOL" => DataSourceType::Exasol,
            "GITHUB" => DataSourceType::Github,
            "JIRA" => DataSourceType::Jira,
            "MARIADB" => DataSourceType::Mariadb,
            "MYSQL" => DataSourceType::Mysql,
            "ORACLE" => DataSourceType::Oracle,
            "POSTGRESQL" => DataSourceType::Postgresql,
            "PRESTO" => DataSourceType::Presto,
            "REDSHIFT" => DataSourceType::Redshift,
            "S3" => DataSourceType::S3,
            "SALESFORCE" => DataSourceType::Salesforce,
            "SERVICENOW" => DataSourceType::Servicenow,
            "SNOWFLAKE" => DataSourceType::Snowflake,
            "SPARK" => DataSourceType::Spark,
            "SQLSERVER" => DataSourceType::Sqlserver,
            "TERADATA" => DataSourceType::Teradata,
            "TIMESTREAM" => DataSourceType::Timestream,
            "TWITTER" => DataSourceType::Twitter,
            other => DataSourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DataSourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataSourceType::from(s))
    }
}
impl DataSourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataSourceType::AdobeAnalytics => "ADOBE_ANALYTICS",
            DataSourceType::AmazonElasticsearch => "AMAZON_ELASTICSEARCH",
            DataSourceType::AmazonOpensearch => "AMAZON_OPENSEARCH",
            DataSourceType::Athena => "ATHENA",
            DataSourceType::Aurora => "AURORA",
            DataSourceType::AuroraPostgresql => "AURORA_POSTGRESQL",
            DataSourceType::AwsIotAnalytics => "AWS_IOT_ANALYTICS",
            DataSourceType::Databricks => "DATABRICKS",
            DataSourceType::Exasol => "EXASOL",
            DataSourceType::Github => "GITHUB",
            DataSourceType::Jira => "JIRA",
            DataSourceType::Mariadb => "MARIADB",
            DataSourceType::Mysql => "MYSQL",
            DataSourceType::Oracle => "ORACLE",
            DataSourceType::Postgresql => "POSTGRESQL",
            DataSourceType::Presto => "PRESTO",
            DataSourceType::Redshift => "REDSHIFT",
            DataSourceType::S3 => "S3",
            DataSourceType::Salesforce => "SALESFORCE",
            DataSourceType::Servicenow => "SERVICENOW",
            DataSourceType::Snowflake => "SNOWFLAKE",
            DataSourceType::Spark => "SPARK",
            DataSourceType::Sqlserver => "SQLSERVER",
            DataSourceType::Teradata => "TERADATA",
            DataSourceType::Timestream => "TIMESTREAM",
            DataSourceType::Twitter => "TWITTER",
            DataSourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ADOBE_ANALYTICS",
            "AMAZON_ELASTICSEARCH",
            "AMAZON_OPENSEARCH",
            "ATHENA",
            "AURORA",
            "AURORA_POSTGRESQL",
            "AWS_IOT_ANALYTICS",
            "DATABRICKS",
            "EXASOL",
            "GITHUB",
            "JIRA",
            "MARIADB",
            "MYSQL",
            "ORACLE",
            "POSTGRESQL",
            "PRESTO",
            "REDSHIFT",
            "S3",
            "SALESFORCE",
            "SERVICENOW",
            "SNOWFLAKE",
            "SPARK",
            "SQLSERVER",
            "TERADATA",
            "TIMESTREAM",
            "TWITTER",
        ]
    }
}
impl AsRef<str> for DataSourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A filter that you apply when searching for data sources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSourceSearchFilter {
    /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
    /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose data sources you want to search in the <code>"Value"</code> field. For example, <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
    /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the data sources you are searching for. For example, <code>"Name":"DATASOURCE_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>DATASOURCE_NAME</code>.</p>
    #[doc(hidden)]
    pub operator: std::option::Option<crate::model::FilterOperator>,
    /// <p>The name of the value that you want to use as a filter, for example, <code>"Name": "DIRECT_QUICKSIGHT_OWNER"</code>.</p>
    /// <p>Valid values are defined as follows:</p>
    /// <ul>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any data sources with that ARN listed as one of the owners or viewers of the data sources are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any data sources with that ARN listed as one of the owners if the data source are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any data sources with that ARN listed as the only owner of the data source are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DATASOURCE_NAME</code>: Any data sources whose names have a substring match to the provided value are returned.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::DataSourceFilterAttribute>,
    /// <p>The value of the named item, for example <code>DIRECT_QUICKSIGHT_OWNER</code>, that you want to use as a filter, for example, <code>"Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl DataSourceSearchFilter {
    /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
    /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose data sources you want to search in the <code>"Value"</code> field. For example, <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
    /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the data sources you are searching for. For example, <code>"Name":"DATASOURCE_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>DATASOURCE_NAME</code>.</p>
    pub fn operator(&self) -> std::option::Option<&crate::model::FilterOperator> {
        self.operator.as_ref()
    }
    /// <p>The name of the value that you want to use as a filter, for example, <code>"Name": "DIRECT_QUICKSIGHT_OWNER"</code>.</p>
    /// <p>Valid values are defined as follows:</p>
    /// <ul>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any data sources with that ARN listed as one of the owners or viewers of the data sources are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any data sources with that ARN listed as one of the owners if the data source are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any data sources with that ARN listed as the only owner of the data source are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DATASOURCE_NAME</code>: Any data sources whose names have a substring match to the provided value are returned.</p> </li>
    /// </ul>
    pub fn name(&self) -> std::option::Option<&crate::model::DataSourceFilterAttribute> {
        self.name.as_ref()
    }
    /// <p>The value of the named item, for example <code>DIRECT_QUICKSIGHT_OWNER</code>, that you want to use as a filter, for example, <code>"Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`DataSourceSearchFilter`](crate::model::DataSourceSearchFilter).
pub mod data_source_search_filter {

    /// A builder for [`DataSourceSearchFilter`](crate::model::DataSourceSearchFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) operator: std::option::Option<crate::model::FilterOperator>,
        pub(crate) name: std::option::Option<crate::model::DataSourceFilterAttribute>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
        /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose data sources you want to search in the <code>"Value"</code> field. For example, <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
        /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the data sources you are searching for. For example, <code>"Name":"DATASOURCE_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>DATASOURCE_NAME</code>.</p>
        pub fn operator(mut self, input: crate::model::FilterOperator) -> Self {
            self.operator = Some(input);
            self
        }
        /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
        /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose data sources you want to search in the <code>"Value"</code> field. For example, <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
        /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the data sources you are searching for. For example, <code>"Name":"DATASOURCE_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>DATASOURCE_NAME</code>.</p>
        pub fn set_operator(
            mut self,
            input: std::option::Option<crate::model::FilterOperator>,
        ) -> Self {
            self.operator = input;
            self
        }
        /// <p>The name of the value that you want to use as a filter, for example, <code>"Name": "DIRECT_QUICKSIGHT_OWNER"</code>.</p>
        /// <p>Valid values are defined as follows:</p>
        /// <ul>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any data sources with that ARN listed as one of the owners or viewers of the data sources are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any data sources with that ARN listed as one of the owners if the data source are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any data sources with that ARN listed as the only owner of the data source are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DATASOURCE_NAME</code>: Any data sources whose names have a substring match to the provided value are returned.</p> </li>
        /// </ul>
        pub fn name(mut self, input: crate::model::DataSourceFilterAttribute) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the value that you want to use as a filter, for example, <code>"Name": "DIRECT_QUICKSIGHT_OWNER"</code>.</p>
        /// <p>Valid values are defined as follows:</p>
        /// <ul>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any data sources with that ARN listed as one of the owners or viewers of the data sources are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any data sources with that ARN listed as one of the owners if the data source are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any data sources with that ARN listed as the only owner of the data source are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DATASOURCE_NAME</code>: Any data sources whose names have a substring match to the provided value are returned.</p> </li>
        /// </ul>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::DataSourceFilterAttribute>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of the named item, for example <code>DIRECT_QUICKSIGHT_OWNER</code>, that you want to use as a filter, for example, <code>"Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the named item, for example <code>DIRECT_QUICKSIGHT_OWNER</code>, that you want to use as a filter, for example, <code>"Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSourceSearchFilter`](crate::model::DataSourceSearchFilter).
        pub fn build(self) -> crate::model::DataSourceSearchFilter {
            crate::model::DataSourceSearchFilter {
                operator: self.operator,
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl DataSourceSearchFilter {
    /// Creates a new builder-style object to manufacture [`DataSourceSearchFilter`](crate::model::DataSourceSearchFilter).
    pub fn builder() -> crate::model::data_source_search_filter::Builder {
        crate::model::data_source_search_filter::Builder::default()
    }
}

/// When writing a match expression against `DataSourceFilterAttribute`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datasourcefilterattribute = unimplemented!();
/// match datasourcefilterattribute {
///     DataSourceFilterAttribute::DatasourceName => { /* ... */ },
///     DataSourceFilterAttribute::DirectQuicksightOwner => { /* ... */ },
///     DataSourceFilterAttribute::DirectQuicksightSoleOwner => { /* ... */ },
///     DataSourceFilterAttribute::DirectQuicksightViewerOrOwner => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datasourcefilterattribute` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataSourceFilterAttribute::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataSourceFilterAttribute::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataSourceFilterAttribute::NewFeature` is defined.
/// Specifically, when `datasourcefilterattribute` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataSourceFilterAttribute::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataSourceFilterAttribute {
    #[allow(missing_docs)] // documentation missing in model
    DatasourceName,
    #[allow(missing_docs)] // documentation missing in model
    DirectQuicksightOwner,
    #[allow(missing_docs)] // documentation missing in model
    DirectQuicksightSoleOwner,
    #[allow(missing_docs)] // documentation missing in model
    DirectQuicksightViewerOrOwner,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataSourceFilterAttribute {
    fn from(s: &str) -> Self {
        match s {
            "DATASOURCE_NAME" => DataSourceFilterAttribute::DatasourceName,
            "DIRECT_QUICKSIGHT_OWNER" => DataSourceFilterAttribute::DirectQuicksightOwner,
            "DIRECT_QUICKSIGHT_SOLE_OWNER" => DataSourceFilterAttribute::DirectQuicksightSoleOwner,
            "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER" => {
                DataSourceFilterAttribute::DirectQuicksightViewerOrOwner
            }
            other => DataSourceFilterAttribute::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DataSourceFilterAttribute {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataSourceFilterAttribute::from(s))
    }
}
impl DataSourceFilterAttribute {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataSourceFilterAttribute::DatasourceName => "DATASOURCE_NAME",
            DataSourceFilterAttribute::DirectQuicksightOwner => "DIRECT_QUICKSIGHT_OWNER",
            DataSourceFilterAttribute::DirectQuicksightSoleOwner => "DIRECT_QUICKSIGHT_SOLE_OWNER",
            DataSourceFilterAttribute::DirectQuicksightViewerOrOwner => {
                "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
            }
            DataSourceFilterAttribute::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DATASOURCE_NAME",
            "DIRECT_QUICKSIGHT_OWNER",
            "DIRECT_QUICKSIGHT_SOLE_OWNER",
            "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER",
        ]
    }
}
impl AsRef<str> for DataSourceFilterAttribute {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Dataset summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSetSummary {
    /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ID of the dataset.</p>
    #[doc(hidden)]
    pub data_set_id: std::option::Option<std::string::String>,
    /// <p>A display name for the dataset.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time that this dataset was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time that this dataset was updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A value that indicates whether you want to import the data into SPICE.</p>
    #[doc(hidden)]
    pub import_mode: std::option::Option<crate::model::DataSetImportMode>,
    /// <p>The row-level security configuration for the dataset.</p>
    #[doc(hidden)]
    pub row_level_permission_data_set: std::option::Option<crate::model::RowLevelPermissionDataSet>,
    /// <p>Whether or not the row level permission tags are applied.</p>
    #[doc(hidden)]
    pub row_level_permission_tag_configuration_applied: bool,
    /// <p>A value that indicates if the dataset has column level permission configured.</p>
    #[doc(hidden)]
    pub column_level_permission_rules_applied: bool,
}
impl DataSetSummary {
    /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The ID of the dataset.</p>
    pub fn data_set_id(&self) -> std::option::Option<&str> {
        self.data_set_id.as_deref()
    }
    /// <p>A display name for the dataset.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time that this dataset was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The last time that this dataset was updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
    /// <p>A value that indicates whether you want to import the data into SPICE.</p>
    pub fn import_mode(&self) -> std::option::Option<&crate::model::DataSetImportMode> {
        self.import_mode.as_ref()
    }
    /// <p>The row-level security configuration for the dataset.</p>
    pub fn row_level_permission_data_set(
        &self,
    ) -> std::option::Option<&crate::model::RowLevelPermissionDataSet> {
        self.row_level_permission_data_set.as_ref()
    }
    /// <p>Whether or not the row level permission tags are applied.</p>
    pub fn row_level_permission_tag_configuration_applied(&self) -> bool {
        self.row_level_permission_tag_configuration_applied
    }
    /// <p>A value that indicates if the dataset has column level permission configured.</p>
    pub fn column_level_permission_rules_applied(&self) -> bool {
        self.column_level_permission_rules_applied
    }
}
/// See [`DataSetSummary`](crate::model::DataSetSummary).
pub mod data_set_summary {

    /// A builder for [`DataSetSummary`](crate::model::DataSetSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) data_set_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) import_mode: std::option::Option<crate::model::DataSetImportMode>,
        pub(crate) row_level_permission_data_set:
            std::option::Option<crate::model::RowLevelPermissionDataSet>,
        pub(crate) row_level_permission_tag_configuration_applied: std::option::Option<bool>,
        pub(crate) column_level_permission_rules_applied: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ID of the dataset.</p>
        pub fn data_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_set_id = Some(input.into());
            self
        }
        /// <p>The ID of the dataset.</p>
        pub fn set_data_set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_set_id = input;
            self
        }
        /// <p>A display name for the dataset.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A display name for the dataset.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time that this dataset was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The time that this dataset was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The last time that this dataset was updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The last time that this dataset was updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>A value that indicates whether you want to import the data into SPICE.</p>
        pub fn import_mode(mut self, input: crate::model::DataSetImportMode) -> Self {
            self.import_mode = Some(input);
            self
        }
        /// <p>A value that indicates whether you want to import the data into SPICE.</p>
        pub fn set_import_mode(
            mut self,
            input: std::option::Option<crate::model::DataSetImportMode>,
        ) -> Self {
            self.import_mode = input;
            self
        }
        /// <p>The row-level security configuration for the dataset.</p>
        pub fn row_level_permission_data_set(
            mut self,
            input: crate::model::RowLevelPermissionDataSet,
        ) -> Self {
            self.row_level_permission_data_set = Some(input);
            self
        }
        /// <p>The row-level security configuration for the dataset.</p>
        pub fn set_row_level_permission_data_set(
            mut self,
            input: std::option::Option<crate::model::RowLevelPermissionDataSet>,
        ) -> Self {
            self.row_level_permission_data_set = input;
            self
        }
        /// <p>Whether or not the row level permission tags are applied.</p>
        pub fn row_level_permission_tag_configuration_applied(mut self, input: bool) -> Self {
            self.row_level_permission_tag_configuration_applied = Some(input);
            self
        }
        /// <p>Whether or not the row level permission tags are applied.</p>
        pub fn set_row_level_permission_tag_configuration_applied(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.row_level_permission_tag_configuration_applied = input;
            self
        }
        /// <p>A value that indicates if the dataset has column level permission configured.</p>
        pub fn column_level_permission_rules_applied(mut self, input: bool) -> Self {
            self.column_level_permission_rules_applied = Some(input);
            self
        }
        /// <p>A value that indicates if the dataset has column level permission configured.</p>
        pub fn set_column_level_permission_rules_applied(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.column_level_permission_rules_applied = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSetSummary`](crate::model::DataSetSummary).
        pub fn build(self) -> crate::model::DataSetSummary {
            crate::model::DataSetSummary {
                arn: self.arn,
                data_set_id: self.data_set_id,
                name: self.name,
                created_time: self.created_time,
                last_updated_time: self.last_updated_time,
                import_mode: self.import_mode,
                row_level_permission_data_set: self.row_level_permission_data_set,
                row_level_permission_tag_configuration_applied: self
                    .row_level_permission_tag_configuration_applied
                    .unwrap_or_default(),
                column_level_permission_rules_applied: self
                    .column_level_permission_rules_applied
                    .unwrap_or_default(),
            }
        }
    }
}
impl DataSetSummary {
    /// Creates a new builder-style object to manufacture [`DataSetSummary`](crate::model::DataSetSummary).
    pub fn builder() -> crate::model::data_set_summary::Builder {
        crate::model::data_set_summary::Builder::default()
    }
}

/// <p>A filter that you apply when searching for datasets.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSetSearchFilter {
    /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
    /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose datasets you want to search in the <code>"Value"</code> field. For example, <code>"Name":"QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east- 1:1:user/default/UserName1"</code>.</p>
    /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the datasets you are searching for. For example, <code>"Name":"DATASET_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>DATASET_NAME</code>.</p>
    #[doc(hidden)]
    pub operator: std::option::Option<crate::model::FilterOperator>,
    /// <p>The name of the value that you want to use as a filter, for example, <code>"Name": "QUICKSIGHT_OWNER"</code>.</p>
    /// <p>Valid values are defined as follows:</p>
    /// <ul>
    /// <li> <p> <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the dataset owners or viewers are returned. Implicit permissions from folders or groups are considered.</p> </li>
    /// <li> <p> <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners of the dataset are returned. Implicit permissions from folders or groups are considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as the only owner of the dataset are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners if the dataset are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners or viewers of the dataset are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DATASET_NAME</code>: Any datasets whose names have a substring match to this value will be returned.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::DataSetFilterAttribute>,
    /// <p>The value of the named item, in this case <code>QUICKSIGHT_OWNER</code>, that you want to use as a filter, for example, <code>"Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl DataSetSearchFilter {
    /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
    /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose datasets you want to search in the <code>"Value"</code> field. For example, <code>"Name":"QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east- 1:1:user/default/UserName1"</code>.</p>
    /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the datasets you are searching for. For example, <code>"Name":"DATASET_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>DATASET_NAME</code>.</p>
    pub fn operator(&self) -> std::option::Option<&crate::model::FilterOperator> {
        self.operator.as_ref()
    }
    /// <p>The name of the value that you want to use as a filter, for example, <code>"Name": "QUICKSIGHT_OWNER"</code>.</p>
    /// <p>Valid values are defined as follows:</p>
    /// <ul>
    /// <li> <p> <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the dataset owners or viewers are returned. Implicit permissions from folders or groups are considered.</p> </li>
    /// <li> <p> <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners of the dataset are returned. Implicit permissions from folders or groups are considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as the only owner of the dataset are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners if the dataset are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners or viewers of the dataset are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DATASET_NAME</code>: Any datasets whose names have a substring match to this value will be returned.</p> </li>
    /// </ul>
    pub fn name(&self) -> std::option::Option<&crate::model::DataSetFilterAttribute> {
        self.name.as_ref()
    }
    /// <p>The value of the named item, in this case <code>QUICKSIGHT_OWNER</code>, that you want to use as a filter, for example, <code>"Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`DataSetSearchFilter`](crate::model::DataSetSearchFilter).
pub mod data_set_search_filter {

    /// A builder for [`DataSetSearchFilter`](crate::model::DataSetSearchFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) operator: std::option::Option<crate::model::FilterOperator>,
        pub(crate) name: std::option::Option<crate::model::DataSetFilterAttribute>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
        /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose datasets you want to search in the <code>"Value"</code> field. For example, <code>"Name":"QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east- 1:1:user/default/UserName1"</code>.</p>
        /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the datasets you are searching for. For example, <code>"Name":"DATASET_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>DATASET_NAME</code>.</p>
        pub fn operator(mut self, input: crate::model::FilterOperator) -> Self {
            self.operator = Some(input);
            self
        }
        /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
        /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose datasets you want to search in the <code>"Value"</code> field. For example, <code>"Name":"QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east- 1:1:user/default/UserName1"</code>.</p>
        /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the datasets you are searching for. For example, <code>"Name":"DATASET_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>DATASET_NAME</code>.</p>
        pub fn set_operator(
            mut self,
            input: std::option::Option<crate::model::FilterOperator>,
        ) -> Self {
            self.operator = input;
            self
        }
        /// <p>The name of the value that you want to use as a filter, for example, <code>"Name": "QUICKSIGHT_OWNER"</code>.</p>
        /// <p>Valid values are defined as follows:</p>
        /// <ul>
        /// <li> <p> <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the dataset owners or viewers are returned. Implicit permissions from folders or groups are considered.</p> </li>
        /// <li> <p> <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners of the dataset are returned. Implicit permissions from folders or groups are considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as the only owner of the dataset are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners if the dataset are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners or viewers of the dataset are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DATASET_NAME</code>: Any datasets whose names have a substring match to this value will be returned.</p> </li>
        /// </ul>
        pub fn name(mut self, input: crate::model::DataSetFilterAttribute) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the value that you want to use as a filter, for example, <code>"Name": "QUICKSIGHT_OWNER"</code>.</p>
        /// <p>Valid values are defined as follows:</p>
        /// <ul>
        /// <li> <p> <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the dataset owners or viewers are returned. Implicit permissions from folders or groups are considered.</p> </li>
        /// <li> <p> <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners of the dataset are returned. Implicit permissions from folders or groups are considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as the only owner of the dataset are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners if the dataset are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners or viewers of the dataset are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DATASET_NAME</code>: Any datasets whose names have a substring match to this value will be returned.</p> </li>
        /// </ul>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::DataSetFilterAttribute>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of the named item, in this case <code>QUICKSIGHT_OWNER</code>, that you want to use as a filter, for example, <code>"Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the named item, in this case <code>QUICKSIGHT_OWNER</code>, that you want to use as a filter, for example, <code>"Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSetSearchFilter`](crate::model::DataSetSearchFilter).
        pub fn build(self) -> crate::model::DataSetSearchFilter {
            crate::model::DataSetSearchFilter {
                operator: self.operator,
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl DataSetSearchFilter {
    /// Creates a new builder-style object to manufacture [`DataSetSearchFilter`](crate::model::DataSetSearchFilter).
    pub fn builder() -> crate::model::data_set_search_filter::Builder {
        crate::model::data_set_search_filter::Builder::default()
    }
}

/// When writing a match expression against `DataSetFilterAttribute`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datasetfilterattribute = unimplemented!();
/// match datasetfilterattribute {
///     DataSetFilterAttribute::DatasetName => { /* ... */ },
///     DataSetFilterAttribute::DirectQuicksightOwner => { /* ... */ },
///     DataSetFilterAttribute::DirectQuicksightSoleOwner => { /* ... */ },
///     DataSetFilterAttribute::DirectQuicksightViewerOrOwner => { /* ... */ },
///     DataSetFilterAttribute::QuicksightOwner => { /* ... */ },
///     DataSetFilterAttribute::QuicksightViewerOrOwner => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datasetfilterattribute` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataSetFilterAttribute::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataSetFilterAttribute::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataSetFilterAttribute::NewFeature` is defined.
/// Specifically, when `datasetfilterattribute` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataSetFilterAttribute::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataSetFilterAttribute {
    #[allow(missing_docs)] // documentation missing in model
    DatasetName,
    #[allow(missing_docs)] // documentation missing in model
    DirectQuicksightOwner,
    #[allow(missing_docs)] // documentation missing in model
    DirectQuicksightSoleOwner,
    #[allow(missing_docs)] // documentation missing in model
    DirectQuicksightViewerOrOwner,
    #[allow(missing_docs)] // documentation missing in model
    QuicksightOwner,
    #[allow(missing_docs)] // documentation missing in model
    QuicksightViewerOrOwner,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataSetFilterAttribute {
    fn from(s: &str) -> Self {
        match s {
            "DATASET_NAME" => DataSetFilterAttribute::DatasetName,
            "DIRECT_QUICKSIGHT_OWNER" => DataSetFilterAttribute::DirectQuicksightOwner,
            "DIRECT_QUICKSIGHT_SOLE_OWNER" => DataSetFilterAttribute::DirectQuicksightSoleOwner,
            "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER" => {
                DataSetFilterAttribute::DirectQuicksightViewerOrOwner
            }
            "QUICKSIGHT_OWNER" => DataSetFilterAttribute::QuicksightOwner,
            "QUICKSIGHT_VIEWER_OR_OWNER" => DataSetFilterAttribute::QuicksightViewerOrOwner,
            other => {
                DataSetFilterAttribute::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DataSetFilterAttribute {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataSetFilterAttribute::from(s))
    }
}
impl DataSetFilterAttribute {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataSetFilterAttribute::DatasetName => "DATASET_NAME",
            DataSetFilterAttribute::DirectQuicksightOwner => "DIRECT_QUICKSIGHT_OWNER",
            DataSetFilterAttribute::DirectQuicksightSoleOwner => "DIRECT_QUICKSIGHT_SOLE_OWNER",
            DataSetFilterAttribute::DirectQuicksightViewerOrOwner => {
                "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
            }
            DataSetFilterAttribute::QuicksightOwner => "QUICKSIGHT_OWNER",
            DataSetFilterAttribute::QuicksightViewerOrOwner => "QUICKSIGHT_VIEWER_OR_OWNER",
            DataSetFilterAttribute::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DATASET_NAME",
            "DIRECT_QUICKSIGHT_OWNER",
            "DIRECT_QUICKSIGHT_SOLE_OWNER",
            "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER",
            "QUICKSIGHT_OWNER",
            "QUICKSIGHT_VIEWER_OR_OWNER",
        ]
    }
}
impl AsRef<str> for DataSetFilterAttribute {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Dashboard summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DashboardSummary {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Dashboard ID.</p>
    #[doc(hidden)]
    pub dashboard_id: std::option::Option<std::string::String>,
    /// <p>A display name for the dashboard.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time that this dashboard was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time that this dashboard was updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Published version number.</p>
    #[doc(hidden)]
    pub published_version_number: std::option::Option<i64>,
    /// <p>The last time that this dashboard was published.</p>
    #[doc(hidden)]
    pub last_published_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl DashboardSummary {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Dashboard ID.</p>
    pub fn dashboard_id(&self) -> std::option::Option<&str> {
        self.dashboard_id.as_deref()
    }
    /// <p>A display name for the dashboard.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time that this dashboard was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The last time that this dashboard was updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
    /// <p>Published version number.</p>
    pub fn published_version_number(&self) -> std::option::Option<i64> {
        self.published_version_number
    }
    /// <p>The last time that this dashboard was published.</p>
    pub fn last_published_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_published_time.as_ref()
    }
}
/// See [`DashboardSummary`](crate::model::DashboardSummary).
pub mod dashboard_summary {

    /// A builder for [`DashboardSummary`](crate::model::DashboardSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) dashboard_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) published_version_number: std::option::Option<i64>,
        pub(crate) last_published_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Dashboard ID.</p>
        pub fn dashboard_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.dashboard_id = Some(input.into());
            self
        }
        /// <p>Dashboard ID.</p>
        pub fn set_dashboard_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dashboard_id = input;
            self
        }
        /// <p>A display name for the dashboard.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A display name for the dashboard.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time that this dashboard was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The time that this dashboard was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The last time that this dashboard was updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The last time that this dashboard was updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>Published version number.</p>
        pub fn published_version_number(mut self, input: i64) -> Self {
            self.published_version_number = Some(input);
            self
        }
        /// <p>Published version number.</p>
        pub fn set_published_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.published_version_number = input;
            self
        }
        /// <p>The last time that this dashboard was published.</p>
        pub fn last_published_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_published_time = Some(input);
            self
        }
        /// <p>The last time that this dashboard was published.</p>
        pub fn set_last_published_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_published_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DashboardSummary`](crate::model::DashboardSummary).
        pub fn build(self) -> crate::model::DashboardSummary {
            crate::model::DashboardSummary {
                arn: self.arn,
                dashboard_id: self.dashboard_id,
                name: self.name,
                created_time: self.created_time,
                last_updated_time: self.last_updated_time,
                published_version_number: self.published_version_number,
                last_published_time: self.last_published_time,
            }
        }
    }
}
impl DashboardSummary {
    /// Creates a new builder-style object to manufacture [`DashboardSummary`](crate::model::DashboardSummary).
    pub fn builder() -> crate::model::dashboard_summary::Builder {
        crate::model::dashboard_summary::Builder::default()
    }
}

/// <p>A filter that you apply when searching for dashboards. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DashboardSearchFilter {
    /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
    /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose folders you want to search in the <code>"Value"</code> field. For example, <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
    /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the folders you are searching for. For example, <code>"Name":"DASHBOARD_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>DASHBOARD_NAME</code>.</p>
    #[doc(hidden)]
    pub operator: std::option::Option<crate::model::FilterOperator>,
    /// <p>The name of the value that you want to use as a filter, for example, <code>"Name": "QUICKSIGHT_OWNER"</code>.</p>
    /// <p>Valid values are defined as follows:</p>
    /// <ul>
    /// <li> <p> <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the dashboards's owners or viewers are returned. Implicit permissions from folders or groups are considered.</p> </li>
    /// <li> <p> <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners of the dashboards are returned. Implicit permissions from folders or groups are considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as the only owner of the dashboard are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners of the dashboards are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners or viewers of the dashboards are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DASHBOARD_NAME</code>: Any dashboards whose names have a substring match to this value will be returned.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::DashboardFilterAttribute>,
    /// <p>The value of the named item, in this case <code>QUICKSIGHT_USER</code>, that you want to use as a filter, for example, <code>"Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>. </p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl DashboardSearchFilter {
    /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
    /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose folders you want to search in the <code>"Value"</code> field. For example, <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
    /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the folders you are searching for. For example, <code>"Name":"DASHBOARD_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>DASHBOARD_NAME</code>.</p>
    pub fn operator(&self) -> std::option::Option<&crate::model::FilterOperator> {
        self.operator.as_ref()
    }
    /// <p>The name of the value that you want to use as a filter, for example, <code>"Name": "QUICKSIGHT_OWNER"</code>.</p>
    /// <p>Valid values are defined as follows:</p>
    /// <ul>
    /// <li> <p> <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the dashboards's owners or viewers are returned. Implicit permissions from folders or groups are considered.</p> </li>
    /// <li> <p> <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners of the dashboards are returned. Implicit permissions from folders or groups are considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as the only owner of the dashboard are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners of the dashboards are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners or viewers of the dashboards are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DASHBOARD_NAME</code>: Any dashboards whose names have a substring match to this value will be returned.</p> </li>
    /// </ul>
    pub fn name(&self) -> std::option::Option<&crate::model::DashboardFilterAttribute> {
        self.name.as_ref()
    }
    /// <p>The value of the named item, in this case <code>QUICKSIGHT_USER</code>, that you want to use as a filter, for example, <code>"Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>. </p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`DashboardSearchFilter`](crate::model::DashboardSearchFilter).
pub mod dashboard_search_filter {

    /// A builder for [`DashboardSearchFilter`](crate::model::DashboardSearchFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) operator: std::option::Option<crate::model::FilterOperator>,
        pub(crate) name: std::option::Option<crate::model::DashboardFilterAttribute>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
        /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose folders you want to search in the <code>"Value"</code> field. For example, <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
        /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the folders you are searching for. For example, <code>"Name":"DASHBOARD_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>DASHBOARD_NAME</code>.</p>
        pub fn operator(mut self, input: crate::model::FilterOperator) -> Self {
            self.operator = Some(input);
            self
        }
        /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
        /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose folders you want to search in the <code>"Value"</code> field. For example, <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
        /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the folders you are searching for. For example, <code>"Name":"DASHBOARD_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>DASHBOARD_NAME</code>.</p>
        pub fn set_operator(
            mut self,
            input: std::option::Option<crate::model::FilterOperator>,
        ) -> Self {
            self.operator = input;
            self
        }
        /// <p>The name of the value that you want to use as a filter, for example, <code>"Name": "QUICKSIGHT_OWNER"</code>.</p>
        /// <p>Valid values are defined as follows:</p>
        /// <ul>
        /// <li> <p> <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the dashboards's owners or viewers are returned. Implicit permissions from folders or groups are considered.</p> </li>
        /// <li> <p> <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners of the dashboards are returned. Implicit permissions from folders or groups are considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as the only owner of the dashboard are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners of the dashboards are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners or viewers of the dashboards are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DASHBOARD_NAME</code>: Any dashboards whose names have a substring match to this value will be returned.</p> </li>
        /// </ul>
        pub fn name(mut self, input: crate::model::DashboardFilterAttribute) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the value that you want to use as a filter, for example, <code>"Name": "QUICKSIGHT_OWNER"</code>.</p>
        /// <p>Valid values are defined as follows:</p>
        /// <ul>
        /// <li> <p> <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the dashboards's owners or viewers are returned. Implicit permissions from folders or groups are considered.</p> </li>
        /// <li> <p> <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners of the dashboards are returned. Implicit permissions from folders or groups are considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as the only owner of the dashboard are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners of the dashboards are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners or viewers of the dashboards are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DASHBOARD_NAME</code>: Any dashboards whose names have a substring match to this value will be returned.</p> </li>
        /// </ul>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::DashboardFilterAttribute>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of the named item, in this case <code>QUICKSIGHT_USER</code>, that you want to use as a filter, for example, <code>"Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>. </p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the named item, in this case <code>QUICKSIGHT_USER</code>, that you want to use as a filter, for example, <code>"Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>. </p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`DashboardSearchFilter`](crate::model::DashboardSearchFilter).
        pub fn build(self) -> crate::model::DashboardSearchFilter {
            crate::model::DashboardSearchFilter {
                operator: self.operator,
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl DashboardSearchFilter {
    /// Creates a new builder-style object to manufacture [`DashboardSearchFilter`](crate::model::DashboardSearchFilter).
    pub fn builder() -> crate::model::dashboard_search_filter::Builder {
        crate::model::dashboard_search_filter::Builder::default()
    }
}

/// When writing a match expression against `DashboardFilterAttribute`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let dashboardfilterattribute = unimplemented!();
/// match dashboardfilterattribute {
///     DashboardFilterAttribute::DashboardName => { /* ... */ },
///     DashboardFilterAttribute::DirectQuicksightOwner => { /* ... */ },
///     DashboardFilterAttribute::DirectQuicksightSoleOwner => { /* ... */ },
///     DashboardFilterAttribute::DirectQuicksightViewerOrOwner => { /* ... */ },
///     DashboardFilterAttribute::QuicksightOwner => { /* ... */ },
///     DashboardFilterAttribute::QuicksightUser => { /* ... */ },
///     DashboardFilterAttribute::QuicksightViewerOrOwner => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `dashboardfilterattribute` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DashboardFilterAttribute::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DashboardFilterAttribute::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DashboardFilterAttribute::NewFeature` is defined.
/// Specifically, when `dashboardfilterattribute` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DashboardFilterAttribute::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DashboardFilterAttribute {
    #[allow(missing_docs)] // documentation missing in model
    DashboardName,
    #[allow(missing_docs)] // documentation missing in model
    DirectQuicksightOwner,
    #[allow(missing_docs)] // documentation missing in model
    DirectQuicksightSoleOwner,
    #[allow(missing_docs)] // documentation missing in model
    DirectQuicksightViewerOrOwner,
    #[allow(missing_docs)] // documentation missing in model
    QuicksightOwner,
    #[allow(missing_docs)] // documentation missing in model
    QuicksightUser,
    #[allow(missing_docs)] // documentation missing in model
    QuicksightViewerOrOwner,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DashboardFilterAttribute {
    fn from(s: &str) -> Self {
        match s {
            "DASHBOARD_NAME" => DashboardFilterAttribute::DashboardName,
            "DIRECT_QUICKSIGHT_OWNER" => DashboardFilterAttribute::DirectQuicksightOwner,
            "DIRECT_QUICKSIGHT_SOLE_OWNER" => DashboardFilterAttribute::DirectQuicksightSoleOwner,
            "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER" => {
                DashboardFilterAttribute::DirectQuicksightViewerOrOwner
            }
            "QUICKSIGHT_OWNER" => DashboardFilterAttribute::QuicksightOwner,
            "QUICKSIGHT_USER" => DashboardFilterAttribute::QuicksightUser,
            "QUICKSIGHT_VIEWER_OR_OWNER" => DashboardFilterAttribute::QuicksightViewerOrOwner,
            other => DashboardFilterAttribute::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DashboardFilterAttribute {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DashboardFilterAttribute::from(s))
    }
}
impl DashboardFilterAttribute {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DashboardFilterAttribute::DashboardName => "DASHBOARD_NAME",
            DashboardFilterAttribute::DirectQuicksightOwner => "DIRECT_QUICKSIGHT_OWNER",
            DashboardFilterAttribute::DirectQuicksightSoleOwner => "DIRECT_QUICKSIGHT_SOLE_OWNER",
            DashboardFilterAttribute::DirectQuicksightViewerOrOwner => {
                "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
            }
            DashboardFilterAttribute::QuicksightOwner => "QUICKSIGHT_OWNER",
            DashboardFilterAttribute::QuicksightUser => "QUICKSIGHT_USER",
            DashboardFilterAttribute::QuicksightViewerOrOwner => "QUICKSIGHT_VIEWER_OR_OWNER",
            DashboardFilterAttribute::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DASHBOARD_NAME",
            "DIRECT_QUICKSIGHT_OWNER",
            "DIRECT_QUICKSIGHT_SOLE_OWNER",
            "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER",
            "QUICKSIGHT_OWNER",
            "QUICKSIGHT_USER",
            "QUICKSIGHT_VIEWER_OR_OWNER",
        ]
    }
}
impl AsRef<str> for DashboardFilterAttribute {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The summary metadata that describes an analysis.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnalysisSummary {
    /// <p>The Amazon Resource Name (ARN) for the analysis.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ID of the analysis. This ID displays in the URL.</p>
    #[doc(hidden)]
    pub analysis_id: std::option::Option<std::string::String>,
    /// <p>The name of the analysis. This name is displayed in the Amazon QuickSight console. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The last known status for the analysis.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ResourceStatus>,
    /// <p>The time that the analysis was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the analysis was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl AnalysisSummary {
    /// <p>The Amazon Resource Name (ARN) for the analysis.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The ID of the analysis. This ID displays in the URL.</p>
    pub fn analysis_id(&self) -> std::option::Option<&str> {
        self.analysis_id.as_deref()
    }
    /// <p>The name of the analysis. This name is displayed in the Amazon QuickSight console. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The last known status for the analysis.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ResourceStatus> {
        self.status.as_ref()
    }
    /// <p>The time that the analysis was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The time that the analysis was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
}
/// See [`AnalysisSummary`](crate::model::AnalysisSummary).
pub mod analysis_summary {

    /// A builder for [`AnalysisSummary`](crate::model::AnalysisSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) analysis_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ResourceStatus>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for the analysis.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the analysis.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ID of the analysis. This ID displays in the URL.</p>
        pub fn analysis_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.analysis_id = Some(input.into());
            self
        }
        /// <p>The ID of the analysis. This ID displays in the URL.</p>
        pub fn set_analysis_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.analysis_id = input;
            self
        }
        /// <p>The name of the analysis. This name is displayed in the Amazon QuickSight console. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the analysis. This name is displayed in the Amazon QuickSight console. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The last known status for the analysis.</p>
        pub fn status(mut self, input: crate::model::ResourceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The last known status for the analysis.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ResourceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The time that the analysis was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The time that the analysis was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The time that the analysis was last updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The time that the analysis was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// Consumes the builder and constructs a [`AnalysisSummary`](crate::model::AnalysisSummary).
        pub fn build(self) -> crate::model::AnalysisSummary {
            crate::model::AnalysisSummary {
                arn: self.arn,
                analysis_id: self.analysis_id,
                name: self.name,
                status: self.status,
                created_time: self.created_time,
                last_updated_time: self.last_updated_time,
            }
        }
    }
}
impl AnalysisSummary {
    /// Creates a new builder-style object to manufacture [`AnalysisSummary`](crate::model::AnalysisSummary).
    pub fn builder() -> crate::model::analysis_summary::Builder {
        crate::model::analysis_summary::Builder::default()
    }
}

/// <p>A filter that you apply when searching for one or more analyses.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnalysisSearchFilter {
    /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
    /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose folders you want to search in the <code>"Value"</code> field. For example, <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
    /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the folders you are searching for. For example, <code>"Name":"ANALYSIS_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>ANALYSIS_NAME</code>.</p>
    #[doc(hidden)]
    pub operator: std::option::Option<crate::model::FilterOperator>,
    /// <p>The name of the value that you want to use as a filter, for example <code>"Name": "QUICKSIGHT_OWNER"</code>.</p>
    /// <p>Valid values are defined as follows:</p>
    /// <ul>
    /// <li> <p> <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the analysis' owners or viewers are returned. Implicit permissions from folders or groups are considered. </p> </li>
    /// <li> <p> <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners of the analyses are returned. Implicit permissions from folders or groups are considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as the only owner of the analysis are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners of the analyses are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners or viewers of the analyses are returned. Implicit permissions from folders or groups are not considered. </p> </li>
    /// <li> <p> <code>ANALYSIS_NAME</code>: Any analyses whose names have a substring match to this value will be returned.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::AnalysisFilterAttribute>,
    /// <p>The value of the named item, in this case <code>QUICKSIGHT_USER</code>, that you want to use as a filter, for example <code>"Value"</code>. An example is <code>"arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl AnalysisSearchFilter {
    /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
    /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose folders you want to search in the <code>"Value"</code> field. For example, <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
    /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the folders you are searching for. For example, <code>"Name":"ANALYSIS_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>ANALYSIS_NAME</code>.</p>
    pub fn operator(&self) -> std::option::Option<&crate::model::FilterOperator> {
        self.operator.as_ref()
    }
    /// <p>The name of the value that you want to use as a filter, for example <code>"Name": "QUICKSIGHT_OWNER"</code>.</p>
    /// <p>Valid values are defined as follows:</p>
    /// <ul>
    /// <li> <p> <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the analysis' owners or viewers are returned. Implicit permissions from folders or groups are considered. </p> </li>
    /// <li> <p> <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners of the analyses are returned. Implicit permissions from folders or groups are considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as the only owner of the analysis are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners of the analyses are returned. Implicit permissions from folders or groups are not considered.</p> </li>
    /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners or viewers of the analyses are returned. Implicit permissions from folders or groups are not considered. </p> </li>
    /// <li> <p> <code>ANALYSIS_NAME</code>: Any analyses whose names have a substring match to this value will be returned.</p> </li>
    /// </ul>
    pub fn name(&self) -> std::option::Option<&crate::model::AnalysisFilterAttribute> {
        self.name.as_ref()
    }
    /// <p>The value of the named item, in this case <code>QUICKSIGHT_USER</code>, that you want to use as a filter, for example <code>"Value"</code>. An example is <code>"arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`AnalysisSearchFilter`](crate::model::AnalysisSearchFilter).
pub mod analysis_search_filter {

    /// A builder for [`AnalysisSearchFilter`](crate::model::AnalysisSearchFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) operator: std::option::Option<crate::model::FilterOperator>,
        pub(crate) name: std::option::Option<crate::model::AnalysisFilterAttribute>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
        /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose folders you want to search in the <code>"Value"</code> field. For example, <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
        /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the folders you are searching for. For example, <code>"Name":"ANALYSIS_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>ANALYSIS_NAME</code>.</p>
        pub fn operator(mut self, input: crate::model::FilterOperator) -> Self {
            self.operator = Some(input);
            self
        }
        /// <p>The comparison operator that you want to use as a filter, for example <code>"Operator": "StringEquals"</code>. Valid values are <code>"StringEquals"</code> and <code>"StringLike"</code>.</p>
        /// <p>If you set the operator value to <code>"StringEquals"</code>, you need to provide an ownership related filter in the <code>"NAME"</code> field and the arn of the user or group whose folders you want to search in the <code>"Value"</code> field. For example, <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
        /// <p>If you set the value to <code>"StringLike"</code>, you need to provide the name of the folders you are searching for. For example, <code>"Name":"ANALYSIS_NAME", "Operator": "StringLike", "Value": "Test"</code>. The <code>"StringLike"</code> operator only supports the <code>NAME</code> value <code>ANALYSIS_NAME</code>.</p>
        pub fn set_operator(
            mut self,
            input: std::option::Option<crate::model::FilterOperator>,
        ) -> Self {
            self.operator = input;
            self
        }
        /// <p>The name of the value that you want to use as a filter, for example <code>"Name": "QUICKSIGHT_OWNER"</code>.</p>
        /// <p>Valid values are defined as follows:</p>
        /// <ul>
        /// <li> <p> <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the analysis' owners or viewers are returned. Implicit permissions from folders or groups are considered. </p> </li>
        /// <li> <p> <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners of the analyses are returned. Implicit permissions from folders or groups are considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as the only owner of the analysis are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners of the analyses are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners or viewers of the analyses are returned. Implicit permissions from folders or groups are not considered. </p> </li>
        /// <li> <p> <code>ANALYSIS_NAME</code>: Any analyses whose names have a substring match to this value will be returned.</p> </li>
        /// </ul>
        pub fn name(mut self, input: crate::model::AnalysisFilterAttribute) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the value that you want to use as a filter, for example <code>"Name": "QUICKSIGHT_OWNER"</code>.</p>
        /// <p>Valid values are defined as follows:</p>
        /// <ul>
        /// <li> <p> <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the analysis' owners or viewers are returned. Implicit permissions from folders or groups are considered. </p> </li>
        /// <li> <p> <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners of the analyses are returned. Implicit permissions from folders or groups are considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as the only owner of the analysis are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners of the analyses are returned. Implicit permissions from folders or groups are not considered.</p> </li>
        /// <li> <p> <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners or viewers of the analyses are returned. Implicit permissions from folders or groups are not considered. </p> </li>
        /// <li> <p> <code>ANALYSIS_NAME</code>: Any analyses whose names have a substring match to this value will be returned.</p> </li>
        /// </ul>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::AnalysisFilterAttribute>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of the named item, in this case <code>QUICKSIGHT_USER</code>, that you want to use as a filter, for example <code>"Value"</code>. An example is <code>"arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the named item, in this case <code>QUICKSIGHT_USER</code>, that you want to use as a filter, for example <code>"Value"</code>. An example is <code>"arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AnalysisSearchFilter`](crate::model::AnalysisSearchFilter).
        pub fn build(self) -> crate::model::AnalysisSearchFilter {
            crate::model::AnalysisSearchFilter {
                operator: self.operator,
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl AnalysisSearchFilter {
    /// Creates a new builder-style object to manufacture [`AnalysisSearchFilter`](crate::model::AnalysisSearchFilter).
    pub fn builder() -> crate::model::analysis_search_filter::Builder {
        crate::model::analysis_search_filter::Builder::default()
    }
}

/// When writing a match expression against `AnalysisFilterAttribute`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let analysisfilterattribute = unimplemented!();
/// match analysisfilterattribute {
///     AnalysisFilterAttribute::AnalysisName => { /* ... */ },
///     AnalysisFilterAttribute::DirectQuicksightOwner => { /* ... */ },
///     AnalysisFilterAttribute::DirectQuicksightSoleOwner => { /* ... */ },
///     AnalysisFilterAttribute::DirectQuicksightViewerOrOwner => { /* ... */ },
///     AnalysisFilterAttribute::QuicksightOwner => { /* ... */ },
///     AnalysisFilterAttribute::QuicksightUser => { /* ... */ },
///     AnalysisFilterAttribute::QuicksightViewerOrOwner => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `analysisfilterattribute` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AnalysisFilterAttribute::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AnalysisFilterAttribute::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AnalysisFilterAttribute::NewFeature` is defined.
/// Specifically, when `analysisfilterattribute` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AnalysisFilterAttribute::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AnalysisFilterAttribute {
    #[allow(missing_docs)] // documentation missing in model
    AnalysisName,
    #[allow(missing_docs)] // documentation missing in model
    DirectQuicksightOwner,
    #[allow(missing_docs)] // documentation missing in model
    DirectQuicksightSoleOwner,
    #[allow(missing_docs)] // documentation missing in model
    DirectQuicksightViewerOrOwner,
    #[allow(missing_docs)] // documentation missing in model
    QuicksightOwner,
    #[allow(missing_docs)] // documentation missing in model
    QuicksightUser,
    #[allow(missing_docs)] // documentation missing in model
    QuicksightViewerOrOwner,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AnalysisFilterAttribute {
    fn from(s: &str) -> Self {
        match s {
            "ANALYSIS_NAME" => AnalysisFilterAttribute::AnalysisName,
            "DIRECT_QUICKSIGHT_OWNER" => AnalysisFilterAttribute::DirectQuicksightOwner,
            "DIRECT_QUICKSIGHT_SOLE_OWNER" => AnalysisFilterAttribute::DirectQuicksightSoleOwner,
            "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER" => {
                AnalysisFilterAttribute::DirectQuicksightViewerOrOwner
            }
            "QUICKSIGHT_OWNER" => AnalysisFilterAttribute::QuicksightOwner,
            "QUICKSIGHT_USER" => AnalysisFilterAttribute::QuicksightUser,
            "QUICKSIGHT_VIEWER_OR_OWNER" => AnalysisFilterAttribute::QuicksightViewerOrOwner,
            other => AnalysisFilterAttribute::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for AnalysisFilterAttribute {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AnalysisFilterAttribute::from(s))
    }
}
impl AnalysisFilterAttribute {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AnalysisFilterAttribute::AnalysisName => "ANALYSIS_NAME",
            AnalysisFilterAttribute::DirectQuicksightOwner => "DIRECT_QUICKSIGHT_OWNER",
            AnalysisFilterAttribute::DirectQuicksightSoleOwner => "DIRECT_QUICKSIGHT_SOLE_OWNER",
            AnalysisFilterAttribute::DirectQuicksightViewerOrOwner => {
                "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
            }
            AnalysisFilterAttribute::QuicksightOwner => "QUICKSIGHT_OWNER",
            AnalysisFilterAttribute::QuicksightUser => "QUICKSIGHT_USER",
            AnalysisFilterAttribute::QuicksightViewerOrOwner => "QUICKSIGHT_VIEWER_OR_OWNER",
            AnalysisFilterAttribute::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ANALYSIS_NAME",
            "DIRECT_QUICKSIGHT_OWNER",
            "DIRECT_QUICKSIGHT_SOLE_OWNER",
            "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER",
            "QUICKSIGHT_OWNER",
            "QUICKSIGHT_USER",
            "QUICKSIGHT_VIEWER_OR_OWNER",
        ]
    }
}
impl AsRef<str> for AnalysisFilterAttribute {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The theme version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThemeVersionSummary {
    /// <p>The version number of the theme version.</p>
    #[doc(hidden)]
    pub version_number: std::option::Option<i64>,
    /// <p>The Amazon Resource Name (ARN) of the theme version.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The description of the theme version.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date and time that this theme version was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the theme version.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ResourceStatus>,
}
impl ThemeVersionSummary {
    /// <p>The version number of the theme version.</p>
    pub fn version_number(&self) -> std::option::Option<i64> {
        self.version_number
    }
    /// <p>The Amazon Resource Name (ARN) of the theme version.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The description of the theme version.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The date and time that this theme version was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The status of the theme version.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ResourceStatus> {
        self.status.as_ref()
    }
}
/// See [`ThemeVersionSummary`](crate::model::ThemeVersionSummary).
pub mod theme_version_summary {

    /// A builder for [`ThemeVersionSummary`](crate::model::ThemeVersionSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) version_number: std::option::Option<i64>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::ResourceStatus>,
    }
    impl Builder {
        /// <p>The version number of the theme version.</p>
        pub fn version_number(mut self, input: i64) -> Self {
            self.version_number = Some(input);
            self
        }
        /// <p>The version number of the theme version.</p>
        pub fn set_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.version_number = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the theme version.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the theme version.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The description of the theme version.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the theme version.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The date and time that this theme version was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The date and time that this theme version was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The status of the theme version.</p>
        pub fn status(mut self, input: crate::model::ResourceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the theme version.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ResourceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ThemeVersionSummary`](crate::model::ThemeVersionSummary).
        pub fn build(self) -> crate::model::ThemeVersionSummary {
            crate::model::ThemeVersionSummary {
                version_number: self.version_number,
                arn: self.arn,
                description: self.description,
                created_time: self.created_time,
                status: self.status,
            }
        }
    }
}
impl ThemeVersionSummary {
    /// Creates a new builder-style object to manufacture [`ThemeVersionSummary`](crate::model::ThemeVersionSummary).
    pub fn builder() -> crate::model::theme_version_summary::Builder {
        crate::model::theme_version_summary::Builder::default()
    }
}

/// <p>The theme summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThemeSummary {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>the display name for the theme.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ID of the theme. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.</p>
    #[doc(hidden)]
    pub theme_id: std::option::Option<std::string::String>,
    /// <p>The latest version number for the theme. </p>
    #[doc(hidden)]
    pub latest_version_number: std::option::Option<i64>,
    /// <p>The date and time that this theme was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last date and time that this theme was updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ThemeSummary {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>the display name for the theme.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ID of the theme. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.</p>
    pub fn theme_id(&self) -> std::option::Option<&str> {
        self.theme_id.as_deref()
    }
    /// <p>The latest version number for the theme. </p>
    pub fn latest_version_number(&self) -> std::option::Option<i64> {
        self.latest_version_number
    }
    /// <p>The date and time that this theme was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The last date and time that this theme was updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
}
/// See [`ThemeSummary`](crate::model::ThemeSummary).
pub mod theme_summary {

    /// A builder for [`ThemeSummary`](crate::model::ThemeSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) theme_id: std::option::Option<std::string::String>,
        pub(crate) latest_version_number: std::option::Option<i64>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>the display name for the theme.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>the display name for the theme.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ID of the theme. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.</p>
        pub fn theme_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.theme_id = Some(input.into());
            self
        }
        /// <p>The ID of the theme. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.</p>
        pub fn set_theme_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.theme_id = input;
            self
        }
        /// <p>The latest version number for the theme. </p>
        pub fn latest_version_number(mut self, input: i64) -> Self {
            self.latest_version_number = Some(input);
            self
        }
        /// <p>The latest version number for the theme. </p>
        pub fn set_latest_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.latest_version_number = input;
            self
        }
        /// <p>The date and time that this theme was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The date and time that this theme was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The last date and time that this theme was updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The last date and time that this theme was updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ThemeSummary`](crate::model::ThemeSummary).
        pub fn build(self) -> crate::model::ThemeSummary {
            crate::model::ThemeSummary {
                arn: self.arn,
                name: self.name,
                theme_id: self.theme_id,
                latest_version_number: self.latest_version_number,
                created_time: self.created_time,
                last_updated_time: self.last_updated_time,
            }
        }
    }
}
impl ThemeSummary {
    /// Creates a new builder-style object to manufacture [`ThemeSummary`](crate::model::ThemeSummary).
    pub fn builder() -> crate::model::theme_summary::Builder {
        crate::model::theme_summary::Builder::default()
    }
}

/// When writing a match expression against `ThemeType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let themetype = unimplemented!();
/// match themetype {
///     ThemeType::All => { /* ... */ },
///     ThemeType::Custom => { /* ... */ },
///     ThemeType::Quicksight => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `themetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ThemeType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ThemeType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ThemeType::NewFeature` is defined.
/// Specifically, when `themetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ThemeType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ThemeType {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Custom,
    #[allow(missing_docs)] // documentation missing in model
    Quicksight,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ThemeType {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => ThemeType::All,
            "CUSTOM" => ThemeType::Custom,
            "QUICKSIGHT" => ThemeType::Quicksight,
            other => ThemeType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ThemeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ThemeType::from(s))
    }
}
impl ThemeType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ThemeType::All => "ALL",
            ThemeType::Custom => "CUSTOM",
            ThemeType::Quicksight => "QUICKSIGHT",
            ThemeType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL", "CUSTOM", "QUICKSIGHT"]
    }
}
impl AsRef<str> for ThemeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The template version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TemplateVersionSummary {
    /// <p>The Amazon Resource Name (ARN) of the template version.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The version number of the template version.</p>
    #[doc(hidden)]
    pub version_number: std::option::Option<i64>,
    /// <p>The time that this template version was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the template version.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ResourceStatus>,
    /// <p>The description of the template version.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl TemplateVersionSummary {
    /// <p>The Amazon Resource Name (ARN) of the template version.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The version number of the template version.</p>
    pub fn version_number(&self) -> std::option::Option<i64> {
        self.version_number
    }
    /// <p>The time that this template version was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The status of the template version.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ResourceStatus> {
        self.status.as_ref()
    }
    /// <p>The description of the template version.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
/// See [`TemplateVersionSummary`](crate::model::TemplateVersionSummary).
pub mod template_version_summary {

    /// A builder for [`TemplateVersionSummary`](crate::model::TemplateVersionSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) version_number: std::option::Option<i64>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::ResourceStatus>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the template version.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the template version.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The version number of the template version.</p>
        pub fn version_number(mut self, input: i64) -> Self {
            self.version_number = Some(input);
            self
        }
        /// <p>The version number of the template version.</p>
        pub fn set_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.version_number = input;
            self
        }
        /// <p>The time that this template version was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The time that this template version was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The status of the template version.</p>
        pub fn status(mut self, input: crate::model::ResourceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the template version.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ResourceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The description of the template version.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the template version.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateVersionSummary`](crate::model::TemplateVersionSummary).
        pub fn build(self) -> crate::model::TemplateVersionSummary {
            crate::model::TemplateVersionSummary {
                arn: self.arn,
                version_number: self.version_number,
                created_time: self.created_time,
                status: self.status,
                description: self.description,
            }
        }
    }
}
impl TemplateVersionSummary {
    /// Creates a new builder-style object to manufacture [`TemplateVersionSummary`](crate::model::TemplateVersionSummary).
    pub fn builder() -> crate::model::template_version_summary::Builder {
        crate::model::template_version_summary::Builder::default()
    }
}

/// <p>The template summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TemplateSummary {
    /// <p>A summary of a template.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ID of the template. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.</p>
    #[doc(hidden)]
    pub template_id: std::option::Option<std::string::String>,
    /// <p>A display name for the template.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A structure containing a list of version numbers for the template summary.</p>
    #[doc(hidden)]
    pub latest_version_number: std::option::Option<i64>,
    /// <p>The last time that this template was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time that this template was updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl TemplateSummary {
    /// <p>A summary of a template.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The ID of the template. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.</p>
    pub fn template_id(&self) -> std::option::Option<&str> {
        self.template_id.as_deref()
    }
    /// <p>A display name for the template.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A structure containing a list of version numbers for the template summary.</p>
    pub fn latest_version_number(&self) -> std::option::Option<i64> {
        self.latest_version_number
    }
    /// <p>The last time that this template was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The last time that this template was updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
}
/// See [`TemplateSummary`](crate::model::TemplateSummary).
pub mod template_summary {

    /// A builder for [`TemplateSummary`](crate::model::TemplateSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) template_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) latest_version_number: std::option::Option<i64>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>A summary of a template.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>A summary of a template.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ID of the template. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.</p>
        pub fn template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_id = Some(input.into());
            self
        }
        /// <p>The ID of the template. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.</p>
        pub fn set_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_id = input;
            self
        }
        /// <p>A display name for the template.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A display name for the template.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A structure containing a list of version numbers for the template summary.</p>
        pub fn latest_version_number(mut self, input: i64) -> Self {
            self.latest_version_number = Some(input);
            self
        }
        /// <p>A structure containing a list of version numbers for the template summary.</p>
        pub fn set_latest_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.latest_version_number = input;
            self
        }
        /// <p>The last time that this template was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The last time that this template was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The last time that this template was updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The last time that this template was updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateSummary`](crate::model::TemplateSummary).
        pub fn build(self) -> crate::model::TemplateSummary {
            crate::model::TemplateSummary {
                arn: self.arn,
                template_id: self.template_id,
                name: self.name,
                latest_version_number: self.latest_version_number,
                created_time: self.created_time,
                last_updated_time: self.last_updated_time,
            }
        }
    }
}
impl TemplateSummary {
    /// Creates a new builder-style object to manufacture [`TemplateSummary`](crate::model::TemplateSummary).
    pub fn builder() -> crate::model::template_summary::Builder {
        crate::model::template_summary::Builder::default()
    }
}

/// <p>The error type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NamespaceInfoV2 {
    /// <p>The name of the error.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The namespace ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The namespace Amazon Web Services Region.</p>
    #[doc(hidden)]
    pub capacity_region: std::option::Option<std::string::String>,
    /// <p>The creation status of a namespace that is not yet completely created.</p>
    #[doc(hidden)]
    pub creation_status: std::option::Option<crate::model::NamespaceStatus>,
    /// <p>The identity store used for the namespace.</p>
    #[doc(hidden)]
    pub identity_store: std::option::Option<crate::model::IdentityStore>,
    /// <p>An error that occurred when the namespace was created.</p>
    #[doc(hidden)]
    pub namespace_error: std::option::Option<crate::model::NamespaceError>,
}
impl NamespaceInfoV2 {
    /// <p>The name of the error.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The namespace ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The namespace Amazon Web Services Region.</p>
    pub fn capacity_region(&self) -> std::option::Option<&str> {
        self.capacity_region.as_deref()
    }
    /// <p>The creation status of a namespace that is not yet completely created.</p>
    pub fn creation_status(&self) -> std::option::Option<&crate::model::NamespaceStatus> {
        self.creation_status.as_ref()
    }
    /// <p>The identity store used for the namespace.</p>
    pub fn identity_store(&self) -> std::option::Option<&crate::model::IdentityStore> {
        self.identity_store.as_ref()
    }
    /// <p>An error that occurred when the namespace was created.</p>
    pub fn namespace_error(&self) -> std::option::Option<&crate::model::NamespaceError> {
        self.namespace_error.as_ref()
    }
}
/// See [`NamespaceInfoV2`](crate::model::NamespaceInfoV2).
pub mod namespace_info_v2 {

    /// A builder for [`NamespaceInfoV2`](crate::model::NamespaceInfoV2).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) capacity_region: std::option::Option<std::string::String>,
        pub(crate) creation_status: std::option::Option<crate::model::NamespaceStatus>,
        pub(crate) identity_store: std::option::Option<crate::model::IdentityStore>,
        pub(crate) namespace_error: std::option::Option<crate::model::NamespaceError>,
    }
    impl Builder {
        /// <p>The name of the error.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the error.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The namespace ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The namespace ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The namespace Amazon Web Services Region.</p>
        pub fn capacity_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.capacity_region = Some(input.into());
            self
        }
        /// <p>The namespace Amazon Web Services Region.</p>
        pub fn set_capacity_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.capacity_region = input;
            self
        }
        /// <p>The creation status of a namespace that is not yet completely created.</p>
        pub fn creation_status(mut self, input: crate::model::NamespaceStatus) -> Self {
            self.creation_status = Some(input);
            self
        }
        /// <p>The creation status of a namespace that is not yet completely created.</p>
        pub fn set_creation_status(
            mut self,
            input: std::option::Option<crate::model::NamespaceStatus>,
        ) -> Self {
            self.creation_status = input;
            self
        }
        /// <p>The identity store used for the namespace.</p>
        pub fn identity_store(mut self, input: crate::model::IdentityStore) -> Self {
            self.identity_store = Some(input);
            self
        }
        /// <p>The identity store used for the namespace.</p>
        pub fn set_identity_store(
            mut self,
            input: std::option::Option<crate::model::IdentityStore>,
        ) -> Self {
            self.identity_store = input;
            self
        }
        /// <p>An error that occurred when the namespace was created.</p>
        pub fn namespace_error(mut self, input: crate::model::NamespaceError) -> Self {
            self.namespace_error = Some(input);
            self
        }
        /// <p>An error that occurred when the namespace was created.</p>
        pub fn set_namespace_error(
            mut self,
            input: std::option::Option<crate::model::NamespaceError>,
        ) -> Self {
            self.namespace_error = input;
            self
        }
        /// Consumes the builder and constructs a [`NamespaceInfoV2`](crate::model::NamespaceInfoV2).
        pub fn build(self) -> crate::model::NamespaceInfoV2 {
            crate::model::NamespaceInfoV2 {
                name: self.name,
                arn: self.arn,
                capacity_region: self.capacity_region,
                creation_status: self.creation_status,
                identity_store: self.identity_store,
                namespace_error: self.namespace_error,
            }
        }
    }
}
impl NamespaceInfoV2 {
    /// Creates a new builder-style object to manufacture [`NamespaceInfoV2`](crate::model::NamespaceInfoV2).
    pub fn builder() -> crate::model::namespace_info_v2::Builder {
        crate::model::namespace_info_v2::Builder::default()
    }
}

/// <p>Errors that occur during namespace creation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NamespaceError {
    /// <p>The error type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::NamespaceErrorType>,
    /// <p>The message for the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl NamespaceError {
    /// <p>The error type.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::NamespaceErrorType> {
        self.r#type.as_ref()
    }
    /// <p>The message for the error.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`NamespaceError`](crate::model::NamespaceError).
pub mod namespace_error {

    /// A builder for [`NamespaceError`](crate::model::NamespaceError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::NamespaceErrorType>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error type.</p>
        pub fn r#type(mut self, input: crate::model::NamespaceErrorType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The error type.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::NamespaceErrorType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The message for the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NamespaceError`](crate::model::NamespaceError).
        pub fn build(self) -> crate::model::NamespaceError {
            crate::model::NamespaceError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl NamespaceError {
    /// Creates a new builder-style object to manufacture [`NamespaceError`](crate::model::NamespaceError).
    pub fn builder() -> crate::model::namespace_error::Builder {
        crate::model::namespace_error::Builder::default()
    }
}

/// When writing a match expression against `NamespaceErrorType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let namespaceerrortype = unimplemented!();
/// match namespaceerrortype {
///     NamespaceErrorType::InternalServiceError => { /* ... */ },
///     NamespaceErrorType::PermissionDenied => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `namespaceerrortype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NamespaceErrorType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NamespaceErrorType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NamespaceErrorType::NewFeature` is defined.
/// Specifically, when `namespaceerrortype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NamespaceErrorType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NamespaceErrorType {
    #[allow(missing_docs)] // documentation missing in model
    InternalServiceError,
    #[allow(missing_docs)] // documentation missing in model
    PermissionDenied,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NamespaceErrorType {
    fn from(s: &str) -> Self {
        match s {
            "INTERNAL_SERVICE_ERROR" => NamespaceErrorType::InternalServiceError,
            "PERMISSION_DENIED" => NamespaceErrorType::PermissionDenied,
            other => {
                NamespaceErrorType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for NamespaceErrorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NamespaceErrorType::from(s))
    }
}
impl NamespaceErrorType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NamespaceErrorType::InternalServiceError => "INTERNAL_SERVICE_ERROR",
            NamespaceErrorType::PermissionDenied => "PERMISSION_DENIED",
            NamespaceErrorType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INTERNAL_SERVICE_ERROR", "PERMISSION_DENIED"]
    }
}
impl AsRef<str> for NamespaceErrorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `IdentityStore`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let identitystore = unimplemented!();
/// match identitystore {
///     IdentityStore::Quicksight => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `identitystore` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `IdentityStore::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `IdentityStore::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `IdentityStore::NewFeature` is defined.
/// Specifically, when `identitystore` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `IdentityStore::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IdentityStore {
    #[allow(missing_docs)] // documentation missing in model
    Quicksight,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for IdentityStore {
    fn from(s: &str) -> Self {
        match s {
            "QUICKSIGHT" => IdentityStore::Quicksight,
            other => IdentityStore::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for IdentityStore {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IdentityStore::from(s))
    }
}
impl IdentityStore {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            IdentityStore::Quicksight => "QUICKSIGHT",
            IdentityStore::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["QUICKSIGHT"]
    }
}
impl AsRef<str> for IdentityStore {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `NamespaceStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let namespacestatus = unimplemented!();
/// match namespacestatus {
///     NamespaceStatus::Created => { /* ... */ },
///     NamespaceStatus::Creating => { /* ... */ },
///     NamespaceStatus::Deleting => { /* ... */ },
///     NamespaceStatus::NonRetryableFailure => { /* ... */ },
///     NamespaceStatus::RetryableFailure => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `namespacestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NamespaceStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NamespaceStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NamespaceStatus::NewFeature` is defined.
/// Specifically, when `namespacestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NamespaceStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NamespaceStatus {
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    NonRetryableFailure,
    #[allow(missing_docs)] // documentation missing in model
    RetryableFailure,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NamespaceStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATED" => NamespaceStatus::Created,
            "CREATING" => NamespaceStatus::Creating,
            "DELETING" => NamespaceStatus::Deleting,
            "NON_RETRYABLE_FAILURE" => NamespaceStatus::NonRetryableFailure,
            "RETRYABLE_FAILURE" => NamespaceStatus::RetryableFailure,
            other => NamespaceStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for NamespaceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NamespaceStatus::from(s))
    }
}
impl NamespaceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NamespaceStatus::Created => "CREATED",
            NamespaceStatus::Creating => "CREATING",
            NamespaceStatus::Deleting => "DELETING",
            NamespaceStatus::NonRetryableFailure => "NON_RETRYABLE_FAILURE",
            NamespaceStatus::RetryableFailure => "RETRYABLE_FAILURE",
            NamespaceStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATED",
            "CREATING",
            "DELETING",
            "NON_RETRYABLE_FAILURE",
            "RETRYABLE_FAILURE",
        ]
    }
}
impl AsRef<str> for NamespaceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the SPICE ingestion for a dataset.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Ingestion {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Ingestion ID.</p>
    #[doc(hidden)]
    pub ingestion_id: std::option::Option<std::string::String>,
    /// <p>Ingestion status.</p>
    #[doc(hidden)]
    pub ingestion_status: std::option::Option<crate::model::IngestionStatus>,
    /// <p>Error information for this ingestion.</p>
    #[doc(hidden)]
    pub error_info: std::option::Option<crate::model::ErrorInfo>,
    /// <p>Information about rows for a data set SPICE ingestion.</p>
    #[doc(hidden)]
    pub row_info: std::option::Option<crate::model::RowInfo>,
    /// <p>Information about a queued dataset SPICE ingestion.</p>
    #[doc(hidden)]
    pub queue_info: std::option::Option<crate::model::QueueInfo>,
    /// <p>The time that this ingestion started.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that this ingestion took, measured in seconds.</p>
    #[doc(hidden)]
    pub ingestion_time_in_seconds: std::option::Option<i64>,
    /// <p>The size of the data ingested, in bytes.</p>
    #[doc(hidden)]
    pub ingestion_size_in_bytes: std::option::Option<i64>,
    /// <p>Event source for this ingestion.</p>
    #[doc(hidden)]
    pub request_source: std::option::Option<crate::model::IngestionRequestSource>,
    /// <p>Type of this ingestion.</p>
    #[doc(hidden)]
    pub request_type: std::option::Option<crate::model::IngestionRequestType>,
}
impl Ingestion {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Ingestion ID.</p>
    pub fn ingestion_id(&self) -> std::option::Option<&str> {
        self.ingestion_id.as_deref()
    }
    /// <p>Ingestion status.</p>
    pub fn ingestion_status(&self) -> std::option::Option<&crate::model::IngestionStatus> {
        self.ingestion_status.as_ref()
    }
    /// <p>Error information for this ingestion.</p>
    pub fn error_info(&self) -> std::option::Option<&crate::model::ErrorInfo> {
        self.error_info.as_ref()
    }
    /// <p>Information about rows for a data set SPICE ingestion.</p>
    pub fn row_info(&self) -> std::option::Option<&crate::model::RowInfo> {
        self.row_info.as_ref()
    }
    /// <p>Information about a queued dataset SPICE ingestion.</p>
    pub fn queue_info(&self) -> std::option::Option<&crate::model::QueueInfo> {
        self.queue_info.as_ref()
    }
    /// <p>The time that this ingestion started.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The time that this ingestion took, measured in seconds.</p>
    pub fn ingestion_time_in_seconds(&self) -> std::option::Option<i64> {
        self.ingestion_time_in_seconds
    }
    /// <p>The size of the data ingested, in bytes.</p>
    pub fn ingestion_size_in_bytes(&self) -> std::option::Option<i64> {
        self.ingestion_size_in_bytes
    }
    /// <p>Event source for this ingestion.</p>
    pub fn request_source(&self) -> std::option::Option<&crate::model::IngestionRequestSource> {
        self.request_source.as_ref()
    }
    /// <p>Type of this ingestion.</p>
    pub fn request_type(&self) -> std::option::Option<&crate::model::IngestionRequestType> {
        self.request_type.as_ref()
    }
}
/// See [`Ingestion`](crate::model::Ingestion).
pub mod ingestion {

    /// A builder for [`Ingestion`](crate::model::Ingestion).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) ingestion_id: std::option::Option<std::string::String>,
        pub(crate) ingestion_status: std::option::Option<crate::model::IngestionStatus>,
        pub(crate) error_info: std::option::Option<crate::model::ErrorInfo>,
        pub(crate) row_info: std::option::Option<crate::model::RowInfo>,
        pub(crate) queue_info: std::option::Option<crate::model::QueueInfo>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) ingestion_time_in_seconds: std::option::Option<i64>,
        pub(crate) ingestion_size_in_bytes: std::option::Option<i64>,
        pub(crate) request_source: std::option::Option<crate::model::IngestionRequestSource>,
        pub(crate) request_type: std::option::Option<crate::model::IngestionRequestType>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Ingestion ID.</p>
        pub fn ingestion_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ingestion_id = Some(input.into());
            self
        }
        /// <p>Ingestion ID.</p>
        pub fn set_ingestion_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ingestion_id = input;
            self
        }
        /// <p>Ingestion status.</p>
        pub fn ingestion_status(mut self, input: crate::model::IngestionStatus) -> Self {
            self.ingestion_status = Some(input);
            self
        }
        /// <p>Ingestion status.</p>
        pub fn set_ingestion_status(
            mut self,
            input: std::option::Option<crate::model::IngestionStatus>,
        ) -> Self {
            self.ingestion_status = input;
            self
        }
        /// <p>Error information for this ingestion.</p>
        pub fn error_info(mut self, input: crate::model::ErrorInfo) -> Self {
            self.error_info = Some(input);
            self
        }
        /// <p>Error information for this ingestion.</p>
        pub fn set_error_info(
            mut self,
            input: std::option::Option<crate::model::ErrorInfo>,
        ) -> Self {
            self.error_info = input;
            self
        }
        /// <p>Information about rows for a data set SPICE ingestion.</p>
        pub fn row_info(mut self, input: crate::model::RowInfo) -> Self {
            self.row_info = Some(input);
            self
        }
        /// <p>Information about rows for a data set SPICE ingestion.</p>
        pub fn set_row_info(mut self, input: std::option::Option<crate::model::RowInfo>) -> Self {
            self.row_info = input;
            self
        }
        /// <p>Information about a queued dataset SPICE ingestion.</p>
        pub fn queue_info(mut self, input: crate::model::QueueInfo) -> Self {
            self.queue_info = Some(input);
            self
        }
        /// <p>Information about a queued dataset SPICE ingestion.</p>
        pub fn set_queue_info(
            mut self,
            input: std::option::Option<crate::model::QueueInfo>,
        ) -> Self {
            self.queue_info = input;
            self
        }
        /// <p>The time that this ingestion started.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The time that this ingestion started.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The time that this ingestion took, measured in seconds.</p>
        pub fn ingestion_time_in_seconds(mut self, input: i64) -> Self {
            self.ingestion_time_in_seconds = Some(input);
            self
        }
        /// <p>The time that this ingestion took, measured in seconds.</p>
        pub fn set_ingestion_time_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.ingestion_time_in_seconds = input;
            self
        }
        /// <p>The size of the data ingested, in bytes.</p>
        pub fn ingestion_size_in_bytes(mut self, input: i64) -> Self {
            self.ingestion_size_in_bytes = Some(input);
            self
        }
        /// <p>The size of the data ingested, in bytes.</p>
        pub fn set_ingestion_size_in_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.ingestion_size_in_bytes = input;
            self
        }
        /// <p>Event source for this ingestion.</p>
        pub fn request_source(mut self, input: crate::model::IngestionRequestSource) -> Self {
            self.request_source = Some(input);
            self
        }
        /// <p>Event source for this ingestion.</p>
        pub fn set_request_source(
            mut self,
            input: std::option::Option<crate::model::IngestionRequestSource>,
        ) -> Self {
            self.request_source = input;
            self
        }
        /// <p>Type of this ingestion.</p>
        pub fn request_type(mut self, input: crate::model::IngestionRequestType) -> Self {
            self.request_type = Some(input);
            self
        }
        /// <p>Type of this ingestion.</p>
        pub fn set_request_type(
            mut self,
            input: std::option::Option<crate::model::IngestionRequestType>,
        ) -> Self {
            self.request_type = input;
            self
        }
        /// Consumes the builder and constructs a [`Ingestion`](crate::model::Ingestion).
        pub fn build(self) -> crate::model::Ingestion {
            crate::model::Ingestion {
                arn: self.arn,
                ingestion_id: self.ingestion_id,
                ingestion_status: self.ingestion_status,
                error_info: self.error_info,
                row_info: self.row_info,
                queue_info: self.queue_info,
                created_time: self.created_time,
                ingestion_time_in_seconds: self.ingestion_time_in_seconds,
                ingestion_size_in_bytes: self.ingestion_size_in_bytes,
                request_source: self.request_source,
                request_type: self.request_type,
            }
        }
    }
}
impl Ingestion {
    /// Creates a new builder-style object to manufacture [`Ingestion`](crate::model::Ingestion).
    pub fn builder() -> crate::model::ingestion::Builder {
        crate::model::ingestion::Builder::default()
    }
}

/// When writing a match expression against `IngestionRequestType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let ingestionrequesttype = unimplemented!();
/// match ingestionrequesttype {
///     IngestionRequestType::Edit => { /* ... */ },
///     IngestionRequestType::FullRefresh => { /* ... */ },
///     IngestionRequestType::IncrementalRefresh => { /* ... */ },
///     IngestionRequestType::InitialIngestion => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ingestionrequesttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `IngestionRequestType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `IngestionRequestType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `IngestionRequestType::NewFeature` is defined.
/// Specifically, when `ingestionrequesttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `IngestionRequestType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// This defines the type of ingestion request. This is returned as part of create ingestion response.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IngestionRequestType {
    #[allow(missing_docs)] // documentation missing in model
    Edit,
    #[allow(missing_docs)] // documentation missing in model
    FullRefresh,
    #[allow(missing_docs)] // documentation missing in model
    IncrementalRefresh,
    #[allow(missing_docs)] // documentation missing in model
    InitialIngestion,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for IngestionRequestType {
    fn from(s: &str) -> Self {
        match s {
            "EDIT" => IngestionRequestType::Edit,
            "FULL_REFRESH" => IngestionRequestType::FullRefresh,
            "INCREMENTAL_REFRESH" => IngestionRequestType::IncrementalRefresh,
            "INITIAL_INGESTION" => IngestionRequestType::InitialIngestion,
            other => {
                IngestionRequestType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for IngestionRequestType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IngestionRequestType::from(s))
    }
}
impl IngestionRequestType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            IngestionRequestType::Edit => "EDIT",
            IngestionRequestType::FullRefresh => "FULL_REFRESH",
            IngestionRequestType::IncrementalRefresh => "INCREMENTAL_REFRESH",
            IngestionRequestType::InitialIngestion => "INITIAL_INGESTION",
            IngestionRequestType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "EDIT",
            "FULL_REFRESH",
            "INCREMENTAL_REFRESH",
            "INITIAL_INGESTION",
        ]
    }
}
impl AsRef<str> for IngestionRequestType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `IngestionRequestSource`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let ingestionrequestsource = unimplemented!();
/// match ingestionrequestsource {
///     IngestionRequestSource::Manual => { /* ... */ },
///     IngestionRequestSource::Scheduled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ingestionrequestsource` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `IngestionRequestSource::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `IngestionRequestSource::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `IngestionRequestSource::NewFeature` is defined.
/// Specifically, when `ingestionrequestsource` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `IngestionRequestSource::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IngestionRequestSource {
    #[allow(missing_docs)] // documentation missing in model
    Manual,
    #[allow(missing_docs)] // documentation missing in model
    Scheduled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for IngestionRequestSource {
    fn from(s: &str) -> Self {
        match s {
            "MANUAL" => IngestionRequestSource::Manual,
            "SCHEDULED" => IngestionRequestSource::Scheduled,
            other => {
                IngestionRequestSource::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for IngestionRequestSource {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IngestionRequestSource::from(s))
    }
}
impl IngestionRequestSource {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            IngestionRequestSource::Manual => "MANUAL",
            IngestionRequestSource::Scheduled => "SCHEDULED",
            IngestionRequestSource::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["MANUAL", "SCHEDULED"]
    }
}
impl AsRef<str> for IngestionRequestSource {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a queued dataset SPICE ingestion.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueueInfo {
    /// <p>The ID of the queued ingestion.</p>
    #[doc(hidden)]
    pub waiting_on_ingestion: std::option::Option<std::string::String>,
    /// <p>The ID of the ongoing ingestion. The queued ingestion is waiting for the ongoing ingestion to complete.</p>
    #[doc(hidden)]
    pub queued_ingestion: std::option::Option<std::string::String>,
}
impl QueueInfo {
    /// <p>The ID of the queued ingestion.</p>
    pub fn waiting_on_ingestion(&self) -> std::option::Option<&str> {
        self.waiting_on_ingestion.as_deref()
    }
    /// <p>The ID of the ongoing ingestion. The queued ingestion is waiting for the ongoing ingestion to complete.</p>
    pub fn queued_ingestion(&self) -> std::option::Option<&str> {
        self.queued_ingestion.as_deref()
    }
}
/// See [`QueueInfo`](crate::model::QueueInfo).
pub mod queue_info {

    /// A builder for [`QueueInfo`](crate::model::QueueInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) waiting_on_ingestion: std::option::Option<std::string::String>,
        pub(crate) queued_ingestion: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the queued ingestion.</p>
        pub fn waiting_on_ingestion(mut self, input: impl Into<std::string::String>) -> Self {
            self.waiting_on_ingestion = Some(input.into());
            self
        }
        /// <p>The ID of the queued ingestion.</p>
        pub fn set_waiting_on_ingestion(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.waiting_on_ingestion = input;
            self
        }
        /// <p>The ID of the ongoing ingestion. The queued ingestion is waiting for the ongoing ingestion to complete.</p>
        pub fn queued_ingestion(mut self, input: impl Into<std::string::String>) -> Self {
            self.queued_ingestion = Some(input.into());
            self
        }
        /// <p>The ID of the ongoing ingestion. The queued ingestion is waiting for the ongoing ingestion to complete.</p>
        pub fn set_queued_ingestion(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.queued_ingestion = input;
            self
        }
        /// Consumes the builder and constructs a [`QueueInfo`](crate::model::QueueInfo).
        pub fn build(self) -> crate::model::QueueInfo {
            crate::model::QueueInfo {
                waiting_on_ingestion: self.waiting_on_ingestion,
                queued_ingestion: self.queued_ingestion,
            }
        }
    }
}
impl QueueInfo {
    /// Creates a new builder-style object to manufacture [`QueueInfo`](crate::model::QueueInfo).
    pub fn builder() -> crate::model::queue_info::Builder {
        crate::model::queue_info::Builder::default()
    }
}

/// <p>Information about rows for a data set SPICE ingestion.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RowInfo {
    /// <p>The number of rows that were ingested.</p>
    #[doc(hidden)]
    pub rows_ingested: std::option::Option<i64>,
    /// <p>The number of rows that were not ingested.</p>
    #[doc(hidden)]
    pub rows_dropped: std::option::Option<i64>,
    /// <p>The total number of rows in the dataset.</p>
    #[doc(hidden)]
    pub total_rows_in_dataset: std::option::Option<i64>,
}
impl RowInfo {
    /// <p>The number of rows that were ingested.</p>
    pub fn rows_ingested(&self) -> std::option::Option<i64> {
        self.rows_ingested
    }
    /// <p>The number of rows that were not ingested.</p>
    pub fn rows_dropped(&self) -> std::option::Option<i64> {
        self.rows_dropped
    }
    /// <p>The total number of rows in the dataset.</p>
    pub fn total_rows_in_dataset(&self) -> std::option::Option<i64> {
        self.total_rows_in_dataset
    }
}
/// See [`RowInfo`](crate::model::RowInfo).
pub mod row_info {

    /// A builder for [`RowInfo`](crate::model::RowInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rows_ingested: std::option::Option<i64>,
        pub(crate) rows_dropped: std::option::Option<i64>,
        pub(crate) total_rows_in_dataset: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The number of rows that were ingested.</p>
        pub fn rows_ingested(mut self, input: i64) -> Self {
            self.rows_ingested = Some(input);
            self
        }
        /// <p>The number of rows that were ingested.</p>
        pub fn set_rows_ingested(mut self, input: std::option::Option<i64>) -> Self {
            self.rows_ingested = input;
            self
        }
        /// <p>The number of rows that were not ingested.</p>
        pub fn rows_dropped(mut self, input: i64) -> Self {
            self.rows_dropped = Some(input);
            self
        }
        /// <p>The number of rows that were not ingested.</p>
        pub fn set_rows_dropped(mut self, input: std::option::Option<i64>) -> Self {
            self.rows_dropped = input;
            self
        }
        /// <p>The total number of rows in the dataset.</p>
        pub fn total_rows_in_dataset(mut self, input: i64) -> Self {
            self.total_rows_in_dataset = Some(input);
            self
        }
        /// <p>The total number of rows in the dataset.</p>
        pub fn set_total_rows_in_dataset(mut self, input: std::option::Option<i64>) -> Self {
            self.total_rows_in_dataset = input;
            self
        }
        /// Consumes the builder and constructs a [`RowInfo`](crate::model::RowInfo).
        pub fn build(self) -> crate::model::RowInfo {
            crate::model::RowInfo {
                rows_ingested: self.rows_ingested,
                rows_dropped: self.rows_dropped,
                total_rows_in_dataset: self.total_rows_in_dataset,
            }
        }
    }
}
impl RowInfo {
    /// Creates a new builder-style object to manufacture [`RowInfo`](crate::model::RowInfo).
    pub fn builder() -> crate::model::row_info::Builder {
        crate::model::row_info::Builder::default()
    }
}

/// <p>Error information for the SPICE ingestion of a dataset.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ErrorInfo {
    /// <p>Error type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::IngestionErrorType>,
    /// <p>Error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ErrorInfo {
    /// <p>Error type.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::IngestionErrorType> {
        self.r#type.as_ref()
    }
    /// <p>Error message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`ErrorInfo`](crate::model::ErrorInfo).
pub mod error_info {

    /// A builder for [`ErrorInfo`](crate::model::ErrorInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::IngestionErrorType>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error type.</p>
        pub fn r#type(mut self, input: crate::model::IngestionErrorType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Error type.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::IngestionErrorType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ErrorInfo`](crate::model::ErrorInfo).
        pub fn build(self) -> crate::model::ErrorInfo {
            crate::model::ErrorInfo {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl ErrorInfo {
    /// Creates a new builder-style object to manufacture [`ErrorInfo`](crate::model::ErrorInfo).
    pub fn builder() -> crate::model::error_info::Builder {
        crate::model::error_info::Builder::default()
    }
}

/// When writing a match expression against `IngestionErrorType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let ingestionerrortype = unimplemented!();
/// match ingestionerrortype {
///     IngestionErrorType::AccountCapacityLimitExceeded => { /* ... */ },
///     IngestionErrorType::ConnectionFailure => { /* ... */ },
///     IngestionErrorType::CursorNotEnabled => { /* ... */ },
///     IngestionErrorType::CustomerError => { /* ... */ },
///     IngestionErrorType::DataSetDeleted => { /* ... */ },
///     IngestionErrorType::DataSetNotSpice => { /* ... */ },
///     IngestionErrorType::DataSetSizeLimitExceeded => { /* ... */ },
///     IngestionErrorType::DataSourceAuthFailed => { /* ... */ },
///     IngestionErrorType::DataSourceConnectionFailed => { /* ... */ },
///     IngestionErrorType::DataSourceNotFound => { /* ... */ },
///     IngestionErrorType::DataToleranceException => { /* ... */ },
///     IngestionErrorType::ElasticsearchCursorNotEnabled => { /* ... */ },
///     IngestionErrorType::FailureToAssumeRole => { /* ... */ },
///     IngestionErrorType::FailureToProcessJsonFile => { /* ... */ },
///     IngestionErrorType::IamRoleNotAvailable => { /* ... */ },
///     IngestionErrorType::IngestionCanceled => { /* ... */ },
///     IngestionErrorType::IngestionSuperseded => { /* ... */ },
///     IngestionErrorType::InternalServiceError => { /* ... */ },
///     IngestionErrorType::InvalidDataprepSyntax => { /* ... */ },
///     IngestionErrorType::InvalidDataSourceConfig => { /* ... */ },
///     IngestionErrorType::InvalidDateFormat => { /* ... */ },
///     IngestionErrorType::IotDataSetFileEmpty => { /* ... */ },
///     IngestionErrorType::IotFileNotFound => { /* ... */ },
///     IngestionErrorType::OauthTokenFailure => { /* ... */ },
///     IngestionErrorType::PasswordAuthenticationFailure => { /* ... */ },
///     IngestionErrorType::PermissionDenied => { /* ... */ },
///     IngestionErrorType::PermissionNotFound => { /* ... */ },
///     IngestionErrorType::QueryTimeout => { /* ... */ },
///     IngestionErrorType::RefreshSuppressedByEdit => { /* ... */ },
///     IngestionErrorType::RowSizeLimitExceeded => { /* ... */ },
///     IngestionErrorType::S3FileInaccessible => { /* ... */ },
///     IngestionErrorType::S3ManifestError => { /* ... */ },
///     IngestionErrorType::S3UploadedFileDeleted => { /* ... */ },
///     IngestionErrorType::SourceApiLimitExceededFailure => { /* ... */ },
///     IngestionErrorType::SourceResourceLimitExceeded => { /* ... */ },
///     IngestionErrorType::SpiceTableNotFound => { /* ... */ },
///     IngestionErrorType::SqlException => { /* ... */ },
///     IngestionErrorType::SqlInvalidParameterValue => { /* ... */ },
///     IngestionErrorType::SqlNumericOverflow => { /* ... */ },
///     IngestionErrorType::SqlSchemaMismatchError => { /* ... */ },
///     IngestionErrorType::SqlTableNotFound => { /* ... */ },
///     IngestionErrorType::SslCertificateValidationFailure => { /* ... */ },
///     IngestionErrorType::UnresolvableHost => { /* ... */ },
///     IngestionErrorType::UnroutableHost => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ingestionerrortype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `IngestionErrorType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `IngestionErrorType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `IngestionErrorType::NewFeature` is defined.
/// Specifically, when `ingestionerrortype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `IngestionErrorType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IngestionErrorType {
    #[allow(missing_docs)] // documentation missing in model
    AccountCapacityLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    ConnectionFailure,
    #[allow(missing_docs)] // documentation missing in model
    CursorNotEnabled,
    #[allow(missing_docs)] // documentation missing in model
    CustomerError,
    #[allow(missing_docs)] // documentation missing in model
    DataSetDeleted,
    #[allow(missing_docs)] // documentation missing in model
    DataSetNotSpice,
    #[allow(missing_docs)] // documentation missing in model
    DataSetSizeLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    DataSourceAuthFailed,
    #[allow(missing_docs)] // documentation missing in model
    DataSourceConnectionFailed,
    #[allow(missing_docs)] // documentation missing in model
    DataSourceNotFound,
    #[allow(missing_docs)] // documentation missing in model
    DataToleranceException,
    #[allow(missing_docs)] // documentation missing in model
    ElasticsearchCursorNotEnabled,
    #[allow(missing_docs)] // documentation missing in model
    FailureToAssumeRole,
    #[allow(missing_docs)] // documentation missing in model
    FailureToProcessJsonFile,
    #[allow(missing_docs)] // documentation missing in model
    IamRoleNotAvailable,
    #[allow(missing_docs)] // documentation missing in model
    IngestionCanceled,
    #[allow(missing_docs)] // documentation missing in model
    IngestionSuperseded,
    #[allow(missing_docs)] // documentation missing in model
    InternalServiceError,
    #[allow(missing_docs)] // documentation missing in model
    InvalidDataprepSyntax,
    #[allow(missing_docs)] // documentation missing in model
    InvalidDataSourceConfig,
    #[allow(missing_docs)] // documentation missing in model
    InvalidDateFormat,
    #[allow(missing_docs)] // documentation missing in model
    IotDataSetFileEmpty,
    #[allow(missing_docs)] // documentation missing in model
    IotFileNotFound,
    #[allow(missing_docs)] // documentation missing in model
    OauthTokenFailure,
    #[allow(missing_docs)] // documentation missing in model
    PasswordAuthenticationFailure,
    #[allow(missing_docs)] // documentation missing in model
    PermissionDenied,
    #[allow(missing_docs)] // documentation missing in model
    PermissionNotFound,
    #[allow(missing_docs)] // documentation missing in model
    QueryTimeout,
    #[allow(missing_docs)] // documentation missing in model
    RefreshSuppressedByEdit,
    #[allow(missing_docs)] // documentation missing in model
    RowSizeLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    S3FileInaccessible,
    #[allow(missing_docs)] // documentation missing in model
    S3ManifestError,
    #[allow(missing_docs)] // documentation missing in model
    S3UploadedFileDeleted,
    #[allow(missing_docs)] // documentation missing in model
    SourceApiLimitExceededFailure,
    #[allow(missing_docs)] // documentation missing in model
    SourceResourceLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    SpiceTableNotFound,
    #[allow(missing_docs)] // documentation missing in model
    SqlException,
    #[allow(missing_docs)] // documentation missing in model
    SqlInvalidParameterValue,
    #[allow(missing_docs)] // documentation missing in model
    SqlNumericOverflow,
    #[allow(missing_docs)] // documentation missing in model
    SqlSchemaMismatchError,
    #[allow(missing_docs)] // documentation missing in model
    SqlTableNotFound,
    #[allow(missing_docs)] // documentation missing in model
    SslCertificateValidationFailure,
    #[allow(missing_docs)] // documentation missing in model
    UnresolvableHost,
    #[allow(missing_docs)] // documentation missing in model
    UnroutableHost,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for IngestionErrorType {
    fn from(s: &str) -> Self {
        match s {
            "ACCOUNT_CAPACITY_LIMIT_EXCEEDED" => IngestionErrorType::AccountCapacityLimitExceeded,
            "CONNECTION_FAILURE" => IngestionErrorType::ConnectionFailure,
            "CURSOR_NOT_ENABLED" => IngestionErrorType::CursorNotEnabled,
            "CUSTOMER_ERROR" => IngestionErrorType::CustomerError,
            "DATA_SET_DELETED" => IngestionErrorType::DataSetDeleted,
            "DATA_SET_NOT_SPICE" => IngestionErrorType::DataSetNotSpice,
            "DATA_SET_SIZE_LIMIT_EXCEEDED" => IngestionErrorType::DataSetSizeLimitExceeded,
            "DATA_SOURCE_AUTH_FAILED" => IngestionErrorType::DataSourceAuthFailed,
            "DATA_SOURCE_CONNECTION_FAILED" => IngestionErrorType::DataSourceConnectionFailed,
            "DATA_SOURCE_NOT_FOUND" => IngestionErrorType::DataSourceNotFound,
            "DATA_TOLERANCE_EXCEPTION" => IngestionErrorType::DataToleranceException,
            "ELASTICSEARCH_CURSOR_NOT_ENABLED" => IngestionErrorType::ElasticsearchCursorNotEnabled,
            "FAILURE_TO_ASSUME_ROLE" => IngestionErrorType::FailureToAssumeRole,
            "FAILURE_TO_PROCESS_JSON_FILE" => IngestionErrorType::FailureToProcessJsonFile,
            "IAM_ROLE_NOT_AVAILABLE" => IngestionErrorType::IamRoleNotAvailable,
            "INGESTION_CANCELED" => IngestionErrorType::IngestionCanceled,
            "INGESTION_SUPERSEDED" => IngestionErrorType::IngestionSuperseded,
            "INTERNAL_SERVICE_ERROR" => IngestionErrorType::InternalServiceError,
            "INVALID_DATAPREP_SYNTAX" => IngestionErrorType::InvalidDataprepSyntax,
            "INVALID_DATA_SOURCE_CONFIG" => IngestionErrorType::InvalidDataSourceConfig,
            "INVALID_DATE_FORMAT" => IngestionErrorType::InvalidDateFormat,
            "IOT_DATA_SET_FILE_EMPTY" => IngestionErrorType::IotDataSetFileEmpty,
            "IOT_FILE_NOT_FOUND" => IngestionErrorType::IotFileNotFound,
            "OAUTH_TOKEN_FAILURE" => IngestionErrorType::OauthTokenFailure,
            "PASSWORD_AUTHENTICATION_FAILURE" => IngestionErrorType::PasswordAuthenticationFailure,
            "PERMISSION_DENIED" => IngestionErrorType::PermissionDenied,
            "PERMISSION_NOT_FOUND" => IngestionErrorType::PermissionNotFound,
            "QUERY_TIMEOUT" => IngestionErrorType::QueryTimeout,
            "REFRESH_SUPPRESSED_BY_EDIT" => IngestionErrorType::RefreshSuppressedByEdit,
            "ROW_SIZE_LIMIT_EXCEEDED" => IngestionErrorType::RowSizeLimitExceeded,
            "S3_FILE_INACCESSIBLE" => IngestionErrorType::S3FileInaccessible,
            "S3_MANIFEST_ERROR" => IngestionErrorType::S3ManifestError,
            "S3_UPLOADED_FILE_DELETED" => IngestionErrorType::S3UploadedFileDeleted,
            "SOURCE_API_LIMIT_EXCEEDED_FAILURE" => {
                IngestionErrorType::SourceApiLimitExceededFailure
            }
            "SOURCE_RESOURCE_LIMIT_EXCEEDED" => IngestionErrorType::SourceResourceLimitExceeded,
            "SPICE_TABLE_NOT_FOUND" => IngestionErrorType::SpiceTableNotFound,
            "SQL_EXCEPTION" => IngestionErrorType::SqlException,
            "SQL_INVALID_PARAMETER_VALUE" => IngestionErrorType::SqlInvalidParameterValue,
            "SQL_NUMERIC_OVERFLOW" => IngestionErrorType::SqlNumericOverflow,
            "SQL_SCHEMA_MISMATCH_ERROR" => IngestionErrorType::SqlSchemaMismatchError,
            "SQL_TABLE_NOT_FOUND" => IngestionErrorType::SqlTableNotFound,
            "SSL_CERTIFICATE_VALIDATION_FAILURE" => {
                IngestionErrorType::SslCertificateValidationFailure
            }
            "UNRESOLVABLE_HOST" => IngestionErrorType::UnresolvableHost,
            "UNROUTABLE_HOST" => IngestionErrorType::UnroutableHost,
            other => {
                IngestionErrorType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for IngestionErrorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IngestionErrorType::from(s))
    }
}
impl IngestionErrorType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            IngestionErrorType::AccountCapacityLimitExceeded => "ACCOUNT_CAPACITY_LIMIT_EXCEEDED",
            IngestionErrorType::ConnectionFailure => "CONNECTION_FAILURE",
            IngestionErrorType::CursorNotEnabled => "CURSOR_NOT_ENABLED",
            IngestionErrorType::CustomerError => "CUSTOMER_ERROR",
            IngestionErrorType::DataSetDeleted => "DATA_SET_DELETED",
            IngestionErrorType::DataSetNotSpice => "DATA_SET_NOT_SPICE",
            IngestionErrorType::DataSetSizeLimitExceeded => "DATA_SET_SIZE_LIMIT_EXCEEDED",
            IngestionErrorType::DataSourceAuthFailed => "DATA_SOURCE_AUTH_FAILED",
            IngestionErrorType::DataSourceConnectionFailed => "DATA_SOURCE_CONNECTION_FAILED",
            IngestionErrorType::DataSourceNotFound => "DATA_SOURCE_NOT_FOUND",
            IngestionErrorType::DataToleranceException => "DATA_TOLERANCE_EXCEPTION",
            IngestionErrorType::ElasticsearchCursorNotEnabled => "ELASTICSEARCH_CURSOR_NOT_ENABLED",
            IngestionErrorType::FailureToAssumeRole => "FAILURE_TO_ASSUME_ROLE",
            IngestionErrorType::FailureToProcessJsonFile => "FAILURE_TO_PROCESS_JSON_FILE",
            IngestionErrorType::IamRoleNotAvailable => "IAM_ROLE_NOT_AVAILABLE",
            IngestionErrorType::IngestionCanceled => "INGESTION_CANCELED",
            IngestionErrorType::IngestionSuperseded => "INGESTION_SUPERSEDED",
            IngestionErrorType::InternalServiceError => "INTERNAL_SERVICE_ERROR",
            IngestionErrorType::InvalidDataprepSyntax => "INVALID_DATAPREP_SYNTAX",
            IngestionErrorType::InvalidDataSourceConfig => "INVALID_DATA_SOURCE_CONFIG",
            IngestionErrorType::InvalidDateFormat => "INVALID_DATE_FORMAT",
            IngestionErrorType::IotDataSetFileEmpty => "IOT_DATA_SET_FILE_EMPTY",
            IngestionErrorType::IotFileNotFound => "IOT_FILE_NOT_FOUND",
            IngestionErrorType::OauthTokenFailure => "OAUTH_TOKEN_FAILURE",
            IngestionErrorType::PasswordAuthenticationFailure => "PASSWORD_AUTHENTICATION_FAILURE",
            IngestionErrorType::PermissionDenied => "PERMISSION_DENIED",
            IngestionErrorType::PermissionNotFound => "PERMISSION_NOT_FOUND",
            IngestionErrorType::QueryTimeout => "QUERY_TIMEOUT",
            IngestionErrorType::RefreshSuppressedByEdit => "REFRESH_SUPPRESSED_BY_EDIT",
            IngestionErrorType::RowSizeLimitExceeded => "ROW_SIZE_LIMIT_EXCEEDED",
            IngestionErrorType::S3FileInaccessible => "S3_FILE_INACCESSIBLE",
            IngestionErrorType::S3ManifestError => "S3_MANIFEST_ERROR",
            IngestionErrorType::S3UploadedFileDeleted => "S3_UPLOADED_FILE_DELETED",
            IngestionErrorType::SourceApiLimitExceededFailure => {
                "SOURCE_API_LIMIT_EXCEEDED_FAILURE"
            }
            IngestionErrorType::SourceResourceLimitExceeded => "SOURCE_RESOURCE_LIMIT_EXCEEDED",
            IngestionErrorType::SpiceTableNotFound => "SPICE_TABLE_NOT_FOUND",
            IngestionErrorType::SqlException => "SQL_EXCEPTION",
            IngestionErrorType::SqlInvalidParameterValue => "SQL_INVALID_PARAMETER_VALUE",
            IngestionErrorType::SqlNumericOverflow => "SQL_NUMERIC_OVERFLOW",
            IngestionErrorType::SqlSchemaMismatchError => "SQL_SCHEMA_MISMATCH_ERROR",
            IngestionErrorType::SqlTableNotFound => "SQL_TABLE_NOT_FOUND",
            IngestionErrorType::SslCertificateValidationFailure => {
                "SSL_CERTIFICATE_VALIDATION_FAILURE"
            }
            IngestionErrorType::UnresolvableHost => "UNRESOLVABLE_HOST",
            IngestionErrorType::UnroutableHost => "UNROUTABLE_HOST",
            IngestionErrorType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACCOUNT_CAPACITY_LIMIT_EXCEEDED",
            "CONNECTION_FAILURE",
            "CURSOR_NOT_ENABLED",
            "CUSTOMER_ERROR",
            "DATA_SET_DELETED",
            "DATA_SET_NOT_SPICE",
            "DATA_SET_SIZE_LIMIT_EXCEEDED",
            "DATA_SOURCE_AUTH_FAILED",
            "DATA_SOURCE_CONNECTION_FAILED",
            "DATA_SOURCE_NOT_FOUND",
            "DATA_TOLERANCE_EXCEPTION",
            "ELASTICSEARCH_CURSOR_NOT_ENABLED",
            "FAILURE_TO_ASSUME_ROLE",
            "FAILURE_TO_PROCESS_JSON_FILE",
            "IAM_ROLE_NOT_AVAILABLE",
            "INGESTION_CANCELED",
            "INGESTION_SUPERSEDED",
            "INTERNAL_SERVICE_ERROR",
            "INVALID_DATAPREP_SYNTAX",
            "INVALID_DATA_SOURCE_CONFIG",
            "INVALID_DATE_FORMAT",
            "IOT_DATA_SET_FILE_EMPTY",
            "IOT_FILE_NOT_FOUND",
            "OAUTH_TOKEN_FAILURE",
            "PASSWORD_AUTHENTICATION_FAILURE",
            "PERMISSION_DENIED",
            "PERMISSION_NOT_FOUND",
            "QUERY_TIMEOUT",
            "REFRESH_SUPPRESSED_BY_EDIT",
            "ROW_SIZE_LIMIT_EXCEEDED",
            "S3_FILE_INACCESSIBLE",
            "S3_MANIFEST_ERROR",
            "S3_UPLOADED_FILE_DELETED",
            "SOURCE_API_LIMIT_EXCEEDED_FAILURE",
            "SOURCE_RESOURCE_LIMIT_EXCEEDED",
            "SPICE_TABLE_NOT_FOUND",
            "SQL_EXCEPTION",
            "SQL_INVALID_PARAMETER_VALUE",
            "SQL_NUMERIC_OVERFLOW",
            "SQL_SCHEMA_MISMATCH_ERROR",
            "SQL_TABLE_NOT_FOUND",
            "SSL_CERTIFICATE_VALIDATION_FAILURE",
            "UNRESOLVABLE_HOST",
            "UNROUTABLE_HOST",
        ]
    }
}
impl AsRef<str> for IngestionErrorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `IngestionStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let ingestionstatus = unimplemented!();
/// match ingestionstatus {
///     IngestionStatus::Cancelled => { /* ... */ },
///     IngestionStatus::Completed => { /* ... */ },
///     IngestionStatus::Failed => { /* ... */ },
///     IngestionStatus::Initialized => { /* ... */ },
///     IngestionStatus::Queued => { /* ... */ },
///     IngestionStatus::Running => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ingestionstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `IngestionStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `IngestionStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `IngestionStatus::NewFeature` is defined.
/// Specifically, when `ingestionstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `IngestionStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IngestionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Initialized,
    #[allow(missing_docs)] // documentation missing in model
    Queued,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for IngestionStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => IngestionStatus::Cancelled,
            "COMPLETED" => IngestionStatus::Completed,
            "FAILED" => IngestionStatus::Failed,
            "INITIALIZED" => IngestionStatus::Initialized,
            "QUEUED" => IngestionStatus::Queued,
            "RUNNING" => IngestionStatus::Running,
            other => IngestionStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for IngestionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IngestionStatus::from(s))
    }
}
impl IngestionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            IngestionStatus::Cancelled => "CANCELLED",
            IngestionStatus::Completed => "COMPLETED",
            IngestionStatus::Failed => "FAILED",
            IngestionStatus::Initialized => "INITIALIZED",
            IngestionStatus::Queued => "QUEUED",
            IngestionStatus::Running => "RUNNING",
            IngestionStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELLED",
            "COMPLETED",
            "FAILED",
            "INITIALIZED",
            "QUEUED",
            "RUNNING",
        ]
    }
}
impl AsRef<str> for IngestionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The active Identity and Access Management (IAM) policy assignment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ActiveIamPolicyAssignment {
    /// <p>A name for the IAM policy assignment.</p>
    #[doc(hidden)]
    pub assignment_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub policy_arn: std::option::Option<std::string::String>,
}
impl ActiveIamPolicyAssignment {
    /// <p>A name for the IAM policy assignment.</p>
    pub fn assignment_name(&self) -> std::option::Option<&str> {
        self.assignment_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn policy_arn(&self) -> std::option::Option<&str> {
        self.policy_arn.as_deref()
    }
}
/// See [`ActiveIamPolicyAssignment`](crate::model::ActiveIamPolicyAssignment).
pub mod active_iam_policy_assignment {

    /// A builder for [`ActiveIamPolicyAssignment`](crate::model::ActiveIamPolicyAssignment).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assignment_name: std::option::Option<std::string::String>,
        pub(crate) policy_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A name for the IAM policy assignment.</p>
        pub fn assignment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.assignment_name = Some(input.into());
            self
        }
        /// <p>A name for the IAM policy assignment.</p>
        pub fn set_assignment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assignment_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn policy_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_policy_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ActiveIamPolicyAssignment`](crate::model::ActiveIamPolicyAssignment).
        pub fn build(self) -> crate::model::ActiveIamPolicyAssignment {
            crate::model::ActiveIamPolicyAssignment {
                assignment_name: self.assignment_name,
                policy_arn: self.policy_arn,
            }
        }
    }
}
impl ActiveIamPolicyAssignment {
    /// Creates a new builder-style object to manufacture [`ActiveIamPolicyAssignment`](crate::model::ActiveIamPolicyAssignment).
    pub fn builder() -> crate::model::active_iam_policy_assignment::Builder {
        crate::model::active_iam_policy_assignment::Builder::default()
    }
}

/// <p>IAM policy assignment summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IamPolicyAssignmentSummary {
    /// <p>Assignment name.</p>
    #[doc(hidden)]
    pub assignment_name: std::option::Option<std::string::String>,
    /// <p>Assignment status.</p>
    #[doc(hidden)]
    pub assignment_status: std::option::Option<crate::model::AssignmentStatus>,
}
impl IamPolicyAssignmentSummary {
    /// <p>Assignment name.</p>
    pub fn assignment_name(&self) -> std::option::Option<&str> {
        self.assignment_name.as_deref()
    }
    /// <p>Assignment status.</p>
    pub fn assignment_status(&self) -> std::option::Option<&crate::model::AssignmentStatus> {
        self.assignment_status.as_ref()
    }
}
/// See [`IamPolicyAssignmentSummary`](crate::model::IamPolicyAssignmentSummary).
pub mod iam_policy_assignment_summary {

    /// A builder for [`IamPolicyAssignmentSummary`](crate::model::IamPolicyAssignmentSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assignment_name: std::option::Option<std::string::String>,
        pub(crate) assignment_status: std::option::Option<crate::model::AssignmentStatus>,
    }
    impl Builder {
        /// <p>Assignment name.</p>
        pub fn assignment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.assignment_name = Some(input.into());
            self
        }
        /// <p>Assignment name.</p>
        pub fn set_assignment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assignment_name = input;
            self
        }
        /// <p>Assignment status.</p>
        pub fn assignment_status(mut self, input: crate::model::AssignmentStatus) -> Self {
            self.assignment_status = Some(input);
            self
        }
        /// <p>Assignment status.</p>
        pub fn set_assignment_status(
            mut self,
            input: std::option::Option<crate::model::AssignmentStatus>,
        ) -> Self {
            self.assignment_status = input;
            self
        }
        /// Consumes the builder and constructs a [`IamPolicyAssignmentSummary`](crate::model::IamPolicyAssignmentSummary).
        pub fn build(self) -> crate::model::IamPolicyAssignmentSummary {
            crate::model::IamPolicyAssignmentSummary {
                assignment_name: self.assignment_name,
                assignment_status: self.assignment_status,
            }
        }
    }
}
impl IamPolicyAssignmentSummary {
    /// Creates a new builder-style object to manufacture [`IamPolicyAssignmentSummary`](crate::model::IamPolicyAssignmentSummary).
    pub fn builder() -> crate::model::iam_policy_assignment_summary::Builder {
        crate::model::iam_policy_assignment_summary::Builder::default()
    }
}

/// <p>A member of an Amazon QuickSight group. Currently, group members must be users. Groups can't be members of another group. .</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GroupMember {
    /// <p>The Amazon Resource Name (ARN) for the group member (user).</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the group member (user).</p>
    #[doc(hidden)]
    pub member_name: std::option::Option<std::string::String>,
}
impl GroupMember {
    /// <p>The Amazon Resource Name (ARN) for the group member (user).</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the group member (user).</p>
    pub fn member_name(&self) -> std::option::Option<&str> {
        self.member_name.as_deref()
    }
}
/// See [`GroupMember`](crate::model::GroupMember).
pub mod group_member {

    /// A builder for [`GroupMember`](crate::model::GroupMember).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) member_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) for the group member (user).</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the group member (user).</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the group member (user).</p>
        pub fn member_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_name = Some(input.into());
            self
        }
        /// <p>The name of the group member (user).</p>
        pub fn set_member_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GroupMember`](crate::model::GroupMember).
        pub fn build(self) -> crate::model::GroupMember {
            crate::model::GroupMember {
                arn: self.arn,
                member_name: self.member_name,
            }
        }
    }
}
impl GroupMember {
    /// Creates a new builder-style object to manufacture [`GroupMember`](crate::model::GroupMember).
    pub fn builder() -> crate::model::group_member::Builder {
        crate::model::group_member::Builder::default()
    }
}

/// <p>An object that consists of a member Amazon Resource Name (ARN) and a member ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MemberIdArnPair {
    /// <p>The ID of the member.</p>
    #[doc(hidden)]
    pub member_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the member.</p>
    #[doc(hidden)]
    pub member_arn: std::option::Option<std::string::String>,
}
impl MemberIdArnPair {
    /// <p>The ID of the member.</p>
    pub fn member_id(&self) -> std::option::Option<&str> {
        self.member_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the member.</p>
    pub fn member_arn(&self) -> std::option::Option<&str> {
        self.member_arn.as_deref()
    }
}
/// See [`MemberIdArnPair`](crate::model::MemberIdArnPair).
pub mod member_id_arn_pair {

    /// A builder for [`MemberIdArnPair`](crate::model::MemberIdArnPair).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) member_id: std::option::Option<std::string::String>,
        pub(crate) member_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the member.</p>
        pub fn member_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_id = Some(input.into());
            self
        }
        /// <p>The ID of the member.</p>
        pub fn set_member_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the member.</p>
        pub fn member_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the member.</p>
        pub fn set_member_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`MemberIdArnPair`](crate::model::MemberIdArnPair).
        pub fn build(self) -> crate::model::MemberIdArnPair {
            crate::model::MemberIdArnPair {
                member_id: self.member_id,
                member_arn: self.member_arn,
            }
        }
    }
}
impl MemberIdArnPair {
    /// Creates a new builder-style object to manufacture [`MemberIdArnPair`](crate::model::MemberIdArnPair).
    pub fn builder() -> crate::model::member_id_arn_pair::Builder {
        crate::model::member_id_arn_pair::Builder::default()
    }
}

/// <p>The structure of a data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSource {
    /// <p>The Amazon Resource Name (ARN) of the data source.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.</p>
    #[doc(hidden)]
    pub data_source_id: std::option::Option<std::string::String>,
    /// <p>A display name for the data source.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of the data source. This type indicates which database engine the data source connects to.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::DataSourceType>,
    /// <p>The HTTP status of the request.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ResourceStatus>,
    /// <p>The time that this data source was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time that this data source was updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The parameters that Amazon QuickSight uses to connect to your underlying source. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.</p>
    #[doc(hidden)]
    pub data_source_parameters: std::option::Option<crate::model::DataSourceParameters>,
    /// <p>A set of alternate data source parameters that you want to share for the credentials stored with this data source. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the <code>DataSourceParameters</code> structure that's in the request with the structures in the <code>AlternateDataSourceParameters</code> allow list. If the structures are an exact match, the request is allowed to use the credentials from this existing data source. If the <code>AlternateDataSourceParameters</code> list is null, the <code>Credentials</code> originally used with this <code>DataSourceParameters</code> are automatically allowed.</p>
    #[doc(hidden)]
    pub alternate_data_source_parameters:
        std::option::Option<std::vec::Vec<crate::model::DataSourceParameters>>,
    /// <p>The VPC connection information. You need to use this parameter only when you want Amazon QuickSight to use a VPC connection when connecting to your underlying source.</p>
    #[doc(hidden)]
    pub vpc_connection_properties: std::option::Option<crate::model::VpcConnectionProperties>,
    /// <p>Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying source.</p>
    #[doc(hidden)]
    pub ssl_properties: std::option::Option<crate::model::SslProperties>,
    /// <p>Error information from the last update or the creation of the data source.</p>
    #[doc(hidden)]
    pub error_info: std::option::Option<crate::model::DataSourceErrorInfo>,
    /// <p>The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.</p>
    #[doc(hidden)]
    pub secret_arn: std::option::Option<std::string::String>,
}
impl DataSource {
    /// <p>The Amazon Resource Name (ARN) of the data source.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.</p>
    pub fn data_source_id(&self) -> std::option::Option<&str> {
        self.data_source_id.as_deref()
    }
    /// <p>A display name for the data source.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of the data source. This type indicates which database engine the data source connects to.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::DataSourceType> {
        self.r#type.as_ref()
    }
    /// <p>The HTTP status of the request.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ResourceStatus> {
        self.status.as_ref()
    }
    /// <p>The time that this data source was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The last time that this data source was updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
    /// <p>The parameters that Amazon QuickSight uses to connect to your underlying source. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.</p>
    pub fn data_source_parameters(
        &self,
    ) -> std::option::Option<&crate::model::DataSourceParameters> {
        self.data_source_parameters.as_ref()
    }
    /// <p>A set of alternate data source parameters that you want to share for the credentials stored with this data source. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the <code>DataSourceParameters</code> structure that's in the request with the structures in the <code>AlternateDataSourceParameters</code> allow list. If the structures are an exact match, the request is allowed to use the credentials from this existing data source. If the <code>AlternateDataSourceParameters</code> list is null, the <code>Credentials</code> originally used with this <code>DataSourceParameters</code> are automatically allowed.</p>
    pub fn alternate_data_source_parameters(
        &self,
    ) -> std::option::Option<&[crate::model::DataSourceParameters]> {
        self.alternate_data_source_parameters.as_deref()
    }
    /// <p>The VPC connection information. You need to use this parameter only when you want Amazon QuickSight to use a VPC connection when connecting to your underlying source.</p>
    pub fn vpc_connection_properties(
        &self,
    ) -> std::option::Option<&crate::model::VpcConnectionProperties> {
        self.vpc_connection_properties.as_ref()
    }
    /// <p>Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying source.</p>
    pub fn ssl_properties(&self) -> std::option::Option<&crate::model::SslProperties> {
        self.ssl_properties.as_ref()
    }
    /// <p>Error information from the last update or the creation of the data source.</p>
    pub fn error_info(&self) -> std::option::Option<&crate::model::DataSourceErrorInfo> {
        self.error_info.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.</p>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
}
/// See [`DataSource`](crate::model::DataSource).
pub mod data_source {

    /// A builder for [`DataSource`](crate::model::DataSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) data_source_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::DataSourceType>,
        pub(crate) status: std::option::Option<crate::model::ResourceStatus>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) data_source_parameters: std::option::Option<crate::model::DataSourceParameters>,
        pub(crate) alternate_data_source_parameters:
            std::option::Option<std::vec::Vec<crate::model::DataSourceParameters>>,
        pub(crate) vpc_connection_properties:
            std::option::Option<crate::model::VpcConnectionProperties>,
        pub(crate) ssl_properties: std::option::Option<crate::model::SslProperties>,
        pub(crate) error_info: std::option::Option<crate::model::DataSourceErrorInfo>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the data source.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the data source.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.</p>
        pub fn data_source_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_source_id = Some(input.into());
            self
        }
        /// <p>The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.</p>
        pub fn set_data_source_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_source_id = input;
            self
        }
        /// <p>A display name for the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A display name for the data source.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of the data source. This type indicates which database engine the data source connects to.</p>
        pub fn r#type(mut self, input: crate::model::DataSourceType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the data source. This type indicates which database engine the data source connects to.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DataSourceType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The HTTP status of the request.</p>
        pub fn status(mut self, input: crate::model::ResourceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The HTTP status of the request.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ResourceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The time that this data source was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The time that this data source was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The last time that this data source was updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The last time that this data source was updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>The parameters that Amazon QuickSight uses to connect to your underlying source. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.</p>
        pub fn data_source_parameters(mut self, input: crate::model::DataSourceParameters) -> Self {
            self.data_source_parameters = Some(input);
            self
        }
        /// <p>The parameters that Amazon QuickSight uses to connect to your underlying source. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.</p>
        pub fn set_data_source_parameters(
            mut self,
            input: std::option::Option<crate::model::DataSourceParameters>,
        ) -> Self {
            self.data_source_parameters = input;
            self
        }
        /// Appends an item to `alternate_data_source_parameters`.
        ///
        /// To override the contents of this collection use [`set_alternate_data_source_parameters`](Self::set_alternate_data_source_parameters).
        ///
        /// <p>A set of alternate data source parameters that you want to share for the credentials stored with this data source. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the <code>DataSourceParameters</code> structure that's in the request with the structures in the <code>AlternateDataSourceParameters</code> allow list. If the structures are an exact match, the request is allowed to use the credentials from this existing data source. If the <code>AlternateDataSourceParameters</code> list is null, the <code>Credentials</code> originally used with this <code>DataSourceParameters</code> are automatically allowed.</p>
        pub fn alternate_data_source_parameters(
            mut self,
            input: crate::model::DataSourceParameters,
        ) -> Self {
            let mut v = self.alternate_data_source_parameters.unwrap_or_default();
            v.push(input);
            self.alternate_data_source_parameters = Some(v);
            self
        }
        /// <p>A set of alternate data source parameters that you want to share for the credentials stored with this data source. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the <code>DataSourceParameters</code> structure that's in the request with the structures in the <code>AlternateDataSourceParameters</code> allow list. If the structures are an exact match, the request is allowed to use the credentials from this existing data source. If the <code>AlternateDataSourceParameters</code> list is null, the <code>Credentials</code> originally used with this <code>DataSourceParameters</code> are automatically allowed.</p>
        pub fn set_alternate_data_source_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSourceParameters>>,
        ) -> Self {
            self.alternate_data_source_parameters = input;
            self
        }
        /// <p>The VPC connection information. You need to use this parameter only when you want Amazon QuickSight to use a VPC connection when connecting to your underlying source.</p>
        pub fn vpc_connection_properties(
            mut self,
            input: crate::model::VpcConnectionProperties,
        ) -> Self {
            self.vpc_connection_properties = Some(input);
            self
        }
        /// <p>The VPC connection information. You need to use this parameter only when you want Amazon QuickSight to use a VPC connection when connecting to your underlying source.</p>
        pub fn set_vpc_connection_properties(
            mut self,
            input: std::option::Option<crate::model::VpcConnectionProperties>,
        ) -> Self {
            self.vpc_connection_properties = input;
            self
        }
        /// <p>Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying source.</p>
        pub fn ssl_properties(mut self, input: crate::model::SslProperties) -> Self {
            self.ssl_properties = Some(input);
            self
        }
        /// <p>Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying source.</p>
        pub fn set_ssl_properties(
            mut self,
            input: std::option::Option<crate::model::SslProperties>,
        ) -> Self {
            self.ssl_properties = input;
            self
        }
        /// <p>Error information from the last update or the creation of the data source.</p>
        pub fn error_info(mut self, input: crate::model::DataSourceErrorInfo) -> Self {
            self.error_info = Some(input);
            self
        }
        /// <p>Error information from the last update or the creation of the data source.</p>
        pub fn set_error_info(
            mut self,
            input: std::option::Option<crate::model::DataSourceErrorInfo>,
        ) -> Self {
            self.error_info = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.</p>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.</p>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSource`](crate::model::DataSource).
        pub fn build(self) -> crate::model::DataSource {
            crate::model::DataSource {
                arn: self.arn,
                data_source_id: self.data_source_id,
                name: self.name,
                r#type: self.r#type,
                status: self.status,
                created_time: self.created_time,
                last_updated_time: self.last_updated_time,
                data_source_parameters: self.data_source_parameters,
                alternate_data_source_parameters: self.alternate_data_source_parameters,
                vpc_connection_properties: self.vpc_connection_properties,
                ssl_properties: self.ssl_properties,
                error_info: self.error_info,
                secret_arn: self.secret_arn,
            }
        }
    }
}
impl DataSource {
    /// Creates a new builder-style object to manufacture [`DataSource`](crate::model::DataSource).
    pub fn builder() -> crate::model::data_source::Builder {
        crate::model::data_source::Builder::default()
    }
}

/// <p>Error information for the data source creation or update.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSourceErrorInfo {
    /// <p>Error type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::DataSourceErrorInfoType>,
    /// <p>Error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl DataSourceErrorInfo {
    /// <p>Error type.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::DataSourceErrorInfoType> {
        self.r#type.as_ref()
    }
    /// <p>Error message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`DataSourceErrorInfo`](crate::model::DataSourceErrorInfo).
pub mod data_source_error_info {

    /// A builder for [`DataSourceErrorInfo`](crate::model::DataSourceErrorInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::DataSourceErrorInfoType>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error type.</p>
        pub fn r#type(mut self, input: crate::model::DataSourceErrorInfoType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Error type.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DataSourceErrorInfoType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSourceErrorInfo`](crate::model::DataSourceErrorInfo).
        pub fn build(self) -> crate::model::DataSourceErrorInfo {
            crate::model::DataSourceErrorInfo {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl DataSourceErrorInfo {
    /// Creates a new builder-style object to manufacture [`DataSourceErrorInfo`](crate::model::DataSourceErrorInfo).
    pub fn builder() -> crate::model::data_source_error_info::Builder {
        crate::model::data_source_error_info::Builder::default()
    }
}

/// When writing a match expression against `DataSourceErrorInfoType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datasourceerrorinfotype = unimplemented!();
/// match datasourceerrorinfotype {
///     DataSourceErrorInfoType::AccessDenied => { /* ... */ },
///     DataSourceErrorInfoType::Conflict => { /* ... */ },
///     DataSourceErrorInfoType::CopySourceNotFound => { /* ... */ },
///     DataSourceErrorInfoType::EngineVersionNotSupported => { /* ... */ },
///     DataSourceErrorInfoType::GenericSqlFailure => { /* ... */ },
///     DataSourceErrorInfoType::Timeout => { /* ... */ },
///     DataSourceErrorInfoType::UnknownValue => { /* ... */ },
///     DataSourceErrorInfoType::UnknownHost => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datasourceerrorinfotype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataSourceErrorInfoType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataSourceErrorInfoType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataSourceErrorInfoType::NewFeature` is defined.
/// Specifically, when `datasourceerrorinfotype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataSourceErrorInfoType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// _Note: `DataSourceErrorInfoType::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataSourceErrorInfoType {
    #[allow(missing_docs)] // documentation missing in model
    AccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    Conflict,
    #[allow(missing_docs)] // documentation missing in model
    CopySourceNotFound,
    #[allow(missing_docs)] // documentation missing in model
    EngineVersionNotSupported,
    #[allow(missing_docs)] // documentation missing in model
    GenericSqlFailure,
    #[allow(missing_docs)] // documentation missing in model
    Timeout,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    #[allow(missing_docs)] // documentation missing in model
    UnknownHost,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataSourceErrorInfoType {
    fn from(s: &str) -> Self {
        match s {
            "ACCESS_DENIED" => DataSourceErrorInfoType::AccessDenied,
            "CONFLICT" => DataSourceErrorInfoType::Conflict,
            "COPY_SOURCE_NOT_FOUND" => DataSourceErrorInfoType::CopySourceNotFound,
            "ENGINE_VERSION_NOT_SUPPORTED" => DataSourceErrorInfoType::EngineVersionNotSupported,
            "GENERIC_SQL_FAILURE" => DataSourceErrorInfoType::GenericSqlFailure,
            "TIMEOUT" => DataSourceErrorInfoType::Timeout,
            "UNKNOWN" => DataSourceErrorInfoType::UnknownValue,
            "UNKNOWN_HOST" => DataSourceErrorInfoType::UnknownHost,
            other => DataSourceErrorInfoType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DataSourceErrorInfoType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataSourceErrorInfoType::from(s))
    }
}
impl DataSourceErrorInfoType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataSourceErrorInfoType::AccessDenied => "ACCESS_DENIED",
            DataSourceErrorInfoType::Conflict => "CONFLICT",
            DataSourceErrorInfoType::CopySourceNotFound => "COPY_SOURCE_NOT_FOUND",
            DataSourceErrorInfoType::EngineVersionNotSupported => "ENGINE_VERSION_NOT_SUPPORTED",
            DataSourceErrorInfoType::GenericSqlFailure => "GENERIC_SQL_FAILURE",
            DataSourceErrorInfoType::Timeout => "TIMEOUT",
            DataSourceErrorInfoType::UnknownValue => "UNKNOWN",
            DataSourceErrorInfoType::UnknownHost => "UNKNOWN_HOST",
            DataSourceErrorInfoType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACCESS_DENIED",
            "CONFLICT",
            "COPY_SOURCE_NOT_FOUND",
            "ENGINE_VERSION_NOT_SUPPORTED",
            "GENERIC_SQL_FAILURE",
            "TIMEOUT",
            "UNKNOWN",
            "UNKNOWN_HOST",
        ]
    }
}
impl AsRef<str> for DataSourceErrorInfoType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Dashboard version summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DashboardVersionSummary {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The time that this dashboard version was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Version number.</p>
    #[doc(hidden)]
    pub version_number: std::option::Option<i64>,
    /// <p>The HTTP status of the request.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ResourceStatus>,
    /// <p>Source entity ARN.</p>
    #[doc(hidden)]
    pub source_entity_arn: std::option::Option<std::string::String>,
    /// <p>Description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl DashboardVersionSummary {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The time that this dashboard version was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>Version number.</p>
    pub fn version_number(&self) -> std::option::Option<i64> {
        self.version_number
    }
    /// <p>The HTTP status of the request.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ResourceStatus> {
        self.status.as_ref()
    }
    /// <p>Source entity ARN.</p>
    pub fn source_entity_arn(&self) -> std::option::Option<&str> {
        self.source_entity_arn.as_deref()
    }
    /// <p>Description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
/// See [`DashboardVersionSummary`](crate::model::DashboardVersionSummary).
pub mod dashboard_version_summary {

    /// A builder for [`DashboardVersionSummary`](crate::model::DashboardVersionSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) version_number: std::option::Option<i64>,
        pub(crate) status: std::option::Option<crate::model::ResourceStatus>,
        pub(crate) source_entity_arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The time that this dashboard version was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The time that this dashboard version was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>Version number.</p>
        pub fn version_number(mut self, input: i64) -> Self {
            self.version_number = Some(input);
            self
        }
        /// <p>Version number.</p>
        pub fn set_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.version_number = input;
            self
        }
        /// <p>The HTTP status of the request.</p>
        pub fn status(mut self, input: crate::model::ResourceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The HTTP status of the request.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ResourceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Source entity ARN.</p>
        pub fn source_entity_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_entity_arn = Some(input.into());
            self
        }
        /// <p>Source entity ARN.</p>
        pub fn set_source_entity_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_entity_arn = input;
            self
        }
        /// <p>Description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`DashboardVersionSummary`](crate::model::DashboardVersionSummary).
        pub fn build(self) -> crate::model::DashboardVersionSummary {
            crate::model::DashboardVersionSummary {
                arn: self.arn,
                created_time: self.created_time,
                version_number: self.version_number,
                status: self.status,
                source_entity_arn: self.source_entity_arn,
                description: self.description,
            }
        }
    }
}
impl DashboardVersionSummary {
    /// Creates a new builder-style object to manufacture [`DashboardVersionSummary`](crate::model::DashboardVersionSummary).
    pub fn builder() -> crate::model::dashboard_version_summary::Builder {
        crate::model::dashboard_version_summary::Builder::default()
    }
}

/// When writing a match expression against `EmbeddingIdentityType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let embeddingidentitytype = unimplemented!();
/// match embeddingidentitytype {
///     EmbeddingIdentityType::Anonymous => { /* ... */ },
///     EmbeddingIdentityType::Iam => { /* ... */ },
///     EmbeddingIdentityType::Quicksight => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `embeddingidentitytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EmbeddingIdentityType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EmbeddingIdentityType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EmbeddingIdentityType::NewFeature` is defined.
/// Specifically, when `embeddingidentitytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EmbeddingIdentityType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EmbeddingIdentityType {
    #[allow(missing_docs)] // documentation missing in model
    Anonymous,
    #[allow(missing_docs)] // documentation missing in model
    Iam,
    #[allow(missing_docs)] // documentation missing in model
    Quicksight,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EmbeddingIdentityType {
    fn from(s: &str) -> Self {
        match s {
            "ANONYMOUS" => EmbeddingIdentityType::Anonymous,
            "IAM" => EmbeddingIdentityType::Iam,
            "QUICKSIGHT" => EmbeddingIdentityType::Quicksight,
            other => {
                EmbeddingIdentityType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for EmbeddingIdentityType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EmbeddingIdentityType::from(s))
    }
}
impl EmbeddingIdentityType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EmbeddingIdentityType::Anonymous => "ANONYMOUS",
            EmbeddingIdentityType::Iam => "IAM",
            EmbeddingIdentityType::Quicksight => "QUICKSIGHT",
            EmbeddingIdentityType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ANONYMOUS", "IAM", "QUICKSIGHT"]
    }
}
impl AsRef<str> for EmbeddingIdentityType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The type of experience you want to embed. For registered users, you can embed Amazon QuickSight dashboards or the Amazon QuickSight console.</p> <note>
/// <p>Exactly one of the experience configurations is required. You can choose <code>Dashboard</code> or <code>QuickSightConsole</code>. You cannot choose more than one experience configuration.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegisteredUserEmbeddingExperienceConfiguration {
    /// <p>The configuration details for providing a dashboard embedding experience.</p>
    #[doc(hidden)]
    pub dashboard: std::option::Option<crate::model::RegisteredUserDashboardEmbeddingConfiguration>,
    /// <p>The configuration details for providing each Amazon QuickSight console embedding experience. This can be used along with custom permissions to restrict access to certain features. For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/customizing-permissions-to-the-quicksight-console.html">Customizing Access to the Amazon QuickSight Console</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    /// <p>Use <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_GenerateEmbedUrlForRegisteredUser.html">GenerateEmbedUrlForRegisteredUser</a> </code> where you want to provide an authoring portal that allows users to create data sources, datasets, analyses, and dashboards. The users who accesses an embedded Amazon QuickSight console needs to belong to the author or admin security cohort. If you want to restrict permissions to some of these features, add a custom permissions profile to the user with the <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdateUser.html">UpdateUser</a> </code> API operation. Use the <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_RegisterUser.html">RegisterUser</a> </code> API operation to add a new user with a custom permission profile attached. For more information, see the following sections in the <i>Amazon QuickSight User Guide</i>:</p>
    /// <ul>
    /// <li> <p> <a href="https://docs.aws.amazon.com/quicksight/latest/user/embedded-analytics-full-console-for-authenticated-users.html">Embedding the Full Functionality of the Amazon QuickSight Console for Authenticated Users</a> </p> </li>
    /// <li> <p> <a href="https://docs.aws.amazon.com/quicksight/latest/user/customizing-permissions-to-the-quicksight-console.html">Customizing Access to the Amazon QuickSight Console</a> </p> </li>
    /// </ul>
    /// <p>For more information about the high-level steps for embedding and for an interactive demo of the ways you can customize embedding, visit the <a href="https://docs.aws.amazon.com/quicksight/latest/user/quicksight-dev-portal.html">Amazon QuickSight Developer Portal</a>.</p>
    #[doc(hidden)]
    pub quick_sight_console:
        std::option::Option<crate::model::RegisteredUserQuickSightConsoleEmbeddingConfiguration>,
    /// <p>The configuration details for embedding the Q search bar.</p>
    /// <p>For more information about embedding the Q search bar, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/embedding-overview.html">Embedding Overview</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    #[doc(hidden)]
    pub q_search_bar:
        std::option::Option<crate::model::RegisteredUserQSearchBarEmbeddingConfiguration>,
    /// <p>The type of embedding experience. In this case, Amazon QuickSight visuals.</p>
    #[doc(hidden)]
    pub dashboard_visual:
        std::option::Option<crate::model::RegisteredUserDashboardVisualEmbeddingConfiguration>,
}
impl RegisteredUserEmbeddingExperienceConfiguration {
    /// <p>The configuration details for providing a dashboard embedding experience.</p>
    pub fn dashboard(
        &self,
    ) -> std::option::Option<&crate::model::RegisteredUserDashboardEmbeddingConfiguration> {
        self.dashboard.as_ref()
    }
    /// <p>The configuration details for providing each Amazon QuickSight console embedding experience. This can be used along with custom permissions to restrict access to certain features. For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/customizing-permissions-to-the-quicksight-console.html">Customizing Access to the Amazon QuickSight Console</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    /// <p>Use <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_GenerateEmbedUrlForRegisteredUser.html">GenerateEmbedUrlForRegisteredUser</a> </code> where you want to provide an authoring portal that allows users to create data sources, datasets, analyses, and dashboards. The users who accesses an embedded Amazon QuickSight console needs to belong to the author or admin security cohort. If you want to restrict permissions to some of these features, add a custom permissions profile to the user with the <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdateUser.html">UpdateUser</a> </code> API operation. Use the <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_RegisterUser.html">RegisterUser</a> </code> API operation to add a new user with a custom permission profile attached. For more information, see the following sections in the <i>Amazon QuickSight User Guide</i>:</p>
    /// <ul>
    /// <li> <p> <a href="https://docs.aws.amazon.com/quicksight/latest/user/embedded-analytics-full-console-for-authenticated-users.html">Embedding the Full Functionality of the Amazon QuickSight Console for Authenticated Users</a> </p> </li>
    /// <li> <p> <a href="https://docs.aws.amazon.com/quicksight/latest/user/customizing-permissions-to-the-quicksight-console.html">Customizing Access to the Amazon QuickSight Console</a> </p> </li>
    /// </ul>
    /// <p>For more information about the high-level steps for embedding and for an interactive demo of the ways you can customize embedding, visit the <a href="https://docs.aws.amazon.com/quicksight/latest/user/quicksight-dev-portal.html">Amazon QuickSight Developer Portal</a>.</p>
    pub fn quick_sight_console(
        &self,
    ) -> std::option::Option<&crate::model::RegisteredUserQuickSightConsoleEmbeddingConfiguration>
    {
        self.quick_sight_console.as_ref()
    }
    /// <p>The configuration details for embedding the Q search bar.</p>
    /// <p>For more information about embedding the Q search bar, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/embedding-overview.html">Embedding Overview</a> in the <i>Amazon QuickSight User Guide</i>.</p>
    pub fn q_search_bar(
        &self,
    ) -> std::option::Option<&crate::model::RegisteredUserQSearchBarEmbeddingConfiguration> {
        self.q_search_bar.as_ref()
    }
    /// <p>The type of embedding experience. In this case, Amazon QuickSight visuals.</p>
    pub fn dashboard_visual(
        &self,
    ) -> std::option::Option<&crate::model::RegisteredUserDashboardVisualEmbeddingConfiguration>
    {
        self.dashboard_visual.as_ref()
    }
}
/// See [`RegisteredUserEmbeddingExperienceConfiguration`](crate::model::RegisteredUserEmbeddingExperienceConfiguration).
pub mod registered_user_embedding_experience_configuration {

    /// A builder for [`RegisteredUserEmbeddingExperienceConfiguration`](crate::model::RegisteredUserEmbeddingExperienceConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dashboard:
            std::option::Option<crate::model::RegisteredUserDashboardEmbeddingConfiguration>,
        pub(crate) quick_sight_console: std::option::Option<
            crate::model::RegisteredUserQuickSightConsoleEmbeddingConfiguration,
        >,
        pub(crate) q_search_bar:
            std::option::Option<crate::model::RegisteredUserQSearchBarEmbeddingConfiguration>,
        pub(crate) dashboard_visual:
            std::option::Option<crate::model::RegisteredUserDashboardVisualEmbeddingConfiguration>,
    }
    impl Builder {
        /// <p>The configuration details for providing a dashboard embedding experience.</p>
        pub fn dashboard(
            mut self,
            input: crate::model::RegisteredUserDashboardEmbeddingConfiguration,
        ) -> Self {
            self.dashboard = Some(input);
            self
        }
        /// <p>The configuration details for providing a dashboard embedding experience.</p>
        pub fn set_dashboard(
            mut self,
            input: std::option::Option<crate::model::RegisteredUserDashboardEmbeddingConfiguration>,
        ) -> Self {
            self.dashboard = input;
            self
        }
        /// <p>The configuration details for providing each Amazon QuickSight console embedding experience. This can be used along with custom permissions to restrict access to certain features. For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/customizing-permissions-to-the-quicksight-console.html">Customizing Access to the Amazon QuickSight Console</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        /// <p>Use <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_GenerateEmbedUrlForRegisteredUser.html">GenerateEmbedUrlForRegisteredUser</a> </code> where you want to provide an authoring portal that allows users to create data sources, datasets, analyses, and dashboards. The users who accesses an embedded Amazon QuickSight console needs to belong to the author or admin security cohort. If you want to restrict permissions to some of these features, add a custom permissions profile to the user with the <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdateUser.html">UpdateUser</a> </code> API operation. Use the <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_RegisterUser.html">RegisterUser</a> </code> API operation to add a new user with a custom permission profile attached. For more information, see the following sections in the <i>Amazon QuickSight User Guide</i>:</p>
        /// <ul>
        /// <li> <p> <a href="https://docs.aws.amazon.com/quicksight/latest/user/embedded-analytics-full-console-for-authenticated-users.html">Embedding the Full Functionality of the Amazon QuickSight Console for Authenticated Users</a> </p> </li>
        /// <li> <p> <a href="https://docs.aws.amazon.com/quicksight/latest/user/customizing-permissions-to-the-quicksight-console.html">Customizing Access to the Amazon QuickSight Console</a> </p> </li>
        /// </ul>
        /// <p>For more information about the high-level steps for embedding and for an interactive demo of the ways you can customize embedding, visit the <a href="https://docs.aws.amazon.com/quicksight/latest/user/quicksight-dev-portal.html">Amazon QuickSight Developer Portal</a>.</p>
        pub fn quick_sight_console(
            mut self,
            input: crate::model::RegisteredUserQuickSightConsoleEmbeddingConfiguration,
        ) -> Self {
            self.quick_sight_console = Some(input);
            self
        }
        /// <p>The configuration details for providing each Amazon QuickSight console embedding experience. This can be used along with custom permissions to restrict access to certain features. For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/customizing-permissions-to-the-quicksight-console.html">Customizing Access to the Amazon QuickSight Console</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        /// <p>Use <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_GenerateEmbedUrlForRegisteredUser.html">GenerateEmbedUrlForRegisteredUser</a> </code> where you want to provide an authoring portal that allows users to create data sources, datasets, analyses, and dashboards. The users who accesses an embedded Amazon QuickSight console needs to belong to the author or admin security cohort. If you want to restrict permissions to some of these features, add a custom permissions profile to the user with the <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdateUser.html">UpdateUser</a> </code> API operation. Use the <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_RegisterUser.html">RegisterUser</a> </code> API operation to add a new user with a custom permission profile attached. For more information, see the following sections in the <i>Amazon QuickSight User Guide</i>:</p>
        /// <ul>
        /// <li> <p> <a href="https://docs.aws.amazon.com/quicksight/latest/user/embedded-analytics-full-console-for-authenticated-users.html">Embedding the Full Functionality of the Amazon QuickSight Console for Authenticated Users</a> </p> </li>
        /// <li> <p> <a href="https://docs.aws.amazon.com/quicksight/latest/user/customizing-permissions-to-the-quicksight-console.html">Customizing Access to the Amazon QuickSight Console</a> </p> </li>
        /// </ul>
        /// <p>For more information about the high-level steps for embedding and for an interactive demo of the ways you can customize embedding, visit the <a href="https://docs.aws.amazon.com/quicksight/latest/user/quicksight-dev-portal.html">Amazon QuickSight Developer Portal</a>.</p>
        pub fn set_quick_sight_console(
            mut self,
            input: std::option::Option<
                crate::model::RegisteredUserQuickSightConsoleEmbeddingConfiguration,
            >,
        ) -> Self {
            self.quick_sight_console = input;
            self
        }
        /// <p>The configuration details for embedding the Q search bar.</p>
        /// <p>For more information about embedding the Q search bar, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/embedding-overview.html">Embedding Overview</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn q_search_bar(
            mut self,
            input: crate::model::RegisteredUserQSearchBarEmbeddingConfiguration,
        ) -> Self {
            self.q_search_bar = Some(input);
            self
        }
        /// <p>The configuration details for embedding the Q search bar.</p>
        /// <p>For more information about embedding the Q search bar, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/embedding-overview.html">Embedding Overview</a> in the <i>Amazon QuickSight User Guide</i>.</p>
        pub fn set_q_search_bar(
            mut self,
            input: std::option::Option<
                crate::model::RegisteredUserQSearchBarEmbeddingConfiguration,
            >,
        ) -> Self {
            self.q_search_bar = input;
            self
        }
        /// <p>The type of embedding experience. In this case, Amazon QuickSight visuals.</p>
        pub fn dashboard_visual(
            mut self,
            input: crate::model::RegisteredUserDashboardVisualEmbeddingConfiguration,
        ) -> Self {
            self.dashboard_visual = Some(input);
            self
        }
        /// <p>The type of embedding experience. In this case, Amazon QuickSight visuals.</p>
        pub fn set_dashboard_visual(
            mut self,
            input: std::option::Option<
                crate::model::RegisteredUserDashboardVisualEmbeddingConfiguration,
            >,
        ) -> Self {
            self.dashboard_visual = input;
            self
        }
        /// Consumes the builder and constructs a [`RegisteredUserEmbeddingExperienceConfiguration`](crate::model::RegisteredUserEmbeddingExperienceConfiguration).
        pub fn build(self) -> crate::model::RegisteredUserEmbeddingExperienceConfiguration {
            crate::model::RegisteredUserEmbeddingExperienceConfiguration {
                dashboard: self.dashboard,
                quick_sight_console: self.quick_sight_console,
                q_search_bar: self.q_search_bar,
                dashboard_visual: self.dashboard_visual,
            }
        }
    }
}
impl RegisteredUserEmbeddingExperienceConfiguration {
    /// Creates a new builder-style object to manufacture [`RegisteredUserEmbeddingExperienceConfiguration`](crate::model::RegisteredUserEmbeddingExperienceConfiguration).
    pub fn builder() -> crate::model::registered_user_embedding_experience_configuration::Builder {
        crate::model::registered_user_embedding_experience_configuration::Builder::default()
    }
}

/// <p>The experience that you are embedding. You can use this object to generate a url that embeds a visual into your application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegisteredUserDashboardVisualEmbeddingConfiguration {
    /// <p>The visual ID for the visual that you want the user to embed. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this visual.</p>
    /// <p>The Amazon Resource Name (ARN) of the dashboard that the visual belongs to must be included in the <code>AuthorizedResourceArns</code> parameter. Otherwise, the request will fail with <code>InvalidParameterValueException</code>.</p>
    #[doc(hidden)]
    pub initial_dashboard_visual_id: std::option::Option<crate::model::DashboardVisualId>,
}
impl RegisteredUserDashboardVisualEmbeddingConfiguration {
    /// <p>The visual ID for the visual that you want the user to embed. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this visual.</p>
    /// <p>The Amazon Resource Name (ARN) of the dashboard that the visual belongs to must be included in the <code>AuthorizedResourceArns</code> parameter. Otherwise, the request will fail with <code>InvalidParameterValueException</code>.</p>
    pub fn initial_dashboard_visual_id(
        &self,
    ) -> std::option::Option<&crate::model::DashboardVisualId> {
        self.initial_dashboard_visual_id.as_ref()
    }
}
/// See [`RegisteredUserDashboardVisualEmbeddingConfiguration`](crate::model::RegisteredUserDashboardVisualEmbeddingConfiguration).
pub mod registered_user_dashboard_visual_embedding_configuration {

    /// A builder for [`RegisteredUserDashboardVisualEmbeddingConfiguration`](crate::model::RegisteredUserDashboardVisualEmbeddingConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) initial_dashboard_visual_id:
            std::option::Option<crate::model::DashboardVisualId>,
    }
    impl Builder {
        /// <p>The visual ID for the visual that you want the user to embed. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this visual.</p>
        /// <p>The Amazon Resource Name (ARN) of the dashboard that the visual belongs to must be included in the <code>AuthorizedResourceArns</code> parameter. Otherwise, the request will fail with <code>InvalidParameterValueException</code>.</p>
        pub fn initial_dashboard_visual_id(
            mut self,
            input: crate::model::DashboardVisualId,
        ) -> Self {
            self.initial_dashboard_visual_id = Some(input);
            self
        }
        /// <p>The visual ID for the visual that you want the user to embed. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this visual.</p>
        /// <p>The Amazon Resource Name (ARN) of the dashboard that the visual belongs to must be included in the <code>AuthorizedResourceArns</code> parameter. Otherwise, the request will fail with <code>InvalidParameterValueException</code>.</p>
        pub fn set_initial_dashboard_visual_id(
            mut self,
            input: std::option::Option<crate::model::DashboardVisualId>,
        ) -> Self {
            self.initial_dashboard_visual_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RegisteredUserDashboardVisualEmbeddingConfiguration`](crate::model::RegisteredUserDashboardVisualEmbeddingConfiguration).
        pub fn build(self) -> crate::model::RegisteredUserDashboardVisualEmbeddingConfiguration {
            crate::model::RegisteredUserDashboardVisualEmbeddingConfiguration {
                initial_dashboard_visual_id: self.initial_dashboard_visual_id,
            }
        }
    }
}
impl RegisteredUserDashboardVisualEmbeddingConfiguration {
    /// Creates a new builder-style object to manufacture [`RegisteredUserDashboardVisualEmbeddingConfiguration`](crate::model::RegisteredUserDashboardVisualEmbeddingConfiguration).
    pub fn builder(
    ) -> crate::model::registered_user_dashboard_visual_embedding_configuration::Builder {
        crate::model::registered_user_dashboard_visual_embedding_configuration::Builder::default()
    }
}

/// <p>A structure that contains the following elements:</p>
/// <ul>
/// <li> <p>The <code>DashboardId</code> of the dashboard that has the visual that you want to embed.</p> </li>
/// <li> <p>The <code>SheetId</code> of the sheet that has the visual that you want to embed.</p> </li>
/// <li> <p>The <code>VisualId</code> of the visual that you want to embed.</p> </li>
/// </ul>
/// <p>The <code>DashboardId</code>, <code>SheetId</code>, and <code>VisualId</code> can be found in the <code>IDs for developers</code> section of the <code>Embed visual</code> pane of the visual's on-visual menu of the Amazon QuickSight console. You can also get the <code>DashboardId</code> with a <code>ListDashboards</code> API operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DashboardVisualId {
    /// <p>The ID of the dashboard that has the visual that you want to embed. The <code>DashboardId</code> can be found in the <code>IDs for developers</code> section of the <code>Embed visual</code> pane of the visual's on-visual menu of the Amazon QuickSight console. You can also get the <code>DashboardId</code> with a <code>ListDashboards</code> API operation.</p>
    #[doc(hidden)]
    pub dashboard_id: std::option::Option<std::string::String>,
    /// <p>The ID of the sheet that the has visual that you want to embed. The <code>SheetId</code> can be found in the <code>IDs for developers</code> section of the <code>Embed visual</code> pane of the visual's on-visual menu of the Amazon QuickSight console.</p>
    #[doc(hidden)]
    pub sheet_id: std::option::Option<std::string::String>,
    /// <p>The ID of the visual that you want to embed. The <code>VisualID</code> can be found in the <code>IDs for developers</code> section of the <code>Embed visual</code> pane of the visual's on-visual menu of the Amazon QuickSight console.</p>
    #[doc(hidden)]
    pub visual_id: std::option::Option<std::string::String>,
}
impl DashboardVisualId {
    /// <p>The ID of the dashboard that has the visual that you want to embed. The <code>DashboardId</code> can be found in the <code>IDs for developers</code> section of the <code>Embed visual</code> pane of the visual's on-visual menu of the Amazon QuickSight console. You can also get the <code>DashboardId</code> with a <code>ListDashboards</code> API operation.</p>
    pub fn dashboard_id(&self) -> std::option::Option<&str> {
        self.dashboard_id.as_deref()
    }
    /// <p>The ID of the sheet that the has visual that you want to embed. The <code>SheetId</code> can be found in the <code>IDs for developers</code> section of the <code>Embed visual</code> pane of the visual's on-visual menu of the Amazon QuickSight console.</p>
    pub fn sheet_id(&self) -> std::option::Option<&str> {
        self.sheet_id.as_deref()
    }
    /// <p>The ID of the visual that you want to embed. The <code>VisualID</code> can be found in the <code>IDs for developers</code> section of the <code>Embed visual</code> pane of the visual's on-visual menu of the Amazon QuickSight console.</p>
    pub fn visual_id(&self) -> std::option::Option<&str> {
        self.visual_id.as_deref()
    }
}
/// See [`DashboardVisualId`](crate::model::DashboardVisualId).
pub mod dashboard_visual_id {

    /// A builder for [`DashboardVisualId`](crate::model::DashboardVisualId).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dashboard_id: std::option::Option<std::string::String>,
        pub(crate) sheet_id: std::option::Option<std::string::String>,
        pub(crate) visual_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the dashboard that has the visual that you want to embed. The <code>DashboardId</code> can be found in the <code>IDs for developers</code> section of the <code>Embed visual</code> pane of the visual's on-visual menu of the Amazon QuickSight console. You can also get the <code>DashboardId</code> with a <code>ListDashboards</code> API operation.</p>
        pub fn dashboard_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.dashboard_id = Some(input.into());
            self
        }
        /// <p>The ID of the dashboard that has the visual that you want to embed. The <code>DashboardId</code> can be found in the <code>IDs for developers</code> section of the <code>Embed visual</code> pane of the visual's on-visual menu of the Amazon QuickSight console. You can also get the <code>DashboardId</code> with a <code>ListDashboards</code> API operation.</p>
        pub fn set_dashboard_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dashboard_id = input;
            self
        }
        /// <p>The ID of the sheet that the has visual that you want to embed. The <code>SheetId</code> can be found in the <code>IDs for developers</code> section of the <code>Embed visual</code> pane of the visual's on-visual menu of the Amazon QuickSight console.</p>
        pub fn sheet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sheet_id = Some(input.into());
            self
        }
        /// <p>The ID of the sheet that the has visual that you want to embed. The <code>SheetId</code> can be found in the <code>IDs for developers</code> section of the <code>Embed visual</code> pane of the visual's on-visual menu of the Amazon QuickSight console.</p>
        pub fn set_sheet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sheet_id = input;
            self
        }
        /// <p>The ID of the visual that you want to embed. The <code>VisualID</code> can be found in the <code>IDs for developers</code> section of the <code>Embed visual</code> pane of the visual's on-visual menu of the Amazon QuickSight console.</p>
        pub fn visual_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.visual_id = Some(input.into());
            self
        }
        /// <p>The ID of the visual that you want to embed. The <code>VisualID</code> can be found in the <code>IDs for developers</code> section of the <code>Embed visual</code> pane of the visual's on-visual menu of the Amazon QuickSight console.</p>
        pub fn set_visual_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.visual_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DashboardVisualId`](crate::model::DashboardVisualId).
        pub fn build(self) -> crate::model::DashboardVisualId {
            crate::model::DashboardVisualId {
                dashboard_id: self.dashboard_id,
                sheet_id: self.sheet_id,
                visual_id: self.visual_id,
            }
        }
    }
}
impl DashboardVisualId {
    /// Creates a new builder-style object to manufacture [`DashboardVisualId`](crate::model::DashboardVisualId).
    pub fn builder() -> crate::model::dashboard_visual_id::Builder {
        crate::model::dashboard_visual_id::Builder::default()
    }
}

/// <p>Information about the Q search bar embedding experience.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegisteredUserQSearchBarEmbeddingConfiguration {
    /// <p>The ID of the Q topic that you want to make the starting topic in the Q search bar. You can find a topic ID by navigating to the Topics pane in the Amazon QuickSight application and opening a topic. The ID is in the URL for the topic that you open.</p>
    /// <p>If you don't specify an initial topic, a list of all shared topics is shown in the Q bar for your readers. When you select an initial topic, you can specify whether or not readers are allowed to select other topics from the available ones in the list.</p>
    #[doc(hidden)]
    pub initial_topic_id: std::option::Option<std::string::String>,
}
impl RegisteredUserQSearchBarEmbeddingConfiguration {
    /// <p>The ID of the Q topic that you want to make the starting topic in the Q search bar. You can find a topic ID by navigating to the Topics pane in the Amazon QuickSight application and opening a topic. The ID is in the URL for the topic that you open.</p>
    /// <p>If you don't specify an initial topic, a list of all shared topics is shown in the Q bar for your readers. When you select an initial topic, you can specify whether or not readers are allowed to select other topics from the available ones in the list.</p>
    pub fn initial_topic_id(&self) -> std::option::Option<&str> {
        self.initial_topic_id.as_deref()
    }
}
/// See [`RegisteredUserQSearchBarEmbeddingConfiguration`](crate::model::RegisteredUserQSearchBarEmbeddingConfiguration).
pub mod registered_user_q_search_bar_embedding_configuration {

    /// A builder for [`RegisteredUserQSearchBarEmbeddingConfiguration`](crate::model::RegisteredUserQSearchBarEmbeddingConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) initial_topic_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Q topic that you want to make the starting topic in the Q search bar. You can find a topic ID by navigating to the Topics pane in the Amazon QuickSight application and opening a topic. The ID is in the URL for the topic that you open.</p>
        /// <p>If you don't specify an initial topic, a list of all shared topics is shown in the Q bar for your readers. When you select an initial topic, you can specify whether or not readers are allowed to select other topics from the available ones in the list.</p>
        pub fn initial_topic_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.initial_topic_id = Some(input.into());
            self
        }
        /// <p>The ID of the Q topic that you want to make the starting topic in the Q search bar. You can find a topic ID by navigating to the Topics pane in the Amazon QuickSight application and opening a topic. The ID is in the URL for the topic that you open.</p>
        /// <p>If you don't specify an initial topic, a list of all shared topics is shown in the Q bar for your readers. When you select an initial topic, you can specify whether or not readers are allowed to select other topics from the available ones in the list.</p>
        pub fn set_initial_topic_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.initial_topic_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RegisteredUserQSearchBarEmbeddingConfiguration`](crate::model::RegisteredUserQSearchBarEmbeddingConfiguration).
        pub fn build(self) -> crate::model::RegisteredUserQSearchBarEmbeddingConfiguration {
            crate::model::RegisteredUserQSearchBarEmbeddingConfiguration {
                initial_topic_id: self.initial_topic_id,
            }
        }
    }
}
impl RegisteredUserQSearchBarEmbeddingConfiguration {
    /// Creates a new builder-style object to manufacture [`RegisteredUserQSearchBarEmbeddingConfiguration`](crate::model::RegisteredUserQSearchBarEmbeddingConfiguration).
    pub fn builder() -> crate::model::registered_user_q_search_bar_embedding_configuration::Builder
    {
        crate::model::registered_user_q_search_bar_embedding_configuration::Builder::default()
    }
}

/// <p>Information about the Amazon QuickSight console that you want to embed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegisteredUserQuickSightConsoleEmbeddingConfiguration {
    /// <p>The initial URL path for the Amazon QuickSight console. <code>InitialPath</code> is required.</p>
    /// <p>The entry point URL is constrained to the following paths:</p>
    /// <ul>
    /// <li> <p> <code>/start</code> </p> </li>
    /// <li> <p> <code>/start/analyses</code> </p> </li>
    /// <li> <p> <code>/start/dashboards</code> </p> </li>
    /// <li> <p> <code>/start/favorites</code> </p> </li>
    /// <li> <p> <code>/dashboards/DashboardId</code>. <i>DashboardId</i> is the actual ID key from the Amazon QuickSight console URL of the dashboard.</p> </li>
    /// <li> <p> <code>/analyses/AnalysisId</code>. <i>AnalysisId</i> is the actual ID key from the Amazon QuickSight console URL of the analysis.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub initial_path: std::option::Option<std::string::String>,
}
impl RegisteredUserQuickSightConsoleEmbeddingConfiguration {
    /// <p>The initial URL path for the Amazon QuickSight console. <code>InitialPath</code> is required.</p>
    /// <p>The entry point URL is constrained to the following paths:</p>
    /// <ul>
    /// <li> <p> <code>/start</code> </p> </li>
    /// <li> <p> <code>/start/analyses</code> </p> </li>
    /// <li> <p> <code>/start/dashboards</code> </p> </li>
    /// <li> <p> <code>/start/favorites</code> </p> </li>
    /// <li> <p> <code>/dashboards/DashboardId</code>. <i>DashboardId</i> is the actual ID key from the Amazon QuickSight console URL of the dashboard.</p> </li>
    /// <li> <p> <code>/analyses/AnalysisId</code>. <i>AnalysisId</i> is the actual ID key from the Amazon QuickSight console URL of the analysis.</p> </li>
    /// </ul>
    pub fn initial_path(&self) -> std::option::Option<&str> {
        self.initial_path.as_deref()
    }
}
/// See [`RegisteredUserQuickSightConsoleEmbeddingConfiguration`](crate::model::RegisteredUserQuickSightConsoleEmbeddingConfiguration).
pub mod registered_user_quick_sight_console_embedding_configuration {

    /// A builder for [`RegisteredUserQuickSightConsoleEmbeddingConfiguration`](crate::model::RegisteredUserQuickSightConsoleEmbeddingConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) initial_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The initial URL path for the Amazon QuickSight console. <code>InitialPath</code> is required.</p>
        /// <p>The entry point URL is constrained to the following paths:</p>
        /// <ul>
        /// <li> <p> <code>/start</code> </p> </li>
        /// <li> <p> <code>/start/analyses</code> </p> </li>
        /// <li> <p> <code>/start/dashboards</code> </p> </li>
        /// <li> <p> <code>/start/favorites</code> </p> </li>
        /// <li> <p> <code>/dashboards/DashboardId</code>. <i>DashboardId</i> is the actual ID key from the Amazon QuickSight console URL of the dashboard.</p> </li>
        /// <li> <p> <code>/analyses/AnalysisId</code>. <i>AnalysisId</i> is the actual ID key from the Amazon QuickSight console URL of the analysis.</p> </li>
        /// </ul>
        pub fn initial_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.initial_path = Some(input.into());
            self
        }
        /// <p>The initial URL path for the Amazon QuickSight console. <code>InitialPath</code> is required.</p>
        /// <p>The entry point URL is constrained to the following paths:</p>
        /// <ul>
        /// <li> <p> <code>/start</code> </p> </li>
        /// <li> <p> <code>/start/analyses</code> </p> </li>
        /// <li> <p> <code>/start/dashboards</code> </p> </li>
        /// <li> <p> <code>/start/favorites</code> </p> </li>
        /// <li> <p> <code>/dashboards/DashboardId</code>. <i>DashboardId</i> is the actual ID key from the Amazon QuickSight console URL of the dashboard.</p> </li>
        /// <li> <p> <code>/analyses/AnalysisId</code>. <i>AnalysisId</i> is the actual ID key from the Amazon QuickSight console URL of the analysis.</p> </li>
        /// </ul>
        pub fn set_initial_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.initial_path = input;
            self
        }
        /// Consumes the builder and constructs a [`RegisteredUserQuickSightConsoleEmbeddingConfiguration`](crate::model::RegisteredUserQuickSightConsoleEmbeddingConfiguration).
        pub fn build(self) -> crate::model::RegisteredUserQuickSightConsoleEmbeddingConfiguration {
            crate::model::RegisteredUserQuickSightConsoleEmbeddingConfiguration {
                initial_path: self.initial_path,
            }
        }
    }
}
impl RegisteredUserQuickSightConsoleEmbeddingConfiguration {
    /// Creates a new builder-style object to manufacture [`RegisteredUserQuickSightConsoleEmbeddingConfiguration`](crate::model::RegisteredUserQuickSightConsoleEmbeddingConfiguration).
    pub fn builder(
    ) -> crate::model::registered_user_quick_sight_console_embedding_configuration::Builder {
        crate::model::registered_user_quick_sight_console_embedding_configuration::Builder::default(
        )
    }
}

/// <p>Information about the dashboard you want to embed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegisteredUserDashboardEmbeddingConfiguration {
    /// <p>The dashboard ID for the dashboard that you want the user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this dashboard if the user has permissions to view it.</p>
    /// <p>If the user does not have permission to view this dashboard, they see a permissions error message.</p>
    #[doc(hidden)]
    pub initial_dashboard_id: std::option::Option<std::string::String>,
}
impl RegisteredUserDashboardEmbeddingConfiguration {
    /// <p>The dashboard ID for the dashboard that you want the user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this dashboard if the user has permissions to view it.</p>
    /// <p>If the user does not have permission to view this dashboard, they see a permissions error message.</p>
    pub fn initial_dashboard_id(&self) -> std::option::Option<&str> {
        self.initial_dashboard_id.as_deref()
    }
}
/// See [`RegisteredUserDashboardEmbeddingConfiguration`](crate::model::RegisteredUserDashboardEmbeddingConfiguration).
pub mod registered_user_dashboard_embedding_configuration {

    /// A builder for [`RegisteredUserDashboardEmbeddingConfiguration`](crate::model::RegisteredUserDashboardEmbeddingConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) initial_dashboard_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The dashboard ID for the dashboard that you want the user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this dashboard if the user has permissions to view it.</p>
        /// <p>If the user does not have permission to view this dashboard, they see a permissions error message.</p>
        pub fn initial_dashboard_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.initial_dashboard_id = Some(input.into());
            self
        }
        /// <p>The dashboard ID for the dashboard that you want the user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this dashboard if the user has permissions to view it.</p>
        /// <p>If the user does not have permission to view this dashboard, they see a permissions error message.</p>
        pub fn set_initial_dashboard_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.initial_dashboard_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RegisteredUserDashboardEmbeddingConfiguration`](crate::model::RegisteredUserDashboardEmbeddingConfiguration).
        pub fn build(self) -> crate::model::RegisteredUserDashboardEmbeddingConfiguration {
            crate::model::RegisteredUserDashboardEmbeddingConfiguration {
                initial_dashboard_id: self.initial_dashboard_id,
            }
        }
    }
}
impl RegisteredUserDashboardEmbeddingConfiguration {
    /// Creates a new builder-style object to manufacture [`RegisteredUserDashboardEmbeddingConfiguration`](crate::model::RegisteredUserDashboardEmbeddingConfiguration).
    pub fn builder() -> crate::model::registered_user_dashboard_embedding_configuration::Builder {
        crate::model::registered_user_dashboard_embedding_configuration::Builder::default()
    }
}

/// <p>The type of experience you want to embed. For anonymous users, you can embed Amazon QuickSight dashboards.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnonymousUserEmbeddingExperienceConfiguration {
    /// <p>The type of embedding experience. In this case, Amazon QuickSight dashboards.</p>
    #[doc(hidden)]
    pub dashboard: std::option::Option<crate::model::AnonymousUserDashboardEmbeddingConfiguration>,
    /// <p>The type of embedding experience. In this case, Amazon QuickSight visuals.</p>
    #[doc(hidden)]
    pub dashboard_visual:
        std::option::Option<crate::model::AnonymousUserDashboardVisualEmbeddingConfiguration>,
    /// <p>The Q search bar that you want to use for anonymous user embedding.</p>
    #[doc(hidden)]
    pub q_search_bar:
        std::option::Option<crate::model::AnonymousUserQSearchBarEmbeddingConfiguration>,
}
impl AnonymousUserEmbeddingExperienceConfiguration {
    /// <p>The type of embedding experience. In this case, Amazon QuickSight dashboards.</p>
    pub fn dashboard(
        &self,
    ) -> std::option::Option<&crate::model::AnonymousUserDashboardEmbeddingConfiguration> {
        self.dashboard.as_ref()
    }
    /// <p>The type of embedding experience. In this case, Amazon QuickSight visuals.</p>
    pub fn dashboard_visual(
        &self,
    ) -> std::option::Option<&crate::model::AnonymousUserDashboardVisualEmbeddingConfiguration>
    {
        self.dashboard_visual.as_ref()
    }
    /// <p>The Q search bar that you want to use for anonymous user embedding.</p>
    pub fn q_search_bar(
        &self,
    ) -> std::option::Option<&crate::model::AnonymousUserQSearchBarEmbeddingConfiguration> {
        self.q_search_bar.as_ref()
    }
}
/// See [`AnonymousUserEmbeddingExperienceConfiguration`](crate::model::AnonymousUserEmbeddingExperienceConfiguration).
pub mod anonymous_user_embedding_experience_configuration {

    /// A builder for [`AnonymousUserEmbeddingExperienceConfiguration`](crate::model::AnonymousUserEmbeddingExperienceConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dashboard:
            std::option::Option<crate::model::AnonymousUserDashboardEmbeddingConfiguration>,
        pub(crate) dashboard_visual:
            std::option::Option<crate::model::AnonymousUserDashboardVisualEmbeddingConfiguration>,
        pub(crate) q_search_bar:
            std::option::Option<crate::model::AnonymousUserQSearchBarEmbeddingConfiguration>,
    }
    impl Builder {
        /// <p>The type of embedding experience. In this case, Amazon QuickSight dashboards.</p>
        pub fn dashboard(
            mut self,
            input: crate::model::AnonymousUserDashboardEmbeddingConfiguration,
        ) -> Self {
            self.dashboard = Some(input);
            self
        }
        /// <p>The type of embedding experience. In this case, Amazon QuickSight dashboards.</p>
        pub fn set_dashboard(
            mut self,
            input: std::option::Option<crate::model::AnonymousUserDashboardEmbeddingConfiguration>,
        ) -> Self {
            self.dashboard = input;
            self
        }
        /// <p>The type of embedding experience. In this case, Amazon QuickSight visuals.</p>
        pub fn dashboard_visual(
            mut self,
            input: crate::model::AnonymousUserDashboardVisualEmbeddingConfiguration,
        ) -> Self {
            self.dashboard_visual = Some(input);
            self
        }
        /// <p>The type of embedding experience. In this case, Amazon QuickSight visuals.</p>
        pub fn set_dashboard_visual(
            mut self,
            input: std::option::Option<
                crate::model::AnonymousUserDashboardVisualEmbeddingConfiguration,
            >,
        ) -> Self {
            self.dashboard_visual = input;
            self
        }
        /// <p>The Q search bar that you want to use for anonymous user embedding.</p>
        pub fn q_search_bar(
            mut self,
            input: crate::model::AnonymousUserQSearchBarEmbeddingConfiguration,
        ) -> Self {
            self.q_search_bar = Some(input);
            self
        }
        /// <p>The Q search bar that you want to use for anonymous user embedding.</p>
        pub fn set_q_search_bar(
            mut self,
            input: std::option::Option<crate::model::AnonymousUserQSearchBarEmbeddingConfiguration>,
        ) -> Self {
            self.q_search_bar = input;
            self
        }
        /// Consumes the builder and constructs a [`AnonymousUserEmbeddingExperienceConfiguration`](crate::model::AnonymousUserEmbeddingExperienceConfiguration).
        pub fn build(self) -> crate::model::AnonymousUserEmbeddingExperienceConfiguration {
            crate::model::AnonymousUserEmbeddingExperienceConfiguration {
                dashboard: self.dashboard,
                dashboard_visual: self.dashboard_visual,
                q_search_bar: self.q_search_bar,
            }
        }
    }
}
impl AnonymousUserEmbeddingExperienceConfiguration {
    /// Creates a new builder-style object to manufacture [`AnonymousUserEmbeddingExperienceConfiguration`](crate::model::AnonymousUserEmbeddingExperienceConfiguration).
    pub fn builder() -> crate::model::anonymous_user_embedding_experience_configuration::Builder {
        crate::model::anonymous_user_embedding_experience_configuration::Builder::default()
    }
}

/// <p>The settings that you want to use with the Q search bar.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnonymousUserQSearchBarEmbeddingConfiguration {
    /// <p>The QuickSight Q topic ID of the topic that you want the anonymous user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders the Q search bar with this topic pre-selected.</p>
    /// <p>The Amazon Resource Name (ARN) of this Q topic must be included in the <code>AuthorizedResourceArns</code> parameter. Otherwise, the request will fail with <code>InvalidParameterValueException</code>.</p>
    #[doc(hidden)]
    pub initial_topic_id: std::option::Option<std::string::String>,
}
impl AnonymousUserQSearchBarEmbeddingConfiguration {
    /// <p>The QuickSight Q topic ID of the topic that you want the anonymous user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders the Q search bar with this topic pre-selected.</p>
    /// <p>The Amazon Resource Name (ARN) of this Q topic must be included in the <code>AuthorizedResourceArns</code> parameter. Otherwise, the request will fail with <code>InvalidParameterValueException</code>.</p>
    pub fn initial_topic_id(&self) -> std::option::Option<&str> {
        self.initial_topic_id.as_deref()
    }
}
/// See [`AnonymousUserQSearchBarEmbeddingConfiguration`](crate::model::AnonymousUserQSearchBarEmbeddingConfiguration).
pub mod anonymous_user_q_search_bar_embedding_configuration {

    /// A builder for [`AnonymousUserQSearchBarEmbeddingConfiguration`](crate::model::AnonymousUserQSearchBarEmbeddingConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) initial_topic_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The QuickSight Q topic ID of the topic that you want the anonymous user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders the Q search bar with this topic pre-selected.</p>
        /// <p>The Amazon Resource Name (ARN) of this Q topic must be included in the <code>AuthorizedResourceArns</code> parameter. Otherwise, the request will fail with <code>InvalidParameterValueException</code>.</p>
        pub fn initial_topic_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.initial_topic_id = Some(input.into());
            self
        }
        /// <p>The QuickSight Q topic ID of the topic that you want the anonymous user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders the Q search bar with this topic pre-selected.</p>
        /// <p>The Amazon Resource Name (ARN) of this Q topic must be included in the <code>AuthorizedResourceArns</code> parameter. Otherwise, the request will fail with <code>InvalidParameterValueException</code>.</p>
        pub fn set_initial_topic_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.initial_topic_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AnonymousUserQSearchBarEmbeddingConfiguration`](crate::model::AnonymousUserQSearchBarEmbeddingConfiguration).
        pub fn build(self) -> crate::model::AnonymousUserQSearchBarEmbeddingConfiguration {
            crate::model::AnonymousUserQSearchBarEmbeddingConfiguration {
                initial_topic_id: self.initial_topic_id,
            }
        }
    }
}
impl AnonymousUserQSearchBarEmbeddingConfiguration {
    /// Creates a new builder-style object to manufacture [`AnonymousUserQSearchBarEmbeddingConfiguration`](crate::model::AnonymousUserQSearchBarEmbeddingConfiguration).
    pub fn builder() -> crate::model::anonymous_user_q_search_bar_embedding_configuration::Builder {
        crate::model::anonymous_user_q_search_bar_embedding_configuration::Builder::default()
    }
}

/// <p>The experience that you are embedding. You can use this object to generate a url that embeds a visual into your application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnonymousUserDashboardVisualEmbeddingConfiguration {
    /// <p>The visual ID for the visual that you want the user to see. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this visual.</p>
    /// <p>The Amazon Resource Name (ARN) of the dashboard that the visual belongs to must be included in the <code>AuthorizedResourceArns</code> parameter. Otherwise, the request will fail with <code>InvalidParameterValueException</code>.</p>
    #[doc(hidden)]
    pub initial_dashboard_visual_id: std::option::Option<crate::model::DashboardVisualId>,
}
impl AnonymousUserDashboardVisualEmbeddingConfiguration {
    /// <p>The visual ID for the visual that you want the user to see. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this visual.</p>
    /// <p>The Amazon Resource Name (ARN) of the dashboard that the visual belongs to must be included in the <code>AuthorizedResourceArns</code> parameter. Otherwise, the request will fail with <code>InvalidParameterValueException</code>.</p>
    pub fn initial_dashboard_visual_id(
        &self,
    ) -> std::option::Option<&crate::model::DashboardVisualId> {
        self.initial_dashboard_visual_id.as_ref()
    }
}
/// See [`AnonymousUserDashboardVisualEmbeddingConfiguration`](crate::model::AnonymousUserDashboardVisualEmbeddingConfiguration).
pub mod anonymous_user_dashboard_visual_embedding_configuration {

    /// A builder for [`AnonymousUserDashboardVisualEmbeddingConfiguration`](crate::model::AnonymousUserDashboardVisualEmbeddingConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) initial_dashboard_visual_id:
            std::option::Option<crate::model::DashboardVisualId>,
    }
    impl Builder {
        /// <p>The visual ID for the visual that you want the user to see. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this visual.</p>
        /// <p>The Amazon Resource Name (ARN) of the dashboard that the visual belongs to must be included in the <code>AuthorizedResourceArns</code> parameter. Otherwise, the request will fail with <code>InvalidParameterValueException</code>.</p>
        pub fn initial_dashboard_visual_id(
            mut self,
            input: crate::model::DashboardVisualId,
        ) -> Self {
            self.initial_dashboard_visual_id = Some(input);
            self
        }
        /// <p>The visual ID for the visual that you want the user to see. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this visual.</p>
        /// <p>The Amazon Resource Name (ARN) of the dashboard that the visual belongs to must be included in the <code>AuthorizedResourceArns</code> parameter. Otherwise, the request will fail with <code>InvalidParameterValueException</code>.</p>
        pub fn set_initial_dashboard_visual_id(
            mut self,
            input: std::option::Option<crate::model::DashboardVisualId>,
        ) -> Self {
            self.initial_dashboard_visual_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AnonymousUserDashboardVisualEmbeddingConfiguration`](crate::model::AnonymousUserDashboardVisualEmbeddingConfiguration).
        pub fn build(self) -> crate::model::AnonymousUserDashboardVisualEmbeddingConfiguration {
            crate::model::AnonymousUserDashboardVisualEmbeddingConfiguration {
                initial_dashboard_visual_id: self.initial_dashboard_visual_id,
            }
        }
    }
}
impl AnonymousUserDashboardVisualEmbeddingConfiguration {
    /// Creates a new builder-style object to manufacture [`AnonymousUserDashboardVisualEmbeddingConfiguration`](crate::model::AnonymousUserDashboardVisualEmbeddingConfiguration).
    pub fn builder(
    ) -> crate::model::anonymous_user_dashboard_visual_embedding_configuration::Builder {
        crate::model::anonymous_user_dashboard_visual_embedding_configuration::Builder::default()
    }
}

/// <p>Information about the dashboard that you want to embed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnonymousUserDashboardEmbeddingConfiguration {
    /// <p>The dashboard ID for the dashboard that you want the user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this dashboard.</p>
    /// <p>The Amazon Resource Name (ARN) of this dashboard must be included in the <code>AuthorizedResourceArns</code> parameter. Otherwise, the request will fail with <code>InvalidParameterValueException</code>.</p>
    #[doc(hidden)]
    pub initial_dashboard_id: std::option::Option<std::string::String>,
}
impl AnonymousUserDashboardEmbeddingConfiguration {
    /// <p>The dashboard ID for the dashboard that you want the user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this dashboard.</p>
    /// <p>The Amazon Resource Name (ARN) of this dashboard must be included in the <code>AuthorizedResourceArns</code> parameter. Otherwise, the request will fail with <code>InvalidParameterValueException</code>.</p>
    pub fn initial_dashboard_id(&self) -> std::option::Option<&str> {
        self.initial_dashboard_id.as_deref()
    }
}
/// See [`AnonymousUserDashboardEmbeddingConfiguration`](crate::model::AnonymousUserDashboardEmbeddingConfiguration).
pub mod anonymous_user_dashboard_embedding_configuration {

    /// A builder for [`AnonymousUserDashboardEmbeddingConfiguration`](crate::model::AnonymousUserDashboardEmbeddingConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) initial_dashboard_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The dashboard ID for the dashboard that you want the user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this dashboard.</p>
        /// <p>The Amazon Resource Name (ARN) of this dashboard must be included in the <code>AuthorizedResourceArns</code> parameter. Otherwise, the request will fail with <code>InvalidParameterValueException</code>.</p>
        pub fn initial_dashboard_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.initial_dashboard_id = Some(input.into());
            self
        }
        /// <p>The dashboard ID for the dashboard that you want the user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this dashboard.</p>
        /// <p>The Amazon Resource Name (ARN) of this dashboard must be included in the <code>AuthorizedResourceArns</code> parameter. Otherwise, the request will fail with <code>InvalidParameterValueException</code>.</p>
        pub fn set_initial_dashboard_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.initial_dashboard_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AnonymousUserDashboardEmbeddingConfiguration`](crate::model::AnonymousUserDashboardEmbeddingConfiguration).
        pub fn build(self) -> crate::model::AnonymousUserDashboardEmbeddingConfiguration {
            crate::model::AnonymousUserDashboardEmbeddingConfiguration {
                initial_dashboard_id: self.initial_dashboard_id,
            }
        }
    }
}
impl AnonymousUserDashboardEmbeddingConfiguration {
    /// Creates a new builder-style object to manufacture [`AnonymousUserDashboardEmbeddingConfiguration`](crate::model::AnonymousUserDashboardEmbeddingConfiguration).
    pub fn builder() -> crate::model::anonymous_user_dashboard_embedding_configuration::Builder {
        crate::model::anonymous_user_dashboard_embedding_configuration::Builder::default()
    }
}

/// <p>The key-value pair used for the row-level security tags feature.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SessionTag {
    /// <p>The key for the tag.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value that you want to assign the tag.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl SessionTag {
    /// <p>The key for the tag.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value that you want to assign the tag.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for SessionTag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SessionTag");
        formatter.field("key", &self.key);
        formatter.field("value", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`SessionTag`](crate::model::SessionTag).
pub mod session_tag {

    /// A builder for [`SessionTag`](crate::model::SessionTag).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key for the tag.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key for the tag.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value that you want to assign the tag.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value that you want to assign the tag.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`SessionTag`](crate::model::SessionTag).
        pub fn build(self) -> crate::model::SessionTag {
            crate::model::SessionTag {
                key: self.key,
                value: self.value,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("key", &self.key);
            formatter.field("value", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl SessionTag {
    /// Creates a new builder-style object to manufacture [`SessionTag`](crate::model::SessionTag).
    pub fn builder() -> crate::model::session_tag::Builder {
        crate::model::session_tag::Builder::default()
    }
}

/// <p>Summary information about a theme.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Theme {
    /// <p>The Amazon Resource Name (ARN) of the theme.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name that the user gives to the theme.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The identifier that the user gives to the theme.</p>
    #[doc(hidden)]
    pub theme_id: std::option::Option<std::string::String>,
    /// <p>A version of a theme.</p>
    #[doc(hidden)]
    pub version: std::option::Option<crate::model::ThemeVersion>,
    /// <p>The date and time that the theme was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time that the theme was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The type of theme, based on how it was created. Valid values include: <code>QUICKSIGHT</code> and <code>CUSTOM</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ThemeType>,
}
impl Theme {
    /// <p>The Amazon Resource Name (ARN) of the theme.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name that the user gives to the theme.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The identifier that the user gives to the theme.</p>
    pub fn theme_id(&self) -> std::option::Option<&str> {
        self.theme_id.as_deref()
    }
    /// <p>A version of a theme.</p>
    pub fn version(&self) -> std::option::Option<&crate::model::ThemeVersion> {
        self.version.as_ref()
    }
    /// <p>The date and time that the theme was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The date and time that the theme was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
    /// <p>The type of theme, based on how it was created. Valid values include: <code>QUICKSIGHT</code> and <code>CUSTOM</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ThemeType> {
        self.r#type.as_ref()
    }
}
/// See [`Theme`](crate::model::Theme).
pub mod theme {

    /// A builder for [`Theme`](crate::model::Theme).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) theme_id: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<crate::model::ThemeVersion>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) r#type: std::option::Option<crate::model::ThemeType>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the theme.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the theme.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name that the user gives to the theme.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name that the user gives to the theme.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The identifier that the user gives to the theme.</p>
        pub fn theme_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.theme_id = Some(input.into());
            self
        }
        /// <p>The identifier that the user gives to the theme.</p>
        pub fn set_theme_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.theme_id = input;
            self
        }
        /// <p>A version of a theme.</p>
        pub fn version(mut self, input: crate::model::ThemeVersion) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>A version of a theme.</p>
        pub fn set_version(
            mut self,
            input: std::option::Option<crate::model::ThemeVersion>,
        ) -> Self {
            self.version = input;
            self
        }
        /// <p>The date and time that the theme was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The date and time that the theme was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The date and time that the theme was last updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The date and time that the theme was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>The type of theme, based on how it was created. Valid values include: <code>QUICKSIGHT</code> and <code>CUSTOM</code>.</p>
        pub fn r#type(mut self, input: crate::model::ThemeType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of theme, based on how it was created. Valid values include: <code>QUICKSIGHT</code> and <code>CUSTOM</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ThemeType>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`Theme`](crate::model::Theme).
        pub fn build(self) -> crate::model::Theme {
            crate::model::Theme {
                arn: self.arn,
                name: self.name,
                theme_id: self.theme_id,
                version: self.version,
                created_time: self.created_time,
                last_updated_time: self.last_updated_time,
                r#type: self.r#type,
            }
        }
    }
}
impl Theme {
    /// Creates a new builder-style object to manufacture [`Theme`](crate::model::Theme).
    pub fn builder() -> crate::model::theme::Builder {
        crate::model::theme::Builder::default()
    }
}

/// <p>A version of a theme.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThemeVersion {
    /// <p>The version number of the theme.</p>
    #[doc(hidden)]
    pub version_number: std::option::Option<i64>,
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The description of the theme.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The Amazon QuickSight-defined ID of the theme that a custom theme inherits from. All themes initially inherit from a default Amazon QuickSight theme.</p>
    #[doc(hidden)]
    pub base_theme_id: std::option::Option<std::string::String>,
    /// <p>The date and time that this theme version was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The theme configuration, which contains all the theme display properties.</p>
    #[doc(hidden)]
    pub configuration: std::option::Option<crate::model::ThemeConfiguration>,
    /// <p>Errors associated with the theme.</p>
    #[doc(hidden)]
    pub errors: std::option::Option<std::vec::Vec<crate::model::ThemeError>>,
    /// <p>The status of the theme version.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ResourceStatus>,
}
impl ThemeVersion {
    /// <p>The version number of the theme.</p>
    pub fn version_number(&self) -> std::option::Option<i64> {
        self.version_number
    }
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The description of the theme.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The Amazon QuickSight-defined ID of the theme that a custom theme inherits from. All themes initially inherit from a default Amazon QuickSight theme.</p>
    pub fn base_theme_id(&self) -> std::option::Option<&str> {
        self.base_theme_id.as_deref()
    }
    /// <p>The date and time that this theme version was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The theme configuration, which contains all the theme display properties.</p>
    pub fn configuration(&self) -> std::option::Option<&crate::model::ThemeConfiguration> {
        self.configuration.as_ref()
    }
    /// <p>Errors associated with the theme.</p>
    pub fn errors(&self) -> std::option::Option<&[crate::model::ThemeError]> {
        self.errors.as_deref()
    }
    /// <p>The status of the theme version.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ResourceStatus> {
        self.status.as_ref()
    }
}
/// See [`ThemeVersion`](crate::model::ThemeVersion).
pub mod theme_version {

    /// A builder for [`ThemeVersion`](crate::model::ThemeVersion).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) version_number: std::option::Option<i64>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) base_theme_id: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) configuration: std::option::Option<crate::model::ThemeConfiguration>,
        pub(crate) errors: std::option::Option<std::vec::Vec<crate::model::ThemeError>>,
        pub(crate) status: std::option::Option<crate::model::ResourceStatus>,
    }
    impl Builder {
        /// <p>The version number of the theme.</p>
        pub fn version_number(mut self, input: i64) -> Self {
            self.version_number = Some(input);
            self
        }
        /// <p>The version number of the theme.</p>
        pub fn set_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.version_number = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The description of the theme.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the theme.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The Amazon QuickSight-defined ID of the theme that a custom theme inherits from. All themes initially inherit from a default Amazon QuickSight theme.</p>
        pub fn base_theme_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.base_theme_id = Some(input.into());
            self
        }
        /// <p>The Amazon QuickSight-defined ID of the theme that a custom theme inherits from. All themes initially inherit from a default Amazon QuickSight theme.</p>
        pub fn set_base_theme_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.base_theme_id = input;
            self
        }
        /// <p>The date and time that this theme version was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The date and time that this theme version was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The theme configuration, which contains all the theme display properties.</p>
        pub fn configuration(mut self, input: crate::model::ThemeConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>The theme configuration, which contains all the theme display properties.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::ThemeConfiguration>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// Appends an item to `errors`.
        ///
        /// To override the contents of this collection use [`set_errors`](Self::set_errors).
        ///
        /// <p>Errors associated with the theme.</p>
        pub fn errors(mut self, input: crate::model::ThemeError) -> Self {
            let mut v = self.errors.unwrap_or_default();
            v.push(input);
            self.errors = Some(v);
            self
        }
        /// <p>Errors associated with the theme.</p>
        pub fn set_errors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ThemeError>>,
        ) -> Self {
            self.errors = input;
            self
        }
        /// <p>The status of the theme version.</p>
        pub fn status(mut self, input: crate::model::ResourceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the theme version.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ResourceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ThemeVersion`](crate::model::ThemeVersion).
        pub fn build(self) -> crate::model::ThemeVersion {
            crate::model::ThemeVersion {
                version_number: self.version_number,
                arn: self.arn,
                description: self.description,
                base_theme_id: self.base_theme_id,
                created_time: self.created_time,
                configuration: self.configuration,
                errors: self.errors,
                status: self.status,
            }
        }
    }
}
impl ThemeVersion {
    /// Creates a new builder-style object to manufacture [`ThemeVersion`](crate::model::ThemeVersion).
    pub fn builder() -> crate::model::theme_version::Builder {
        crate::model::theme_version::Builder::default()
    }
}

/// <p>Theme error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThemeError {
    /// <p>The type of error.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ThemeErrorType>,
    /// <p>The error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ThemeError {
    /// <p>The type of error.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ThemeErrorType> {
        self.r#type.as_ref()
    }
    /// <p>The error message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`ThemeError`](crate::model::ThemeError).
pub mod theme_error {

    /// A builder for [`ThemeError`](crate::model::ThemeError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::ThemeErrorType>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of error.</p>
        pub fn r#type(mut self, input: crate::model::ThemeErrorType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of error.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ThemeErrorType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ThemeError`](crate::model::ThemeError).
        pub fn build(self) -> crate::model::ThemeError {
            crate::model::ThemeError {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl ThemeError {
    /// Creates a new builder-style object to manufacture [`ThemeError`](crate::model::ThemeError).
    pub fn builder() -> crate::model::theme_error::Builder {
        crate::model::theme_error::Builder::default()
    }
}

/// When writing a match expression against `ThemeErrorType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let themeerrortype = unimplemented!();
/// match themeerrortype {
///     ThemeErrorType::InternalFailure => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `themeerrortype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ThemeErrorType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ThemeErrorType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ThemeErrorType::NewFeature` is defined.
/// Specifically, when `themeerrortype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ThemeErrorType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ThemeErrorType {
    #[allow(missing_docs)] // documentation missing in model
    InternalFailure,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ThemeErrorType {
    fn from(s: &str) -> Self {
        match s {
            "INTERNAL_FAILURE" => ThemeErrorType::InternalFailure,
            other => ThemeErrorType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ThemeErrorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ThemeErrorType::from(s))
    }
}
impl ThemeErrorType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ThemeErrorType::InternalFailure => "INTERNAL_FAILURE",
            ThemeErrorType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INTERNAL_FAILURE"]
    }
}
impl AsRef<str> for ThemeErrorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>List of errors that occurred when the template version creation failed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TemplateError {
    /// <p>Type of error.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::TemplateErrorType>,
    /// <p>Description of the error type.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>An error path that shows which entities caused the template error.</p>
    #[doc(hidden)]
    pub violated_entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
}
impl TemplateError {
    /// <p>Type of error.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::TemplateErrorType> {
        self.r#type.as_ref()
    }
    /// <p>Description of the error type.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>An error path that shows which entities caused the template error.</p>
    pub fn violated_entities(&self) -> std::option::Option<&[crate::model::Entity]> {
        self.violated_entities.as_deref()
    }
}
/// See [`TemplateError`](crate::model::TemplateError).
pub mod template_error {

    /// A builder for [`TemplateError`](crate::model::TemplateError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::TemplateErrorType>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) violated_entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
    }
    impl Builder {
        /// <p>Type of error.</p>
        pub fn r#type(mut self, input: crate::model::TemplateErrorType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Type of error.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::TemplateErrorType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Description of the error type.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Description of the error type.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Appends an item to `violated_entities`.
        ///
        /// To override the contents of this collection use [`set_violated_entities`](Self::set_violated_entities).
        ///
        /// <p>An error path that shows which entities caused the template error.</p>
        pub fn violated_entities(mut self, input: crate::model::Entity) -> Self {
            let mut v = self.violated_entities.unwrap_or_default();
            v.push(input);
            self.violated_entities = Some(v);
            self
        }
        /// <p>An error path that shows which entities caused the template error.</p>
        pub fn set_violated_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        ) -> Self {
            self.violated_entities = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateError`](crate::model::TemplateError).
        pub fn build(self) -> crate::model::TemplateError {
            crate::model::TemplateError {
                r#type: self.r#type,
                message: self.message,
                violated_entities: self.violated_entities,
            }
        }
    }
}
impl TemplateError {
    /// Creates a new builder-style object to manufacture [`TemplateError`](crate::model::TemplateError).
    pub fn builder() -> crate::model::template_error::Builder {
        crate::model::template_error::Builder::default()
    }
}

/// <p>An object, structure, or sub-structure of an analysis, template, or dashboard.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Entity {
    /// <p>The hierarchical path of the entity within the analysis, template, or dashboard definition tree.</p>
    #[doc(hidden)]
    pub path: std::option::Option<std::string::String>,
}
impl Entity {
    /// <p>The hierarchical path of the entity within the analysis, template, or dashboard definition tree.</p>
    pub fn path(&self) -> std::option::Option<&str> {
        self.path.as_deref()
    }
}
/// See [`Entity`](crate::model::Entity).
pub mod entity {

    /// A builder for [`Entity`](crate::model::Entity).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The hierarchical path of the entity within the analysis, template, or dashboard definition tree.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>The hierarchical path of the entity within the analysis, template, or dashboard definition tree.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// Consumes the builder and constructs a [`Entity`](crate::model::Entity).
        pub fn build(self) -> crate::model::Entity {
            crate::model::Entity { path: self.path }
        }
    }
}
impl Entity {
    /// Creates a new builder-style object to manufacture [`Entity`](crate::model::Entity).
    pub fn builder() -> crate::model::entity::Builder {
        crate::model::entity::Builder::default()
    }
}

/// When writing a match expression against `TemplateErrorType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let templateerrortype = unimplemented!();
/// match templateerrortype {
///     TemplateErrorType::AccessDenied => { /* ... */ },
///     TemplateErrorType::DataSetNotFound => { /* ... */ },
///     TemplateErrorType::InternalFailure => { /* ... */ },
///     TemplateErrorType::SourceNotFound => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `templateerrortype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TemplateErrorType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TemplateErrorType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TemplateErrorType::NewFeature` is defined.
/// Specifically, when `templateerrortype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TemplateErrorType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TemplateErrorType {
    #[allow(missing_docs)] // documentation missing in model
    AccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    DataSetNotFound,
    #[allow(missing_docs)] // documentation missing in model
    InternalFailure,
    #[allow(missing_docs)] // documentation missing in model
    SourceNotFound,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TemplateErrorType {
    fn from(s: &str) -> Self {
        match s {
            "ACCESS_DENIED" => TemplateErrorType::AccessDenied,
            "DATA_SET_NOT_FOUND" => TemplateErrorType::DataSetNotFound,
            "INTERNAL_FAILURE" => TemplateErrorType::InternalFailure,
            "SOURCE_NOT_FOUND" => TemplateErrorType::SourceNotFound,
            other => {
                TemplateErrorType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TemplateErrorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TemplateErrorType::from(s))
    }
}
impl TemplateErrorType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TemplateErrorType::AccessDenied => "ACCESS_DENIED",
            TemplateErrorType::DataSetNotFound => "DATA_SET_NOT_FOUND",
            TemplateErrorType::InternalFailure => "INTERNAL_FAILURE",
            TemplateErrorType::SourceNotFound => "SOURCE_NOT_FOUND",
            TemplateErrorType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACCESS_DENIED",
            "DATA_SET_NOT_FOUND",
            "INTERNAL_FAILURE",
            "SOURCE_NOT_FOUND",
        ]
    }
}
impl AsRef<str> for TemplateErrorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A template object. A <i>template</i> is an entity in Amazon QuickSight that encapsulates the metadata required to create an analysis and that you can use to create a dashboard. A template adds a layer of abstraction by using placeholders to replace the dataset associated with an analysis. You can use templates to create dashboards by replacing dataset placeholders with datasets that follow the same schema that was used to create the source analysis and template.</p>
/// <p>You can share templates across Amazon Web Services accounts by allowing users in other Amazon Web Services accounts to create a template or a dashboard from an existing template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Template {
    /// <p>The Amazon Resource Name (ARN) of the template.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The display name of the template.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A structure describing the versions of the template.</p>
    #[doc(hidden)]
    pub version: std::option::Option<crate::model::TemplateVersion>,
    /// <p>The ID for the template. This is unique per Amazon Web Services Region for each Amazon Web Services account.</p>
    #[doc(hidden)]
    pub template_id: std::option::Option<std::string::String>,
    /// <p>Time when this was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Time when this was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl Template {
    /// <p>The Amazon Resource Name (ARN) of the template.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The display name of the template.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A structure describing the versions of the template.</p>
    pub fn version(&self) -> std::option::Option<&crate::model::TemplateVersion> {
        self.version.as_ref()
    }
    /// <p>The ID for the template. This is unique per Amazon Web Services Region for each Amazon Web Services account.</p>
    pub fn template_id(&self) -> std::option::Option<&str> {
        self.template_id.as_deref()
    }
    /// <p>Time when this was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
    /// <p>Time when this was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
}
/// See [`Template`](crate::model::Template).
pub mod template {

    /// A builder for [`Template`](crate::model::Template).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<crate::model::TemplateVersion>,
        pub(crate) template_id: std::option::Option<std::string::String>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the template.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the template.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The display name of the template.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The display name of the template.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A structure describing the versions of the template.</p>
        pub fn version(mut self, input: crate::model::TemplateVersion) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>A structure describing the versions of the template.</p>
        pub fn set_version(
            mut self,
            input: std::option::Option<crate::model::TemplateVersion>,
        ) -> Self {
            self.version = input;
            self
        }
        /// <p>The ID for the template. This is unique per Amazon Web Services Region for each Amazon Web Services account.</p>
        pub fn template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_id = Some(input.into());
            self
        }
        /// <p>The ID for the template. This is unique per Amazon Web Services Region for each Amazon Web Services account.</p>
        pub fn set_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_id = input;
            self
        }
        /// <p>Time when this was last updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>Time when this was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>Time when this was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>Time when this was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// Consumes the builder and constructs a [`Template`](crate::model::Template).
        pub fn build(self) -> crate::model::Template {
            crate::model::Template {
                arn: self.arn,
                name: self.name,
                version: self.version,
                template_id: self.template_id,
                last_updated_time: self.last_updated_time,
                created_time: self.created_time,
            }
        }
    }
}
impl Template {
    /// Creates a new builder-style object to manufacture [`Template`](crate::model::Template).
    pub fn builder() -> crate::model::template::Builder {
        crate::model::template::Builder::default()
    }
}

/// <p>A version of a template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TemplateVersion {
    /// <p>The time that this template version was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Errors associated with this template version.</p>
    #[doc(hidden)]
    pub errors: std::option::Option<std::vec::Vec<crate::model::TemplateError>>,
    /// <p>The version number of the template version.</p>
    #[doc(hidden)]
    pub version_number: std::option::Option<i64>,
    /// <p>The status that is associated with the template.</p>
    /// <ul>
    /// <li> <p> <code>CREATION_IN_PROGRESS</code> </p> </li>
    /// <li> <p> <code>CREATION_SUCCESSFUL</code> </p> </li>
    /// <li> <p> <code>CREATION_FAILED</code> </p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> </p> </li>
    /// <li> <p> <code>UPDATE_SUCCESSFUL</code> </p> </li>
    /// <li> <p> <code>UPDATE_FAILED</code> </p> </li>
    /// <li> <p> <code>DELETED</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ResourceStatus>,
    /// <p>Schema of the dataset identified by the placeholder. Any dashboard created from this template should be bound to new datasets matching the same schema described through this API operation.</p>
    #[doc(hidden)]
    pub data_set_configurations:
        std::option::Option<std::vec::Vec<crate::model::DataSetConfiguration>>,
    /// <p>The description of the template.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of an analysis or template that was used to create this template.</p>
    #[doc(hidden)]
    pub source_entity_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the theme associated with this version of the template.</p>
    #[doc(hidden)]
    pub theme_arn: std::option::Option<std::string::String>,
    /// <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
    #[doc(hidden)]
    pub sheets: std::option::Option<std::vec::Vec<crate::model::Sheet>>,
}
impl TemplateVersion {
    /// <p>The time that this template version was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>Errors associated with this template version.</p>
    pub fn errors(&self) -> std::option::Option<&[crate::model::TemplateError]> {
        self.errors.as_deref()
    }
    /// <p>The version number of the template version.</p>
    pub fn version_number(&self) -> std::option::Option<i64> {
        self.version_number
    }
    /// <p>The status that is associated with the template.</p>
    /// <ul>
    /// <li> <p> <code>CREATION_IN_PROGRESS</code> </p> </li>
    /// <li> <p> <code>CREATION_SUCCESSFUL</code> </p> </li>
    /// <li> <p> <code>CREATION_FAILED</code> </p> </li>
    /// <li> <p> <code>UPDATE_IN_PROGRESS</code> </p> </li>
    /// <li> <p> <code>UPDATE_SUCCESSFUL</code> </p> </li>
    /// <li> <p> <code>UPDATE_FAILED</code> </p> </li>
    /// <li> <p> <code>DELETED</code> </p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::ResourceStatus> {
        self.status.as_ref()
    }
    /// <p>Schema of the dataset identified by the placeholder. Any dashboard created from this template should be bound to new datasets matching the same schema described through this API operation.</p>
    pub fn data_set_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::DataSetConfiguration]> {
        self.data_set_configurations.as_deref()
    }
    /// <p>The description of the template.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of an analysis or template that was used to create this template.</p>
    pub fn source_entity_arn(&self) -> std::option::Option<&str> {
        self.source_entity_arn.as_deref()
    }
    /// <p>The ARN of the theme associated with this version of the template.</p>
    pub fn theme_arn(&self) -> std::option::Option<&str> {
        self.theme_arn.as_deref()
    }
    /// <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
    pub fn sheets(&self) -> std::option::Option<&[crate::model::Sheet]> {
        self.sheets.as_deref()
    }
}
/// See [`TemplateVersion`](crate::model::TemplateVersion).
pub mod template_version {

    /// A builder for [`TemplateVersion`](crate::model::TemplateVersion).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) errors: std::option::Option<std::vec::Vec<crate::model::TemplateError>>,
        pub(crate) version_number: std::option::Option<i64>,
        pub(crate) status: std::option::Option<crate::model::ResourceStatus>,
        pub(crate) data_set_configurations:
            std::option::Option<std::vec::Vec<crate::model::DataSetConfiguration>>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) source_entity_arn: std::option::Option<std::string::String>,
        pub(crate) theme_arn: std::option::Option<std::string::String>,
        pub(crate) sheets: std::option::Option<std::vec::Vec<crate::model::Sheet>>,
    }
    impl Builder {
        /// <p>The time that this template version was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The time that this template version was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// Appends an item to `errors`.
        ///
        /// To override the contents of this collection use [`set_errors`](Self::set_errors).
        ///
        /// <p>Errors associated with this template version.</p>
        pub fn errors(mut self, input: crate::model::TemplateError) -> Self {
            let mut v = self.errors.unwrap_or_default();
            v.push(input);
            self.errors = Some(v);
            self
        }
        /// <p>Errors associated with this template version.</p>
        pub fn set_errors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TemplateError>>,
        ) -> Self {
            self.errors = input;
            self
        }
        /// <p>The version number of the template version.</p>
        pub fn version_number(mut self, input: i64) -> Self {
            self.version_number = Some(input);
            self
        }
        /// <p>The version number of the template version.</p>
        pub fn set_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.version_number = input;
            self
        }
        /// <p>The status that is associated with the template.</p>
        /// <ul>
        /// <li> <p> <code>CREATION_IN_PROGRESS</code> </p> </li>
        /// <li> <p> <code>CREATION_SUCCESSFUL</code> </p> </li>
        /// <li> <p> <code>CREATION_FAILED</code> </p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> </p> </li>
        /// <li> <p> <code>UPDATE_SUCCESSFUL</code> </p> </li>
        /// <li> <p> <code>UPDATE_FAILED</code> </p> </li>
        /// <li> <p> <code>DELETED</code> </p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::ResourceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status that is associated with the template.</p>
        /// <ul>
        /// <li> <p> <code>CREATION_IN_PROGRESS</code> </p> </li>
        /// <li> <p> <code>CREATION_SUCCESSFUL</code> </p> </li>
        /// <li> <p> <code>CREATION_FAILED</code> </p> </li>
        /// <li> <p> <code>UPDATE_IN_PROGRESS</code> </p> </li>
        /// <li> <p> <code>UPDATE_SUCCESSFUL</code> </p> </li>
        /// <li> <p> <code>UPDATE_FAILED</code> </p> </li>
        /// <li> <p> <code>DELETED</code> </p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ResourceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `data_set_configurations`.
        ///
        /// To override the contents of this collection use [`set_data_set_configurations`](Self::set_data_set_configurations).
        ///
        /// <p>Schema of the dataset identified by the placeholder. Any dashboard created from this template should be bound to new datasets matching the same schema described through this API operation.</p>
        pub fn data_set_configurations(
            mut self,
            input: crate::model::DataSetConfiguration,
        ) -> Self {
            let mut v = self.data_set_configurations.unwrap_or_default();
            v.push(input);
            self.data_set_configurations = Some(v);
            self
        }
        /// <p>Schema of the dataset identified by the placeholder. Any dashboard created from this template should be bound to new datasets matching the same schema described through this API operation.</p>
        pub fn set_data_set_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataSetConfiguration>>,
        ) -> Self {
            self.data_set_configurations = input;
            self
        }
        /// <p>The description of the template.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the template.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an analysis or template that was used to create this template.</p>
        pub fn source_entity_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_entity_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an analysis or template that was used to create this template.</p>
        pub fn set_source_entity_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_entity_arn = input;
            self
        }
        /// <p>The ARN of the theme associated with this version of the template.</p>
        pub fn theme_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.theme_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the theme associated with this version of the template.</p>
        pub fn set_theme_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.theme_arn = input;
            self
        }
        /// Appends an item to `sheets`.
        ///
        /// To override the contents of this collection use [`set_sheets`](Self::set_sheets).
        ///
        /// <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
        pub fn sheets(mut self, input: crate::model::Sheet) -> Self {
            let mut v = self.sheets.unwrap_or_default();
            v.push(input);
            self.sheets = Some(v);
            self
        }
        /// <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
        pub fn set_sheets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Sheet>>,
        ) -> Self {
            self.sheets = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateVersion`](crate::model::TemplateVersion).
        pub fn build(self) -> crate::model::TemplateVersion {
            crate::model::TemplateVersion {
                created_time: self.created_time,
                errors: self.errors,
                version_number: self.version_number,
                status: self.status,
                data_set_configurations: self.data_set_configurations,
                description: self.description,
                source_entity_arn: self.source_entity_arn,
                theme_arn: self.theme_arn,
                sheets: self.sheets,
            }
        }
    }
}
impl TemplateVersion {
    /// Creates a new builder-style object to manufacture [`TemplateVersion`](crate::model::TemplateVersion).
    pub fn builder() -> crate::model::template_version::Builder {
        crate::model::template_version::Builder::default()
    }
}

/// <p>A <i>sheet</i>, which is an object that contains a set of visuals that are viewed together on one page in Amazon QuickSight. Every analysis and dashboard contains at least one sheet. Each sheet contains at least one visualization widget, for example a chart, pivot table, or narrative insight. Sheets can be associated with other components, such as controls, filters, and so on.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Sheet {
    /// <p>The unique identifier associated with a sheet.</p>
    #[doc(hidden)]
    pub sheet_id: std::option::Option<std::string::String>,
    /// <p>The name of a sheet. This name is displayed on the sheet's tab in the Amazon QuickSight console.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl Sheet {
    /// <p>The unique identifier associated with a sheet.</p>
    pub fn sheet_id(&self) -> std::option::Option<&str> {
        self.sheet_id.as_deref()
    }
    /// <p>The name of a sheet. This name is displayed on the sheet's tab in the Amazon QuickSight console.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`Sheet`](crate::model::Sheet).
pub mod sheet {

    /// A builder for [`Sheet`](crate::model::Sheet).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sheet_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier associated with a sheet.</p>
        pub fn sheet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sheet_id = Some(input.into());
            self
        }
        /// <p>The unique identifier associated with a sheet.</p>
        pub fn set_sheet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sheet_id = input;
            self
        }
        /// <p>The name of a sheet. This name is displayed on the sheet's tab in the Amazon QuickSight console.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a sheet. This name is displayed on the sheet's tab in the Amazon QuickSight console.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`Sheet`](crate::model::Sheet).
        pub fn build(self) -> crate::model::Sheet {
            crate::model::Sheet {
                sheet_id: self.sheet_id,
                name: self.name,
            }
        }
    }
}
impl Sheet {
    /// Creates a new builder-style object to manufacture [`Sheet`](crate::model::Sheet).
    pub fn builder() -> crate::model::sheet::Builder {
        crate::model::sheet::Builder::default()
    }
}

/// <p>An Identity and Access Management (IAM) policy assignment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IamPolicyAssignment {
    /// <p>The Amazon Web Services account ID.</p>
    #[doc(hidden)]
    pub aws_account_id: std::option::Option<std::string::String>,
    /// <p>Assignment ID.</p>
    #[doc(hidden)]
    pub assignment_id: std::option::Option<std::string::String>,
    /// <p>Assignment name.</p>
    #[doc(hidden)]
    pub assignment_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the IAM policy.</p>
    #[doc(hidden)]
    pub policy_arn: std::option::Option<std::string::String>,
    /// <p>Identities.</p>
    #[doc(hidden)]
    pub identities: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>Assignment status.</p>
    #[doc(hidden)]
    pub assignment_status: std::option::Option<crate::model::AssignmentStatus>,
}
impl IamPolicyAssignment {
    /// <p>The Amazon Web Services account ID.</p>
    pub fn aws_account_id(&self) -> std::option::Option<&str> {
        self.aws_account_id.as_deref()
    }
    /// <p>Assignment ID.</p>
    pub fn assignment_id(&self) -> std::option::Option<&str> {
        self.assignment_id.as_deref()
    }
    /// <p>Assignment name.</p>
    pub fn assignment_name(&self) -> std::option::Option<&str> {
        self.assignment_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the IAM policy.</p>
    pub fn policy_arn(&self) -> std::option::Option<&str> {
        self.policy_arn.as_deref()
    }
    /// <p>Identities.</p>
    pub fn identities(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    > {
        self.identities.as_ref()
    }
    /// <p>Assignment status.</p>
    pub fn assignment_status(&self) -> std::option::Option<&crate::model::AssignmentStatus> {
        self.assignment_status.as_ref()
    }
}
/// See [`IamPolicyAssignment`](crate::model::IamPolicyAssignment).
pub mod iam_policy_assignment {

    /// A builder for [`IamPolicyAssignment`](crate::model::IamPolicyAssignment).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) aws_account_id: std::option::Option<std::string::String>,
        pub(crate) assignment_id: std::option::Option<std::string::String>,
        pub(crate) assignment_name: std::option::Option<std::string::String>,
        pub(crate) policy_arn: std::option::Option<std::string::String>,
        pub(crate) identities: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) assignment_status: std::option::Option<crate::model::AssignmentStatus>,
    }
    impl Builder {
        /// <p>The Amazon Web Services account ID.</p>
        pub fn aws_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn set_aws_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.aws_account_id = input;
            self
        }
        /// <p>Assignment ID.</p>
        pub fn assignment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assignment_id = Some(input.into());
            self
        }
        /// <p>Assignment ID.</p>
        pub fn set_assignment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assignment_id = input;
            self
        }
        /// <p>Assignment name.</p>
        pub fn assignment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.assignment_name = Some(input.into());
            self
        }
        /// <p>Assignment name.</p>
        pub fn set_assignment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assignment_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the IAM policy.</p>
        pub fn policy_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the IAM policy.</p>
        pub fn set_policy_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = input;
            self
        }
        /// Adds a key-value pair to `identities`.
        ///
        /// To override the contents of this collection use [`set_identities`](Self::set_identities).
        ///
        /// <p>Identities.</p>
        pub fn identities(
            mut self,
            k: impl Into<std::string::String>,
            v: std::vec::Vec<std::string::String>,
        ) -> Self {
            let mut hash_map = self.identities.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.identities = Some(hash_map);
            self
        }
        /// <p>Identities.</p>
        pub fn set_identities(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.identities = input;
            self
        }
        /// <p>Assignment status.</p>
        pub fn assignment_status(mut self, input: crate::model::AssignmentStatus) -> Self {
            self.assignment_status = Some(input);
            self
        }
        /// <p>Assignment status.</p>
        pub fn set_assignment_status(
            mut self,
            input: std::option::Option<crate::model::AssignmentStatus>,
        ) -> Self {
            self.assignment_status = input;
            self
        }
        /// Consumes the builder and constructs a [`IamPolicyAssignment`](crate::model::IamPolicyAssignment).
        pub fn build(self) -> crate::model::IamPolicyAssignment {
            crate::model::IamPolicyAssignment {
                aws_account_id: self.aws_account_id,
                assignment_id: self.assignment_id,
                assignment_name: self.assignment_name,
                policy_arn: self.policy_arn,
                identities: self.identities,
                assignment_status: self.assignment_status,
            }
        }
    }
}
impl IamPolicyAssignment {
    /// Creates a new builder-style object to manufacture [`IamPolicyAssignment`](crate::model::IamPolicyAssignment).
    pub fn builder() -> crate::model::iam_policy_assignment::Builder {
        crate::model::iam_policy_assignment::Builder::default()
    }
}

/// <p>A folder in Amazon QuickSight.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Folder {
    /// <p>The ID of the folder.</p>
    #[doc(hidden)]
    pub folder_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the folder.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>A display name for the folder.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of folder it is.</p>
    #[doc(hidden)]
    pub folder_type: std::option::Option<crate::model::FolderType>,
    /// <p>An array of ancestor ARN strings for the folder.</p>
    #[doc(hidden)]
    pub folder_path: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The time that the folder was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the folder was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl Folder {
    /// <p>The ID of the folder.</p>
    pub fn folder_id(&self) -> std::option::Option<&str> {
        self.folder_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the folder.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>A display name for the folder.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of folder it is.</p>
    pub fn folder_type(&self) -> std::option::Option<&crate::model::FolderType> {
        self.folder_type.as_ref()
    }
    /// <p>An array of ancestor ARN strings for the folder.</p>
    pub fn folder_path(&self) -> std::option::Option<&[std::string::String]> {
        self.folder_path.as_deref()
    }
    /// <p>The time that the folder was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The time that the folder was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
}
/// See [`Folder`](crate::model::Folder).
pub mod folder {

    /// A builder for [`Folder`](crate::model::Folder).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) folder_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) folder_type: std::option::Option<crate::model::FolderType>,
        pub(crate) folder_path: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ID of the folder.</p>
        pub fn folder_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.folder_id = Some(input.into());
            self
        }
        /// <p>The ID of the folder.</p>
        pub fn set_folder_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.folder_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the folder.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the folder.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>A display name for the folder.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A display name for the folder.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of folder it is.</p>
        pub fn folder_type(mut self, input: crate::model::FolderType) -> Self {
            self.folder_type = Some(input);
            self
        }
        /// <p>The type of folder it is.</p>
        pub fn set_folder_type(
            mut self,
            input: std::option::Option<crate::model::FolderType>,
        ) -> Self {
            self.folder_type = input;
            self
        }
        /// Appends an item to `folder_path`.
        ///
        /// To override the contents of this collection use [`set_folder_path`](Self::set_folder_path).
        ///
        /// <p>An array of ancestor ARN strings for the folder.</p>
        pub fn folder_path(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.folder_path.unwrap_or_default();
            v.push(input.into());
            self.folder_path = Some(v);
            self
        }
        /// <p>An array of ancestor ARN strings for the folder.</p>
        pub fn set_folder_path(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.folder_path = input;
            self
        }
        /// <p>The time that the folder was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The time that the folder was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The time that the folder was last updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The time that the folder was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// Consumes the builder and constructs a [`Folder`](crate::model::Folder).
        pub fn build(self) -> crate::model::Folder {
            crate::model::Folder {
                folder_id: self.folder_id,
                arn: self.arn,
                name: self.name,
                folder_type: self.folder_type,
                folder_path: self.folder_path,
                created_time: self.created_time,
                last_updated_time: self.last_updated_time,
            }
        }
    }
}
impl Folder {
    /// Creates a new builder-style object to manufacture [`Folder`](crate::model::Folder).
    pub fn builder() -> crate::model::folder::Builder {
        crate::model::folder::Builder::default()
    }
}

/// <p>Dataset.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataSet {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ID of the dataset.</p>
    #[doc(hidden)]
    pub data_set_id: std::option::Option<std::string::String>,
    /// <p>A display name for the dataset.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The time that this dataset was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time that this dataset was updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Declares the physical tables that are available in the underlying data sources.</p>
    #[doc(hidden)]
    pub physical_table_map: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::PhysicalTable>,
    >,
    /// <p>Configures the combination and transformation of the data from the physical tables.</p>
    #[doc(hidden)]
    pub logical_table_map: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::LogicalTable>,
    >,
    /// <p>The list of columns after all transforms. These columns are available in templates, analyses, and dashboards.</p>
    #[doc(hidden)]
    pub output_columns: std::option::Option<std::vec::Vec<crate::model::OutputColumn>>,
    /// <p>A value that indicates whether you want to import the data into SPICE.</p>
    #[doc(hidden)]
    pub import_mode: std::option::Option<crate::model::DataSetImportMode>,
    /// <p>The amount of SPICE capacity used by this dataset. This is 0 if the dataset isn't imported into SPICE.</p>
    #[doc(hidden)]
    pub consumed_spice_capacity_in_bytes: i64,
    /// <p>Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.</p>
    #[doc(hidden)]
    pub column_groups: std::option::Option<std::vec::Vec<crate::model::ColumnGroup>>,
    /// <p>The folder that contains fields and nested subfolders for your dataset.</p>
    #[doc(hidden)]
    pub field_folders: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::FieldFolder>,
    >,
    /// <p>The row-level security configuration for the dataset.</p>
    #[doc(hidden)]
    pub row_level_permission_data_set: std::option::Option<crate::model::RowLevelPermissionDataSet>,
    /// <p>The element you can use to define tags for row-level security.</p>
    #[doc(hidden)]
    pub row_level_permission_tag_configuration:
        std::option::Option<crate::model::RowLevelPermissionTagConfiguration>,
    /// <p>A set of one or more definitions of a <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ColumnLevelPermissionRule.html">ColumnLevelPermissionRule</a> </code>.</p>
    #[doc(hidden)]
    pub column_level_permission_rules:
        std::option::Option<std::vec::Vec<crate::model::ColumnLevelPermissionRule>>,
    /// <p>The usage configuration to apply to child datasets that reference this dataset as a source.</p>
    #[doc(hidden)]
    pub data_set_usage_configuration: std::option::Option<crate::model::DataSetUsageConfiguration>,
}
impl DataSet {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The ID of the dataset.</p>
    pub fn data_set_id(&self) -> std::option::Option<&str> {
        self.data_set_id.as_deref()
    }
    /// <p>A display name for the dataset.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The time that this dataset was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The last time that this dataset was updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
    /// <p>Declares the physical tables that are available in the underlying data sources.</p>
    pub fn physical_table_map(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::PhysicalTable>,
    > {
        self.physical_table_map.as_ref()
    }
    /// <p>Configures the combination and transformation of the data from the physical tables.</p>
    pub fn logical_table_map(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::LogicalTable>,
    > {
        self.logical_table_map.as_ref()
    }
    /// <p>The list of columns after all transforms. These columns are available in templates, analyses, and dashboards.</p>
    pub fn output_columns(&self) -> std::option::Option<&[crate::model::OutputColumn]> {
        self.output_columns.as_deref()
    }
    /// <p>A value that indicates whether you want to import the data into SPICE.</p>
    pub fn import_mode(&self) -> std::option::Option<&crate::model::DataSetImportMode> {
        self.import_mode.as_ref()
    }
    /// <p>The amount of SPICE capacity used by this dataset. This is 0 if the dataset isn't imported into SPICE.</p>
    pub fn consumed_spice_capacity_in_bytes(&self) -> i64 {
        self.consumed_spice_capacity_in_bytes
    }
    /// <p>Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.</p>
    pub fn column_groups(&self) -> std::option::Option<&[crate::model::ColumnGroup]> {
        self.column_groups.as_deref()
    }
    /// <p>The folder that contains fields and nested subfolders for your dataset.</p>
    pub fn field_folders(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::FieldFolder>,
    > {
        self.field_folders.as_ref()
    }
    /// <p>The row-level security configuration for the dataset.</p>
    pub fn row_level_permission_data_set(
        &self,
    ) -> std::option::Option<&crate::model::RowLevelPermissionDataSet> {
        self.row_level_permission_data_set.as_ref()
    }
    /// <p>The element you can use to define tags for row-level security.</p>
    pub fn row_level_permission_tag_configuration(
        &self,
    ) -> std::option::Option<&crate::model::RowLevelPermissionTagConfiguration> {
        self.row_level_permission_tag_configuration.as_ref()
    }
    /// <p>A set of one or more definitions of a <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ColumnLevelPermissionRule.html">ColumnLevelPermissionRule</a> </code>.</p>
    pub fn column_level_permission_rules(
        &self,
    ) -> std::option::Option<&[crate::model::ColumnLevelPermissionRule]> {
        self.column_level_permission_rules.as_deref()
    }
    /// <p>The usage configuration to apply to child datasets that reference this dataset as a source.</p>
    pub fn data_set_usage_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DataSetUsageConfiguration> {
        self.data_set_usage_configuration.as_ref()
    }
}
/// See [`DataSet`](crate::model::DataSet).
pub mod data_set {

    /// A builder for [`DataSet`](crate::model::DataSet).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) data_set_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) physical_table_map: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::PhysicalTable>,
        >,
        pub(crate) logical_table_map: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::LogicalTable>,
        >,
        pub(crate) output_columns: std::option::Option<std::vec::Vec<crate::model::OutputColumn>>,
        pub(crate) import_mode: std::option::Option<crate::model::DataSetImportMode>,
        pub(crate) consumed_spice_capacity_in_bytes: std::option::Option<i64>,
        pub(crate) column_groups: std::option::Option<std::vec::Vec<crate::model::ColumnGroup>>,
        pub(crate) field_folders: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::FieldFolder>,
        >,
        pub(crate) row_level_permission_data_set:
            std::option::Option<crate::model::RowLevelPermissionDataSet>,
        pub(crate) row_level_permission_tag_configuration:
            std::option::Option<crate::model::RowLevelPermissionTagConfiguration>,
        pub(crate) column_level_permission_rules:
            std::option::Option<std::vec::Vec<crate::model::ColumnLevelPermissionRule>>,
        pub(crate) data_set_usage_configuration:
            std::option::Option<crate::model::DataSetUsageConfiguration>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ID of the dataset.</p>
        pub fn data_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_set_id = Some(input.into());
            self
        }
        /// <p>The ID of the dataset.</p>
        pub fn set_data_set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_set_id = input;
            self
        }
        /// <p>A display name for the dataset.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A display name for the dataset.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The time that this dataset was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The time that this dataset was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The last time that this dataset was updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The last time that this dataset was updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// Adds a key-value pair to `physical_table_map`.
        ///
        /// To override the contents of this collection use [`set_physical_table_map`](Self::set_physical_table_map).
        ///
        /// <p>Declares the physical tables that are available in the underlying data sources.</p>
        pub fn physical_table_map(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::PhysicalTable,
        ) -> Self {
            let mut hash_map = self.physical_table_map.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.physical_table_map = Some(hash_map);
            self
        }
        /// <p>Declares the physical tables that are available in the underlying data sources.</p>
        pub fn set_physical_table_map(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::PhysicalTable>,
            >,
        ) -> Self {
            self.physical_table_map = input;
            self
        }
        /// Adds a key-value pair to `logical_table_map`.
        ///
        /// To override the contents of this collection use [`set_logical_table_map`](Self::set_logical_table_map).
        ///
        /// <p>Configures the combination and transformation of the data from the physical tables.</p>
        pub fn logical_table_map(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::LogicalTable,
        ) -> Self {
            let mut hash_map = self.logical_table_map.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.logical_table_map = Some(hash_map);
            self
        }
        /// <p>Configures the combination and transformation of the data from the physical tables.</p>
        pub fn set_logical_table_map(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::LogicalTable>,
            >,
        ) -> Self {
            self.logical_table_map = input;
            self
        }
        /// Appends an item to `output_columns`.
        ///
        /// To override the contents of this collection use [`set_output_columns`](Self::set_output_columns).
        ///
        /// <p>The list of columns after all transforms. These columns are available in templates, analyses, and dashboards.</p>
        pub fn output_columns(mut self, input: crate::model::OutputColumn) -> Self {
            let mut v = self.output_columns.unwrap_or_default();
            v.push(input);
            self.output_columns = Some(v);
            self
        }
        /// <p>The list of columns after all transforms. These columns are available in templates, analyses, and dashboards.</p>
        pub fn set_output_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::OutputColumn>>,
        ) -> Self {
            self.output_columns = input;
            self
        }
        /// <p>A value that indicates whether you want to import the data into SPICE.</p>
        pub fn import_mode(mut self, input: crate::model::DataSetImportMode) -> Self {
            self.import_mode = Some(input);
            self
        }
        /// <p>A value that indicates whether you want to import the data into SPICE.</p>
        pub fn set_import_mode(
            mut self,
            input: std::option::Option<crate::model::DataSetImportMode>,
        ) -> Self {
            self.import_mode = input;
            self
        }
        /// <p>The amount of SPICE capacity used by this dataset. This is 0 if the dataset isn't imported into SPICE.</p>
        pub fn consumed_spice_capacity_in_bytes(mut self, input: i64) -> Self {
            self.consumed_spice_capacity_in_bytes = Some(input);
            self
        }
        /// <p>The amount of SPICE capacity used by this dataset. This is 0 if the dataset isn't imported into SPICE.</p>
        pub fn set_consumed_spice_capacity_in_bytes(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.consumed_spice_capacity_in_bytes = input;
            self
        }
        /// Appends an item to `column_groups`.
        ///
        /// To override the contents of this collection use [`set_column_groups`](Self::set_column_groups).
        ///
        /// <p>Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.</p>
        pub fn column_groups(mut self, input: crate::model::ColumnGroup) -> Self {
            let mut v = self.column_groups.unwrap_or_default();
            v.push(input);
            self.column_groups = Some(v);
            self
        }
        /// <p>Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.</p>
        pub fn set_column_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnGroup>>,
        ) -> Self {
            self.column_groups = input;
            self
        }
        /// Adds a key-value pair to `field_folders`.
        ///
        /// To override the contents of this collection use [`set_field_folders`](Self::set_field_folders).
        ///
        /// <p>The folder that contains fields and nested subfolders for your dataset.</p>
        pub fn field_folders(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::FieldFolder,
        ) -> Self {
            let mut hash_map = self.field_folders.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.field_folders = Some(hash_map);
            self
        }
        /// <p>The folder that contains fields and nested subfolders for your dataset.</p>
        pub fn set_field_folders(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::FieldFolder>,
            >,
        ) -> Self {
            self.field_folders = input;
            self
        }
        /// <p>The row-level security configuration for the dataset.</p>
        pub fn row_level_permission_data_set(
            mut self,
            input: crate::model::RowLevelPermissionDataSet,
        ) -> Self {
            self.row_level_permission_data_set = Some(input);
            self
        }
        /// <p>The row-level security configuration for the dataset.</p>
        pub fn set_row_level_permission_data_set(
            mut self,
            input: std::option::Option<crate::model::RowLevelPermissionDataSet>,
        ) -> Self {
            self.row_level_permission_data_set = input;
            self
        }
        /// <p>The element you can use to define tags for row-level security.</p>
        pub fn row_level_permission_tag_configuration(
            mut self,
            input: crate::model::RowLevelPermissionTagConfiguration,
        ) -> Self {
            self.row_level_permission_tag_configuration = Some(input);
            self
        }
        /// <p>The element you can use to define tags for row-level security.</p>
        pub fn set_row_level_permission_tag_configuration(
            mut self,
            input: std::option::Option<crate::model::RowLevelPermissionTagConfiguration>,
        ) -> Self {
            self.row_level_permission_tag_configuration = input;
            self
        }
        /// Appends an item to `column_level_permission_rules`.
        ///
        /// To override the contents of this collection use [`set_column_level_permission_rules`](Self::set_column_level_permission_rules).
        ///
        /// <p>A set of one or more definitions of a <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ColumnLevelPermissionRule.html">ColumnLevelPermissionRule</a> </code>.</p>
        pub fn column_level_permission_rules(
            mut self,
            input: crate::model::ColumnLevelPermissionRule,
        ) -> Self {
            let mut v = self.column_level_permission_rules.unwrap_or_default();
            v.push(input);
            self.column_level_permission_rules = Some(v);
            self
        }
        /// <p>A set of one or more definitions of a <code> <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ColumnLevelPermissionRule.html">ColumnLevelPermissionRule</a> </code>.</p>
        pub fn set_column_level_permission_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnLevelPermissionRule>>,
        ) -> Self {
            self.column_level_permission_rules = input;
            self
        }
        /// <p>The usage configuration to apply to child datasets that reference this dataset as a source.</p>
        pub fn data_set_usage_configuration(
            mut self,
            input: crate::model::DataSetUsageConfiguration,
        ) -> Self {
            self.data_set_usage_configuration = Some(input);
            self
        }
        /// <p>The usage configuration to apply to child datasets that reference this dataset as a source.</p>
        pub fn set_data_set_usage_configuration(
            mut self,
            input: std::option::Option<crate::model::DataSetUsageConfiguration>,
        ) -> Self {
            self.data_set_usage_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSet`](crate::model::DataSet).
        pub fn build(self) -> crate::model::DataSet {
            crate::model::DataSet {
                arn: self.arn,
                data_set_id: self.data_set_id,
                name: self.name,
                created_time: self.created_time,
                last_updated_time: self.last_updated_time,
                physical_table_map: self.physical_table_map,
                logical_table_map: self.logical_table_map,
                output_columns: self.output_columns,
                import_mode: self.import_mode,
                consumed_spice_capacity_in_bytes: self
                    .consumed_spice_capacity_in_bytes
                    .unwrap_or_default(),
                column_groups: self.column_groups,
                field_folders: self.field_folders,
                row_level_permission_data_set: self.row_level_permission_data_set,
                row_level_permission_tag_configuration: self.row_level_permission_tag_configuration,
                column_level_permission_rules: self.column_level_permission_rules,
                data_set_usage_configuration: self.data_set_usage_configuration,
            }
        }
    }
}
impl DataSet {
    /// Creates a new builder-style object to manufacture [`DataSet`](crate::model::DataSet).
    pub fn builder() -> crate::model::data_set::Builder {
        crate::model::data_set::Builder::default()
    }
}

/// <p>Output column.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OutputColumn {
    /// <p>A display name for the dataset.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A description for a column.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ColumnDataType>,
}
impl OutputColumn {
    /// <p>A display name for the dataset.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A description for a column.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Type.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ColumnDataType> {
        self.r#type.as_ref()
    }
}
/// See [`OutputColumn`](crate::model::OutputColumn).
pub mod output_column {

    /// A builder for [`OutputColumn`](crate::model::OutputColumn).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ColumnDataType>,
    }
    impl Builder {
        /// <p>A display name for the dataset.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A display name for the dataset.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description for a column.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description for a column.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Type.</p>
        pub fn r#type(mut self, input: crate::model::ColumnDataType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Type.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ColumnDataType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputColumn`](crate::model::OutputColumn).
        pub fn build(self) -> crate::model::OutputColumn {
            crate::model::OutputColumn {
                name: self.name,
                description: self.description,
                r#type: self.r#type,
            }
        }
    }
}
impl OutputColumn {
    /// Creates a new builder-style object to manufacture [`OutputColumn`](crate::model::OutputColumn).
    pub fn builder() -> crate::model::output_column::Builder {
        crate::model::output_column::Builder::default()
    }
}

/// <p>Dashboard error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DashboardError {
    /// <p>Type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::DashboardErrorType>,
    /// <p>Message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p></p>
    #[doc(hidden)]
    pub violated_entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
}
impl DashboardError {
    /// <p>Type.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::DashboardErrorType> {
        self.r#type.as_ref()
    }
    /// <p>Message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p></p>
    pub fn violated_entities(&self) -> std::option::Option<&[crate::model::Entity]> {
        self.violated_entities.as_deref()
    }
}
/// See [`DashboardError`](crate::model::DashboardError).
pub mod dashboard_error {

    /// A builder for [`DashboardError`](crate::model::DashboardError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::DashboardErrorType>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) violated_entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
    }
    impl Builder {
        /// <p>Type.</p>
        pub fn r#type(mut self, input: crate::model::DashboardErrorType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Type.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DashboardErrorType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Appends an item to `violated_entities`.
        ///
        /// To override the contents of this collection use [`set_violated_entities`](Self::set_violated_entities).
        ///
        /// <p></p>
        pub fn violated_entities(mut self, input: crate::model::Entity) -> Self {
            let mut v = self.violated_entities.unwrap_or_default();
            v.push(input);
            self.violated_entities = Some(v);
            self
        }
        /// <p></p>
        pub fn set_violated_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        ) -> Self {
            self.violated_entities = input;
            self
        }
        /// Consumes the builder and constructs a [`DashboardError`](crate::model::DashboardError).
        pub fn build(self) -> crate::model::DashboardError {
            crate::model::DashboardError {
                r#type: self.r#type,
                message: self.message,
                violated_entities: self.violated_entities,
            }
        }
    }
}
impl DashboardError {
    /// Creates a new builder-style object to manufacture [`DashboardError`](crate::model::DashboardError).
    pub fn builder() -> crate::model::dashboard_error::Builder {
        crate::model::dashboard_error::Builder::default()
    }
}

/// When writing a match expression against `DashboardErrorType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let dashboarderrortype = unimplemented!();
/// match dashboarderrortype {
///     DashboardErrorType::AccessDenied => { /* ... */ },
///     DashboardErrorType::ColumnGeographicRoleMismatch => { /* ... */ },
///     DashboardErrorType::ColumnReplacementMissing => { /* ... */ },
///     DashboardErrorType::ColumnTypeMismatch => { /* ... */ },
///     DashboardErrorType::DataSetNotFound => { /* ... */ },
///     DashboardErrorType::InternalFailure => { /* ... */ },
///     DashboardErrorType::ParameterNotFound => { /* ... */ },
///     DashboardErrorType::ParameterTypeInvalid => { /* ... */ },
///     DashboardErrorType::ParameterValueIncompatible => { /* ... */ },
///     DashboardErrorType::SourceNotFound => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `dashboarderrortype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DashboardErrorType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DashboardErrorType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DashboardErrorType::NewFeature` is defined.
/// Specifically, when `dashboarderrortype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DashboardErrorType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DashboardErrorType {
    #[allow(missing_docs)] // documentation missing in model
    AccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    ColumnGeographicRoleMismatch,
    #[allow(missing_docs)] // documentation missing in model
    ColumnReplacementMissing,
    #[allow(missing_docs)] // documentation missing in model
    ColumnTypeMismatch,
    #[allow(missing_docs)] // documentation missing in model
    DataSetNotFound,
    #[allow(missing_docs)] // documentation missing in model
    InternalFailure,
    #[allow(missing_docs)] // documentation missing in model
    ParameterNotFound,
    #[allow(missing_docs)] // documentation missing in model
    ParameterTypeInvalid,
    #[allow(missing_docs)] // documentation missing in model
    ParameterValueIncompatible,
    #[allow(missing_docs)] // documentation missing in model
    SourceNotFound,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DashboardErrorType {
    fn from(s: &str) -> Self {
        match s {
            "ACCESS_DENIED" => DashboardErrorType::AccessDenied,
            "COLUMN_GEOGRAPHIC_ROLE_MISMATCH" => DashboardErrorType::ColumnGeographicRoleMismatch,
            "COLUMN_REPLACEMENT_MISSING" => DashboardErrorType::ColumnReplacementMissing,
            "COLUMN_TYPE_MISMATCH" => DashboardErrorType::ColumnTypeMismatch,
            "DATA_SET_NOT_FOUND" => DashboardErrorType::DataSetNotFound,
            "INTERNAL_FAILURE" => DashboardErrorType::InternalFailure,
            "PARAMETER_NOT_FOUND" => DashboardErrorType::ParameterNotFound,
            "PARAMETER_TYPE_INVALID" => DashboardErrorType::ParameterTypeInvalid,
            "PARAMETER_VALUE_INCOMPATIBLE" => DashboardErrorType::ParameterValueIncompatible,
            "SOURCE_NOT_FOUND" => DashboardErrorType::SourceNotFound,
            other => {
                DashboardErrorType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DashboardErrorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DashboardErrorType::from(s))
    }
}
impl DashboardErrorType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DashboardErrorType::AccessDenied => "ACCESS_DENIED",
            DashboardErrorType::ColumnGeographicRoleMismatch => "COLUMN_GEOGRAPHIC_ROLE_MISMATCH",
            DashboardErrorType::ColumnReplacementMissing => "COLUMN_REPLACEMENT_MISSING",
            DashboardErrorType::ColumnTypeMismatch => "COLUMN_TYPE_MISMATCH",
            DashboardErrorType::DataSetNotFound => "DATA_SET_NOT_FOUND",
            DashboardErrorType::InternalFailure => "INTERNAL_FAILURE",
            DashboardErrorType::ParameterNotFound => "PARAMETER_NOT_FOUND",
            DashboardErrorType::ParameterTypeInvalid => "PARAMETER_TYPE_INVALID",
            DashboardErrorType::ParameterValueIncompatible => "PARAMETER_VALUE_INCOMPATIBLE",
            DashboardErrorType::SourceNotFound => "SOURCE_NOT_FOUND",
            DashboardErrorType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACCESS_DENIED",
            "COLUMN_GEOGRAPHIC_ROLE_MISMATCH",
            "COLUMN_REPLACEMENT_MISSING",
            "COLUMN_TYPE_MISMATCH",
            "DATA_SET_NOT_FOUND",
            "INTERNAL_FAILURE",
            "PARAMETER_NOT_FOUND",
            "PARAMETER_TYPE_INVALID",
            "PARAMETER_VALUE_INCOMPATIBLE",
            "SOURCE_NOT_FOUND",
        ]
    }
}
impl AsRef<str> for DashboardErrorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Dashboard.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Dashboard {
    /// <p>Dashboard ID.</p>
    #[doc(hidden)]
    pub dashboard_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>A display name for the dashboard.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Version.</p>
    #[doc(hidden)]
    pub version: std::option::Option<crate::model::DashboardVersion>,
    /// <p>The time that this dashboard was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time that this dashboard was published.</p>
    #[doc(hidden)]
    pub last_published_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time that this dashboard was updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl Dashboard {
    /// <p>Dashboard ID.</p>
    pub fn dashboard_id(&self) -> std::option::Option<&str> {
        self.dashboard_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>A display name for the dashboard.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Version.</p>
    pub fn version(&self) -> std::option::Option<&crate::model::DashboardVersion> {
        self.version.as_ref()
    }
    /// <p>The time that this dashboard was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The last time that this dashboard was published.</p>
    pub fn last_published_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_published_time.as_ref()
    }
    /// <p>The last time that this dashboard was updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
}
/// See [`Dashboard`](crate::model::Dashboard).
pub mod dashboard {

    /// A builder for [`Dashboard`](crate::model::Dashboard).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dashboard_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<crate::model::DashboardVersion>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_published_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Dashboard ID.</p>
        pub fn dashboard_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.dashboard_id = Some(input.into());
            self
        }
        /// <p>Dashboard ID.</p>
        pub fn set_dashboard_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dashboard_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>A display name for the dashboard.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A display name for the dashboard.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Version.</p>
        pub fn version(mut self, input: crate::model::DashboardVersion) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>Version.</p>
        pub fn set_version(
            mut self,
            input: std::option::Option<crate::model::DashboardVersion>,
        ) -> Self {
            self.version = input;
            self
        }
        /// <p>The time that this dashboard was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The time that this dashboard was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The last time that this dashboard was published.</p>
        pub fn last_published_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_published_time = Some(input);
            self
        }
        /// <p>The last time that this dashboard was published.</p>
        pub fn set_last_published_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_published_time = input;
            self
        }
        /// <p>The last time that this dashboard was updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The last time that this dashboard was updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// Consumes the builder and constructs a [`Dashboard`](crate::model::Dashboard).
        pub fn build(self) -> crate::model::Dashboard {
            crate::model::Dashboard {
                dashboard_id: self.dashboard_id,
                arn: self.arn,
                name: self.name,
                version: self.version,
                created_time: self.created_time,
                last_published_time: self.last_published_time,
                last_updated_time: self.last_updated_time,
            }
        }
    }
}
impl Dashboard {
    /// Creates a new builder-style object to manufacture [`Dashboard`](crate::model::Dashboard).
    pub fn builder() -> crate::model::dashboard::Builder {
        crate::model::dashboard::Builder::default()
    }
}

/// <p>Dashboard version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DashboardVersion {
    /// <p>The time that this dashboard version was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Errors associated with this dashboard version.</p>
    #[doc(hidden)]
    pub errors: std::option::Option<std::vec::Vec<crate::model::DashboardError>>,
    /// <p>Version number for this version of the dashboard.</p>
    #[doc(hidden)]
    pub version_number: std::option::Option<i64>,
    /// <p>The HTTP status of the request.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ResourceStatus>,
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Source entity ARN.</p>
    #[doc(hidden)]
    pub source_entity_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Numbers (ARNs) for the datasets that are associated with this version of the dashboard.</p>
    #[doc(hidden)]
    pub data_set_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The ARN of the theme associated with a version of the dashboard.</p>
    #[doc(hidden)]
    pub theme_arn: std::option::Option<std::string::String>,
    /// <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
    #[doc(hidden)]
    pub sheets: std::option::Option<std::vec::Vec<crate::model::Sheet>>,
}
impl DashboardVersion {
    /// <p>The time that this dashboard version was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>Errors associated with this dashboard version.</p>
    pub fn errors(&self) -> std::option::Option<&[crate::model::DashboardError]> {
        self.errors.as_deref()
    }
    /// <p>Version number for this version of the dashboard.</p>
    pub fn version_number(&self) -> std::option::Option<i64> {
        self.version_number
    }
    /// <p>The HTTP status of the request.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ResourceStatus> {
        self.status.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Source entity ARN.</p>
    pub fn source_entity_arn(&self) -> std::option::Option<&str> {
        self.source_entity_arn.as_deref()
    }
    /// <p>The Amazon Resource Numbers (ARNs) for the datasets that are associated with this version of the dashboard.</p>
    pub fn data_set_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.data_set_arns.as_deref()
    }
    /// <p>Description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The ARN of the theme associated with a version of the dashboard.</p>
    pub fn theme_arn(&self) -> std::option::Option<&str> {
        self.theme_arn.as_deref()
    }
    /// <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
    pub fn sheets(&self) -> std::option::Option<&[crate::model::Sheet]> {
        self.sheets.as_deref()
    }
}
/// See [`DashboardVersion`](crate::model::DashboardVersion).
pub mod dashboard_version {

    /// A builder for [`DashboardVersion`](crate::model::DashboardVersion).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) errors: std::option::Option<std::vec::Vec<crate::model::DashboardError>>,
        pub(crate) version_number: std::option::Option<i64>,
        pub(crate) status: std::option::Option<crate::model::ResourceStatus>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) source_entity_arn: std::option::Option<std::string::String>,
        pub(crate) data_set_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) theme_arn: std::option::Option<std::string::String>,
        pub(crate) sheets: std::option::Option<std::vec::Vec<crate::model::Sheet>>,
    }
    impl Builder {
        /// <p>The time that this dashboard version was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The time that this dashboard version was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// Appends an item to `errors`.
        ///
        /// To override the contents of this collection use [`set_errors`](Self::set_errors).
        ///
        /// <p>Errors associated with this dashboard version.</p>
        pub fn errors(mut self, input: crate::model::DashboardError) -> Self {
            let mut v = self.errors.unwrap_or_default();
            v.push(input);
            self.errors = Some(v);
            self
        }
        /// <p>Errors associated with this dashboard version.</p>
        pub fn set_errors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DashboardError>>,
        ) -> Self {
            self.errors = input;
            self
        }
        /// <p>Version number for this version of the dashboard.</p>
        pub fn version_number(mut self, input: i64) -> Self {
            self.version_number = Some(input);
            self
        }
        /// <p>Version number for this version of the dashboard.</p>
        pub fn set_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.version_number = input;
            self
        }
        /// <p>The HTTP status of the request.</p>
        pub fn status(mut self, input: crate::model::ResourceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The HTTP status of the request.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ResourceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Source entity ARN.</p>
        pub fn source_entity_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_entity_arn = Some(input.into());
            self
        }
        /// <p>Source entity ARN.</p>
        pub fn set_source_entity_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_entity_arn = input;
            self
        }
        /// Appends an item to `data_set_arns`.
        ///
        /// To override the contents of this collection use [`set_data_set_arns`](Self::set_data_set_arns).
        ///
        /// <p>The Amazon Resource Numbers (ARNs) for the datasets that are associated with this version of the dashboard.</p>
        pub fn data_set_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.data_set_arns.unwrap_or_default();
            v.push(input.into());
            self.data_set_arns = Some(v);
            self
        }
        /// <p>The Amazon Resource Numbers (ARNs) for the datasets that are associated with this version of the dashboard.</p>
        pub fn set_data_set_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.data_set_arns = input;
            self
        }
        /// <p>Description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ARN of the theme associated with a version of the dashboard.</p>
        pub fn theme_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.theme_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the theme associated with a version of the dashboard.</p>
        pub fn set_theme_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.theme_arn = input;
            self
        }
        /// Appends an item to `sheets`.
        ///
        /// To override the contents of this collection use [`set_sheets`](Self::set_sheets).
        ///
        /// <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
        pub fn sheets(mut self, input: crate::model::Sheet) -> Self {
            let mut v = self.sheets.unwrap_or_default();
            v.push(input);
            self.sheets = Some(v);
            self
        }
        /// <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
        pub fn set_sheets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Sheet>>,
        ) -> Self {
            self.sheets = input;
            self
        }
        /// Consumes the builder and constructs a [`DashboardVersion`](crate::model::DashboardVersion).
        pub fn build(self) -> crate::model::DashboardVersion {
            crate::model::DashboardVersion {
                created_time: self.created_time,
                errors: self.errors,
                version_number: self.version_number,
                status: self.status,
                arn: self.arn,
                source_entity_arn: self.source_entity_arn,
                data_set_arns: self.data_set_arns,
                description: self.description,
                theme_arn: self.theme_arn,
                sheets: self.sheets,
            }
        }
    }
}
impl DashboardVersion {
    /// Creates a new builder-style object to manufacture [`DashboardVersion`](crate::model::DashboardVersion).
    pub fn builder() -> crate::model::dashboard_version::Builder {
        crate::model::dashboard_version::Builder::default()
    }
}

/// <p>Analysis error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AnalysisError {
    /// <p>The type of the analysis error.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::AnalysisErrorType>,
    /// <p>The message associated with the analysis error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p></p>
    #[doc(hidden)]
    pub violated_entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
}
impl AnalysisError {
    /// <p>The type of the analysis error.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::AnalysisErrorType> {
        self.r#type.as_ref()
    }
    /// <p>The message associated with the analysis error.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p></p>
    pub fn violated_entities(&self) -> std::option::Option<&[crate::model::Entity]> {
        self.violated_entities.as_deref()
    }
}
/// See [`AnalysisError`](crate::model::AnalysisError).
pub mod analysis_error {

    /// A builder for [`AnalysisError`](crate::model::AnalysisError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::AnalysisErrorType>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) violated_entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
    }
    impl Builder {
        /// <p>The type of the analysis error.</p>
        pub fn r#type(mut self, input: crate::model::AnalysisErrorType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the analysis error.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::AnalysisErrorType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The message associated with the analysis error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message associated with the analysis error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Appends an item to `violated_entities`.
        ///
        /// To override the contents of this collection use [`set_violated_entities`](Self::set_violated_entities).
        ///
        /// <p></p>
        pub fn violated_entities(mut self, input: crate::model::Entity) -> Self {
            let mut v = self.violated_entities.unwrap_or_default();
            v.push(input);
            self.violated_entities = Some(v);
            self
        }
        /// <p></p>
        pub fn set_violated_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        ) -> Self {
            self.violated_entities = input;
            self
        }
        /// Consumes the builder and constructs a [`AnalysisError`](crate::model::AnalysisError).
        pub fn build(self) -> crate::model::AnalysisError {
            crate::model::AnalysisError {
                r#type: self.r#type,
                message: self.message,
                violated_entities: self.violated_entities,
            }
        }
    }
}
impl AnalysisError {
    /// Creates a new builder-style object to manufacture [`AnalysisError`](crate::model::AnalysisError).
    pub fn builder() -> crate::model::analysis_error::Builder {
        crate::model::analysis_error::Builder::default()
    }
}

/// When writing a match expression against `AnalysisErrorType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let analysiserrortype = unimplemented!();
/// match analysiserrortype {
///     AnalysisErrorType::AccessDenied => { /* ... */ },
///     AnalysisErrorType::ColumnGeographicRoleMismatch => { /* ... */ },
///     AnalysisErrorType::ColumnReplacementMissing => { /* ... */ },
///     AnalysisErrorType::ColumnTypeMismatch => { /* ... */ },
///     AnalysisErrorType::DataSetNotFound => { /* ... */ },
///     AnalysisErrorType::InternalFailure => { /* ... */ },
///     AnalysisErrorType::ParameterNotFound => { /* ... */ },
///     AnalysisErrorType::ParameterTypeInvalid => { /* ... */ },
///     AnalysisErrorType::ParameterValueIncompatible => { /* ... */ },
///     AnalysisErrorType::SourceNotFound => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `analysiserrortype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AnalysisErrorType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AnalysisErrorType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AnalysisErrorType::NewFeature` is defined.
/// Specifically, when `analysiserrortype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AnalysisErrorType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AnalysisErrorType {
    #[allow(missing_docs)] // documentation missing in model
    AccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    ColumnGeographicRoleMismatch,
    #[allow(missing_docs)] // documentation missing in model
    ColumnReplacementMissing,
    #[allow(missing_docs)] // documentation missing in model
    ColumnTypeMismatch,
    #[allow(missing_docs)] // documentation missing in model
    DataSetNotFound,
    #[allow(missing_docs)] // documentation missing in model
    InternalFailure,
    #[allow(missing_docs)] // documentation missing in model
    ParameterNotFound,
    #[allow(missing_docs)] // documentation missing in model
    ParameterTypeInvalid,
    #[allow(missing_docs)] // documentation missing in model
    ParameterValueIncompatible,
    #[allow(missing_docs)] // documentation missing in model
    SourceNotFound,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AnalysisErrorType {
    fn from(s: &str) -> Self {
        match s {
            "ACCESS_DENIED" => AnalysisErrorType::AccessDenied,
            "COLUMN_GEOGRAPHIC_ROLE_MISMATCH" => AnalysisErrorType::ColumnGeographicRoleMismatch,
            "COLUMN_REPLACEMENT_MISSING" => AnalysisErrorType::ColumnReplacementMissing,
            "COLUMN_TYPE_MISMATCH" => AnalysisErrorType::ColumnTypeMismatch,
            "DATA_SET_NOT_FOUND" => AnalysisErrorType::DataSetNotFound,
            "INTERNAL_FAILURE" => AnalysisErrorType::InternalFailure,
            "PARAMETER_NOT_FOUND" => AnalysisErrorType::ParameterNotFound,
            "PARAMETER_TYPE_INVALID" => AnalysisErrorType::ParameterTypeInvalid,
            "PARAMETER_VALUE_INCOMPATIBLE" => AnalysisErrorType::ParameterValueIncompatible,
            "SOURCE_NOT_FOUND" => AnalysisErrorType::SourceNotFound,
            other => {
                AnalysisErrorType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for AnalysisErrorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AnalysisErrorType::from(s))
    }
}
impl AnalysisErrorType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AnalysisErrorType::AccessDenied => "ACCESS_DENIED",
            AnalysisErrorType::ColumnGeographicRoleMismatch => "COLUMN_GEOGRAPHIC_ROLE_MISMATCH",
            AnalysisErrorType::ColumnReplacementMissing => "COLUMN_REPLACEMENT_MISSING",
            AnalysisErrorType::ColumnTypeMismatch => "COLUMN_TYPE_MISMATCH",
            AnalysisErrorType::DataSetNotFound => "DATA_SET_NOT_FOUND",
            AnalysisErrorType::InternalFailure => "INTERNAL_FAILURE",
            AnalysisErrorType::ParameterNotFound => "PARAMETER_NOT_FOUND",
            AnalysisErrorType::ParameterTypeInvalid => "PARAMETER_TYPE_INVALID",
            AnalysisErrorType::ParameterValueIncompatible => "PARAMETER_VALUE_INCOMPATIBLE",
            AnalysisErrorType::SourceNotFound => "SOURCE_NOT_FOUND",
            AnalysisErrorType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACCESS_DENIED",
            "COLUMN_GEOGRAPHIC_ROLE_MISMATCH",
            "COLUMN_REPLACEMENT_MISSING",
            "COLUMN_TYPE_MISMATCH",
            "DATA_SET_NOT_FOUND",
            "INTERNAL_FAILURE",
            "PARAMETER_NOT_FOUND",
            "PARAMETER_TYPE_INVALID",
            "PARAMETER_VALUE_INCOMPATIBLE",
            "SOURCE_NOT_FOUND",
        ]
    }
}
impl AsRef<str> for AnalysisErrorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Metadata structure for an analysis in Amazon QuickSight</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Analysis {
    /// <p>The ID of the analysis.</p>
    #[doc(hidden)]
    pub analysis_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the analysis.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The descriptive name of the analysis.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Status associated with the analysis.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ResourceStatus>,
    /// <p>Errors associated with the analysis.</p>
    #[doc(hidden)]
    pub errors: std::option::Option<std::vec::Vec<crate::model::AnalysisError>>,
    /// <p>The ARNs of the datasets of the analysis.</p>
    #[doc(hidden)]
    pub data_set_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ARN of the theme of the analysis.</p>
    #[doc(hidden)]
    pub theme_arn: std::option::Option<std::string::String>,
    /// <p>The time that the analysis was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the analysis was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
    #[doc(hidden)]
    pub sheets: std::option::Option<std::vec::Vec<crate::model::Sheet>>,
}
impl Analysis {
    /// <p>The ID of the analysis.</p>
    pub fn analysis_id(&self) -> std::option::Option<&str> {
        self.analysis_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the analysis.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The descriptive name of the analysis.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Status associated with the analysis.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ResourceStatus> {
        self.status.as_ref()
    }
    /// <p>Errors associated with the analysis.</p>
    pub fn errors(&self) -> std::option::Option<&[crate::model::AnalysisError]> {
        self.errors.as_deref()
    }
    /// <p>The ARNs of the datasets of the analysis.</p>
    pub fn data_set_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.data_set_arns.as_deref()
    }
    /// <p>The ARN of the theme of the analysis.</p>
    pub fn theme_arn(&self) -> std::option::Option<&str> {
        self.theme_arn.as_deref()
    }
    /// <p>The time that the analysis was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The time that the analysis was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
    /// <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
    pub fn sheets(&self) -> std::option::Option<&[crate::model::Sheet]> {
        self.sheets.as_deref()
    }
}
/// See [`Analysis`](crate::model::Analysis).
pub mod analysis {

    /// A builder for [`Analysis`](crate::model::Analysis).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) analysis_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ResourceStatus>,
        pub(crate) errors: std::option::Option<std::vec::Vec<crate::model::AnalysisError>>,
        pub(crate) data_set_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) theme_arn: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) sheets: std::option::Option<std::vec::Vec<crate::model::Sheet>>,
    }
    impl Builder {
        /// <p>The ID of the analysis.</p>
        pub fn analysis_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.analysis_id = Some(input.into());
            self
        }
        /// <p>The ID of the analysis.</p>
        pub fn set_analysis_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.analysis_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the analysis.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the analysis.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The descriptive name of the analysis.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The descriptive name of the analysis.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Status associated with the analysis.</p>
        pub fn status(mut self, input: crate::model::ResourceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Status associated with the analysis.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ResourceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `errors`.
        ///
        /// To override the contents of this collection use [`set_errors`](Self::set_errors).
        ///
        /// <p>Errors associated with the analysis.</p>
        pub fn errors(mut self, input: crate::model::AnalysisError) -> Self {
            let mut v = self.errors.unwrap_or_default();
            v.push(input);
            self.errors = Some(v);
            self
        }
        /// <p>Errors associated with the analysis.</p>
        pub fn set_errors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AnalysisError>>,
        ) -> Self {
            self.errors = input;
            self
        }
        /// Appends an item to `data_set_arns`.
        ///
        /// To override the contents of this collection use [`set_data_set_arns`](Self::set_data_set_arns).
        ///
        /// <p>The ARNs of the datasets of the analysis.</p>
        pub fn data_set_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.data_set_arns.unwrap_or_default();
            v.push(input.into());
            self.data_set_arns = Some(v);
            self
        }
        /// <p>The ARNs of the datasets of the analysis.</p>
        pub fn set_data_set_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.data_set_arns = input;
            self
        }
        /// <p>The ARN of the theme of the analysis.</p>
        pub fn theme_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.theme_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the theme of the analysis.</p>
        pub fn set_theme_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.theme_arn = input;
            self
        }
        /// <p>The time that the analysis was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The time that the analysis was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The time that the analysis was last updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The time that the analysis was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// Appends an item to `sheets`.
        ///
        /// To override the contents of this collection use [`set_sheets`](Self::set_sheets).
        ///
        /// <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
        pub fn sheets(mut self, input: crate::model::Sheet) -> Self {
            let mut v = self.sheets.unwrap_or_default();
            v.push(input);
            self.sheets = Some(v);
            self
        }
        /// <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
        pub fn set_sheets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Sheet>>,
        ) -> Self {
            self.sheets = input;
            self
        }
        /// Consumes the builder and constructs a [`Analysis`](crate::model::Analysis).
        pub fn build(self) -> crate::model::Analysis {
            crate::model::Analysis {
                analysis_id: self.analysis_id,
                arn: self.arn,
                name: self.name,
                status: self.status,
                errors: self.errors,
                data_set_arns: self.data_set_arns,
                theme_arn: self.theme_arn,
                created_time: self.created_time,
                last_updated_time: self.last_updated_time,
                sheets: self.sheets,
            }
        }
    }
}
impl Analysis {
    /// Creates a new builder-style object to manufacture [`Analysis`](crate::model::Analysis).
    pub fn builder() -> crate::model::analysis::Builder {
        crate::model::analysis::Builder::default()
    }
}

/// <p>A structure that contains the following account information elements:</p>
/// <ul>
/// <li> <p>Your Amazon QuickSight account name.</p> </li>
/// <li> <p>The edition of Amazon QuickSight that your account is using.</p> </li>
/// <li> <p>The notification email address that is associated with the Amazon QuickSight account. </p> </li>
/// <li> <p>The authentication type of the Amazon QuickSight account.</p> </li>
/// <li> <p>The status of the Amazon QuickSight account's subscription.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccountInfo {
    /// <p>The account name that you provided for the Amazon QuickSight subscription in your Amazon Web Services account. You create this name when you sign up for Amazon QuickSight. It's unique over all of Amazon Web Services, and it appears only when users sign in.</p>
    #[doc(hidden)]
    pub account_name: std::option::Option<std::string::String>,
    /// <p>The edition of your Amazon QuickSight account.</p>
    #[doc(hidden)]
    pub edition: std::option::Option<crate::model::Edition>,
    /// <p>The email address that will be used for Amazon QuickSight to send notifications regarding your Amazon Web Services account or Amazon QuickSight subscription.</p>
    #[doc(hidden)]
    pub notification_email: std::option::Option<std::string::String>,
    /// <p>The way that your Amazon QuickSight account is authenticated.</p>
    #[doc(hidden)]
    pub authentication_type: std::option::Option<std::string::String>,
    /// <p>The status of your account subscription.</p>
    #[doc(hidden)]
    pub account_subscription_status: std::option::Option<std::string::String>,
}
impl AccountInfo {
    /// <p>The account name that you provided for the Amazon QuickSight subscription in your Amazon Web Services account. You create this name when you sign up for Amazon QuickSight. It's unique over all of Amazon Web Services, and it appears only when users sign in.</p>
    pub fn account_name(&self) -> std::option::Option<&str> {
        self.account_name.as_deref()
    }
    /// <p>The edition of your Amazon QuickSight account.</p>
    pub fn edition(&self) -> std::option::Option<&crate::model::Edition> {
        self.edition.as_ref()
    }
    /// <p>The email address that will be used for Amazon QuickSight to send notifications regarding your Amazon Web Services account or Amazon QuickSight subscription.</p>
    pub fn notification_email(&self) -> std::option::Option<&str> {
        self.notification_email.as_deref()
    }
    /// <p>The way that your Amazon QuickSight account is authenticated.</p>
    pub fn authentication_type(&self) -> std::option::Option<&str> {
        self.authentication_type.as_deref()
    }
    /// <p>The status of your account subscription.</p>
    pub fn account_subscription_status(&self) -> std::option::Option<&str> {
        self.account_subscription_status.as_deref()
    }
}
/// See [`AccountInfo`](crate::model::AccountInfo).
pub mod account_info {

    /// A builder for [`AccountInfo`](crate::model::AccountInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_name: std::option::Option<std::string::String>,
        pub(crate) edition: std::option::Option<crate::model::Edition>,
        pub(crate) notification_email: std::option::Option<std::string::String>,
        pub(crate) authentication_type: std::option::Option<std::string::String>,
        pub(crate) account_subscription_status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The account name that you provided for the Amazon QuickSight subscription in your Amazon Web Services account. You create this name when you sign up for Amazon QuickSight. It's unique over all of Amazon Web Services, and it appears only when users sign in.</p>
        pub fn account_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_name = Some(input.into());
            self
        }
        /// <p>The account name that you provided for the Amazon QuickSight subscription in your Amazon Web Services account. You create this name when you sign up for Amazon QuickSight. It's unique over all of Amazon Web Services, and it appears only when users sign in.</p>
        pub fn set_account_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_name = input;
            self
        }
        /// <p>The edition of your Amazon QuickSight account.</p>
        pub fn edition(mut self, input: crate::model::Edition) -> Self {
            self.edition = Some(input);
            self
        }
        /// <p>The edition of your Amazon QuickSight account.</p>
        pub fn set_edition(mut self, input: std::option::Option<crate::model::Edition>) -> Self {
            self.edition = input;
            self
        }
        /// <p>The email address that will be used for Amazon QuickSight to send notifications regarding your Amazon Web Services account or Amazon QuickSight subscription.</p>
        pub fn notification_email(mut self, input: impl Into<std::string::String>) -> Self {
            self.notification_email = Some(input.into());
            self
        }
        /// <p>The email address that will be used for Amazon QuickSight to send notifications regarding your Amazon Web Services account or Amazon QuickSight subscription.</p>
        pub fn set_notification_email(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notification_email = input;
            self
        }
        /// <p>The way that your Amazon QuickSight account is authenticated.</p>
        pub fn authentication_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.authentication_type = Some(input.into());
            self
        }
        /// <p>The way that your Amazon QuickSight account is authenticated.</p>
        pub fn set_authentication_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authentication_type = input;
            self
        }
        /// <p>The status of your account subscription.</p>
        pub fn account_subscription_status(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.account_subscription_status = Some(input.into());
            self
        }
        /// <p>The status of your account subscription.</p>
        pub fn set_account_subscription_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.account_subscription_status = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountInfo`](crate::model::AccountInfo).
        pub fn build(self) -> crate::model::AccountInfo {
            crate::model::AccountInfo {
                account_name: self.account_name,
                edition: self.edition,
                notification_email: self.notification_email,
                authentication_type: self.authentication_type,
                account_subscription_status: self.account_subscription_status,
            }
        }
    }
}
impl AccountInfo {
    /// Creates a new builder-style object to manufacture [`AccountInfo`](crate::model::AccountInfo).
    pub fn builder() -> crate::model::account_info::Builder {
        crate::model::account_info::Builder::default()
    }
}

/// When writing a match expression against `Edition`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let edition = unimplemented!();
/// match edition {
///     Edition::Enterprise => { /* ... */ },
///     Edition::EnterpriseAndQ => { /* ... */ },
///     Edition::Standard => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `edition` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Edition::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Edition::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Edition::NewFeature` is defined.
/// Specifically, when `edition` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Edition::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Edition {
    #[allow(missing_docs)] // documentation missing in model
    Enterprise,
    #[allow(missing_docs)] // documentation missing in model
    EnterpriseAndQ,
    #[allow(missing_docs)] // documentation missing in model
    Standard,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Edition {
    fn from(s: &str) -> Self {
        match s {
            "ENTERPRISE" => Edition::Enterprise,
            "ENTERPRISE_AND_Q" => Edition::EnterpriseAndQ,
            "STANDARD" => Edition::Standard,
            other => Edition::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Edition {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Edition::from(s))
    }
}
impl Edition {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Edition::Enterprise => "ENTERPRISE",
            Edition::EnterpriseAndQ => "ENTERPRISE_AND_Q",
            Edition::Standard => "STANDARD",
            Edition::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ENTERPRISE", "ENTERPRISE_AND_Q", "STANDARD"]
    }
}
impl AsRef<str> for Edition {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The Amazon QuickSight settings associated with your Amazon Web Services account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccountSettings {
    /// <p>The "account name" you provided for the Amazon QuickSight subscription in your Amazon Web Services account. You create this name when you sign up for Amazon QuickSight. It is unique in all of Amazon Web Services and it appears only when users sign in.</p>
    #[doc(hidden)]
    pub account_name: std::option::Option<std::string::String>,
    /// <p>The edition of Amazon QuickSight that you're currently subscribed to: Enterprise edition or Standard edition.</p>
    #[doc(hidden)]
    pub edition: std::option::Option<crate::model::Edition>,
    /// <p>The default Amazon QuickSight namespace for your Amazon Web Services account. </p>
    #[doc(hidden)]
    pub default_namespace: std::option::Option<std::string::String>,
    /// <p>The main notification email for your Amazon QuickSight subscription.</p>
    #[doc(hidden)]
    pub notification_email: std::option::Option<std::string::String>,
    /// <p>A Boolean value that indicates whether public sharing is turned on for an Amazon QuickSight account. For more information about turning on public sharing, see <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdatePublicSharingSettings.html">UpdatePublicSharingSettings</a>.</p>
    #[doc(hidden)]
    pub public_sharing_enabled: bool,
    /// <p>A boolean value that determines whether or not an Amazon QuickSight account can be deleted. A <code>True</code> value doesn't allow the account to be deleted and results in an error message if a user tries to make a <code>DeleteAccountSubsctiption</code> request. A <code>False</code> value will allow the ccount to be deleted. </p>
    #[doc(hidden)]
    pub termination_protection_enabled: bool,
}
impl AccountSettings {
    /// <p>The "account name" you provided for the Amazon QuickSight subscription in your Amazon Web Services account. You create this name when you sign up for Amazon QuickSight. It is unique in all of Amazon Web Services and it appears only when users sign in.</p>
    pub fn account_name(&self) -> std::option::Option<&str> {
        self.account_name.as_deref()
    }
    /// <p>The edition of Amazon QuickSight that you're currently subscribed to: Enterprise edition or Standard edition.</p>
    pub fn edition(&self) -> std::option::Option<&crate::model::Edition> {
        self.edition.as_ref()
    }
    /// <p>The default Amazon QuickSight namespace for your Amazon Web Services account. </p>
    pub fn default_namespace(&self) -> std::option::Option<&str> {
        self.default_namespace.as_deref()
    }
    /// <p>The main notification email for your Amazon QuickSight subscription.</p>
    pub fn notification_email(&self) -> std::option::Option<&str> {
        self.notification_email.as_deref()
    }
    /// <p>A Boolean value that indicates whether public sharing is turned on for an Amazon QuickSight account. For more information about turning on public sharing, see <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdatePublicSharingSettings.html">UpdatePublicSharingSettings</a>.</p>
    pub fn public_sharing_enabled(&self) -> bool {
        self.public_sharing_enabled
    }
    /// <p>A boolean value that determines whether or not an Amazon QuickSight account can be deleted. A <code>True</code> value doesn't allow the account to be deleted and results in an error message if a user tries to make a <code>DeleteAccountSubsctiption</code> request. A <code>False</code> value will allow the ccount to be deleted. </p>
    pub fn termination_protection_enabled(&self) -> bool {
        self.termination_protection_enabled
    }
}
/// See [`AccountSettings`](crate::model::AccountSettings).
pub mod account_settings {

    /// A builder for [`AccountSettings`](crate::model::AccountSettings).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_name: std::option::Option<std::string::String>,
        pub(crate) edition: std::option::Option<crate::model::Edition>,
        pub(crate) default_namespace: std::option::Option<std::string::String>,
        pub(crate) notification_email: std::option::Option<std::string::String>,
        pub(crate) public_sharing_enabled: std::option::Option<bool>,
        pub(crate) termination_protection_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The "account name" you provided for the Amazon QuickSight subscription in your Amazon Web Services account. You create this name when you sign up for Amazon QuickSight. It is unique in all of Amazon Web Services and it appears only when users sign in.</p>
        pub fn account_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_name = Some(input.into());
            self
        }
        /// <p>The "account name" you provided for the Amazon QuickSight subscription in your Amazon Web Services account. You create this name when you sign up for Amazon QuickSight. It is unique in all of Amazon Web Services and it appears only when users sign in.</p>
        pub fn set_account_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_name = input;
            self
        }
        /// <p>The edition of Amazon QuickSight that you're currently subscribed to: Enterprise edition or Standard edition.</p>
        pub fn edition(mut self, input: crate::model::Edition) -> Self {
            self.edition = Some(input);
            self
        }
        /// <p>The edition of Amazon QuickSight that you're currently subscribed to: Enterprise edition or Standard edition.</p>
        pub fn set_edition(mut self, input: std::option::Option<crate::model::Edition>) -> Self {
            self.edition = input;
            self
        }
        /// <p>The default Amazon QuickSight namespace for your Amazon Web Services account. </p>
        pub fn default_namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_namespace = Some(input.into());
            self
        }
        /// <p>The default Amazon QuickSight namespace for your Amazon Web Services account. </p>
        pub fn set_default_namespace(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_namespace = input;
            self
        }
        /// <p>The main notification email for your Amazon QuickSight subscription.</p>
        pub fn notification_email(mut self, input: impl Into<std::string::String>) -> Self {
            self.notification_email = Some(input.into());
            self
        }
        /// <p>The main notification email for your Amazon QuickSight subscription.</p>
        pub fn set_notification_email(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notification_email = input;
            self
        }
        /// <p>A Boolean value that indicates whether public sharing is turned on for an Amazon QuickSight account. For more information about turning on public sharing, see <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdatePublicSharingSettings.html">UpdatePublicSharingSettings</a>.</p>
        pub fn public_sharing_enabled(mut self, input: bool) -> Self {
            self.public_sharing_enabled = Some(input);
            self
        }
        /// <p>A Boolean value that indicates whether public sharing is turned on for an Amazon QuickSight account. For more information about turning on public sharing, see <a href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdatePublicSharingSettings.html">UpdatePublicSharingSettings</a>.</p>
        pub fn set_public_sharing_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.public_sharing_enabled = input;
            self
        }
        /// <p>A boolean value that determines whether or not an Amazon QuickSight account can be deleted. A <code>True</code> value doesn't allow the account to be deleted and results in an error message if a user tries to make a <code>DeleteAccountSubsctiption</code> request. A <code>False</code> value will allow the ccount to be deleted. </p>
        pub fn termination_protection_enabled(mut self, input: bool) -> Self {
            self.termination_protection_enabled = Some(input);
            self
        }
        /// <p>A boolean value that determines whether or not an Amazon QuickSight account can be deleted. A <code>True</code> value doesn't allow the account to be deleted and results in an error message if a user tries to make a <code>DeleteAccountSubsctiption</code> request. A <code>False</code> value will allow the ccount to be deleted. </p>
        pub fn set_termination_protection_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.termination_protection_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountSettings`](crate::model::AccountSettings).
        pub fn build(self) -> crate::model::AccountSettings {
            crate::model::AccountSettings {
                account_name: self.account_name,
                edition: self.edition,
                default_namespace: self.default_namespace,
                notification_email: self.notification_email,
                public_sharing_enabled: self.public_sharing_enabled.unwrap_or_default(),
                termination_protection_enabled: self
                    .termination_protection_enabled
                    .unwrap_or_default(),
            }
        }
    }
}
impl AccountSettings {
    /// Creates a new builder-style object to manufacture [`AccountSettings`](crate::model::AccountSettings).
    pub fn builder() -> crate::model::account_settings::Builder {
        crate::model::account_settings::Builder::default()
    }
}

/// When writing a match expression against `MemberType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let membertype = unimplemented!();
/// match membertype {
///     MemberType::Analysis => { /* ... */ },
///     MemberType::Dashboard => { /* ... */ },
///     MemberType::Dataset => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `membertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MemberType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MemberType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MemberType::NewFeature` is defined.
/// Specifically, when `membertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MemberType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MemberType {
    #[allow(missing_docs)] // documentation missing in model
    Analysis,
    #[allow(missing_docs)] // documentation missing in model
    Dashboard,
    #[allow(missing_docs)] // documentation missing in model
    Dataset,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MemberType {
    fn from(s: &str) -> Self {
        match s {
            "ANALYSIS" => MemberType::Analysis,
            "DASHBOARD" => MemberType::Dashboard,
            "DATASET" => MemberType::Dataset,
            other => MemberType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for MemberType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MemberType::from(s))
    }
}
impl MemberType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MemberType::Analysis => "ANALYSIS",
            MemberType::Dashboard => "DASHBOARD",
            MemberType::Dataset => "DATASET",
            MemberType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ANALYSIS", "DASHBOARD", "DATASET"]
    }
}
impl AsRef<str> for MemberType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `IngestionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let ingestiontype = unimplemented!();
/// match ingestiontype {
///     IngestionType::FullRefresh => { /* ... */ },
///     IngestionType::IncrementalRefresh => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ingestiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `IngestionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `IngestionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `IngestionType::NewFeature` is defined.
/// Specifically, when `ingestiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `IngestionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// This defines the type of ingestion user wants to trigger. This is part of create ingestion request.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IngestionType {
    #[allow(missing_docs)] // documentation missing in model
    FullRefresh,
    #[allow(missing_docs)] // documentation missing in model
    IncrementalRefresh,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for IngestionType {
    fn from(s: &str) -> Self {
        match s {
            "FULL_REFRESH" => IngestionType::FullRefresh,
            "INCREMENTAL_REFRESH" => IngestionType::IncrementalRefresh,
            other => IngestionType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for IngestionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IngestionType::from(s))
    }
}
impl IngestionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            IngestionType::FullRefresh => "FULL_REFRESH",
            IngestionType::IncrementalRefresh => "INCREMENTAL_REFRESH",
            IngestionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FULL_REFRESH", "INCREMENTAL_REFRESH"]
    }
}
impl AsRef<str> for IngestionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An asset in a Amazon QuickSight folder, such as a dashboard, analysis, or dataset.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FolderMember {
    /// <p>The ID of an asset in the folder.</p>
    #[doc(hidden)]
    pub member_id: std::option::Option<std::string::String>,
    /// <p>The type of asset that it is.</p>
    #[doc(hidden)]
    pub member_type: std::option::Option<crate::model::MemberType>,
}
impl FolderMember {
    /// <p>The ID of an asset in the folder.</p>
    pub fn member_id(&self) -> std::option::Option<&str> {
        self.member_id.as_deref()
    }
    /// <p>The type of asset that it is.</p>
    pub fn member_type(&self) -> std::option::Option<&crate::model::MemberType> {
        self.member_type.as_ref()
    }
}
/// See [`FolderMember`](crate::model::FolderMember).
pub mod folder_member {

    /// A builder for [`FolderMember`](crate::model::FolderMember).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) member_id: std::option::Option<std::string::String>,
        pub(crate) member_type: std::option::Option<crate::model::MemberType>,
    }
    impl Builder {
        /// <p>The ID of an asset in the folder.</p>
        pub fn member_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_id = Some(input.into());
            self
        }
        /// <p>The ID of an asset in the folder.</p>
        pub fn set_member_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_id = input;
            self
        }
        /// <p>The type of asset that it is.</p>
        pub fn member_type(mut self, input: crate::model::MemberType) -> Self {
            self.member_type = Some(input);
            self
        }
        /// <p>The type of asset that it is.</p>
        pub fn set_member_type(
            mut self,
            input: std::option::Option<crate::model::MemberType>,
        ) -> Self {
            self.member_type = input;
            self
        }
        /// Consumes the builder and constructs a [`FolderMember`](crate::model::FolderMember).
        pub fn build(self) -> crate::model::FolderMember {
            crate::model::FolderMember {
                member_id: self.member_id,
                member_type: self.member_type,
            }
        }
    }
}
impl FolderMember {
    /// Creates a new builder-style object to manufacture [`FolderMember`](crate::model::FolderMember).
    pub fn builder() -> crate::model::folder_member::Builder {
        crate::model::folder_member::Builder::default()
    }
}

/// <p>A <code>SignupResponse</code> object that contains a summary of a newly created account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SignupResponse {
    /// <p>A Boolean that is <code>TRUE</code> if the Amazon QuickSight uses IAM as an authentication method.</p>
    #[doc(hidden)]
    pub iam_user: bool,
    /// <p>The user login name for your Amazon QuickSight account.</p>
    #[doc(hidden)]
    pub user_login_name: std::option::Option<std::string::String>,
    /// <p>The name of your Amazon QuickSight account.</p>
    #[doc(hidden)]
    pub account_name: std::option::Option<std::string::String>,
    /// <p>The type of Active Directory that is being used to authenticate the Amazon QuickSight account. Valid values are <code>SIMPLE_AD</code>, <code>AD_CONNECTOR</code>, and <code>MICROSOFT_AD</code>.</p>
    #[doc(hidden)]
    pub directory_type: std::option::Option<std::string::String>,
}
impl SignupResponse {
    /// <p>A Boolean that is <code>TRUE</code> if the Amazon QuickSight uses IAM as an authentication method.</p>
    pub fn iam_user(&self) -> bool {
        self.iam_user
    }
    /// <p>The user login name for your Amazon QuickSight account.</p>
    pub fn user_login_name(&self) -> std::option::Option<&str> {
        self.user_login_name.as_deref()
    }
    /// <p>The name of your Amazon QuickSight account.</p>
    pub fn account_name(&self) -> std::option::Option<&str> {
        self.account_name.as_deref()
    }
    /// <p>The type of Active Directory that is being used to authenticate the Amazon QuickSight account. Valid values are <code>SIMPLE_AD</code>, <code>AD_CONNECTOR</code>, and <code>MICROSOFT_AD</code>.</p>
    pub fn directory_type(&self) -> std::option::Option<&str> {
        self.directory_type.as_deref()
    }
}
/// See [`SignupResponse`](crate::model::SignupResponse).
pub mod signup_response {

    /// A builder for [`SignupResponse`](crate::model::SignupResponse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) iam_user: std::option::Option<bool>,
        pub(crate) user_login_name: std::option::Option<std::string::String>,
        pub(crate) account_name: std::option::Option<std::string::String>,
        pub(crate) directory_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A Boolean that is <code>TRUE</code> if the Amazon QuickSight uses IAM as an authentication method.</p>
        pub fn iam_user(mut self, input: bool) -> Self {
            self.iam_user = Some(input);
            self
        }
        /// <p>A Boolean that is <code>TRUE</code> if the Amazon QuickSight uses IAM as an authentication method.</p>
        pub fn set_iam_user(mut self, input: std::option::Option<bool>) -> Self {
            self.iam_user = input;
            self
        }
        /// <p>The user login name for your Amazon QuickSight account.</p>
        pub fn user_login_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_login_name = Some(input.into());
            self
        }
        /// <p>The user login name for your Amazon QuickSight account.</p>
        pub fn set_user_login_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_login_name = input;
            self
        }
        /// <p>The name of your Amazon QuickSight account.</p>
        pub fn account_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_name = Some(input.into());
            self
        }
        /// <p>The name of your Amazon QuickSight account.</p>
        pub fn set_account_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_name = input;
            self
        }
        /// <p>The type of Active Directory that is being used to authenticate the Amazon QuickSight account. Valid values are <code>SIMPLE_AD</code>, <code>AD_CONNECTOR</code>, and <code>MICROSOFT_AD</code>.</p>
        pub fn directory_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_type = Some(input.into());
            self
        }
        /// <p>The type of Active Directory that is being used to authenticate the Amazon QuickSight account. Valid values are <code>SIMPLE_AD</code>, <code>AD_CONNECTOR</code>, and <code>MICROSOFT_AD</code>.</p>
        pub fn set_directory_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.directory_type = input;
            self
        }
        /// Consumes the builder and constructs a [`SignupResponse`](crate::model::SignupResponse).
        pub fn build(self) -> crate::model::SignupResponse {
            crate::model::SignupResponse {
                iam_user: self.iam_user.unwrap_or_default(),
                user_login_name: self.user_login_name,
                account_name: self.account_name,
                directory_type: self.directory_type,
            }
        }
    }
}
impl SignupResponse {
    /// Creates a new builder-style object to manufacture [`SignupResponse`](crate::model::SignupResponse).
    pub fn builder() -> crate::model::signup_response::Builder {
        crate::model::signup_response::Builder::default()
    }
}

/// When writing a match expression against `AuthenticationMethodOption`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let authenticationmethodoption = unimplemented!();
/// match authenticationmethodoption {
///     AuthenticationMethodOption::ActiveDirectory => { /* ... */ },
///     AuthenticationMethodOption::IamAndQuicksight => { /* ... */ },
///     AuthenticationMethodOption::IamOnly => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `authenticationmethodoption` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AuthenticationMethodOption::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AuthenticationMethodOption::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AuthenticationMethodOption::NewFeature` is defined.
/// Specifically, when `authenticationmethodoption` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AuthenticationMethodOption::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AuthenticationMethodOption {
    #[allow(missing_docs)] // documentation missing in model
    ActiveDirectory,
    #[allow(missing_docs)] // documentation missing in model
    IamAndQuicksight,
    #[allow(missing_docs)] // documentation missing in model
    IamOnly,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AuthenticationMethodOption {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE_DIRECTORY" => AuthenticationMethodOption::ActiveDirectory,
            "IAM_AND_QUICKSIGHT" => AuthenticationMethodOption::IamAndQuicksight,
            "IAM_ONLY" => AuthenticationMethodOption::IamOnly,
            other => AuthenticationMethodOption::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for AuthenticationMethodOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AuthenticationMethodOption::from(s))
    }
}
impl AuthenticationMethodOption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AuthenticationMethodOption::ActiveDirectory => "ACTIVE_DIRECTORY",
            AuthenticationMethodOption::IamAndQuicksight => "IAM_AND_QUICKSIGHT",
            AuthenticationMethodOption::IamOnly => "IAM_ONLY",
            AuthenticationMethodOption::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE_DIRECTORY", "IAM_AND_QUICKSIGHT", "IAM_ONLY"]
    }
}
impl AsRef<str> for AuthenticationMethodOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
