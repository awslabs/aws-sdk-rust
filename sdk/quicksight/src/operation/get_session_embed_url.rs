// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

impl GetSessionEmbedUrlInput {
    /// Consumes the builder and constructs an Operation<[`GetSessionEmbedUrl`](crate::operation::get_session_embed_url::GetSessionEmbedUrl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::get_session_embed_url::GetSessionEmbedUrl,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::operation::get_session_embed_url::GetSessionEmbedUrlInput,
                output: &mut String,
            ) -> std::result::Result<(), aws_smithy_http::operation::error::BuildError>
            {
                let input_1 = &_input.aws_account_id;
                let input_1 = input_1.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "aws_account_id",
                        "cannot be empty or unset",
                    )
                })?;
                let aws_account_id = aws_smithy_http::label::fmt_string(
                    input_1,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if aws_account_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "aws_account_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/accounts/{AwsAccountId}/session-embed-url",
                    AwsAccountId = aws_account_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::operation::get_session_embed_url::GetSessionEmbedUrlInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_2) = &_input.entry_point {
                    {
                        query.push_kv("entry-point", &aws_smithy_http::query::fmt_string(&inner_2));
                    }
                }
                if let Some(inner_3) = &_input.session_lifetime_in_minutes {
                    if *inner_3 != 0 {
                        query.push_kv(
                            "session-lifetime",
                            aws_smithy_types::primitive::Encoder::from(*inner_3).encode(),
                        );
                    }
                }
                if let Some(inner_4) = &_input.user_arn {
                    {
                        query.push_kv("user-arn", &aws_smithy_http::query::fmt_string(&inner_4));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::operation::get_session_embed_url::GetSessionEmbedUrlInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::meta::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::get_session_embed_url::GetSessionEmbedUrl::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetSessionEmbedUrl",
            "quicksight",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}
/// `ParseStrictResponse` impl for `GetSessionEmbedUrl`.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
#[non_exhaustive]
#[doc(hidden)]
pub struct GetSessionEmbedUrl;
impl GetSessionEmbedUrl {
    #[doc(hidden)]
    pub fn new() -> Self {
        Self
    }
}
impl aws_smithy_http::response::ParseStrictResponse for GetSessionEmbedUrl {
    type Output = std::result::Result<
        crate::operation::get_session_embed_url::GetSessionEmbedUrlOutput,
        crate::operation::get_session_embed_url::GetSessionEmbedUrlError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::protocol_serde::shape_get_session_embed_url::de_get_session_embed_url_http_error(
                response,
            )
        } else {
            crate::protocol_serde::shape_get_session_embed_url::de_get_session_embed_url_http_response(response)
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetSessionEmbedUrlErrorKind = GetSessionEmbedUrlError;
/// Error type for the `GetSessionEmbedUrlError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSessionEmbedUrlError {
    /// <p>You don't have access to this item. The provided credentials couldn't be validated. You might not be authorized to carry out the request. Make sure that your account is authorized to use the Amazon QuickSight service, that your policies have the correct permissions, and that you are using the correct access keys.</p>
    AccessDeniedException(crate::types::error::AccessDeniedException),
    /// <p>An internal failure occurred.</p>
    InternalFailureException(crate::types::error::InternalFailureException),
    /// <p>One or more parameters has a value that isn't valid.</p>
    InvalidParameterValueException(crate::types::error::InvalidParameterValueException),
    /// <p>The user with the provided name isn't found. This error can happen in any operation that requires finding a user based on a provided user name, such as <code>DeleteUser</code>, <code>DescribeUser</code>, and so on.</p>
    QuickSightUserNotFoundException(crate::types::error::QuickSightUserNotFoundException),
    /// <p>The resource specified already exists. </p>
    ResourceExistsException(crate::types::error::ResourceExistsException),
    /// <p>One or more resources can't be found.</p>
    ResourceNotFoundException(crate::types::error::ResourceNotFoundException),
    /// <p>The number of minutes specified for the lifetime of a session isn't valid. The session lifetime must be 15-600 minutes.</p>
    SessionLifetimeInMinutesInvalidException(
        crate::types::error::SessionLifetimeInMinutesInvalidException,
    ),
    /// <p>Access is throttled.</p>
    ThrottlingException(crate::types::error::ThrottlingException),
    /// <p>This error indicates that you are calling an operation on an Amazon QuickSight subscription where the edition doesn't include support for that operation. Amazon Amazon QuickSight currently has Standard Edition and Enterprise Edition. Not every operation and capability is available in every edition.</p>
    UnsupportedUserEditionException(crate::types::error::UnsupportedUserEditionException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetSessionEmbedUrlError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: std::option::Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetSessionEmbedUrlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) => _inner.fmt(f),
            Self::InternalFailureException(_inner) => _inner.fmt(f),
            Self::InvalidParameterValueException(_inner) => _inner.fmt(f),
            Self::QuickSightUserNotFoundException(_inner) => _inner.fmt(f),
            Self::ResourceExistsException(_inner) => _inner.fmt(f),
            Self::ResourceNotFoundException(_inner) => _inner.fmt(f),
            Self::SessionLifetimeInMinutesInvalidException(_inner) => _inner.fmt(f),
            Self::ThrottlingException(_inner) => _inner.fmt(f),
            Self::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetSessionEmbedUrlError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalFailureException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::QuickSightUserNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SessionLifetimeInMinutesInvalidException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ThrottlingException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedUserEditionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId
    for crate::operation::get_session_embed_url::GetSessionEmbedUrlError
{
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetSessionEmbedUrlError {
    fn code(&self) -> std::option::Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> std::option::Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSessionEmbedUrlError {
    /// Creates the `GetSessionEmbedUrlError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetSessionEmbedUrlError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::InternalFailureException(e) => e.meta(),
            Self::InvalidParameterValueException(e) => e.meta(),
            Self::QuickSightUserNotFoundException(e) => e.meta(),
            Self::ResourceExistsException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::SessionLifetimeInMinutesInvalidException(e) => e.meta(),
            Self::ThrottlingException(e) => e.meta(),
            Self::UnsupportedUserEditionException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetSessionEmbedUrlError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetSessionEmbedUrlError::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(self, Self::InternalFailureException(_))
    }
    /// Returns `true` if the error kind is `GetSessionEmbedUrlError::InvalidParameterValueException`.
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterValueException(_))
    }
    /// Returns `true` if the error kind is `GetSessionEmbedUrlError::QuickSightUserNotFoundException`.
    pub fn is_quick_sight_user_not_found_exception(&self) -> bool {
        matches!(self, Self::QuickSightUserNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetSessionEmbedUrlError::ResourceExistsException`.
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(self, Self::ResourceExistsException(_))
    }
    /// Returns `true` if the error kind is `GetSessionEmbedUrlError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetSessionEmbedUrlError::SessionLifetimeInMinutesInvalidException`.
    pub fn is_session_lifetime_in_minutes_invalid_exception(&self) -> bool {
        matches!(self, Self::SessionLifetimeInMinutesInvalidException(_))
    }
    /// Returns `true` if the error kind is `GetSessionEmbedUrlError::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(self, Self::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetSessionEmbedUrlError::UnsupportedUserEditionException`.
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(self, Self::UnsupportedUserEditionException(_))
    }
}
impl std::error::Error for GetSessionEmbedUrlError {
    fn source(&self) -> std::option::Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) => Some(_inner),
            Self::InternalFailureException(_inner) => Some(_inner),
            Self::InvalidParameterValueException(_inner) => Some(_inner),
            Self::QuickSightUserNotFoundException(_inner) => Some(_inner),
            Self::ResourceExistsException(_inner) => Some(_inner),
            Self::ResourceNotFoundException(_inner) => Some(_inner),
            Self::SessionLifetimeInMinutesInvalidException(_inner) => Some(_inner),
            Self::ThrottlingException(_inner) => Some(_inner),
            Self::UnsupportedUserEditionException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

pub use crate::operation::get_session_embed_url::_get_session_embed_url_output::GetSessionEmbedUrlOutput;

pub use crate::operation::get_session_embed_url::_get_session_embed_url_input::GetSessionEmbedUrlInput;

mod _get_session_embed_url_input;

mod _get_session_embed_url_output;

/// Builders
pub mod builders;
