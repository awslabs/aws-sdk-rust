// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Cancels an ongoing ingestion of data into SPICE.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelIngestion {
    _private: (),
}
impl CancelIngestion {
    /// Creates a new builder-style object to manufacture [`CancelIngestionInput`](crate::input::CancelIngestionInput)
    pub fn builder() -> crate::input::cancel_ingestion_input::Builder {
        crate::input::cancel_ingestion_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelIngestion {
    type Output = std::result::Result<
        crate::output::CancelIngestionOutput,
        crate::error::CancelIngestionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_cancel_ingestion_error(response)
        } else {
            crate::operation_deser::parse_cancel_ingestion_response(response)
        }
    }
}

/// <p>Creates Amazon QuickSight customizations the current AWS Region. Currently, you can
/// add a custom default theme by using the <code>CreateAccountCustomization</code> or
/// <code>UpdateAccountCustomization</code> API operation. To further customize
/// QuickSight by removing QuickSight sample assets and videos for all new users, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/customizing-quicksight.html">Customizing QuickSight</a> in the <i>Amazon QuickSight User
/// Guide.</i>
/// </p>
/// <p>You can create customizations for your AWS account or, if you specify a namespace, for
/// a QuickSight namespace instead. Customizations that apply to a namespace always override
/// customizations that apply to an AWS account. To find out which customizations apply, use
/// the <code>DescribeAccountCustomization</code> API operation.</p>
/// <p>Before you use the <code>CreateAccountCustomization</code> API operation to add a theme
/// as the namespace default, make sure that you first share the theme with the namespace.
/// If you don't share it with the namespace, the theme isn't visible to your users
/// even if you make it the default theme.
/// To check if the theme is shared, view the current permissions by using the
/// <code>
/// <a>DescribeThemePermissions</a>
/// </code> API operation.
/// To share the theme, grant permissions by using the
/// <code>
/// <a>UpdateThemePermissions</a>
/// </code> API operation. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateAccountCustomization {
    _private: (),
}
impl CreateAccountCustomization {
    /// Creates a new builder-style object to manufacture [`CreateAccountCustomizationInput`](crate::input::CreateAccountCustomizationInput)
    pub fn builder() -> crate::input::create_account_customization_input::Builder {
        crate::input::create_account_customization_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateAccountCustomization {
    type Output = std::result::Result<
        crate::output::CreateAccountCustomizationOutput,
        crate::error::CreateAccountCustomizationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_account_customization_error(response)
        } else {
            crate::operation_deser::parse_create_account_customization_response(response)
        }
    }
}

/// <p>Creates an analysis in Amazon QuickSight.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateAnalysis {
    _private: (),
}
impl CreateAnalysis {
    /// Creates a new builder-style object to manufacture [`CreateAnalysisInput`](crate::input::CreateAnalysisInput)
    pub fn builder() -> crate::input::create_analysis_input::Builder {
        crate::input::create_analysis_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateAnalysis {
    type Output =
        std::result::Result<crate::output::CreateAnalysisOutput, crate::error::CreateAnalysisError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_analysis_error(response)
        } else {
            crate::operation_deser::parse_create_analysis_response(response)
        }
    }
}

/// <p>Creates a dashboard from a template. To first create a template, see the <code>
/// <a>CreateTemplate</a>
/// </code> API operation.</p>
/// <p>A dashboard is an entity in QuickSight that identifies QuickSight reports, created
/// from analyses. You can share QuickSight dashboards. With the right permissions, you can
/// create scheduled email reports from them. If you have the correct permissions, you can
/// create a dashboard from a template that exists in a different AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDashboard {
    _private: (),
}
impl CreateDashboard {
    /// Creates a new builder-style object to manufacture [`CreateDashboardInput`](crate::input::CreateDashboardInput)
    pub fn builder() -> crate::input::create_dashboard_input::Builder {
        crate::input::create_dashboard_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDashboard {
    type Output = std::result::Result<
        crate::output::CreateDashboardOutput,
        crate::error::CreateDashboardError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_dashboard_error(response)
        } else {
            crate::operation_deser::parse_create_dashboard_response(response)
        }
    }
}

/// <p>Creates a dataset.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDataSet {
    _private: (),
}
impl CreateDataSet {
    /// Creates a new builder-style object to manufacture [`CreateDataSetInput`](crate::input::CreateDataSetInput)
    pub fn builder() -> crate::input::create_data_set_input::Builder {
        crate::input::create_data_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDataSet {
    type Output =
        std::result::Result<crate::output::CreateDataSetOutput, crate::error::CreateDataSetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_data_set_error(response)
        } else {
            crate::operation_deser::parse_create_data_set_response(response)
        }
    }
}

/// <p>Creates a data source.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDataSource {
    _private: (),
}
impl CreateDataSource {
    /// Creates a new builder-style object to manufacture [`CreateDataSourceInput`](crate::input::CreateDataSourceInput)
    pub fn builder() -> crate::input::create_data_source_input::Builder {
        crate::input::create_data_source_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDataSource {
    type Output = std::result::Result<
        crate::output::CreateDataSourceOutput,
        crate::error::CreateDataSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_data_source_error(response)
        } else {
            crate::operation_deser::parse_create_data_source_response(response)
        }
    }
}

/// <p>Creates an empty shared folder.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateFolder {
    _private: (),
}
impl CreateFolder {
    /// Creates a new builder-style object to manufacture [`CreateFolderInput`](crate::input::CreateFolderInput)
    pub fn builder() -> crate::input::create_folder_input::Builder {
        crate::input::create_folder_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateFolder {
    type Output =
        std::result::Result<crate::output::CreateFolderOutput, crate::error::CreateFolderError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_folder_error(response)
        } else {
            crate::operation_deser::parse_create_folder_response(response)
        }
    }
}

/// <p>Adds an asset, such as a dashboard, analysis, or dataset into a folder.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateFolderMembership {
    _private: (),
}
impl CreateFolderMembership {
    /// Creates a new builder-style object to manufacture [`CreateFolderMembershipInput`](crate::input::CreateFolderMembershipInput)
    pub fn builder() -> crate::input::create_folder_membership_input::Builder {
        crate::input::create_folder_membership_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateFolderMembership {
    type Output = std::result::Result<
        crate::output::CreateFolderMembershipOutput,
        crate::error::CreateFolderMembershipError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_folder_membership_error(response)
        } else {
            crate::operation_deser::parse_create_folder_membership_response(response)
        }
    }
}

/// <p>Creates an Amazon QuickSight group.</p>
/// <p>The permissions resource is
/// <code>arn:aws:quicksight:us-east-1:<i><relevant-aws-account-id></i>:group/default/<i><group-name></i>
/// </code>.</p>
/// <p>The response is a group object.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateGroup {
    _private: (),
}
impl CreateGroup {
    /// Creates a new builder-style object to manufacture [`CreateGroupInput`](crate::input::CreateGroupInput)
    pub fn builder() -> crate::input::create_group_input::Builder {
        crate::input::create_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateGroup {
    type Output =
        std::result::Result<crate::output::CreateGroupOutput, crate::error::CreateGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_group_error(response)
        } else {
            crate::operation_deser::parse_create_group_response(response)
        }
    }
}

/// <p>Adds an Amazon QuickSight user to an Amazon QuickSight group. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateGroupMembership {
    _private: (),
}
impl CreateGroupMembership {
    /// Creates a new builder-style object to manufacture [`CreateGroupMembershipInput`](crate::input::CreateGroupMembershipInput)
    pub fn builder() -> crate::input::create_group_membership_input::Builder {
        crate::input::create_group_membership_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateGroupMembership {
    type Output = std::result::Result<
        crate::output::CreateGroupMembershipOutput,
        crate::error::CreateGroupMembershipError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_group_membership_error(response)
        } else {
            crate::operation_deser::parse_create_group_membership_response(response)
        }
    }
}

/// <p>Creates an assignment with one specified IAM policy, identified by its Amazon Resource Name
/// (ARN). This policy assignment is attached to the specified groups or users of Amazon QuickSight.
/// Assignment names are unique per AWS account. To avoid overwriting rules in other namespaces,
/// use assignment names that are unique.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateIAMPolicyAssignment {
    _private: (),
}
impl CreateIAMPolicyAssignment {
    /// Creates a new builder-style object to manufacture [`CreateIamPolicyAssignmentInput`](crate::input::CreateIamPolicyAssignmentInput)
    pub fn builder() -> crate::input::create_iam_policy_assignment_input::Builder {
        crate::input::create_iam_policy_assignment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateIAMPolicyAssignment {
    type Output = std::result::Result<
        crate::output::CreateIamPolicyAssignmentOutput,
        crate::error::CreateIAMPolicyAssignmentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_iam_policy_assignment_error(response)
        } else {
            crate::operation_deser::parse_create_iam_policy_assignment_response(response)
        }
    }
}

/// <p>Creates and starts a new SPICE ingestion on a dataset</p>
/// <p>Any ingestions operating on tagged datasets inherit the same tags automatically for use in
/// access control. For an example, see <a href="http://aws.amazon.com/premiumsupport/knowledge-center/iam-ec2-resource-tags/">How do I create an IAM policy to control access to Amazon EC2 resources using
/// tags?</a> in the AWS Knowledge Center. Tags are visible on the tagged dataset, but not on the ingestion resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateIngestion {
    _private: (),
}
impl CreateIngestion {
    /// Creates a new builder-style object to manufacture [`CreateIngestionInput`](crate::input::CreateIngestionInput)
    pub fn builder() -> crate::input::create_ingestion_input::Builder {
        crate::input::create_ingestion_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateIngestion {
    type Output = std::result::Result<
        crate::output::CreateIngestionOutput,
        crate::error::CreateIngestionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_ingestion_error(response)
        } else {
            crate::operation_deser::parse_create_ingestion_response(response)
        }
    }
}

/// <p>(Enterprise edition only) Creates a new namespace for you to use with Amazon QuickSight.</p>
/// <p>A namespace allows you to isolate the QuickSight users and groups that are registered
/// for that namespace. Users that access the namespace can share assets only with other
/// users or groups in the same namespace. They can't see users and groups in other
/// namespaces. You can create a namespace after your AWS account is subscribed to
/// QuickSight. The namespace must be unique within the AWS account. By default, there is a
/// limit of 100 namespaces per AWS account. To increase your limit, create a ticket with
/// AWS Support. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateNamespace {
    _private: (),
}
impl CreateNamespace {
    /// Creates a new builder-style object to manufacture [`CreateNamespaceInput`](crate::input::CreateNamespaceInput)
    pub fn builder() -> crate::input::create_namespace_input::Builder {
        crate::input::create_namespace_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateNamespace {
    type Output = std::result::Result<
        crate::output::CreateNamespaceOutput,
        crate::error::CreateNamespaceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_namespace_error(response)
        } else {
            crate::operation_deser::parse_create_namespace_response(response)
        }
    }
}

/// <p>Creates a template from an existing QuickSight analysis or template. You can use the resulting
/// template to create a dashboard.</p>
/// <p>A <i>template</i> is an entity in QuickSight that encapsulates the metadata
/// required to create an analysis and that you can use to create s dashboard. A template adds
/// a layer of abstraction by using placeholders to replace the dataset associated with the
/// analysis. You can use templates to create dashboards by replacing dataset placeholders
/// with datasets that follow the same schema that was used to create the source analysis
/// and template.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateTemplate {
    _private: (),
}
impl CreateTemplate {
    /// Creates a new builder-style object to manufacture [`CreateTemplateInput`](crate::input::CreateTemplateInput)
    pub fn builder() -> crate::input::create_template_input::Builder {
        crate::input::create_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateTemplate {
    type Output =
        std::result::Result<crate::output::CreateTemplateOutput, crate::error::CreateTemplateError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_template_error(response)
        } else {
            crate::operation_deser::parse_create_template_response(response)
        }
    }
}

/// <p>Creates a template alias for a template.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateTemplateAlias {
    _private: (),
}
impl CreateTemplateAlias {
    /// Creates a new builder-style object to manufacture [`CreateTemplateAliasInput`](crate::input::CreateTemplateAliasInput)
    pub fn builder() -> crate::input::create_template_alias_input::Builder {
        crate::input::create_template_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateTemplateAlias {
    type Output = std::result::Result<
        crate::output::CreateTemplateAliasOutput,
        crate::error::CreateTemplateAliasError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_template_alias_error(response)
        } else {
            crate::operation_deser::parse_create_template_alias_response(response)
        }
    }
}

/// <p>Creates a theme.</p>
/// <p>A <i>theme</i> is set of configuration options for color and layout.
/// Themes apply to analyses and dashboards. For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/themes-in-quicksight.html">Using
/// Themes in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateTheme {
    _private: (),
}
impl CreateTheme {
    /// Creates a new builder-style object to manufacture [`CreateThemeInput`](crate::input::CreateThemeInput)
    pub fn builder() -> crate::input::create_theme_input::Builder {
        crate::input::create_theme_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateTheme {
    type Output =
        std::result::Result<crate::output::CreateThemeOutput, crate::error::CreateThemeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_theme_error(response)
        } else {
            crate::operation_deser::parse_create_theme_response(response)
        }
    }
}

/// <p>Creates a theme alias for a theme.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateThemeAlias {
    _private: (),
}
impl CreateThemeAlias {
    /// Creates a new builder-style object to manufacture [`CreateThemeAliasInput`](crate::input::CreateThemeAliasInput)
    pub fn builder() -> crate::input::create_theme_alias_input::Builder {
        crate::input::create_theme_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateThemeAlias {
    type Output = std::result::Result<
        crate::output::CreateThemeAliasOutput,
        crate::error::CreateThemeAliasError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_theme_alias_error(response)
        } else {
            crate::operation_deser::parse_create_theme_alias_response(response)
        }
    }
}

/// <p>Deletes all Amazon QuickSight customizations in this AWS Region for the specified AWS
/// account and QuickSight namespace.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteAccountCustomization {
    _private: (),
}
impl DeleteAccountCustomization {
    /// Creates a new builder-style object to manufacture [`DeleteAccountCustomizationInput`](crate::input::DeleteAccountCustomizationInput)
    pub fn builder() -> crate::input::delete_account_customization_input::Builder {
        crate::input::delete_account_customization_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteAccountCustomization {
    type Output = std::result::Result<
        crate::output::DeleteAccountCustomizationOutput,
        crate::error::DeleteAccountCustomizationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_account_customization_error(response)
        } else {
            crate::operation_deser::parse_delete_account_customization_response(response)
        }
    }
}

/// <p>Deletes an analysis from Amazon QuickSight. You can optionally include a recovery window during
/// which you can restore the analysis. If you don't specify a recovery window value, the
/// operation defaults to 30 days. QuickSight attaches a <code>DeletionTime</code> stamp to
/// the response that specifies the end of the recovery window. At the end of the recovery
/// window, QuickSight deletes the analysis permanently.</p>
/// <p>At any time before recovery window ends, you can use the <code>RestoreAnalysis</code>
/// API operation to remove the <code>DeletionTime</code> stamp and cancel the deletion of
/// the analysis. The analysis remains visible in the API until it's deleted, so you can
/// describe it but you can't make a template from it.</p>
/// <p>An analysis that's scheduled for deletion isn't accessible in the QuickSight console.
/// To access it in the console, restore it. Deleting an analysis doesn't delete the
/// dashboards that you publish from it.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteAnalysis {
    _private: (),
}
impl DeleteAnalysis {
    /// Creates a new builder-style object to manufacture [`DeleteAnalysisInput`](crate::input::DeleteAnalysisInput)
    pub fn builder() -> crate::input::delete_analysis_input::Builder {
        crate::input::delete_analysis_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteAnalysis {
    type Output =
        std::result::Result<crate::output::DeleteAnalysisOutput, crate::error::DeleteAnalysisError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_analysis_error(response)
        } else {
            crate::operation_deser::parse_delete_analysis_response(response)
        }
    }
}

/// <p>Deletes a dashboard.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDashboard {
    _private: (),
}
impl DeleteDashboard {
    /// Creates a new builder-style object to manufacture [`DeleteDashboardInput`](crate::input::DeleteDashboardInput)
    pub fn builder() -> crate::input::delete_dashboard_input::Builder {
        crate::input::delete_dashboard_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDashboard {
    type Output = std::result::Result<
        crate::output::DeleteDashboardOutput,
        crate::error::DeleteDashboardError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_dashboard_error(response)
        } else {
            crate::operation_deser::parse_delete_dashboard_response(response)
        }
    }
}

/// <p>Deletes a dataset.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDataSet {
    _private: (),
}
impl DeleteDataSet {
    /// Creates a new builder-style object to manufacture [`DeleteDataSetInput`](crate::input::DeleteDataSetInput)
    pub fn builder() -> crate::input::delete_data_set_input::Builder {
        crate::input::delete_data_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDataSet {
    type Output =
        std::result::Result<crate::output::DeleteDataSetOutput, crate::error::DeleteDataSetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_data_set_error(response)
        } else {
            crate::operation_deser::parse_delete_data_set_response(response)
        }
    }
}

/// <p>Deletes the data source permanently. This operation breaks
/// all the datasets that reference the deleted data source.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDataSource {
    _private: (),
}
impl DeleteDataSource {
    /// Creates a new builder-style object to manufacture [`DeleteDataSourceInput`](crate::input::DeleteDataSourceInput)
    pub fn builder() -> crate::input::delete_data_source_input::Builder {
        crate::input::delete_data_source_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDataSource {
    type Output = std::result::Result<
        crate::output::DeleteDataSourceOutput,
        crate::error::DeleteDataSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_data_source_error(response)
        } else {
            crate::operation_deser::parse_delete_data_source_response(response)
        }
    }
}

/// <p>Deletes an empty folder.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFolder {
    _private: (),
}
impl DeleteFolder {
    /// Creates a new builder-style object to manufacture [`DeleteFolderInput`](crate::input::DeleteFolderInput)
    pub fn builder() -> crate::input::delete_folder_input::Builder {
        crate::input::delete_folder_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFolder {
    type Output =
        std::result::Result<crate::output::DeleteFolderOutput, crate::error::DeleteFolderError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_folder_error(response)
        } else {
            crate::operation_deser::parse_delete_folder_response(response)
        }
    }
}

/// <p>Removes an asset, such as a dashboard, analysis, or dataset, from a folder.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFolderMembership {
    _private: (),
}
impl DeleteFolderMembership {
    /// Creates a new builder-style object to manufacture [`DeleteFolderMembershipInput`](crate::input::DeleteFolderMembershipInput)
    pub fn builder() -> crate::input::delete_folder_membership_input::Builder {
        crate::input::delete_folder_membership_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFolderMembership {
    type Output = std::result::Result<
        crate::output::DeleteFolderMembershipOutput,
        crate::error::DeleteFolderMembershipError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_folder_membership_error(response)
        } else {
            crate::operation_deser::parse_delete_folder_membership_response(response)
        }
    }
}

/// <p>Removes a user group from Amazon QuickSight. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteGroup {
    _private: (),
}
impl DeleteGroup {
    /// Creates a new builder-style object to manufacture [`DeleteGroupInput`](crate::input::DeleteGroupInput)
    pub fn builder() -> crate::input::delete_group_input::Builder {
        crate::input::delete_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteGroup {
    type Output =
        std::result::Result<crate::output::DeleteGroupOutput, crate::error::DeleteGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_group_error(response)
        } else {
            crate::operation_deser::parse_delete_group_response(response)
        }
    }
}

/// <p>Removes a user from a group so that the user is no longer a member of the group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteGroupMembership {
    _private: (),
}
impl DeleteGroupMembership {
    /// Creates a new builder-style object to manufacture [`DeleteGroupMembershipInput`](crate::input::DeleteGroupMembershipInput)
    pub fn builder() -> crate::input::delete_group_membership_input::Builder {
        crate::input::delete_group_membership_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteGroupMembership {
    type Output = std::result::Result<
        crate::output::DeleteGroupMembershipOutput,
        crate::error::DeleteGroupMembershipError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_group_membership_error(response)
        } else {
            crate::operation_deser::parse_delete_group_membership_response(response)
        }
    }
}

/// <p>Deletes an existing IAM policy assignment.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteIAMPolicyAssignment {
    _private: (),
}
impl DeleteIAMPolicyAssignment {
    /// Creates a new builder-style object to manufacture [`DeleteIamPolicyAssignmentInput`](crate::input::DeleteIamPolicyAssignmentInput)
    pub fn builder() -> crate::input::delete_iam_policy_assignment_input::Builder {
        crate::input::delete_iam_policy_assignment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteIAMPolicyAssignment {
    type Output = std::result::Result<
        crate::output::DeleteIamPolicyAssignmentOutput,
        crate::error::DeleteIAMPolicyAssignmentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_iam_policy_assignment_error(response)
        } else {
            crate::operation_deser::parse_delete_iam_policy_assignment_response(response)
        }
    }
}

/// <p>Deletes a namespace and the users and groups that are associated with the namespace.
/// This is an asynchronous process. Assets including dashboards, analyses, datasets and data sources are not
/// deleted. To delete these assets, you use the API operations for the relevant asset. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteNamespace {
    _private: (),
}
impl DeleteNamespace {
    /// Creates a new builder-style object to manufacture [`DeleteNamespaceInput`](crate::input::DeleteNamespaceInput)
    pub fn builder() -> crate::input::delete_namespace_input::Builder {
        crate::input::delete_namespace_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteNamespace {
    type Output = std::result::Result<
        crate::output::DeleteNamespaceOutput,
        crate::error::DeleteNamespaceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_namespace_error(response)
        } else {
            crate::operation_deser::parse_delete_namespace_response(response)
        }
    }
}

/// <p>Deletes a template.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTemplate {
    _private: (),
}
impl DeleteTemplate {
    /// Creates a new builder-style object to manufacture [`DeleteTemplateInput`](crate::input::DeleteTemplateInput)
    pub fn builder() -> crate::input::delete_template_input::Builder {
        crate::input::delete_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTemplate {
    type Output =
        std::result::Result<crate::output::DeleteTemplateOutput, crate::error::DeleteTemplateError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_template_error(response)
        } else {
            crate::operation_deser::parse_delete_template_response(response)
        }
    }
}

/// <p>Deletes the item that the specified template alias points to. If you provide a specific
/// alias, you delete the version of the template that the alias points to.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTemplateAlias {
    _private: (),
}
impl DeleteTemplateAlias {
    /// Creates a new builder-style object to manufacture [`DeleteTemplateAliasInput`](crate::input::DeleteTemplateAliasInput)
    pub fn builder() -> crate::input::delete_template_alias_input::Builder {
        crate::input::delete_template_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTemplateAlias {
    type Output = std::result::Result<
        crate::output::DeleteTemplateAliasOutput,
        crate::error::DeleteTemplateAliasError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_template_alias_error(response)
        } else {
            crate::operation_deser::parse_delete_template_alias_response(response)
        }
    }
}

/// <p>Deletes a theme.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTheme {
    _private: (),
}
impl DeleteTheme {
    /// Creates a new builder-style object to manufacture [`DeleteThemeInput`](crate::input::DeleteThemeInput)
    pub fn builder() -> crate::input::delete_theme_input::Builder {
        crate::input::delete_theme_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTheme {
    type Output =
        std::result::Result<crate::output::DeleteThemeOutput, crate::error::DeleteThemeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_theme_error(response)
        } else {
            crate::operation_deser::parse_delete_theme_response(response)
        }
    }
}

/// <p>Deletes the version of the theme that the specified theme alias points to.
/// If you provide a specific alias, you delete the version of the theme
/// that the alias points to.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteThemeAlias {
    _private: (),
}
impl DeleteThemeAlias {
    /// Creates a new builder-style object to manufacture [`DeleteThemeAliasInput`](crate::input::DeleteThemeAliasInput)
    pub fn builder() -> crate::input::delete_theme_alias_input::Builder {
        crate::input::delete_theme_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteThemeAlias {
    type Output = std::result::Result<
        crate::output::DeleteThemeAliasOutput,
        crate::error::DeleteThemeAliasError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_theme_alias_error(response)
        } else {
            crate::operation_deser::parse_delete_theme_alias_response(response)
        }
    }
}

/// <p>Deletes the Amazon QuickSight user that is associated with the identity of the AWS
/// Identity and Access Management (IAM) user or role that's making the call. The IAM user
/// isn't deleted as a result of this call. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteUser {
    _private: (),
}
impl DeleteUser {
    /// Creates a new builder-style object to manufacture [`DeleteUserInput`](crate::input::DeleteUserInput)
    pub fn builder() -> crate::input::delete_user_input::Builder {
        crate::input::delete_user_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteUser {
    type Output =
        std::result::Result<crate::output::DeleteUserOutput, crate::error::DeleteUserError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_user_error(response)
        } else {
            crate::operation_deser::parse_delete_user_response(response)
        }
    }
}

/// <p>Deletes a user identified by its principal ID. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteUserByPrincipalId {
    _private: (),
}
impl DeleteUserByPrincipalId {
    /// Creates a new builder-style object to manufacture [`DeleteUserByPrincipalIdInput`](crate::input::DeleteUserByPrincipalIdInput)
    pub fn builder() -> crate::input::delete_user_by_principal_id_input::Builder {
        crate::input::delete_user_by_principal_id_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteUserByPrincipalId {
    type Output = std::result::Result<
        crate::output::DeleteUserByPrincipalIdOutput,
        crate::error::DeleteUserByPrincipalIdError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_user_by_principal_id_error(response)
        } else {
            crate::operation_deser::parse_delete_user_by_principal_id_response(response)
        }
    }
}

/// <p>Describes the customizations associated with the provided AWS account and Amazon
/// QuickSight namespace in an AWS Region. The QuickSight console evaluates which
/// customizations to apply by running this API operation with the <code>Resolved</code> flag
/// included. </p>
/// <p>To determine what customizations display when you run this command, it can help to
/// visualize the relationship of the entities involved. </p>
/// <ul>
/// <li>
/// <p>
/// <code>AWS Account</code> - The AWS account exists at the top of the hierarchy.
/// It has the potential to use all of the AWS Regions and AWS Services. When you
/// subscribe to QuickSight, you choose one AWS Region to use as your home Region.
/// That's where your free SPICE capacity is located. You can use QuickSight in any
/// supported AWS Region. </p>
/// </li>
/// <li>
/// <p>
/// <code>AWS Region</code> - In each AWS Region where you sign in to QuickSight
/// at least once, QuickSight acts as a separate instance of the same service. If
/// you have a user directory, it resides in us-east-1, which is the US East (N.
/// Virginia). Generally speaking, these users have access to QuickSight in any AWS
/// Region, unless they are constrained to a namespace. </p>
/// <p>To run the command in a different AWS Region, you change your Region settings.
/// If you're using the AWS CLI, you can use one of the following options:</p>
/// <ul>
/// <li>
/// <p>Use <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-options.html">command line options</a>. </p>
/// </li>
/// <li>
/// <p>Use <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-profiles.html">named profiles</a>. </p>
/// </li>
/// <li>
/// <p>Run <code>aws configure</code> to change your default AWS Region. Use
/// Enter to key the same settings for your keys. For more information, see
/// <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html">Configuring the AWS CLI</a>.</p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>
/// <code>Namespace</code> - A QuickSight namespace is a partition that contains
/// users and assets (data sources, datasets, dashboards, and so on). To access
/// assets that are in a specific namespace, users and groups must also be part of
/// the same namespace. People who share a namespace are completely isolated from
/// users and assets in other namespaces, even if they are in the same AWS account
/// and AWS Region.</p>
/// </li>
/// <li>
/// <p>
/// <code>Applied customizations</code> -  Within an AWS Region, a set of
/// QuickSight customizations can apply to an AWS account or to a namespace.
/// Settings that you apply to a namespace override settings that you apply to an
/// AWS account. All settings are isolated to a single AWS Region. To apply them in
/// other AWS Regions, run the <code>CreateAccountCustomization</code> command in
/// each AWS Region where you want to apply the same customizations. </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAccountCustomization {
    _private: (),
}
impl DescribeAccountCustomization {
    /// Creates a new builder-style object to manufacture [`DescribeAccountCustomizationInput`](crate::input::DescribeAccountCustomizationInput)
    pub fn builder() -> crate::input::describe_account_customization_input::Builder {
        crate::input::describe_account_customization_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAccountCustomization {
    type Output = std::result::Result<
        crate::output::DescribeAccountCustomizationOutput,
        crate::error::DescribeAccountCustomizationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_account_customization_error(response)
        } else {
            crate::operation_deser::parse_describe_account_customization_response(response)
        }
    }
}

/// <p>Describes the settings that were used when your QuickSight subscription was first
/// created in this AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAccountSettings {
    _private: (),
}
impl DescribeAccountSettings {
    /// Creates a new builder-style object to manufacture [`DescribeAccountSettingsInput`](crate::input::DescribeAccountSettingsInput)
    pub fn builder() -> crate::input::describe_account_settings_input::Builder {
        crate::input::describe_account_settings_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAccountSettings {
    type Output = std::result::Result<
        crate::output::DescribeAccountSettingsOutput,
        crate::error::DescribeAccountSettingsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_account_settings_error(response)
        } else {
            crate::operation_deser::parse_describe_account_settings_response(response)
        }
    }
}

/// <p>Provides a summary of the metadata for an analysis.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAnalysis {
    _private: (),
}
impl DescribeAnalysis {
    /// Creates a new builder-style object to manufacture [`DescribeAnalysisInput`](crate::input::DescribeAnalysisInput)
    pub fn builder() -> crate::input::describe_analysis_input::Builder {
        crate::input::describe_analysis_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAnalysis {
    type Output = std::result::Result<
        crate::output::DescribeAnalysisOutput,
        crate::error::DescribeAnalysisError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_analysis_error(response)
        } else {
            crate::operation_deser::parse_describe_analysis_response(response)
        }
    }
}

/// <p>Provides the read and write permissions for an analysis.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAnalysisPermissions {
    _private: (),
}
impl DescribeAnalysisPermissions {
    /// Creates a new builder-style object to manufacture [`DescribeAnalysisPermissionsInput`](crate::input::DescribeAnalysisPermissionsInput)
    pub fn builder() -> crate::input::describe_analysis_permissions_input::Builder {
        crate::input::describe_analysis_permissions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAnalysisPermissions {
    type Output = std::result::Result<
        crate::output::DescribeAnalysisPermissionsOutput,
        crate::error::DescribeAnalysisPermissionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_analysis_permissions_error(response)
        } else {
            crate::operation_deser::parse_describe_analysis_permissions_response(response)
        }
    }
}

/// <p>Provides a summary for a dashboard.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDashboard {
    _private: (),
}
impl DescribeDashboard {
    /// Creates a new builder-style object to manufacture [`DescribeDashboardInput`](crate::input::DescribeDashboardInput)
    pub fn builder() -> crate::input::describe_dashboard_input::Builder {
        crate::input::describe_dashboard_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDashboard {
    type Output = std::result::Result<
        crate::output::DescribeDashboardOutput,
        crate::error::DescribeDashboardError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_dashboard_error(response)
        } else {
            crate::operation_deser::parse_describe_dashboard_response(response)
        }
    }
}

/// <p>Describes read and write permissions for a dashboard.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDashboardPermissions {
    _private: (),
}
impl DescribeDashboardPermissions {
    /// Creates a new builder-style object to manufacture [`DescribeDashboardPermissionsInput`](crate::input::DescribeDashboardPermissionsInput)
    pub fn builder() -> crate::input::describe_dashboard_permissions_input::Builder {
        crate::input::describe_dashboard_permissions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDashboardPermissions {
    type Output = std::result::Result<
        crate::output::DescribeDashboardPermissionsOutput,
        crate::error::DescribeDashboardPermissionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_dashboard_permissions_error(response)
        } else {
            crate::operation_deser::parse_describe_dashboard_permissions_response(response)
        }
    }
}

/// <p>Describes a dataset. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDataSet {
    _private: (),
}
impl DescribeDataSet {
    /// Creates a new builder-style object to manufacture [`DescribeDataSetInput`](crate::input::DescribeDataSetInput)
    pub fn builder() -> crate::input::describe_data_set_input::Builder {
        crate::input::describe_data_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDataSet {
    type Output = std::result::Result<
        crate::output::DescribeDataSetOutput,
        crate::error::DescribeDataSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_data_set_error(response)
        } else {
            crate::operation_deser::parse_describe_data_set_response(response)
        }
    }
}

/// <p>Describes the permissions on a dataset.</p>
/// <p>The permissions resource is <code>arn:aws:quicksight:region:aws-account-id:dataset/data-set-id</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDataSetPermissions {
    _private: (),
}
impl DescribeDataSetPermissions {
    /// Creates a new builder-style object to manufacture [`DescribeDataSetPermissionsInput`](crate::input::DescribeDataSetPermissionsInput)
    pub fn builder() -> crate::input::describe_data_set_permissions_input::Builder {
        crate::input::describe_data_set_permissions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDataSetPermissions {
    type Output = std::result::Result<
        crate::output::DescribeDataSetPermissionsOutput,
        crate::error::DescribeDataSetPermissionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_data_set_permissions_error(response)
        } else {
            crate::operation_deser::parse_describe_data_set_permissions_response(response)
        }
    }
}

/// <p>Describes a data source.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDataSource {
    _private: (),
}
impl DescribeDataSource {
    /// Creates a new builder-style object to manufacture [`DescribeDataSourceInput`](crate::input::DescribeDataSourceInput)
    pub fn builder() -> crate::input::describe_data_source_input::Builder {
        crate::input::describe_data_source_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDataSource {
    type Output = std::result::Result<
        crate::output::DescribeDataSourceOutput,
        crate::error::DescribeDataSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_data_source_error(response)
        } else {
            crate::operation_deser::parse_describe_data_source_response(response)
        }
    }
}

/// <p>Describes the resource permissions for a data source.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDataSourcePermissions {
    _private: (),
}
impl DescribeDataSourcePermissions {
    /// Creates a new builder-style object to manufacture [`DescribeDataSourcePermissionsInput`](crate::input::DescribeDataSourcePermissionsInput)
    pub fn builder() -> crate::input::describe_data_source_permissions_input::Builder {
        crate::input::describe_data_source_permissions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDataSourcePermissions {
    type Output = std::result::Result<
        crate::output::DescribeDataSourcePermissionsOutput,
        crate::error::DescribeDataSourcePermissionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_data_source_permissions_error(response)
        } else {
            crate::operation_deser::parse_describe_data_source_permissions_response(response)
        }
    }
}

/// <p>Describes a folder.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeFolder {
    _private: (),
}
impl DescribeFolder {
    /// Creates a new builder-style object to manufacture [`DescribeFolderInput`](crate::input::DescribeFolderInput)
    pub fn builder() -> crate::input::describe_folder_input::Builder {
        crate::input::describe_folder_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeFolder {
    type Output =
        std::result::Result<crate::output::DescribeFolderOutput, crate::error::DescribeFolderError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_folder_error(response)
        } else {
            crate::operation_deser::parse_describe_folder_response(response)
        }
    }
}

/// <p>Describes permissions for a folder.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeFolderPermissions {
    _private: (),
}
impl DescribeFolderPermissions {
    /// Creates a new builder-style object to manufacture [`DescribeFolderPermissionsInput`](crate::input::DescribeFolderPermissionsInput)
    pub fn builder() -> crate::input::describe_folder_permissions_input::Builder {
        crate::input::describe_folder_permissions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeFolderPermissions {
    type Output = std::result::Result<
        crate::output::DescribeFolderPermissionsOutput,
        crate::error::DescribeFolderPermissionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_folder_permissions_error(response)
        } else {
            crate::operation_deser::parse_describe_folder_permissions_response(response)
        }
    }
}

/// <p>Describes the folder resolved permissions. Permissions consists of both folder direct permissions and the inherited permissions from the ancestor folders.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeFolderResolvedPermissions {
    _private: (),
}
impl DescribeFolderResolvedPermissions {
    /// Creates a new builder-style object to manufacture [`DescribeFolderResolvedPermissionsInput`](crate::input::DescribeFolderResolvedPermissionsInput)
    pub fn builder() -> crate::input::describe_folder_resolved_permissions_input::Builder {
        crate::input::describe_folder_resolved_permissions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeFolderResolvedPermissions {
    type Output = std::result::Result<
        crate::output::DescribeFolderResolvedPermissionsOutput,
        crate::error::DescribeFolderResolvedPermissionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_folder_resolved_permissions_error(response)
        } else {
            crate::operation_deser::parse_describe_folder_resolved_permissions_response(response)
        }
    }
}

/// <p>Returns an Amazon QuickSight group's description and Amazon Resource Name (ARN). </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeGroup {
    _private: (),
}
impl DescribeGroup {
    /// Creates a new builder-style object to manufacture [`DescribeGroupInput`](crate::input::DescribeGroupInput)
    pub fn builder() -> crate::input::describe_group_input::Builder {
        crate::input::describe_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeGroup {
    type Output =
        std::result::Result<crate::output::DescribeGroupOutput, crate::error::DescribeGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_group_error(response)
        } else {
            crate::operation_deser::parse_describe_group_response(response)
        }
    }
}

/// <p>Describes an existing IAM policy assignment, as specified by the assignment name.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeIAMPolicyAssignment {
    _private: (),
}
impl DescribeIAMPolicyAssignment {
    /// Creates a new builder-style object to manufacture [`DescribeIamPolicyAssignmentInput`](crate::input::DescribeIamPolicyAssignmentInput)
    pub fn builder() -> crate::input::describe_iam_policy_assignment_input::Builder {
        crate::input::describe_iam_policy_assignment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeIAMPolicyAssignment {
    type Output = std::result::Result<
        crate::output::DescribeIamPolicyAssignmentOutput,
        crate::error::DescribeIAMPolicyAssignmentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_iam_policy_assignment_error(response)
        } else {
            crate::operation_deser::parse_describe_iam_policy_assignment_response(response)
        }
    }
}

/// <p>Describes a SPICE ingestion.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeIngestion {
    _private: (),
}
impl DescribeIngestion {
    /// Creates a new builder-style object to manufacture [`DescribeIngestionInput`](crate::input::DescribeIngestionInput)
    pub fn builder() -> crate::input::describe_ingestion_input::Builder {
        crate::input::describe_ingestion_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeIngestion {
    type Output = std::result::Result<
        crate::output::DescribeIngestionOutput,
        crate::error::DescribeIngestionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_ingestion_error(response)
        } else {
            crate::operation_deser::parse_describe_ingestion_response(response)
        }
    }
}

/// <p>Describes the current namespace.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeNamespace {
    _private: (),
}
impl DescribeNamespace {
    /// Creates a new builder-style object to manufacture [`DescribeNamespaceInput`](crate::input::DescribeNamespaceInput)
    pub fn builder() -> crate::input::describe_namespace_input::Builder {
        crate::input::describe_namespace_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeNamespace {
    type Output = std::result::Result<
        crate::output::DescribeNamespaceOutput,
        crate::error::DescribeNamespaceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_namespace_error(response)
        } else {
            crate::operation_deser::parse_describe_namespace_response(response)
        }
    }
}

/// <p>Describes a template's metadata.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTemplate {
    _private: (),
}
impl DescribeTemplate {
    /// Creates a new builder-style object to manufacture [`DescribeTemplateInput`](crate::input::DescribeTemplateInput)
    pub fn builder() -> crate::input::describe_template_input::Builder {
        crate::input::describe_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTemplate {
    type Output = std::result::Result<
        crate::output::DescribeTemplateOutput,
        crate::error::DescribeTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_template_error(response)
        } else {
            crate::operation_deser::parse_describe_template_response(response)
        }
    }
}

/// <p>Describes the template alias for a template.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTemplateAlias {
    _private: (),
}
impl DescribeTemplateAlias {
    /// Creates a new builder-style object to manufacture [`DescribeTemplateAliasInput`](crate::input::DescribeTemplateAliasInput)
    pub fn builder() -> crate::input::describe_template_alias_input::Builder {
        crate::input::describe_template_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTemplateAlias {
    type Output = std::result::Result<
        crate::output::DescribeTemplateAliasOutput,
        crate::error::DescribeTemplateAliasError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_template_alias_error(response)
        } else {
            crate::operation_deser::parse_describe_template_alias_response(response)
        }
    }
}

/// <p>Describes read and write permissions on a template.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTemplatePermissions {
    _private: (),
}
impl DescribeTemplatePermissions {
    /// Creates a new builder-style object to manufacture [`DescribeTemplatePermissionsInput`](crate::input::DescribeTemplatePermissionsInput)
    pub fn builder() -> crate::input::describe_template_permissions_input::Builder {
        crate::input::describe_template_permissions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTemplatePermissions {
    type Output = std::result::Result<
        crate::output::DescribeTemplatePermissionsOutput,
        crate::error::DescribeTemplatePermissionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_template_permissions_error(response)
        } else {
            crate::operation_deser::parse_describe_template_permissions_response(response)
        }
    }
}

/// <p>Describes a theme.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTheme {
    _private: (),
}
impl DescribeTheme {
    /// Creates a new builder-style object to manufacture [`DescribeThemeInput`](crate::input::DescribeThemeInput)
    pub fn builder() -> crate::input::describe_theme_input::Builder {
        crate::input::describe_theme_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTheme {
    type Output =
        std::result::Result<crate::output::DescribeThemeOutput, crate::error::DescribeThemeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_theme_error(response)
        } else {
            crate::operation_deser::parse_describe_theme_response(response)
        }
    }
}

/// <p>Describes the alias for a theme.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeThemeAlias {
    _private: (),
}
impl DescribeThemeAlias {
    /// Creates a new builder-style object to manufacture [`DescribeThemeAliasInput`](crate::input::DescribeThemeAliasInput)
    pub fn builder() -> crate::input::describe_theme_alias_input::Builder {
        crate::input::describe_theme_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeThemeAlias {
    type Output = std::result::Result<
        crate::output::DescribeThemeAliasOutput,
        crate::error::DescribeThemeAliasError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_theme_alias_error(response)
        } else {
            crate::operation_deser::parse_describe_theme_alias_response(response)
        }
    }
}

/// <p>Describes the read and write permissions for a theme.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeThemePermissions {
    _private: (),
}
impl DescribeThemePermissions {
    /// Creates a new builder-style object to manufacture [`DescribeThemePermissionsInput`](crate::input::DescribeThemePermissionsInput)
    pub fn builder() -> crate::input::describe_theme_permissions_input::Builder {
        crate::input::describe_theme_permissions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeThemePermissions {
    type Output = std::result::Result<
        crate::output::DescribeThemePermissionsOutput,
        crate::error::DescribeThemePermissionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_theme_permissions_error(response)
        } else {
            crate::operation_deser::parse_describe_theme_permissions_response(response)
        }
    }
}

/// <p>Returns information about a user, given the user name. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeUser {
    _private: (),
}
impl DescribeUser {
    /// Creates a new builder-style object to manufacture [`DescribeUserInput`](crate::input::DescribeUserInput)
    pub fn builder() -> crate::input::describe_user_input::Builder {
        crate::input::describe_user_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeUser {
    type Output =
        std::result::Result<crate::output::DescribeUserOutput, crate::error::DescribeUserError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_user_error(response)
        } else {
            crate::operation_deser::parse_describe_user_response(response)
        }
    }
}

/// <p>Generates a session URL and authorization code that you can use to embed an Amazon
/// QuickSight read-only dashboard in your web server code. Before you use this command,
/// make sure that you have configured the dashboards and permissions. </p>
/// <p>Currently, you can use <code>GetDashboardEmbedURL</code> only from the server, not
/// from the user's browser. The following rules apply to the combination of URL and
/// authorization code:</p>
/// <ul>
/// <li>
/// <p>They must be used together.</p>
/// </li>
/// <li>
/// <p>They can be used one time only.</p>
/// </li>
/// <li>
/// <p>They are valid for 5 minutes after you run this command.</p>
/// </li>
/// <li>
/// <p>The resulting user session is valid for 10 hours.</p>
/// </li>
/// </ul>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/embedded-analytics.html">Embedded Analytics</a> in the <i>Amazon QuickSight User
/// Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDashboardEmbedUrl {
    _private: (),
}
impl GetDashboardEmbedUrl {
    /// Creates a new builder-style object to manufacture [`GetDashboardEmbedUrlInput`](crate::input::GetDashboardEmbedUrlInput)
    pub fn builder() -> crate::input::get_dashboard_embed_url_input::Builder {
        crate::input::get_dashboard_embed_url_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDashboardEmbedUrl {
    type Output = std::result::Result<
        crate::output::GetDashboardEmbedUrlOutput,
        crate::error::GetDashboardEmbedUrlError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_dashboard_embed_url_error(response)
        } else {
            crate::operation_deser::parse_get_dashboard_embed_url_response(response)
        }
    }
}

/// <p>Generates a session URL and authorization code that you can use to embed the Amazon
/// QuickSight console in your web server code. Use <code>GetSessionEmbedUrl</code> where
/// you want to provide an authoring portal that allows users to create data sources,
/// datasets, analyses, and dashboards. The users who access an embedded QuickSight console
/// need belong to the author or admin security cohort. If you want to restrict permissions
/// to some of these features, add a custom permissions profile to the user with the
/// <code>
/// <a>UpdateUser</a>
/// </code> API operation. Use <code>
/// <a>RegisterUser</a>
/// </code> API operation to add a new user with a custom permission profile attached. For more
/// information, see the following sections in the <i>Amazon QuickSight User
/// Guide</i>:</p>
/// <ul>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/quicksight/latest/user/embedding-the-quicksight-console.html">Embedding the Amazon QuickSight Console</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/quicksight/latest/user/customizing-permissions-to-the-quicksight-console.html">Customizing Access to the Amazon QuickSight Console</a>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSessionEmbedUrl {
    _private: (),
}
impl GetSessionEmbedUrl {
    /// Creates a new builder-style object to manufacture [`GetSessionEmbedUrlInput`](crate::input::GetSessionEmbedUrlInput)
    pub fn builder() -> crate::input::get_session_embed_url_input::Builder {
        crate::input::get_session_embed_url_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSessionEmbedUrl {
    type Output = std::result::Result<
        crate::output::GetSessionEmbedUrlOutput,
        crate::error::GetSessionEmbedUrlError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_session_embed_url_error(response)
        } else {
            crate::operation_deser::parse_get_session_embed_url_response(response)
        }
    }
}

/// <p>Lists Amazon QuickSight analyses that exist in the specified AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListAnalyses {
    _private: (),
}
impl ListAnalyses {
    /// Creates a new builder-style object to manufacture [`ListAnalysesInput`](crate::input::ListAnalysesInput)
    pub fn builder() -> crate::input::list_analyses_input::Builder {
        crate::input::list_analyses_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListAnalyses {
    type Output =
        std::result::Result<crate::output::ListAnalysesOutput, crate::error::ListAnalysesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_analyses_error(response)
        } else {
            crate::operation_deser::parse_list_analyses_response(response)
        }
    }
}

/// <p>Lists dashboards in an AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDashboards {
    _private: (),
}
impl ListDashboards {
    /// Creates a new builder-style object to manufacture [`ListDashboardsInput`](crate::input::ListDashboardsInput)
    pub fn builder() -> crate::input::list_dashboards_input::Builder {
        crate::input::list_dashboards_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDashboards {
    type Output =
        std::result::Result<crate::output::ListDashboardsOutput, crate::error::ListDashboardsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_dashboards_error(response)
        } else {
            crate::operation_deser::parse_list_dashboards_response(response)
        }
    }
}

/// <p>Lists all the versions of the dashboards in the QuickSight subscription.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDashboardVersions {
    _private: (),
}
impl ListDashboardVersions {
    /// Creates a new builder-style object to manufacture [`ListDashboardVersionsInput`](crate::input::ListDashboardVersionsInput)
    pub fn builder() -> crate::input::list_dashboard_versions_input::Builder {
        crate::input::list_dashboard_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDashboardVersions {
    type Output = std::result::Result<
        crate::output::ListDashboardVersionsOutput,
        crate::error::ListDashboardVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_dashboard_versions_error(response)
        } else {
            crate::operation_deser::parse_list_dashboard_versions_response(response)
        }
    }
}

/// <p>Lists all of the datasets belonging to the current AWS account in an AWS Region.</p>
/// <p>The permissions resource is <code>arn:aws:quicksight:region:aws-account-id:dataset/*</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDataSets {
    _private: (),
}
impl ListDataSets {
    /// Creates a new builder-style object to manufacture [`ListDataSetsInput`](crate::input::ListDataSetsInput)
    pub fn builder() -> crate::input::list_data_sets_input::Builder {
        crate::input::list_data_sets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDataSets {
    type Output =
        std::result::Result<crate::output::ListDataSetsOutput, crate::error::ListDataSetsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_data_sets_error(response)
        } else {
            crate::operation_deser::parse_list_data_sets_response(response)
        }
    }
}

/// <p>Lists data sources in current AWS Region that belong to this AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDataSources {
    _private: (),
}
impl ListDataSources {
    /// Creates a new builder-style object to manufacture [`ListDataSourcesInput`](crate::input::ListDataSourcesInput)
    pub fn builder() -> crate::input::list_data_sources_input::Builder {
        crate::input::list_data_sources_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDataSources {
    type Output = std::result::Result<
        crate::output::ListDataSourcesOutput,
        crate::error::ListDataSourcesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_data_sources_error(response)
        } else {
            crate::operation_deser::parse_list_data_sources_response(response)
        }
    }
}

/// <p>List all assets (<code>DASHBOARD</code>, <code>ANALYSIS</code>, and <code>DATASET</code>) in a folder. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFolderMembers {
    _private: (),
}
impl ListFolderMembers {
    /// Creates a new builder-style object to manufacture [`ListFolderMembersInput`](crate::input::ListFolderMembersInput)
    pub fn builder() -> crate::input::list_folder_members_input::Builder {
        crate::input::list_folder_members_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFolderMembers {
    type Output = std::result::Result<
        crate::output::ListFolderMembersOutput,
        crate::error::ListFolderMembersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_folder_members_error(response)
        } else {
            crate::operation_deser::parse_list_folder_members_response(response)
        }
    }
}

/// <p>Lists all folders in an account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFolders {
    _private: (),
}
impl ListFolders {
    /// Creates a new builder-style object to manufacture [`ListFoldersInput`](crate::input::ListFoldersInput)
    pub fn builder() -> crate::input::list_folders_input::Builder {
        crate::input::list_folders_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFolders {
    type Output =
        std::result::Result<crate::output::ListFoldersOutput, crate::error::ListFoldersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_folders_error(response)
        } else {
            crate::operation_deser::parse_list_folders_response(response)
        }
    }
}

/// <p>Lists member users in a group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListGroupMemberships {
    _private: (),
}
impl ListGroupMemberships {
    /// Creates a new builder-style object to manufacture [`ListGroupMembershipsInput`](crate::input::ListGroupMembershipsInput)
    pub fn builder() -> crate::input::list_group_memberships_input::Builder {
        crate::input::list_group_memberships_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListGroupMemberships {
    type Output = std::result::Result<
        crate::output::ListGroupMembershipsOutput,
        crate::error::ListGroupMembershipsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_group_memberships_error(response)
        } else {
            crate::operation_deser::parse_list_group_memberships_response(response)
        }
    }
}

/// <p>Lists all user groups in Amazon QuickSight. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListGroups {
    _private: (),
}
impl ListGroups {
    /// Creates a new builder-style object to manufacture [`ListGroupsInput`](crate::input::ListGroupsInput)
    pub fn builder() -> crate::input::list_groups_input::Builder {
        crate::input::list_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListGroups {
    type Output =
        std::result::Result<crate::output::ListGroupsOutput, crate::error::ListGroupsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_groups_error(response)
        } else {
            crate::operation_deser::parse_list_groups_response(response)
        }
    }
}

/// <p>Lists IAM policy assignments in the current Amazon QuickSight account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListIAMPolicyAssignments {
    _private: (),
}
impl ListIAMPolicyAssignments {
    /// Creates a new builder-style object to manufacture [`ListIamPolicyAssignmentsInput`](crate::input::ListIamPolicyAssignmentsInput)
    pub fn builder() -> crate::input::list_iam_policy_assignments_input::Builder {
        crate::input::list_iam_policy_assignments_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListIAMPolicyAssignments {
    type Output = std::result::Result<
        crate::output::ListIamPolicyAssignmentsOutput,
        crate::error::ListIAMPolicyAssignmentsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_iam_policy_assignments_error(response)
        } else {
            crate::operation_deser::parse_list_iam_policy_assignments_response(response)
        }
    }
}

/// <p>Lists all the IAM policy assignments, including the Amazon Resource Names (ARNs) for the IAM
/// policies assigned to the specified user and group or groups that the user belongs
/// to.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListIAMPolicyAssignmentsForUser {
    _private: (),
}
impl ListIAMPolicyAssignmentsForUser {
    /// Creates a new builder-style object to manufacture [`ListIamPolicyAssignmentsForUserInput`](crate::input::ListIamPolicyAssignmentsForUserInput)
    pub fn builder() -> crate::input::list_iam_policy_assignments_for_user_input::Builder {
        crate::input::list_iam_policy_assignments_for_user_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListIAMPolicyAssignmentsForUser {
    type Output = std::result::Result<
        crate::output::ListIamPolicyAssignmentsForUserOutput,
        crate::error::ListIAMPolicyAssignmentsForUserError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_iam_policy_assignments_for_user_error(response)
        } else {
            crate::operation_deser::parse_list_iam_policy_assignments_for_user_response(response)
        }
    }
}

/// <p>Lists the history of SPICE ingestions for a dataset.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListIngestions {
    _private: (),
}
impl ListIngestions {
    /// Creates a new builder-style object to manufacture [`ListIngestionsInput`](crate::input::ListIngestionsInput)
    pub fn builder() -> crate::input::list_ingestions_input::Builder {
        crate::input::list_ingestions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListIngestions {
    type Output =
        std::result::Result<crate::output::ListIngestionsOutput, crate::error::ListIngestionsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_ingestions_error(response)
        } else {
            crate::operation_deser::parse_list_ingestions_response(response)
        }
    }
}

/// <p>Lists the namespaces for the specified AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListNamespaces {
    _private: (),
}
impl ListNamespaces {
    /// Creates a new builder-style object to manufacture [`ListNamespacesInput`](crate::input::ListNamespacesInput)
    pub fn builder() -> crate::input::list_namespaces_input::Builder {
        crate::input::list_namespaces_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListNamespaces {
    type Output =
        std::result::Result<crate::output::ListNamespacesOutput, crate::error::ListNamespacesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_namespaces_error(response)
        } else {
            crate::operation_deser::parse_list_namespaces_response(response)
        }
    }
}

/// <p>Lists the tags assigned to a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Lists all the aliases of a template.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTemplateAliases {
    _private: (),
}
impl ListTemplateAliases {
    /// Creates a new builder-style object to manufacture [`ListTemplateAliasesInput`](crate::input::ListTemplateAliasesInput)
    pub fn builder() -> crate::input::list_template_aliases_input::Builder {
        crate::input::list_template_aliases_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTemplateAliases {
    type Output = std::result::Result<
        crate::output::ListTemplateAliasesOutput,
        crate::error::ListTemplateAliasesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_template_aliases_error(response)
        } else {
            crate::operation_deser::parse_list_template_aliases_response(response)
        }
    }
}

/// <p>Lists all the templates in the current Amazon QuickSight account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTemplates {
    _private: (),
}
impl ListTemplates {
    /// Creates a new builder-style object to manufacture [`ListTemplatesInput`](crate::input::ListTemplatesInput)
    pub fn builder() -> crate::input::list_templates_input::Builder {
        crate::input::list_templates_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTemplates {
    type Output =
        std::result::Result<crate::output::ListTemplatesOutput, crate::error::ListTemplatesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_templates_error(response)
        } else {
            crate::operation_deser::parse_list_templates_response(response)
        }
    }
}

/// <p>Lists all the versions of the templates in the current Amazon QuickSight account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTemplateVersions {
    _private: (),
}
impl ListTemplateVersions {
    /// Creates a new builder-style object to manufacture [`ListTemplateVersionsInput`](crate::input::ListTemplateVersionsInput)
    pub fn builder() -> crate::input::list_template_versions_input::Builder {
        crate::input::list_template_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTemplateVersions {
    type Output = std::result::Result<
        crate::output::ListTemplateVersionsOutput,
        crate::error::ListTemplateVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_template_versions_error(response)
        } else {
            crate::operation_deser::parse_list_template_versions_response(response)
        }
    }
}

/// <p>Lists all the aliases of a theme.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListThemeAliases {
    _private: (),
}
impl ListThemeAliases {
    /// Creates a new builder-style object to manufacture [`ListThemeAliasesInput`](crate::input::ListThemeAliasesInput)
    pub fn builder() -> crate::input::list_theme_aliases_input::Builder {
        crate::input::list_theme_aliases_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListThemeAliases {
    type Output = std::result::Result<
        crate::output::ListThemeAliasesOutput,
        crate::error::ListThemeAliasesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_theme_aliases_error(response)
        } else {
            crate::operation_deser::parse_list_theme_aliases_response(response)
        }
    }
}

/// <p>Lists all the themes in the current AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListThemes {
    _private: (),
}
impl ListThemes {
    /// Creates a new builder-style object to manufacture [`ListThemesInput`](crate::input::ListThemesInput)
    pub fn builder() -> crate::input::list_themes_input::Builder {
        crate::input::list_themes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListThemes {
    type Output =
        std::result::Result<crate::output::ListThemesOutput, crate::error::ListThemesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_themes_error(response)
        } else {
            crate::operation_deser::parse_list_themes_response(response)
        }
    }
}

/// <p>Lists all the versions of the themes in the current AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListThemeVersions {
    _private: (),
}
impl ListThemeVersions {
    /// Creates a new builder-style object to manufacture [`ListThemeVersionsInput`](crate::input::ListThemeVersionsInput)
    pub fn builder() -> crate::input::list_theme_versions_input::Builder {
        crate::input::list_theme_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListThemeVersions {
    type Output = std::result::Result<
        crate::output::ListThemeVersionsOutput,
        crate::error::ListThemeVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_theme_versions_error(response)
        } else {
            crate::operation_deser::parse_list_theme_versions_response(response)
        }
    }
}

/// <p>Lists the Amazon QuickSight groups that an Amazon QuickSight user is a member of.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListUserGroups {
    _private: (),
}
impl ListUserGroups {
    /// Creates a new builder-style object to manufacture [`ListUserGroupsInput`](crate::input::ListUserGroupsInput)
    pub fn builder() -> crate::input::list_user_groups_input::Builder {
        crate::input::list_user_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListUserGroups {
    type Output =
        std::result::Result<crate::output::ListUserGroupsOutput, crate::error::ListUserGroupsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_user_groups_error(response)
        } else {
            crate::operation_deser::parse_list_user_groups_response(response)
        }
    }
}

/// <p>Returns a list of all of the Amazon QuickSight users belonging to this account. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListUsers {
    _private: (),
}
impl ListUsers {
    /// Creates a new builder-style object to manufacture [`ListUsersInput`](crate::input::ListUsersInput)
    pub fn builder() -> crate::input::list_users_input::Builder {
        crate::input::list_users_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListUsers {
    type Output = std::result::Result<crate::output::ListUsersOutput, crate::error::ListUsersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_users_error(response)
        } else {
            crate::operation_deser::parse_list_users_response(response)
        }
    }
}

/// <p>Creates an Amazon QuickSight user, whose identity is associated with the AWS Identity
/// and Access Management (IAM) identity or role specified in the request. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterUser {
    _private: (),
}
impl RegisterUser {
    /// Creates a new builder-style object to manufacture [`RegisterUserInput`](crate::input::RegisterUserInput)
    pub fn builder() -> crate::input::register_user_input::Builder {
        crate::input::register_user_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RegisterUser {
    type Output =
        std::result::Result<crate::output::RegisterUserOutput, crate::error::RegisterUserError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_register_user_error(response)
        } else {
            crate::operation_deser::parse_register_user_response(response)
        }
    }
}

/// <p>Restores an analysis.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RestoreAnalysis {
    _private: (),
}
impl RestoreAnalysis {
    /// Creates a new builder-style object to manufacture [`RestoreAnalysisInput`](crate::input::RestoreAnalysisInput)
    pub fn builder() -> crate::input::restore_analysis_input::Builder {
        crate::input::restore_analysis_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RestoreAnalysis {
    type Output = std::result::Result<
        crate::output::RestoreAnalysisOutput,
        crate::error::RestoreAnalysisError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_restore_analysis_error(response)
        } else {
            crate::operation_deser::parse_restore_analysis_response(response)
        }
    }
}

/// <p>Searches for analyses that belong to the user specified in the filter.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SearchAnalyses {
    _private: (),
}
impl SearchAnalyses {
    /// Creates a new builder-style object to manufacture [`SearchAnalysesInput`](crate::input::SearchAnalysesInput)
    pub fn builder() -> crate::input::search_analyses_input::Builder {
        crate::input::search_analyses_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SearchAnalyses {
    type Output =
        std::result::Result<crate::output::SearchAnalysesOutput, crate::error::SearchAnalysesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_search_analyses_error(response)
        } else {
            crate::operation_deser::parse_search_analyses_response(response)
        }
    }
}

/// <p>Searches for dashboards that belong to a user. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SearchDashboards {
    _private: (),
}
impl SearchDashboards {
    /// Creates a new builder-style object to manufacture [`SearchDashboardsInput`](crate::input::SearchDashboardsInput)
    pub fn builder() -> crate::input::search_dashboards_input::Builder {
        crate::input::search_dashboards_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SearchDashboards {
    type Output = std::result::Result<
        crate::output::SearchDashboardsOutput,
        crate::error::SearchDashboardsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_search_dashboards_error(response)
        } else {
            crate::operation_deser::parse_search_dashboards_response(response)
        }
    }
}

/// <p>Searches the subfolders in a folder.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SearchFolders {
    _private: (),
}
impl SearchFolders {
    /// Creates a new builder-style object to manufacture [`SearchFoldersInput`](crate::input::SearchFoldersInput)
    pub fn builder() -> crate::input::search_folders_input::Builder {
        crate::input::search_folders_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SearchFolders {
    type Output =
        std::result::Result<crate::output::SearchFoldersOutput, crate::error::SearchFoldersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_search_folders_error(response)
        } else {
            crate::operation_deser::parse_search_folders_response(response)
        }
    }
}

/// <p>Assigns one or more tags (key-value pairs) to the specified QuickSight resource. </p>
/// <p>Tags can help you organize and categorize your resources. You can also use them to
/// scope user permissions, by granting a user permission to access or change only resources
/// with certain tag values. You can use the <code>TagResource</code> operation with a
/// resource that already has tags. If you specify a new tag key for the resource, this tag
/// is appended to the list of tags associated with the resource. If you specify a tag key
/// that is already associated with the resource, the new tag value that you specify
/// replaces the previous value for that tag.</p>
/// <p>You can associate as many as 50 tags with a resource. QuickSight supports tagging on data
/// set, data source, dashboard, and template. </p>
/// <p>Tagging for QuickSight works in a similar way to tagging for other AWS services, except for
/// the following:</p>
/// <ul>
/// <li>
/// <p>You can't use tags to track AWS costs for QuickSight. This restriction is because QuickSight
/// costs are based on users and SPICE capacity, which aren't taggable
/// resources.</p>
/// </li>
/// <li>
/// <p>QuickSight doesn't currently support the Tag Editor for AWS Resource Groups.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes a tag or tags from a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates Amazon QuickSight customizations the current AWS Region. Currently, the only
/// customization you can use is a theme.</p>
/// <p>You can use customizations for your AWS account or, if you specify a namespace, for a
/// QuickSight namespace instead. Customizations that apply to a namespace override
/// customizations that apply to an AWS account. To find out which customizations apply, use
/// the <code>DescribeAccountCustomization</code> API operation. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateAccountCustomization {
    _private: (),
}
impl UpdateAccountCustomization {
    /// Creates a new builder-style object to manufacture [`UpdateAccountCustomizationInput`](crate::input::UpdateAccountCustomizationInput)
    pub fn builder() -> crate::input::update_account_customization_input::Builder {
        crate::input::update_account_customization_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateAccountCustomization {
    type Output = std::result::Result<
        crate::output::UpdateAccountCustomizationOutput,
        crate::error::UpdateAccountCustomizationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_account_customization_error(response)
        } else {
            crate::operation_deser::parse_update_account_customization_response(response)
        }
    }
}

/// <p>Updates the Amazon QuickSight settings in your AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateAccountSettings {
    _private: (),
}
impl UpdateAccountSettings {
    /// Creates a new builder-style object to manufacture [`UpdateAccountSettingsInput`](crate::input::UpdateAccountSettingsInput)
    pub fn builder() -> crate::input::update_account_settings_input::Builder {
        crate::input::update_account_settings_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateAccountSettings {
    type Output = std::result::Result<
        crate::output::UpdateAccountSettingsOutput,
        crate::error::UpdateAccountSettingsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_account_settings_error(response)
        } else {
            crate::operation_deser::parse_update_account_settings_response(response)
        }
    }
}

/// <p>Updates an analysis in Amazon QuickSight</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateAnalysis {
    _private: (),
}
impl UpdateAnalysis {
    /// Creates a new builder-style object to manufacture [`UpdateAnalysisInput`](crate::input::UpdateAnalysisInput)
    pub fn builder() -> crate::input::update_analysis_input::Builder {
        crate::input::update_analysis_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateAnalysis {
    type Output =
        std::result::Result<crate::output::UpdateAnalysisOutput, crate::error::UpdateAnalysisError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_analysis_error(response)
        } else {
            crate::operation_deser::parse_update_analysis_response(response)
        }
    }
}

/// <p>Updates the read and write permissions for an analysis.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateAnalysisPermissions {
    _private: (),
}
impl UpdateAnalysisPermissions {
    /// Creates a new builder-style object to manufacture [`UpdateAnalysisPermissionsInput`](crate::input::UpdateAnalysisPermissionsInput)
    pub fn builder() -> crate::input::update_analysis_permissions_input::Builder {
        crate::input::update_analysis_permissions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateAnalysisPermissions {
    type Output = std::result::Result<
        crate::output::UpdateAnalysisPermissionsOutput,
        crate::error::UpdateAnalysisPermissionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_analysis_permissions_error(response)
        } else {
            crate::operation_deser::parse_update_analysis_permissions_response(response)
        }
    }
}

/// <p>Updates a dashboard in an AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDashboard {
    _private: (),
}
impl UpdateDashboard {
    /// Creates a new builder-style object to manufacture [`UpdateDashboardInput`](crate::input::UpdateDashboardInput)
    pub fn builder() -> crate::input::update_dashboard_input::Builder {
        crate::input::update_dashboard_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDashboard {
    type Output = std::result::Result<
        crate::output::UpdateDashboardOutput,
        crate::error::UpdateDashboardError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_dashboard_error(response)
        } else {
            crate::operation_deser::parse_update_dashboard_response(response)
        }
    }
}

/// <p>Updates read and write permissions on a dashboard.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDashboardPermissions {
    _private: (),
}
impl UpdateDashboardPermissions {
    /// Creates a new builder-style object to manufacture [`UpdateDashboardPermissionsInput`](crate::input::UpdateDashboardPermissionsInput)
    pub fn builder() -> crate::input::update_dashboard_permissions_input::Builder {
        crate::input::update_dashboard_permissions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDashboardPermissions {
    type Output = std::result::Result<
        crate::output::UpdateDashboardPermissionsOutput,
        crate::error::UpdateDashboardPermissionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_dashboard_permissions_error(response)
        } else {
            crate::operation_deser::parse_update_dashboard_permissions_response(response)
        }
    }
}

/// <p>Updates the published version of a dashboard.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDashboardPublishedVersion {
    _private: (),
}
impl UpdateDashboardPublishedVersion {
    /// Creates a new builder-style object to manufacture [`UpdateDashboardPublishedVersionInput`](crate::input::UpdateDashboardPublishedVersionInput)
    pub fn builder() -> crate::input::update_dashboard_published_version_input::Builder {
        crate::input::update_dashboard_published_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDashboardPublishedVersion {
    type Output = std::result::Result<
        crate::output::UpdateDashboardPublishedVersionOutput,
        crate::error::UpdateDashboardPublishedVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_dashboard_published_version_error(response)
        } else {
            crate::operation_deser::parse_update_dashboard_published_version_response(response)
        }
    }
}

/// <p>Updates a dataset.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDataSet {
    _private: (),
}
impl UpdateDataSet {
    /// Creates a new builder-style object to manufacture [`UpdateDataSetInput`](crate::input::UpdateDataSetInput)
    pub fn builder() -> crate::input::update_data_set_input::Builder {
        crate::input::update_data_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDataSet {
    type Output =
        std::result::Result<crate::output::UpdateDataSetOutput, crate::error::UpdateDataSetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_data_set_error(response)
        } else {
            crate::operation_deser::parse_update_data_set_response(response)
        }
    }
}

/// <p>Updates the permissions on a dataset.</p>
/// <p>The permissions resource is <code>arn:aws:quicksight:region:aws-account-id:dataset/data-set-id</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDataSetPermissions {
    _private: (),
}
impl UpdateDataSetPermissions {
    /// Creates a new builder-style object to manufacture [`UpdateDataSetPermissionsInput`](crate::input::UpdateDataSetPermissionsInput)
    pub fn builder() -> crate::input::update_data_set_permissions_input::Builder {
        crate::input::update_data_set_permissions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDataSetPermissions {
    type Output = std::result::Result<
        crate::output::UpdateDataSetPermissionsOutput,
        crate::error::UpdateDataSetPermissionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_data_set_permissions_error(response)
        } else {
            crate::operation_deser::parse_update_data_set_permissions_response(response)
        }
    }
}

/// <p>Updates a data source.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDataSource {
    _private: (),
}
impl UpdateDataSource {
    /// Creates a new builder-style object to manufacture [`UpdateDataSourceInput`](crate::input::UpdateDataSourceInput)
    pub fn builder() -> crate::input::update_data_source_input::Builder {
        crate::input::update_data_source_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDataSource {
    type Output = std::result::Result<
        crate::output::UpdateDataSourceOutput,
        crate::error::UpdateDataSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_data_source_error(response)
        } else {
            crate::operation_deser::parse_update_data_source_response(response)
        }
    }
}

/// <p>Updates the permissions to a data source.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDataSourcePermissions {
    _private: (),
}
impl UpdateDataSourcePermissions {
    /// Creates a new builder-style object to manufacture [`UpdateDataSourcePermissionsInput`](crate::input::UpdateDataSourcePermissionsInput)
    pub fn builder() -> crate::input::update_data_source_permissions_input::Builder {
        crate::input::update_data_source_permissions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDataSourcePermissions {
    type Output = std::result::Result<
        crate::output::UpdateDataSourcePermissionsOutput,
        crate::error::UpdateDataSourcePermissionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_data_source_permissions_error(response)
        } else {
            crate::operation_deser::parse_update_data_source_permissions_response(response)
        }
    }
}

/// <p>Updates the name of a folder.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateFolder {
    _private: (),
}
impl UpdateFolder {
    /// Creates a new builder-style object to manufacture [`UpdateFolderInput`](crate::input::UpdateFolderInput)
    pub fn builder() -> crate::input::update_folder_input::Builder {
        crate::input::update_folder_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateFolder {
    type Output =
        std::result::Result<crate::output::UpdateFolderOutput, crate::error::UpdateFolderError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_folder_error(response)
        } else {
            crate::operation_deser::parse_update_folder_response(response)
        }
    }
}

/// <p>Updates permissions of a folder.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateFolderPermissions {
    _private: (),
}
impl UpdateFolderPermissions {
    /// Creates a new builder-style object to manufacture [`UpdateFolderPermissionsInput`](crate::input::UpdateFolderPermissionsInput)
    pub fn builder() -> crate::input::update_folder_permissions_input::Builder {
        crate::input::update_folder_permissions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateFolderPermissions {
    type Output = std::result::Result<
        crate::output::UpdateFolderPermissionsOutput,
        crate::error::UpdateFolderPermissionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_folder_permissions_error(response)
        } else {
            crate::operation_deser::parse_update_folder_permissions_response(response)
        }
    }
}

/// <p>Changes a group description. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateGroup {
    _private: (),
}
impl UpdateGroup {
    /// Creates a new builder-style object to manufacture [`UpdateGroupInput`](crate::input::UpdateGroupInput)
    pub fn builder() -> crate::input::update_group_input::Builder {
        crate::input::update_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateGroup {
    type Output =
        std::result::Result<crate::output::UpdateGroupOutput, crate::error::UpdateGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_group_error(response)
        } else {
            crate::operation_deser::parse_update_group_response(response)
        }
    }
}

/// <p>Updates an existing IAM policy assignment. This operation updates only the optional
/// parameter or parameters that are specified in the request.
/// This overwrites all of the users included in <code>Identities</code>.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateIAMPolicyAssignment {
    _private: (),
}
impl UpdateIAMPolicyAssignment {
    /// Creates a new builder-style object to manufacture [`UpdateIamPolicyAssignmentInput`](crate::input::UpdateIamPolicyAssignmentInput)
    pub fn builder() -> crate::input::update_iam_policy_assignment_input::Builder {
        crate::input::update_iam_policy_assignment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateIAMPolicyAssignment {
    type Output = std::result::Result<
        crate::output::UpdateIamPolicyAssignmentOutput,
        crate::error::UpdateIAMPolicyAssignmentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_iam_policy_assignment_error(response)
        } else {
            crate::operation_deser::parse_update_iam_policy_assignment_response(response)
        }
    }
}

/// <p>Updates a template from an existing Amazon QuickSight analysis or another template.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateTemplate {
    _private: (),
}
impl UpdateTemplate {
    /// Creates a new builder-style object to manufacture [`UpdateTemplateInput`](crate::input::UpdateTemplateInput)
    pub fn builder() -> crate::input::update_template_input::Builder {
        crate::input::update_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateTemplate {
    type Output =
        std::result::Result<crate::output::UpdateTemplateOutput, crate::error::UpdateTemplateError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_template_error(response)
        } else {
            crate::operation_deser::parse_update_template_response(response)
        }
    }
}

/// <p>Updates the template alias of a template.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateTemplateAlias {
    _private: (),
}
impl UpdateTemplateAlias {
    /// Creates a new builder-style object to manufacture [`UpdateTemplateAliasInput`](crate::input::UpdateTemplateAliasInput)
    pub fn builder() -> crate::input::update_template_alias_input::Builder {
        crate::input::update_template_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateTemplateAlias {
    type Output = std::result::Result<
        crate::output::UpdateTemplateAliasOutput,
        crate::error::UpdateTemplateAliasError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_template_alias_error(response)
        } else {
            crate::operation_deser::parse_update_template_alias_response(response)
        }
    }
}

/// <p>Updates the resource permissions for a template.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateTemplatePermissions {
    _private: (),
}
impl UpdateTemplatePermissions {
    /// Creates a new builder-style object to manufacture [`UpdateTemplatePermissionsInput`](crate::input::UpdateTemplatePermissionsInput)
    pub fn builder() -> crate::input::update_template_permissions_input::Builder {
        crate::input::update_template_permissions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateTemplatePermissions {
    type Output = std::result::Result<
        crate::output::UpdateTemplatePermissionsOutput,
        crate::error::UpdateTemplatePermissionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_template_permissions_error(response)
        } else {
            crate::operation_deser::parse_update_template_permissions_response(response)
        }
    }
}

/// <p>Updates a theme.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateTheme {
    _private: (),
}
impl UpdateTheme {
    /// Creates a new builder-style object to manufacture [`UpdateThemeInput`](crate::input::UpdateThemeInput)
    pub fn builder() -> crate::input::update_theme_input::Builder {
        crate::input::update_theme_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateTheme {
    type Output =
        std::result::Result<crate::output::UpdateThemeOutput, crate::error::UpdateThemeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_theme_error(response)
        } else {
            crate::operation_deser::parse_update_theme_response(response)
        }
    }
}

/// <p>Updates an alias of a theme.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateThemeAlias {
    _private: (),
}
impl UpdateThemeAlias {
    /// Creates a new builder-style object to manufacture [`UpdateThemeAliasInput`](crate::input::UpdateThemeAliasInput)
    pub fn builder() -> crate::input::update_theme_alias_input::Builder {
        crate::input::update_theme_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateThemeAlias {
    type Output = std::result::Result<
        crate::output::UpdateThemeAliasOutput,
        crate::error::UpdateThemeAliasError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_theme_alias_error(response)
        } else {
            crate::operation_deser::parse_update_theme_alias_response(response)
        }
    }
}

/// <p>Updates the resource permissions for a theme. Permissions apply to the action to grant or
/// revoke permissions on, for example <code>"quicksight:DescribeTheme"</code>.</p>
/// <p>Theme permissions apply in groupings. Valid groupings include the following for the three
/// levels of permissions, which are user, owner, or no permissions: </p>
/// <ul>
/// <li>
/// <p>User</p>
/// <ul>
/// <li>
/// <p>
/// <code>"quicksight:DescribeTheme"</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>"quicksight:DescribeThemeAlias"</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>"quicksight:ListThemeAliases"</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>"quicksight:ListThemeVersions"</code>
/// </p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Owner</p>
/// <ul>
/// <li>
/// <p>
/// <code>"quicksight:DescribeTheme"</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>"quicksight:DescribeThemeAlias"</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>"quicksight:ListThemeAliases"</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>"quicksight:ListThemeVersions"</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>"quicksight:DeleteTheme"</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>"quicksight:UpdateTheme"</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>"quicksight:CreateThemeAlias"</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>"quicksight:DeleteThemeAlias"</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>"quicksight:UpdateThemeAlias"</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>"quicksight:UpdateThemePermissions"</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>"quicksight:DescribeThemePermissions"</code>
/// </p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>To specify no permissions, omit the permissions list.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateThemePermissions {
    _private: (),
}
impl UpdateThemePermissions {
    /// Creates a new builder-style object to manufacture [`UpdateThemePermissionsInput`](crate::input::UpdateThemePermissionsInput)
    pub fn builder() -> crate::input::update_theme_permissions_input::Builder {
        crate::input::update_theme_permissions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateThemePermissions {
    type Output = std::result::Result<
        crate::output::UpdateThemePermissionsOutput,
        crate::error::UpdateThemePermissionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_theme_permissions_error(response)
        } else {
            crate::operation_deser::parse_update_theme_permissions_response(response)
        }
    }
}

/// <p>Updates an Amazon QuickSight user.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateUser {
    _private: (),
}
impl UpdateUser {
    /// Creates a new builder-style object to manufacture [`UpdateUserInput`](crate::input::UpdateUserInput)
    pub fn builder() -> crate::input::update_user_input::Builder {
        crate::input::update_user_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateUser {
    type Output =
        std::result::Result<crate::output::UpdateUserOutput, crate::error::UpdateUserError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_user_error(response)
        } else {
            crate::operation_deser::parse_update_user_response(response)
        }
    }
}
