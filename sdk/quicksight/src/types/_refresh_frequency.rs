// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Specifies the interval between each scheduled refresh of a dataset.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct RefreshFrequency {
    /// <p>The interval between scheduled refreshes. Valid values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>MINUTE15</code>: The dataset refreshes every 15 minutes. This value is only supported for incremental refreshes. This interval can only be used for one schedule per dataset.</p> </li>
    /// <li> <p> <code>MINUTE30</code>:The dataset refreshes every 30 minutes. This value is only supported for incremental refreshes. This interval can only be used for one schedule per dataset.</p> </li>
    /// <li> <p> <code>HOURLY</code>: The dataset refreshes every hour. This interval can only be used for one schedule per dataset.</p> </li>
    /// <li> <p> <code>DAILY</code>: The dataset refreshes every day.</p> </li>
    /// <li> <p> <code>WEEKLY</code>: The dataset refreshes every week.</p> </li>
    /// <li> <p> <code>MONTHLY</code>: The dataset refreshes every month.</p> </li>
    /// </ul>
    pub interval: crate::types::RefreshInterval,
    /// <p>The day of the week that you want to schedule the refresh on. This value is required for weekly and monthly refresh intervals.</p>
    pub refresh_on_day: ::std::option::Option<crate::types::ScheduleRefreshOnEntity>,
    /// <p>The timezone that you want the refresh schedule to use. The timezone ID must match a corresponding ID found on <code>java.util.time.getAvailableIDs()</code>.</p>
    pub timezone: ::std::option::Option<::std::string::String>,
    /// <p>The time of day that you want the datset to refresh. This value is expressed in HH:MM format. This field is not required for schedules that refresh hourly.</p>
    pub time_of_the_day: ::std::option::Option<::std::string::String>,
}
impl RefreshFrequency {
    /// <p>The interval between scheduled refreshes. Valid values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>MINUTE15</code>: The dataset refreshes every 15 minutes. This value is only supported for incremental refreshes. This interval can only be used for one schedule per dataset.</p> </li>
    /// <li> <p> <code>MINUTE30</code>:The dataset refreshes every 30 minutes. This value is only supported for incremental refreshes. This interval can only be used for one schedule per dataset.</p> </li>
    /// <li> <p> <code>HOURLY</code>: The dataset refreshes every hour. This interval can only be used for one schedule per dataset.</p> </li>
    /// <li> <p> <code>DAILY</code>: The dataset refreshes every day.</p> </li>
    /// <li> <p> <code>WEEKLY</code>: The dataset refreshes every week.</p> </li>
    /// <li> <p> <code>MONTHLY</code>: The dataset refreshes every month.</p> </li>
    /// </ul>
    pub fn interval(&self) -> &crate::types::RefreshInterval {
        &self.interval
    }
    /// <p>The day of the week that you want to schedule the refresh on. This value is required for weekly and monthly refresh intervals.</p>
    pub fn refresh_on_day(&self) -> ::std::option::Option<&crate::types::ScheduleRefreshOnEntity> {
        self.refresh_on_day.as_ref()
    }
    /// <p>The timezone that you want the refresh schedule to use. The timezone ID must match a corresponding ID found on <code>java.util.time.getAvailableIDs()</code>.</p>
    pub fn timezone(&self) -> ::std::option::Option<&str> {
        self.timezone.as_deref()
    }
    /// <p>The time of day that you want the datset to refresh. This value is expressed in HH:MM format. This field is not required for schedules that refresh hourly.</p>
    pub fn time_of_the_day(&self) -> ::std::option::Option<&str> {
        self.time_of_the_day.as_deref()
    }
}
impl RefreshFrequency {
    /// Creates a new builder-style object to manufacture [`RefreshFrequency`](crate::types::RefreshFrequency).
    pub fn builder() -> crate::types::builders::RefreshFrequencyBuilder {
        crate::types::builders::RefreshFrequencyBuilder::default()
    }
}

/// A builder for [`RefreshFrequency`](crate::types::RefreshFrequency).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct RefreshFrequencyBuilder {
    pub(crate) interval: ::std::option::Option<crate::types::RefreshInterval>,
    pub(crate) refresh_on_day: ::std::option::Option<crate::types::ScheduleRefreshOnEntity>,
    pub(crate) timezone: ::std::option::Option<::std::string::String>,
    pub(crate) time_of_the_day: ::std::option::Option<::std::string::String>,
}
impl RefreshFrequencyBuilder {
    /// <p>The interval between scheduled refreshes. Valid values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>MINUTE15</code>: The dataset refreshes every 15 minutes. This value is only supported for incremental refreshes. This interval can only be used for one schedule per dataset.</p> </li>
    /// <li> <p> <code>MINUTE30</code>:The dataset refreshes every 30 minutes. This value is only supported for incremental refreshes. This interval can only be used for one schedule per dataset.</p> </li>
    /// <li> <p> <code>HOURLY</code>: The dataset refreshes every hour. This interval can only be used for one schedule per dataset.</p> </li>
    /// <li> <p> <code>DAILY</code>: The dataset refreshes every day.</p> </li>
    /// <li> <p> <code>WEEKLY</code>: The dataset refreshes every week.</p> </li>
    /// <li> <p> <code>MONTHLY</code>: The dataset refreshes every month.</p> </li>
    /// </ul>
    /// This field is required.
    pub fn interval(mut self, input: crate::types::RefreshInterval) -> Self {
        self.interval = ::std::option::Option::Some(input);
        self
    }
    /// <p>The interval between scheduled refreshes. Valid values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>MINUTE15</code>: The dataset refreshes every 15 minutes. This value is only supported for incremental refreshes. This interval can only be used for one schedule per dataset.</p> </li>
    /// <li> <p> <code>MINUTE30</code>:The dataset refreshes every 30 minutes. This value is only supported for incremental refreshes. This interval can only be used for one schedule per dataset.</p> </li>
    /// <li> <p> <code>HOURLY</code>: The dataset refreshes every hour. This interval can only be used for one schedule per dataset.</p> </li>
    /// <li> <p> <code>DAILY</code>: The dataset refreshes every day.</p> </li>
    /// <li> <p> <code>WEEKLY</code>: The dataset refreshes every week.</p> </li>
    /// <li> <p> <code>MONTHLY</code>: The dataset refreshes every month.</p> </li>
    /// </ul>
    pub fn set_interval(mut self, input: ::std::option::Option<crate::types::RefreshInterval>) -> Self {
        self.interval = input;
        self
    }
    /// <p>The interval between scheduled refreshes. Valid values are as follows:</p>
    /// <ul>
    /// <li> <p> <code>MINUTE15</code>: The dataset refreshes every 15 minutes. This value is only supported for incremental refreshes. This interval can only be used for one schedule per dataset.</p> </li>
    /// <li> <p> <code>MINUTE30</code>:The dataset refreshes every 30 minutes. This value is only supported for incremental refreshes. This interval can only be used for one schedule per dataset.</p> </li>
    /// <li> <p> <code>HOURLY</code>: The dataset refreshes every hour. This interval can only be used for one schedule per dataset.</p> </li>
    /// <li> <p> <code>DAILY</code>: The dataset refreshes every day.</p> </li>
    /// <li> <p> <code>WEEKLY</code>: The dataset refreshes every week.</p> </li>
    /// <li> <p> <code>MONTHLY</code>: The dataset refreshes every month.</p> </li>
    /// </ul>
    pub fn get_interval(&self) -> &::std::option::Option<crate::types::RefreshInterval> {
        &self.interval
    }
    /// <p>The day of the week that you want to schedule the refresh on. This value is required for weekly and monthly refresh intervals.</p>
    pub fn refresh_on_day(mut self, input: crate::types::ScheduleRefreshOnEntity) -> Self {
        self.refresh_on_day = ::std::option::Option::Some(input);
        self
    }
    /// <p>The day of the week that you want to schedule the refresh on. This value is required for weekly and monthly refresh intervals.</p>
    pub fn set_refresh_on_day(mut self, input: ::std::option::Option<crate::types::ScheduleRefreshOnEntity>) -> Self {
        self.refresh_on_day = input;
        self
    }
    /// <p>The day of the week that you want to schedule the refresh on. This value is required for weekly and monthly refresh intervals.</p>
    pub fn get_refresh_on_day(&self) -> &::std::option::Option<crate::types::ScheduleRefreshOnEntity> {
        &self.refresh_on_day
    }
    /// <p>The timezone that you want the refresh schedule to use. The timezone ID must match a corresponding ID found on <code>java.util.time.getAvailableIDs()</code>.</p>
    pub fn timezone(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.timezone = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The timezone that you want the refresh schedule to use. The timezone ID must match a corresponding ID found on <code>java.util.time.getAvailableIDs()</code>.</p>
    pub fn set_timezone(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.timezone = input;
        self
    }
    /// <p>The timezone that you want the refresh schedule to use. The timezone ID must match a corresponding ID found on <code>java.util.time.getAvailableIDs()</code>.</p>
    pub fn get_timezone(&self) -> &::std::option::Option<::std::string::String> {
        &self.timezone
    }
    /// <p>The time of day that you want the datset to refresh. This value is expressed in HH:MM format. This field is not required for schedules that refresh hourly.</p>
    pub fn time_of_the_day(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.time_of_the_day = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The time of day that you want the datset to refresh. This value is expressed in HH:MM format. This field is not required for schedules that refresh hourly.</p>
    pub fn set_time_of_the_day(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.time_of_the_day = input;
        self
    }
    /// <p>The time of day that you want the datset to refresh. This value is expressed in HH:MM format. This field is not required for schedules that refresh hourly.</p>
    pub fn get_time_of_the_day(&self) -> &::std::option::Option<::std::string::String> {
        &self.time_of_the_day
    }
    /// Consumes the builder and constructs a [`RefreshFrequency`](crate::types::RefreshFrequency).
    /// This method will fail if any of the following fields are not set:
    /// - [`interval`](crate::types::builders::RefreshFrequencyBuilder::interval)
    pub fn build(self) -> ::std::result::Result<crate::types::RefreshFrequency, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::RefreshFrequency {
            interval: self.interval.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "interval",
                    "interval was not specified but it is required when building RefreshFrequency",
                )
            })?,
            refresh_on_day: self.refresh_on_day,
            timezone: self.timezone,
            time_of_the_day: self.time_of_the_day,
        })
    }
}
