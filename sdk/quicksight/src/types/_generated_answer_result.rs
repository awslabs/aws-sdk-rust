// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The QA result that is made from generated answer.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct GeneratedAnswerResult {
    /// <p>The question text.</p>
    pub question_text: ::std::option::Option<::std::string::String>,
    /// <p>The answer status of the generated answer.</p>
    pub answer_status: ::std::option::Option<crate::types::GeneratedAnswerStatus>,
    /// <p>The ID of the topic.</p>
    pub topic_id: ::std::option::Option<::std::string::String>,
    /// <p>The name of the topic.</p>
    pub topic_name: ::std::option::Option<::std::string::String>,
    /// <p>The restatement for the answer.</p>
    pub restatement: ::std::option::Option<::std::string::String>,
    /// <p>The ID of the question.</p>
    pub question_id: ::std::option::Option<::std::string::String>,
    /// <p>The ID of the answer.</p>
    pub answer_id: ::std::option::Option<::std::string::String>,
    /// <p>The URL of the question.</p>
    pub question_url: ::std::option::Option<::std::string::String>,
}
impl GeneratedAnswerResult {
    /// <p>The question text.</p>
    pub fn question_text(&self) -> ::std::option::Option<&str> {
        self.question_text.as_deref()
    }
    /// <p>The answer status of the generated answer.</p>
    pub fn answer_status(&self) -> ::std::option::Option<&crate::types::GeneratedAnswerStatus> {
        self.answer_status.as_ref()
    }
    /// <p>The ID of the topic.</p>
    pub fn topic_id(&self) -> ::std::option::Option<&str> {
        self.topic_id.as_deref()
    }
    /// <p>The name of the topic.</p>
    pub fn topic_name(&self) -> ::std::option::Option<&str> {
        self.topic_name.as_deref()
    }
    /// <p>The restatement for the answer.</p>
    pub fn restatement(&self) -> ::std::option::Option<&str> {
        self.restatement.as_deref()
    }
    /// <p>The ID of the question.</p>
    pub fn question_id(&self) -> ::std::option::Option<&str> {
        self.question_id.as_deref()
    }
    /// <p>The ID of the answer.</p>
    pub fn answer_id(&self) -> ::std::option::Option<&str> {
        self.answer_id.as_deref()
    }
    /// <p>The URL of the question.</p>
    pub fn question_url(&self) -> ::std::option::Option<&str> {
        self.question_url.as_deref()
    }
}
impl ::std::fmt::Debug for GeneratedAnswerResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("GeneratedAnswerResult");
        formatter.field("question_text", &"*** Sensitive Data Redacted ***");
        formatter.field("answer_status", &self.answer_status);
        formatter.field("topic_id", &self.topic_id);
        formatter.field("topic_name", &self.topic_name);
        formatter.field("restatement", &"*** Sensitive Data Redacted ***");
        formatter.field("question_id", &self.question_id);
        formatter.field("answer_id", &self.answer_id);
        formatter.field("question_url", &self.question_url);
        formatter.finish()
    }
}
impl GeneratedAnswerResult {
    /// Creates a new builder-style object to manufacture [`GeneratedAnswerResult`](crate::types::GeneratedAnswerResult).
    pub fn builder() -> crate::types::builders::GeneratedAnswerResultBuilder {
        crate::types::builders::GeneratedAnswerResultBuilder::default()
    }
}

/// A builder for [`GeneratedAnswerResult`](crate::types::GeneratedAnswerResult).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct GeneratedAnswerResultBuilder {
    pub(crate) question_text: ::std::option::Option<::std::string::String>,
    pub(crate) answer_status: ::std::option::Option<crate::types::GeneratedAnswerStatus>,
    pub(crate) topic_id: ::std::option::Option<::std::string::String>,
    pub(crate) topic_name: ::std::option::Option<::std::string::String>,
    pub(crate) restatement: ::std::option::Option<::std::string::String>,
    pub(crate) question_id: ::std::option::Option<::std::string::String>,
    pub(crate) answer_id: ::std::option::Option<::std::string::String>,
    pub(crate) question_url: ::std::option::Option<::std::string::String>,
}
impl GeneratedAnswerResultBuilder {
    /// <p>The question text.</p>
    pub fn question_text(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.question_text = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The question text.</p>
    pub fn set_question_text(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.question_text = input;
        self
    }
    /// <p>The question text.</p>
    pub fn get_question_text(&self) -> &::std::option::Option<::std::string::String> {
        &self.question_text
    }
    /// <p>The answer status of the generated answer.</p>
    pub fn answer_status(mut self, input: crate::types::GeneratedAnswerStatus) -> Self {
        self.answer_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The answer status of the generated answer.</p>
    pub fn set_answer_status(mut self, input: ::std::option::Option<crate::types::GeneratedAnswerStatus>) -> Self {
        self.answer_status = input;
        self
    }
    /// <p>The answer status of the generated answer.</p>
    pub fn get_answer_status(&self) -> &::std::option::Option<crate::types::GeneratedAnswerStatus> {
        &self.answer_status
    }
    /// <p>The ID of the topic.</p>
    pub fn topic_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.topic_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the topic.</p>
    pub fn set_topic_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.topic_id = input;
        self
    }
    /// <p>The ID of the topic.</p>
    pub fn get_topic_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.topic_id
    }
    /// <p>The name of the topic.</p>
    pub fn topic_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.topic_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the topic.</p>
    pub fn set_topic_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.topic_name = input;
        self
    }
    /// <p>The name of the topic.</p>
    pub fn get_topic_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.topic_name
    }
    /// <p>The restatement for the answer.</p>
    pub fn restatement(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.restatement = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The restatement for the answer.</p>
    pub fn set_restatement(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.restatement = input;
        self
    }
    /// <p>The restatement for the answer.</p>
    pub fn get_restatement(&self) -> &::std::option::Option<::std::string::String> {
        &self.restatement
    }
    /// <p>The ID of the question.</p>
    pub fn question_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.question_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the question.</p>
    pub fn set_question_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.question_id = input;
        self
    }
    /// <p>The ID of the question.</p>
    pub fn get_question_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.question_id
    }
    /// <p>The ID of the answer.</p>
    pub fn answer_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.answer_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the answer.</p>
    pub fn set_answer_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.answer_id = input;
        self
    }
    /// <p>The ID of the answer.</p>
    pub fn get_answer_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.answer_id
    }
    /// <p>The URL of the question.</p>
    pub fn question_url(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.question_url = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The URL of the question.</p>
    pub fn set_question_url(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.question_url = input;
        self
    }
    /// <p>The URL of the question.</p>
    pub fn get_question_url(&self) -> &::std::option::Option<::std::string::String> {
        &self.question_url
    }
    /// Consumes the builder and constructs a [`GeneratedAnswerResult`](crate::types::GeneratedAnswerResult).
    pub fn build(self) -> crate::types::GeneratedAnswerResult {
        crate::types::GeneratedAnswerResult {
            question_text: self.question_text,
            answer_status: self.answer_status,
            topic_id: self.topic_id,
            topic_name: self.topic_name,
            restatement: self.restatement,
            question_id: self.question_id,
            answer_id: self.answer_id,
            question_url: self.question_url,
        }
    }
}
impl ::std::fmt::Debug for GeneratedAnswerResultBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("GeneratedAnswerResultBuilder");
        formatter.field("question_text", &"*** Sensitive Data Redacted ***");
        formatter.field("answer_status", &self.answer_status);
        formatter.field("topic_id", &self.topic_id);
        formatter.field("topic_name", &self.topic_name);
        formatter.field("restatement", &"*** Sensitive Data Redacted ***");
        formatter.field("question_id", &self.question_id);
        formatter.field("answer_id", &self.answer_id);
        formatter.field("question_url", &self.question_url);
        formatter.finish()
    }
}
