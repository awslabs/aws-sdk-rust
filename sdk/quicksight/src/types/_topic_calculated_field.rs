// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A structure that represents a calculated field.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct TopicCalculatedField {
    /// <p>The calculated field name.</p>
    pub calculated_field_name: ::std::string::String,
    /// <p>The calculated field description.</p>
    pub calculated_field_description: ::std::option::Option<::std::string::String>,
    /// <p>The calculated field expression.</p>
    pub expression: ::std::string::String,
    /// <p>The other names or aliases for the calculated field.</p>
    pub calculated_field_synonyms: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>A boolean value that indicates if a calculated field is included in the topic.</p>
    pub is_included_in_topic: bool,
    /// <p>A Boolean value that indicates if a calculated field is visible in the autocomplete.</p>
    pub disable_indexing: ::std::option::Option<bool>,
    /// <p>The column data role for a calculated field. Valid values for this structure are <code>DIMENSION</code> and <code>MEASURE</code>.</p>
    pub column_data_role: ::std::option::Option<crate::types::ColumnDataRole>,
    /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
    pub time_granularity: ::std::option::Option<crate::types::TopicTimeGranularity>,
    /// <p>The default formatting definition.</p>
    pub default_formatting: ::std::option::Option<crate::types::DefaultFormatting>,
    /// <p>The default aggregation. Valid values for this structure are <code>SUM</code>, <code>MAX</code>, <code>MIN</code>, <code>COUNT</code>, <code>DISTINCT_COUNT</code>, and <code>AVERAGE</code>.</p>
    pub aggregation: ::std::option::Option<crate::types::DefaultAggregation>,
    /// <p>The order in which data is displayed for the calculated field when it's used in a comparative context.</p>
    pub comparative_order: ::std::option::Option<crate::types::ComparativeOrder>,
    /// <p>The semantic type.</p>
    pub semantic_type: ::std::option::Option<crate::types::SemanticType>,
    /// <p>The list of aggregation types that are allowed for the calculated field. Valid values for this structure are <code>COUNT</code>, <code>DISTINCT_COUNT</code>, <code>MIN</code>, <code>MAX</code>, <code>MEDIAN</code>, <code>SUM</code>, <code>AVERAGE</code>, <code>STDEV</code>, <code>STDEVP</code>, <code>VAR</code>, <code>VARP</code>, and <code>PERCENTILE</code>.</p>
    pub allowed_aggregations: ::std::option::Option<::std::vec::Vec<crate::types::AuthorSpecifiedAggregation>>,
    /// <p>The list of aggregation types that are not allowed for the calculated field. Valid values for this structure are <code>COUNT</code>, <code>DISTINCT_COUNT</code>, <code>MIN</code>, <code>MAX</code>, <code>MEDIAN</code>, <code>SUM</code>, <code>AVERAGE</code>, <code>STDEV</code>, <code>STDEVP</code>, <code>VAR</code>, <code>VARP</code>, and <code>PERCENTILE</code>.</p>
    pub not_allowed_aggregations: ::std::option::Option<::std::vec::Vec<crate::types::AuthorSpecifiedAggregation>>,
    /// <p>A Boolean value that indicates whether to never aggregate calculated field in filters.</p>
    pub never_aggregate_in_filter: bool,
    /// <p>The other names or aliases for the calculated field cell value.</p>
    pub cell_value_synonyms: ::std::option::Option<::std::vec::Vec<crate::types::CellValueSynonym>>,
    /// <p>The non additive for the table style target.</p>
    pub non_additive: ::std::option::Option<bool>,
}
impl TopicCalculatedField {
    /// <p>The calculated field name.</p>
    pub fn calculated_field_name(&self) -> &str {
        use std::ops::Deref;
        self.calculated_field_name.deref()
    }
    /// <p>The calculated field description.</p>
    pub fn calculated_field_description(&self) -> ::std::option::Option<&str> {
        self.calculated_field_description.as_deref()
    }
    /// <p>The calculated field expression.</p>
    pub fn expression(&self) -> &str {
        use std::ops::Deref;
        self.expression.deref()
    }
    /// <p>The other names or aliases for the calculated field.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.calculated_field_synonyms.is_none()`.
    pub fn calculated_field_synonyms(&self) -> &[::std::string::String] {
        self.calculated_field_synonyms.as_deref().unwrap_or_default()
    }
    /// <p>A boolean value that indicates if a calculated field is included in the topic.</p>
    pub fn is_included_in_topic(&self) -> bool {
        self.is_included_in_topic
    }
    /// <p>A Boolean value that indicates if a calculated field is visible in the autocomplete.</p>
    pub fn disable_indexing(&self) -> ::std::option::Option<bool> {
        self.disable_indexing
    }
    /// <p>The column data role for a calculated field. Valid values for this structure are <code>DIMENSION</code> and <code>MEASURE</code>.</p>
    pub fn column_data_role(&self) -> ::std::option::Option<&crate::types::ColumnDataRole> {
        self.column_data_role.as_ref()
    }
    /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
    pub fn time_granularity(&self) -> ::std::option::Option<&crate::types::TopicTimeGranularity> {
        self.time_granularity.as_ref()
    }
    /// <p>The default formatting definition.</p>
    pub fn default_formatting(&self) -> ::std::option::Option<&crate::types::DefaultFormatting> {
        self.default_formatting.as_ref()
    }
    /// <p>The default aggregation. Valid values for this structure are <code>SUM</code>, <code>MAX</code>, <code>MIN</code>, <code>COUNT</code>, <code>DISTINCT_COUNT</code>, and <code>AVERAGE</code>.</p>
    pub fn aggregation(&self) -> ::std::option::Option<&crate::types::DefaultAggregation> {
        self.aggregation.as_ref()
    }
    /// <p>The order in which data is displayed for the calculated field when it's used in a comparative context.</p>
    pub fn comparative_order(&self) -> ::std::option::Option<&crate::types::ComparativeOrder> {
        self.comparative_order.as_ref()
    }
    /// <p>The semantic type.</p>
    pub fn semantic_type(&self) -> ::std::option::Option<&crate::types::SemanticType> {
        self.semantic_type.as_ref()
    }
    /// <p>The list of aggregation types that are allowed for the calculated field. Valid values for this structure are <code>COUNT</code>, <code>DISTINCT_COUNT</code>, <code>MIN</code>, <code>MAX</code>, <code>MEDIAN</code>, <code>SUM</code>, <code>AVERAGE</code>, <code>STDEV</code>, <code>STDEVP</code>, <code>VAR</code>, <code>VARP</code>, and <code>PERCENTILE</code>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.allowed_aggregations.is_none()`.
    pub fn allowed_aggregations(&self) -> &[crate::types::AuthorSpecifiedAggregation] {
        self.allowed_aggregations.as_deref().unwrap_or_default()
    }
    /// <p>The list of aggregation types that are not allowed for the calculated field. Valid values for this structure are <code>COUNT</code>, <code>DISTINCT_COUNT</code>, <code>MIN</code>, <code>MAX</code>, <code>MEDIAN</code>, <code>SUM</code>, <code>AVERAGE</code>, <code>STDEV</code>, <code>STDEVP</code>, <code>VAR</code>, <code>VARP</code>, and <code>PERCENTILE</code>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.not_allowed_aggregations.is_none()`.
    pub fn not_allowed_aggregations(&self) -> &[crate::types::AuthorSpecifiedAggregation] {
        self.not_allowed_aggregations.as_deref().unwrap_or_default()
    }
    /// <p>A Boolean value that indicates whether to never aggregate calculated field in filters.</p>
    pub fn never_aggregate_in_filter(&self) -> bool {
        self.never_aggregate_in_filter
    }
    /// <p>The other names or aliases for the calculated field cell value.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.cell_value_synonyms.is_none()`.
    pub fn cell_value_synonyms(&self) -> &[crate::types::CellValueSynonym] {
        self.cell_value_synonyms.as_deref().unwrap_or_default()
    }
    /// <p>The non additive for the table style target.</p>
    pub fn non_additive(&self) -> ::std::option::Option<bool> {
        self.non_additive
    }
}
impl ::std::fmt::Debug for TopicCalculatedField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("TopicCalculatedField");
        formatter.field("calculated_field_name", &self.calculated_field_name);
        formatter.field("calculated_field_description", &self.calculated_field_description);
        formatter.field("expression", &"*** Sensitive Data Redacted ***");
        formatter.field("calculated_field_synonyms", &self.calculated_field_synonyms);
        formatter.field("is_included_in_topic", &self.is_included_in_topic);
        formatter.field("disable_indexing", &self.disable_indexing);
        formatter.field("column_data_role", &self.column_data_role);
        formatter.field("time_granularity", &self.time_granularity);
        formatter.field("default_formatting", &self.default_formatting);
        formatter.field("aggregation", &self.aggregation);
        formatter.field("comparative_order", &self.comparative_order);
        formatter.field("semantic_type", &self.semantic_type);
        formatter.field("allowed_aggregations", &self.allowed_aggregations);
        formatter.field("not_allowed_aggregations", &self.not_allowed_aggregations);
        formatter.field("never_aggregate_in_filter", &self.never_aggregate_in_filter);
        formatter.field("cell_value_synonyms", &self.cell_value_synonyms);
        formatter.field("non_additive", &self.non_additive);
        formatter.finish()
    }
}
impl TopicCalculatedField {
    /// Creates a new builder-style object to manufacture [`TopicCalculatedField`](crate::types::TopicCalculatedField).
    pub fn builder() -> crate::types::builders::TopicCalculatedFieldBuilder {
        crate::types::builders::TopicCalculatedFieldBuilder::default()
    }
}

/// A builder for [`TopicCalculatedField`](crate::types::TopicCalculatedField).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
pub struct TopicCalculatedFieldBuilder {
    pub(crate) calculated_field_name: ::std::option::Option<::std::string::String>,
    pub(crate) calculated_field_description: ::std::option::Option<::std::string::String>,
    pub(crate) expression: ::std::option::Option<::std::string::String>,
    pub(crate) calculated_field_synonyms: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) is_included_in_topic: ::std::option::Option<bool>,
    pub(crate) disable_indexing: ::std::option::Option<bool>,
    pub(crate) column_data_role: ::std::option::Option<crate::types::ColumnDataRole>,
    pub(crate) time_granularity: ::std::option::Option<crate::types::TopicTimeGranularity>,
    pub(crate) default_formatting: ::std::option::Option<crate::types::DefaultFormatting>,
    pub(crate) aggregation: ::std::option::Option<crate::types::DefaultAggregation>,
    pub(crate) comparative_order: ::std::option::Option<crate::types::ComparativeOrder>,
    pub(crate) semantic_type: ::std::option::Option<crate::types::SemanticType>,
    pub(crate) allowed_aggregations: ::std::option::Option<::std::vec::Vec<crate::types::AuthorSpecifiedAggregation>>,
    pub(crate) not_allowed_aggregations: ::std::option::Option<::std::vec::Vec<crate::types::AuthorSpecifiedAggregation>>,
    pub(crate) never_aggregate_in_filter: ::std::option::Option<bool>,
    pub(crate) cell_value_synonyms: ::std::option::Option<::std::vec::Vec<crate::types::CellValueSynonym>>,
    pub(crate) non_additive: ::std::option::Option<bool>,
}
impl TopicCalculatedFieldBuilder {
    /// <p>The calculated field name.</p>
    /// This field is required.
    pub fn calculated_field_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.calculated_field_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The calculated field name.</p>
    pub fn set_calculated_field_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.calculated_field_name = input;
        self
    }
    /// <p>The calculated field name.</p>
    pub fn get_calculated_field_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.calculated_field_name
    }
    /// <p>The calculated field description.</p>
    pub fn calculated_field_description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.calculated_field_description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The calculated field description.</p>
    pub fn set_calculated_field_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.calculated_field_description = input;
        self
    }
    /// <p>The calculated field description.</p>
    pub fn get_calculated_field_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.calculated_field_description
    }
    /// <p>The calculated field expression.</p>
    /// This field is required.
    pub fn expression(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.expression = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The calculated field expression.</p>
    pub fn set_expression(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.expression = input;
        self
    }
    /// <p>The calculated field expression.</p>
    pub fn get_expression(&self) -> &::std::option::Option<::std::string::String> {
        &self.expression
    }
    /// Appends an item to `calculated_field_synonyms`.
    ///
    /// To override the contents of this collection use [`set_calculated_field_synonyms`](Self::set_calculated_field_synonyms).
    ///
    /// <p>The other names or aliases for the calculated field.</p>
    pub fn calculated_field_synonyms(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.calculated_field_synonyms.unwrap_or_default();
        v.push(input.into());
        self.calculated_field_synonyms = ::std::option::Option::Some(v);
        self
    }
    /// <p>The other names or aliases for the calculated field.</p>
    pub fn set_calculated_field_synonyms(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.calculated_field_synonyms = input;
        self
    }
    /// <p>The other names or aliases for the calculated field.</p>
    pub fn get_calculated_field_synonyms(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.calculated_field_synonyms
    }
    /// <p>A boolean value that indicates if a calculated field is included in the topic.</p>
    pub fn is_included_in_topic(mut self, input: bool) -> Self {
        self.is_included_in_topic = ::std::option::Option::Some(input);
        self
    }
    /// <p>A boolean value that indicates if a calculated field is included in the topic.</p>
    pub fn set_is_included_in_topic(mut self, input: ::std::option::Option<bool>) -> Self {
        self.is_included_in_topic = input;
        self
    }
    /// <p>A boolean value that indicates if a calculated field is included in the topic.</p>
    pub fn get_is_included_in_topic(&self) -> &::std::option::Option<bool> {
        &self.is_included_in_topic
    }
    /// <p>A Boolean value that indicates if a calculated field is visible in the autocomplete.</p>
    pub fn disable_indexing(mut self, input: bool) -> Self {
        self.disable_indexing = ::std::option::Option::Some(input);
        self
    }
    /// <p>A Boolean value that indicates if a calculated field is visible in the autocomplete.</p>
    pub fn set_disable_indexing(mut self, input: ::std::option::Option<bool>) -> Self {
        self.disable_indexing = input;
        self
    }
    /// <p>A Boolean value that indicates if a calculated field is visible in the autocomplete.</p>
    pub fn get_disable_indexing(&self) -> &::std::option::Option<bool> {
        &self.disable_indexing
    }
    /// <p>The column data role for a calculated field. Valid values for this structure are <code>DIMENSION</code> and <code>MEASURE</code>.</p>
    pub fn column_data_role(mut self, input: crate::types::ColumnDataRole) -> Self {
        self.column_data_role = ::std::option::Option::Some(input);
        self
    }
    /// <p>The column data role for a calculated field. Valid values for this structure are <code>DIMENSION</code> and <code>MEASURE</code>.</p>
    pub fn set_column_data_role(mut self, input: ::std::option::Option<crate::types::ColumnDataRole>) -> Self {
        self.column_data_role = input;
        self
    }
    /// <p>The column data role for a calculated field. Valid values for this structure are <code>DIMENSION</code> and <code>MEASURE</code>.</p>
    pub fn get_column_data_role(&self) -> &::std::option::Option<crate::types::ColumnDataRole> {
        &self.column_data_role
    }
    /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
    pub fn time_granularity(mut self, input: crate::types::TopicTimeGranularity) -> Self {
        self.time_granularity = ::std::option::Option::Some(input);
        self
    }
    /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
    pub fn set_time_granularity(mut self, input: ::std::option::Option<crate::types::TopicTimeGranularity>) -> Self {
        self.time_granularity = input;
        self
    }
    /// <p>The level of time precision that is used to aggregate <code>DateTime</code> values.</p>
    pub fn get_time_granularity(&self) -> &::std::option::Option<crate::types::TopicTimeGranularity> {
        &self.time_granularity
    }
    /// <p>The default formatting definition.</p>
    pub fn default_formatting(mut self, input: crate::types::DefaultFormatting) -> Self {
        self.default_formatting = ::std::option::Option::Some(input);
        self
    }
    /// <p>The default formatting definition.</p>
    pub fn set_default_formatting(mut self, input: ::std::option::Option<crate::types::DefaultFormatting>) -> Self {
        self.default_formatting = input;
        self
    }
    /// <p>The default formatting definition.</p>
    pub fn get_default_formatting(&self) -> &::std::option::Option<crate::types::DefaultFormatting> {
        &self.default_formatting
    }
    /// <p>The default aggregation. Valid values for this structure are <code>SUM</code>, <code>MAX</code>, <code>MIN</code>, <code>COUNT</code>, <code>DISTINCT_COUNT</code>, and <code>AVERAGE</code>.</p>
    pub fn aggregation(mut self, input: crate::types::DefaultAggregation) -> Self {
        self.aggregation = ::std::option::Option::Some(input);
        self
    }
    /// <p>The default aggregation. Valid values for this structure are <code>SUM</code>, <code>MAX</code>, <code>MIN</code>, <code>COUNT</code>, <code>DISTINCT_COUNT</code>, and <code>AVERAGE</code>.</p>
    pub fn set_aggregation(mut self, input: ::std::option::Option<crate::types::DefaultAggregation>) -> Self {
        self.aggregation = input;
        self
    }
    /// <p>The default aggregation. Valid values for this structure are <code>SUM</code>, <code>MAX</code>, <code>MIN</code>, <code>COUNT</code>, <code>DISTINCT_COUNT</code>, and <code>AVERAGE</code>.</p>
    pub fn get_aggregation(&self) -> &::std::option::Option<crate::types::DefaultAggregation> {
        &self.aggregation
    }
    /// <p>The order in which data is displayed for the calculated field when it's used in a comparative context.</p>
    pub fn comparative_order(mut self, input: crate::types::ComparativeOrder) -> Self {
        self.comparative_order = ::std::option::Option::Some(input);
        self
    }
    /// <p>The order in which data is displayed for the calculated field when it's used in a comparative context.</p>
    pub fn set_comparative_order(mut self, input: ::std::option::Option<crate::types::ComparativeOrder>) -> Self {
        self.comparative_order = input;
        self
    }
    /// <p>The order in which data is displayed for the calculated field when it's used in a comparative context.</p>
    pub fn get_comparative_order(&self) -> &::std::option::Option<crate::types::ComparativeOrder> {
        &self.comparative_order
    }
    /// <p>The semantic type.</p>
    pub fn semantic_type(mut self, input: crate::types::SemanticType) -> Self {
        self.semantic_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The semantic type.</p>
    pub fn set_semantic_type(mut self, input: ::std::option::Option<crate::types::SemanticType>) -> Self {
        self.semantic_type = input;
        self
    }
    /// <p>The semantic type.</p>
    pub fn get_semantic_type(&self) -> &::std::option::Option<crate::types::SemanticType> {
        &self.semantic_type
    }
    /// Appends an item to `allowed_aggregations`.
    ///
    /// To override the contents of this collection use [`set_allowed_aggregations`](Self::set_allowed_aggregations).
    ///
    /// <p>The list of aggregation types that are allowed for the calculated field. Valid values for this structure are <code>COUNT</code>, <code>DISTINCT_COUNT</code>, <code>MIN</code>, <code>MAX</code>, <code>MEDIAN</code>, <code>SUM</code>, <code>AVERAGE</code>, <code>STDEV</code>, <code>STDEVP</code>, <code>VAR</code>, <code>VARP</code>, and <code>PERCENTILE</code>.</p>
    pub fn allowed_aggregations(mut self, input: crate::types::AuthorSpecifiedAggregation) -> Self {
        let mut v = self.allowed_aggregations.unwrap_or_default();
        v.push(input);
        self.allowed_aggregations = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of aggregation types that are allowed for the calculated field. Valid values for this structure are <code>COUNT</code>, <code>DISTINCT_COUNT</code>, <code>MIN</code>, <code>MAX</code>, <code>MEDIAN</code>, <code>SUM</code>, <code>AVERAGE</code>, <code>STDEV</code>, <code>STDEVP</code>, <code>VAR</code>, <code>VARP</code>, and <code>PERCENTILE</code>.</p>
    pub fn set_allowed_aggregations(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::AuthorSpecifiedAggregation>>) -> Self {
        self.allowed_aggregations = input;
        self
    }
    /// <p>The list of aggregation types that are allowed for the calculated field. Valid values for this structure are <code>COUNT</code>, <code>DISTINCT_COUNT</code>, <code>MIN</code>, <code>MAX</code>, <code>MEDIAN</code>, <code>SUM</code>, <code>AVERAGE</code>, <code>STDEV</code>, <code>STDEVP</code>, <code>VAR</code>, <code>VARP</code>, and <code>PERCENTILE</code>.</p>
    pub fn get_allowed_aggregations(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::AuthorSpecifiedAggregation>> {
        &self.allowed_aggregations
    }
    /// Appends an item to `not_allowed_aggregations`.
    ///
    /// To override the contents of this collection use [`set_not_allowed_aggregations`](Self::set_not_allowed_aggregations).
    ///
    /// <p>The list of aggregation types that are not allowed for the calculated field. Valid values for this structure are <code>COUNT</code>, <code>DISTINCT_COUNT</code>, <code>MIN</code>, <code>MAX</code>, <code>MEDIAN</code>, <code>SUM</code>, <code>AVERAGE</code>, <code>STDEV</code>, <code>STDEVP</code>, <code>VAR</code>, <code>VARP</code>, and <code>PERCENTILE</code>.</p>
    pub fn not_allowed_aggregations(mut self, input: crate::types::AuthorSpecifiedAggregation) -> Self {
        let mut v = self.not_allowed_aggregations.unwrap_or_default();
        v.push(input);
        self.not_allowed_aggregations = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of aggregation types that are not allowed for the calculated field. Valid values for this structure are <code>COUNT</code>, <code>DISTINCT_COUNT</code>, <code>MIN</code>, <code>MAX</code>, <code>MEDIAN</code>, <code>SUM</code>, <code>AVERAGE</code>, <code>STDEV</code>, <code>STDEVP</code>, <code>VAR</code>, <code>VARP</code>, and <code>PERCENTILE</code>.</p>
    pub fn set_not_allowed_aggregations(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::AuthorSpecifiedAggregation>>) -> Self {
        self.not_allowed_aggregations = input;
        self
    }
    /// <p>The list of aggregation types that are not allowed for the calculated field. Valid values for this structure are <code>COUNT</code>, <code>DISTINCT_COUNT</code>, <code>MIN</code>, <code>MAX</code>, <code>MEDIAN</code>, <code>SUM</code>, <code>AVERAGE</code>, <code>STDEV</code>, <code>STDEVP</code>, <code>VAR</code>, <code>VARP</code>, and <code>PERCENTILE</code>.</p>
    pub fn get_not_allowed_aggregations(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::AuthorSpecifiedAggregation>> {
        &self.not_allowed_aggregations
    }
    /// <p>A Boolean value that indicates whether to never aggregate calculated field in filters.</p>
    pub fn never_aggregate_in_filter(mut self, input: bool) -> Self {
        self.never_aggregate_in_filter = ::std::option::Option::Some(input);
        self
    }
    /// <p>A Boolean value that indicates whether to never aggregate calculated field in filters.</p>
    pub fn set_never_aggregate_in_filter(mut self, input: ::std::option::Option<bool>) -> Self {
        self.never_aggregate_in_filter = input;
        self
    }
    /// <p>A Boolean value that indicates whether to never aggregate calculated field in filters.</p>
    pub fn get_never_aggregate_in_filter(&self) -> &::std::option::Option<bool> {
        &self.never_aggregate_in_filter
    }
    /// Appends an item to `cell_value_synonyms`.
    ///
    /// To override the contents of this collection use [`set_cell_value_synonyms`](Self::set_cell_value_synonyms).
    ///
    /// <p>The other names or aliases for the calculated field cell value.</p>
    pub fn cell_value_synonyms(mut self, input: crate::types::CellValueSynonym) -> Self {
        let mut v = self.cell_value_synonyms.unwrap_or_default();
        v.push(input);
        self.cell_value_synonyms = ::std::option::Option::Some(v);
        self
    }
    /// <p>The other names or aliases for the calculated field cell value.</p>
    pub fn set_cell_value_synonyms(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::CellValueSynonym>>) -> Self {
        self.cell_value_synonyms = input;
        self
    }
    /// <p>The other names or aliases for the calculated field cell value.</p>
    pub fn get_cell_value_synonyms(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::CellValueSynonym>> {
        &self.cell_value_synonyms
    }
    /// <p>The non additive for the table style target.</p>
    pub fn non_additive(mut self, input: bool) -> Self {
        self.non_additive = ::std::option::Option::Some(input);
        self
    }
    /// <p>The non additive for the table style target.</p>
    pub fn set_non_additive(mut self, input: ::std::option::Option<bool>) -> Self {
        self.non_additive = input;
        self
    }
    /// <p>The non additive for the table style target.</p>
    pub fn get_non_additive(&self) -> &::std::option::Option<bool> {
        &self.non_additive
    }
    /// Consumes the builder and constructs a [`TopicCalculatedField`](crate::types::TopicCalculatedField).
    /// This method will fail if any of the following fields are not set:
    /// - [`calculated_field_name`](crate::types::builders::TopicCalculatedFieldBuilder::calculated_field_name)
    /// - [`expression`](crate::types::builders::TopicCalculatedFieldBuilder::expression)
    pub fn build(self) -> ::std::result::Result<crate::types::TopicCalculatedField, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::TopicCalculatedField {
            calculated_field_name: self.calculated_field_name.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "calculated_field_name",
                    "calculated_field_name was not specified but it is required when building TopicCalculatedField",
                )
            })?,
            calculated_field_description: self.calculated_field_description,
            expression: self.expression.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "expression",
                    "expression was not specified but it is required when building TopicCalculatedField",
                )
            })?,
            calculated_field_synonyms: self.calculated_field_synonyms,
            is_included_in_topic: self.is_included_in_topic.unwrap_or_default(),
            disable_indexing: self.disable_indexing,
            column_data_role: self.column_data_role,
            time_granularity: self.time_granularity,
            default_formatting: self.default_formatting,
            aggregation: self.aggregation,
            comparative_order: self.comparative_order,
            semantic_type: self.semantic_type,
            allowed_aggregations: self.allowed_aggregations,
            not_allowed_aggregations: self.not_allowed_aggregations,
            never_aggregate_in_filter: self.never_aggregate_in_filter.unwrap_or_default(),
            cell_value_synonyms: self.cell_value_synonyms,
            non_additive: self.non_additive,
        })
    }
}
impl ::std::fmt::Debug for TopicCalculatedFieldBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("TopicCalculatedFieldBuilder");
        formatter.field("calculated_field_name", &self.calculated_field_name);
        formatter.field("calculated_field_description", &self.calculated_field_description);
        formatter.field("expression", &"*** Sensitive Data Redacted ***");
        formatter.field("calculated_field_synonyms", &self.calculated_field_synonyms);
        formatter.field("is_included_in_topic", &self.is_included_in_topic);
        formatter.field("disable_indexing", &self.disable_indexing);
        formatter.field("column_data_role", &self.column_data_role);
        formatter.field("time_granularity", &self.time_granularity);
        formatter.field("default_formatting", &self.default_formatting);
        formatter.field("aggregation", &self.aggregation);
        formatter.field("comparative_order", &self.comparative_order);
        formatter.field("semantic_type", &self.semantic_type);
        formatter.field("allowed_aggregations", &self.allowed_aggregations);
        formatter.field("not_allowed_aggregations", &self.not_allowed_aggregations);
        formatter.field("never_aggregate_in_filter", &self.never_aggregate_in_filter);
        formatter.field("cell_value_synonyms", &self.cell_value_synonyms);
        formatter.field("non_additive", &self.non_additive);
        formatter.finish()
    }
}
