// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A filter that filters topics based on the value of a numeric field. The filter includes only topics whose numeric field value falls within the specified range.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TopicNumericRangeFilter {
    /// <p>A Boolean value that indicates whether the endpoints of the numeric range are included in the filter. If set to true, topics whose numeric field value is equal to the endpoint values will be included in the filter. If set to false, topics whose numeric field value is equal to the endpoint values will be excluded from the filter.</p>
    #[doc(hidden)]
    pub inclusive: bool,
    /// <p>The constant used in a numeric range filter.</p>
    #[doc(hidden)]
    pub constant: std::option::Option<crate::types::TopicRangeFilterConstant>,
    /// <p>An aggregation function that specifies how to calculate the value of a numeric field for a topic, Valid values for this structure are <code>NO_AGGREGATION</code>, <code>SUM</code>, <code>AVERAGE</code>, <code>COUNT</code>, <code>DISTINCT_COUNT</code>, <code>MAX</code>, <code>MEDIAN</code>, <code>MIN</code>, <code>STDEV</code>, <code>STDEVP</code>, <code>VAR</code>, and <code>VARP</code>.</p>
    #[doc(hidden)]
    pub aggregation: std::option::Option<crate::types::NamedFilterAggType>,
}
impl TopicNumericRangeFilter {
    /// <p>A Boolean value that indicates whether the endpoints of the numeric range are included in the filter. If set to true, topics whose numeric field value is equal to the endpoint values will be included in the filter. If set to false, topics whose numeric field value is equal to the endpoint values will be excluded from the filter.</p>
    pub fn inclusive(&self) -> bool {
        self.inclusive
    }
    /// <p>The constant used in a numeric range filter.</p>
    pub fn constant(&self) -> std::option::Option<&crate::types::TopicRangeFilterConstant> {
        self.constant.as_ref()
    }
    /// <p>An aggregation function that specifies how to calculate the value of a numeric field for a topic, Valid values for this structure are <code>NO_AGGREGATION</code>, <code>SUM</code>, <code>AVERAGE</code>, <code>COUNT</code>, <code>DISTINCT_COUNT</code>, <code>MAX</code>, <code>MEDIAN</code>, <code>MIN</code>, <code>STDEV</code>, <code>STDEVP</code>, <code>VAR</code>, and <code>VARP</code>.</p>
    pub fn aggregation(&self) -> std::option::Option<&crate::types::NamedFilterAggType> {
        self.aggregation.as_ref()
    }
}
impl std::fmt::Debug for TopicNumericRangeFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TopicNumericRangeFilter");
        formatter.field("inclusive", &self.inclusive);
        formatter.field("constant", &"*** Sensitive Data Redacted ***");
        formatter.field("aggregation", &self.aggregation);
        formatter.finish()
    }
}
impl TopicNumericRangeFilter {
    /// Creates a new builder-style object to manufacture [`TopicNumericRangeFilter`](crate::types::TopicNumericRangeFilter).
    pub fn builder() -> crate::types::builders::TopicNumericRangeFilterBuilder {
        crate::types::builders::TopicNumericRangeFilterBuilder::default()
    }
}

/// A builder for [`TopicNumericRangeFilter`](crate::types::TopicNumericRangeFilter).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
pub struct TopicNumericRangeFilterBuilder {
    pub(crate) inclusive: std::option::Option<bool>,
    pub(crate) constant: std::option::Option<crate::types::TopicRangeFilterConstant>,
    pub(crate) aggregation: std::option::Option<crate::types::NamedFilterAggType>,
}
impl TopicNumericRangeFilterBuilder {
    /// <p>A Boolean value that indicates whether the endpoints of the numeric range are included in the filter. If set to true, topics whose numeric field value is equal to the endpoint values will be included in the filter. If set to false, topics whose numeric field value is equal to the endpoint values will be excluded from the filter.</p>
    pub fn inclusive(mut self, input: bool) -> Self {
        self.inclusive = Some(input);
        self
    }
    /// <p>A Boolean value that indicates whether the endpoints of the numeric range are included in the filter. If set to true, topics whose numeric field value is equal to the endpoint values will be included in the filter. If set to false, topics whose numeric field value is equal to the endpoint values will be excluded from the filter.</p>
    pub fn set_inclusive(mut self, input: std::option::Option<bool>) -> Self {
        self.inclusive = input;
        self
    }
    /// <p>The constant used in a numeric range filter.</p>
    pub fn constant(mut self, input: crate::types::TopicRangeFilterConstant) -> Self {
        self.constant = Some(input);
        self
    }
    /// <p>The constant used in a numeric range filter.</p>
    pub fn set_constant(
        mut self,
        input: std::option::Option<crate::types::TopicRangeFilterConstant>,
    ) -> Self {
        self.constant = input;
        self
    }
    /// <p>An aggregation function that specifies how to calculate the value of a numeric field for a topic, Valid values for this structure are <code>NO_AGGREGATION</code>, <code>SUM</code>, <code>AVERAGE</code>, <code>COUNT</code>, <code>DISTINCT_COUNT</code>, <code>MAX</code>, <code>MEDIAN</code>, <code>MIN</code>, <code>STDEV</code>, <code>STDEVP</code>, <code>VAR</code>, and <code>VARP</code>.</p>
    pub fn aggregation(mut self, input: crate::types::NamedFilterAggType) -> Self {
        self.aggregation = Some(input);
        self
    }
    /// <p>An aggregation function that specifies how to calculate the value of a numeric field for a topic, Valid values for this structure are <code>NO_AGGREGATION</code>, <code>SUM</code>, <code>AVERAGE</code>, <code>COUNT</code>, <code>DISTINCT_COUNT</code>, <code>MAX</code>, <code>MEDIAN</code>, <code>MIN</code>, <code>STDEV</code>, <code>STDEVP</code>, <code>VAR</code>, and <code>VARP</code>.</p>
    pub fn set_aggregation(
        mut self,
        input: std::option::Option<crate::types::NamedFilterAggType>,
    ) -> Self {
        self.aggregation = input;
        self
    }
    /// Consumes the builder and constructs a [`TopicNumericRangeFilter`](crate::types::TopicNumericRangeFilter).
    pub fn build(self) -> crate::types::TopicNumericRangeFilter {
        crate::types::TopicNumericRangeFilter {
            inclusive: self.inclusive.unwrap_or_default(),
            constant: self.constant,
            aggregation: self.aggregation,
        }
    }
}
impl std::fmt::Debug for TopicNumericRangeFilterBuilder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TopicNumericRangeFilterBuilder");
        formatter.field("inclusive", &self.inclusive);
        formatter.field("constant", &"*** Sensitive Data Redacted ***");
        formatter.field("aggregation", &self.aggregation);
        formatter.finish()
    }
}
