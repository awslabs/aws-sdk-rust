// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `DecalPatternType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let decalpatterntype = unimplemented!();
/// match decalpatterntype {
///     DecalPatternType::CheckerboardLarge => { /* ... */ },
///     DecalPatternType::CheckerboardMedium => { /* ... */ },
///     DecalPatternType::CheckerboardSmall => { /* ... */ },
///     DecalPatternType::CircleLarge => { /* ... */ },
///     DecalPatternType::CircleMedium => { /* ... */ },
///     DecalPatternType::CircleSmall => { /* ... */ },
///     DecalPatternType::DiagonalLarge => { /* ... */ },
///     DecalPatternType::DiagonalMedium => { /* ... */ },
///     DecalPatternType::DiagonalOppositeLarge => { /* ... */ },
///     DecalPatternType::DiagonalOppositeMedium => { /* ... */ },
///     DecalPatternType::DiagonalOppositeSmall => { /* ... */ },
///     DecalPatternType::DiagonalSmall => { /* ... */ },
///     DecalPatternType::DiamondGridLarge => { /* ... */ },
///     DecalPatternType::DiamondGridMedium => { /* ... */ },
///     DecalPatternType::DiamondGridSmall => { /* ... */ },
///     DecalPatternType::DiamondLarge => { /* ... */ },
///     DecalPatternType::DiamondMedium => { /* ... */ },
///     DecalPatternType::DiamondSmall => { /* ... */ },
///     DecalPatternType::Solid => { /* ... */ },
///     DecalPatternType::TriangleLarge => { /* ... */ },
///     DecalPatternType::TriangleMedium => { /* ... */ },
///     DecalPatternType::TriangleSmall => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `decalpatterntype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DecalPatternType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DecalPatternType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DecalPatternType::NewFeature` is defined.
/// Specifically, when `decalpatterntype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DecalPatternType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
///
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::Ord, ::std::cmp::PartialEq, ::std::cmp::PartialOrd, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub enum DecalPatternType {
    #[allow(missing_docs)] // documentation missing in model
    CheckerboardLarge,
    #[allow(missing_docs)] // documentation missing in model
    CheckerboardMedium,
    #[allow(missing_docs)] // documentation missing in model
    CheckerboardSmall,
    #[allow(missing_docs)] // documentation missing in model
    CircleLarge,
    #[allow(missing_docs)] // documentation missing in model
    CircleMedium,
    #[allow(missing_docs)] // documentation missing in model
    CircleSmall,
    #[allow(missing_docs)] // documentation missing in model
    DiagonalLarge,
    #[allow(missing_docs)] // documentation missing in model
    DiagonalMedium,
    #[allow(missing_docs)] // documentation missing in model
    DiagonalOppositeLarge,
    #[allow(missing_docs)] // documentation missing in model
    DiagonalOppositeMedium,
    #[allow(missing_docs)] // documentation missing in model
    DiagonalOppositeSmall,
    #[allow(missing_docs)] // documentation missing in model
    DiagonalSmall,
    #[allow(missing_docs)] // documentation missing in model
    DiamondGridLarge,
    #[allow(missing_docs)] // documentation missing in model
    DiamondGridMedium,
    #[allow(missing_docs)] // documentation missing in model
    DiamondGridSmall,
    #[allow(missing_docs)] // documentation missing in model
    DiamondLarge,
    #[allow(missing_docs)] // documentation missing in model
    DiamondMedium,
    #[allow(missing_docs)] // documentation missing in model
    DiamondSmall,
    #[allow(missing_docs)] // documentation missing in model
    Solid,
    #[allow(missing_docs)] // documentation missing in model
    TriangleLarge,
    #[allow(missing_docs)] // documentation missing in model
    TriangleMedium,
    #[allow(missing_docs)] // documentation missing in model
    TriangleSmall,
    /// `Unknown` contains new variants that have been added since this code was generated.
    #[deprecated(note = "Don't directly match on `Unknown`. See the docs on this enum for the correct way to handle unknown variants.")]
    Unknown(crate::primitives::sealed_enum_unknown::UnknownVariantValue),
}
impl ::std::convert::From<&str> for DecalPatternType {
    fn from(s: &str) -> Self {
        match s {
            "CHECKERBOARD_LARGE" => DecalPatternType::CheckerboardLarge,
            "CHECKERBOARD_MEDIUM" => DecalPatternType::CheckerboardMedium,
            "CHECKERBOARD_SMALL" => DecalPatternType::CheckerboardSmall,
            "CIRCLE_LARGE" => DecalPatternType::CircleLarge,
            "CIRCLE_MEDIUM" => DecalPatternType::CircleMedium,
            "CIRCLE_SMALL" => DecalPatternType::CircleSmall,
            "DIAGONAL_LARGE" => DecalPatternType::DiagonalLarge,
            "DIAGONAL_MEDIUM" => DecalPatternType::DiagonalMedium,
            "DIAGONAL_OPPOSITE_LARGE" => DecalPatternType::DiagonalOppositeLarge,
            "DIAGONAL_OPPOSITE_MEDIUM" => DecalPatternType::DiagonalOppositeMedium,
            "DIAGONAL_OPPOSITE_SMALL" => DecalPatternType::DiagonalOppositeSmall,
            "DIAGONAL_SMALL" => DecalPatternType::DiagonalSmall,
            "DIAMOND_GRID_LARGE" => DecalPatternType::DiamondGridLarge,
            "DIAMOND_GRID_MEDIUM" => DecalPatternType::DiamondGridMedium,
            "DIAMOND_GRID_SMALL" => DecalPatternType::DiamondGridSmall,
            "DIAMOND_LARGE" => DecalPatternType::DiamondLarge,
            "DIAMOND_MEDIUM" => DecalPatternType::DiamondMedium,
            "DIAMOND_SMALL" => DecalPatternType::DiamondSmall,
            "SOLID" => DecalPatternType::Solid,
            "TRIANGLE_LARGE" => DecalPatternType::TriangleLarge,
            "TRIANGLE_MEDIUM" => DecalPatternType::TriangleMedium,
            "TRIANGLE_SMALL" => DecalPatternType::TriangleSmall,
            other => DecalPatternType::Unknown(crate::primitives::sealed_enum_unknown::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl ::std::str::FromStr for DecalPatternType {
    type Err = ::std::convert::Infallible;

    fn from_str(s: &str) -> ::std::result::Result<Self, <Self as ::std::str::FromStr>::Err> {
        ::std::result::Result::Ok(DecalPatternType::from(s))
    }
}
impl DecalPatternType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DecalPatternType::CheckerboardLarge => "CHECKERBOARD_LARGE",
            DecalPatternType::CheckerboardMedium => "CHECKERBOARD_MEDIUM",
            DecalPatternType::CheckerboardSmall => "CHECKERBOARD_SMALL",
            DecalPatternType::CircleLarge => "CIRCLE_LARGE",
            DecalPatternType::CircleMedium => "CIRCLE_MEDIUM",
            DecalPatternType::CircleSmall => "CIRCLE_SMALL",
            DecalPatternType::DiagonalLarge => "DIAGONAL_LARGE",
            DecalPatternType::DiagonalMedium => "DIAGONAL_MEDIUM",
            DecalPatternType::DiagonalOppositeLarge => "DIAGONAL_OPPOSITE_LARGE",
            DecalPatternType::DiagonalOppositeMedium => "DIAGONAL_OPPOSITE_MEDIUM",
            DecalPatternType::DiagonalOppositeSmall => "DIAGONAL_OPPOSITE_SMALL",
            DecalPatternType::DiagonalSmall => "DIAGONAL_SMALL",
            DecalPatternType::DiamondGridLarge => "DIAMOND_GRID_LARGE",
            DecalPatternType::DiamondGridMedium => "DIAMOND_GRID_MEDIUM",
            DecalPatternType::DiamondGridSmall => "DIAMOND_GRID_SMALL",
            DecalPatternType::DiamondLarge => "DIAMOND_LARGE",
            DecalPatternType::DiamondMedium => "DIAMOND_MEDIUM",
            DecalPatternType::DiamondSmall => "DIAMOND_SMALL",
            DecalPatternType::Solid => "SOLID",
            DecalPatternType::TriangleLarge => "TRIANGLE_LARGE",
            DecalPatternType::TriangleMedium => "TRIANGLE_MEDIUM",
            DecalPatternType::TriangleSmall => "TRIANGLE_SMALL",
            DecalPatternType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CHECKERBOARD_LARGE",
            "CHECKERBOARD_MEDIUM",
            "CHECKERBOARD_SMALL",
            "CIRCLE_LARGE",
            "CIRCLE_MEDIUM",
            "CIRCLE_SMALL",
            "DIAGONAL_LARGE",
            "DIAGONAL_MEDIUM",
            "DIAGONAL_OPPOSITE_LARGE",
            "DIAGONAL_OPPOSITE_MEDIUM",
            "DIAGONAL_OPPOSITE_SMALL",
            "DIAGONAL_SMALL",
            "DIAMOND_GRID_LARGE",
            "DIAMOND_GRID_MEDIUM",
            "DIAMOND_GRID_SMALL",
            "DIAMOND_LARGE",
            "DIAMOND_MEDIUM",
            "DIAMOND_SMALL",
            "SOLID",
            "TRIANGLE_LARGE",
            "TRIANGLE_MEDIUM",
            "TRIANGLE_SMALL",
        ]
    }
}
impl ::std::convert::AsRef<str> for DecalPatternType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl DecalPatternType {
    /// Parses the enum value while disallowing unknown variants.
    ///
    /// Unknown variants will result in an error.
    pub fn try_parse(value: &str) -> ::std::result::Result<Self, crate::error::UnknownVariantError> {
        match Self::from(value) {
            #[allow(deprecated)]
            Self::Unknown(_) => ::std::result::Result::Err(crate::error::UnknownVariantError::new(value)),
            known => Ok(known),
        }
    }
}
impl ::std::fmt::Display for DecalPatternType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            DecalPatternType::CheckerboardLarge => write!(f, "CHECKERBOARD_LARGE"),
            DecalPatternType::CheckerboardMedium => write!(f, "CHECKERBOARD_MEDIUM"),
            DecalPatternType::CheckerboardSmall => write!(f, "CHECKERBOARD_SMALL"),
            DecalPatternType::CircleLarge => write!(f, "CIRCLE_LARGE"),
            DecalPatternType::CircleMedium => write!(f, "CIRCLE_MEDIUM"),
            DecalPatternType::CircleSmall => write!(f, "CIRCLE_SMALL"),
            DecalPatternType::DiagonalLarge => write!(f, "DIAGONAL_LARGE"),
            DecalPatternType::DiagonalMedium => write!(f, "DIAGONAL_MEDIUM"),
            DecalPatternType::DiagonalOppositeLarge => write!(f, "DIAGONAL_OPPOSITE_LARGE"),
            DecalPatternType::DiagonalOppositeMedium => write!(f, "DIAGONAL_OPPOSITE_MEDIUM"),
            DecalPatternType::DiagonalOppositeSmall => write!(f, "DIAGONAL_OPPOSITE_SMALL"),
            DecalPatternType::DiagonalSmall => write!(f, "DIAGONAL_SMALL"),
            DecalPatternType::DiamondGridLarge => write!(f, "DIAMOND_GRID_LARGE"),
            DecalPatternType::DiamondGridMedium => write!(f, "DIAMOND_GRID_MEDIUM"),
            DecalPatternType::DiamondGridSmall => write!(f, "DIAMOND_GRID_SMALL"),
            DecalPatternType::DiamondLarge => write!(f, "DIAMOND_LARGE"),
            DecalPatternType::DiamondMedium => write!(f, "DIAMOND_MEDIUM"),
            DecalPatternType::DiamondSmall => write!(f, "DIAMOND_SMALL"),
            DecalPatternType::Solid => write!(f, "SOLID"),
            DecalPatternType::TriangleLarge => write!(f, "TRIANGLE_LARGE"),
            DecalPatternType::TriangleMedium => write!(f, "TRIANGLE_MEDIUM"),
            DecalPatternType::TriangleSmall => write!(f, "TRIANGLE_SMALL"),
            DecalPatternType::Unknown(value) => write!(f, "{value}"),
        }
    }
}
