// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelIngestionError {
    pub kind: CancelIngestionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelIngestionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelIngestionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelIngestionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CancelIngestionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CancelIngestionErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CancelIngestionErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            CancelIngestionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CancelIngestionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CancelIngestionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelIngestionError {
    fn code(&self) -> Option<&str> {
        CancelIngestionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelIngestionError {
    pub fn new(kind: CancelIngestionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelIngestionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelIngestionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelIngestionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelIngestionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelIngestionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelIngestionErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelIngestionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CancelIngestionErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CancelIngestionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelIngestionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CancelIngestionErrorKind::InternalFailureException(_inner) => Some(_inner),
            CancelIngestionErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CancelIngestionErrorKind::ResourceExistsException(_inner) => Some(_inner),
            CancelIngestionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CancelIngestionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelIngestionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAccountCustomizationError {
    pub kind: CreateAccountCustomizationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAccountCustomizationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAccountCustomizationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAccountCustomizationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateAccountCustomizationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateAccountCustomizationErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            CreateAccountCustomizationErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            CreateAccountCustomizationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateAccountCustomizationErrorKind::ResourceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreateAccountCustomizationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateAccountCustomizationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAccountCustomizationError {
    fn code(&self) -> Option<&str> {
        CreateAccountCustomizationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAccountCustomizationError {
    pub fn new(kind: CreateAccountCustomizationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAccountCustomizationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAccountCustomizationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccountCustomizationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccountCustomizationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccountCustomizationErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccountCustomizationErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccountCustomizationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccountCustomizationErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccountCustomizationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateAccountCustomizationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAccountCustomizationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateAccountCustomizationErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateAccountCustomizationErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            CreateAccountCustomizationErrorKind::ResourceExistsException(_inner) => Some(_inner),
            CreateAccountCustomizationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateAccountCustomizationErrorKind::ResourceUnavailableException(_inner) => {
                Some(_inner)
            }
            CreateAccountCustomizationErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateAccountCustomizationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAnalysisError {
    pub kind: CreateAnalysisErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAnalysisErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAnalysisError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAnalysisErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateAnalysisErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateAnalysisErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateAnalysisErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            CreateAnalysisErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateAnalysisErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateAnalysisErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            CreateAnalysisErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAnalysisError {
    fn code(&self) -> Option<&str> {
        CreateAnalysisError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAnalysisError {
    pub fn new(kind: CreateAnalysisErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAnalysisErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAnalysisErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateAnalysisErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAnalysisErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAnalysisErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAnalysisErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAnalysisErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateAnalysisErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAnalysisErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for CreateAnalysisError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAnalysisErrorKind::ConflictException(_inner) => Some(_inner),
            CreateAnalysisErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateAnalysisErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateAnalysisErrorKind::ResourceExistsException(_inner) => Some(_inner),
            CreateAnalysisErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateAnalysisErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateAnalysisErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            CreateAnalysisErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDashboardError {
    pub kind: CreateDashboardErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDashboardErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDashboardError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDashboardErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateDashboardErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateDashboardErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateDashboardErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            CreateDashboardErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateDashboardErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateDashboardErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            CreateDashboardErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDashboardError {
    fn code(&self) -> Option<&str> {
        CreateDashboardError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDashboardError {
    pub fn new(kind: CreateDashboardErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDashboardErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDashboardErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateDashboardErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDashboardErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDashboardErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDashboardErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDashboardErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateDashboardErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDashboardErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for CreateDashboardError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDashboardErrorKind::ConflictException(_inner) => Some(_inner),
            CreateDashboardErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateDashboardErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateDashboardErrorKind::ResourceExistsException(_inner) => Some(_inner),
            CreateDashboardErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateDashboardErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateDashboardErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            CreateDashboardErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDataSetError {
    pub kind: CreateDataSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDataSetErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDataSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDataSetErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateDataSetErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateDataSetErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateDataSetErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateDataSetErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateDataSetErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            CreateDataSetErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateDataSetErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateDataSetErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            CreateDataSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDataSetError {
    fn code(&self) -> Option<&str> {
        CreateDataSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDataSetError {
    pub fn new(kind: CreateDataSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDataSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDataSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateDataSetErrorKind::AccessDeniedException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateDataSetErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSetErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSetErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSetErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSetErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSetErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateDataSetErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSetErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for CreateDataSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDataSetErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateDataSetErrorKind::ConflictException(_inner) => Some(_inner),
            CreateDataSetErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateDataSetErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateDataSetErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateDataSetErrorKind::ResourceExistsException(_inner) => Some(_inner),
            CreateDataSetErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateDataSetErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateDataSetErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            CreateDataSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDataSourceError {
    pub kind: CreateDataSourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDataSourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDataSourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDataSourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDataSourceError {
    fn code(&self) -> Option<&str> {
        CreateDataSourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDataSourceError {
    pub fn new(kind: CreateDataSourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDataSourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDataSourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateDataSourceErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSourceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSourceErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSourceErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSourceErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateDataSourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDataSourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::ConflictException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::ResourceExistsException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateFolderError {
    pub kind: CreateFolderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFolderErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateFolderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateFolderErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateFolderErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateFolderErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateFolderErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateFolderErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateFolderErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            CreateFolderErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateFolderErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateFolderErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            CreateFolderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateFolderError {
    fn code(&self) -> Option<&str> {
        CreateFolderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFolderError {
    pub fn new(kind: CreateFolderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateFolderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateFolderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateFolderErrorKind::AccessDeniedException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateFolderErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFolderErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFolderErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateFolderErrorKind::LimitExceededException(_))
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFolderErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFolderErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateFolderErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFolderErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for CreateFolderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateFolderErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateFolderErrorKind::ConflictException(_inner) => Some(_inner),
            CreateFolderErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateFolderErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateFolderErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateFolderErrorKind::ResourceExistsException(_inner) => Some(_inner),
            CreateFolderErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateFolderErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateFolderErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            CreateFolderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateFolderMembershipError {
    pub kind: CreateFolderMembershipErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFolderMembershipErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateFolderMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateFolderMembershipErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateFolderMembershipErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateFolderMembershipErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            CreateFolderMembershipErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateFolderMembershipErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            CreateFolderMembershipErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateFolderMembershipErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateFolderMembershipErrorKind::UnsupportedUserEditionException(_inner) => {
                _inner.fmt(f)
            }
            CreateFolderMembershipErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateFolderMembershipError {
    fn code(&self) -> Option<&str> {
        CreateFolderMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFolderMembershipError {
    pub fn new(kind: CreateFolderMembershipErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateFolderMembershipErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateFolderMembershipErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFolderMembershipErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFolderMembershipErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFolderMembershipErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFolderMembershipErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFolderMembershipErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFolderMembershipErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFolderMembershipErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFolderMembershipErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for CreateFolderMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateFolderMembershipErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateFolderMembershipErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateFolderMembershipErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateFolderMembershipErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateFolderMembershipErrorKind::ResourceExistsException(_inner) => Some(_inner),
            CreateFolderMembershipErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateFolderMembershipErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateFolderMembershipErrorKind::UnsupportedUserEditionException(_inner) => {
                Some(_inner)
            }
            CreateFolderMembershipErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGroupError {
    pub kind: CreateGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGroupErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateGroupErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateGroupError {
    fn code(&self) -> Option<&str> {
        CreateGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateGroupError {
    pub fn new(kind: CreateGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateGroupErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGroupErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateGroupErrorKind::LimitExceededException(_))
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGroupErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(&self.kind, CreateGroupErrorKind::ResourceExistsException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGroupErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateGroupErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CreateGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateGroupErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateGroupErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateGroupErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateGroupErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            CreateGroupErrorKind::ResourceExistsException(_inner) => Some(_inner),
            CreateGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateGroupErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            CreateGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGroupMembershipError {
    pub kind: CreateGroupMembershipErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGroupMembershipErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGroupMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateGroupMembershipErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateGroupMembershipErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateGroupMembershipErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateGroupMembershipErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            CreateGroupMembershipErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateGroupMembershipErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            CreateGroupMembershipErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateGroupMembershipErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateGroupMembershipError {
    fn code(&self) -> Option<&str> {
        CreateGroupMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateGroupMembershipError {
    pub fn new(kind: CreateGroupMembershipErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateGroupMembershipErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateGroupMembershipErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGroupMembershipErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGroupMembershipErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGroupMembershipErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGroupMembershipErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGroupMembershipErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGroupMembershipErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGroupMembershipErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateGroupMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateGroupMembershipErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateGroupMembershipErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateGroupMembershipErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateGroupMembershipErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            CreateGroupMembershipErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateGroupMembershipErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            CreateGroupMembershipErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateGroupMembershipErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateIAMPolicyAssignmentError {
    pub kind: CreateIAMPolicyAssignmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateIAMPolicyAssignmentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConcurrentUpdatingException(crate::error::ConcurrentUpdatingException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateIAMPolicyAssignmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateIAMPolicyAssignmentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateIAMPolicyAssignmentErrorKind::ConcurrentUpdatingException(_inner) => {
                _inner.fmt(f)
            }
            CreateIAMPolicyAssignmentErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateIAMPolicyAssignmentErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            CreateIAMPolicyAssignmentErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            CreateIAMPolicyAssignmentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateIAMPolicyAssignmentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateIAMPolicyAssignmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateIAMPolicyAssignmentError {
    fn code(&self) -> Option<&str> {
        CreateIAMPolicyAssignmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateIAMPolicyAssignmentError {
    pub fn new(kind: CreateIAMPolicyAssignmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateIAMPolicyAssignmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateIAMPolicyAssignmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIAMPolicyAssignmentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_concurrent_updating_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIAMPolicyAssignmentErrorKind::ConcurrentUpdatingException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIAMPolicyAssignmentErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIAMPolicyAssignmentErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIAMPolicyAssignmentErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIAMPolicyAssignmentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIAMPolicyAssignmentErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for CreateIAMPolicyAssignmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateIAMPolicyAssignmentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateIAMPolicyAssignmentErrorKind::ConcurrentUpdatingException(_inner) => Some(_inner),
            CreateIAMPolicyAssignmentErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateIAMPolicyAssignmentErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            CreateIAMPolicyAssignmentErrorKind::ResourceExistsException(_inner) => Some(_inner),
            CreateIAMPolicyAssignmentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateIAMPolicyAssignmentErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateIAMPolicyAssignmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateIngestionError {
    pub kind: CreateIngestionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateIngestionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateIngestionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateIngestionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateIngestionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateIngestionErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateIngestionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateIngestionErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            CreateIngestionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateIngestionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateIngestionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateIngestionError {
    fn code(&self) -> Option<&str> {
        CreateIngestionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateIngestionError {
    pub fn new(kind: CreateIngestionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateIngestionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateIngestionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIngestionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIngestionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIngestionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIngestionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIngestionErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIngestionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateIngestionErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CreateIngestionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateIngestionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateIngestionErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateIngestionErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateIngestionErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateIngestionErrorKind::ResourceExistsException(_inner) => Some(_inner),
            CreateIngestionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateIngestionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateIngestionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateNamespaceError {
    pub kind: CreateNamespaceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateNamespaceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateNamespaceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateNamespaceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateNamespaceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateNamespaceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateNamespaceErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateNamespaceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateNamespaceErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            CreateNamespaceErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            CreateNamespaceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateNamespaceErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            CreateNamespaceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateNamespaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateNamespaceError {
    fn code(&self) -> Option<&str> {
        CreateNamespaceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateNamespaceError {
    pub fn new(kind: CreateNamespaceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateNamespaceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateNamespaceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateNamespaceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateNamespaceErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateNamespaceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateNamespaceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateNamespaceErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateNamespaceErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateNamespaceErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateNamespaceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateNamespaceErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateNamespaceErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for CreateNamespaceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateNamespaceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateNamespaceErrorKind::ConflictException(_inner) => Some(_inner),
            CreateNamespaceErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateNamespaceErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateNamespaceErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateNamespaceErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            CreateNamespaceErrorKind::ResourceExistsException(_inner) => Some(_inner),
            CreateNamespaceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateNamespaceErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            CreateNamespaceErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateNamespaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTemplateError {
    pub kind: CreateTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTemplateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTemplateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateTemplateErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateTemplateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateTemplateErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateTemplateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateTemplateErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            CreateTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateTemplateErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            CreateTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTemplateError {
    fn code(&self) -> Option<&str> {
        CreateTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTemplateError {
    pub fn new(kind: CreateTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTemplateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateTemplateErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTemplateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTemplateErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTemplateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTemplateErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateTemplateErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTemplateErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for CreateTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTemplateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateTemplateErrorKind::ConflictException(_inner) => Some(_inner),
            CreateTemplateErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateTemplateErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateTemplateErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateTemplateErrorKind::ResourceExistsException(_inner) => Some(_inner),
            CreateTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateTemplateErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            CreateTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTemplateAliasError {
    pub kind: CreateTemplateAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTemplateAliasErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTemplateAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTemplateAliasErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateTemplateAliasErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateTemplateAliasErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateTemplateAliasErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            CreateTemplateAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateTemplateAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateTemplateAliasErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            CreateTemplateAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTemplateAliasError {
    fn code(&self) -> Option<&str> {
        CreateTemplateAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTemplateAliasError {
    pub fn new(kind: CreateTemplateAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTemplateAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTemplateAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTemplateAliasErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTemplateAliasErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTemplateAliasErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTemplateAliasErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTemplateAliasErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTemplateAliasErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTemplateAliasErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for CreateTemplateAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTemplateAliasErrorKind::ConflictException(_inner) => Some(_inner),
            CreateTemplateAliasErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateTemplateAliasErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateTemplateAliasErrorKind::ResourceExistsException(_inner) => Some(_inner),
            CreateTemplateAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateTemplateAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateTemplateAliasErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            CreateTemplateAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateThemeError {
    pub kind: CreateThemeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateThemeErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateThemeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateThemeErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateThemeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateThemeErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateThemeErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateThemeErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            CreateThemeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateThemeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateThemeErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            CreateThemeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateThemeError {
    fn code(&self) -> Option<&str> {
        CreateThemeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateThemeError {
    pub fn new(kind: CreateThemeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateThemeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateThemeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateThemeErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThemeErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThemeErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateThemeErrorKind::LimitExceededException(_))
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(&self.kind, CreateThemeErrorKind::ResourceExistsException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThemeErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateThemeErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThemeErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for CreateThemeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateThemeErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateThemeErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateThemeErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateThemeErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateThemeErrorKind::ResourceExistsException(_inner) => Some(_inner),
            CreateThemeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateThemeErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateThemeErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            CreateThemeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateThemeAliasError {
    pub kind: CreateThemeAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateThemeAliasErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateThemeAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateThemeAliasErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateThemeAliasErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateThemeAliasErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateThemeAliasErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateThemeAliasErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            CreateThemeAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateThemeAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateThemeAliasErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            CreateThemeAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateThemeAliasError {
    fn code(&self) -> Option<&str> {
        CreateThemeAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateThemeAliasError {
    pub fn new(kind: CreateThemeAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateThemeAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateThemeAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateThemeAliasErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThemeAliasErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThemeAliasErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThemeAliasErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThemeAliasErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThemeAliasErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThemeAliasErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateThemeAliasErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for CreateThemeAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateThemeAliasErrorKind::ConflictException(_inner) => Some(_inner),
            CreateThemeAliasErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateThemeAliasErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateThemeAliasErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateThemeAliasErrorKind::ResourceExistsException(_inner) => Some(_inner),
            CreateThemeAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateThemeAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateThemeAliasErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            CreateThemeAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAccountCustomizationError {
    pub kind: DeleteAccountCustomizationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAccountCustomizationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAccountCustomizationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAccountCustomizationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteAccountCustomizationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteAccountCustomizationErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAccountCustomizationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteAccountCustomizationErrorKind::ResourceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAccountCustomizationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteAccountCustomizationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAccountCustomizationError {
    fn code(&self) -> Option<&str> {
        DeleteAccountCustomizationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAccountCustomizationError {
    pub fn new(kind: DeleteAccountCustomizationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAccountCustomizationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAccountCustomizationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountCustomizationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountCustomizationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountCustomizationErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountCustomizationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountCustomizationErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountCustomizationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteAccountCustomizationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAccountCustomizationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteAccountCustomizationErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteAccountCustomizationErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteAccountCustomizationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteAccountCustomizationErrorKind::ResourceUnavailableException(_inner) => {
                Some(_inner)
            }
            DeleteAccountCustomizationErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteAccountCustomizationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAnalysisError {
    pub kind: DeleteAnalysisErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAnalysisErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAnalysisError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAnalysisErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteAnalysisErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteAnalysisErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteAnalysisErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteAnalysisErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteAnalysisErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            DeleteAnalysisErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAnalysisError {
    fn code(&self) -> Option<&str> {
        DeleteAnalysisError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAnalysisError {
    pub fn new(kind: DeleteAnalysisErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAnalysisErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAnalysisErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteAnalysisErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAnalysisErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAnalysisErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAnalysisErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteAnalysisErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAnalysisErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DeleteAnalysisError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAnalysisErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteAnalysisErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteAnalysisErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteAnalysisErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteAnalysisErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteAnalysisErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            DeleteAnalysisErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDashboardError {
    pub kind: DeleteDashboardErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDashboardErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDashboardError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDashboardErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteDashboardErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteDashboardErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteDashboardErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteDashboardErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteDashboardErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            DeleteDashboardErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDashboardError {
    fn code(&self) -> Option<&str> {
        DeleteDashboardError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDashboardError {
    pub fn new(kind: DeleteDashboardErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDashboardErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDashboardErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteDashboardErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDashboardErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDashboardErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDashboardErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteDashboardErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDashboardErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DeleteDashboardError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDashboardErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteDashboardErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteDashboardErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteDashboardErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteDashboardErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteDashboardErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            DeleteDashboardErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDataSetError {
    pub kind: DeleteDataSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDataSetErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDataSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDataSetErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteDataSetErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteDataSetErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteDataSetErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteDataSetErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteDataSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDataSetError {
    fn code(&self) -> Option<&str> {
        DeleteDataSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDataSetError {
    pub fn new(kind: DeleteDataSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDataSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDataSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteDataSetErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDataSetErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDataSetErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDataSetErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteDataSetErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DeleteDataSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDataSetErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteDataSetErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteDataSetErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteDataSetErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteDataSetErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteDataSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDataSourceError {
    pub kind: DeleteDataSourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDataSourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDataSourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDataSourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteDataSourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteDataSourceErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteDataSourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteDataSourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteDataSourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDataSourceError {
    fn code(&self) -> Option<&str> {
        DeleteDataSourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDataSourceError {
    pub fn new(kind: DeleteDataSourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDataSourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDataSourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDataSourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDataSourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDataSourceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDataSourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDataSourceErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteDataSourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDataSourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteDataSourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteDataSourceErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteDataSourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteDataSourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteDataSourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFolderError {
    pub kind: DeleteFolderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFolderErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFolderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFolderErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteFolderErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteFolderErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteFolderErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteFolderErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            DeleteFolderErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteFolderErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteFolderErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            DeleteFolderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFolderError {
    fn code(&self) -> Option<&str> {
        DeleteFolderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFolderError {
    pub fn new(kind: DeleteFolderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFolderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFolderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteFolderErrorKind::AccessDeniedException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteFolderErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFolderErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFolderErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFolderErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFolderErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteFolderErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFolderErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DeleteFolderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFolderErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteFolderErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteFolderErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteFolderErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteFolderErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            DeleteFolderErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteFolderErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteFolderErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            DeleteFolderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFolderMembershipError {
    pub kind: DeleteFolderMembershipErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFolderMembershipErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFolderMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFolderMembershipErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteFolderMembershipErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteFolderMembershipErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteFolderMembershipErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteFolderMembershipErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteFolderMembershipErrorKind::UnsupportedUserEditionException(_inner) => {
                _inner.fmt(f)
            }
            DeleteFolderMembershipErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFolderMembershipError {
    fn code(&self) -> Option<&str> {
        DeleteFolderMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFolderMembershipError {
    pub fn new(kind: DeleteFolderMembershipErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFolderMembershipErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFolderMembershipErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFolderMembershipErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFolderMembershipErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFolderMembershipErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFolderMembershipErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFolderMembershipErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFolderMembershipErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DeleteFolderMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFolderMembershipErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteFolderMembershipErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteFolderMembershipErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteFolderMembershipErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteFolderMembershipErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteFolderMembershipErrorKind::UnsupportedUserEditionException(_inner) => {
                Some(_inner)
            }
            DeleteFolderMembershipErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteGroupError {
    pub kind: DeleteGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGroupErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteGroupErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteGroupError {
    fn code(&self) -> Option<&str> {
        DeleteGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteGroupError {
    pub fn new(kind: DeleteGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteGroupErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteGroupErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DeleteGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteGroupErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteGroupErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteGroupErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            DeleteGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteGroupErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            DeleteGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteGroupMembershipError {
    pub kind: DeleteGroupMembershipErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGroupMembershipErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteGroupMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteGroupMembershipErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteGroupMembershipErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteGroupMembershipErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteGroupMembershipErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            DeleteGroupMembershipErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteGroupMembershipErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            DeleteGroupMembershipErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteGroupMembershipErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteGroupMembershipError {
    fn code(&self) -> Option<&str> {
        DeleteGroupMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteGroupMembershipError {
    pub fn new(kind: DeleteGroupMembershipErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteGroupMembershipErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteGroupMembershipErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupMembershipErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupMembershipErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupMembershipErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupMembershipErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupMembershipErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupMembershipErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupMembershipErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteGroupMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteGroupMembershipErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteGroupMembershipErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteGroupMembershipErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteGroupMembershipErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            DeleteGroupMembershipErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteGroupMembershipErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            DeleteGroupMembershipErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteGroupMembershipErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteIAMPolicyAssignmentError {
    pub kind: DeleteIAMPolicyAssignmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteIAMPolicyAssignmentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConcurrentUpdatingException(crate::error::ConcurrentUpdatingException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteIAMPolicyAssignmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteIAMPolicyAssignmentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteIAMPolicyAssignmentErrorKind::ConcurrentUpdatingException(_inner) => {
                _inner.fmt(f)
            }
            DeleteIAMPolicyAssignmentErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteIAMPolicyAssignmentErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteIAMPolicyAssignmentErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            DeleteIAMPolicyAssignmentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteIAMPolicyAssignmentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteIAMPolicyAssignmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteIAMPolicyAssignmentError {
    fn code(&self) -> Option<&str> {
        DeleteIAMPolicyAssignmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteIAMPolicyAssignmentError {
    pub fn new(kind: DeleteIAMPolicyAssignmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteIAMPolicyAssignmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteIAMPolicyAssignmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIAMPolicyAssignmentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_concurrent_updating_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIAMPolicyAssignmentErrorKind::ConcurrentUpdatingException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIAMPolicyAssignmentErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIAMPolicyAssignmentErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIAMPolicyAssignmentErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIAMPolicyAssignmentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIAMPolicyAssignmentErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteIAMPolicyAssignmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteIAMPolicyAssignmentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteIAMPolicyAssignmentErrorKind::ConcurrentUpdatingException(_inner) => Some(_inner),
            DeleteIAMPolicyAssignmentErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteIAMPolicyAssignmentErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteIAMPolicyAssignmentErrorKind::ResourceExistsException(_inner) => Some(_inner),
            DeleteIAMPolicyAssignmentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteIAMPolicyAssignmentErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteIAMPolicyAssignmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteNamespaceError {
    pub kind: DeleteNamespaceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteNamespaceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteNamespaceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteNamespaceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteNamespaceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteNamespaceErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteNamespaceErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            DeleteNamespaceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteNamespaceErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            DeleteNamespaceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteNamespaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteNamespaceError {
    fn code(&self) -> Option<&str> {
        DeleteNamespaceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteNamespaceError {
    pub fn new(kind: DeleteNamespaceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteNamespaceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteNamespaceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteNamespaceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteNamespaceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteNamespaceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteNamespaceErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteNamespaceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteNamespaceErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteNamespaceErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DeleteNamespaceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteNamespaceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteNamespaceErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteNamespaceErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteNamespaceErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            DeleteNamespaceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteNamespaceErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            DeleteNamespaceErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteNamespaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTemplateError {
    pub kind: DeleteTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTemplateErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTemplateErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteTemplateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteTemplateErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteTemplateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteTemplateErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            DeleteTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTemplateError {
    pub fn new(kind: DeleteTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteTemplateErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTemplateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTemplateErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTemplateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteTemplateErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTemplateErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DeleteTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTemplateErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteTemplateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteTemplateErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteTemplateErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteTemplateErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            DeleteTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTemplateAliasError {
    pub kind: DeleteTemplateAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTemplateAliasErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTemplateAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTemplateAliasErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteTemplateAliasErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteTemplateAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteTemplateAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteTemplateAliasErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            DeleteTemplateAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTemplateAliasError {
    fn code(&self) -> Option<&str> {
        DeleteTemplateAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTemplateAliasError {
    pub fn new(kind: DeleteTemplateAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTemplateAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTemplateAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTemplateAliasErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTemplateAliasErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTemplateAliasErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTemplateAliasErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTemplateAliasErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DeleteTemplateAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTemplateAliasErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteTemplateAliasErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteTemplateAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteTemplateAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteTemplateAliasErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            DeleteTemplateAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteThemeError {
    pub kind: DeleteThemeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteThemeErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteThemeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteThemeErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteThemeErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteThemeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteThemeErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteThemeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteThemeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteThemeErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            DeleteThemeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteThemeError {
    fn code(&self) -> Option<&str> {
        DeleteThemeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteThemeError {
    pub fn new(kind: DeleteThemeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteThemeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteThemeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteThemeErrorKind::AccessDeniedException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteThemeErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThemeErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThemeErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThemeErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteThemeErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThemeErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DeleteThemeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteThemeErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteThemeErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteThemeErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteThemeErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteThemeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteThemeErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteThemeErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            DeleteThemeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteThemeAliasError {
    pub kind: DeleteThemeAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteThemeAliasErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteThemeAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteThemeAliasErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteThemeAliasErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteThemeAliasErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteThemeAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteThemeAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteThemeAliasErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            DeleteThemeAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteThemeAliasError {
    fn code(&self) -> Option<&str> {
        DeleteThemeAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteThemeAliasError {
    pub fn new(kind: DeleteThemeAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteThemeAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteThemeAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteThemeAliasErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThemeAliasErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThemeAliasErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThemeAliasErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThemeAliasErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteThemeAliasErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DeleteThemeAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteThemeAliasErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteThemeAliasErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteThemeAliasErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteThemeAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteThemeAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteThemeAliasErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            DeleteThemeAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserError {
    pub kind: DeleteUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserError {
    fn code(&self) -> Option<&str> {
        DeleteUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserError {
    pub fn new(kind: DeleteUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::InternalFailureException(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DeleteUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteUserErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteUserErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteUserErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            DeleteUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteUserErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            DeleteUserErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserByPrincipalIdError {
    pub kind: DeleteUserByPrincipalIdErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserByPrincipalIdErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserByPrincipalIdError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserByPrincipalIdErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteUserByPrincipalIdErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteUserByPrincipalIdErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteUserByPrincipalIdErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            DeleteUserByPrincipalIdErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteUserByPrincipalIdErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            DeleteUserByPrincipalIdErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteUserByPrincipalIdErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserByPrincipalIdError {
    fn code(&self) -> Option<&str> {
        DeleteUserByPrincipalIdError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserByPrincipalIdError {
    pub fn new(kind: DeleteUserByPrincipalIdErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserByPrincipalIdErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserByPrincipalIdErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserByPrincipalIdErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserByPrincipalIdErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserByPrincipalIdErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserByPrincipalIdErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserByPrincipalIdErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserByPrincipalIdErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserByPrincipalIdErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DeleteUserByPrincipalIdError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserByPrincipalIdErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteUserByPrincipalIdErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteUserByPrincipalIdErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteUserByPrincipalIdErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            DeleteUserByPrincipalIdErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteUserByPrincipalIdErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            DeleteUserByPrincipalIdErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteUserByPrincipalIdErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAccountCustomizationError {
    pub kind: DescribeAccountCustomizationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAccountCustomizationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAccountCustomizationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAccountCustomizationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeAccountCustomizationErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAccountCustomizationErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAccountCustomizationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAccountCustomizationErrorKind::ResourceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAccountCustomizationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeAccountCustomizationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAccountCustomizationError {
    fn code(&self) -> Option<&str> {
        DescribeAccountCustomizationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAccountCustomizationError {
    pub fn new(kind: DescribeAccountCustomizationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAccountCustomizationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAccountCustomizationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAccountCustomizationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAccountCustomizationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAccountCustomizationErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAccountCustomizationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAccountCustomizationErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAccountCustomizationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeAccountCustomizationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAccountCustomizationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeAccountCustomizationErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeAccountCustomizationErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeAccountCustomizationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeAccountCustomizationErrorKind::ResourceUnavailableException(_inner) => {
                Some(_inner)
            }
            DescribeAccountCustomizationErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeAccountCustomizationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAccountSettingsError {
    pub kind: DescribeAccountSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAccountSettingsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAccountSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAccountSettingsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeAccountSettingsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeAccountSettingsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAccountSettingsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeAccountSettingsErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            DescribeAccountSettingsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeAccountSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAccountSettingsError {
    fn code(&self) -> Option<&str> {
        DescribeAccountSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAccountSettingsError {
    pub fn new(kind: DescribeAccountSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAccountSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAccountSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAccountSettingsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAccountSettingsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAccountSettingsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAccountSettingsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAccountSettingsErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAccountSettingsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeAccountSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAccountSettingsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeAccountSettingsErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeAccountSettingsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeAccountSettingsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeAccountSettingsErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            DescribeAccountSettingsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeAccountSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAnalysisError {
    pub kind: DescribeAnalysisErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAnalysisErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAnalysisError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAnalysisErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeAnalysisErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeAnalysisErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeAnalysisErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeAnalysisErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeAnalysisErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            DescribeAnalysisErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAnalysisError {
    fn code(&self) -> Option<&str> {
        DescribeAnalysisError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAnalysisError {
    pub fn new(kind: DescribeAnalysisErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAnalysisErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAnalysisErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAnalysisErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAnalysisErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAnalysisErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAnalysisErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAnalysisErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAnalysisErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DescribeAnalysisError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAnalysisErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeAnalysisErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeAnalysisErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeAnalysisErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeAnalysisErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeAnalysisErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            DescribeAnalysisErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAnalysisPermissionsError {
    pub kind: DescribeAnalysisPermissionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAnalysisPermissionsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAnalysisPermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAnalysisPermissionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeAnalysisPermissionsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAnalysisPermissionsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAnalysisPermissionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeAnalysisPermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAnalysisPermissionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAnalysisPermissionsError {
    fn code(&self) -> Option<&str> {
        DescribeAnalysisPermissionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAnalysisPermissionsError {
    pub fn new(kind: DescribeAnalysisPermissionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAnalysisPermissionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAnalysisPermissionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAnalysisPermissionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAnalysisPermissionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAnalysisPermissionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAnalysisPermissionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAnalysisPermissionsErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DescribeAnalysisPermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAnalysisPermissionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeAnalysisPermissionsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeAnalysisPermissionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeAnalysisPermissionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeAnalysisPermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                Some(_inner)
            }
            DescribeAnalysisPermissionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDashboardError {
    pub kind: DescribeDashboardErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDashboardErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDashboardError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDashboardErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeDashboardErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeDashboardErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeDashboardErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeDashboardErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeDashboardErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            DescribeDashboardErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDashboardError {
    fn code(&self) -> Option<&str> {
        DescribeDashboardError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDashboardError {
    pub fn new(kind: DescribeDashboardErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDashboardErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDashboardErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDashboardErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDashboardErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDashboardErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDashboardErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDashboardErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDashboardErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DescribeDashboardError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDashboardErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeDashboardErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeDashboardErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeDashboardErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeDashboardErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeDashboardErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            DescribeDashboardErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDashboardPermissionsError {
    pub kind: DescribeDashboardPermissionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDashboardPermissionsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDashboardPermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDashboardPermissionsErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDashboardPermissionsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDashboardPermissionsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDashboardPermissionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeDashboardPermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDashboardPermissionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDashboardPermissionsError {
    fn code(&self) -> Option<&str> {
        DescribeDashboardPermissionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDashboardPermissionsError {
    pub fn new(kind: DescribeDashboardPermissionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDashboardPermissionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDashboardPermissionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDashboardPermissionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDashboardPermissionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDashboardPermissionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDashboardPermissionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDashboardPermissionsErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DescribeDashboardPermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDashboardPermissionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeDashboardPermissionsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeDashboardPermissionsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeDashboardPermissionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeDashboardPermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                Some(_inner)
            }
            DescribeDashboardPermissionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDataSetError {
    pub kind: DescribeDataSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDataSetErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDataSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDataSetErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeDataSetErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeDataSetErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeDataSetErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeDataSetErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeDataSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDataSetError {
    fn code(&self) -> Option<&str> {
        DescribeDataSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDataSetError {
    pub fn new(kind: DescribeDataSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDataSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDataSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSetErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSetErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSetErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSetErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeDataSetErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DescribeDataSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDataSetErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeDataSetErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeDataSetErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeDataSetErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeDataSetErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeDataSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDataSetPermissionsError {
    pub kind: DescribeDataSetPermissionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDataSetPermissionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDataSetPermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDataSetPermissionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeDataSetPermissionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeDataSetPermissionsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDataSetPermissionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeDataSetPermissionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeDataSetPermissionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDataSetPermissionsError {
    fn code(&self) -> Option<&str> {
        DescribeDataSetPermissionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDataSetPermissionsError {
    pub fn new(kind: DescribeDataSetPermissionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDataSetPermissionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDataSetPermissionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSetPermissionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSetPermissionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSetPermissionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSetPermissionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSetPermissionsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeDataSetPermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDataSetPermissionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeDataSetPermissionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeDataSetPermissionsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeDataSetPermissionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeDataSetPermissionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeDataSetPermissionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDataSourceError {
    pub kind: DescribeDataSourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDataSourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDataSourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDataSourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeDataSourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeDataSourceErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeDataSourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeDataSourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeDataSourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDataSourceError {
    fn code(&self) -> Option<&str> {
        DescribeDataSourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDataSourceError {
    pub fn new(kind: DescribeDataSourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDataSourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDataSourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSourceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSourceErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeDataSourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDataSourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeDataSourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeDataSourceErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeDataSourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeDataSourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeDataSourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDataSourcePermissionsError {
    pub kind: DescribeDataSourcePermissionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDataSourcePermissionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDataSourcePermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDataSourcePermissionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeDataSourcePermissionsErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDataSourcePermissionsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDataSourcePermissionsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDataSourcePermissionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeDataSourcePermissionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDataSourcePermissionsError {
    fn code(&self) -> Option<&str> {
        DescribeDataSourcePermissionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDataSourcePermissionsError {
    pub fn new(kind: DescribeDataSourcePermissionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDataSourcePermissionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDataSourcePermissionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSourcePermissionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSourcePermissionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSourcePermissionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSourcePermissionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataSourcePermissionsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeDataSourcePermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDataSourcePermissionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeDataSourcePermissionsErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            DescribeDataSourcePermissionsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeDataSourcePermissionsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeDataSourcePermissionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeDataSourcePermissionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeFolderError {
    pub kind: DescribeFolderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeFolderErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeFolderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeFolderErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeFolderErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeFolderErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeFolderErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeFolderErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeFolderErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            DescribeFolderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeFolderError {
    fn code(&self) -> Option<&str> {
        DescribeFolderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeFolderError {
    pub fn new(kind: DescribeFolderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeFolderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeFolderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFolderErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFolderErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFolderErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFolderErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeFolderErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFolderErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DescribeFolderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeFolderErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeFolderErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeFolderErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeFolderErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeFolderErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeFolderErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            DescribeFolderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeFolderPermissionsError {
    pub kind: DescribeFolderPermissionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeFolderPermissionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeFolderPermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeFolderPermissionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeFolderPermissionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeFolderPermissionsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeFolderPermissionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeFolderPermissionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeFolderPermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                _inner.fmt(f)
            }
            DescribeFolderPermissionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeFolderPermissionsError {
    fn code(&self) -> Option<&str> {
        DescribeFolderPermissionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeFolderPermissionsError {
    pub fn new(kind: DescribeFolderPermissionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeFolderPermissionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeFolderPermissionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFolderPermissionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFolderPermissionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFolderPermissionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFolderPermissionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFolderPermissionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFolderPermissionsErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DescribeFolderPermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeFolderPermissionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeFolderPermissionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeFolderPermissionsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeFolderPermissionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeFolderPermissionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeFolderPermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                Some(_inner)
            }
            DescribeFolderPermissionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeFolderResolvedPermissionsError {
    pub kind: DescribeFolderResolvedPermissionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeFolderResolvedPermissionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeFolderResolvedPermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeFolderResolvedPermissionsErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DescribeFolderResolvedPermissionsErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DescribeFolderResolvedPermissionsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeFolderResolvedPermissionsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeFolderResolvedPermissionsErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DescribeFolderResolvedPermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                _inner.fmt(f)
            }
            DescribeFolderResolvedPermissionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeFolderResolvedPermissionsError {
    fn code(&self) -> Option<&str> {
        DescribeFolderResolvedPermissionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeFolderResolvedPermissionsError {
    pub fn new(
        kind: DescribeFolderResolvedPermissionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeFolderResolvedPermissionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeFolderResolvedPermissionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFolderResolvedPermissionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFolderResolvedPermissionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFolderResolvedPermissionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFolderResolvedPermissionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFolderResolvedPermissionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFolderResolvedPermissionsErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DescribeFolderResolvedPermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeFolderResolvedPermissionsErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            DescribeFolderResolvedPermissionsErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            DescribeFolderResolvedPermissionsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeFolderResolvedPermissionsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeFolderResolvedPermissionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeFolderResolvedPermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                Some(_inner)
            }
            DescribeFolderResolvedPermissionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeGroupError {
    pub kind: DescribeGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeGroupErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeGroupErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeGroupErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeGroupErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            DescribeGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeGroupErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            DescribeGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeGroupError {
    fn code(&self) -> Option<&str> {
        DescribeGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeGroupError {
    pub fn new(kind: DescribeGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DescribeGroupErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGroupErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGroupErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGroupErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeGroupErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DescribeGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeGroupErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeGroupErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeGroupErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            DescribeGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeGroupErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            DescribeGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeIAMPolicyAssignmentError {
    pub kind: DescribeIAMPolicyAssignmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeIAMPolicyAssignmentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeIAMPolicyAssignmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeIAMPolicyAssignmentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeIAMPolicyAssignmentErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeIAMPolicyAssignmentErrorKind::InvalidNextTokenException(_inner) => {
                _inner.fmt(f)
            }
            DescribeIAMPolicyAssignmentErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeIAMPolicyAssignmentErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeIAMPolicyAssignmentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeIAMPolicyAssignmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeIAMPolicyAssignmentError {
    fn code(&self) -> Option<&str> {
        DescribeIAMPolicyAssignmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeIAMPolicyAssignmentError {
    pub fn new(kind: DescribeIAMPolicyAssignmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeIAMPolicyAssignmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeIAMPolicyAssignmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIAMPolicyAssignmentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIAMPolicyAssignmentErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIAMPolicyAssignmentErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIAMPolicyAssignmentErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIAMPolicyAssignmentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIAMPolicyAssignmentErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeIAMPolicyAssignmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeIAMPolicyAssignmentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeIAMPolicyAssignmentErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeIAMPolicyAssignmentErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            DescribeIAMPolicyAssignmentErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeIAMPolicyAssignmentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeIAMPolicyAssignmentErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeIAMPolicyAssignmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeIngestionError {
    pub kind: DescribeIngestionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeIngestionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeIngestionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeIngestionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeIngestionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeIngestionErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeIngestionErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            DescribeIngestionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeIngestionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeIngestionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeIngestionError {
    fn code(&self) -> Option<&str> {
        DescribeIngestionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeIngestionError {
    pub fn new(kind: DescribeIngestionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeIngestionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeIngestionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIngestionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIngestionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIngestionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIngestionErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIngestionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIngestionErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeIngestionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeIngestionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeIngestionErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeIngestionErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeIngestionErrorKind::ResourceExistsException(_inner) => Some(_inner),
            DescribeIngestionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeIngestionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeIngestionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeNamespaceError {
    pub kind: DescribeNamespaceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeNamespaceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeNamespaceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeNamespaceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeNamespaceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeNamespaceErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeNamespaceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeNamespaceErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            DescribeNamespaceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeNamespaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeNamespaceError {
    fn code(&self) -> Option<&str> {
        DescribeNamespaceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeNamespaceError {
    pub fn new(kind: DescribeNamespaceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeNamespaceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeNamespaceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeNamespaceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeNamespaceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeNamespaceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeNamespaceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeNamespaceErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeNamespaceErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for DescribeNamespaceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeNamespaceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeNamespaceErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeNamespaceErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeNamespaceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeNamespaceErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            DescribeNamespaceErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeNamespaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTemplateError {
    pub kind: DescribeTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTemplateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTemplateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeTemplateErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DescribeTemplateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeTemplateErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeTemplateErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            DescribeTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeTemplateErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            DescribeTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTemplateError {
    fn code(&self) -> Option<&str> {
        DescribeTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTemplateError {
    pub fn new(kind: DescribeTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTemplateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DescribeTemplateErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTemplateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTemplateErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTemplateErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTemplateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTemplateErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DescribeTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTemplateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeTemplateErrorKind::ConflictException(_inner) => Some(_inner),
            DescribeTemplateErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeTemplateErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeTemplateErrorKind::ResourceExistsException(_inner) => Some(_inner),
            DescribeTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeTemplateErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            DescribeTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTemplateAliasError {
    pub kind: DescribeTemplateAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTemplateAliasErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTemplateAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTemplateAliasErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeTemplateAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeTemplateAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeTemplateAliasErrorKind::UnsupportedUserEditionException(_inner) => {
                _inner.fmt(f)
            }
            DescribeTemplateAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTemplateAliasError {
    fn code(&self) -> Option<&str> {
        DescribeTemplateAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTemplateAliasError {
    pub fn new(kind: DescribeTemplateAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTemplateAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTemplateAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTemplateAliasErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTemplateAliasErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTemplateAliasErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTemplateAliasErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DescribeTemplateAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTemplateAliasErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeTemplateAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeTemplateAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeTemplateAliasErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            DescribeTemplateAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTemplatePermissionsError {
    pub kind: DescribeTemplatePermissionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTemplatePermissionsErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTemplatePermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTemplatePermissionsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DescribeTemplatePermissionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeTemplatePermissionsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeTemplatePermissionsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeTemplatePermissionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeTemplatePermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                _inner.fmt(f)
            }
            DescribeTemplatePermissionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTemplatePermissionsError {
    fn code(&self) -> Option<&str> {
        DescribeTemplatePermissionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTemplatePermissionsError {
    pub fn new(kind: DescribeTemplatePermissionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTemplatePermissionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTemplatePermissionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTemplatePermissionsErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTemplatePermissionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTemplatePermissionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTemplatePermissionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTemplatePermissionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTemplatePermissionsErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DescribeTemplatePermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTemplatePermissionsErrorKind::ConflictException(_inner) => Some(_inner),
            DescribeTemplatePermissionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeTemplatePermissionsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeTemplatePermissionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeTemplatePermissionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeTemplatePermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                Some(_inner)
            }
            DescribeTemplatePermissionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeThemeError {
    pub kind: DescribeThemeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeThemeErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeThemeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeThemeErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeThemeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeThemeErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeThemeErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            DescribeThemeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeThemeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeThemeErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            DescribeThemeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeThemeError {
    fn code(&self) -> Option<&str> {
        DescribeThemeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeThemeError {
    pub fn new(kind: DescribeThemeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeThemeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeThemeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DescribeThemeErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThemeErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThemeErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThemeErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThemeErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeThemeErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThemeErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DescribeThemeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeThemeErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeThemeErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeThemeErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeThemeErrorKind::ResourceExistsException(_inner) => Some(_inner),
            DescribeThemeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeThemeErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeThemeErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            DescribeThemeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeThemeAliasError {
    pub kind: DescribeThemeAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeThemeAliasErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeThemeAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeThemeAliasErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DescribeThemeAliasErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeThemeAliasErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeThemeAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeThemeAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeThemeAliasErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            DescribeThemeAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeThemeAliasError {
    fn code(&self) -> Option<&str> {
        DescribeThemeAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeThemeAliasError {
    pub fn new(kind: DescribeThemeAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeThemeAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeThemeAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThemeAliasErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThemeAliasErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThemeAliasErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThemeAliasErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThemeAliasErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThemeAliasErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DescribeThemeAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeThemeAliasErrorKind::ConflictException(_inner) => Some(_inner),
            DescribeThemeAliasErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeThemeAliasErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeThemeAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeThemeAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeThemeAliasErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            DescribeThemeAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeThemePermissionsError {
    pub kind: DescribeThemePermissionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeThemePermissionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeThemePermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeThemePermissionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeThemePermissionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeThemePermissionsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeThemePermissionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeThemePermissionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeThemePermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                _inner.fmt(f)
            }
            DescribeThemePermissionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeThemePermissionsError {
    fn code(&self) -> Option<&str> {
        DescribeThemePermissionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeThemePermissionsError {
    pub fn new(kind: DescribeThemePermissionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeThemePermissionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeThemePermissionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThemePermissionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThemePermissionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThemePermissionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThemePermissionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThemePermissionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeThemePermissionsErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for DescribeThemePermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeThemePermissionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeThemePermissionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeThemePermissionsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeThemePermissionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeThemePermissionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeThemePermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                Some(_inner)
            }
            DescribeThemePermissionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeUserError {
    pub kind: DescribeUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeUserErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeUserErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DescribeUserErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeUserErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeUserErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            DescribeUserErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeUserErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            DescribeUserErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DescribeUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeUserError {
    fn code(&self) -> Option<&str> {
        DescribeUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeUserError {
    pub fn new(kind: DescribeUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DescribeUserErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DescribeUserErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for DescribeUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeUserErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DescribeUserErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeUserErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeUserErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            DescribeUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeUserErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            DescribeUserErrorKind::ThrottlingException(_inner) => Some(_inner),
            DescribeUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateEmbedUrlForAnonymousUserError {
    pub kind: GenerateEmbedUrlForAnonymousUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateEmbedUrlForAnonymousUserErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    SessionLifetimeInMinutesInvalidException(
        crate::error::SessionLifetimeInMinutesInvalidException,
    ),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedPricingPlanException(crate::error::UnsupportedPricingPlanException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateEmbedUrlForAnonymousUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateEmbedUrlForAnonymousUserErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GenerateEmbedUrlForAnonymousUserErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            GenerateEmbedUrlForAnonymousUserErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            GenerateEmbedUrlForAnonymousUserErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GenerateEmbedUrlForAnonymousUserErrorKind::SessionLifetimeInMinutesInvalidException(
                _inner,
            ) => _inner.fmt(f),
            GenerateEmbedUrlForAnonymousUserErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GenerateEmbedUrlForAnonymousUserErrorKind::UnsupportedPricingPlanException(_inner) => {
                _inner.fmt(f)
            }
            GenerateEmbedUrlForAnonymousUserErrorKind::UnsupportedUserEditionException(_inner) => {
                _inner.fmt(f)
            }
            GenerateEmbedUrlForAnonymousUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateEmbedUrlForAnonymousUserError {
    fn code(&self) -> Option<&str> {
        GenerateEmbedUrlForAnonymousUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GenerateEmbedUrlForAnonymousUserError {
    pub fn new(kind: GenerateEmbedUrlForAnonymousUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateEmbedUrlForAnonymousUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateEmbedUrlForAnonymousUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateEmbedUrlForAnonymousUserErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateEmbedUrlForAnonymousUserErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateEmbedUrlForAnonymousUserErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateEmbedUrlForAnonymousUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_session_lifetime_in_minutes_invalid_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateEmbedUrlForAnonymousUserErrorKind::SessionLifetimeInMinutesInvalidException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateEmbedUrlForAnonymousUserErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_pricing_plan_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateEmbedUrlForAnonymousUserErrorKind::UnsupportedPricingPlanException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateEmbedUrlForAnonymousUserErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for GenerateEmbedUrlForAnonymousUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateEmbedUrlForAnonymousUserErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            GenerateEmbedUrlForAnonymousUserErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            GenerateEmbedUrlForAnonymousUserErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            GenerateEmbedUrlForAnonymousUserErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GenerateEmbedUrlForAnonymousUserErrorKind::SessionLifetimeInMinutesInvalidException(
                _inner,
            ) => Some(_inner),
            GenerateEmbedUrlForAnonymousUserErrorKind::ThrottlingException(_inner) => Some(_inner),
            GenerateEmbedUrlForAnonymousUserErrorKind::UnsupportedPricingPlanException(_inner) => {
                Some(_inner)
            }
            GenerateEmbedUrlForAnonymousUserErrorKind::UnsupportedUserEditionException(_inner) => {
                Some(_inner)
            }
            GenerateEmbedUrlForAnonymousUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateEmbedUrlForRegisteredUserError {
    pub kind: GenerateEmbedUrlForRegisteredUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateEmbedUrlForRegisteredUserErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    QuickSightUserNotFoundException(crate::error::QuickSightUserNotFoundException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    SessionLifetimeInMinutesInvalidException(
        crate::error::SessionLifetimeInMinutesInvalidException,
    ),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedPricingPlanException(crate::error::UnsupportedPricingPlanException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateEmbedUrlForRegisteredUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateEmbedUrlForRegisteredUserErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GenerateEmbedUrlForRegisteredUserErrorKind::InternalFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GenerateEmbedUrlForRegisteredUserErrorKind::InvalidParameterValueException(_inner) =>
            _inner.fmt(f)
            ,
            GenerateEmbedUrlForRegisteredUserErrorKind::QuickSightUserNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GenerateEmbedUrlForRegisteredUserErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GenerateEmbedUrlForRegisteredUserErrorKind::SessionLifetimeInMinutesInvalidException(_inner) =>
            _inner.fmt(f)
            ,
            GenerateEmbedUrlForRegisteredUserErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GenerateEmbedUrlForRegisteredUserErrorKind::UnsupportedPricingPlanException(_inner) =>
            _inner.fmt(f)
            ,
            GenerateEmbedUrlForRegisteredUserErrorKind::UnsupportedUserEditionException(_inner) =>
            _inner.fmt(f)
            ,
            GenerateEmbedUrlForRegisteredUserErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateEmbedUrlForRegisteredUserError {
    fn code(&self) -> Option<&str> {
        GenerateEmbedUrlForRegisteredUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GenerateEmbedUrlForRegisteredUserError {
    pub fn new(
        kind: GenerateEmbedUrlForRegisteredUserErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateEmbedUrlForRegisteredUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateEmbedUrlForRegisteredUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateEmbedUrlForRegisteredUserErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateEmbedUrlForRegisteredUserErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateEmbedUrlForRegisteredUserErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_quick_sight_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateEmbedUrlForRegisteredUserErrorKind::QuickSightUserNotFoundException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateEmbedUrlForRegisteredUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_session_lifetime_in_minutes_invalid_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateEmbedUrlForRegisteredUserErrorKind::SessionLifetimeInMinutesInvalidException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateEmbedUrlForRegisteredUserErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_pricing_plan_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateEmbedUrlForRegisteredUserErrorKind::UnsupportedPricingPlanException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateEmbedUrlForRegisteredUserErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for GenerateEmbedUrlForRegisteredUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateEmbedUrlForRegisteredUserErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GenerateEmbedUrlForRegisteredUserErrorKind::InternalFailureException(_inner) =>
            Some(_inner)
            ,
            GenerateEmbedUrlForRegisteredUserErrorKind::InvalidParameterValueException(_inner) =>
            Some(_inner)
            ,
            GenerateEmbedUrlForRegisteredUserErrorKind::QuickSightUserNotFoundException(_inner) =>
            Some(_inner)
            ,
            GenerateEmbedUrlForRegisteredUserErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GenerateEmbedUrlForRegisteredUserErrorKind::SessionLifetimeInMinutesInvalidException(_inner) =>
            Some(_inner)
            ,
            GenerateEmbedUrlForRegisteredUserErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GenerateEmbedUrlForRegisteredUserErrorKind::UnsupportedPricingPlanException(_inner) =>
            Some(_inner)
            ,
            GenerateEmbedUrlForRegisteredUserErrorKind::UnsupportedUserEditionException(_inner) =>
            Some(_inner)
            ,
            GenerateEmbedUrlForRegisteredUserErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDashboardEmbedUrlError {
    pub kind: GetDashboardEmbedUrlErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDashboardEmbedUrlErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    DomainNotWhitelistedException(crate::error::DomainNotWhitelistedException),
    IdentityTypeNotSupportedException(crate::error::IdentityTypeNotSupportedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    QuickSightUserNotFoundException(crate::error::QuickSightUserNotFoundException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    SessionLifetimeInMinutesInvalidException(
        crate::error::SessionLifetimeInMinutesInvalidException,
    ),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedPricingPlanException(crate::error::UnsupportedPricingPlanException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDashboardEmbedUrlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDashboardEmbedUrlErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetDashboardEmbedUrlErrorKind::DomainNotWhitelistedException(_inner) => _inner.fmt(f),
            GetDashboardEmbedUrlErrorKind::IdentityTypeNotSupportedException(_inner) => {
                _inner.fmt(f)
            }
            GetDashboardEmbedUrlErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetDashboardEmbedUrlErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            GetDashboardEmbedUrlErrorKind::QuickSightUserNotFoundException(_inner) => _inner.fmt(f),
            GetDashboardEmbedUrlErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            GetDashboardEmbedUrlErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetDashboardEmbedUrlErrorKind::SessionLifetimeInMinutesInvalidException(_inner) => {
                _inner.fmt(f)
            }
            GetDashboardEmbedUrlErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetDashboardEmbedUrlErrorKind::UnsupportedPricingPlanException(_inner) => _inner.fmt(f),
            GetDashboardEmbedUrlErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            GetDashboardEmbedUrlErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDashboardEmbedUrlError {
    fn code(&self) -> Option<&str> {
        GetDashboardEmbedUrlError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDashboardEmbedUrlError {
    pub fn new(kind: GetDashboardEmbedUrlErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDashboardEmbedUrlErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDashboardEmbedUrlErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDashboardEmbedUrlErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_domain_not_whitelisted_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDashboardEmbedUrlErrorKind::DomainNotWhitelistedException(_)
        )
    }
    pub fn is_identity_type_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDashboardEmbedUrlErrorKind::IdentityTypeNotSupportedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDashboardEmbedUrlErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDashboardEmbedUrlErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_quick_sight_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDashboardEmbedUrlErrorKind::QuickSightUserNotFoundException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDashboardEmbedUrlErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDashboardEmbedUrlErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_session_lifetime_in_minutes_invalid_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDashboardEmbedUrlErrorKind::SessionLifetimeInMinutesInvalidException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDashboardEmbedUrlErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_pricing_plan_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDashboardEmbedUrlErrorKind::UnsupportedPricingPlanException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDashboardEmbedUrlErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for GetDashboardEmbedUrlError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDashboardEmbedUrlErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetDashboardEmbedUrlErrorKind::DomainNotWhitelistedException(_inner) => Some(_inner),
            GetDashboardEmbedUrlErrorKind::IdentityTypeNotSupportedException(_inner) => {
                Some(_inner)
            }
            GetDashboardEmbedUrlErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetDashboardEmbedUrlErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            GetDashboardEmbedUrlErrorKind::QuickSightUserNotFoundException(_inner) => Some(_inner),
            GetDashboardEmbedUrlErrorKind::ResourceExistsException(_inner) => Some(_inner),
            GetDashboardEmbedUrlErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetDashboardEmbedUrlErrorKind::SessionLifetimeInMinutesInvalidException(_inner) => {
                Some(_inner)
            }
            GetDashboardEmbedUrlErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetDashboardEmbedUrlErrorKind::UnsupportedPricingPlanException(_inner) => Some(_inner),
            GetDashboardEmbedUrlErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            GetDashboardEmbedUrlErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSessionEmbedUrlError {
    pub kind: GetSessionEmbedUrlErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSessionEmbedUrlErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    QuickSightUserNotFoundException(crate::error::QuickSightUserNotFoundException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    SessionLifetimeInMinutesInvalidException(
        crate::error::SessionLifetimeInMinutesInvalidException,
    ),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSessionEmbedUrlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSessionEmbedUrlErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetSessionEmbedUrlErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetSessionEmbedUrlErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            GetSessionEmbedUrlErrorKind::QuickSightUserNotFoundException(_inner) => _inner.fmt(f),
            GetSessionEmbedUrlErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            GetSessionEmbedUrlErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetSessionEmbedUrlErrorKind::SessionLifetimeInMinutesInvalidException(_inner) => {
                _inner.fmt(f)
            }
            GetSessionEmbedUrlErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetSessionEmbedUrlErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            GetSessionEmbedUrlErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSessionEmbedUrlError {
    fn code(&self) -> Option<&str> {
        GetSessionEmbedUrlError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSessionEmbedUrlError {
    pub fn new(kind: GetSessionEmbedUrlErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSessionEmbedUrlErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSessionEmbedUrlErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSessionEmbedUrlErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSessionEmbedUrlErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSessionEmbedUrlErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_quick_sight_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSessionEmbedUrlErrorKind::QuickSightUserNotFoundException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSessionEmbedUrlErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSessionEmbedUrlErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_session_lifetime_in_minutes_invalid_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSessionEmbedUrlErrorKind::SessionLifetimeInMinutesInvalidException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSessionEmbedUrlErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSessionEmbedUrlErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for GetSessionEmbedUrlError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSessionEmbedUrlErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetSessionEmbedUrlErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetSessionEmbedUrlErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            GetSessionEmbedUrlErrorKind::QuickSightUserNotFoundException(_inner) => Some(_inner),
            GetSessionEmbedUrlErrorKind::ResourceExistsException(_inner) => Some(_inner),
            GetSessionEmbedUrlErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetSessionEmbedUrlErrorKind::SessionLifetimeInMinutesInvalidException(_inner) => {
                Some(_inner)
            }
            GetSessionEmbedUrlErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetSessionEmbedUrlErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            GetSessionEmbedUrlErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAnalysesError {
    pub kind: ListAnalysesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAnalysesErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAnalysesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAnalysesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListAnalysesErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListAnalysesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListAnalysesErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            ListAnalysesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAnalysesError {
    fn code(&self) -> Option<&str> {
        ListAnalysesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAnalysesError {
    pub fn new(kind: ListAnalysesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAnalysesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAnalysesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAnalysesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAnalysesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListAnalysesErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAnalysesErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for ListAnalysesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAnalysesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListAnalysesErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListAnalysesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListAnalysesErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            ListAnalysesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDashboardsError {
    pub kind: ListDashboardsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDashboardsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDashboardsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDashboardsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListDashboardsErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListDashboardsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListDashboardsErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            ListDashboardsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDashboardsError {
    fn code(&self) -> Option<&str> {
        ListDashboardsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDashboardsError {
    pub fn new(kind: ListDashboardsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDashboardsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDashboardsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDashboardsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDashboardsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListDashboardsErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDashboardsErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for ListDashboardsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDashboardsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListDashboardsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListDashboardsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListDashboardsErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            ListDashboardsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDashboardVersionsError {
    pub kind: ListDashboardVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDashboardVersionsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDashboardVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDashboardVersionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListDashboardVersionsErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListDashboardVersionsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListDashboardVersionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListDashboardVersionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListDashboardVersionsErrorKind::UnsupportedUserEditionException(_inner) => {
                _inner.fmt(f)
            }
            ListDashboardVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDashboardVersionsError {
    fn code(&self) -> Option<&str> {
        ListDashboardVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDashboardVersionsError {
    pub fn new(kind: ListDashboardVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDashboardVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDashboardVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDashboardVersionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDashboardVersionsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDashboardVersionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDashboardVersionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDashboardVersionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDashboardVersionsErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for ListDashboardVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDashboardVersionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListDashboardVersionsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListDashboardVersionsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListDashboardVersionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListDashboardVersionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListDashboardVersionsErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            ListDashboardVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDataSetsError {
    pub kind: ListDataSetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDataSetsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDataSetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDataSetsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListDataSetsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListDataSetsErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListDataSetsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListDataSetsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListDataSetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDataSetsError {
    fn code(&self) -> Option<&str> {
        ListDataSetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDataSetsError {
    pub fn new(kind: ListDataSetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDataSetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDataSetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListDataSetsErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDataSetsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDataSetsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDataSetsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListDataSetsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListDataSetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDataSetsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListDataSetsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListDataSetsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListDataSetsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListDataSetsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListDataSetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDataSourcesError {
    pub kind: ListDataSourcesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDataSourcesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDataSourcesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDataSourcesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListDataSourcesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListDataSourcesErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListDataSourcesErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListDataSourcesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListDataSourcesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDataSourcesError {
    fn code(&self) -> Option<&str> {
        ListDataSourcesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDataSourcesError {
    pub fn new(kind: ListDataSourcesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDataSourcesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDataSourcesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDataSourcesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDataSourcesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDataSourcesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDataSourcesErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListDataSourcesErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListDataSourcesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDataSourcesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListDataSourcesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListDataSourcesErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListDataSourcesErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListDataSourcesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListDataSourcesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFolderMembersError {
    pub kind: ListFolderMembersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFolderMembersErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFolderMembersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFolderMembersErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListFolderMembersErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListFolderMembersErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListFolderMembersErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListFolderMembersErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListFolderMembersErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListFolderMembersErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            ListFolderMembersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFolderMembersError {
    fn code(&self) -> Option<&str> {
        ListFolderMembersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFolderMembersError {
    pub fn new(kind: ListFolderMembersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFolderMembersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFolderMembersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFolderMembersErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFolderMembersErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFolderMembersErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFolderMembersErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFolderMembersErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFolderMembersErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFolderMembersErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for ListFolderMembersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFolderMembersErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListFolderMembersErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListFolderMembersErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListFolderMembersErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListFolderMembersErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListFolderMembersErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListFolderMembersErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            ListFolderMembersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFoldersError {
    pub kind: ListFoldersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFoldersErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFoldersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFoldersErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListFoldersErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListFoldersErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListFoldersErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListFoldersErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListFoldersErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListFoldersErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            ListFoldersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFoldersError {
    fn code(&self) -> Option<&str> {
        ListFoldersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFoldersError {
    pub fn new(kind: ListFoldersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFoldersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFoldersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListFoldersErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFoldersErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFoldersErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFoldersErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFoldersErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListFoldersErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFoldersErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for ListFoldersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFoldersErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListFoldersErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListFoldersErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListFoldersErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListFoldersErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListFoldersErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListFoldersErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            ListFoldersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGroupMembershipsError {
    pub kind: ListGroupMembershipsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGroupMembershipsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGroupMembershipsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListGroupMembershipsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListGroupMembershipsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListGroupMembershipsErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListGroupMembershipsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListGroupMembershipsErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            ListGroupMembershipsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListGroupMembershipsErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            ListGroupMembershipsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListGroupMembershipsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListGroupMembershipsError {
    fn code(&self) -> Option<&str> {
        ListGroupMembershipsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListGroupMembershipsError {
    pub fn new(kind: ListGroupMembershipsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListGroupMembershipsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListGroupMembershipsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupMembershipsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupMembershipsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupMembershipsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupMembershipsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupMembershipsErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupMembershipsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupMembershipsErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupMembershipsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListGroupMembershipsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListGroupMembershipsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListGroupMembershipsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListGroupMembershipsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListGroupMembershipsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListGroupMembershipsErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            ListGroupMembershipsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListGroupMembershipsErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            ListGroupMembershipsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListGroupMembershipsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGroupsError {
    pub kind: ListGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGroupsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListGroupsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListGroupsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListGroupsErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListGroupsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListGroupsErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            ListGroupsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListGroupsErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            ListGroupsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListGroupsError {
    fn code(&self) -> Option<&str> {
        ListGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListGroupsError {
    pub fn new(kind: ListGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListGroupsErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, ListGroupsErrorKind::InternalFailureException(_))
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupsErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupsErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListGroupsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListGroupsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListGroupsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListGroupsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListGroupsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListGroupsErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            ListGroupsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListGroupsErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            ListGroupsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListIAMPolicyAssignmentsError {
    pub kind: ListIAMPolicyAssignmentsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListIAMPolicyAssignmentsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListIAMPolicyAssignmentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListIAMPolicyAssignmentsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListIAMPolicyAssignmentsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListIAMPolicyAssignmentsErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListIAMPolicyAssignmentsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListIAMPolicyAssignmentsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListIAMPolicyAssignmentsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListIAMPolicyAssignmentsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListIAMPolicyAssignmentsError {
    fn code(&self) -> Option<&str> {
        ListIAMPolicyAssignmentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListIAMPolicyAssignmentsError {
    pub fn new(kind: ListIAMPolicyAssignmentsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListIAMPolicyAssignmentsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListIAMPolicyAssignmentsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIAMPolicyAssignmentsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIAMPolicyAssignmentsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIAMPolicyAssignmentsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIAMPolicyAssignmentsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIAMPolicyAssignmentsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIAMPolicyAssignmentsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListIAMPolicyAssignmentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListIAMPolicyAssignmentsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListIAMPolicyAssignmentsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListIAMPolicyAssignmentsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListIAMPolicyAssignmentsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            ListIAMPolicyAssignmentsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListIAMPolicyAssignmentsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListIAMPolicyAssignmentsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListIAMPolicyAssignmentsForUserError {
    pub kind: ListIAMPolicyAssignmentsForUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListIAMPolicyAssignmentsForUserErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConcurrentUpdatingException(crate::error::ConcurrentUpdatingException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListIAMPolicyAssignmentsForUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListIAMPolicyAssignmentsForUserErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ListIAMPolicyAssignmentsForUserErrorKind::ConcurrentUpdatingException(_inner) => {
                _inner.fmt(f)
            }
            ListIAMPolicyAssignmentsForUserErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListIAMPolicyAssignmentsForUserErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListIAMPolicyAssignmentsForUserErrorKind::ResourceExistsException(_inner) => {
                _inner.fmt(f)
            }
            ListIAMPolicyAssignmentsForUserErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListIAMPolicyAssignmentsForUserErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListIAMPolicyAssignmentsForUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListIAMPolicyAssignmentsForUserError {
    fn code(&self) -> Option<&str> {
        ListIAMPolicyAssignmentsForUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListIAMPolicyAssignmentsForUserError {
    pub fn new(kind: ListIAMPolicyAssignmentsForUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListIAMPolicyAssignmentsForUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListIAMPolicyAssignmentsForUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIAMPolicyAssignmentsForUserErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_concurrent_updating_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIAMPolicyAssignmentsForUserErrorKind::ConcurrentUpdatingException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIAMPolicyAssignmentsForUserErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIAMPolicyAssignmentsForUserErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIAMPolicyAssignmentsForUserErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIAMPolicyAssignmentsForUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIAMPolicyAssignmentsForUserErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListIAMPolicyAssignmentsForUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListIAMPolicyAssignmentsForUserErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListIAMPolicyAssignmentsForUserErrorKind::ConcurrentUpdatingException(_inner) => {
                Some(_inner)
            }
            ListIAMPolicyAssignmentsForUserErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            ListIAMPolicyAssignmentsForUserErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            ListIAMPolicyAssignmentsForUserErrorKind::ResourceExistsException(_inner) => {
                Some(_inner)
            }
            ListIAMPolicyAssignmentsForUserErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListIAMPolicyAssignmentsForUserErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListIAMPolicyAssignmentsForUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListIngestionsError {
    pub kind: ListIngestionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListIngestionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListIngestionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListIngestionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListIngestionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListIngestionsErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListIngestionsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListIngestionsErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            ListIngestionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListIngestionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListIngestionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListIngestionsError {
    fn code(&self) -> Option<&str> {
        ListIngestionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListIngestionsError {
    pub fn new(kind: ListIngestionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListIngestionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListIngestionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIngestionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIngestionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIngestionsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIngestionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIngestionsErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIngestionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListIngestionsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListIngestionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListIngestionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListIngestionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListIngestionsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListIngestionsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListIngestionsErrorKind::ResourceExistsException(_inner) => Some(_inner),
            ListIngestionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListIngestionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListIngestionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListNamespacesError {
    pub kind: ListNamespacesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListNamespacesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListNamespacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListNamespacesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListNamespacesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListNamespacesErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListNamespacesErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListNamespacesErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            ListNamespacesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListNamespacesErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            ListNamespacesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListNamespacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListNamespacesError {
    fn code(&self) -> Option<&str> {
        ListNamespacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListNamespacesError {
    pub fn new(kind: ListNamespacesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListNamespacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListNamespacesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListNamespacesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListNamespacesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListNamespacesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListNamespacesErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListNamespacesErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListNamespacesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListNamespacesErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListNamespacesErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListNamespacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListNamespacesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListNamespacesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListNamespacesErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListNamespacesErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListNamespacesErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            ListNamespacesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListNamespacesErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            ListNamespacesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListNamespacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTemplateAliasesError {
    pub kind: ListTemplateAliasesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTemplateAliasesErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTemplateAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTemplateAliasesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListTemplateAliasesErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListTemplateAliasesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTemplateAliasesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTemplateAliasesErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            ListTemplateAliasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTemplateAliasesError {
    fn code(&self) -> Option<&str> {
        ListTemplateAliasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTemplateAliasesError {
    pub fn new(kind: ListTemplateAliasesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTemplateAliasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTemplateAliasesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplateAliasesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplateAliasesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplateAliasesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplateAliasesErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplateAliasesErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for ListTemplateAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTemplateAliasesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListTemplateAliasesErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListTemplateAliasesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTemplateAliasesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTemplateAliasesErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            ListTemplateAliasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTemplatesError {
    pub kind: ListTemplatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTemplatesErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTemplatesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListTemplatesErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListTemplatesErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListTemplatesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTemplatesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTemplatesErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            ListTemplatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTemplatesError {
    fn code(&self) -> Option<&str> {
        ListTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTemplatesError {
    pub fn new(kind: ListTemplatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTemplatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTemplatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplatesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplatesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplatesErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplatesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListTemplatesErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplatesErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for ListTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTemplatesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListTemplatesErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListTemplatesErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListTemplatesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTemplatesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTemplatesErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            ListTemplatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTemplateVersionsError {
    pub kind: ListTemplateVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTemplateVersionsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTemplateVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTemplateVersionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListTemplateVersionsErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListTemplateVersionsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListTemplateVersionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTemplateVersionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTemplateVersionsErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            ListTemplateVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTemplateVersionsError {
    fn code(&self) -> Option<&str> {
        ListTemplateVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTemplateVersionsError {
    pub fn new(kind: ListTemplateVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTemplateVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTemplateVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplateVersionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplateVersionsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplateVersionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplateVersionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplateVersionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplateVersionsErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for ListTemplateVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTemplateVersionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListTemplateVersionsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListTemplateVersionsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListTemplateVersionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTemplateVersionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTemplateVersionsErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            ListTemplateVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThemeAliasesError {
    pub kind: ListThemeAliasesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThemeAliasesErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThemeAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThemeAliasesErrorKind::ConflictException(_inner) => _inner.fmt(f),
            ListThemeAliasesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListThemeAliasesErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListThemeAliasesErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListThemeAliasesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListThemeAliasesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThemeAliasesErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            ListThemeAliasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListThemeAliasesError {
    fn code(&self) -> Option<&str> {
        ListThemeAliasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThemeAliasesError {
    pub fn new(kind: ListThemeAliasesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThemeAliasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThemeAliasesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, ListThemeAliasesErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThemeAliasesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThemeAliasesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThemeAliasesErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThemeAliasesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThemeAliasesErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThemeAliasesErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for ListThemeAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThemeAliasesErrorKind::ConflictException(_inner) => Some(_inner),
            ListThemeAliasesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListThemeAliasesErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListThemeAliasesErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListThemeAliasesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListThemeAliasesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThemeAliasesErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            ListThemeAliasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThemesError {
    pub kind: ListThemesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThemesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThemesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThemesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListThemesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListThemesErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListThemesErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListThemesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListThemesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThemesErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            ListThemesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListThemesError {
    fn code(&self) -> Option<&str> {
        ListThemesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThemesError {
    pub fn new(kind: ListThemesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThemesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThemesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListThemesErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, ListThemesErrorKind::InternalFailureException(_))
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThemesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThemesErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThemesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListThemesErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThemesErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for ListThemesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThemesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListThemesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListThemesErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListThemesErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListThemesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListThemesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThemesErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            ListThemesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListThemeVersionsError {
    pub kind: ListThemeVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListThemeVersionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListThemeVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListThemeVersionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListThemeVersionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListThemeVersionsErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListThemeVersionsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListThemeVersionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListThemeVersionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListThemeVersionsErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            ListThemeVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListThemeVersionsError {
    fn code(&self) -> Option<&str> {
        ListThemeVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListThemeVersionsError {
    pub fn new(kind: ListThemeVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListThemeVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListThemeVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThemeVersionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThemeVersionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThemeVersionsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThemeVersionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThemeVersionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThemeVersionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListThemeVersionsErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for ListThemeVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListThemeVersionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListThemeVersionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListThemeVersionsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListThemeVersionsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListThemeVersionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListThemeVersionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListThemeVersionsErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            ListThemeVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUserGroupsError {
    pub kind: ListUserGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUserGroupsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUserGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUserGroupsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListUserGroupsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListUserGroupsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListUserGroupsErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            ListUserGroupsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListUserGroupsErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            ListUserGroupsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListUserGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUserGroupsError {
    fn code(&self) -> Option<&str> {
        ListUserGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUserGroupsError {
    pub fn new(kind: ListUserGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUserGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUserGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserGroupsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserGroupsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserGroupsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserGroupsErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserGroupsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserGroupsErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListUserGroupsErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListUserGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUserGroupsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListUserGroupsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListUserGroupsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListUserGroupsErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            ListUserGroupsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListUserGroupsErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            ListUserGroupsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListUserGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUsersError {
    pub kind: ListUsersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUsersErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUsersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUsersErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUsersError {
    fn code(&self) -> Option<&str> {
        ListUsersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUsersError {
    pub fn new(kind: ListUsersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUsersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUsersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::InternalFailureException(_))
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::InvalidNextTokenException(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUsersErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUsersErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUsersErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for ListUsersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUsersErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListUsersErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListUsersErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListUsersErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListUsersErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            ListUsersErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListUsersErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            ListUsersErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListUsersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterUserError {
    pub kind: RegisterUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterUserErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterUserErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            RegisterUserErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            RegisterUserErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            RegisterUserErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            RegisterUserErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            RegisterUserErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            RegisterUserErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RegisterUserErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            RegisterUserErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RegisterUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterUserError {
    fn code(&self) -> Option<&str> {
        RegisterUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterUserError {
    pub fn new(kind: RegisterUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, RegisterUserErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterUserErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterUserErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, RegisterUserErrorKind::LimitExceededException(_))
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterUserErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterUserErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterUserErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, RegisterUserErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for RegisterUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterUserErrorKind::AccessDeniedException(_inner) => Some(_inner),
            RegisterUserErrorKind::InternalFailureException(_inner) => Some(_inner),
            RegisterUserErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            RegisterUserErrorKind::LimitExceededException(_inner) => Some(_inner),
            RegisterUserErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            RegisterUserErrorKind::ResourceExistsException(_inner) => Some(_inner),
            RegisterUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RegisterUserErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            RegisterUserErrorKind::ThrottlingException(_inner) => Some(_inner),
            RegisterUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreAnalysisError {
    pub kind: RestoreAnalysisErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreAnalysisErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreAnalysisError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreAnalysisErrorKind::ConflictException(_inner) => _inner.fmt(f),
            RestoreAnalysisErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            RestoreAnalysisErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            RestoreAnalysisErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RestoreAnalysisErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            RestoreAnalysisErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            RestoreAnalysisErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestoreAnalysisError {
    fn code(&self) -> Option<&str> {
        RestoreAnalysisError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreAnalysisError {
    pub fn new(kind: RestoreAnalysisErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreAnalysisErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreAnalysisErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, RestoreAnalysisErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestoreAnalysisErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestoreAnalysisErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestoreAnalysisErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, RestoreAnalysisErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestoreAnalysisErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for RestoreAnalysisError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreAnalysisErrorKind::ConflictException(_inner) => Some(_inner),
            RestoreAnalysisErrorKind::InternalFailureException(_inner) => Some(_inner),
            RestoreAnalysisErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            RestoreAnalysisErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RestoreAnalysisErrorKind::ThrottlingException(_inner) => Some(_inner),
            RestoreAnalysisErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            RestoreAnalysisErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SearchAnalysesError {
    pub kind: SearchAnalysesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SearchAnalysesErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SearchAnalysesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SearchAnalysesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            SearchAnalysesErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            SearchAnalysesErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            SearchAnalysesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SearchAnalysesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            SearchAnalysesErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            SearchAnalysesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SearchAnalysesError {
    fn code(&self) -> Option<&str> {
        SearchAnalysesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SearchAnalysesError {
    pub fn new(kind: SearchAnalysesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SearchAnalysesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SearchAnalysesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchAnalysesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchAnalysesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchAnalysesErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchAnalysesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, SearchAnalysesErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchAnalysesErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for SearchAnalysesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SearchAnalysesErrorKind::InternalFailureException(_inner) => Some(_inner),
            SearchAnalysesErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            SearchAnalysesErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            SearchAnalysesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SearchAnalysesErrorKind::ThrottlingException(_inner) => Some(_inner),
            SearchAnalysesErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            SearchAnalysesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SearchDashboardsError {
    pub kind: SearchDashboardsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SearchDashboardsErrorKind {
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SearchDashboardsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SearchDashboardsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            SearchDashboardsErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            SearchDashboardsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            SearchDashboardsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SearchDashboardsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            SearchDashboardsErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            SearchDashboardsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SearchDashboardsError {
    fn code(&self) -> Option<&str> {
        SearchDashboardsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SearchDashboardsError {
    pub fn new(kind: SearchDashboardsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SearchDashboardsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SearchDashboardsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchDashboardsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchDashboardsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchDashboardsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchDashboardsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchDashboardsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchDashboardsErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for SearchDashboardsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SearchDashboardsErrorKind::InternalFailureException(_inner) => Some(_inner),
            SearchDashboardsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            SearchDashboardsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            SearchDashboardsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SearchDashboardsErrorKind::ThrottlingException(_inner) => Some(_inner),
            SearchDashboardsErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            SearchDashboardsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SearchFoldersError {
    pub kind: SearchFoldersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SearchFoldersErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SearchFoldersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SearchFoldersErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            SearchFoldersErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            SearchFoldersErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            SearchFoldersErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            SearchFoldersErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SearchFoldersErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            SearchFoldersErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            SearchFoldersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SearchFoldersError {
    fn code(&self) -> Option<&str> {
        SearchFoldersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SearchFoldersError {
    pub fn new(kind: SearchFoldersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SearchFoldersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SearchFoldersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, SearchFoldersErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFoldersErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFoldersErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFoldersErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFoldersErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, SearchFoldersErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchFoldersErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for SearchFoldersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SearchFoldersErrorKind::AccessDeniedException(_inner) => Some(_inner),
            SearchFoldersErrorKind::InternalFailureException(_inner) => Some(_inner),
            SearchFoldersErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            SearchFoldersErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            SearchFoldersErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SearchFoldersErrorKind::ThrottlingException(_inner) => Some(_inner),
            SearchFoldersErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            SearchFoldersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::LimitExceededException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            TagResourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            TagResourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UntagResourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAccountCustomizationError {
    pub kind: UpdateAccountCustomizationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAccountCustomizationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAccountCustomizationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAccountCustomizationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateAccountCustomizationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateAccountCustomizationErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAccountCustomizationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateAccountCustomizationErrorKind::ResourceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAccountCustomizationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateAccountCustomizationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAccountCustomizationError {
    fn code(&self) -> Option<&str> {
        UpdateAccountCustomizationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAccountCustomizationError {
    pub fn new(kind: UpdateAccountCustomizationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAccountCustomizationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAccountCustomizationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountCustomizationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountCustomizationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountCustomizationErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountCustomizationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountCustomizationErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountCustomizationErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateAccountCustomizationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAccountCustomizationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateAccountCustomizationErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateAccountCustomizationErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            UpdateAccountCustomizationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateAccountCustomizationErrorKind::ResourceUnavailableException(_inner) => {
                Some(_inner)
            }
            UpdateAccountCustomizationErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateAccountCustomizationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAccountSettingsError {
    pub kind: UpdateAccountSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAccountSettingsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAccountSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAccountSettingsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateAccountSettingsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateAccountSettingsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UpdateAccountSettingsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateAccountSettingsErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            UpdateAccountSettingsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateAccountSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAccountSettingsError {
    fn code(&self) -> Option<&str> {
        UpdateAccountSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAccountSettingsError {
    pub fn new(kind: UpdateAccountSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAccountSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAccountSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountSettingsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountSettingsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountSettingsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountSettingsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountSettingsErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountSettingsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateAccountSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAccountSettingsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateAccountSettingsErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateAccountSettingsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateAccountSettingsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateAccountSettingsErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            UpdateAccountSettingsErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateAccountSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAnalysisError {
    pub kind: UpdateAnalysisErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAnalysisErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAnalysisError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAnalysisErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateAnalysisErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateAnalysisErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UpdateAnalysisErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            UpdateAnalysisErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateAnalysisErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateAnalysisErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            UpdateAnalysisErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAnalysisError {
    fn code(&self) -> Option<&str> {
        UpdateAnalysisError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAnalysisError {
    pub fn new(kind: UpdateAnalysisErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAnalysisErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAnalysisErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateAnalysisErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAnalysisErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAnalysisErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAnalysisErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAnalysisErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateAnalysisErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAnalysisErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for UpdateAnalysisError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAnalysisErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateAnalysisErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateAnalysisErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateAnalysisErrorKind::ResourceExistsException(_inner) => Some(_inner),
            UpdateAnalysisErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateAnalysisErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateAnalysisErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            UpdateAnalysisErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAnalysisPermissionsError {
    pub kind: UpdateAnalysisPermissionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAnalysisPermissionsErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAnalysisPermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAnalysisPermissionsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateAnalysisPermissionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateAnalysisPermissionsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAnalysisPermissionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateAnalysisPermissionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateAnalysisPermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAnalysisPermissionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAnalysisPermissionsError {
    fn code(&self) -> Option<&str> {
        UpdateAnalysisPermissionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAnalysisPermissionsError {
    pub fn new(kind: UpdateAnalysisPermissionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAnalysisPermissionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAnalysisPermissionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAnalysisPermissionsErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAnalysisPermissionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAnalysisPermissionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAnalysisPermissionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAnalysisPermissionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAnalysisPermissionsErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for UpdateAnalysisPermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAnalysisPermissionsErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateAnalysisPermissionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateAnalysisPermissionsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            UpdateAnalysisPermissionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateAnalysisPermissionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateAnalysisPermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                Some(_inner)
            }
            UpdateAnalysisPermissionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDashboardError {
    pub kind: UpdateDashboardErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDashboardErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDashboardError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDashboardErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateDashboardErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateDashboardErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UpdateDashboardErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateDashboardErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateDashboardErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateDashboardErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            UpdateDashboardErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDashboardError {
    fn code(&self) -> Option<&str> {
        UpdateDashboardError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDashboardError {
    pub fn new(kind: UpdateDashboardErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDashboardErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDashboardErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateDashboardErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDashboardErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDashboardErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDashboardErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDashboardErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateDashboardErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDashboardErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for UpdateDashboardError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDashboardErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateDashboardErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateDashboardErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateDashboardErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateDashboardErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateDashboardErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateDashboardErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            UpdateDashboardErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDashboardPermissionsError {
    pub kind: UpdateDashboardPermissionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDashboardPermissionsErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDashboardPermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDashboardPermissionsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateDashboardPermissionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateDashboardPermissionsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDashboardPermissionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateDashboardPermissionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateDashboardPermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDashboardPermissionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDashboardPermissionsError {
    fn code(&self) -> Option<&str> {
        UpdateDashboardPermissionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDashboardPermissionsError {
    pub fn new(kind: UpdateDashboardPermissionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDashboardPermissionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDashboardPermissionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDashboardPermissionsErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDashboardPermissionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDashboardPermissionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDashboardPermissionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDashboardPermissionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDashboardPermissionsErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for UpdateDashboardPermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDashboardPermissionsErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateDashboardPermissionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateDashboardPermissionsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            UpdateDashboardPermissionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateDashboardPermissionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateDashboardPermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                Some(_inner)
            }
            UpdateDashboardPermissionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDashboardPublishedVersionError {
    pub kind: UpdateDashboardPublishedVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDashboardPublishedVersionErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDashboardPublishedVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDashboardPublishedVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateDashboardPublishedVersionErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDashboardPublishedVersionErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDashboardPublishedVersionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDashboardPublishedVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateDashboardPublishedVersionErrorKind::UnsupportedUserEditionException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDashboardPublishedVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDashboardPublishedVersionError {
    fn code(&self) -> Option<&str> {
        UpdateDashboardPublishedVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDashboardPublishedVersionError {
    pub fn new(kind: UpdateDashboardPublishedVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDashboardPublishedVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDashboardPublishedVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDashboardPublishedVersionErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDashboardPublishedVersionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDashboardPublishedVersionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDashboardPublishedVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDashboardPublishedVersionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDashboardPublishedVersionErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for UpdateDashboardPublishedVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDashboardPublishedVersionErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateDashboardPublishedVersionErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            UpdateDashboardPublishedVersionErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            UpdateDashboardPublishedVersionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateDashboardPublishedVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateDashboardPublishedVersionErrorKind::UnsupportedUserEditionException(_inner) => {
                Some(_inner)
            }
            UpdateDashboardPublishedVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDataSetError {
    pub kind: UpdateDataSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDataSetErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDataSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDataSetErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateDataSetErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateDataSetErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateDataSetErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UpdateDataSetErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateDataSetErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateDataSetErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateDataSetErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            UpdateDataSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDataSetError {
    fn code(&self) -> Option<&str> {
        UpdateDataSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDataSetError {
    pub fn new(kind: UpdateDataSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDataSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDataSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateDataSetErrorKind::AccessDeniedException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateDataSetErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSetErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSetErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSetErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSetErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateDataSetErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSetErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for UpdateDataSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDataSetErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateDataSetErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateDataSetErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateDataSetErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateDataSetErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateDataSetErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateDataSetErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateDataSetErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            UpdateDataSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDataSetPermissionsError {
    pub kind: UpdateDataSetPermissionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDataSetPermissionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDataSetPermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDataSetPermissionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateDataSetPermissionsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateDataSetPermissionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateDataSetPermissionsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDataSetPermissionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateDataSetPermissionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateDataSetPermissionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDataSetPermissionsError {
    fn code(&self) -> Option<&str> {
        UpdateDataSetPermissionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDataSetPermissionsError {
    pub fn new(kind: UpdateDataSetPermissionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDataSetPermissionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDataSetPermissionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSetPermissionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSetPermissionsErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSetPermissionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSetPermissionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSetPermissionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSetPermissionsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateDataSetPermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDataSetPermissionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateDataSetPermissionsErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateDataSetPermissionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateDataSetPermissionsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            UpdateDataSetPermissionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateDataSetPermissionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateDataSetPermissionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDataSourceError {
    pub kind: UpdateDataSourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDataSourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDataSourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDataSourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateDataSourceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateDataSourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateDataSourceErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UpdateDataSourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateDataSourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateDataSourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDataSourceError {
    fn code(&self) -> Option<&str> {
        UpdateDataSourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDataSourceError {
    pub fn new(kind: UpdateDataSourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDataSourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDataSourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateDataSourceErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourceErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateDataSourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDataSourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateDataSourceErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateDataSourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateDataSourceErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateDataSourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateDataSourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateDataSourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDataSourcePermissionsError {
    pub kind: UpdateDataSourcePermissionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDataSourcePermissionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDataSourcePermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDataSourcePermissionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateDataSourcePermissionsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateDataSourcePermissionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateDataSourcePermissionsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDataSourcePermissionsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDataSourcePermissionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateDataSourcePermissionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDataSourcePermissionsError {
    fn code(&self) -> Option<&str> {
        UpdateDataSourcePermissionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDataSourcePermissionsError {
    pub fn new(kind: UpdateDataSourcePermissionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDataSourcePermissionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDataSourcePermissionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourcePermissionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourcePermissionsErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourcePermissionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourcePermissionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourcePermissionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourcePermissionsErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateDataSourcePermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDataSourcePermissionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateDataSourcePermissionsErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateDataSourcePermissionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateDataSourcePermissionsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            UpdateDataSourcePermissionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateDataSourcePermissionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateDataSourcePermissionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFolderError {
    pub kind: UpdateFolderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFolderErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFolderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFolderErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateFolderErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateFolderErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateFolderErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UpdateFolderErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            UpdateFolderErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateFolderErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateFolderErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            UpdateFolderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateFolderError {
    fn code(&self) -> Option<&str> {
        UpdateFolderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFolderError {
    pub fn new(kind: UpdateFolderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFolderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFolderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateFolderErrorKind::AccessDeniedException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateFolderErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFolderErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFolderErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFolderErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFolderErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateFolderErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFolderErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for UpdateFolderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFolderErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateFolderErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateFolderErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateFolderErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateFolderErrorKind::ResourceExistsException(_inner) => Some(_inner),
            UpdateFolderErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateFolderErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateFolderErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            UpdateFolderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFolderPermissionsError {
    pub kind: UpdateFolderPermissionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFolderPermissionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFolderPermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFolderPermissionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateFolderPermissionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateFolderPermissionsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFolderPermissionsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateFolderPermissionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateFolderPermissionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateFolderPermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFolderPermissionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateFolderPermissionsError {
    fn code(&self) -> Option<&str> {
        UpdateFolderPermissionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFolderPermissionsError {
    pub fn new(kind: UpdateFolderPermissionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFolderPermissionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFolderPermissionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFolderPermissionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFolderPermissionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFolderPermissionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFolderPermissionsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFolderPermissionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFolderPermissionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFolderPermissionsErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for UpdateFolderPermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFolderPermissionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateFolderPermissionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateFolderPermissionsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            UpdateFolderPermissionsErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateFolderPermissionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateFolderPermissionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateFolderPermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                Some(_inner)
            }
            UpdateFolderPermissionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGroupError {
    pub kind: UpdateGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGroupErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateGroupErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateGroupError {
    fn code(&self) -> Option<&str> {
        UpdateGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateGroupError {
    pub fn new(kind: UpdateGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateGroupErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGroupErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGroupErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGroupErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGroupErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateGroupErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for UpdateGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateGroupErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateGroupErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateGroupErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateGroupErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            UpdateGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateGroupErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            UpdateGroupErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateIAMPolicyAssignmentError {
    pub kind: UpdateIAMPolicyAssignmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateIAMPolicyAssignmentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConcurrentUpdatingException(crate::error::ConcurrentUpdatingException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateIAMPolicyAssignmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateIAMPolicyAssignmentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateIAMPolicyAssignmentErrorKind::ConcurrentUpdatingException(_inner) => {
                _inner.fmt(f)
            }
            UpdateIAMPolicyAssignmentErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateIAMPolicyAssignmentErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            UpdateIAMPolicyAssignmentErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            UpdateIAMPolicyAssignmentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateIAMPolicyAssignmentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateIAMPolicyAssignmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateIAMPolicyAssignmentError {
    fn code(&self) -> Option<&str> {
        UpdateIAMPolicyAssignmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateIAMPolicyAssignmentError {
    pub fn new(kind: UpdateIAMPolicyAssignmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateIAMPolicyAssignmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateIAMPolicyAssignmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIAMPolicyAssignmentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_concurrent_updating_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIAMPolicyAssignmentErrorKind::ConcurrentUpdatingException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIAMPolicyAssignmentErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIAMPolicyAssignmentErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIAMPolicyAssignmentErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIAMPolicyAssignmentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIAMPolicyAssignmentErrorKind::ThrottlingException(_)
        )
    }
}
impl std::error::Error for UpdateIAMPolicyAssignmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateIAMPolicyAssignmentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateIAMPolicyAssignmentErrorKind::ConcurrentUpdatingException(_inner) => Some(_inner),
            UpdateIAMPolicyAssignmentErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateIAMPolicyAssignmentErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            UpdateIAMPolicyAssignmentErrorKind::ResourceExistsException(_inner) => Some(_inner),
            UpdateIAMPolicyAssignmentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateIAMPolicyAssignmentErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateIAMPolicyAssignmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTemplateError {
    pub kind: UpdateTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTemplateErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTemplateErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateTemplateErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateTemplateErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UpdateTemplateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateTemplateErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            UpdateTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateTemplateErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            UpdateTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateTemplateError {
    fn code(&self) -> Option<&str> {
        UpdateTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTemplateError {
    pub fn new(kind: UpdateTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateTemplateErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplateErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplateErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplateErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateTemplateErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplateErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for UpdateTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTemplateErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateTemplateErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateTemplateErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateTemplateErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateTemplateErrorKind::ResourceExistsException(_inner) => Some(_inner),
            UpdateTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateTemplateErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            UpdateTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTemplateAliasError {
    pub kind: UpdateTemplateAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTemplateAliasErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateTemplateAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTemplateAliasErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateTemplateAliasErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateTemplateAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateTemplateAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateTemplateAliasErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            UpdateTemplateAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateTemplateAliasError {
    fn code(&self) -> Option<&str> {
        UpdateTemplateAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTemplateAliasError {
    pub fn new(kind: UpdateTemplateAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateTemplateAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateTemplateAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplateAliasErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplateAliasErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplateAliasErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplateAliasErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplateAliasErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for UpdateTemplateAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTemplateAliasErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateTemplateAliasErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateTemplateAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateTemplateAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateTemplateAliasErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            UpdateTemplateAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTemplatePermissionsError {
    pub kind: UpdateTemplatePermissionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTemplatePermissionsErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateTemplatePermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTemplatePermissionsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateTemplatePermissionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateTemplatePermissionsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            UpdateTemplatePermissionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateTemplatePermissionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateTemplatePermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                _inner.fmt(f)
            }
            UpdateTemplatePermissionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateTemplatePermissionsError {
    fn code(&self) -> Option<&str> {
        UpdateTemplatePermissionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTemplatePermissionsError {
    pub fn new(kind: UpdateTemplatePermissionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateTemplatePermissionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateTemplatePermissionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplatePermissionsErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplatePermissionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplatePermissionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplatePermissionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplatePermissionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplatePermissionsErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for UpdateTemplatePermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTemplatePermissionsErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateTemplatePermissionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateTemplatePermissionsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            UpdateTemplatePermissionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateTemplatePermissionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateTemplatePermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                Some(_inner)
            }
            UpdateTemplatePermissionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateThemeError {
    pub kind: UpdateThemeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateThemeErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateThemeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateThemeErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateThemeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateThemeErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UpdateThemeErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateThemeErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            UpdateThemeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateThemeErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateThemeErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            UpdateThemeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateThemeError {
    fn code(&self) -> Option<&str> {
        UpdateThemeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateThemeError {
    pub fn new(kind: UpdateThemeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateThemeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateThemeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateThemeErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThemeErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThemeErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, UpdateThemeErrorKind::LimitExceededException(_))
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(&self.kind, UpdateThemeErrorKind::ResourceExistsException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThemeErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateThemeErrorKind::ThrottlingException(_))
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThemeErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for UpdateThemeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateThemeErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateThemeErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateThemeErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateThemeErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateThemeErrorKind::ResourceExistsException(_inner) => Some(_inner),
            UpdateThemeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateThemeErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateThemeErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            UpdateThemeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateThemeAliasError {
    pub kind: UpdateThemeAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateThemeAliasErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceExistsException(crate::error::ResourceExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateThemeAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateThemeAliasErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateThemeAliasErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateThemeAliasErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UpdateThemeAliasErrorKind::ResourceExistsException(_inner) => _inner.fmt(f),
            UpdateThemeAliasErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateThemeAliasErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateThemeAliasErrorKind::UnsupportedUserEditionException(_inner) => _inner.fmt(f),
            UpdateThemeAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateThemeAliasError {
    fn code(&self) -> Option<&str> {
        UpdateThemeAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateThemeAliasError {
    pub fn new(kind: UpdateThemeAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateThemeAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateThemeAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateThemeAliasErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThemeAliasErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThemeAliasErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThemeAliasErrorKind::ResourceExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThemeAliasErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThemeAliasErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThemeAliasErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for UpdateThemeAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateThemeAliasErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateThemeAliasErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateThemeAliasErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateThemeAliasErrorKind::ResourceExistsException(_inner) => Some(_inner),
            UpdateThemeAliasErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateThemeAliasErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateThemeAliasErrorKind::UnsupportedUserEditionException(_inner) => Some(_inner),
            UpdateThemeAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateThemePermissionsError {
    pub kind: UpdateThemePermissionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateThemePermissionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    UnsupportedUserEditionException(crate::error::UnsupportedUserEditionException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateThemePermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateThemePermissionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateThemePermissionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateThemePermissionsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            UpdateThemePermissionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateThemePermissionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateThemePermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                _inner.fmt(f)
            }
            UpdateThemePermissionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateThemePermissionsError {
    fn code(&self) -> Option<&str> {
        UpdateThemePermissionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateThemePermissionsError {
    pub fn new(kind: UpdateThemePermissionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateThemePermissionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateThemePermissionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThemePermissionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThemePermissionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThemePermissionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThemePermissionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThemePermissionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_unsupported_user_edition_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateThemePermissionsErrorKind::UnsupportedUserEditionException(_)
        )
    }
}
impl std::error::Error for UpdateThemePermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateThemePermissionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateThemePermissionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateThemePermissionsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateThemePermissionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateThemePermissionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateThemePermissionsErrorKind::UnsupportedUserEditionException(_inner) => {
                Some(_inner)
            }
            UpdateThemePermissionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUserError {
    pub kind: UpdateUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalFailureException(crate::error::InternalFailureException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ResourceUnavailableException(crate::error::ResourceUnavailableException),
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUserErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::ResourceUnavailableException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUserError {
    fn code(&self) -> Option<&str> {
        UpdateUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserError {
    pub fn new(kind: UpdateUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateUserErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, UpdateUserErrorKind::InternalFailureException(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_resource_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserErrorKind::ResourceUnavailableException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateUserErrorKind::ThrottlingException(_))
    }
}
impl std::error::Error for UpdateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUserErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateUserErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateUserErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateUserErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            UpdateUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateUserErrorKind::ResourceUnavailableException(_inner) => Some(_inner),
            UpdateUserErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>Access is throttled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ThrottlingException {
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request ID for this request.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ThrottlingException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl ThrottlingException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
/// See [`ThrottlingException`](crate::error::ThrottlingException)
pub mod throttling_exception {
    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request ID for this request.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException)
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException)
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// <p>This resource is currently unavailable.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceUnavailableException {
    pub message: std::option::Option<std::string::String>,
    /// <p>The resource type for this request.</p>
    pub resource_type: std::option::Option<crate::model::ExceptionResourceType>,
    /// <p>The Amazon Web Services request ID for this request.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceUnavailableException");
        formatter.field("message", &self.message);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl ResourceUnavailableException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceUnavailableException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceUnavailableException {}
/// See [`ResourceUnavailableException`](crate::error::ResourceUnavailableException)
pub mod resource_unavailable_exception {
    /// A builder for [`ResourceUnavailableException`](crate::error::ResourceUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::ExceptionResourceType>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The resource type for this request.</p>
        pub fn resource_type(mut self, input: crate::model::ExceptionResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ExceptionResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The Amazon Web Services request ID for this request.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceUnavailableException`](crate::error::ResourceUnavailableException)
        pub fn build(self) -> crate::error::ResourceUnavailableException {
            crate::error::ResourceUnavailableException {
                message: self.message,
                resource_type: self.resource_type,
                request_id: self.request_id,
            }
        }
    }
}
impl ResourceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ResourceUnavailableException`](crate::error::ResourceUnavailableException)
    pub fn builder() -> crate::error::resource_unavailable_exception::Builder {
        crate::error::resource_unavailable_exception::Builder::default()
    }
}

/// <p>One or more resources can't be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    pub message: std::option::Option<std::string::String>,
    /// <p>The resource type for this request.</p>
    pub resource_type: std::option::Option<crate::model::ExceptionResourceType>,
    /// <p>The Amazon Web Services request ID for this request.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::ExceptionResourceType>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The resource type for this request.</p>
        pub fn resource_type(mut self, input: crate::model::ExceptionResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ExceptionResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The Amazon Web Services request ID for this request.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
                resource_type: self.resource_type,
                request_id: self.request_id,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>One or more preconditions aren't met.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PreconditionNotMetException {
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request ID for this request.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PreconditionNotMetException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PreconditionNotMetException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl PreconditionNotMetException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PreconditionNotMetException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PreconditionNotMetException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for PreconditionNotMetException {}
/// See [`PreconditionNotMetException`](crate::error::PreconditionNotMetException)
pub mod precondition_not_met_exception {
    /// A builder for [`PreconditionNotMetException`](crate::error::PreconditionNotMetException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request ID for this request.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PreconditionNotMetException`](crate::error::PreconditionNotMetException)
        pub fn build(self) -> crate::error::PreconditionNotMetException {
            crate::error::PreconditionNotMetException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl PreconditionNotMetException {
    /// Creates a new builder-style object to manufacture [`PreconditionNotMetException`](crate::error::PreconditionNotMetException)
    pub fn builder() -> crate::error::precondition_not_met_exception::Builder {
        crate::error::precondition_not_met_exception::Builder::default()
    }
}

/// <p>One or more parameters has a value that isn't valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterValueException {
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request ID for this request.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterValueException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl InvalidParameterValueException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterValueException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterValueException {}
/// See [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
pub mod invalid_parameter_value_exception {
    /// A builder for [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request ID for this request.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
        pub fn build(self) -> crate::error::InvalidParameterValueException {
            crate::error::InvalidParameterValueException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl InvalidParameterValueException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
    pub fn builder() -> crate::error::invalid_parameter_value_exception::Builder {
        crate::error::invalid_parameter_value_exception::Builder::default()
    }
}

/// <p>An internal failure occurred.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalFailureException {
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request ID for this request.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalFailureException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl InternalFailureException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalFailureException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalFailureException {}
/// See [`InternalFailureException`](crate::error::InternalFailureException)
pub mod internal_failure_exception {
    /// A builder for [`InternalFailureException`](crate::error::InternalFailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request ID for this request.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalFailureException`](crate::error::InternalFailureException)
        pub fn build(self) -> crate::error::InternalFailureException {
            crate::error::InternalFailureException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl InternalFailureException {
    /// Creates a new builder-style object to manufacture [`InternalFailureException`](crate::error::InternalFailureException)
    pub fn builder() -> crate::error::internal_failure_exception::Builder {
        crate::error::internal_failure_exception::Builder::default()
    }
}

/// <p>You don't have access to this item. The provided credentials couldn't be
/// validated. You might not be authorized to carry out the request. Make sure that your
/// account is authorized to use the Amazon QuickSight service, that your policies have the
/// correct permissions, and that you are using the correct access keys.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request ID for this request.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl AccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request ID for this request.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// <p>This error indicates that you are calling an operation on an Amazon QuickSight
/// subscription where the edition doesn't include support for that operation. Amazon
/// Amazon QuickSight currently has Standard Edition and Enterprise Edition. Not every operation and
/// capability is available in every edition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedUserEditionException {
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request ID for this request.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedUserEditionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedUserEditionException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl UnsupportedUserEditionException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedUserEditionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedUserEditionException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedUserEditionException {}
/// See [`UnsupportedUserEditionException`](crate::error::UnsupportedUserEditionException)
pub mod unsupported_user_edition_exception {
    /// A builder for [`UnsupportedUserEditionException`](crate::error::UnsupportedUserEditionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request ID for this request.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedUserEditionException`](crate::error::UnsupportedUserEditionException)
        pub fn build(self) -> crate::error::UnsupportedUserEditionException {
            crate::error::UnsupportedUserEditionException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl UnsupportedUserEditionException {
    /// Creates a new builder-style object to manufacture [`UnsupportedUserEditionException`](crate::error::UnsupportedUserEditionException)
    pub fn builder() -> crate::error::unsupported_user_edition_exception::Builder {
        crate::error::unsupported_user_edition_exception::Builder::default()
    }
}

/// <p>The resource specified already exists. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceExistsException {
    pub message: std::option::Option<std::string::String>,
    /// <p>The resource type for this request.</p>
    pub resource_type: std::option::Option<crate::model::ExceptionResourceType>,
    /// <p>The Amazon Web Services request ID for this request.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceExistsException");
        formatter.field("message", &self.message);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl ResourceExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceExistsException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceExistsException {}
/// See [`ResourceExistsException`](crate::error::ResourceExistsException)
pub mod resource_exists_exception {
    /// A builder for [`ResourceExistsException`](crate::error::ResourceExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::ExceptionResourceType>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The resource type for this request.</p>
        pub fn resource_type(mut self, input: crate::model::ExceptionResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ExceptionResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The Amazon Web Services request ID for this request.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceExistsException`](crate::error::ResourceExistsException)
        pub fn build(self) -> crate::error::ResourceExistsException {
            crate::error::ResourceExistsException {
                message: self.message,
                resource_type: self.resource_type,
                request_id: self.request_id,
            }
        }
    }
}
impl ResourceExistsException {
    /// Creates a new builder-style object to manufacture [`ResourceExistsException`](crate::error::ResourceExistsException)
    pub fn builder() -> crate::error::resource_exists_exception::Builder {
        crate::error::resource_exists_exception::Builder::default()
    }
}

/// <p>Updating or deleting a resource can cause an inconsistent state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request ID for this request.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request ID for this request.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p>A limit is exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    pub message: std::option::Option<std::string::String>,
    /// <p>Limit exceeded.</p>
    pub resource_type: std::option::Option<crate::model::ExceptionResourceType>,
    /// <p>The Amazon Web Services request ID for this request.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::ExceptionResourceType>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>Limit exceeded.</p>
        pub fn resource_type(mut self, input: crate::model::ExceptionResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ExceptionResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The Amazon Web Services request ID for this request.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
                resource_type: self.resource_type,
                request_id: self.request_id,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>A resource is already in a state that indicates an operation is happening that must complete
/// before a new update can be applied.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConcurrentUpdatingException {
    pub message: std::option::Option<std::string::String>,
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConcurrentUpdatingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConcurrentUpdatingException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl ConcurrentUpdatingException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConcurrentUpdatingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConcurrentUpdatingException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConcurrentUpdatingException {}
/// See [`ConcurrentUpdatingException`](crate::error::ConcurrentUpdatingException)
pub mod concurrent_updating_exception {
    /// A builder for [`ConcurrentUpdatingException`](crate::error::ConcurrentUpdatingException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ConcurrentUpdatingException`](crate::error::ConcurrentUpdatingException)
        pub fn build(self) -> crate::error::ConcurrentUpdatingException {
            crate::error::ConcurrentUpdatingException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl ConcurrentUpdatingException {
    /// Creates a new builder-style object to manufacture [`ConcurrentUpdatingException`](crate::error::ConcurrentUpdatingException)
    pub fn builder() -> crate::error::concurrent_updating_exception::Builder {
        crate::error::concurrent_updating_exception::Builder::default()
    }
}

/// <p>The <code>NextToken</code> value isn't valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidNextTokenException {
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request ID for this request.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidNextTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidNextTokenException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl InvalidNextTokenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidNextTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNextTokenException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidNextTokenException {}
/// See [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
pub mod invalid_next_token_exception {
    /// A builder for [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request ID for this request.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
        pub fn build(self) -> crate::error::InvalidNextTokenException {
            crate::error::InvalidNextTokenException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl InvalidNextTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
    pub fn builder() -> crate::error::invalid_next_token_exception::Builder {
        crate::error::invalid_next_token_exception::Builder::default()
    }
}

/// <p>The number of minutes specified for the lifetime of a session isn't valid. The session
/// lifetime must be 15-600 minutes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SessionLifetimeInMinutesInvalidException {
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request ID for this request.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SessionLifetimeInMinutesInvalidException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SessionLifetimeInMinutesInvalidException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl SessionLifetimeInMinutesInvalidException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SessionLifetimeInMinutesInvalidException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SessionLifetimeInMinutesInvalidException")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for SessionLifetimeInMinutesInvalidException {}
/// See [`SessionLifetimeInMinutesInvalidException`](crate::error::SessionLifetimeInMinutesInvalidException)
pub mod session_lifetime_in_minutes_invalid_exception {
    /// A builder for [`SessionLifetimeInMinutesInvalidException`](crate::error::SessionLifetimeInMinutesInvalidException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request ID for this request.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SessionLifetimeInMinutesInvalidException`](crate::error::SessionLifetimeInMinutesInvalidException)
        pub fn build(self) -> crate::error::SessionLifetimeInMinutesInvalidException {
            crate::error::SessionLifetimeInMinutesInvalidException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl SessionLifetimeInMinutesInvalidException {
    /// Creates a new builder-style object to manufacture [`SessionLifetimeInMinutesInvalidException`](crate::error::SessionLifetimeInMinutesInvalidException)
    pub fn builder() -> crate::error::session_lifetime_in_minutes_invalid_exception::Builder {
        crate::error::session_lifetime_in_minutes_invalid_exception::Builder::default()
    }
}

/// <p>The user with the provided name isn't found. This error can happen in any operation
/// that requires finding a user based on a provided user name, such as
/// <code>DeleteUser</code>, <code>DescribeUser</code>, and so on.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QuickSightUserNotFoundException {
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request ID for this request.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for QuickSightUserNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QuickSightUserNotFoundException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl QuickSightUserNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for QuickSightUserNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "QuickSightUserNotFoundException")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for QuickSightUserNotFoundException {}
/// See [`QuickSightUserNotFoundException`](crate::error::QuickSightUserNotFoundException)
pub mod quick_sight_user_not_found_exception {
    /// A builder for [`QuickSightUserNotFoundException`](crate::error::QuickSightUserNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request ID for this request.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`QuickSightUserNotFoundException`](crate::error::QuickSightUserNotFoundException)
        pub fn build(self) -> crate::error::QuickSightUserNotFoundException {
            crate::error::QuickSightUserNotFoundException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl QuickSightUserNotFoundException {
    /// Creates a new builder-style object to manufacture [`QuickSightUserNotFoundException`](crate::error::QuickSightUserNotFoundException)
    pub fn builder() -> crate::error::quick_sight_user_not_found_exception::Builder {
        crate::error::quick_sight_user_not_found_exception::Builder::default()
    }
}

/// <p>This error indicates that you are calling an embedding operation in Amazon QuickSight
/// without the required pricing plan on your Amazon Web Services account. Before you can use embedding
/// for anonymous users, a Amazon QuickSight administrator needs to add capacity pricing to Amazon QuickSight. You
/// can do this on the <b>Manage Amazon QuickSight</b> page. </p>
/// <p>After capacity pricing is added, you can use the
/// <a>GetDashboardEmbedUrl</a> API operation with the
/// <code>--identity-type ANONYMOUS</code> option.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedPricingPlanException {
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request ID for this request.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedPricingPlanException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedPricingPlanException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl UnsupportedPricingPlanException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedPricingPlanException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedPricingPlanException")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedPricingPlanException {}
/// See [`UnsupportedPricingPlanException`](crate::error::UnsupportedPricingPlanException)
pub mod unsupported_pricing_plan_exception {
    /// A builder for [`UnsupportedPricingPlanException`](crate::error::UnsupportedPricingPlanException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request ID for this request.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedPricingPlanException`](crate::error::UnsupportedPricingPlanException)
        pub fn build(self) -> crate::error::UnsupportedPricingPlanException {
            crate::error::UnsupportedPricingPlanException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl UnsupportedPricingPlanException {
    /// Creates a new builder-style object to manufacture [`UnsupportedPricingPlanException`](crate::error::UnsupportedPricingPlanException)
    pub fn builder() -> crate::error::unsupported_pricing_plan_exception::Builder {
        crate::error::unsupported_pricing_plan_exception::Builder::default()
    }
}

/// <p>The identity type specified isn't supported. Supported identity types include
/// <code>IAM</code> and <code>QUICKSIGHT</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IdentityTypeNotSupportedException {
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request ID for this request.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IdentityTypeNotSupportedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IdentityTypeNotSupportedException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl IdentityTypeNotSupportedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IdentityTypeNotSupportedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IdentityTypeNotSupportedException")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for IdentityTypeNotSupportedException {}
/// See [`IdentityTypeNotSupportedException`](crate::error::IdentityTypeNotSupportedException)
pub mod identity_type_not_supported_exception {
    /// A builder for [`IdentityTypeNotSupportedException`](crate::error::IdentityTypeNotSupportedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request ID for this request.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`IdentityTypeNotSupportedException`](crate::error::IdentityTypeNotSupportedException)
        pub fn build(self) -> crate::error::IdentityTypeNotSupportedException {
            crate::error::IdentityTypeNotSupportedException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl IdentityTypeNotSupportedException {
    /// Creates a new builder-style object to manufacture [`IdentityTypeNotSupportedException`](crate::error::IdentityTypeNotSupportedException)
    pub fn builder() -> crate::error::identity_type_not_supported_exception::Builder {
        crate::error::identity_type_not_supported_exception::Builder::default()
    }
}

/// <p>The domain specified isn't on the allow list. All domains for embedded dashboards must be
/// added to the approved list by an Amazon QuickSight admin.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainNotWhitelistedException {
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request ID for this request.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DomainNotWhitelistedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainNotWhitelistedException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl DomainNotWhitelistedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DomainNotWhitelistedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DomainNotWhitelistedException")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for DomainNotWhitelistedException {}
/// See [`DomainNotWhitelistedException`](crate::error::DomainNotWhitelistedException)
pub mod domain_not_whitelisted_exception {
    /// A builder for [`DomainNotWhitelistedException`](crate::error::DomainNotWhitelistedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request ID for this request.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainNotWhitelistedException`](crate::error::DomainNotWhitelistedException)
        pub fn build(self) -> crate::error::DomainNotWhitelistedException {
            crate::error::DomainNotWhitelistedException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl DomainNotWhitelistedException {
    /// Creates a new builder-style object to manufacture [`DomainNotWhitelistedException`](crate::error::DomainNotWhitelistedException)
    pub fn builder() -> crate::error::domain_not_whitelisted_exception::Builder {
        crate::error::domain_not_whitelisted_exception::Builder::default()
    }
}
