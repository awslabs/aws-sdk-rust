// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The request failed because one or more input parameters don't satisfy their constraint requirements. The output is provided as a list of fields and a reason for each field that isn't valid.</p>
/// <p>The possible reasons include the following:</p>
/// <ul>
/// <li>
/// <p><b>UnrecognizedEntityType</b></p>
/// <p>The policy includes an entity type that isn't found in the schema.</p></li>
/// <li>
/// <p><b>UnrecognizedActionId</b></p>
/// <p>The policy includes an action id that isn't found in the schema.</p></li>
/// <li>
/// <p><b>InvalidActionApplication</b></p>
/// <p>The policy includes an action that, according to the schema, doesn't support the specified principal and resource.</p></li>
/// <li>
/// <p><b>UnexpectedType</b></p>
/// <p>The policy included an operand that isn't a valid type for the specified operation.</p></li>
/// <li>
/// <p><b>IncompatibleTypes</b></p>
/// <p>The types of elements included in a <code>set</code>, or the types of expressions used in an <code>if...then...else</code> clause aren't compatible in this context.</p></li>
/// <li>
/// <p><b>MissingAttribute</b></p>
/// <p>The policy attempts to access a record or entity attribute that isn't specified in the schema. Test for the existence of the attribute first before attempting to access its value. For more information, see the <a href="https://docs.cedarpolicy.com/policies/syntax-operators.html#has-presence-of-attribute-test">has (presence of attribute test) operator</a> in the <i>Cedar Policy Language Guide</i>.</p></li>
/// <li>
/// <p><b>UnsafeOptionalAttributeAccess</b></p>
/// <p>The policy attempts to access a record or entity attribute that is optional and isn't guaranteed to be present. Test for the existence of the attribute first before attempting to access its value. For more information, see the <a href="https://docs.cedarpolicy.com/policies/syntax-operators.html#has-presence-of-attribute-test">has (presence of attribute test) operator</a> in the <i>Cedar Policy Language Guide</i>.</p></li>
/// <li>
/// <p><b>ImpossiblePolicy</b></p>
/// <p>Cedar has determined that a policy condition always evaluates to false. If the policy is always false, it can never apply to any query, and so it can never affect an authorization decision.</p></li>
/// <li>
/// <p><b>WrongNumberArguments</b></p>
/// <p>The policy references an extension type with the wrong number of arguments.</p></li>
/// <li>
/// <p><b>FunctionArgumentValidationError</b></p>
/// <p>Cedar couldn't parse the argument passed to an extension type. For example, a string that is to be parsed as an IPv4 address can contain only digits and the period character.</p></li>
/// </ul>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ValidationException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: ::std::string::String,
    /// <p>The list of fields that aren't valid.</p>
    pub field_list: ::std::option::Option<::std::vec::Vec<crate::types::ValidationExceptionField>>,
    pub(crate) meta: ::aws_smithy_types::error::ErrorMetadata,
}
impl ValidationException {
    /// <p>The list of fields that aren't valid.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.field_list.is_none()`.
    pub fn field_list(&self) -> &[crate::types::ValidationExceptionField] {
        self.field_list.as_deref().unwrap_or_default()
    }
}
impl ValidationException {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        &self.message
    }
}
impl ::std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "ValidationException")?;
        {
            ::std::write!(f, ": {}", &self.message)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ValidationException {}
impl ::aws_types::request_id::RequestId for crate::types::error::ValidationException {
    fn request_id(&self) -> Option<&str> {
        use ::aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for ValidationException {
    fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::types::error::ValidationException).
    pub fn builder() -> crate::types::error::builders::ValidationExceptionBuilder {
        crate::types::error::builders::ValidationExceptionBuilder::default()
    }
}

/// A builder for [`ValidationException`](crate::types::error::ValidationException).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ValidationExceptionBuilder {
    pub(crate) message: ::std::option::Option<::std::string::String>,
    pub(crate) field_list: ::std::option::Option<::std::vec::Vec<crate::types::ValidationExceptionField>>,
    meta: std::option::Option<::aws_smithy_types::error::ErrorMetadata>,
}
impl ValidationExceptionBuilder {
    #[allow(missing_docs)] // documentation missing in model
    /// This field is required.
    pub fn message(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.message = ::std::option::Option::Some(input.into());
        self
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn set_message(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.message = input;
        self
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn get_message(&self) -> &::std::option::Option<::std::string::String> {
        &self.message
    }
    /// Appends an item to `field_list`.
    ///
    /// To override the contents of this collection use [`set_field_list`](Self::set_field_list).
    ///
    /// <p>The list of fields that aren't valid.</p>
    pub fn field_list(mut self, input: crate::types::ValidationExceptionField) -> Self {
        let mut v = self.field_list.unwrap_or_default();
        v.push(input);
        self.field_list = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of fields that aren't valid.</p>
    pub fn set_field_list(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ValidationExceptionField>>) -> Self {
        self.field_list = input;
        self
    }
    /// <p>The list of fields that aren't valid.</p>
    pub fn get_field_list(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ValidationExceptionField>> {
        &self.field_list
    }
    /// Sets error metadata
    pub fn meta(mut self, meta: ::aws_smithy_types::error::ErrorMetadata) -> Self {
        self.meta = Some(meta);
        self
    }

    /// Sets error metadata
    pub fn set_meta(&mut self, meta: std::option::Option<::aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
        self.meta = meta;
        self
    }
    /// Consumes the builder and constructs a [`ValidationException`](crate::types::error::ValidationException).
    /// This method will fail if any of the following fields are not set:
    /// - [`message`](crate::types::error::builders::ValidationExceptionBuilder::message)
    pub fn build(self) -> ::std::result::Result<crate::types::error::ValidationException, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::error::ValidationException {
            message: self.message.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "message",
                    "message was not specified but it is required when building ValidationException",
                )
            })?,
            field_list: self.field_list,
            meta: self.meta.unwrap_or_default(),
        })
    }
}
