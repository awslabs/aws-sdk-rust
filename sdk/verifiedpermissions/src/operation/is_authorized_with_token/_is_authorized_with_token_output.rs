// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct IsAuthorizedWithTokenOutput {
    /// <p>An authorization decision that indicates if the authorization request should be allowed or denied.</p>
    pub decision: crate::types::Decision,
    /// <p>The list of determining policies used to make the authorization decision. For example, if there are multiple matching policies, where at least one is a forbid policy, then because forbid always overrides permit the forbid policies are the determining policies. If all matching policies are permit policies, then those policies are the determining policies. When no policies match and the response is the default DENY, there are no determining policies.</p>
    pub determining_policies: ::std::vec::Vec<crate::types::DeterminingPolicyItem>,
    /// <p>Errors that occurred while making an authorization decision. For example, a policy references an entity or entity attribute that does not exist in the slice.</p>
    pub errors: ::std::vec::Vec<crate::types::EvaluationErrorItem>,
    _request_id: Option<String>,
}
impl IsAuthorizedWithTokenOutput {
    /// <p>An authorization decision that indicates if the authorization request should be allowed or denied.</p>
    pub fn decision(&self) -> &crate::types::Decision {
        &self.decision
    }
    /// <p>The list of determining policies used to make the authorization decision. For example, if there are multiple matching policies, where at least one is a forbid policy, then because forbid always overrides permit the forbid policies are the determining policies. If all matching policies are permit policies, then those policies are the determining policies. When no policies match and the response is the default DENY, there are no determining policies.</p>
    pub fn determining_policies(&self) -> &[crate::types::DeterminingPolicyItem] {
        use std::ops::Deref;
        self.determining_policies.deref()
    }
    /// <p>Errors that occurred while making an authorization decision. For example, a policy references an entity or entity attribute that does not exist in the slice.</p>
    pub fn errors(&self) -> &[crate::types::EvaluationErrorItem] {
        use std::ops::Deref;
        self.errors.deref()
    }
}
impl ::aws_types::request_id::RequestId for IsAuthorizedWithTokenOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl IsAuthorizedWithTokenOutput {
    /// Creates a new builder-style object to manufacture [`IsAuthorizedWithTokenOutput`](crate::operation::is_authorized_with_token::IsAuthorizedWithTokenOutput).
    pub fn builder() -> crate::operation::is_authorized_with_token::builders::IsAuthorizedWithTokenOutputBuilder {
        crate::operation::is_authorized_with_token::builders::IsAuthorizedWithTokenOutputBuilder::default()
    }
}

/// A builder for [`IsAuthorizedWithTokenOutput`](crate::operation::is_authorized_with_token::IsAuthorizedWithTokenOutput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct IsAuthorizedWithTokenOutputBuilder {
    pub(crate) decision: ::std::option::Option<crate::types::Decision>,
    pub(crate) determining_policies: ::std::option::Option<::std::vec::Vec<crate::types::DeterminingPolicyItem>>,
    pub(crate) errors: ::std::option::Option<::std::vec::Vec<crate::types::EvaluationErrorItem>>,
    _request_id: Option<String>,
}
impl IsAuthorizedWithTokenOutputBuilder {
    /// <p>An authorization decision that indicates if the authorization request should be allowed or denied.</p>
    /// This field is required.
    pub fn decision(mut self, input: crate::types::Decision) -> Self {
        self.decision = ::std::option::Option::Some(input);
        self
    }
    /// <p>An authorization decision that indicates if the authorization request should be allowed or denied.</p>
    pub fn set_decision(mut self, input: ::std::option::Option<crate::types::Decision>) -> Self {
        self.decision = input;
        self
    }
    /// <p>An authorization decision that indicates if the authorization request should be allowed or denied.</p>
    pub fn get_decision(&self) -> &::std::option::Option<crate::types::Decision> {
        &self.decision
    }
    /// Appends an item to `determining_policies`.
    ///
    /// To override the contents of this collection use [`set_determining_policies`](Self::set_determining_policies).
    ///
    /// <p>The list of determining policies used to make the authorization decision. For example, if there are multiple matching policies, where at least one is a forbid policy, then because forbid always overrides permit the forbid policies are the determining policies. If all matching policies are permit policies, then those policies are the determining policies. When no policies match and the response is the default DENY, there are no determining policies.</p>
    pub fn determining_policies(mut self, input: crate::types::DeterminingPolicyItem) -> Self {
        let mut v = self.determining_policies.unwrap_or_default();
        v.push(input);
        self.determining_policies = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of determining policies used to make the authorization decision. For example, if there are multiple matching policies, where at least one is a forbid policy, then because forbid always overrides permit the forbid policies are the determining policies. If all matching policies are permit policies, then those policies are the determining policies. When no policies match and the response is the default DENY, there are no determining policies.</p>
    pub fn set_determining_policies(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::DeterminingPolicyItem>>) -> Self {
        self.determining_policies = input;
        self
    }
    /// <p>The list of determining policies used to make the authorization decision. For example, if there are multiple matching policies, where at least one is a forbid policy, then because forbid always overrides permit the forbid policies are the determining policies. If all matching policies are permit policies, then those policies are the determining policies. When no policies match and the response is the default DENY, there are no determining policies.</p>
    pub fn get_determining_policies(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::DeterminingPolicyItem>> {
        &self.determining_policies
    }
    /// Appends an item to `errors`.
    ///
    /// To override the contents of this collection use [`set_errors`](Self::set_errors).
    ///
    /// <p>Errors that occurred while making an authorization decision. For example, a policy references an entity or entity attribute that does not exist in the slice.</p>
    pub fn errors(mut self, input: crate::types::EvaluationErrorItem) -> Self {
        let mut v = self.errors.unwrap_or_default();
        v.push(input);
        self.errors = ::std::option::Option::Some(v);
        self
    }
    /// <p>Errors that occurred while making an authorization decision. For example, a policy references an entity or entity attribute that does not exist in the slice.</p>
    pub fn set_errors(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::EvaluationErrorItem>>) -> Self {
        self.errors = input;
        self
    }
    /// <p>Errors that occurred while making an authorization decision. For example, a policy references an entity or entity attribute that does not exist in the slice.</p>
    pub fn get_errors(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::EvaluationErrorItem>> {
        &self.errors
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`IsAuthorizedWithTokenOutput`](crate::operation::is_authorized_with_token::IsAuthorizedWithTokenOutput).
    /// This method will fail if any of the following fields are not set:
    /// - [`decision`](crate::operation::is_authorized_with_token::builders::IsAuthorizedWithTokenOutputBuilder::decision)
    /// - [`determining_policies`](crate::operation::is_authorized_with_token::builders::IsAuthorizedWithTokenOutputBuilder::determining_policies)
    /// - [`errors`](crate::operation::is_authorized_with_token::builders::IsAuthorizedWithTokenOutputBuilder::errors)
    pub fn build(
        self,
    ) -> ::std::result::Result<
        crate::operation::is_authorized_with_token::IsAuthorizedWithTokenOutput,
        ::aws_smithy_types::error::operation::BuildError,
    > {
        ::std::result::Result::Ok(crate::operation::is_authorized_with_token::IsAuthorizedWithTokenOutput {
            decision: self.decision.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "decision",
                    "decision was not specified but it is required when building IsAuthorizedWithTokenOutput",
                )
            })?,
            determining_policies: self.determining_policies.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "determining_policies",
                    "determining_policies was not specified but it is required when building IsAuthorizedWithTokenOutput",
                )
            })?,
            errors: self.errors.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "errors",
                    "errors was not specified but it is required when building IsAuthorizedWithTokenOutput",
                )
            })?,
            _request_id: self._request_id,
        })
    }
}
