// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct IsAuthorizedOutput {
    /// <p>An authorization decision that indicates if the authorization request should be allowed or denied.</p>
    pub decision: crate::types::Decision,
    /// <p>The list of determining policies used to make the authorization decision. For example, if there are two matching policies, where one is a forbid and the other is a permit, then the forbid policy will be the determining policy. In the case of multiple matching permit policies then there would be multiple determining policies. In the case that no policies match, and hence the response is DENY, there would be no determining policies.</p>
    pub determining_policies: ::std::vec::Vec<crate::types::DeterminingPolicyItem>,
    /// <p>Errors that occurred while making an authorization decision, for example, a policy references an Entity or entity Attribute that does not exist in the slice.</p>
    pub errors: ::std::vec::Vec<crate::types::EvaluationErrorItem>,
    _request_id: Option<String>,
}
impl IsAuthorizedOutput {
    /// <p>An authorization decision that indicates if the authorization request should be allowed or denied.</p>
    pub fn decision(&self) -> &crate::types::Decision {
        &self.decision
    }
    /// <p>The list of determining policies used to make the authorization decision. For example, if there are two matching policies, where one is a forbid and the other is a permit, then the forbid policy will be the determining policy. In the case of multiple matching permit policies then there would be multiple determining policies. In the case that no policies match, and hence the response is DENY, there would be no determining policies.</p>
    pub fn determining_policies(&self) -> &[crate::types::DeterminingPolicyItem] {
        use std::ops::Deref;
        self.determining_policies.deref()
    }
    /// <p>Errors that occurred while making an authorization decision, for example, a policy references an Entity or entity Attribute that does not exist in the slice.</p>
    pub fn errors(&self) -> &[crate::types::EvaluationErrorItem] {
        use std::ops::Deref;
        self.errors.deref()
    }
}
impl ::aws_http::request_id::RequestId for IsAuthorizedOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl IsAuthorizedOutput {
    /// Creates a new builder-style object to manufacture [`IsAuthorizedOutput`](crate::operation::is_authorized::IsAuthorizedOutput).
    pub fn builder() -> crate::operation::is_authorized::builders::IsAuthorizedOutputBuilder {
        crate::operation::is_authorized::builders::IsAuthorizedOutputBuilder::default()
    }
}

/// A builder for [`IsAuthorizedOutput`](crate::operation::is_authorized::IsAuthorizedOutput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct IsAuthorizedOutputBuilder {
    pub(crate) decision: ::std::option::Option<crate::types::Decision>,
    pub(crate) determining_policies: ::std::option::Option<::std::vec::Vec<crate::types::DeterminingPolicyItem>>,
    pub(crate) errors: ::std::option::Option<::std::vec::Vec<crate::types::EvaluationErrorItem>>,
    _request_id: Option<String>,
}
impl IsAuthorizedOutputBuilder {
    /// <p>An authorization decision that indicates if the authorization request should be allowed or denied.</p>
    /// This field is required.
    pub fn decision(mut self, input: crate::types::Decision) -> Self {
        self.decision = ::std::option::Option::Some(input);
        self
    }
    /// <p>An authorization decision that indicates if the authorization request should be allowed or denied.</p>
    pub fn set_decision(mut self, input: ::std::option::Option<crate::types::Decision>) -> Self {
        self.decision = input;
        self
    }
    /// <p>An authorization decision that indicates if the authorization request should be allowed or denied.</p>
    pub fn get_decision(&self) -> &::std::option::Option<crate::types::Decision> {
        &self.decision
    }
    /// Appends an item to `determining_policies`.
    ///
    /// To override the contents of this collection use [`set_determining_policies`](Self::set_determining_policies).
    ///
    /// <p>The list of determining policies used to make the authorization decision. For example, if there are two matching policies, where one is a forbid and the other is a permit, then the forbid policy will be the determining policy. In the case of multiple matching permit policies then there would be multiple determining policies. In the case that no policies match, and hence the response is DENY, there would be no determining policies.</p>
    pub fn determining_policies(mut self, input: crate::types::DeterminingPolicyItem) -> Self {
        let mut v = self.determining_policies.unwrap_or_default();
        v.push(input);
        self.determining_policies = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of determining policies used to make the authorization decision. For example, if there are two matching policies, where one is a forbid and the other is a permit, then the forbid policy will be the determining policy. In the case of multiple matching permit policies then there would be multiple determining policies. In the case that no policies match, and hence the response is DENY, there would be no determining policies.</p>
    pub fn set_determining_policies(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::DeterminingPolicyItem>>) -> Self {
        self.determining_policies = input;
        self
    }
    /// <p>The list of determining policies used to make the authorization decision. For example, if there are two matching policies, where one is a forbid and the other is a permit, then the forbid policy will be the determining policy. In the case of multiple matching permit policies then there would be multiple determining policies. In the case that no policies match, and hence the response is DENY, there would be no determining policies.</p>
    pub fn get_determining_policies(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::DeterminingPolicyItem>> {
        &self.determining_policies
    }
    /// Appends an item to `errors`.
    ///
    /// To override the contents of this collection use [`set_errors`](Self::set_errors).
    ///
    /// <p>Errors that occurred while making an authorization decision, for example, a policy references an Entity or entity Attribute that does not exist in the slice.</p>
    pub fn errors(mut self, input: crate::types::EvaluationErrorItem) -> Self {
        let mut v = self.errors.unwrap_or_default();
        v.push(input);
        self.errors = ::std::option::Option::Some(v);
        self
    }
    /// <p>Errors that occurred while making an authorization decision, for example, a policy references an Entity or entity Attribute that does not exist in the slice.</p>
    pub fn set_errors(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::EvaluationErrorItem>>) -> Self {
        self.errors = input;
        self
    }
    /// <p>Errors that occurred while making an authorization decision, for example, a policy references an Entity or entity Attribute that does not exist in the slice.</p>
    pub fn get_errors(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::EvaluationErrorItem>> {
        &self.errors
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`IsAuthorizedOutput`](crate::operation::is_authorized::IsAuthorizedOutput).
    /// This method will fail if any of the following fields are not set:
    /// - [`decision`](crate::operation::is_authorized::builders::IsAuthorizedOutputBuilder::decision)
    /// - [`determining_policies`](crate::operation::is_authorized::builders::IsAuthorizedOutputBuilder::determining_policies)
    /// - [`errors`](crate::operation::is_authorized::builders::IsAuthorizedOutputBuilder::errors)
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::is_authorized::IsAuthorizedOutput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::is_authorized::IsAuthorizedOutput {
            decision: self.decision.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "decision",
                    "decision was not specified but it is required when building IsAuthorizedOutput",
                )
            })?,
            determining_policies: self.determining_policies.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "determining_policies",
                    "determining_policies was not specified but it is required when building IsAuthorizedOutput",
                )
            })?,
            errors: self.errors.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "errors",
                    "errors was not specified but it is required when building IsAuthorizedOutput",
                )
            })?,
            _request_id: self._request_id,
        })
    }
}
