// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Orchestration and serialization glue logic for `CreateTrail`.
#[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct CreateTrail;
impl CreateTrail {
    /// Creates a new `CreateTrail`
    pub fn new() -> Self {
        Self
    }
    pub(crate) async fn orchestrate(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::create_trail::CreateTrailInput,
    ) -> ::std::result::Result<
        crate::operation::create_trail::CreateTrailOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_trail::CreateTrailError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let map_err = |err: ::aws_smithy_runtime_api::client::result::SdkError<
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >| {
            err.map_service_error(|err| {
                err.downcast::<crate::operation::create_trail::CreateTrailError>()
                    .expect("correct error type")
            })
        };
        let context = Self::orchestrate_with_stop_point(runtime_plugins, input, ::aws_smithy_runtime::client::orchestrator::StopPoint::None)
            .await
            .map_err(map_err)?;
        let output = context.finalize().map_err(map_err)?;
        ::std::result::Result::Ok(
            output
                .downcast::<crate::operation::create_trail::CreateTrailOutput>()
                .expect("correct output type"),
        )
    }

    pub(crate) async fn orchestrate_with_stop_point(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::create_trail::CreateTrailInput,
        stop_point: ::aws_smithy_runtime::client::orchestrator::StopPoint,
    ) -> ::std::result::Result<
        ::aws_smithy_runtime_api::client::interceptors::context::InterceptorContext,
        ::aws_smithy_runtime_api::client::result::SdkError<
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = ::aws_smithy_runtime_api::client::interceptors::context::Input::erase(input);
        ::aws_smithy_runtime::client::orchestrator::invoke_with_stop_point("cloudtrail", "CreateTrail", input, runtime_plugins, stop_point).await
    }

    pub(crate) fn operation_runtime_plugins(
        client_runtime_plugins: ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        client_config: &crate::config::Config,
        config_override: ::std::option::Option<crate::config::Builder>,
    ) -> ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins {
        let mut runtime_plugins = client_runtime_plugins.with_operation_plugin(Self::new());
        runtime_plugins = runtime_plugins.with_client_plugin(crate::auth_plugin::DefaultAuthOptionsPlugin::new(vec![
            ::aws_runtime::auth::sigv4::SCHEME_ID,
        ]));
        if let ::std::option::Option::Some(config_override) = config_override {
            for plugin in config_override.runtime_plugins.iter().cloned() {
                runtime_plugins = runtime_plugins.with_operation_plugin(plugin);
            }
            runtime_plugins = runtime_plugins.with_operation_plugin(crate::config::ConfigOverrideRuntimePlugin::new(
                config_override,
                client_config.config.clone(),
                &client_config.runtime_components,
            ));
        }
        runtime_plugins
    }
}
impl ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugin for CreateTrail {
    fn config(&self) -> ::std::option::Option<::aws_smithy_types::config_bag::FrozenLayer> {
        let mut cfg = ::aws_smithy_types::config_bag::Layer::new("CreateTrail");

        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedRequestSerializer::new(
            CreateTrailRequestSerializer,
        ));
        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedResponseDeserializer::new(
            CreateTrailResponseDeserializer,
        ));

        cfg.store_put(::aws_smithy_runtime_api::client::auth::AuthSchemeOptionResolverParams::new(
            ::aws_smithy_runtime_api::client::auth::static_resolver::StaticAuthSchemeOptionResolverParams::new(),
        ));

        cfg.store_put(::aws_smithy_runtime_api::client::orchestrator::Metadata::new("CreateTrail", "cloudtrail"));
        let mut signing_options = ::aws_runtime::auth::SigningOptions::default();
        signing_options.double_uri_encode = true;
        signing_options.content_sha256_header = false;
        signing_options.normalize_uri_path = true;
        signing_options.payload_override = None;

        cfg.store_put(::aws_runtime::auth::SigV4OperationSigningConfig {
            signing_options,
            ..::std::default::Default::default()
        });

        ::std::option::Option::Some(cfg.freeze())
    }

    fn runtime_components(
        &self,
        _: &::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder,
    ) -> ::std::borrow::Cow<'_, ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder> {
        #[allow(unused_mut)]
        let mut rcb = ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder::new("CreateTrail")
            .with_interceptor(
                ::aws_smithy_runtime::client::stalled_stream_protection::StalledStreamProtectionInterceptor::new(
                    ::aws_smithy_runtime::client::stalled_stream_protection::StalledStreamProtectionInterceptorKind::ResponseBody,
                ),
            )
            .with_interceptor(CreateTrailEndpointParamsInterceptor)
            .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::TransientErrorClassifier::<
                crate::operation::create_trail::CreateTrailError,
            >::new())
            .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::ModeledAsRetryableClassifier::<
                crate::operation::create_trail::CreateTrailError,
            >::new())
            .with_retry_classifier(::aws_runtime::retries::classifiers::AwsErrorCodeClassifier::<
                crate::operation::create_trail::CreateTrailError,
            >::new());

        ::std::borrow::Cow::Owned(rcb)
    }
}

#[derive(Debug)]
struct CreateTrailResponseDeserializer;
impl ::aws_smithy_runtime_api::client::ser_de::DeserializeResponse for CreateTrailResponseDeserializer {
    fn deserialize_nonstreaming(
        &self,
        response: &::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
    ) -> ::aws_smithy_runtime_api::client::interceptors::context::OutputOrError {
        let (success, status) = (response.status().is_success(), response.status().as_u16());
        let headers = response.headers();
        let body = response.body().bytes().expect("body loaded");
        #[allow(unused_mut)]
        let mut force_error = false;
        ::tracing::debug!(request_id = ?::aws_types::request_id::RequestId::request_id(response));
        let parse_result = if !success && status != 200 || force_error {
            crate::protocol_serde::shape_create_trail::de_create_trail_http_error(status, headers, body)
        } else {
            crate::protocol_serde::shape_create_trail::de_create_trail_http_response(status, headers, body)
        };
        crate::protocol_serde::type_erase_result(parse_result)
    }
}
#[derive(Debug)]
struct CreateTrailRequestSerializer;
impl ::aws_smithy_runtime_api::client::ser_de::SerializeRequest for CreateTrailRequestSerializer {
    #[allow(unused_mut, clippy::let_and_return, clippy::needless_borrow, clippy::useless_conversion)]
    fn serialize_input(
        &self,
        input: ::aws_smithy_runtime_api::client::interceptors::context::Input,
        _cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<::aws_smithy_runtime_api::client::orchestrator::HttpRequest, ::aws_smithy_runtime_api::box_error::BoxError> {
        let input = input
            .downcast::<crate::operation::create_trail::CreateTrailInput>()
            .expect("correct type");
        let _header_serialization_settings = _cfg
            .load::<crate::serialization_settings::HeaderSerializationSettings>()
            .cloned()
            .unwrap_or_default();
        let mut request_builder = {
            fn uri_base(
                _input: &crate::operation::create_trail::CreateTrailInput,
                output: &mut ::std::string::String,
            ) -> ::std::result::Result<(), ::aws_smithy_types::error::operation::BuildError> {
                use ::std::fmt::Write as _;
                ::std::write!(output, "/").expect("formatting should succeed");
                ::std::result::Result::Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::operation::create_trail::CreateTrailInput,
                builder: ::http::request::Builder,
            ) -> ::std::result::Result<::http::request::Builder, ::aws_smithy_types::error::operation::BuildError> {
                let mut uri = ::std::string::String::new();
                uri_base(input, &mut uri)?;
                ::std::result::Result::Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&input, ::http::request::Builder::new())?;
            builder = _header_serialization_settings.set_default_header(builder, ::http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = _header_serialization_settings.set_default_header(
                builder,
                ::http::header::HeaderName::from_static("x-amz-target"),
                "CloudTrail_20131101.CreateTrail",
            );
            builder
        };
        let body = ::aws_smithy_types::body::SdkBody::from(crate::protocol_serde::shape_create_trail::ser_create_trail_input(&input)?);
        if let Some(content_length) = body.content_length() {
            let content_length = content_length.to_string();
            request_builder = _header_serialization_settings.set_default_header(request_builder, ::http::header::CONTENT_LENGTH, &content_length);
        }
        ::std::result::Result::Ok(request_builder.body(body).expect("valid request").try_into().unwrap())
    }
}
#[derive(Debug)]
struct CreateTrailEndpointParamsInterceptor;

impl ::aws_smithy_runtime_api::client::interceptors::Intercept for CreateTrailEndpointParamsInterceptor {
    fn name(&self) -> &'static str {
        "CreateTrailEndpointParamsInterceptor"
    }

    fn read_before_execution(
        &self,
        context: &::aws_smithy_runtime_api::client::interceptors::context::BeforeSerializationInterceptorContextRef<
            '_,
            ::aws_smithy_runtime_api::client::interceptors::context::Input,
            ::aws_smithy_runtime_api::client::interceptors::context::Output,
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
        >,
        cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<(), ::aws_smithy_runtime_api::box_error::BoxError> {
        let _input = context
            .input()
            .downcast_ref::<CreateTrailInput>()
            .ok_or("failed to downcast to CreateTrailInput")?;

        let params = crate::config::endpoint::Params::builder()
            .set_region(cfg.load::<::aws_types::region::Region>().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(cfg.load::<::aws_types::endpoint_config::UseDualStack>().map(|ty| ty.0))
            .set_use_fips(cfg.load::<::aws_types::endpoint_config::UseFips>().map(|ty| ty.0))
            .set_endpoint(cfg.load::<::aws_types::endpoint_config::EndpointUrl>().map(|ty| ty.0.clone()))
            .build()
            .map_err(|err| {
                ::aws_smithy_runtime_api::client::interceptors::error::ContextAttachedError::new("endpoint params could not be built", err)
            })?;
        cfg.interceptor_state()
            .store_put(::aws_smithy_runtime_api::client::endpoint::EndpointResolverParams::new(params));
        ::std::result::Result::Ok(())
    }
}

/// Error type for the `CreateTrailError` operation.
#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum CreateTrailError {
    /// <p>This exception is thrown when trusted access has not been enabled between CloudTrail and Organizations. For more information, see <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_integrate_services.html">Enabling Trusted Access with Other Amazon Web Services Services</a> and <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
    CloudTrailAccessNotEnabledException(crate::types::error::CloudTrailAccessNotEnabledException),
    /// <p>This exception is thrown when a call results in the <code>InvalidClientTokenId</code> error code. This can occur when you are creating or updating a trail to send notifications to an Amazon SNS topic that is in a suspended Amazon Web Services account.</p>
    CloudTrailInvalidClientTokenIdException(crate::types::error::CloudTrailInvalidClientTokenIdException),
    /// <p>Cannot set a CloudWatch Logs delivery for this Region.</p>
    CloudWatchLogsDeliveryUnavailableException(crate::types::error::CloudWatchLogsDeliveryUnavailableException),
    /// <p>This exception is thrown when the specified resource is not ready for an operation. This can occur when you try to run an operation on a resource before CloudTrail has time to fully load the resource, or because another operation is modifying the resource. If this exception occurs, wait a few minutes, and then try the operation again.</p>
    ConflictException(crate::types::error::ConflictException),
    /// <p>This exception is thrown when the IAM identity that is used to create the organization resource lacks one or more required permissions for creating an organization resource in a required service.</p>
    InsufficientDependencyServiceAccessPermissionException(crate::types::error::InsufficientDependencyServiceAccessPermissionException),
    /// <p>This exception is thrown when the policy on the S3 bucket or KMS key does not have sufficient permissions for the operation.</p>
    InsufficientEncryptionPolicyException(crate::types::error::InsufficientEncryptionPolicyException),
    /// <p>This exception is thrown when the policy on the S3 bucket is not sufficient.</p>
    InsufficientS3BucketPolicyException(crate::types::error::InsufficientS3BucketPolicyException),
    /// <p>This exception is thrown when the policy on the Amazon SNS topic is not sufficient.</p>
    InsufficientSnsTopicPolicyException(crate::types::error::InsufficientSnsTopicPolicyException),
    /// <p>This exception is thrown when the provided CloudWatch Logs log group is not valid.</p>
    InvalidCloudWatchLogsLogGroupArnException(crate::types::error::InvalidCloudWatchLogsLogGroupArnException),
    /// <p>This exception is thrown when the provided role is not valid.</p>
    InvalidCloudWatchLogsRoleArnException(crate::types::error::InvalidCloudWatchLogsRoleArnException),
    /// <p>This exception is thrown when the KMS key ARN is not valid.</p>
    InvalidKmsKeyIdException(crate::types::error::InvalidKmsKeyIdException),
    /// <p>This exception is thrown when the combination of parameters provided is not valid.</p>
    InvalidParameterCombinationException(crate::types::error::InvalidParameterCombinationException),
    /// <p>This exception is thrown when the provided S3 bucket name is not valid.</p>
    InvalidS3BucketNameException(crate::types::error::InvalidS3BucketNameException),
    /// <p>This exception is thrown when the provided S3 prefix is not valid.</p>
    InvalidS3PrefixException(crate::types::error::InvalidS3PrefixException),
    /// <p>This exception is thrown when the provided SNS topic name is not valid.</p>
    InvalidSnsTopicNameException(crate::types::error::InvalidSnsTopicNameException),
    /// <p>This exception is thrown when the specified tag key or values are not valid. It can also occur if there are duplicate tags or too many tags on the resource.</p>
    InvalidTagParameterException(crate::types::error::InvalidTagParameterException),
    /// <p>This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p></li>
    /// <li>
    /// <p>Start with a letter or number, and end with a letter or number</p></li>
    /// <li>
    /// <p>Be between 3 and 128 characters</p></li>
    /// <li>
    /// <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code> and <code>my--namespace</code> are not valid.</p></li>
    /// <li>
    /// <p>Not be in IP address format (for example, 192.168.5.4)</p></li>
    /// </ul>
    InvalidTrailNameException(crate::types::error::InvalidTrailNameException),
    /// <p>This exception is thrown when there is an issue with the specified KMS key and the trail or event data store can't be updated.</p>
    KmsException(crate::types::error::KmsException),
    /// <p>This exception is no longer in use.</p>
    #[deprecated]
    KmsKeyDisabledException(crate::types::error::KmsKeyDisabledException),
    /// <p>This exception is thrown when the KMS key does not exist, when the S3 bucket and the KMS key are not in the same Region, or when the KMS key associated with the Amazon SNS topic either does not exist or is not in the same Region.</p>
    KmsKeyNotFoundException(crate::types::error::KmsKeyNotFoundException),
    /// <p>This exception is thrown when the maximum number of trails is reached.</p>
    MaximumNumberOfTrailsExceededException(crate::types::error::MaximumNumberOfTrailsExceededException),
    /// <p>This exception is thrown when the management account does not have a service-linked role.</p>
    NoManagementAccountSlrExistsException(crate::types::error::NoManagementAccountSlrExistsException),
    /// <p>This exception is thrown when the Amazon Web Services account making the request to create or update an organization trail or event data store is not the management account for an organization in Organizations. For more information, see <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a> or <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/query-event-data-store.html">Create an event data store</a>.</p>
    NotOrganizationMasterAccountException(crate::types::error::NotOrganizationMasterAccountException),
    /// <p>This exception is thrown when the requested operation is not permitted.</p>
    OperationNotPermittedException(crate::types::error::OperationNotPermittedException),
    /// <p>This exception is thrown when Organizations is not configured to support all features. All features must be enabled in Organizations to support creating an organization trail or event data store.</p>
    OrganizationNotInAllFeaturesModeException(crate::types::error::OrganizationNotInAllFeaturesModeException),
    /// <p>This exception is thrown when the request is made from an Amazon Web Services account that is not a member of an organization. To make this request, sign in using the credentials of an account that belongs to an organization.</p>
    OrganizationsNotInUseException(crate::types::error::OrganizationsNotInUseException),
    /// <p>This exception is thrown when the specified S3 bucket does not exist.</p>
    S3BucketDoesNotExistException(crate::types::error::S3BucketDoesNotExistException),
    /// <p>The number of tags per trail, event data store, or channel has exceeded the permitted amount. Currently, the limit is 50.</p>
    TagsLimitExceededException(crate::types::error::TagsLimitExceededException),
    /// <p>This exception is thrown when the request rate exceeds the limit.</p>
    ThrottlingException(crate::types::error::ThrottlingException),
    /// <p>This exception is thrown when the specified trail already exists.</p>
    TrailAlreadyExistsException(crate::types::error::TrailAlreadyExistsException),
    /// <p>This exception is no longer in use.</p>
    TrailNotProvidedException(crate::types::error::TrailNotProvidedException),
    /// <p>This exception is thrown when the requested operation is not supported.</p>
    UnsupportedOperationException(crate::types::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    #[deprecated(note = "Matching `Unhandled` directly is not forwards compatible. Instead, match using a \
    variable wildcard pattern and check `.code()`:
     \
    &nbsp;&nbsp;&nbsp;`err if err.code() == Some(\"SpecificExceptionCode\") => { /* handle the error */ }`
     \
    See [`ProvideErrorMetadata`](#impl-ProvideErrorMetadata-for-CreateTrailError) for what information is available for the error.")]
    Unhandled(crate::error::sealed_unhandled::Unhandled),
}
impl CreateTrailError {
    /// Creates the `CreateTrailError::Unhandled` variant from any error type.
    pub fn unhandled(
        err: impl ::std::convert::Into<::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>>,
    ) -> Self {
        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source: err.into(),
            meta: ::std::default::Default::default(),
        })
    }

    /// Creates the `CreateTrailError::Unhandled` variant from an [`ErrorMetadata`](::aws_smithy_types::error::ErrorMetadata).
    pub fn generic(err: ::aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source: err.clone().into(),
            meta: err,
        })
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CloudTrailAccessNotEnabledException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::CloudTrailInvalidClientTokenIdException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::CloudWatchLogsDeliveryUnavailableException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::ConflictException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InsufficientDependencyServiceAccessPermissionException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InsufficientEncryptionPolicyException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InsufficientS3BucketPolicyException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InsufficientSnsTopicPolicyException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidCloudWatchLogsLogGroupArnException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidCloudWatchLogsRoleArnException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidKmsKeyIdException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidParameterCombinationException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidS3BucketNameException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidS3PrefixException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidSnsTopicNameException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidTagParameterException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidTrailNameException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::KmsException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::KmsKeyDisabledException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::KmsKeyNotFoundException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::MaximumNumberOfTrailsExceededException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::NoManagementAccountSlrExistsException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::NotOrganizationMasterAccountException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::OperationNotPermittedException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::OrganizationNotInAllFeaturesModeException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::OrganizationsNotInUseException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::S3BucketDoesNotExistException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::TagsLimitExceededException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::ThrottlingException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::TrailAlreadyExistsException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::TrailNotProvidedException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::UnsupportedOperationException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::Unhandled(e) => &e.meta,
        }
    }
    /// Returns `true` if the error kind is `CreateTrailError::CloudTrailAccessNotEnabledException`.
    pub fn is_cloud_trail_access_not_enabled_exception(&self) -> bool {
        matches!(self, Self::CloudTrailAccessNotEnabledException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::CloudTrailInvalidClientTokenIdException`.
    pub fn is_cloud_trail_invalid_client_token_id_exception(&self) -> bool {
        matches!(self, Self::CloudTrailInvalidClientTokenIdException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::CloudWatchLogsDeliveryUnavailableException`.
    pub fn is_cloud_watch_logs_delivery_unavailable_exception(&self) -> bool {
        matches!(self, Self::CloudWatchLogsDeliveryUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(self, Self::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::InsufficientDependencyServiceAccessPermissionException`.
    pub fn is_insufficient_dependency_service_access_permission_exception(&self) -> bool {
        matches!(self, Self::InsufficientDependencyServiceAccessPermissionException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::InsufficientEncryptionPolicyException`.
    pub fn is_insufficient_encryption_policy_exception(&self) -> bool {
        matches!(self, Self::InsufficientEncryptionPolicyException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::InsufficientS3BucketPolicyException`.
    pub fn is_insufficient_s3_bucket_policy_exception(&self) -> bool {
        matches!(self, Self::InsufficientS3BucketPolicyException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::InsufficientSnsTopicPolicyException`.
    pub fn is_insufficient_sns_topic_policy_exception(&self) -> bool {
        matches!(self, Self::InsufficientSnsTopicPolicyException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::InvalidCloudWatchLogsLogGroupArnException`.
    pub fn is_invalid_cloud_watch_logs_log_group_arn_exception(&self) -> bool {
        matches!(self, Self::InvalidCloudWatchLogsLogGroupArnException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::InvalidCloudWatchLogsRoleArnException`.
    pub fn is_invalid_cloud_watch_logs_role_arn_exception(&self) -> bool {
        matches!(self, Self::InvalidCloudWatchLogsRoleArnException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::InvalidKmsKeyIdException`.
    pub fn is_invalid_kms_key_id_exception(&self) -> bool {
        matches!(self, Self::InvalidKmsKeyIdException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterCombinationException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::InvalidS3BucketNameException`.
    pub fn is_invalid_s3_bucket_name_exception(&self) -> bool {
        matches!(self, Self::InvalidS3BucketNameException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::InvalidS3PrefixException`.
    pub fn is_invalid_s3_prefix_exception(&self) -> bool {
        matches!(self, Self::InvalidS3PrefixException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::InvalidSnsTopicNameException`.
    pub fn is_invalid_sns_topic_name_exception(&self) -> bool {
        matches!(self, Self::InvalidSnsTopicNameException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::InvalidTagParameterException`.
    pub fn is_invalid_tag_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidTagParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::InvalidTrailNameException`.
    pub fn is_invalid_trail_name_exception(&self) -> bool {
        matches!(self, Self::InvalidTrailNameException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::KmsException`.
    pub fn is_kms_exception(&self) -> bool {
        matches!(self, Self::KmsException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::KmsKeyDisabledException`.
    pub fn is_kms_key_disabled_exception(&self) -> bool {
        matches!(self, Self::KmsKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::KmsKeyNotFoundException`.
    pub fn is_kms_key_not_found_exception(&self) -> bool {
        matches!(self, Self::KmsKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::MaximumNumberOfTrailsExceededException`.
    pub fn is_maximum_number_of_trails_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumNumberOfTrailsExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::NoManagementAccountSlrExistsException`.
    pub fn is_no_management_account_slr_exists_exception(&self) -> bool {
        matches!(self, Self::NoManagementAccountSlrExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::NotOrganizationMasterAccountException`.
    pub fn is_not_organization_master_account_exception(&self) -> bool {
        matches!(self, Self::NotOrganizationMasterAccountException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(self, Self::OperationNotPermittedException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::OrganizationNotInAllFeaturesModeException`.
    pub fn is_organization_not_in_all_features_mode_exception(&self) -> bool {
        matches!(self, Self::OrganizationNotInAllFeaturesModeException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::OrganizationsNotInUseException`.
    pub fn is_organizations_not_in_use_exception(&self) -> bool {
        matches!(self, Self::OrganizationsNotInUseException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::S3BucketDoesNotExistException`.
    pub fn is_s3_bucket_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::S3BucketDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::TagsLimitExceededException`.
    pub fn is_tags_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::TagsLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(self, Self::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::TrailAlreadyExistsException`.
    pub fn is_trail_already_exists_exception(&self) -> bool {
        matches!(self, Self::TrailAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::TrailNotProvidedException`.
    pub fn is_trail_not_provided_exception(&self) -> bool {
        matches!(self, Self::TrailNotProvidedException(_))
    }
    /// Returns `true` if the error kind is `CreateTrailError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl ::std::error::Error for CreateTrailError {
    fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            Self::CloudTrailAccessNotEnabledException(_inner) => ::std::option::Option::Some(_inner),
            Self::CloudTrailInvalidClientTokenIdException(_inner) => ::std::option::Option::Some(_inner),
            Self::CloudWatchLogsDeliveryUnavailableException(_inner) => ::std::option::Option::Some(_inner),
            Self::ConflictException(_inner) => ::std::option::Option::Some(_inner),
            Self::InsufficientDependencyServiceAccessPermissionException(_inner) => ::std::option::Option::Some(_inner),
            Self::InsufficientEncryptionPolicyException(_inner) => ::std::option::Option::Some(_inner),
            Self::InsufficientS3BucketPolicyException(_inner) => ::std::option::Option::Some(_inner),
            Self::InsufficientSnsTopicPolicyException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidCloudWatchLogsLogGroupArnException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidCloudWatchLogsRoleArnException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidKmsKeyIdException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidParameterCombinationException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidS3BucketNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidS3PrefixException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidSnsTopicNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidTagParameterException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidTrailNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::KmsException(_inner) => ::std::option::Option::Some(_inner),
            Self::KmsKeyDisabledException(_inner) => ::std::option::Option::Some(_inner),
            Self::KmsKeyNotFoundException(_inner) => ::std::option::Option::Some(_inner),
            Self::MaximumNumberOfTrailsExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::NoManagementAccountSlrExistsException(_inner) => ::std::option::Option::Some(_inner),
            Self::NotOrganizationMasterAccountException(_inner) => ::std::option::Option::Some(_inner),
            Self::OperationNotPermittedException(_inner) => ::std::option::Option::Some(_inner),
            Self::OrganizationNotInAllFeaturesModeException(_inner) => ::std::option::Option::Some(_inner),
            Self::OrganizationsNotInUseException(_inner) => ::std::option::Option::Some(_inner),
            Self::S3BucketDoesNotExistException(_inner) => ::std::option::Option::Some(_inner),
            Self::TagsLimitExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::ThrottlingException(_inner) => ::std::option::Option::Some(_inner),
            Self::TrailAlreadyExistsException(_inner) => ::std::option::Option::Some(_inner),
            Self::TrailNotProvidedException(_inner) => ::std::option::Option::Some(_inner),
            Self::UnsupportedOperationException(_inner) => ::std::option::Option::Some(_inner),
            Self::Unhandled(_inner) => ::std::option::Option::Some(&*_inner.source),
        }
    }
}
impl ::std::fmt::Display for CreateTrailError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::CloudTrailAccessNotEnabledException(_inner) => _inner.fmt(f),
            Self::CloudTrailInvalidClientTokenIdException(_inner) => _inner.fmt(f),
            Self::CloudWatchLogsDeliveryUnavailableException(_inner) => _inner.fmt(f),
            Self::ConflictException(_inner) => _inner.fmt(f),
            Self::InsufficientDependencyServiceAccessPermissionException(_inner) => _inner.fmt(f),
            Self::InsufficientEncryptionPolicyException(_inner) => _inner.fmt(f),
            Self::InsufficientS3BucketPolicyException(_inner) => _inner.fmt(f),
            Self::InsufficientSnsTopicPolicyException(_inner) => _inner.fmt(f),
            Self::InvalidCloudWatchLogsLogGroupArnException(_inner) => _inner.fmt(f),
            Self::InvalidCloudWatchLogsRoleArnException(_inner) => _inner.fmt(f),
            Self::InvalidKmsKeyIdException(_inner) => _inner.fmt(f),
            Self::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidS3BucketNameException(_inner) => _inner.fmt(f),
            Self::InvalidS3PrefixException(_inner) => _inner.fmt(f),
            Self::InvalidSnsTopicNameException(_inner) => _inner.fmt(f),
            Self::InvalidTagParameterException(_inner) => _inner.fmt(f),
            Self::InvalidTrailNameException(_inner) => _inner.fmt(f),
            Self::KmsException(_inner) => _inner.fmt(f),
            Self::KmsKeyDisabledException(_inner) => _inner.fmt(f),
            Self::KmsKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::MaximumNumberOfTrailsExceededException(_inner) => _inner.fmt(f),
            Self::NoManagementAccountSlrExistsException(_inner) => _inner.fmt(f),
            Self::NotOrganizationMasterAccountException(_inner) => _inner.fmt(f),
            Self::OperationNotPermittedException(_inner) => _inner.fmt(f),
            Self::OrganizationNotInAllFeaturesModeException(_inner) => _inner.fmt(f),
            Self::OrganizationsNotInUseException(_inner) => _inner.fmt(f),
            Self::S3BucketDoesNotExistException(_inner) => _inner.fmt(f),
            Self::TagsLimitExceededException(_inner) => _inner.fmt(f),
            Self::ThrottlingException(_inner) => _inner.fmt(f),
            Self::TrailAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::TrailNotProvidedException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => {
                if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self) {
                    write!(f, "unhandled error ({code})")
                } else {
                    f.write_str("unhandled error")
                }
            }
        }
    }
}
impl ::aws_smithy_types::retry::ProvideErrorKind for CreateTrailError {
    fn code(&self) -> ::std::option::Option<&str> {
        ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> ::std::option::Option<::aws_smithy_types::retry::ErrorKind> {
        ::std::option::Option::None
    }
}
impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateTrailError {
    fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CloudTrailAccessNotEnabledException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::CloudTrailInvalidClientTokenIdException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::CloudWatchLogsDeliveryUnavailableException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::ConflictException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InsufficientDependencyServiceAccessPermissionException(_inner) => {
                ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InsufficientEncryptionPolicyException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InsufficientS3BucketPolicyException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InsufficientSnsTopicPolicyException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidCloudWatchLogsLogGroupArnException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidCloudWatchLogsRoleArnException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidKmsKeyIdException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidParameterCombinationException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidS3BucketNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidS3PrefixException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidSnsTopicNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidTagParameterException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidTrailNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::KmsException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::KmsKeyDisabledException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::KmsKeyNotFoundException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::MaximumNumberOfTrailsExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::NoManagementAccountSlrExistsException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::NotOrganizationMasterAccountException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::OperationNotPermittedException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::OrganizationNotInAllFeaturesModeException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::OrganizationsNotInUseException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::S3BucketDoesNotExistException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::TagsLimitExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::ThrottlingException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::TrailAlreadyExistsException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::TrailNotProvidedException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::UnsupportedOperationException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::Unhandled(_inner) => &_inner.meta,
        }
    }
}
impl ::aws_smithy_runtime_api::client::result::CreateUnhandledError for CreateTrailError {
    fn create_unhandled_error(
        source: ::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>,
        meta: ::std::option::Option<::aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source,
            meta: meta.unwrap_or_default(),
        })
    }
}
impl ::aws_types::request_id::RequestId for crate::operation::create_trail::CreateTrailError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}

pub use crate::operation::create_trail::_create_trail_output::CreateTrailOutput;

pub use crate::operation::create_trail::_create_trail_input::CreateTrailInput;

mod _create_trail_input;

mod _create_trail_output;

/// Builders
pub mod builders;
