// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `AddTags` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddTagsError {
    /// Kind of error that occurred.
    pub kind: AddTagsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `AddTags` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddTagsErrorKind {
    /// <p>This exception is thrown when an operation is called with a trail ARN that is not valid. The following is the format of a trail ARN.</p>
    /// <p>
    /// <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
    /// </p>
    CloudTrailArnInvalidException(crate::error::CloudTrailArnInvalidException),
    /// <p>This exception is thrown when the specified tag key or values are not valid.
    /// It can also occur if there are duplicate tags or too many tags on the resource.</p>
    InvalidTagParameterException(crate::error::InvalidTagParameterException),
    /// <p>This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    /// </li>
    /// <li>
    /// <p>Start with a letter or number, and end with a letter or number</p>
    /// </li>
    /// <li>
    /// <p>Be between 3 and 128 characters</p>
    /// </li>
    /// <li>
    /// <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    /// and <code>my--namespace</code> are not valid.</p>
    /// </li>
    /// <li>
    /// <p>Not be in IP address format (for example, 192.168.5.4)</p>
    /// </li>
    /// </ul>
    InvalidTrailNameException(crate::error::InvalidTrailNameException),
    /// <p>This exception is thrown when the Amazon Web Services account making the request to create or update an organization trail is not the management account for an
    /// organization in Organizations. For more information, see
    /// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
    NotOrganizationMasterAccountException(crate::error::NotOrganizationMasterAccountException),
    /// <p>This exception is thrown when the requested operation is not permitted.</p>
    OperationNotPermittedException(crate::error::OperationNotPermittedException),
    /// <p>This exception is thrown when the specified resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>This exception is thrown when the specified resource type is not supported by CloudTrail.</p>
    ResourceTypeNotSupportedException(crate::error::ResourceTypeNotSupportedException),
    /// <p>The number of tags per trail has exceeded the permitted amount. Currently, the limit is 50.</p>
    TagsLimitExceededException(crate::error::TagsLimitExceededException),
    /// <p>This exception is thrown when the requested operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddTagsErrorKind::CloudTrailArnInvalidException(_inner) => _inner.fmt(f),
            AddTagsErrorKind::InvalidTagParameterException(_inner) => _inner.fmt(f),
            AddTagsErrorKind::InvalidTrailNameException(_inner) => _inner.fmt(f),
            AddTagsErrorKind::NotOrganizationMasterAccountException(_inner) => _inner.fmt(f),
            AddTagsErrorKind::OperationNotPermittedException(_inner) => _inner.fmt(f),
            AddTagsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AddTagsErrorKind::ResourceTypeNotSupportedException(_inner) => _inner.fmt(f),
            AddTagsErrorKind::TagsLimitExceededException(_inner) => _inner.fmt(f),
            AddTagsErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            AddTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AddTagsError {
    fn code(&self) -> Option<&str> {
        AddTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddTagsError {
    /// Creates a new `AddTagsError`.
    pub fn new(kind: AddTagsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `AddTagsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `AddTagsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddTagsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `AddTagsErrorKind::CloudTrailArnInvalidException`.
    pub fn is_cloud_trail_arn_invalid_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsErrorKind::CloudTrailArnInvalidException(_)
        )
    }
    /// Returns true if the error kind is `AddTagsErrorKind::InvalidTagParameterException`.
    pub fn is_invalid_tag_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsErrorKind::InvalidTagParameterException(_)
        )
    }
    /// Returns true if the error kind is `AddTagsErrorKind::InvalidTrailNameException`.
    pub fn is_invalid_trail_name_exception(&self) -> bool {
        matches!(&self.kind, AddTagsErrorKind::InvalidTrailNameException(_))
    }
    /// Returns true if the error kind is `AddTagsErrorKind::NotOrganizationMasterAccountException`.
    pub fn is_not_organization_master_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsErrorKind::NotOrganizationMasterAccountException(_)
        )
    }
    /// Returns true if the error kind is `AddTagsErrorKind::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsErrorKind::OperationNotPermittedException(_)
        )
    }
    /// Returns true if the error kind is `AddTagsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, AddTagsErrorKind::ResourceNotFoundException(_))
    }
    /// Returns true if the error kind is `AddTagsErrorKind::ResourceTypeNotSupportedException`.
    pub fn is_resource_type_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsErrorKind::ResourceTypeNotSupportedException(_)
        )
    }
    /// Returns true if the error kind is `AddTagsErrorKind::TagsLimitExceededException`.
    pub fn is_tags_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, AddTagsErrorKind::TagsLimitExceededException(_))
    }
    /// Returns true if the error kind is `AddTagsErrorKind::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for AddTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddTagsErrorKind::CloudTrailArnInvalidException(_inner) => Some(_inner),
            AddTagsErrorKind::InvalidTagParameterException(_inner) => Some(_inner),
            AddTagsErrorKind::InvalidTrailNameException(_inner) => Some(_inner),
            AddTagsErrorKind::NotOrganizationMasterAccountException(_inner) => Some(_inner),
            AddTagsErrorKind::OperationNotPermittedException(_inner) => Some(_inner),
            AddTagsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AddTagsErrorKind::ResourceTypeNotSupportedException(_inner) => Some(_inner),
            AddTagsErrorKind::TagsLimitExceededException(_inner) => Some(_inner),
            AddTagsErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            AddTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateTrail` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTrailError {
    /// Kind of error that occurred.
    pub kind: CreateTrailErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateTrail` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTrailErrorKind {
    /// <p>This exception is thrown when trusted access has not been enabled between CloudTrail and Organizations. For more information,
    /// see <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_integrate_services.html">Enabling Trusted Access with Other Amazon Web Services Services</a>
    /// and <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>. </p>
    CloudTrailAccessNotEnabledException(crate::error::CloudTrailAccessNotEnabledException),
    /// <p>This exception is thrown when a call results in the <code>InvalidClientTokenId</code> error code.
    /// This can occur when you are creating or updating a trail to send notifications to an Amazon SNS topic that
    /// is in a suspended Amazon Web Services account.</p>
    CloudTrailInvalidClientTokenIdException(crate::error::CloudTrailInvalidClientTokenIdException),
    /// <p>Cannot set a CloudWatch Logs delivery for this region.</p>
    CloudWatchLogsDeliveryUnavailableException(
        crate::error::CloudWatchLogsDeliveryUnavailableException,
    ),
    /// <p>This exception is thrown when the IAM user or role that is used to create the organization trail is lacking one or more required permissions for
    /// creating an organization trail in a required service. For more information, see
    /// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
    InsufficientDependencyServiceAccessPermissionException(
        crate::error::InsufficientDependencyServiceAccessPermissionException,
    ),
    /// <p>This exception is thrown when the policy on the S3 bucket or KMS key is not sufficient.</p>
    InsufficientEncryptionPolicyException(crate::error::InsufficientEncryptionPolicyException),
    /// <p>This exception is thrown when the policy on the S3 bucket is not sufficient.</p>
    InsufficientS3BucketPolicyException(crate::error::InsufficientS3BucketPolicyException),
    /// <p>This exception is thrown when the policy on the Amazon SNS topic is not sufficient.</p>
    InsufficientSnsTopicPolicyException(crate::error::InsufficientSnsTopicPolicyException),
    /// <p>This exception is thrown when the provided CloudWatch Logs log group is not valid.</p>
    InvalidCloudWatchLogsLogGroupArnException(
        crate::error::InvalidCloudWatchLogsLogGroupArnException,
    ),
    /// <p>This exception is thrown when the provided role is not valid.</p>
    InvalidCloudWatchLogsRoleArnException(crate::error::InvalidCloudWatchLogsRoleArnException),
    /// <p>This exception is thrown when the KMS key ARN is not valid.</p>
    InvalidKmsKeyIdException(crate::error::InvalidKmsKeyIdException),
    /// <p>This exception is thrown when the combination of parameters provided is not valid.</p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p>This exception is thrown when the provided S3 bucket name is not valid.</p>
    InvalidS3BucketNameException(crate::error::InvalidS3BucketNameException),
    /// <p>This exception is thrown when the provided S3 prefix is not valid.</p>
    InvalidS3PrefixException(crate::error::InvalidS3PrefixException),
    /// <p>This exception is thrown when the provided SNS topic name is not valid.</p>
    InvalidSnsTopicNameException(crate::error::InvalidSnsTopicNameException),
    /// <p>This exception is thrown when the specified tag key or values are not valid.
    /// It can also occur if there are duplicate tags or too many tags on the resource.</p>
    InvalidTagParameterException(crate::error::InvalidTagParameterException),
    /// <p>This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    /// </li>
    /// <li>
    /// <p>Start with a letter or number, and end with a letter or number</p>
    /// </li>
    /// <li>
    /// <p>Be between 3 and 128 characters</p>
    /// </li>
    /// <li>
    /// <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    /// and <code>my--namespace</code> are not valid.</p>
    /// </li>
    /// <li>
    /// <p>Not be in IP address format (for example, 192.168.5.4)</p>
    /// </li>
    /// </ul>
    InvalidTrailNameException(crate::error::InvalidTrailNameException),
    /// <p>This exception is thrown when there is an issue with the specified KMS key and the trail can’t be updated.</p>
    KmsException(crate::error::KmsException),
    /// <p>This exception is no longer in use.</p>
    KmsKeyDisabledException(crate::error::KmsKeyDisabledException),
    /// <p>This exception is thrown when the KMS key does not exist, when the S3 bucket and the
    /// KMS key are not in the same region, or when the KMS key associated with the Amazon SNS
    /// topic either does not exist or is not in the same region.</p>
    KmsKeyNotFoundException(crate::error::KmsKeyNotFoundException),
    /// <p>This exception is thrown when the maximum number of trails is reached.</p>
    MaximumNumberOfTrailsExceededException(crate::error::MaximumNumberOfTrailsExceededException),
    /// <p>This exception is thrown when the Amazon Web Services account making the request to create or update an organization trail is not the management account for an
    /// organization in Organizations. For more information, see
    /// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
    NotOrganizationMasterAccountException(crate::error::NotOrganizationMasterAccountException),
    /// <p>This exception is thrown when the requested operation is not permitted.</p>
    OperationNotPermittedException(crate::error::OperationNotPermittedException),
    /// <p>This exception is thrown when Organizations is not configured to support all features. All features must be enabled in Organizations to support
    /// creating an organization trail. For more information, see
    /// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
    OrganizationNotInAllFeaturesModeException(
        crate::error::OrganizationNotInAllFeaturesModeException,
    ),
    /// <p>This exception is thrown when the request is made from an Amazon Web Services account that is not a member of an organization.
    /// To make this request, sign in using the credentials of an account that belongs to an organization.</p>
    OrganizationsNotInUseException(crate::error::OrganizationsNotInUseException),
    /// <p>This exception is thrown when the specified S3 bucket does not exist.</p>
    S3BucketDoesNotExistException(crate::error::S3BucketDoesNotExistException),
    /// <p>This exception is thrown when the specified trail already exists.</p>
    TrailAlreadyExistsException(crate::error::TrailAlreadyExistsException),
    /// <p>This exception is no longer in use.</p>
    TrailNotProvidedException(crate::error::TrailNotProvidedException),
    /// <p>This exception is thrown when the requested operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTrailError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTrailErrorKind::CloudTrailAccessNotEnabledException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::CloudTrailInvalidClientTokenIdException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::CloudWatchLogsDeliveryUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreateTrailErrorKind::InsufficientDependencyServiceAccessPermissionException(
                _inner,
            ) => _inner.fmt(f),
            CreateTrailErrorKind::InsufficientEncryptionPolicyException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::InsufficientS3BucketPolicyException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::InsufficientSnsTopicPolicyException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::InvalidCloudWatchLogsLogGroupArnException(_inner) => {
                _inner.fmt(f)
            }
            CreateTrailErrorKind::InvalidCloudWatchLogsRoleArnException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::InvalidKmsKeyIdException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::InvalidS3BucketNameException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::InvalidS3PrefixException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::InvalidSnsTopicNameException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::InvalidTagParameterException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::InvalidTrailNameException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::KmsException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::KmsKeyDisabledException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::KmsKeyNotFoundException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::MaximumNumberOfTrailsExceededException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::NotOrganizationMasterAccountException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::OperationNotPermittedException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::OrganizationNotInAllFeaturesModeException(_inner) => {
                _inner.fmt(f)
            }
            CreateTrailErrorKind::OrganizationsNotInUseException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::S3BucketDoesNotExistException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::TrailAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::TrailNotProvidedException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            CreateTrailErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateTrailError {
    fn code(&self) -> Option<&str> {
        CreateTrailError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTrailError {
    /// Creates a new `CreateTrailError`.
    pub fn new(kind: CreateTrailErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateTrailError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTrailErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateTrailError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTrailErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::CloudTrailAccessNotEnabledException`.
    pub fn is_cloud_trail_access_not_enabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::CloudTrailAccessNotEnabledException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::CloudTrailInvalidClientTokenIdException`.
    pub fn is_cloud_trail_invalid_client_token_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::CloudTrailInvalidClientTokenIdException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::CloudWatchLogsDeliveryUnavailableException`.
    pub fn is_cloud_watch_logs_delivery_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::CloudWatchLogsDeliveryUnavailableException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::InsufficientDependencyServiceAccessPermissionException`.
    pub fn is_insufficient_dependency_service_access_permission_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::InsufficientDependencyServiceAccessPermissionException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::InsufficientEncryptionPolicyException`.
    pub fn is_insufficient_encryption_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::InsufficientEncryptionPolicyException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::InsufficientS3BucketPolicyException`.
    pub fn is_insufficient_s3_bucket_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::InsufficientS3BucketPolicyException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::InsufficientSnsTopicPolicyException`.
    pub fn is_insufficient_sns_topic_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::InsufficientSnsTopicPolicyException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::InvalidCloudWatchLogsLogGroupArnException`.
    pub fn is_invalid_cloud_watch_logs_log_group_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::InvalidCloudWatchLogsLogGroupArnException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::InvalidCloudWatchLogsRoleArnException`.
    pub fn is_invalid_cloud_watch_logs_role_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::InvalidCloudWatchLogsRoleArnException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::InvalidKmsKeyIdException`.
    pub fn is_invalid_kms_key_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::InvalidKmsKeyIdException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::InvalidParameterCombinationException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::InvalidS3BucketNameException`.
    pub fn is_invalid_s3_bucket_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::InvalidS3BucketNameException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::InvalidS3PrefixException`.
    pub fn is_invalid_s3_prefix_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::InvalidS3PrefixException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::InvalidSnsTopicNameException`.
    pub fn is_invalid_sns_topic_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::InvalidSnsTopicNameException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::InvalidTagParameterException`.
    pub fn is_invalid_tag_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::InvalidTagParameterException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::InvalidTrailNameException`.
    pub fn is_invalid_trail_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::InvalidTrailNameException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::KmsException`.
    pub fn is_kms_exception(&self) -> bool {
        matches!(&self.kind, CreateTrailErrorKind::KmsException(_))
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::KmsKeyDisabledException`.
    pub fn is_kms_key_disabled_exception(&self) -> bool {
        matches!(&self.kind, CreateTrailErrorKind::KmsKeyDisabledException(_))
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::KmsKeyNotFoundException`.
    pub fn is_kms_key_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateTrailErrorKind::KmsKeyNotFoundException(_))
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::MaximumNumberOfTrailsExceededException`.
    pub fn is_maximum_number_of_trails_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::MaximumNumberOfTrailsExceededException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::NotOrganizationMasterAccountException`.
    pub fn is_not_organization_master_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::NotOrganizationMasterAccountException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::OperationNotPermittedException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::OrganizationNotInAllFeaturesModeException`.
    pub fn is_organization_not_in_all_features_mode_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::OrganizationNotInAllFeaturesModeException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::OrganizationsNotInUseException`.
    pub fn is_organizations_not_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::OrganizationsNotInUseException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::S3BucketDoesNotExistException`.
    pub fn is_s3_bucket_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::S3BucketDoesNotExistException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::TrailAlreadyExistsException`.
    pub fn is_trail_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::TrailAlreadyExistsException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::TrailNotProvidedException`.
    pub fn is_trail_not_provided_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::TrailNotProvidedException(_)
        )
    }
    /// Returns true if the error kind is `CreateTrailErrorKind::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTrailErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for CreateTrailError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTrailErrorKind::CloudTrailAccessNotEnabledException(_inner) => Some(_inner),
            CreateTrailErrorKind::CloudTrailInvalidClientTokenIdException(_inner) => Some(_inner),
            CreateTrailErrorKind::CloudWatchLogsDeliveryUnavailableException(_inner) => {
                Some(_inner)
            }
            CreateTrailErrorKind::InsufficientDependencyServiceAccessPermissionException(
                _inner,
            ) => Some(_inner),
            CreateTrailErrorKind::InsufficientEncryptionPolicyException(_inner) => Some(_inner),
            CreateTrailErrorKind::InsufficientS3BucketPolicyException(_inner) => Some(_inner),
            CreateTrailErrorKind::InsufficientSnsTopicPolicyException(_inner) => Some(_inner),
            CreateTrailErrorKind::InvalidCloudWatchLogsLogGroupArnException(_inner) => Some(_inner),
            CreateTrailErrorKind::InvalidCloudWatchLogsRoleArnException(_inner) => Some(_inner),
            CreateTrailErrorKind::InvalidKmsKeyIdException(_inner) => Some(_inner),
            CreateTrailErrorKind::InvalidParameterCombinationException(_inner) => Some(_inner),
            CreateTrailErrorKind::InvalidS3BucketNameException(_inner) => Some(_inner),
            CreateTrailErrorKind::InvalidS3PrefixException(_inner) => Some(_inner),
            CreateTrailErrorKind::InvalidSnsTopicNameException(_inner) => Some(_inner),
            CreateTrailErrorKind::InvalidTagParameterException(_inner) => Some(_inner),
            CreateTrailErrorKind::InvalidTrailNameException(_inner) => Some(_inner),
            CreateTrailErrorKind::KmsException(_inner) => Some(_inner),
            CreateTrailErrorKind::KmsKeyDisabledException(_inner) => Some(_inner),
            CreateTrailErrorKind::KmsKeyNotFoundException(_inner) => Some(_inner),
            CreateTrailErrorKind::MaximumNumberOfTrailsExceededException(_inner) => Some(_inner),
            CreateTrailErrorKind::NotOrganizationMasterAccountException(_inner) => Some(_inner),
            CreateTrailErrorKind::OperationNotPermittedException(_inner) => Some(_inner),
            CreateTrailErrorKind::OrganizationNotInAllFeaturesModeException(_inner) => Some(_inner),
            CreateTrailErrorKind::OrganizationsNotInUseException(_inner) => Some(_inner),
            CreateTrailErrorKind::S3BucketDoesNotExistException(_inner) => Some(_inner),
            CreateTrailErrorKind::TrailAlreadyExistsException(_inner) => Some(_inner),
            CreateTrailErrorKind::TrailNotProvidedException(_inner) => Some(_inner),
            CreateTrailErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            CreateTrailErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteTrail` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTrailError {
    /// Kind of error that occurred.
    pub kind: DeleteTrailErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteTrail` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTrailErrorKind {
    /// <p>This exception is thrown when the specified resource is not ready for an operation.
    /// This can occur when you try to run an operation on a trail before CloudTrail has time to fully load the trail.
    /// If this exception occurs, wait a few minutes, and then try the operation again.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>This exception is thrown when the IAM user or role that is used to create the organization trail is lacking one or more required permissions for
    /// creating an organization trail in a required service. For more information, see
    /// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
    InsufficientDependencyServiceAccessPermissionException(
        crate::error::InsufficientDependencyServiceAccessPermissionException,
    ),
    /// <p>This exception is thrown when an operation is called on a trail from a region other than the region in which the trail was created.</p>
    InvalidHomeRegionException(crate::error::InvalidHomeRegionException),
    /// <p>This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    /// </li>
    /// <li>
    /// <p>Start with a letter or number, and end with a letter or number</p>
    /// </li>
    /// <li>
    /// <p>Be between 3 and 128 characters</p>
    /// </li>
    /// <li>
    /// <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    /// and <code>my--namespace</code> are not valid.</p>
    /// </li>
    /// <li>
    /// <p>Not be in IP address format (for example, 192.168.5.4)</p>
    /// </li>
    /// </ul>
    InvalidTrailNameException(crate::error::InvalidTrailNameException),
    /// <p>This exception is thrown when the Amazon Web Services account making the request to create or update an organization trail is not the management account for an
    /// organization in Organizations. For more information, see
    /// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
    NotOrganizationMasterAccountException(crate::error::NotOrganizationMasterAccountException),
    /// <p>This exception is thrown when the requested operation is not permitted.</p>
    OperationNotPermittedException(crate::error::OperationNotPermittedException),
    /// <p>This exception is thrown when the trail with the given name is not found.</p>
    TrailNotFoundException(crate::error::TrailNotFoundException),
    /// <p>This exception is thrown when the requested operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTrailError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTrailErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteTrailErrorKind::InsufficientDependencyServiceAccessPermissionException(
                _inner,
            ) => _inner.fmt(f),
            DeleteTrailErrorKind::InvalidHomeRegionException(_inner) => _inner.fmt(f),
            DeleteTrailErrorKind::InvalidTrailNameException(_inner) => _inner.fmt(f),
            DeleteTrailErrorKind::NotOrganizationMasterAccountException(_inner) => _inner.fmt(f),
            DeleteTrailErrorKind::OperationNotPermittedException(_inner) => _inner.fmt(f),
            DeleteTrailErrorKind::TrailNotFoundException(_inner) => _inner.fmt(f),
            DeleteTrailErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            DeleteTrailErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteTrailError {
    fn code(&self) -> Option<&str> {
        DeleteTrailError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTrailError {
    /// Creates a new `DeleteTrailError`.
    pub fn new(kind: DeleteTrailErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteTrailError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTrailErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteTrailError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTrailErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `DeleteTrailErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteTrailErrorKind::ConflictException(_))
    }
    /// Returns true if the error kind is `DeleteTrailErrorKind::InsufficientDependencyServiceAccessPermissionException`.
    pub fn is_insufficient_dependency_service_access_permission_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTrailErrorKind::InsufficientDependencyServiceAccessPermissionException(_)
        )
    }
    /// Returns true if the error kind is `DeleteTrailErrorKind::InvalidHomeRegionException`.
    pub fn is_invalid_home_region_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTrailErrorKind::InvalidHomeRegionException(_)
        )
    }
    /// Returns true if the error kind is `DeleteTrailErrorKind::InvalidTrailNameException`.
    pub fn is_invalid_trail_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTrailErrorKind::InvalidTrailNameException(_)
        )
    }
    /// Returns true if the error kind is `DeleteTrailErrorKind::NotOrganizationMasterAccountException`.
    pub fn is_not_organization_master_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTrailErrorKind::NotOrganizationMasterAccountException(_)
        )
    }
    /// Returns true if the error kind is `DeleteTrailErrorKind::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTrailErrorKind::OperationNotPermittedException(_)
        )
    }
    /// Returns true if the error kind is `DeleteTrailErrorKind::TrailNotFoundException`.
    pub fn is_trail_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteTrailErrorKind::TrailNotFoundException(_))
    }
    /// Returns true if the error kind is `DeleteTrailErrorKind::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTrailErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for DeleteTrailError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTrailErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteTrailErrorKind::InsufficientDependencyServiceAccessPermissionException(
                _inner,
            ) => Some(_inner),
            DeleteTrailErrorKind::InvalidHomeRegionException(_inner) => Some(_inner),
            DeleteTrailErrorKind::InvalidTrailNameException(_inner) => Some(_inner),
            DeleteTrailErrorKind::NotOrganizationMasterAccountException(_inner) => Some(_inner),
            DeleteTrailErrorKind::OperationNotPermittedException(_inner) => Some(_inner),
            DeleteTrailErrorKind::TrailNotFoundException(_inner) => Some(_inner),
            DeleteTrailErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            DeleteTrailErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeTrails` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTrailsError {
    /// Kind of error that occurred.
    pub kind: DescribeTrailsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeTrails` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTrailsErrorKind {
    /// <p>This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    /// </li>
    /// <li>
    /// <p>Start with a letter or number, and end with a letter or number</p>
    /// </li>
    /// <li>
    /// <p>Be between 3 and 128 characters</p>
    /// </li>
    /// <li>
    /// <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    /// and <code>my--namespace</code> are not valid.</p>
    /// </li>
    /// <li>
    /// <p>Not be in IP address format (for example, 192.168.5.4)</p>
    /// </li>
    /// </ul>
    InvalidTrailNameException(crate::error::InvalidTrailNameException),
    /// <p>This exception is thrown when the requested operation is not permitted.</p>
    OperationNotPermittedException(crate::error::OperationNotPermittedException),
    /// <p>This exception is thrown when the requested operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTrailsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTrailsErrorKind::InvalidTrailNameException(_inner) => _inner.fmt(f),
            DescribeTrailsErrorKind::OperationNotPermittedException(_inner) => _inner.fmt(f),
            DescribeTrailsErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            DescribeTrailsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeTrailsError {
    fn code(&self) -> Option<&str> {
        DescribeTrailsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTrailsError {
    /// Creates a new `DescribeTrailsError`.
    pub fn new(kind: DescribeTrailsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeTrailsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTrailsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeTrailsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTrailsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `DescribeTrailsErrorKind::InvalidTrailNameException`.
    pub fn is_invalid_trail_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTrailsErrorKind::InvalidTrailNameException(_)
        )
    }
    /// Returns true if the error kind is `DescribeTrailsErrorKind::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTrailsErrorKind::OperationNotPermittedException(_)
        )
    }
    /// Returns true if the error kind is `DescribeTrailsErrorKind::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTrailsErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for DescribeTrailsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTrailsErrorKind::InvalidTrailNameException(_inner) => Some(_inner),
            DescribeTrailsErrorKind::OperationNotPermittedException(_inner) => Some(_inner),
            DescribeTrailsErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            DescribeTrailsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetEventSelectors` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEventSelectorsError {
    /// Kind of error that occurred.
    pub kind: GetEventSelectorsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetEventSelectors` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEventSelectorsErrorKind {
    /// <p>This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    /// </li>
    /// <li>
    /// <p>Start with a letter or number, and end with a letter or number</p>
    /// </li>
    /// <li>
    /// <p>Be between 3 and 128 characters</p>
    /// </li>
    /// <li>
    /// <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    /// and <code>my--namespace</code> are not valid.</p>
    /// </li>
    /// <li>
    /// <p>Not be in IP address format (for example, 192.168.5.4)</p>
    /// </li>
    /// </ul>
    InvalidTrailNameException(crate::error::InvalidTrailNameException),
    /// <p>This exception is thrown when the requested operation is not permitted.</p>
    OperationNotPermittedException(crate::error::OperationNotPermittedException),
    /// <p>This exception is thrown when the trail with the given name is not found.</p>
    TrailNotFoundException(crate::error::TrailNotFoundException),
    /// <p>This exception is thrown when the requested operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEventSelectorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEventSelectorsErrorKind::InvalidTrailNameException(_inner) => _inner.fmt(f),
            GetEventSelectorsErrorKind::OperationNotPermittedException(_inner) => _inner.fmt(f),
            GetEventSelectorsErrorKind::TrailNotFoundException(_inner) => _inner.fmt(f),
            GetEventSelectorsErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            GetEventSelectorsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetEventSelectorsError {
    fn code(&self) -> Option<&str> {
        GetEventSelectorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEventSelectorsError {
    /// Creates a new `GetEventSelectorsError`.
    pub fn new(kind: GetEventSelectorsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetEventSelectorsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEventSelectorsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetEventSelectorsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEventSelectorsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `GetEventSelectorsErrorKind::InvalidTrailNameException`.
    pub fn is_invalid_trail_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEventSelectorsErrorKind::InvalidTrailNameException(_)
        )
    }
    /// Returns true if the error kind is `GetEventSelectorsErrorKind::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEventSelectorsErrorKind::OperationNotPermittedException(_)
        )
    }
    /// Returns true if the error kind is `GetEventSelectorsErrorKind::TrailNotFoundException`.
    pub fn is_trail_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEventSelectorsErrorKind::TrailNotFoundException(_)
        )
    }
    /// Returns true if the error kind is `GetEventSelectorsErrorKind::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEventSelectorsErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for GetEventSelectorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEventSelectorsErrorKind::InvalidTrailNameException(_inner) => Some(_inner),
            GetEventSelectorsErrorKind::OperationNotPermittedException(_inner) => Some(_inner),
            GetEventSelectorsErrorKind::TrailNotFoundException(_inner) => Some(_inner),
            GetEventSelectorsErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            GetEventSelectorsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetInsightSelectors` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInsightSelectorsError {
    /// Kind of error that occurred.
    pub kind: GetInsightSelectorsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetInsightSelectors` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInsightSelectorsErrorKind {
    /// <p>If you run <code>GetInsightSelectors</code> on a trail that does not have Insights events enabled, the operation throws the exception <code>InsightNotEnabledException</code>.</p>
    InsightNotEnabledException(crate::error::InsightNotEnabledException),
    /// <p>This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    /// </li>
    /// <li>
    /// <p>Start with a letter or number, and end with a letter or number</p>
    /// </li>
    /// <li>
    /// <p>Be between 3 and 128 characters</p>
    /// </li>
    /// <li>
    /// <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    /// and <code>my--namespace</code> are not valid.</p>
    /// </li>
    /// <li>
    /// <p>Not be in IP address format (for example, 192.168.5.4)</p>
    /// </li>
    /// </ul>
    InvalidTrailNameException(crate::error::InvalidTrailNameException),
    /// <p>This exception is thrown when the requested operation is not permitted.</p>
    OperationNotPermittedException(crate::error::OperationNotPermittedException),
    /// <p>This exception is thrown when the trail with the given name is not found.</p>
    TrailNotFoundException(crate::error::TrailNotFoundException),
    /// <p>This exception is thrown when the requested operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetInsightSelectorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInsightSelectorsErrorKind::InsightNotEnabledException(_inner) => _inner.fmt(f),
            GetInsightSelectorsErrorKind::InvalidTrailNameException(_inner) => _inner.fmt(f),
            GetInsightSelectorsErrorKind::OperationNotPermittedException(_inner) => _inner.fmt(f),
            GetInsightSelectorsErrorKind::TrailNotFoundException(_inner) => _inner.fmt(f),
            GetInsightSelectorsErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            GetInsightSelectorsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetInsightSelectorsError {
    fn code(&self) -> Option<&str> {
        GetInsightSelectorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInsightSelectorsError {
    /// Creates a new `GetInsightSelectorsError`.
    pub fn new(kind: GetInsightSelectorsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetInsightSelectorsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetInsightSelectorsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetInsightSelectorsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetInsightSelectorsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `GetInsightSelectorsErrorKind::InsightNotEnabledException`.
    pub fn is_insight_not_enabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInsightSelectorsErrorKind::InsightNotEnabledException(_)
        )
    }
    /// Returns true if the error kind is `GetInsightSelectorsErrorKind::InvalidTrailNameException`.
    pub fn is_invalid_trail_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInsightSelectorsErrorKind::InvalidTrailNameException(_)
        )
    }
    /// Returns true if the error kind is `GetInsightSelectorsErrorKind::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInsightSelectorsErrorKind::OperationNotPermittedException(_)
        )
    }
    /// Returns true if the error kind is `GetInsightSelectorsErrorKind::TrailNotFoundException`.
    pub fn is_trail_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInsightSelectorsErrorKind::TrailNotFoundException(_)
        )
    }
    /// Returns true if the error kind is `GetInsightSelectorsErrorKind::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInsightSelectorsErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for GetInsightSelectorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInsightSelectorsErrorKind::InsightNotEnabledException(_inner) => Some(_inner),
            GetInsightSelectorsErrorKind::InvalidTrailNameException(_inner) => Some(_inner),
            GetInsightSelectorsErrorKind::OperationNotPermittedException(_inner) => Some(_inner),
            GetInsightSelectorsErrorKind::TrailNotFoundException(_inner) => Some(_inner),
            GetInsightSelectorsErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            GetInsightSelectorsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetTrail` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTrailError {
    /// Kind of error that occurred.
    pub kind: GetTrailErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetTrail` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTrailErrorKind {
    /// <p>This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    /// </li>
    /// <li>
    /// <p>Start with a letter or number, and end with a letter or number</p>
    /// </li>
    /// <li>
    /// <p>Be between 3 and 128 characters</p>
    /// </li>
    /// <li>
    /// <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    /// and <code>my--namespace</code> are not valid.</p>
    /// </li>
    /// <li>
    /// <p>Not be in IP address format (for example, 192.168.5.4)</p>
    /// </li>
    /// </ul>
    InvalidTrailNameException(crate::error::InvalidTrailNameException),
    /// <p>This exception is thrown when the requested operation is not permitted.</p>
    OperationNotPermittedException(crate::error::OperationNotPermittedException),
    /// <p>This exception is thrown when the trail with the given name is not found.</p>
    TrailNotFoundException(crate::error::TrailNotFoundException),
    /// <p>This exception is thrown when the requested operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTrailError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTrailErrorKind::InvalidTrailNameException(_inner) => _inner.fmt(f),
            GetTrailErrorKind::OperationNotPermittedException(_inner) => _inner.fmt(f),
            GetTrailErrorKind::TrailNotFoundException(_inner) => _inner.fmt(f),
            GetTrailErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            GetTrailErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetTrailError {
    fn code(&self) -> Option<&str> {
        GetTrailError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTrailError {
    /// Creates a new `GetTrailError`.
    pub fn new(kind: GetTrailErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetTrailError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTrailErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetTrailError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTrailErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `GetTrailErrorKind::InvalidTrailNameException`.
    pub fn is_invalid_trail_name_exception(&self) -> bool {
        matches!(&self.kind, GetTrailErrorKind::InvalidTrailNameException(_))
    }
    /// Returns true if the error kind is `GetTrailErrorKind::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTrailErrorKind::OperationNotPermittedException(_)
        )
    }
    /// Returns true if the error kind is `GetTrailErrorKind::TrailNotFoundException`.
    pub fn is_trail_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetTrailErrorKind::TrailNotFoundException(_))
    }
    /// Returns true if the error kind is `GetTrailErrorKind::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTrailErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for GetTrailError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTrailErrorKind::InvalidTrailNameException(_inner) => Some(_inner),
            GetTrailErrorKind::OperationNotPermittedException(_inner) => Some(_inner),
            GetTrailErrorKind::TrailNotFoundException(_inner) => Some(_inner),
            GetTrailErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            GetTrailErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetTrailStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTrailStatusError {
    /// Kind of error that occurred.
    pub kind: GetTrailStatusErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetTrailStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTrailStatusErrorKind {
    /// <p>This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    /// </li>
    /// <li>
    /// <p>Start with a letter or number, and end with a letter or number</p>
    /// </li>
    /// <li>
    /// <p>Be between 3 and 128 characters</p>
    /// </li>
    /// <li>
    /// <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    /// and <code>my--namespace</code> are not valid.</p>
    /// </li>
    /// <li>
    /// <p>Not be in IP address format (for example, 192.168.5.4)</p>
    /// </li>
    /// </ul>
    InvalidTrailNameException(crate::error::InvalidTrailNameException),
    /// <p>This exception is thrown when the requested operation is not permitted.</p>
    OperationNotPermittedException(crate::error::OperationNotPermittedException),
    /// <p>This exception is thrown when the trail with the given name is not found.</p>
    TrailNotFoundException(crate::error::TrailNotFoundException),
    /// <p>This exception is thrown when the requested operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTrailStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTrailStatusErrorKind::InvalidTrailNameException(_inner) => _inner.fmt(f),
            GetTrailStatusErrorKind::OperationNotPermittedException(_inner) => _inner.fmt(f),
            GetTrailStatusErrorKind::TrailNotFoundException(_inner) => _inner.fmt(f),
            GetTrailStatusErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            GetTrailStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetTrailStatusError {
    fn code(&self) -> Option<&str> {
        GetTrailStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTrailStatusError {
    /// Creates a new `GetTrailStatusError`.
    pub fn new(kind: GetTrailStatusErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetTrailStatusError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTrailStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetTrailStatusError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTrailStatusErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `GetTrailStatusErrorKind::InvalidTrailNameException`.
    pub fn is_invalid_trail_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTrailStatusErrorKind::InvalidTrailNameException(_)
        )
    }
    /// Returns true if the error kind is `GetTrailStatusErrorKind::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTrailStatusErrorKind::OperationNotPermittedException(_)
        )
    }
    /// Returns true if the error kind is `GetTrailStatusErrorKind::TrailNotFoundException`.
    pub fn is_trail_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTrailStatusErrorKind::TrailNotFoundException(_)
        )
    }
    /// Returns true if the error kind is `GetTrailStatusErrorKind::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTrailStatusErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for GetTrailStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTrailStatusErrorKind::InvalidTrailNameException(_inner) => Some(_inner),
            GetTrailStatusErrorKind::OperationNotPermittedException(_inner) => Some(_inner),
            GetTrailStatusErrorKind::TrailNotFoundException(_inner) => Some(_inner),
            GetTrailStatusErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            GetTrailStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListPublicKeys` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPublicKeysError {
    /// Kind of error that occurred.
    pub kind: ListPublicKeysErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListPublicKeys` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPublicKeysErrorKind {
    /// <p>Occurs if the timestamp values are not valid. Either the start time occurs after the end time, or the time range is outside the range of possible values.</p>
    InvalidTimeRangeException(crate::error::InvalidTimeRangeException),
    /// <p>Reserved for future use.</p>
    InvalidTokenException(crate::error::InvalidTokenException),
    /// <p>This exception is thrown when the requested operation is not permitted.</p>
    OperationNotPermittedException(crate::error::OperationNotPermittedException),
    /// <p>This exception is thrown when the requested operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPublicKeysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPublicKeysErrorKind::InvalidTimeRangeException(_inner) => _inner.fmt(f),
            ListPublicKeysErrorKind::InvalidTokenException(_inner) => _inner.fmt(f),
            ListPublicKeysErrorKind::OperationNotPermittedException(_inner) => _inner.fmt(f),
            ListPublicKeysErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            ListPublicKeysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListPublicKeysError {
    fn code(&self) -> Option<&str> {
        ListPublicKeysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPublicKeysError {
    /// Creates a new `ListPublicKeysError`.
    pub fn new(kind: ListPublicKeysErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListPublicKeysError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPublicKeysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListPublicKeysError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPublicKeysErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `ListPublicKeysErrorKind::InvalidTimeRangeException`.
    pub fn is_invalid_time_range_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPublicKeysErrorKind::InvalidTimeRangeException(_)
        )
    }
    /// Returns true if the error kind is `ListPublicKeysErrorKind::InvalidTokenException`.
    pub fn is_invalid_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPublicKeysErrorKind::InvalidTokenException(_)
        )
    }
    /// Returns true if the error kind is `ListPublicKeysErrorKind::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPublicKeysErrorKind::OperationNotPermittedException(_)
        )
    }
    /// Returns true if the error kind is `ListPublicKeysErrorKind::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPublicKeysErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for ListPublicKeysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPublicKeysErrorKind::InvalidTimeRangeException(_inner) => Some(_inner),
            ListPublicKeysErrorKind::InvalidTokenException(_inner) => Some(_inner),
            ListPublicKeysErrorKind::OperationNotPermittedException(_inner) => Some(_inner),
            ListPublicKeysErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            ListPublicKeysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListTags` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsError {
    /// Kind of error that occurred.
    pub kind: ListTagsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListTags` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsErrorKind {
    /// <p>This exception is thrown when an operation is called with a trail ARN that is not valid. The following is the format of a trail ARN.</p>
    /// <p>
    /// <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
    /// </p>
    CloudTrailArnInvalidException(crate::error::CloudTrailArnInvalidException),
    /// <p>Reserved for future use.</p>
    InvalidTokenException(crate::error::InvalidTokenException),
    /// <p>This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    /// </li>
    /// <li>
    /// <p>Start with a letter or number, and end with a letter or number</p>
    /// </li>
    /// <li>
    /// <p>Be between 3 and 128 characters</p>
    /// </li>
    /// <li>
    /// <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    /// and <code>my--namespace</code> are not valid.</p>
    /// </li>
    /// <li>
    /// <p>Not be in IP address format (for example, 192.168.5.4)</p>
    /// </li>
    /// </ul>
    InvalidTrailNameException(crate::error::InvalidTrailNameException),
    /// <p>This exception is thrown when the requested operation is not permitted.</p>
    OperationNotPermittedException(crate::error::OperationNotPermittedException),
    /// <p>This exception is thrown when the specified resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>This exception is thrown when the specified resource type is not supported by CloudTrail.</p>
    ResourceTypeNotSupportedException(crate::error::ResourceTypeNotSupportedException),
    /// <p>This exception is thrown when the requested operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsErrorKind::CloudTrailArnInvalidException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::InvalidTokenException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::InvalidTrailNameException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::OperationNotPermittedException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::ResourceTypeNotSupportedException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsError {
    fn code(&self) -> Option<&str> {
        ListTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsError {
    /// Creates a new `ListTagsError`.
    pub fn new(kind: ListTagsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListTagsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListTagsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `ListTagsErrorKind::CloudTrailArnInvalidException`.
    pub fn is_cloud_trail_arn_invalid_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsErrorKind::CloudTrailArnInvalidException(_)
        )
    }
    /// Returns true if the error kind is `ListTagsErrorKind::InvalidTokenException`.
    pub fn is_invalid_token_exception(&self) -> bool {
        matches!(&self.kind, ListTagsErrorKind::InvalidTokenException(_))
    }
    /// Returns true if the error kind is `ListTagsErrorKind::InvalidTrailNameException`.
    pub fn is_invalid_trail_name_exception(&self) -> bool {
        matches!(&self.kind, ListTagsErrorKind::InvalidTrailNameException(_))
    }
    /// Returns true if the error kind is `ListTagsErrorKind::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsErrorKind::OperationNotPermittedException(_)
        )
    }
    /// Returns true if the error kind is `ListTagsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListTagsErrorKind::ResourceNotFoundException(_))
    }
    /// Returns true if the error kind is `ListTagsErrorKind::ResourceTypeNotSupportedException`.
    pub fn is_resource_type_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsErrorKind::ResourceTypeNotSupportedException(_)
        )
    }
    /// Returns true if the error kind is `ListTagsErrorKind::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for ListTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsErrorKind::CloudTrailArnInvalidException(_inner) => Some(_inner),
            ListTagsErrorKind::InvalidTokenException(_inner) => Some(_inner),
            ListTagsErrorKind::InvalidTrailNameException(_inner) => Some(_inner),
            ListTagsErrorKind::OperationNotPermittedException(_inner) => Some(_inner),
            ListTagsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsErrorKind::ResourceTypeNotSupportedException(_inner) => Some(_inner),
            ListTagsErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            ListTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListTrails` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTrailsError {
    /// Kind of error that occurred.
    pub kind: ListTrailsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListTrails` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTrailsErrorKind {
    /// <p>This exception is thrown when the requested operation is not permitted.</p>
    OperationNotPermittedException(crate::error::OperationNotPermittedException),
    /// <p>This exception is thrown when the requested operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTrailsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTrailsErrorKind::OperationNotPermittedException(_inner) => _inner.fmt(f),
            ListTrailsErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            ListTrailsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTrailsError {
    fn code(&self) -> Option<&str> {
        ListTrailsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTrailsError {
    /// Creates a new `ListTrailsError`.
    pub fn new(kind: ListTrailsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListTrailsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTrailsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListTrailsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTrailsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `ListTrailsErrorKind::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTrailsErrorKind::OperationNotPermittedException(_)
        )
    }
    /// Returns true if the error kind is `ListTrailsErrorKind::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTrailsErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for ListTrailsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTrailsErrorKind::OperationNotPermittedException(_inner) => Some(_inner),
            ListTrailsErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            ListTrailsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `LookupEvents` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct LookupEventsError {
    /// Kind of error that occurred.
    pub kind: LookupEventsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `LookupEvents` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum LookupEventsErrorKind {
    /// <p>Occurs if an event category that is not valid is specified as a value of <code>EventCategory</code>.</p>
    InvalidEventCategoryException(crate::error::InvalidEventCategoryException),
    /// <p>Occurs when a lookup attribute is specified that is not valid.</p>
    InvalidLookupAttributesException(crate::error::InvalidLookupAttributesException),
    /// <p>This exception is thrown if the limit specified is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// <p>A token that is not valid, or a token that was previously used in a request with different parameters. This exception is thrown if the token is not valid.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>Occurs if the timestamp values are not valid. Either the start time occurs after the end time, or the time range is outside the range of possible values.</p>
    InvalidTimeRangeException(crate::error::InvalidTimeRangeException),
    /// <p>This exception is thrown when the requested operation is not permitted.</p>
    OperationNotPermittedException(crate::error::OperationNotPermittedException),
    /// <p>This exception is thrown when the requested operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for LookupEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            LookupEventsErrorKind::InvalidEventCategoryException(_inner) => _inner.fmt(f),
            LookupEventsErrorKind::InvalidLookupAttributesException(_inner) => _inner.fmt(f),
            LookupEventsErrorKind::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            LookupEventsErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            LookupEventsErrorKind::InvalidTimeRangeException(_inner) => _inner.fmt(f),
            LookupEventsErrorKind::OperationNotPermittedException(_inner) => _inner.fmt(f),
            LookupEventsErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            LookupEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for LookupEventsError {
    fn code(&self) -> Option<&str> {
        LookupEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl LookupEventsError {
    /// Creates a new `LookupEventsError`.
    pub fn new(kind: LookupEventsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `LookupEventsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: LookupEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `LookupEventsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: LookupEventsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `LookupEventsErrorKind::InvalidEventCategoryException`.
    pub fn is_invalid_event_category_exception(&self) -> bool {
        matches!(
            &self.kind,
            LookupEventsErrorKind::InvalidEventCategoryException(_)
        )
    }
    /// Returns true if the error kind is `LookupEventsErrorKind::InvalidLookupAttributesException`.
    pub fn is_invalid_lookup_attributes_exception(&self) -> bool {
        matches!(
            &self.kind,
            LookupEventsErrorKind::InvalidLookupAttributesException(_)
        )
    }
    /// Returns true if the error kind is `LookupEventsErrorKind::InvalidMaxResultsException`.
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(
            &self.kind,
            LookupEventsErrorKind::InvalidMaxResultsException(_)
        )
    }
    /// Returns true if the error kind is `LookupEventsErrorKind::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            LookupEventsErrorKind::InvalidNextTokenException(_)
        )
    }
    /// Returns true if the error kind is `LookupEventsErrorKind::InvalidTimeRangeException`.
    pub fn is_invalid_time_range_exception(&self) -> bool {
        matches!(
            &self.kind,
            LookupEventsErrorKind::InvalidTimeRangeException(_)
        )
    }
    /// Returns true if the error kind is `LookupEventsErrorKind::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(
            &self.kind,
            LookupEventsErrorKind::OperationNotPermittedException(_)
        )
    }
    /// Returns true if the error kind is `LookupEventsErrorKind::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            LookupEventsErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for LookupEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            LookupEventsErrorKind::InvalidEventCategoryException(_inner) => Some(_inner),
            LookupEventsErrorKind::InvalidLookupAttributesException(_inner) => Some(_inner),
            LookupEventsErrorKind::InvalidMaxResultsException(_inner) => Some(_inner),
            LookupEventsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            LookupEventsErrorKind::InvalidTimeRangeException(_inner) => Some(_inner),
            LookupEventsErrorKind::OperationNotPermittedException(_inner) => Some(_inner),
            LookupEventsErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            LookupEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `PutEventSelectors` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutEventSelectorsError {
    /// Kind of error that occurred.
    pub kind: PutEventSelectorsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `PutEventSelectors` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutEventSelectorsErrorKind {
    /// <p>This exception is thrown when the IAM user or role that is used to create the organization trail is lacking one or more required permissions for
    /// creating an organization trail in a required service. For more information, see
    /// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
    InsufficientDependencyServiceAccessPermissionException(
        crate::error::InsufficientDependencyServiceAccessPermissionException,
    ),
    /// <p>This exception is thrown when the <code>PutEventSelectors</code> operation is called with a number of event
    /// selectors, advanced event selectors, or data resources that is not valid. The combination of event selectors or advanced event selectors and
    /// data resources is not valid. A trail can have up to 5 event selectors. If a trail uses advanced event selectors, a maximum
    /// of 500 total values for all conditions in all advanced event selectors is allowed. A trail is limited to 250 data resources. These data resources can be distributed across event selectors, but the overall total cannot exceed 250.</p>
    /// <p>You can:</p>
    /// <ul>
    /// <li>
    /// <p>Specify a valid number of event selectors (1 to 5) for a trail.</p>
    /// </li>
    /// <li>
    /// <p>Specify a valid number of data resources (1 to 250) for an event selector.
    /// The limit of number of resources on an individual event selector is configurable up to 250.
    /// However, this upper limit is allowed only if the total number of data resources does not
    /// exceed 250 across all event selectors for a trail.</p>
    /// </li>
    /// <li>
    /// <p>Specify up to 500 values for all conditions in all advanced event selectors for a trail.</p>
    /// </li>
    /// <li>
    /// <p>Specify a valid value for a parameter. For example, specifying the <code>ReadWriteType</code>
    /// parameter with a value of <code>read-only</code> is not valid.</p>
    /// </li>
    /// </ul>
    InvalidEventSelectorsException(crate::error::InvalidEventSelectorsException),
    /// <p>This exception is thrown when an operation is called on a trail from a region other than the region in which the trail was created.</p>
    InvalidHomeRegionException(crate::error::InvalidHomeRegionException),
    /// <p>This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    /// </li>
    /// <li>
    /// <p>Start with a letter or number, and end with a letter or number</p>
    /// </li>
    /// <li>
    /// <p>Be between 3 and 128 characters</p>
    /// </li>
    /// <li>
    /// <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    /// and <code>my--namespace</code> are not valid.</p>
    /// </li>
    /// <li>
    /// <p>Not be in IP address format (for example, 192.168.5.4)</p>
    /// </li>
    /// </ul>
    InvalidTrailNameException(crate::error::InvalidTrailNameException),
    /// <p>This exception is thrown when the Amazon Web Services account making the request to create or update an organization trail is not the management account for an
    /// organization in Organizations. For more information, see
    /// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
    NotOrganizationMasterAccountException(crate::error::NotOrganizationMasterAccountException),
    /// <p>This exception is thrown when the requested operation is not permitted.</p>
    OperationNotPermittedException(crate::error::OperationNotPermittedException),
    /// <p>This exception is thrown when the trail with the given name is not found.</p>
    TrailNotFoundException(crate::error::TrailNotFoundException),
    /// <p>This exception is thrown when the requested operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutEventSelectorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutEventSelectorsErrorKind::InsufficientDependencyServiceAccessPermissionException(
                _inner,
            ) => _inner.fmt(f),
            PutEventSelectorsErrorKind::InvalidEventSelectorsException(_inner) => _inner.fmt(f),
            PutEventSelectorsErrorKind::InvalidHomeRegionException(_inner) => _inner.fmt(f),
            PutEventSelectorsErrorKind::InvalidTrailNameException(_inner) => _inner.fmt(f),
            PutEventSelectorsErrorKind::NotOrganizationMasterAccountException(_inner) => {
                _inner.fmt(f)
            }
            PutEventSelectorsErrorKind::OperationNotPermittedException(_inner) => _inner.fmt(f),
            PutEventSelectorsErrorKind::TrailNotFoundException(_inner) => _inner.fmt(f),
            PutEventSelectorsErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            PutEventSelectorsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutEventSelectorsError {
    fn code(&self) -> Option<&str> {
        PutEventSelectorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutEventSelectorsError {
    /// Creates a new `PutEventSelectorsError`.
    pub fn new(kind: PutEventSelectorsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PutEventSelectorsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutEventSelectorsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `PutEventSelectorsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutEventSelectorsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `PutEventSelectorsErrorKind::InsufficientDependencyServiceAccessPermissionException`.
    pub fn is_insufficient_dependency_service_access_permission_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventSelectorsErrorKind::InsufficientDependencyServiceAccessPermissionException(_)
        )
    }
    /// Returns true if the error kind is `PutEventSelectorsErrorKind::InvalidEventSelectorsException`.
    pub fn is_invalid_event_selectors_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventSelectorsErrorKind::InvalidEventSelectorsException(_)
        )
    }
    /// Returns true if the error kind is `PutEventSelectorsErrorKind::InvalidHomeRegionException`.
    pub fn is_invalid_home_region_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventSelectorsErrorKind::InvalidHomeRegionException(_)
        )
    }
    /// Returns true if the error kind is `PutEventSelectorsErrorKind::InvalidTrailNameException`.
    pub fn is_invalid_trail_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventSelectorsErrorKind::InvalidTrailNameException(_)
        )
    }
    /// Returns true if the error kind is `PutEventSelectorsErrorKind::NotOrganizationMasterAccountException`.
    pub fn is_not_organization_master_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventSelectorsErrorKind::NotOrganizationMasterAccountException(_)
        )
    }
    /// Returns true if the error kind is `PutEventSelectorsErrorKind::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventSelectorsErrorKind::OperationNotPermittedException(_)
        )
    }
    /// Returns true if the error kind is `PutEventSelectorsErrorKind::TrailNotFoundException`.
    pub fn is_trail_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventSelectorsErrorKind::TrailNotFoundException(_)
        )
    }
    /// Returns true if the error kind is `PutEventSelectorsErrorKind::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventSelectorsErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for PutEventSelectorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutEventSelectorsErrorKind::InsufficientDependencyServiceAccessPermissionException(
                _inner,
            ) => Some(_inner),
            PutEventSelectorsErrorKind::InvalidEventSelectorsException(_inner) => Some(_inner),
            PutEventSelectorsErrorKind::InvalidHomeRegionException(_inner) => Some(_inner),
            PutEventSelectorsErrorKind::InvalidTrailNameException(_inner) => Some(_inner),
            PutEventSelectorsErrorKind::NotOrganizationMasterAccountException(_inner) => {
                Some(_inner)
            }
            PutEventSelectorsErrorKind::OperationNotPermittedException(_inner) => Some(_inner),
            PutEventSelectorsErrorKind::TrailNotFoundException(_inner) => Some(_inner),
            PutEventSelectorsErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            PutEventSelectorsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `PutInsightSelectors` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutInsightSelectorsError {
    /// Kind of error that occurred.
    pub kind: PutInsightSelectorsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `PutInsightSelectors` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutInsightSelectorsErrorKind {
    /// <p>This exception is thrown when the policy on the S3 bucket or KMS key is not sufficient.</p>
    InsufficientEncryptionPolicyException(crate::error::InsufficientEncryptionPolicyException),
    /// <p>This exception is thrown when the policy on the S3 bucket is not sufficient.</p>
    InsufficientS3BucketPolicyException(crate::error::InsufficientS3BucketPolicyException),
    /// <p>This exception is thrown when an operation is called on a trail from a region other than the region in which the trail was created.</p>
    InvalidHomeRegionException(crate::error::InvalidHomeRegionException),
    /// <p>The formatting or syntax of the <code>InsightSelectors</code> JSON statement in your <code>PutInsightSelectors</code> or <code>GetInsightSelectors</code> request
    /// is not valid, or the specified insight type in the <code>InsightSelectors</code> statement is not a valid insight type.</p>
    InvalidInsightSelectorsException(crate::error::InvalidInsightSelectorsException),
    /// <p>This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    /// </li>
    /// <li>
    /// <p>Start with a letter or number, and end with a letter or number</p>
    /// </li>
    /// <li>
    /// <p>Be between 3 and 128 characters</p>
    /// </li>
    /// <li>
    /// <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    /// and <code>my--namespace</code> are not valid.</p>
    /// </li>
    /// <li>
    /// <p>Not be in IP address format (for example, 192.168.5.4)</p>
    /// </li>
    /// </ul>
    InvalidTrailNameException(crate::error::InvalidTrailNameException),
    /// <p>This exception is thrown when there is an issue with the specified KMS key and the trail can’t be updated.</p>
    KmsException(crate::error::KmsException),
    /// <p>This exception is thrown when the Amazon Web Services account making the request to create or update an organization trail is not the management account for an
    /// organization in Organizations. For more information, see
    /// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
    NotOrganizationMasterAccountException(crate::error::NotOrganizationMasterAccountException),
    /// <p>This exception is thrown when the requested operation is not permitted.</p>
    OperationNotPermittedException(crate::error::OperationNotPermittedException),
    /// <p>This exception is thrown when the specified S3 bucket does not exist.</p>
    S3BucketDoesNotExistException(crate::error::S3BucketDoesNotExistException),
    /// <p>This exception is thrown when the trail with the given name is not found.</p>
    TrailNotFoundException(crate::error::TrailNotFoundException),
    /// <p>This exception is thrown when the requested operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutInsightSelectorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutInsightSelectorsErrorKind::InsufficientEncryptionPolicyException(_inner) => {
                _inner.fmt(f)
            }
            PutInsightSelectorsErrorKind::InsufficientS3BucketPolicyException(_inner) => {
                _inner.fmt(f)
            }
            PutInsightSelectorsErrorKind::InvalidHomeRegionException(_inner) => _inner.fmt(f),
            PutInsightSelectorsErrorKind::InvalidInsightSelectorsException(_inner) => _inner.fmt(f),
            PutInsightSelectorsErrorKind::InvalidTrailNameException(_inner) => _inner.fmt(f),
            PutInsightSelectorsErrorKind::KmsException(_inner) => _inner.fmt(f),
            PutInsightSelectorsErrorKind::NotOrganizationMasterAccountException(_inner) => {
                _inner.fmt(f)
            }
            PutInsightSelectorsErrorKind::OperationNotPermittedException(_inner) => _inner.fmt(f),
            PutInsightSelectorsErrorKind::S3BucketDoesNotExistException(_inner) => _inner.fmt(f),
            PutInsightSelectorsErrorKind::TrailNotFoundException(_inner) => _inner.fmt(f),
            PutInsightSelectorsErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            PutInsightSelectorsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutInsightSelectorsError {
    fn code(&self) -> Option<&str> {
        PutInsightSelectorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutInsightSelectorsError {
    /// Creates a new `PutInsightSelectorsError`.
    pub fn new(kind: PutInsightSelectorsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PutInsightSelectorsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutInsightSelectorsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `PutInsightSelectorsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutInsightSelectorsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `PutInsightSelectorsErrorKind::InsufficientEncryptionPolicyException`.
    pub fn is_insufficient_encryption_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutInsightSelectorsErrorKind::InsufficientEncryptionPolicyException(_)
        )
    }
    /// Returns true if the error kind is `PutInsightSelectorsErrorKind::InsufficientS3BucketPolicyException`.
    pub fn is_insufficient_s3_bucket_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutInsightSelectorsErrorKind::InsufficientS3BucketPolicyException(_)
        )
    }
    /// Returns true if the error kind is `PutInsightSelectorsErrorKind::InvalidHomeRegionException`.
    pub fn is_invalid_home_region_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutInsightSelectorsErrorKind::InvalidHomeRegionException(_)
        )
    }
    /// Returns true if the error kind is `PutInsightSelectorsErrorKind::InvalidInsightSelectorsException`.
    pub fn is_invalid_insight_selectors_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutInsightSelectorsErrorKind::InvalidInsightSelectorsException(_)
        )
    }
    /// Returns true if the error kind is `PutInsightSelectorsErrorKind::InvalidTrailNameException`.
    pub fn is_invalid_trail_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutInsightSelectorsErrorKind::InvalidTrailNameException(_)
        )
    }
    /// Returns true if the error kind is `PutInsightSelectorsErrorKind::KmsException`.
    pub fn is_kms_exception(&self) -> bool {
        matches!(&self.kind, PutInsightSelectorsErrorKind::KmsException(_))
    }
    /// Returns true if the error kind is `PutInsightSelectorsErrorKind::NotOrganizationMasterAccountException`.
    pub fn is_not_organization_master_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutInsightSelectorsErrorKind::NotOrganizationMasterAccountException(_)
        )
    }
    /// Returns true if the error kind is `PutInsightSelectorsErrorKind::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutInsightSelectorsErrorKind::OperationNotPermittedException(_)
        )
    }
    /// Returns true if the error kind is `PutInsightSelectorsErrorKind::S3BucketDoesNotExistException`.
    pub fn is_s3_bucket_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutInsightSelectorsErrorKind::S3BucketDoesNotExistException(_)
        )
    }
    /// Returns true if the error kind is `PutInsightSelectorsErrorKind::TrailNotFoundException`.
    pub fn is_trail_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutInsightSelectorsErrorKind::TrailNotFoundException(_)
        )
    }
    /// Returns true if the error kind is `PutInsightSelectorsErrorKind::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutInsightSelectorsErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for PutInsightSelectorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutInsightSelectorsErrorKind::InsufficientEncryptionPolicyException(_inner) => {
                Some(_inner)
            }
            PutInsightSelectorsErrorKind::InsufficientS3BucketPolicyException(_inner) => {
                Some(_inner)
            }
            PutInsightSelectorsErrorKind::InvalidHomeRegionException(_inner) => Some(_inner),
            PutInsightSelectorsErrorKind::InvalidInsightSelectorsException(_inner) => Some(_inner),
            PutInsightSelectorsErrorKind::InvalidTrailNameException(_inner) => Some(_inner),
            PutInsightSelectorsErrorKind::KmsException(_inner) => Some(_inner),
            PutInsightSelectorsErrorKind::NotOrganizationMasterAccountException(_inner) => {
                Some(_inner)
            }
            PutInsightSelectorsErrorKind::OperationNotPermittedException(_inner) => Some(_inner),
            PutInsightSelectorsErrorKind::S3BucketDoesNotExistException(_inner) => Some(_inner),
            PutInsightSelectorsErrorKind::TrailNotFoundException(_inner) => Some(_inner),
            PutInsightSelectorsErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            PutInsightSelectorsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `RemoveTags` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveTagsError {
    /// Kind of error that occurred.
    pub kind: RemoveTagsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `RemoveTags` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveTagsErrorKind {
    /// <p>This exception is thrown when an operation is called with a trail ARN that is not valid. The following is the format of a trail ARN.</p>
    /// <p>
    /// <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
    /// </p>
    CloudTrailArnInvalidException(crate::error::CloudTrailArnInvalidException),
    /// <p>This exception is thrown when the specified tag key or values are not valid.
    /// It can also occur if there are duplicate tags or too many tags on the resource.</p>
    InvalidTagParameterException(crate::error::InvalidTagParameterException),
    /// <p>This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    /// </li>
    /// <li>
    /// <p>Start with a letter or number, and end with a letter or number</p>
    /// </li>
    /// <li>
    /// <p>Be between 3 and 128 characters</p>
    /// </li>
    /// <li>
    /// <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    /// and <code>my--namespace</code> are not valid.</p>
    /// </li>
    /// <li>
    /// <p>Not be in IP address format (for example, 192.168.5.4)</p>
    /// </li>
    /// </ul>
    InvalidTrailNameException(crate::error::InvalidTrailNameException),
    /// <p>This exception is thrown when the Amazon Web Services account making the request to create or update an organization trail is not the management account for an
    /// organization in Organizations. For more information, see
    /// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
    NotOrganizationMasterAccountException(crate::error::NotOrganizationMasterAccountException),
    /// <p>This exception is thrown when the requested operation is not permitted.</p>
    OperationNotPermittedException(crate::error::OperationNotPermittedException),
    /// <p>This exception is thrown when the specified resource is not found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>This exception is thrown when the specified resource type is not supported by CloudTrail.</p>
    ResourceTypeNotSupportedException(crate::error::ResourceTypeNotSupportedException),
    /// <p>This exception is thrown when the requested operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveTagsErrorKind::CloudTrailArnInvalidException(_inner) => _inner.fmt(f),
            RemoveTagsErrorKind::InvalidTagParameterException(_inner) => _inner.fmt(f),
            RemoveTagsErrorKind::InvalidTrailNameException(_inner) => _inner.fmt(f),
            RemoveTagsErrorKind::NotOrganizationMasterAccountException(_inner) => _inner.fmt(f),
            RemoveTagsErrorKind::OperationNotPermittedException(_inner) => _inner.fmt(f),
            RemoveTagsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RemoveTagsErrorKind::ResourceTypeNotSupportedException(_inner) => _inner.fmt(f),
            RemoveTagsErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            RemoveTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RemoveTagsError {
    fn code(&self) -> Option<&str> {
        RemoveTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveTagsError {
    /// Creates a new `RemoveTagsError`.
    pub fn new(kind: RemoveTagsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `RemoveTagsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `RemoveTagsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveTagsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `RemoveTagsErrorKind::CloudTrailArnInvalidException`.
    pub fn is_cloud_trail_arn_invalid_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsErrorKind::CloudTrailArnInvalidException(_)
        )
    }
    /// Returns true if the error kind is `RemoveTagsErrorKind::InvalidTagParameterException`.
    pub fn is_invalid_tag_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsErrorKind::InvalidTagParameterException(_)
        )
    }
    /// Returns true if the error kind is `RemoveTagsErrorKind::InvalidTrailNameException`.
    pub fn is_invalid_trail_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsErrorKind::InvalidTrailNameException(_)
        )
    }
    /// Returns true if the error kind is `RemoveTagsErrorKind::NotOrganizationMasterAccountException`.
    pub fn is_not_organization_master_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsErrorKind::NotOrganizationMasterAccountException(_)
        )
    }
    /// Returns true if the error kind is `RemoveTagsErrorKind::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsErrorKind::OperationNotPermittedException(_)
        )
    }
    /// Returns true if the error kind is `RemoveTagsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns true if the error kind is `RemoveTagsErrorKind::ResourceTypeNotSupportedException`.
    pub fn is_resource_type_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsErrorKind::ResourceTypeNotSupportedException(_)
        )
    }
    /// Returns true if the error kind is `RemoveTagsErrorKind::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for RemoveTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveTagsErrorKind::CloudTrailArnInvalidException(_inner) => Some(_inner),
            RemoveTagsErrorKind::InvalidTagParameterException(_inner) => Some(_inner),
            RemoveTagsErrorKind::InvalidTrailNameException(_inner) => Some(_inner),
            RemoveTagsErrorKind::NotOrganizationMasterAccountException(_inner) => Some(_inner),
            RemoveTagsErrorKind::OperationNotPermittedException(_inner) => Some(_inner),
            RemoveTagsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RemoveTagsErrorKind::ResourceTypeNotSupportedException(_inner) => Some(_inner),
            RemoveTagsErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            RemoveTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StartLogging` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartLoggingError {
    /// Kind of error that occurred.
    pub kind: StartLoggingErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StartLogging` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartLoggingErrorKind {
    /// <p>This exception is thrown when the IAM user or role that is used to create the organization trail is lacking one or more required permissions for
    /// creating an organization trail in a required service. For more information, see
    /// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
    InsufficientDependencyServiceAccessPermissionException(
        crate::error::InsufficientDependencyServiceAccessPermissionException,
    ),
    /// <p>This exception is thrown when an operation is called on a trail from a region other than the region in which the trail was created.</p>
    InvalidHomeRegionException(crate::error::InvalidHomeRegionException),
    /// <p>This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    /// </li>
    /// <li>
    /// <p>Start with a letter or number, and end with a letter or number</p>
    /// </li>
    /// <li>
    /// <p>Be between 3 and 128 characters</p>
    /// </li>
    /// <li>
    /// <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    /// and <code>my--namespace</code> are not valid.</p>
    /// </li>
    /// <li>
    /// <p>Not be in IP address format (for example, 192.168.5.4)</p>
    /// </li>
    /// </ul>
    InvalidTrailNameException(crate::error::InvalidTrailNameException),
    /// <p>This exception is thrown when the Amazon Web Services account making the request to create or update an organization trail is not the management account for an
    /// organization in Organizations. For more information, see
    /// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
    NotOrganizationMasterAccountException(crate::error::NotOrganizationMasterAccountException),
    /// <p>This exception is thrown when the requested operation is not permitted.</p>
    OperationNotPermittedException(crate::error::OperationNotPermittedException),
    /// <p>This exception is thrown when the trail with the given name is not found.</p>
    TrailNotFoundException(crate::error::TrailNotFoundException),
    /// <p>This exception is thrown when the requested operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartLoggingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartLoggingErrorKind::InsufficientDependencyServiceAccessPermissionException(
                _inner,
            ) => _inner.fmt(f),
            StartLoggingErrorKind::InvalidHomeRegionException(_inner) => _inner.fmt(f),
            StartLoggingErrorKind::InvalidTrailNameException(_inner) => _inner.fmt(f),
            StartLoggingErrorKind::NotOrganizationMasterAccountException(_inner) => _inner.fmt(f),
            StartLoggingErrorKind::OperationNotPermittedException(_inner) => _inner.fmt(f),
            StartLoggingErrorKind::TrailNotFoundException(_inner) => _inner.fmt(f),
            StartLoggingErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            StartLoggingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartLoggingError {
    fn code(&self) -> Option<&str> {
        StartLoggingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartLoggingError {
    /// Creates a new `StartLoggingError`.
    pub fn new(kind: StartLoggingErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StartLoggingError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartLoggingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StartLoggingError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartLoggingErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `StartLoggingErrorKind::InsufficientDependencyServiceAccessPermissionException`.
    pub fn is_insufficient_dependency_service_access_permission_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLoggingErrorKind::InsufficientDependencyServiceAccessPermissionException(_)
        )
    }
    /// Returns true if the error kind is `StartLoggingErrorKind::InvalidHomeRegionException`.
    pub fn is_invalid_home_region_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLoggingErrorKind::InvalidHomeRegionException(_)
        )
    }
    /// Returns true if the error kind is `StartLoggingErrorKind::InvalidTrailNameException`.
    pub fn is_invalid_trail_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLoggingErrorKind::InvalidTrailNameException(_)
        )
    }
    /// Returns true if the error kind is `StartLoggingErrorKind::NotOrganizationMasterAccountException`.
    pub fn is_not_organization_master_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLoggingErrorKind::NotOrganizationMasterAccountException(_)
        )
    }
    /// Returns true if the error kind is `StartLoggingErrorKind::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLoggingErrorKind::OperationNotPermittedException(_)
        )
    }
    /// Returns true if the error kind is `StartLoggingErrorKind::TrailNotFoundException`.
    pub fn is_trail_not_found_exception(&self) -> bool {
        matches!(&self.kind, StartLoggingErrorKind::TrailNotFoundException(_))
    }
    /// Returns true if the error kind is `StartLoggingErrorKind::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartLoggingErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for StartLoggingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartLoggingErrorKind::InsufficientDependencyServiceAccessPermissionException(
                _inner,
            ) => Some(_inner),
            StartLoggingErrorKind::InvalidHomeRegionException(_inner) => Some(_inner),
            StartLoggingErrorKind::InvalidTrailNameException(_inner) => Some(_inner),
            StartLoggingErrorKind::NotOrganizationMasterAccountException(_inner) => Some(_inner),
            StartLoggingErrorKind::OperationNotPermittedException(_inner) => Some(_inner),
            StartLoggingErrorKind::TrailNotFoundException(_inner) => Some(_inner),
            StartLoggingErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            StartLoggingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `StopLogging` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopLoggingError {
    /// Kind of error that occurred.
    pub kind: StopLoggingErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `StopLogging` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopLoggingErrorKind {
    /// <p>This exception is thrown when the IAM user or role that is used to create the organization trail is lacking one or more required permissions for
    /// creating an organization trail in a required service. For more information, see
    /// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
    InsufficientDependencyServiceAccessPermissionException(
        crate::error::InsufficientDependencyServiceAccessPermissionException,
    ),
    /// <p>This exception is thrown when an operation is called on a trail from a region other than the region in which the trail was created.</p>
    InvalidHomeRegionException(crate::error::InvalidHomeRegionException),
    /// <p>This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    /// </li>
    /// <li>
    /// <p>Start with a letter or number, and end with a letter or number</p>
    /// </li>
    /// <li>
    /// <p>Be between 3 and 128 characters</p>
    /// </li>
    /// <li>
    /// <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    /// and <code>my--namespace</code> are not valid.</p>
    /// </li>
    /// <li>
    /// <p>Not be in IP address format (for example, 192.168.5.4)</p>
    /// </li>
    /// </ul>
    InvalidTrailNameException(crate::error::InvalidTrailNameException),
    /// <p>This exception is thrown when the Amazon Web Services account making the request to create or update an organization trail is not the management account for an
    /// organization in Organizations. For more information, see
    /// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
    NotOrganizationMasterAccountException(crate::error::NotOrganizationMasterAccountException),
    /// <p>This exception is thrown when the requested operation is not permitted.</p>
    OperationNotPermittedException(crate::error::OperationNotPermittedException),
    /// <p>This exception is thrown when the trail with the given name is not found.</p>
    TrailNotFoundException(crate::error::TrailNotFoundException),
    /// <p>This exception is thrown when the requested operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopLoggingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopLoggingErrorKind::InsufficientDependencyServiceAccessPermissionException(
                _inner,
            ) => _inner.fmt(f),
            StopLoggingErrorKind::InvalidHomeRegionException(_inner) => _inner.fmt(f),
            StopLoggingErrorKind::InvalidTrailNameException(_inner) => _inner.fmt(f),
            StopLoggingErrorKind::NotOrganizationMasterAccountException(_inner) => _inner.fmt(f),
            StopLoggingErrorKind::OperationNotPermittedException(_inner) => _inner.fmt(f),
            StopLoggingErrorKind::TrailNotFoundException(_inner) => _inner.fmt(f),
            StopLoggingErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            StopLoggingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StopLoggingError {
    fn code(&self) -> Option<&str> {
        StopLoggingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopLoggingError {
    /// Creates a new `StopLoggingError`.
    pub fn new(kind: StopLoggingErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `StopLoggingError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopLoggingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `StopLoggingError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopLoggingErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `StopLoggingErrorKind::InsufficientDependencyServiceAccessPermissionException`.
    pub fn is_insufficient_dependency_service_access_permission_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopLoggingErrorKind::InsufficientDependencyServiceAccessPermissionException(_)
        )
    }
    /// Returns true if the error kind is `StopLoggingErrorKind::InvalidHomeRegionException`.
    pub fn is_invalid_home_region_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopLoggingErrorKind::InvalidHomeRegionException(_)
        )
    }
    /// Returns true if the error kind is `StopLoggingErrorKind::InvalidTrailNameException`.
    pub fn is_invalid_trail_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopLoggingErrorKind::InvalidTrailNameException(_)
        )
    }
    /// Returns true if the error kind is `StopLoggingErrorKind::NotOrganizationMasterAccountException`.
    pub fn is_not_organization_master_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopLoggingErrorKind::NotOrganizationMasterAccountException(_)
        )
    }
    /// Returns true if the error kind is `StopLoggingErrorKind::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopLoggingErrorKind::OperationNotPermittedException(_)
        )
    }
    /// Returns true if the error kind is `StopLoggingErrorKind::TrailNotFoundException`.
    pub fn is_trail_not_found_exception(&self) -> bool {
        matches!(&self.kind, StopLoggingErrorKind::TrailNotFoundException(_))
    }
    /// Returns true if the error kind is `StopLoggingErrorKind::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopLoggingErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for StopLoggingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopLoggingErrorKind::InsufficientDependencyServiceAccessPermissionException(
                _inner,
            ) => Some(_inner),
            StopLoggingErrorKind::InvalidHomeRegionException(_inner) => Some(_inner),
            StopLoggingErrorKind::InvalidTrailNameException(_inner) => Some(_inner),
            StopLoggingErrorKind::NotOrganizationMasterAccountException(_inner) => Some(_inner),
            StopLoggingErrorKind::OperationNotPermittedException(_inner) => Some(_inner),
            StopLoggingErrorKind::TrailNotFoundException(_inner) => Some(_inner),
            StopLoggingErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            StopLoggingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateTrail` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTrailError {
    /// Kind of error that occurred.
    pub kind: UpdateTrailErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateTrail` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTrailErrorKind {
    /// <p>This exception is thrown when trusted access has not been enabled between CloudTrail and Organizations. For more information,
    /// see <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_integrate_services.html">Enabling Trusted Access with Other Amazon Web Services Services</a>
    /// and <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>. </p>
    CloudTrailAccessNotEnabledException(crate::error::CloudTrailAccessNotEnabledException),
    /// <p>This exception is thrown when a call results in the <code>InvalidClientTokenId</code> error code.
    /// This can occur when you are creating or updating a trail to send notifications to an Amazon SNS topic that
    /// is in a suspended Amazon Web Services account.</p>
    CloudTrailInvalidClientTokenIdException(crate::error::CloudTrailInvalidClientTokenIdException),
    /// <p>Cannot set a CloudWatch Logs delivery for this region.</p>
    CloudWatchLogsDeliveryUnavailableException(
        crate::error::CloudWatchLogsDeliveryUnavailableException,
    ),
    /// <p>This exception is thrown when the IAM user or role that is used to create the organization trail is lacking one or more required permissions for
    /// creating an organization trail in a required service. For more information, see
    /// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
    InsufficientDependencyServiceAccessPermissionException(
        crate::error::InsufficientDependencyServiceAccessPermissionException,
    ),
    /// <p>This exception is thrown when the policy on the S3 bucket or KMS key is not sufficient.</p>
    InsufficientEncryptionPolicyException(crate::error::InsufficientEncryptionPolicyException),
    /// <p>This exception is thrown when the policy on the S3 bucket is not sufficient.</p>
    InsufficientS3BucketPolicyException(crate::error::InsufficientS3BucketPolicyException),
    /// <p>This exception is thrown when the policy on the Amazon SNS topic is not sufficient.</p>
    InsufficientSnsTopicPolicyException(crate::error::InsufficientSnsTopicPolicyException),
    /// <p>This exception is thrown when the provided CloudWatch Logs log group is not valid.</p>
    InvalidCloudWatchLogsLogGroupArnException(
        crate::error::InvalidCloudWatchLogsLogGroupArnException,
    ),
    /// <p>This exception is thrown when the provided role is not valid.</p>
    InvalidCloudWatchLogsRoleArnException(crate::error::InvalidCloudWatchLogsRoleArnException),
    /// <p>This exception is thrown when the <code>PutEventSelectors</code> operation is called with a number of event
    /// selectors, advanced event selectors, or data resources that is not valid. The combination of event selectors or advanced event selectors and
    /// data resources is not valid. A trail can have up to 5 event selectors. If a trail uses advanced event selectors, a maximum
    /// of 500 total values for all conditions in all advanced event selectors is allowed. A trail is limited to 250 data resources. These data resources can be distributed across event selectors, but the overall total cannot exceed 250.</p>
    /// <p>You can:</p>
    /// <ul>
    /// <li>
    /// <p>Specify a valid number of event selectors (1 to 5) for a trail.</p>
    /// </li>
    /// <li>
    /// <p>Specify a valid number of data resources (1 to 250) for an event selector.
    /// The limit of number of resources on an individual event selector is configurable up to 250.
    /// However, this upper limit is allowed only if the total number of data resources does not
    /// exceed 250 across all event selectors for a trail.</p>
    /// </li>
    /// <li>
    /// <p>Specify up to 500 values for all conditions in all advanced event selectors for a trail.</p>
    /// </li>
    /// <li>
    /// <p>Specify a valid value for a parameter. For example, specifying the <code>ReadWriteType</code>
    /// parameter with a value of <code>read-only</code> is not valid.</p>
    /// </li>
    /// </ul>
    InvalidEventSelectorsException(crate::error::InvalidEventSelectorsException),
    /// <p>This exception is thrown when an operation is called on a trail from a region other than the region in which the trail was created.</p>
    InvalidHomeRegionException(crate::error::InvalidHomeRegionException),
    /// <p>This exception is thrown when the KMS key ARN is not valid.</p>
    InvalidKmsKeyIdException(crate::error::InvalidKmsKeyIdException),
    /// <p>This exception is thrown when the combination of parameters provided is not valid.</p>
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    /// <p>This exception is thrown when the provided S3 bucket name is not valid.</p>
    InvalidS3BucketNameException(crate::error::InvalidS3BucketNameException),
    /// <p>This exception is thrown when the provided S3 prefix is not valid.</p>
    InvalidS3PrefixException(crate::error::InvalidS3PrefixException),
    /// <p>This exception is thrown when the provided SNS topic name is not valid.</p>
    InvalidSnsTopicNameException(crate::error::InvalidSnsTopicNameException),
    /// <p>This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    /// </li>
    /// <li>
    /// <p>Start with a letter or number, and end with a letter or number</p>
    /// </li>
    /// <li>
    /// <p>Be between 3 and 128 characters</p>
    /// </li>
    /// <li>
    /// <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    /// and <code>my--namespace</code> are not valid.</p>
    /// </li>
    /// <li>
    /// <p>Not be in IP address format (for example, 192.168.5.4)</p>
    /// </li>
    /// </ul>
    InvalidTrailNameException(crate::error::InvalidTrailNameException),
    /// <p>This exception is thrown when there is an issue with the specified KMS key and the trail can’t be updated.</p>
    KmsException(crate::error::KmsException),
    /// <p>This exception is no longer in use.</p>
    KmsKeyDisabledException(crate::error::KmsKeyDisabledException),
    /// <p>This exception is thrown when the KMS key does not exist, when the S3 bucket and the
    /// KMS key are not in the same region, or when the KMS key associated with the Amazon SNS
    /// topic either does not exist or is not in the same region.</p>
    KmsKeyNotFoundException(crate::error::KmsKeyNotFoundException),
    /// <p>This exception is thrown when the Amazon Web Services account making the request to create or update an organization trail is not the management account for an
    /// organization in Organizations. For more information, see
    /// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
    NotOrganizationMasterAccountException(crate::error::NotOrganizationMasterAccountException),
    /// <p>This exception is thrown when the requested operation is not permitted.</p>
    OperationNotPermittedException(crate::error::OperationNotPermittedException),
    /// <p>This exception is thrown when Organizations is not configured to support all features. All features must be enabled in Organizations to support
    /// creating an organization trail. For more information, see
    /// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
    OrganizationNotInAllFeaturesModeException(
        crate::error::OrganizationNotInAllFeaturesModeException,
    ),
    /// <p>This exception is thrown when the request is made from an Amazon Web Services account that is not a member of an organization.
    /// To make this request, sign in using the credentials of an account that belongs to an organization.</p>
    OrganizationsNotInUseException(crate::error::OrganizationsNotInUseException),
    /// <p>This exception is thrown when the specified S3 bucket does not exist.</p>
    S3BucketDoesNotExistException(crate::error::S3BucketDoesNotExistException),
    /// <p>This exception is thrown when the trail with the given name is not found.</p>
    TrailNotFoundException(crate::error::TrailNotFoundException),
    /// <p>This exception is no longer in use.</p>
    TrailNotProvidedException(crate::error::TrailNotProvidedException),
    /// <p>This exception is thrown when the requested operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateTrailError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTrailErrorKind::CloudTrailAccessNotEnabledException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::CloudTrailInvalidClientTokenIdException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::CloudWatchLogsDeliveryUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateTrailErrorKind::InsufficientDependencyServiceAccessPermissionException(
                _inner,
            ) => _inner.fmt(f),
            UpdateTrailErrorKind::InsufficientEncryptionPolicyException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::InsufficientS3BucketPolicyException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::InsufficientSnsTopicPolicyException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::InvalidCloudWatchLogsLogGroupArnException(_inner) => {
                _inner.fmt(f)
            }
            UpdateTrailErrorKind::InvalidCloudWatchLogsRoleArnException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::InvalidEventSelectorsException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::InvalidHomeRegionException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::InvalidKmsKeyIdException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::InvalidS3BucketNameException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::InvalidS3PrefixException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::InvalidSnsTopicNameException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::InvalidTrailNameException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::KmsException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::KmsKeyDisabledException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::KmsKeyNotFoundException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::NotOrganizationMasterAccountException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::OperationNotPermittedException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::OrganizationNotInAllFeaturesModeException(_inner) => {
                _inner.fmt(f)
            }
            UpdateTrailErrorKind::OrganizationsNotInUseException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::S3BucketDoesNotExistException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::TrailNotFoundException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::TrailNotProvidedException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            UpdateTrailErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateTrailError {
    fn code(&self) -> Option<&str> {
        UpdateTrailError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTrailError {
    /// Creates a new `UpdateTrailError`.
    pub fn new(kind: UpdateTrailErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateTrailError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateTrailErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateTrailError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateTrailErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::CloudTrailAccessNotEnabledException`.
    pub fn is_cloud_trail_access_not_enabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::CloudTrailAccessNotEnabledException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::CloudTrailInvalidClientTokenIdException`.
    pub fn is_cloud_trail_invalid_client_token_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::CloudTrailInvalidClientTokenIdException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::CloudWatchLogsDeliveryUnavailableException`.
    pub fn is_cloud_watch_logs_delivery_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::CloudWatchLogsDeliveryUnavailableException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::InsufficientDependencyServiceAccessPermissionException`.
    pub fn is_insufficient_dependency_service_access_permission_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::InsufficientDependencyServiceAccessPermissionException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::InsufficientEncryptionPolicyException`.
    pub fn is_insufficient_encryption_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::InsufficientEncryptionPolicyException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::InsufficientS3BucketPolicyException`.
    pub fn is_insufficient_s3_bucket_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::InsufficientS3BucketPolicyException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::InsufficientSnsTopicPolicyException`.
    pub fn is_insufficient_sns_topic_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::InsufficientSnsTopicPolicyException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::InvalidCloudWatchLogsLogGroupArnException`.
    pub fn is_invalid_cloud_watch_logs_log_group_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::InvalidCloudWatchLogsLogGroupArnException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::InvalidCloudWatchLogsRoleArnException`.
    pub fn is_invalid_cloud_watch_logs_role_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::InvalidCloudWatchLogsRoleArnException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::InvalidEventSelectorsException`.
    pub fn is_invalid_event_selectors_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::InvalidEventSelectorsException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::InvalidHomeRegionException`.
    pub fn is_invalid_home_region_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::InvalidHomeRegionException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::InvalidKmsKeyIdException`.
    pub fn is_invalid_kms_key_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::InvalidKmsKeyIdException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::InvalidParameterCombinationException`.
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::InvalidParameterCombinationException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::InvalidS3BucketNameException`.
    pub fn is_invalid_s3_bucket_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::InvalidS3BucketNameException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::InvalidS3PrefixException`.
    pub fn is_invalid_s3_prefix_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::InvalidS3PrefixException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::InvalidSnsTopicNameException`.
    pub fn is_invalid_sns_topic_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::InvalidSnsTopicNameException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::InvalidTrailNameException`.
    pub fn is_invalid_trail_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::InvalidTrailNameException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::KmsException`.
    pub fn is_kms_exception(&self) -> bool {
        matches!(&self.kind, UpdateTrailErrorKind::KmsException(_))
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::KmsKeyDisabledException`.
    pub fn is_kms_key_disabled_exception(&self) -> bool {
        matches!(&self.kind, UpdateTrailErrorKind::KmsKeyDisabledException(_))
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::KmsKeyNotFoundException`.
    pub fn is_kms_key_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateTrailErrorKind::KmsKeyNotFoundException(_))
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::NotOrganizationMasterAccountException`.
    pub fn is_not_organization_master_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::NotOrganizationMasterAccountException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::OperationNotPermittedException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::OrganizationNotInAllFeaturesModeException`.
    pub fn is_organization_not_in_all_features_mode_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::OrganizationNotInAllFeaturesModeException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::OrganizationsNotInUseException`.
    pub fn is_organizations_not_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::OrganizationsNotInUseException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::S3BucketDoesNotExistException`.
    pub fn is_s3_bucket_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::S3BucketDoesNotExistException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::TrailNotFoundException`.
    pub fn is_trail_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateTrailErrorKind::TrailNotFoundException(_))
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::TrailNotProvidedException`.
    pub fn is_trail_not_provided_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::TrailNotProvidedException(_)
        )
    }
    /// Returns true if the error kind is `UpdateTrailErrorKind::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTrailErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for UpdateTrailError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTrailErrorKind::CloudTrailAccessNotEnabledException(_inner) => Some(_inner),
            UpdateTrailErrorKind::CloudTrailInvalidClientTokenIdException(_inner) => Some(_inner),
            UpdateTrailErrorKind::CloudWatchLogsDeliveryUnavailableException(_inner) => {
                Some(_inner)
            }
            UpdateTrailErrorKind::InsufficientDependencyServiceAccessPermissionException(
                _inner,
            ) => Some(_inner),
            UpdateTrailErrorKind::InsufficientEncryptionPolicyException(_inner) => Some(_inner),
            UpdateTrailErrorKind::InsufficientS3BucketPolicyException(_inner) => Some(_inner),
            UpdateTrailErrorKind::InsufficientSnsTopicPolicyException(_inner) => Some(_inner),
            UpdateTrailErrorKind::InvalidCloudWatchLogsLogGroupArnException(_inner) => Some(_inner),
            UpdateTrailErrorKind::InvalidCloudWatchLogsRoleArnException(_inner) => Some(_inner),
            UpdateTrailErrorKind::InvalidEventSelectorsException(_inner) => Some(_inner),
            UpdateTrailErrorKind::InvalidHomeRegionException(_inner) => Some(_inner),
            UpdateTrailErrorKind::InvalidKmsKeyIdException(_inner) => Some(_inner),
            UpdateTrailErrorKind::InvalidParameterCombinationException(_inner) => Some(_inner),
            UpdateTrailErrorKind::InvalidS3BucketNameException(_inner) => Some(_inner),
            UpdateTrailErrorKind::InvalidS3PrefixException(_inner) => Some(_inner),
            UpdateTrailErrorKind::InvalidSnsTopicNameException(_inner) => Some(_inner),
            UpdateTrailErrorKind::InvalidTrailNameException(_inner) => Some(_inner),
            UpdateTrailErrorKind::KmsException(_inner) => Some(_inner),
            UpdateTrailErrorKind::KmsKeyDisabledException(_inner) => Some(_inner),
            UpdateTrailErrorKind::KmsKeyNotFoundException(_inner) => Some(_inner),
            UpdateTrailErrorKind::NotOrganizationMasterAccountException(_inner) => Some(_inner),
            UpdateTrailErrorKind::OperationNotPermittedException(_inner) => Some(_inner),
            UpdateTrailErrorKind::OrganizationNotInAllFeaturesModeException(_inner) => Some(_inner),
            UpdateTrailErrorKind::OrganizationsNotInUseException(_inner) => Some(_inner),
            UpdateTrailErrorKind::S3BucketDoesNotExistException(_inner) => Some(_inner),
            UpdateTrailErrorKind::TrailNotFoundException(_inner) => Some(_inner),
            UpdateTrailErrorKind::TrailNotProvidedException(_inner) => Some(_inner),
            UpdateTrailErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            UpdateTrailErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>This exception is thrown when the requested operation is not supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedOperationException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedOperationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedOperationException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedOperationException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedOperationException {}
/// See [`UnsupportedOperationException`](crate::error::UnsupportedOperationException)
pub mod unsupported_operation_exception {
    /// A builder for [`UnsupportedOperationException`](crate::error::UnsupportedOperationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedOperationException`](crate::error::UnsupportedOperationException)
        pub fn build(self) -> crate::error::UnsupportedOperationException {
            crate::error::UnsupportedOperationException {
                message: self.message,
            }
        }
    }
}
impl UnsupportedOperationException {
    /// Creates a new builder-style object to manufacture [`UnsupportedOperationException`](crate::error::UnsupportedOperationException)
    pub fn builder() -> crate::error::unsupported_operation_exception::Builder {
        crate::error::unsupported_operation_exception::Builder::default()
    }
}

/// <p>This exception is no longer in use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrailNotProvidedException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TrailNotProvidedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrailNotProvidedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TrailNotProvidedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TrailNotProvidedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TrailNotProvidedException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for TrailNotProvidedException {}
/// See [`TrailNotProvidedException`](crate::error::TrailNotProvidedException)
pub mod trail_not_provided_exception {
    /// A builder for [`TrailNotProvidedException`](crate::error::TrailNotProvidedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TrailNotProvidedException`](crate::error::TrailNotProvidedException)
        pub fn build(self) -> crate::error::TrailNotProvidedException {
            crate::error::TrailNotProvidedException {
                message: self.message,
            }
        }
    }
}
impl TrailNotProvidedException {
    /// Creates a new builder-style object to manufacture [`TrailNotProvidedException`](crate::error::TrailNotProvidedException)
    pub fn builder() -> crate::error::trail_not_provided_exception::Builder {
        crate::error::trail_not_provided_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the trail with the given name is not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrailNotFoundException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TrailNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrailNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TrailNotFoundException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TrailNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TrailNotFoundException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for TrailNotFoundException {}
/// See [`TrailNotFoundException`](crate::error::TrailNotFoundException)
pub mod trail_not_found_exception {
    /// A builder for [`TrailNotFoundException`](crate::error::TrailNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TrailNotFoundException`](crate::error::TrailNotFoundException)
        pub fn build(self) -> crate::error::TrailNotFoundException {
            crate::error::TrailNotFoundException {
                message: self.message,
            }
        }
    }
}
impl TrailNotFoundException {
    /// Creates a new builder-style object to manufacture [`TrailNotFoundException`](crate::error::TrailNotFoundException)
    pub fn builder() -> crate::error::trail_not_found_exception::Builder {
        crate::error::trail_not_found_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the specified S3 bucket does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3BucketDoesNotExistException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for S3BucketDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3BucketDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl S3BucketDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for S3BucketDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "S3BucketDoesNotExistException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for S3BucketDoesNotExistException {}
/// See [`S3BucketDoesNotExistException`](crate::error::S3BucketDoesNotExistException)
pub mod s3_bucket_does_not_exist_exception {
    /// A builder for [`S3BucketDoesNotExistException`](crate::error::S3BucketDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`S3BucketDoesNotExistException`](crate::error::S3BucketDoesNotExistException)
        pub fn build(self) -> crate::error::S3BucketDoesNotExistException {
            crate::error::S3BucketDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl S3BucketDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`S3BucketDoesNotExistException`](crate::error::S3BucketDoesNotExistException)
    pub fn builder() -> crate::error::s3_bucket_does_not_exist_exception::Builder {
        crate::error::s3_bucket_does_not_exist_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the request is made from an Amazon Web Services account that is not a member of an organization.
/// To make this request, sign in using the credentials of an account that belongs to an organization.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OrganizationsNotInUseException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OrganizationsNotInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OrganizationsNotInUseException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OrganizationsNotInUseException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OrganizationsNotInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OrganizationsNotInUseException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for OrganizationsNotInUseException {}
/// See [`OrganizationsNotInUseException`](crate::error::OrganizationsNotInUseException)
pub mod organizations_not_in_use_exception {
    /// A builder for [`OrganizationsNotInUseException`](crate::error::OrganizationsNotInUseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OrganizationsNotInUseException`](crate::error::OrganizationsNotInUseException)
        pub fn build(self) -> crate::error::OrganizationsNotInUseException {
            crate::error::OrganizationsNotInUseException {
                message: self.message,
            }
        }
    }
}
impl OrganizationsNotInUseException {
    /// Creates a new builder-style object to manufacture [`OrganizationsNotInUseException`](crate::error::OrganizationsNotInUseException)
    pub fn builder() -> crate::error::organizations_not_in_use_exception::Builder {
        crate::error::organizations_not_in_use_exception::Builder::default()
    }
}

/// <p>This exception is thrown when Organizations is not configured to support all features. All features must be enabled in Organizations to support
/// creating an organization trail. For more information, see
/// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OrganizationNotInAllFeaturesModeException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OrganizationNotInAllFeaturesModeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OrganizationNotInAllFeaturesModeException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OrganizationNotInAllFeaturesModeException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OrganizationNotInAllFeaturesModeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OrganizationNotInAllFeaturesModeException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for OrganizationNotInAllFeaturesModeException {}
/// See [`OrganizationNotInAllFeaturesModeException`](crate::error::OrganizationNotInAllFeaturesModeException)
pub mod organization_not_in_all_features_mode_exception {
    /// A builder for [`OrganizationNotInAllFeaturesModeException`](crate::error::OrganizationNotInAllFeaturesModeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OrganizationNotInAllFeaturesModeException`](crate::error::OrganizationNotInAllFeaturesModeException)
        pub fn build(self) -> crate::error::OrganizationNotInAllFeaturesModeException {
            crate::error::OrganizationNotInAllFeaturesModeException {
                message: self.message,
            }
        }
    }
}
impl OrganizationNotInAllFeaturesModeException {
    /// Creates a new builder-style object to manufacture [`OrganizationNotInAllFeaturesModeException`](crate::error::OrganizationNotInAllFeaturesModeException)
    pub fn builder() -> crate::error::organization_not_in_all_features_mode_exception::Builder {
        crate::error::organization_not_in_all_features_mode_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the requested operation is not permitted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OperationNotPermittedException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OperationNotPermittedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OperationNotPermittedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OperationNotPermittedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OperationNotPermittedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OperationNotPermittedException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for OperationNotPermittedException {}
/// See [`OperationNotPermittedException`](crate::error::OperationNotPermittedException)
pub mod operation_not_permitted_exception {
    /// A builder for [`OperationNotPermittedException`](crate::error::OperationNotPermittedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OperationNotPermittedException`](crate::error::OperationNotPermittedException)
        pub fn build(self) -> crate::error::OperationNotPermittedException {
            crate::error::OperationNotPermittedException {
                message: self.message,
            }
        }
    }
}
impl OperationNotPermittedException {
    /// Creates a new builder-style object to manufacture [`OperationNotPermittedException`](crate::error::OperationNotPermittedException)
    pub fn builder() -> crate::error::operation_not_permitted_exception::Builder {
        crate::error::operation_not_permitted_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the Amazon Web Services account making the request to create or update an organization trail is not the management account for an
/// organization in Organizations. For more information, see
/// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotOrganizationMasterAccountException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotOrganizationMasterAccountException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotOrganizationMasterAccountException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotOrganizationMasterAccountException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotOrganizationMasterAccountException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotOrganizationMasterAccountException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotOrganizationMasterAccountException {}
/// See [`NotOrganizationMasterAccountException`](crate::error::NotOrganizationMasterAccountException)
pub mod not_organization_master_account_exception {
    /// A builder for [`NotOrganizationMasterAccountException`](crate::error::NotOrganizationMasterAccountException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotOrganizationMasterAccountException`](crate::error::NotOrganizationMasterAccountException)
        pub fn build(self) -> crate::error::NotOrganizationMasterAccountException {
            crate::error::NotOrganizationMasterAccountException {
                message: self.message,
            }
        }
    }
}
impl NotOrganizationMasterAccountException {
    /// Creates a new builder-style object to manufacture [`NotOrganizationMasterAccountException`](crate::error::NotOrganizationMasterAccountException)
    pub fn builder() -> crate::error::not_organization_master_account_exception::Builder {
        crate::error::not_organization_master_account_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the KMS key does not exist, when the S3 bucket and the
/// KMS key are not in the same region, or when the KMS key associated with the Amazon SNS
/// topic either does not exist or is not in the same region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KmsKeyNotFoundException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KmsKeyNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KmsKeyNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KmsKeyNotFoundException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KmsKeyNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KmsKeyNotFoundException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for KmsKeyNotFoundException {}
/// See [`KmsKeyNotFoundException`](crate::error::KmsKeyNotFoundException)
pub mod kms_key_not_found_exception {
    /// A builder for [`KmsKeyNotFoundException`](crate::error::KmsKeyNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`KmsKeyNotFoundException`](crate::error::KmsKeyNotFoundException)
        pub fn build(self) -> crate::error::KmsKeyNotFoundException {
            crate::error::KmsKeyNotFoundException {
                message: self.message,
            }
        }
    }
}
impl KmsKeyNotFoundException {
    /// Creates a new builder-style object to manufacture [`KmsKeyNotFoundException`](crate::error::KmsKeyNotFoundException)
    pub fn builder() -> crate::error::kms_key_not_found_exception::Builder {
        crate::error::kms_key_not_found_exception::Builder::default()
    }
}

/// <p>This exception is no longer in use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KmsKeyDisabledException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KmsKeyDisabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KmsKeyDisabledException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KmsKeyDisabledException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KmsKeyDisabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KmsKeyDisabledException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for KmsKeyDisabledException {}
/// See [`KmsKeyDisabledException`](crate::error::KmsKeyDisabledException)
pub mod kms_key_disabled_exception {
    /// A builder for [`KmsKeyDisabledException`](crate::error::KmsKeyDisabledException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`KmsKeyDisabledException`](crate::error::KmsKeyDisabledException)
        pub fn build(self) -> crate::error::KmsKeyDisabledException {
            crate::error::KmsKeyDisabledException {
                message: self.message,
            }
        }
    }
}
impl KmsKeyDisabledException {
    /// Creates a new builder-style object to manufacture [`KmsKeyDisabledException`](crate::error::KmsKeyDisabledException)
    pub fn builder() -> crate::error::kms_key_disabled_exception::Builder {
        crate::error::kms_key_disabled_exception::Builder::default()
    }
}

/// <p>This exception is thrown when there is an issue with the specified KMS key and the trail can’t be updated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KmsException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KmsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KmsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KmsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KmsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KmsException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for KmsException {}
/// See [`KmsException`](crate::error::KmsException)
pub mod kms_exception {
    /// A builder for [`KmsException`](crate::error::KmsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`KmsException`](crate::error::KmsException)
        pub fn build(self) -> crate::error::KmsException {
            crate::error::KmsException {
                message: self.message,
            }
        }
    }
}
impl KmsException {
    /// Creates a new builder-style object to manufacture [`KmsException`](crate::error::KmsException)
    pub fn builder() -> crate::error::kms_exception::Builder {
        crate::error::kms_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:</p>
/// <ul>
/// <li>
/// <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
/// </li>
/// <li>
/// <p>Start with a letter or number, and end with a letter or number</p>
/// </li>
/// <li>
/// <p>Be between 3 and 128 characters</p>
/// </li>
/// <li>
/// <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
/// and <code>my--namespace</code> are not valid.</p>
/// </li>
/// <li>
/// <p>Not be in IP address format (for example, 192.168.5.4)</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTrailNameException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTrailNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTrailNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTrailNameException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTrailNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTrailNameException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTrailNameException {}
/// See [`InvalidTrailNameException`](crate::error::InvalidTrailNameException)
pub mod invalid_trail_name_exception {
    /// A builder for [`InvalidTrailNameException`](crate::error::InvalidTrailNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTrailNameException`](crate::error::InvalidTrailNameException)
        pub fn build(self) -> crate::error::InvalidTrailNameException {
            crate::error::InvalidTrailNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidTrailNameException {
    /// Creates a new builder-style object to manufacture [`InvalidTrailNameException`](crate::error::InvalidTrailNameException)
    pub fn builder() -> crate::error::invalid_trail_name_exception::Builder {
        crate::error::invalid_trail_name_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the provided SNS topic name is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSnsTopicNameException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSnsTopicNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSnsTopicNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSnsTopicNameException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSnsTopicNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSnsTopicNameException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSnsTopicNameException {}
/// See [`InvalidSnsTopicNameException`](crate::error::InvalidSnsTopicNameException)
pub mod invalid_sns_topic_name_exception {
    /// A builder for [`InvalidSnsTopicNameException`](crate::error::InvalidSnsTopicNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSnsTopicNameException`](crate::error::InvalidSnsTopicNameException)
        pub fn build(self) -> crate::error::InvalidSnsTopicNameException {
            crate::error::InvalidSnsTopicNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidSnsTopicNameException {
    /// Creates a new builder-style object to manufacture [`InvalidSnsTopicNameException`](crate::error::InvalidSnsTopicNameException)
    pub fn builder() -> crate::error::invalid_sns_topic_name_exception::Builder {
        crate::error::invalid_sns_topic_name_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the provided S3 prefix is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidS3PrefixException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidS3PrefixException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidS3PrefixException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidS3PrefixException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidS3PrefixException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidS3PrefixException")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidS3PrefixException {}
/// See [`InvalidS3PrefixException`](crate::error::InvalidS3PrefixException)
pub mod invalid_s3_prefix_exception {
    /// A builder for [`InvalidS3PrefixException`](crate::error::InvalidS3PrefixException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidS3PrefixException`](crate::error::InvalidS3PrefixException)
        pub fn build(self) -> crate::error::InvalidS3PrefixException {
            crate::error::InvalidS3PrefixException {
                message: self.message,
            }
        }
    }
}
impl InvalidS3PrefixException {
    /// Creates a new builder-style object to manufacture [`InvalidS3PrefixException`](crate::error::InvalidS3PrefixException)
    pub fn builder() -> crate::error::invalid_s3_prefix_exception::Builder {
        crate::error::invalid_s3_prefix_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the provided S3 bucket name is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidS3BucketNameException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidS3BucketNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidS3BucketNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidS3BucketNameException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidS3BucketNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidS3BucketNameException")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidS3BucketNameException {}
/// See [`InvalidS3BucketNameException`](crate::error::InvalidS3BucketNameException)
pub mod invalid_s3_bucket_name_exception {
    /// A builder for [`InvalidS3BucketNameException`](crate::error::InvalidS3BucketNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidS3BucketNameException`](crate::error::InvalidS3BucketNameException)
        pub fn build(self) -> crate::error::InvalidS3BucketNameException {
            crate::error::InvalidS3BucketNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidS3BucketNameException {
    /// Creates a new builder-style object to manufacture [`InvalidS3BucketNameException`](crate::error::InvalidS3BucketNameException)
    pub fn builder() -> crate::error::invalid_s3_bucket_name_exception::Builder {
        crate::error::invalid_s3_bucket_name_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the combination of parameters provided is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterCombinationException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterCombinationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterCombinationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameterCombinationException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterCombinationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterCombinationException")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterCombinationException {}
/// See [`InvalidParameterCombinationException`](crate::error::InvalidParameterCombinationException)
pub mod invalid_parameter_combination_exception {
    /// A builder for [`InvalidParameterCombinationException`](crate::error::InvalidParameterCombinationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterCombinationException`](crate::error::InvalidParameterCombinationException)
        pub fn build(self) -> crate::error::InvalidParameterCombinationException {
            crate::error::InvalidParameterCombinationException {
                message: self.message,
            }
        }
    }
}
impl InvalidParameterCombinationException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterCombinationException`](crate::error::InvalidParameterCombinationException)
    pub fn builder() -> crate::error::invalid_parameter_combination_exception::Builder {
        crate::error::invalid_parameter_combination_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the KMS key ARN is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidKmsKeyIdException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidKmsKeyIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidKmsKeyIdException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidKmsKeyIdException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidKmsKeyIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidKmsKeyIdException")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidKmsKeyIdException {}
/// See [`InvalidKmsKeyIdException`](crate::error::InvalidKmsKeyIdException)
pub mod invalid_kms_key_id_exception {
    /// A builder for [`InvalidKmsKeyIdException`](crate::error::InvalidKmsKeyIdException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidKmsKeyIdException`](crate::error::InvalidKmsKeyIdException)
        pub fn build(self) -> crate::error::InvalidKmsKeyIdException {
            crate::error::InvalidKmsKeyIdException {
                message: self.message,
            }
        }
    }
}
impl InvalidKmsKeyIdException {
    /// Creates a new builder-style object to manufacture [`InvalidKmsKeyIdException`](crate::error::InvalidKmsKeyIdException)
    pub fn builder() -> crate::error::invalid_kms_key_id_exception::Builder {
        crate::error::invalid_kms_key_id_exception::Builder::default()
    }
}

/// <p>This exception is thrown when an operation is called on a trail from a region other than the region in which the trail was created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidHomeRegionException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidHomeRegionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidHomeRegionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidHomeRegionException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidHomeRegionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidHomeRegionException")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidHomeRegionException {}
/// See [`InvalidHomeRegionException`](crate::error::InvalidHomeRegionException)
pub mod invalid_home_region_exception {
    /// A builder for [`InvalidHomeRegionException`](crate::error::InvalidHomeRegionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidHomeRegionException`](crate::error::InvalidHomeRegionException)
        pub fn build(self) -> crate::error::InvalidHomeRegionException {
            crate::error::InvalidHomeRegionException {
                message: self.message,
            }
        }
    }
}
impl InvalidHomeRegionException {
    /// Creates a new builder-style object to manufacture [`InvalidHomeRegionException`](crate::error::InvalidHomeRegionException)
    pub fn builder() -> crate::error::invalid_home_region_exception::Builder {
        crate::error::invalid_home_region_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the <code>PutEventSelectors</code> operation is called with a number of event
/// selectors, advanced event selectors, or data resources that is not valid. The combination of event selectors or advanced event selectors and
/// data resources is not valid. A trail can have up to 5 event selectors. If a trail uses advanced event selectors, a maximum
/// of 500 total values for all conditions in all advanced event selectors is allowed. A trail is limited to 250 data resources. These data resources can be distributed across event selectors, but the overall total cannot exceed 250.</p>
/// <p>You can:</p>
/// <ul>
/// <li>
/// <p>Specify a valid number of event selectors (1 to 5) for a trail.</p>
/// </li>
/// <li>
/// <p>Specify a valid number of data resources (1 to 250) for an event selector.
/// The limit of number of resources on an individual event selector is configurable up to 250.
/// However, this upper limit is allowed only if the total number of data resources does not
/// exceed 250 across all event selectors for a trail.</p>
/// </li>
/// <li>
/// <p>Specify up to 500 values for all conditions in all advanced event selectors for a trail.</p>
/// </li>
/// <li>
/// <p>Specify a valid value for a parameter. For example, specifying the <code>ReadWriteType</code>
/// parameter with a value of <code>read-only</code> is not valid.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidEventSelectorsException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidEventSelectorsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidEventSelectorsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidEventSelectorsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidEventSelectorsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidEventSelectorsException")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidEventSelectorsException {}
/// See [`InvalidEventSelectorsException`](crate::error::InvalidEventSelectorsException)
pub mod invalid_event_selectors_exception {
    /// A builder for [`InvalidEventSelectorsException`](crate::error::InvalidEventSelectorsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidEventSelectorsException`](crate::error::InvalidEventSelectorsException)
        pub fn build(self) -> crate::error::InvalidEventSelectorsException {
            crate::error::InvalidEventSelectorsException {
                message: self.message,
            }
        }
    }
}
impl InvalidEventSelectorsException {
    /// Creates a new builder-style object to manufacture [`InvalidEventSelectorsException`](crate::error::InvalidEventSelectorsException)
    pub fn builder() -> crate::error::invalid_event_selectors_exception::Builder {
        crate::error::invalid_event_selectors_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the provided role is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidCloudWatchLogsRoleArnException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidCloudWatchLogsRoleArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCloudWatchLogsRoleArnException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidCloudWatchLogsRoleArnException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCloudWatchLogsRoleArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCloudWatchLogsRoleArnException")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCloudWatchLogsRoleArnException {}
/// See [`InvalidCloudWatchLogsRoleArnException`](crate::error::InvalidCloudWatchLogsRoleArnException)
pub mod invalid_cloud_watch_logs_role_arn_exception {
    /// A builder for [`InvalidCloudWatchLogsRoleArnException`](crate::error::InvalidCloudWatchLogsRoleArnException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCloudWatchLogsRoleArnException`](crate::error::InvalidCloudWatchLogsRoleArnException)
        pub fn build(self) -> crate::error::InvalidCloudWatchLogsRoleArnException {
            crate::error::InvalidCloudWatchLogsRoleArnException {
                message: self.message,
            }
        }
    }
}
impl InvalidCloudWatchLogsRoleArnException {
    /// Creates a new builder-style object to manufacture [`InvalidCloudWatchLogsRoleArnException`](crate::error::InvalidCloudWatchLogsRoleArnException)
    pub fn builder() -> crate::error::invalid_cloud_watch_logs_role_arn_exception::Builder {
        crate::error::invalid_cloud_watch_logs_role_arn_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the provided CloudWatch Logs log group is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidCloudWatchLogsLogGroupArnException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidCloudWatchLogsLogGroupArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCloudWatchLogsLogGroupArnException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidCloudWatchLogsLogGroupArnException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCloudWatchLogsLogGroupArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCloudWatchLogsLogGroupArnException")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCloudWatchLogsLogGroupArnException {}
/// See [`InvalidCloudWatchLogsLogGroupArnException`](crate::error::InvalidCloudWatchLogsLogGroupArnException)
pub mod invalid_cloud_watch_logs_log_group_arn_exception {
    /// A builder for [`InvalidCloudWatchLogsLogGroupArnException`](crate::error::InvalidCloudWatchLogsLogGroupArnException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCloudWatchLogsLogGroupArnException`](crate::error::InvalidCloudWatchLogsLogGroupArnException)
        pub fn build(self) -> crate::error::InvalidCloudWatchLogsLogGroupArnException {
            crate::error::InvalidCloudWatchLogsLogGroupArnException {
                message: self.message,
            }
        }
    }
}
impl InvalidCloudWatchLogsLogGroupArnException {
    /// Creates a new builder-style object to manufacture [`InvalidCloudWatchLogsLogGroupArnException`](crate::error::InvalidCloudWatchLogsLogGroupArnException)
    pub fn builder() -> crate::error::invalid_cloud_watch_logs_log_group_arn_exception::Builder {
        crate::error::invalid_cloud_watch_logs_log_group_arn_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the policy on the Amazon SNS topic is not sufficient.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InsufficientSnsTopicPolicyException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InsufficientSnsTopicPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InsufficientSnsTopicPolicyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InsufficientSnsTopicPolicyException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientSnsTopicPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InsufficientSnsTopicPolicyException")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientSnsTopicPolicyException {}
/// See [`InsufficientSnsTopicPolicyException`](crate::error::InsufficientSnsTopicPolicyException)
pub mod insufficient_sns_topic_policy_exception {
    /// A builder for [`InsufficientSnsTopicPolicyException`](crate::error::InsufficientSnsTopicPolicyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientSnsTopicPolicyException`](crate::error::InsufficientSnsTopicPolicyException)
        pub fn build(self) -> crate::error::InsufficientSnsTopicPolicyException {
            crate::error::InsufficientSnsTopicPolicyException {
                message: self.message,
            }
        }
    }
}
impl InsufficientSnsTopicPolicyException {
    /// Creates a new builder-style object to manufacture [`InsufficientSnsTopicPolicyException`](crate::error::InsufficientSnsTopicPolicyException)
    pub fn builder() -> crate::error::insufficient_sns_topic_policy_exception::Builder {
        crate::error::insufficient_sns_topic_policy_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the policy on the S3 bucket is not sufficient.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InsufficientS3BucketPolicyException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InsufficientS3BucketPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InsufficientS3BucketPolicyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InsufficientS3BucketPolicyException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientS3BucketPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InsufficientS3BucketPolicyException")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientS3BucketPolicyException {}
/// See [`InsufficientS3BucketPolicyException`](crate::error::InsufficientS3BucketPolicyException)
pub mod insufficient_s3_bucket_policy_exception {
    /// A builder for [`InsufficientS3BucketPolicyException`](crate::error::InsufficientS3BucketPolicyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientS3BucketPolicyException`](crate::error::InsufficientS3BucketPolicyException)
        pub fn build(self) -> crate::error::InsufficientS3BucketPolicyException {
            crate::error::InsufficientS3BucketPolicyException {
                message: self.message,
            }
        }
    }
}
impl InsufficientS3BucketPolicyException {
    /// Creates a new builder-style object to manufacture [`InsufficientS3BucketPolicyException`](crate::error::InsufficientS3BucketPolicyException)
    pub fn builder() -> crate::error::insufficient_s3_bucket_policy_exception::Builder {
        crate::error::insufficient_s3_bucket_policy_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the policy on the S3 bucket or KMS key is not sufficient.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InsufficientEncryptionPolicyException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InsufficientEncryptionPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InsufficientEncryptionPolicyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InsufficientEncryptionPolicyException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientEncryptionPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InsufficientEncryptionPolicyException")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientEncryptionPolicyException {}
/// See [`InsufficientEncryptionPolicyException`](crate::error::InsufficientEncryptionPolicyException)
pub mod insufficient_encryption_policy_exception {
    /// A builder for [`InsufficientEncryptionPolicyException`](crate::error::InsufficientEncryptionPolicyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientEncryptionPolicyException`](crate::error::InsufficientEncryptionPolicyException)
        pub fn build(self) -> crate::error::InsufficientEncryptionPolicyException {
            crate::error::InsufficientEncryptionPolicyException {
                message: self.message,
            }
        }
    }
}
impl InsufficientEncryptionPolicyException {
    /// Creates a new builder-style object to manufacture [`InsufficientEncryptionPolicyException`](crate::error::InsufficientEncryptionPolicyException)
    pub fn builder() -> crate::error::insufficient_encryption_policy_exception::Builder {
        crate::error::insufficient_encryption_policy_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the IAM user or role that is used to create the organization trail is lacking one or more required permissions for
/// creating an organization trail in a required service. For more information, see
/// <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InsufficientDependencyServiceAccessPermissionException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InsufficientDependencyServiceAccessPermissionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("InsufficientDependencyServiceAccessPermissionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InsufficientDependencyServiceAccessPermissionException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientDependencyServiceAccessPermissionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InsufficientDependencyServiceAccessPermissionException")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientDependencyServiceAccessPermissionException {}
/// See [`InsufficientDependencyServiceAccessPermissionException`](crate::error::InsufficientDependencyServiceAccessPermissionException)
pub mod insufficient_dependency_service_access_permission_exception {
    /// A builder for [`InsufficientDependencyServiceAccessPermissionException`](crate::error::InsufficientDependencyServiceAccessPermissionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientDependencyServiceAccessPermissionException`](crate::error::InsufficientDependencyServiceAccessPermissionException)
        pub fn build(self) -> crate::error::InsufficientDependencyServiceAccessPermissionException {
            crate::error::InsufficientDependencyServiceAccessPermissionException {
                message: self.message,
            }
        }
    }
}
impl InsufficientDependencyServiceAccessPermissionException {
    /// Creates a new builder-style object to manufacture [`InsufficientDependencyServiceAccessPermissionException`](crate::error::InsufficientDependencyServiceAccessPermissionException)
    pub fn builder(
    ) -> crate::error::insufficient_dependency_service_access_permission_exception::Builder {
        crate::error::insufficient_dependency_service_access_permission_exception::Builder::default(
        )
    }
}

/// <p>Cannot set a CloudWatch Logs delivery for this region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudWatchLogsDeliveryUnavailableException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CloudWatchLogsDeliveryUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudWatchLogsDeliveryUnavailableException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CloudWatchLogsDeliveryUnavailableException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CloudWatchLogsDeliveryUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CloudWatchLogsDeliveryUnavailableException")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl std::error::Error for CloudWatchLogsDeliveryUnavailableException {}
/// See [`CloudWatchLogsDeliveryUnavailableException`](crate::error::CloudWatchLogsDeliveryUnavailableException)
pub mod cloud_watch_logs_delivery_unavailable_exception {
    /// A builder for [`CloudWatchLogsDeliveryUnavailableException`](crate::error::CloudWatchLogsDeliveryUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudWatchLogsDeliveryUnavailableException`](crate::error::CloudWatchLogsDeliveryUnavailableException)
        pub fn build(self) -> crate::error::CloudWatchLogsDeliveryUnavailableException {
            crate::error::CloudWatchLogsDeliveryUnavailableException {
                message: self.message,
            }
        }
    }
}
impl CloudWatchLogsDeliveryUnavailableException {
    /// Creates a new builder-style object to manufacture [`CloudWatchLogsDeliveryUnavailableException`](crate::error::CloudWatchLogsDeliveryUnavailableException)
    pub fn builder() -> crate::error::cloud_watch_logs_delivery_unavailable_exception::Builder {
        crate::error::cloud_watch_logs_delivery_unavailable_exception::Builder::default()
    }
}

/// <p>This exception is thrown when a call results in the <code>InvalidClientTokenId</code> error code.
/// This can occur when you are creating or updating a trail to send notifications to an Amazon SNS topic that
/// is in a suspended Amazon Web Services account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudTrailInvalidClientTokenIdException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CloudTrailInvalidClientTokenIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudTrailInvalidClientTokenIdException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CloudTrailInvalidClientTokenIdException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CloudTrailInvalidClientTokenIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CloudTrailInvalidClientTokenIdException")?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl std::error::Error for CloudTrailInvalidClientTokenIdException {}
/// See [`CloudTrailInvalidClientTokenIdException`](crate::error::CloudTrailInvalidClientTokenIdException)
pub mod cloud_trail_invalid_client_token_id_exception {
    /// A builder for [`CloudTrailInvalidClientTokenIdException`](crate::error::CloudTrailInvalidClientTokenIdException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudTrailInvalidClientTokenIdException`](crate::error::CloudTrailInvalidClientTokenIdException)
        pub fn build(self) -> crate::error::CloudTrailInvalidClientTokenIdException {
            crate::error::CloudTrailInvalidClientTokenIdException {
                message: self.message,
            }
        }
    }
}
impl CloudTrailInvalidClientTokenIdException {
    /// Creates a new builder-style object to manufacture [`CloudTrailInvalidClientTokenIdException`](crate::error::CloudTrailInvalidClientTokenIdException)
    pub fn builder() -> crate::error::cloud_trail_invalid_client_token_id_exception::Builder {
        crate::error::cloud_trail_invalid_client_token_id_exception::Builder::default()
    }
}

/// <p>This exception is thrown when trusted access has not been enabled between CloudTrail and Organizations. For more information,
/// see <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_integrate_services.html">Enabling Trusted Access with Other Amazon Web Services Services</a>
/// and <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudTrailAccessNotEnabledException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CloudTrailAccessNotEnabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudTrailAccessNotEnabledException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CloudTrailAccessNotEnabledException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CloudTrailAccessNotEnabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CloudTrailAccessNotEnabledException")?;
        if let Some(inner_28) = &self.message {
            write!(f, ": {}", inner_28)?;
        }
        Ok(())
    }
}
impl std::error::Error for CloudTrailAccessNotEnabledException {}
/// See [`CloudTrailAccessNotEnabledException`](crate::error::CloudTrailAccessNotEnabledException)
pub mod cloud_trail_access_not_enabled_exception {
    /// A builder for [`CloudTrailAccessNotEnabledException`](crate::error::CloudTrailAccessNotEnabledException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudTrailAccessNotEnabledException`](crate::error::CloudTrailAccessNotEnabledException)
        pub fn build(self) -> crate::error::CloudTrailAccessNotEnabledException {
            crate::error::CloudTrailAccessNotEnabledException {
                message: self.message,
            }
        }
    }
}
impl CloudTrailAccessNotEnabledException {
    /// Creates a new builder-style object to manufacture [`CloudTrailAccessNotEnabledException`](crate::error::CloudTrailAccessNotEnabledException)
    pub fn builder() -> crate::error::cloud_trail_access_not_enabled_exception::Builder {
        crate::error::cloud_trail_access_not_enabled_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the specified resource type is not supported by CloudTrail.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceTypeNotSupportedException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceTypeNotSupportedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceTypeNotSupportedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceTypeNotSupportedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceTypeNotSupportedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceTypeNotSupportedException")?;
        if let Some(inner_29) = &self.message {
            write!(f, ": {}", inner_29)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceTypeNotSupportedException {}
/// See [`ResourceTypeNotSupportedException`](crate::error::ResourceTypeNotSupportedException)
pub mod resource_type_not_supported_exception {
    /// A builder for [`ResourceTypeNotSupportedException`](crate::error::ResourceTypeNotSupportedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceTypeNotSupportedException`](crate::error::ResourceTypeNotSupportedException)
        pub fn build(self) -> crate::error::ResourceTypeNotSupportedException {
            crate::error::ResourceTypeNotSupportedException {
                message: self.message,
            }
        }
    }
}
impl ResourceTypeNotSupportedException {
    /// Creates a new builder-style object to manufacture [`ResourceTypeNotSupportedException`](crate::error::ResourceTypeNotSupportedException)
    pub fn builder() -> crate::error::resource_type_not_supported_exception::Builder {
        crate::error::resource_type_not_supported_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the specified resource is not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_30) = &self.message {
            write!(f, ": {}", inner_30)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the specified tag key or values are not valid.
/// It can also occur if there are duplicate tags or too many tags on the resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTagParameterException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTagParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTagParameterException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTagParameterException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTagParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTagParameterException")?;
        if let Some(inner_31) = &self.message {
            write!(f, ": {}", inner_31)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTagParameterException {}
/// See [`InvalidTagParameterException`](crate::error::InvalidTagParameterException)
pub mod invalid_tag_parameter_exception {
    /// A builder for [`InvalidTagParameterException`](crate::error::InvalidTagParameterException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTagParameterException`](crate::error::InvalidTagParameterException)
        pub fn build(self) -> crate::error::InvalidTagParameterException {
            crate::error::InvalidTagParameterException {
                message: self.message,
            }
        }
    }
}
impl InvalidTagParameterException {
    /// Creates a new builder-style object to manufacture [`InvalidTagParameterException`](crate::error::InvalidTagParameterException)
    pub fn builder() -> crate::error::invalid_tag_parameter_exception::Builder {
        crate::error::invalid_tag_parameter_exception::Builder::default()
    }
}

/// <p>This exception is thrown when an operation is called with a trail ARN that is not valid. The following is the format of a trail ARN.</p>
/// <p>
/// <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudTrailArnInvalidException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CloudTrailArnInvalidException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudTrailArnInvalidException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CloudTrailArnInvalidException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CloudTrailArnInvalidException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "CloudTrailArnInvalidException [CloudTrailARNInvalidException]"
        )?;
        if let Some(inner_32) = &self.message {
            write!(f, ": {}", inner_32)?;
        }
        Ok(())
    }
}
impl std::error::Error for CloudTrailArnInvalidException {}
/// See [`CloudTrailArnInvalidException`](crate::error::CloudTrailArnInvalidException)
pub mod cloud_trail_arn_invalid_exception {
    /// A builder for [`CloudTrailArnInvalidException`](crate::error::CloudTrailArnInvalidException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudTrailArnInvalidException`](crate::error::CloudTrailArnInvalidException)
        pub fn build(self) -> crate::error::CloudTrailArnInvalidException {
            crate::error::CloudTrailArnInvalidException {
                message: self.message,
            }
        }
    }
}
impl CloudTrailArnInvalidException {
    /// Creates a new builder-style object to manufacture [`CloudTrailArnInvalidException`](crate::error::CloudTrailArnInvalidException)
    pub fn builder() -> crate::error::cloud_trail_arn_invalid_exception::Builder {
        crate::error::cloud_trail_arn_invalid_exception::Builder::default()
    }
}

/// <p>The formatting or syntax of the <code>InsightSelectors</code> JSON statement in your <code>PutInsightSelectors</code> or <code>GetInsightSelectors</code> request
/// is not valid, or the specified insight type in the <code>InsightSelectors</code> statement is not a valid insight type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidInsightSelectorsException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidInsightSelectorsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidInsightSelectorsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidInsightSelectorsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidInsightSelectorsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidInsightSelectorsException")?;
        if let Some(inner_33) = &self.message {
            write!(f, ": {}", inner_33)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidInsightSelectorsException {}
/// See [`InvalidInsightSelectorsException`](crate::error::InvalidInsightSelectorsException)
pub mod invalid_insight_selectors_exception {
    /// A builder for [`InvalidInsightSelectorsException`](crate::error::InvalidInsightSelectorsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidInsightSelectorsException`](crate::error::InvalidInsightSelectorsException)
        pub fn build(self) -> crate::error::InvalidInsightSelectorsException {
            crate::error::InvalidInsightSelectorsException {
                message: self.message,
            }
        }
    }
}
impl InvalidInsightSelectorsException {
    /// Creates a new builder-style object to manufacture [`InvalidInsightSelectorsException`](crate::error::InvalidInsightSelectorsException)
    pub fn builder() -> crate::error::invalid_insight_selectors_exception::Builder {
        crate::error::invalid_insight_selectors_exception::Builder::default()
    }
}

/// <p>Occurs if the timestamp values are not valid. Either the start time occurs after the end time, or the time range is outside the range of possible values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTimeRangeException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTimeRangeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTimeRangeException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTimeRangeException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTimeRangeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTimeRangeException")?;
        if let Some(inner_34) = &self.message {
            write!(f, ": {}", inner_34)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTimeRangeException {}
/// See [`InvalidTimeRangeException`](crate::error::InvalidTimeRangeException)
pub mod invalid_time_range_exception {
    /// A builder for [`InvalidTimeRangeException`](crate::error::InvalidTimeRangeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTimeRangeException`](crate::error::InvalidTimeRangeException)
        pub fn build(self) -> crate::error::InvalidTimeRangeException {
            crate::error::InvalidTimeRangeException {
                message: self.message,
            }
        }
    }
}
impl InvalidTimeRangeException {
    /// Creates a new builder-style object to manufacture [`InvalidTimeRangeException`](crate::error::InvalidTimeRangeException)
    pub fn builder() -> crate::error::invalid_time_range_exception::Builder {
        crate::error::invalid_time_range_exception::Builder::default()
    }
}

/// <p>A token that is not valid, or a token that was previously used in a request with different parameters. This exception is thrown if the token is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidNextTokenException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidNextTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidNextTokenException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidNextTokenException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidNextTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNextTokenException")?;
        if let Some(inner_35) = &self.message {
            write!(f, ": {}", inner_35)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidNextTokenException {}
/// See [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
pub mod invalid_next_token_exception {
    /// A builder for [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
        pub fn build(self) -> crate::error::InvalidNextTokenException {
            crate::error::InvalidNextTokenException {
                message: self.message,
            }
        }
    }
}
impl InvalidNextTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
    pub fn builder() -> crate::error::invalid_next_token_exception::Builder {
        crate::error::invalid_next_token_exception::Builder::default()
    }
}

/// <p>This exception is thrown if the limit specified is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidMaxResultsException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidMaxResultsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidMaxResultsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidMaxResultsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidMaxResultsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidMaxResultsException")?;
        if let Some(inner_36) = &self.message {
            write!(f, ": {}", inner_36)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidMaxResultsException {}
/// See [`InvalidMaxResultsException`](crate::error::InvalidMaxResultsException)
pub mod invalid_max_results_exception {
    /// A builder for [`InvalidMaxResultsException`](crate::error::InvalidMaxResultsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidMaxResultsException`](crate::error::InvalidMaxResultsException)
        pub fn build(self) -> crate::error::InvalidMaxResultsException {
            crate::error::InvalidMaxResultsException {
                message: self.message,
            }
        }
    }
}
impl InvalidMaxResultsException {
    /// Creates a new builder-style object to manufacture [`InvalidMaxResultsException`](crate::error::InvalidMaxResultsException)
    pub fn builder() -> crate::error::invalid_max_results_exception::Builder {
        crate::error::invalid_max_results_exception::Builder::default()
    }
}

/// <p>Occurs when a lookup attribute is specified that is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidLookupAttributesException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidLookupAttributesException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidLookupAttributesException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidLookupAttributesException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidLookupAttributesException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidLookupAttributesException")?;
        if let Some(inner_37) = &self.message {
            write!(f, ": {}", inner_37)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidLookupAttributesException {}
/// See [`InvalidLookupAttributesException`](crate::error::InvalidLookupAttributesException)
pub mod invalid_lookup_attributes_exception {
    /// A builder for [`InvalidLookupAttributesException`](crate::error::InvalidLookupAttributesException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidLookupAttributesException`](crate::error::InvalidLookupAttributesException)
        pub fn build(self) -> crate::error::InvalidLookupAttributesException {
            crate::error::InvalidLookupAttributesException {
                message: self.message,
            }
        }
    }
}
impl InvalidLookupAttributesException {
    /// Creates a new builder-style object to manufacture [`InvalidLookupAttributesException`](crate::error::InvalidLookupAttributesException)
    pub fn builder() -> crate::error::invalid_lookup_attributes_exception::Builder {
        crate::error::invalid_lookup_attributes_exception::Builder::default()
    }
}

/// <p>Occurs if an event category that is not valid is specified as a value of <code>EventCategory</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidEventCategoryException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidEventCategoryException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidEventCategoryException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidEventCategoryException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidEventCategoryException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidEventCategoryException")?;
        if let Some(inner_38) = &self.message {
            write!(f, ": {}", inner_38)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidEventCategoryException {}
/// See [`InvalidEventCategoryException`](crate::error::InvalidEventCategoryException)
pub mod invalid_event_category_exception {
    /// A builder for [`InvalidEventCategoryException`](crate::error::InvalidEventCategoryException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidEventCategoryException`](crate::error::InvalidEventCategoryException)
        pub fn build(self) -> crate::error::InvalidEventCategoryException {
            crate::error::InvalidEventCategoryException {
                message: self.message,
            }
        }
    }
}
impl InvalidEventCategoryException {
    /// Creates a new builder-style object to manufacture [`InvalidEventCategoryException`](crate::error::InvalidEventCategoryException)
    pub fn builder() -> crate::error::invalid_event_category_exception::Builder {
        crate::error::invalid_event_category_exception::Builder::default()
    }
}

/// <p>Reserved for future use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTokenException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTokenException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTokenException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTokenException")?;
        if let Some(inner_39) = &self.message {
            write!(f, ": {}", inner_39)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTokenException {}
/// See [`InvalidTokenException`](crate::error::InvalidTokenException)
pub mod invalid_token_exception {
    /// A builder for [`InvalidTokenException`](crate::error::InvalidTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTokenException`](crate::error::InvalidTokenException)
        pub fn build(self) -> crate::error::InvalidTokenException {
            crate::error::InvalidTokenException {
                message: self.message,
            }
        }
    }
}
impl InvalidTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidTokenException`](crate::error::InvalidTokenException)
    pub fn builder() -> crate::error::invalid_token_exception::Builder {
        crate::error::invalid_token_exception::Builder::default()
    }
}

/// <p>If you run <code>GetInsightSelectors</code> on a trail that does not have Insights events enabled, the operation throws the exception <code>InsightNotEnabledException</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InsightNotEnabledException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InsightNotEnabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InsightNotEnabledException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InsightNotEnabledException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsightNotEnabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InsightNotEnabledException")?;
        if let Some(inner_40) = &self.message {
            write!(f, ": {}", inner_40)?;
        }
        Ok(())
    }
}
impl std::error::Error for InsightNotEnabledException {}
/// See [`InsightNotEnabledException`](crate::error::InsightNotEnabledException)
pub mod insight_not_enabled_exception {
    /// A builder for [`InsightNotEnabledException`](crate::error::InsightNotEnabledException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InsightNotEnabledException`](crate::error::InsightNotEnabledException)
        pub fn build(self) -> crate::error::InsightNotEnabledException {
            crate::error::InsightNotEnabledException {
                message: self.message,
            }
        }
    }
}
impl InsightNotEnabledException {
    /// Creates a new builder-style object to manufacture [`InsightNotEnabledException`](crate::error::InsightNotEnabledException)
    pub fn builder() -> crate::error::insight_not_enabled_exception::Builder {
        crate::error::insight_not_enabled_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the specified resource is not ready for an operation.
/// This can occur when you try to run an operation on a trail before CloudTrail has time to fully load the trail.
/// If this exception occurs, wait a few minutes, and then try the operation again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_41) = &self.message {
            write!(f, ": {}", inner_41)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the specified trail already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrailAlreadyExistsException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TrailAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrailAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TrailAlreadyExistsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TrailAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TrailAlreadyExistsException")?;
        if let Some(inner_42) = &self.message {
            write!(f, ": {}", inner_42)?;
        }
        Ok(())
    }
}
impl std::error::Error for TrailAlreadyExistsException {}
/// See [`TrailAlreadyExistsException`](crate::error::TrailAlreadyExistsException)
pub mod trail_already_exists_exception {
    /// A builder for [`TrailAlreadyExistsException`](crate::error::TrailAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TrailAlreadyExistsException`](crate::error::TrailAlreadyExistsException)
        pub fn build(self) -> crate::error::TrailAlreadyExistsException {
            crate::error::TrailAlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl TrailAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`TrailAlreadyExistsException`](crate::error::TrailAlreadyExistsException)
    pub fn builder() -> crate::error::trail_already_exists_exception::Builder {
        crate::error::trail_already_exists_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the maximum number of trails is reached.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumNumberOfTrailsExceededException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumNumberOfTrailsExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumNumberOfTrailsExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumNumberOfTrailsExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumNumberOfTrailsExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumNumberOfTrailsExceededException")?;
        if let Some(inner_43) = &self.message {
            write!(f, ": {}", inner_43)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumNumberOfTrailsExceededException {}
/// See [`MaximumNumberOfTrailsExceededException`](crate::error::MaximumNumberOfTrailsExceededException)
pub mod maximum_number_of_trails_exceeded_exception {
    /// A builder for [`MaximumNumberOfTrailsExceededException`](crate::error::MaximumNumberOfTrailsExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumNumberOfTrailsExceededException`](crate::error::MaximumNumberOfTrailsExceededException)
        pub fn build(self) -> crate::error::MaximumNumberOfTrailsExceededException {
            crate::error::MaximumNumberOfTrailsExceededException {
                message: self.message,
            }
        }
    }
}
impl MaximumNumberOfTrailsExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumNumberOfTrailsExceededException`](crate::error::MaximumNumberOfTrailsExceededException)
    pub fn builder() -> crate::error::maximum_number_of_trails_exceeded_exception::Builder {
        crate::error::maximum_number_of_trails_exceeded_exception::Builder::default()
    }
}

/// <p>The number of tags per trail has exceeded the permitted amount. Currently, the limit is 50.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagsLimitExceededException {
    /// <p>Brief description of the exception returned by the request.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TagsLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagsLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TagsLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagsLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagsLimitExceededException")?;
        if let Some(inner_44) = &self.message {
            write!(f, ": {}", inner_44)?;
        }
        Ok(())
    }
}
impl std::error::Error for TagsLimitExceededException {}
/// See [`TagsLimitExceededException`](crate::error::TagsLimitExceededException)
pub mod tags_limit_exceeded_exception {
    /// A builder for [`TagsLimitExceededException`](crate::error::TagsLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Brief description of the exception returned by the request.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TagsLimitExceededException`](crate::error::TagsLimitExceededException)
        pub fn build(self) -> crate::error::TagsLimitExceededException {
            crate::error::TagsLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl TagsLimitExceededException {
    /// Creates a new builder-style object to manufacture [`TagsLimitExceededException`](crate::error::TagsLimitExceededException)
    pub fn builder() -> crate::error::tags_limit_exceeded_exception::Builder {
        crate::error::tags_limit_exceeded_exception::Builder::default()
    }
}
