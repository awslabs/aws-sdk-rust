// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddAttachmentsToSetError {
    pub kind: AddAttachmentsToSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddAttachmentsToSetErrorKind {
    AttachmentLimitExceeded(crate::error::AttachmentLimitExceeded),
    AttachmentSetExpired(crate::error::AttachmentSetExpired),
    AttachmentSetIdNotFound(crate::error::AttachmentSetIdNotFound),
    AttachmentSetSizeLimitExceeded(crate::error::AttachmentSetSizeLimitExceeded),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddAttachmentsToSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddAttachmentsToSetErrorKind::AttachmentLimitExceeded(_inner) => _inner.fmt(f),
            AddAttachmentsToSetErrorKind::AttachmentSetExpired(_inner) => _inner.fmt(f),
            AddAttachmentsToSetErrorKind::AttachmentSetIdNotFound(_inner) => _inner.fmt(f),
            AddAttachmentsToSetErrorKind::AttachmentSetSizeLimitExceeded(_inner) => _inner.fmt(f),
            AddAttachmentsToSetErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            AddAttachmentsToSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddAttachmentsToSetError {
    fn code(&self) -> Option<&str> {
        AddAttachmentsToSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddAttachmentsToSetError {
    pub fn new(kind: AddAttachmentsToSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddAttachmentsToSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddAttachmentsToSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_attachment_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            AddAttachmentsToSetErrorKind::AttachmentLimitExceeded(_)
        )
    }
    pub fn is_attachment_set_expired(&self) -> bool {
        matches!(
            &self.kind,
            AddAttachmentsToSetErrorKind::AttachmentSetExpired(_)
        )
    }
    pub fn is_attachment_set_id_not_found(&self) -> bool {
        matches!(
            &self.kind,
            AddAttachmentsToSetErrorKind::AttachmentSetIdNotFound(_)
        )
    }
    pub fn is_attachment_set_size_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            AddAttachmentsToSetErrorKind::AttachmentSetSizeLimitExceeded(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            AddAttachmentsToSetErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for AddAttachmentsToSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddAttachmentsToSetErrorKind::AttachmentLimitExceeded(_inner) => Some(_inner),
            AddAttachmentsToSetErrorKind::AttachmentSetExpired(_inner) => Some(_inner),
            AddAttachmentsToSetErrorKind::AttachmentSetIdNotFound(_inner) => Some(_inner),
            AddAttachmentsToSetErrorKind::AttachmentSetSizeLimitExceeded(_inner) => Some(_inner),
            AddAttachmentsToSetErrorKind::InternalServerError(_inner) => Some(_inner),
            AddAttachmentsToSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddCommunicationToCaseError {
    pub kind: AddCommunicationToCaseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddCommunicationToCaseErrorKind {
    AttachmentSetExpired(crate::error::AttachmentSetExpired),
    AttachmentSetIdNotFound(crate::error::AttachmentSetIdNotFound),
    CaseIdNotFound(crate::error::CaseIdNotFound),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddCommunicationToCaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddCommunicationToCaseErrorKind::AttachmentSetExpired(_inner) => _inner.fmt(f),
            AddCommunicationToCaseErrorKind::AttachmentSetIdNotFound(_inner) => _inner.fmt(f),
            AddCommunicationToCaseErrorKind::CaseIdNotFound(_inner) => _inner.fmt(f),
            AddCommunicationToCaseErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            AddCommunicationToCaseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddCommunicationToCaseError {
    fn code(&self) -> Option<&str> {
        AddCommunicationToCaseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddCommunicationToCaseError {
    pub fn new(kind: AddCommunicationToCaseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddCommunicationToCaseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddCommunicationToCaseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_attachment_set_expired(&self) -> bool {
        matches!(
            &self.kind,
            AddCommunicationToCaseErrorKind::AttachmentSetExpired(_)
        )
    }
    pub fn is_attachment_set_id_not_found(&self) -> bool {
        matches!(
            &self.kind,
            AddCommunicationToCaseErrorKind::AttachmentSetIdNotFound(_)
        )
    }
    pub fn is_case_id_not_found(&self) -> bool {
        matches!(
            &self.kind,
            AddCommunicationToCaseErrorKind::CaseIdNotFound(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            AddCommunicationToCaseErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for AddCommunicationToCaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddCommunicationToCaseErrorKind::AttachmentSetExpired(_inner) => Some(_inner),
            AddCommunicationToCaseErrorKind::AttachmentSetIdNotFound(_inner) => Some(_inner),
            AddCommunicationToCaseErrorKind::CaseIdNotFound(_inner) => Some(_inner),
            AddCommunicationToCaseErrorKind::InternalServerError(_inner) => Some(_inner),
            AddCommunicationToCaseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCaseError {
    pub kind: CreateCaseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCaseErrorKind {
    AttachmentSetExpired(crate::error::AttachmentSetExpired),
    AttachmentSetIdNotFound(crate::error::AttachmentSetIdNotFound),
    CaseCreationLimitExceeded(crate::error::CaseCreationLimitExceeded),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCaseErrorKind::AttachmentSetExpired(_inner) => _inner.fmt(f),
            CreateCaseErrorKind::AttachmentSetIdNotFound(_inner) => _inner.fmt(f),
            CreateCaseErrorKind::CaseCreationLimitExceeded(_inner) => _inner.fmt(f),
            CreateCaseErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateCaseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCaseError {
    fn code(&self) -> Option<&str> {
        CreateCaseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCaseError {
    pub fn new(kind: CreateCaseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCaseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCaseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_attachment_set_expired(&self) -> bool {
        matches!(&self.kind, CreateCaseErrorKind::AttachmentSetExpired(_))
    }
    pub fn is_attachment_set_id_not_found(&self) -> bool {
        matches!(&self.kind, CreateCaseErrorKind::AttachmentSetIdNotFound(_))
    }
    pub fn is_case_creation_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            CreateCaseErrorKind::CaseCreationLimitExceeded(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, CreateCaseErrorKind::InternalServerError(_))
    }
}
impl std::error::Error for CreateCaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCaseErrorKind::AttachmentSetExpired(_inner) => Some(_inner),
            CreateCaseErrorKind::AttachmentSetIdNotFound(_inner) => Some(_inner),
            CreateCaseErrorKind::CaseCreationLimitExceeded(_inner) => Some(_inner),
            CreateCaseErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateCaseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAttachmentError {
    pub kind: DescribeAttachmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAttachmentErrorKind {
    AttachmentIdNotFound(crate::error::AttachmentIdNotFound),
    DescribeAttachmentLimitExceeded(crate::error::DescribeAttachmentLimitExceeded),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAttachmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAttachmentErrorKind::AttachmentIdNotFound(_inner) => _inner.fmt(f),
            DescribeAttachmentErrorKind::DescribeAttachmentLimitExceeded(_inner) => _inner.fmt(f),
            DescribeAttachmentErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeAttachmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAttachmentError {
    fn code(&self) -> Option<&str> {
        DescribeAttachmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAttachmentError {
    pub fn new(kind: DescribeAttachmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAttachmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAttachmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_attachment_id_not_found(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAttachmentErrorKind::AttachmentIdNotFound(_)
        )
    }
    pub fn is_describe_attachment_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAttachmentErrorKind::DescribeAttachmentLimitExceeded(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAttachmentErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeAttachmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAttachmentErrorKind::AttachmentIdNotFound(_inner) => Some(_inner),
            DescribeAttachmentErrorKind::DescribeAttachmentLimitExceeded(_inner) => Some(_inner),
            DescribeAttachmentErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeAttachmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCasesError {
    pub kind: DescribeCasesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCasesErrorKind {
    CaseIdNotFound(crate::error::CaseIdNotFound),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCasesErrorKind::CaseIdNotFound(_inner) => _inner.fmt(f),
            DescribeCasesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeCasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCasesError {
    fn code(&self) -> Option<&str> {
        DescribeCasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCasesError {
    pub fn new(kind: DescribeCasesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCasesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_case_id_not_found(&self) -> bool {
        matches!(&self.kind, DescribeCasesErrorKind::CaseIdNotFound(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DescribeCasesErrorKind::InternalServerError(_))
    }
}
impl std::error::Error for DescribeCasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCasesErrorKind::CaseIdNotFound(_inner) => Some(_inner),
            DescribeCasesErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeCasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCommunicationsError {
    pub kind: DescribeCommunicationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCommunicationsErrorKind {
    CaseIdNotFound(crate::error::CaseIdNotFound),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCommunicationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCommunicationsErrorKind::CaseIdNotFound(_inner) => _inner.fmt(f),
            DescribeCommunicationsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeCommunicationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCommunicationsError {
    fn code(&self) -> Option<&str> {
        DescribeCommunicationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCommunicationsError {
    pub fn new(kind: DescribeCommunicationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCommunicationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCommunicationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_case_id_not_found(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCommunicationsErrorKind::CaseIdNotFound(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCommunicationsErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeCommunicationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCommunicationsErrorKind::CaseIdNotFound(_inner) => Some(_inner),
            DescribeCommunicationsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeCommunicationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeServicesError {
    pub kind: DescribeServicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeServicesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeServicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeServicesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeServicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeServicesError {
    fn code(&self) -> Option<&str> {
        DescribeServicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeServicesError {
    pub fn new(kind: DescribeServicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeServicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeServicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeServicesErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeServicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeServicesErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeServicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeSeverityLevelsError {
    pub kind: DescribeSeverityLevelsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSeverityLevelsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeSeverityLevelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeSeverityLevelsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeSeverityLevelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeSeverityLevelsError {
    fn code(&self) -> Option<&str> {
        DescribeSeverityLevelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSeverityLevelsError {
    pub fn new(kind: DescribeSeverityLevelsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeSeverityLevelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeSeverityLevelsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSeverityLevelsErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeSeverityLevelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeSeverityLevelsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeSeverityLevelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTrustedAdvisorCheckRefreshStatusesError {
    pub kind: DescribeTrustedAdvisorCheckRefreshStatusesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTrustedAdvisorCheckRefreshStatusesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTrustedAdvisorCheckRefreshStatusesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTrustedAdvisorCheckRefreshStatusesErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            DescribeTrustedAdvisorCheckRefreshStatusesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTrustedAdvisorCheckRefreshStatusesError {
    fn code(&self) -> Option<&str> {
        DescribeTrustedAdvisorCheckRefreshStatusesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTrustedAdvisorCheckRefreshStatusesError {
    pub fn new(
        kind: DescribeTrustedAdvisorCheckRefreshStatusesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTrustedAdvisorCheckRefreshStatusesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTrustedAdvisorCheckRefreshStatusesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTrustedAdvisorCheckRefreshStatusesErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeTrustedAdvisorCheckRefreshStatusesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTrustedAdvisorCheckRefreshStatusesErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            DescribeTrustedAdvisorCheckRefreshStatusesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTrustedAdvisorCheckResultError {
    pub kind: DescribeTrustedAdvisorCheckResultErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTrustedAdvisorCheckResultErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTrustedAdvisorCheckResultError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTrustedAdvisorCheckResultErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            DescribeTrustedAdvisorCheckResultErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTrustedAdvisorCheckResultError {
    fn code(&self) -> Option<&str> {
        DescribeTrustedAdvisorCheckResultError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTrustedAdvisorCheckResultError {
    pub fn new(
        kind: DescribeTrustedAdvisorCheckResultErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTrustedAdvisorCheckResultErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTrustedAdvisorCheckResultErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTrustedAdvisorCheckResultErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeTrustedAdvisorCheckResultError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTrustedAdvisorCheckResultErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeTrustedAdvisorCheckResultErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTrustedAdvisorChecksError {
    pub kind: DescribeTrustedAdvisorChecksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTrustedAdvisorChecksErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTrustedAdvisorChecksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTrustedAdvisorChecksErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeTrustedAdvisorChecksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTrustedAdvisorChecksError {
    fn code(&self) -> Option<&str> {
        DescribeTrustedAdvisorChecksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTrustedAdvisorChecksError {
    pub fn new(kind: DescribeTrustedAdvisorChecksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTrustedAdvisorChecksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTrustedAdvisorChecksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTrustedAdvisorChecksErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeTrustedAdvisorChecksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTrustedAdvisorChecksErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeTrustedAdvisorChecksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTrustedAdvisorCheckSummariesError {
    pub kind: DescribeTrustedAdvisorCheckSummariesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTrustedAdvisorCheckSummariesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTrustedAdvisorCheckSummariesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTrustedAdvisorCheckSummariesErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            DescribeTrustedAdvisorCheckSummariesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTrustedAdvisorCheckSummariesError {
    fn code(&self) -> Option<&str> {
        DescribeTrustedAdvisorCheckSummariesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTrustedAdvisorCheckSummariesError {
    pub fn new(
        kind: DescribeTrustedAdvisorCheckSummariesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTrustedAdvisorCheckSummariesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTrustedAdvisorCheckSummariesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTrustedAdvisorCheckSummariesErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeTrustedAdvisorCheckSummariesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTrustedAdvisorCheckSummariesErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            DescribeTrustedAdvisorCheckSummariesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RefreshTrustedAdvisorCheckError {
    pub kind: RefreshTrustedAdvisorCheckErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RefreshTrustedAdvisorCheckErrorKind {
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RefreshTrustedAdvisorCheckError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RefreshTrustedAdvisorCheckErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            RefreshTrustedAdvisorCheckErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RefreshTrustedAdvisorCheckError {
    fn code(&self) -> Option<&str> {
        RefreshTrustedAdvisorCheckError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RefreshTrustedAdvisorCheckError {
    pub fn new(kind: RefreshTrustedAdvisorCheckErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RefreshTrustedAdvisorCheckErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RefreshTrustedAdvisorCheckErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            RefreshTrustedAdvisorCheckErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for RefreshTrustedAdvisorCheckError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RefreshTrustedAdvisorCheckErrorKind::InternalServerError(_inner) => Some(_inner),
            RefreshTrustedAdvisorCheckErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResolveCaseError {
    pub kind: ResolveCaseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResolveCaseErrorKind {
    CaseIdNotFound(crate::error::CaseIdNotFound),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResolveCaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResolveCaseErrorKind::CaseIdNotFound(_inner) => _inner.fmt(f),
            ResolveCaseErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ResolveCaseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResolveCaseError {
    fn code(&self) -> Option<&str> {
        ResolveCaseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResolveCaseError {
    pub fn new(kind: ResolveCaseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResolveCaseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResolveCaseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_case_id_not_found(&self) -> bool {
        matches!(&self.kind, ResolveCaseErrorKind::CaseIdNotFound(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, ResolveCaseErrorKind::InternalServerError(_))
    }
}
impl std::error::Error for ResolveCaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResolveCaseErrorKind::CaseIdNotFound(_inner) => Some(_inner),
            ResolveCaseErrorKind::InternalServerError(_inner) => Some(_inner),
            ResolveCaseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>An internal server error occurred.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerError {
    /// <p>An internal server error occurred.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServerError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerError")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerError {}
/// See [`InternalServerError`](crate::error::InternalServerError)
pub mod internal_server_error {
    /// A builder for [`InternalServerError`](crate::error::InternalServerError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An internal server error occurred.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerError`](crate::error::InternalServerError)
        pub fn build(self) -> crate::error::InternalServerError {
            crate::error::InternalServerError {
                message: self.message,
            }
        }
    }
}
impl InternalServerError {
    /// Creates a new builder-style object to manufacture [`InternalServerError`](crate::error::InternalServerError)
    pub fn builder() -> crate::error::internal_server_error::Builder {
        crate::error::internal_server_error::Builder::default()
    }
}

/// <p>The requested <code>caseId</code> couldn't be located.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CaseIdNotFound {
    /// <p>The requested <code>CaseId</code> could not be located.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CaseIdNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CaseIdNotFound");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CaseIdNotFound {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CaseIdNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CaseIdNotFound")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for CaseIdNotFound {}
/// See [`CaseIdNotFound`](crate::error::CaseIdNotFound)
pub mod case_id_not_found {
    /// A builder for [`CaseIdNotFound`](crate::error::CaseIdNotFound)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The requested <code>CaseId</code> could not be located.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CaseIdNotFound`](crate::error::CaseIdNotFound)
        pub fn build(self) -> crate::error::CaseIdNotFound {
            crate::error::CaseIdNotFound {
                message: self.message,
            }
        }
    }
}
impl CaseIdNotFound {
    /// Creates a new builder-style object to manufacture [`CaseIdNotFound`](crate::error::CaseIdNotFound)
    pub fn builder() -> crate::error::case_id_not_found::Builder {
        crate::error::case_id_not_found::Builder::default()
    }
}

/// <p>The limit for the number of <a>DescribeAttachment</a> requests in a short
/// period of time has been exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAttachmentLimitExceeded {
    /// <p>The limit for the number of <a>DescribeAttachment</a> requests in a short
    /// period of time has been exceeded.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeAttachmentLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAttachmentLimitExceeded");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DescribeAttachmentLimitExceeded {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DescribeAttachmentLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DescribeAttachmentLimitExceeded")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for DescribeAttachmentLimitExceeded {}
/// See [`DescribeAttachmentLimitExceeded`](crate::error::DescribeAttachmentLimitExceeded)
pub mod describe_attachment_limit_exceeded {
    /// A builder for [`DescribeAttachmentLimitExceeded`](crate::error::DescribeAttachmentLimitExceeded)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The limit for the number of <a>DescribeAttachment</a> requests in a short
        /// period of time has been exceeded.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeAttachmentLimitExceeded`](crate::error::DescribeAttachmentLimitExceeded)
        pub fn build(self) -> crate::error::DescribeAttachmentLimitExceeded {
            crate::error::DescribeAttachmentLimitExceeded {
                message: self.message,
            }
        }
    }
}
impl DescribeAttachmentLimitExceeded {
    /// Creates a new builder-style object to manufacture [`DescribeAttachmentLimitExceeded`](crate::error::DescribeAttachmentLimitExceeded)
    pub fn builder() -> crate::error::describe_attachment_limit_exceeded::Builder {
        crate::error::describe_attachment_limit_exceeded::Builder::default()
    }
}

/// <p>An attachment with the specified ID could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachmentIdNotFound {
    /// <p>An attachment with the specified ID could not be found.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AttachmentIdNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachmentIdNotFound");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AttachmentIdNotFound {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AttachmentIdNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AttachmentIdNotFound")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for AttachmentIdNotFound {}
/// See [`AttachmentIdNotFound`](crate::error::AttachmentIdNotFound)
pub mod attachment_id_not_found {
    /// A builder for [`AttachmentIdNotFound`](crate::error::AttachmentIdNotFound)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An attachment with the specified ID could not be found.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachmentIdNotFound`](crate::error::AttachmentIdNotFound)
        pub fn build(self) -> crate::error::AttachmentIdNotFound {
            crate::error::AttachmentIdNotFound {
                message: self.message,
            }
        }
    }
}
impl AttachmentIdNotFound {
    /// Creates a new builder-style object to manufacture [`AttachmentIdNotFound`](crate::error::AttachmentIdNotFound)
    pub fn builder() -> crate::error::attachment_id_not_found::Builder {
        crate::error::attachment_id_not_found::Builder::default()
    }
}

/// <p>The case creation limit for the account has been exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CaseCreationLimitExceeded {
    /// <p>An error message that indicates that you have exceeded the number of cases you can
    /// have open.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CaseCreationLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CaseCreationLimitExceeded");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CaseCreationLimitExceeded {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CaseCreationLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CaseCreationLimitExceeded")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for CaseCreationLimitExceeded {}
/// See [`CaseCreationLimitExceeded`](crate::error::CaseCreationLimitExceeded)
pub mod case_creation_limit_exceeded {
    /// A builder for [`CaseCreationLimitExceeded`](crate::error::CaseCreationLimitExceeded)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An error message that indicates that you have exceeded the number of cases you can
        /// have open.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CaseCreationLimitExceeded`](crate::error::CaseCreationLimitExceeded)
        pub fn build(self) -> crate::error::CaseCreationLimitExceeded {
            crate::error::CaseCreationLimitExceeded {
                message: self.message,
            }
        }
    }
}
impl CaseCreationLimitExceeded {
    /// Creates a new builder-style object to manufacture [`CaseCreationLimitExceeded`](crate::error::CaseCreationLimitExceeded)
    pub fn builder() -> crate::error::case_creation_limit_exceeded::Builder {
        crate::error::case_creation_limit_exceeded::Builder::default()
    }
}

/// <p>An attachment set with the specified ID could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachmentSetIdNotFound {
    /// <p>An attachment set with the specified ID could not be found.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AttachmentSetIdNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachmentSetIdNotFound");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AttachmentSetIdNotFound {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AttachmentSetIdNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AttachmentSetIdNotFound")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for AttachmentSetIdNotFound {}
/// See [`AttachmentSetIdNotFound`](crate::error::AttachmentSetIdNotFound)
pub mod attachment_set_id_not_found {
    /// A builder for [`AttachmentSetIdNotFound`](crate::error::AttachmentSetIdNotFound)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An attachment set with the specified ID could not be found.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachmentSetIdNotFound`](crate::error::AttachmentSetIdNotFound)
        pub fn build(self) -> crate::error::AttachmentSetIdNotFound {
            crate::error::AttachmentSetIdNotFound {
                message: self.message,
            }
        }
    }
}
impl AttachmentSetIdNotFound {
    /// Creates a new builder-style object to manufacture [`AttachmentSetIdNotFound`](crate::error::AttachmentSetIdNotFound)
    pub fn builder() -> crate::error::attachment_set_id_not_found::Builder {
        crate::error::attachment_set_id_not_found::Builder::default()
    }
}

/// <p>The expiration time of the attachment set has passed. The set expires 1 hour after it
/// is created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachmentSetExpired {
    /// <p>The expiration time of the attachment set has passed. The set expires one hour after
    /// it is created.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AttachmentSetExpired {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachmentSetExpired");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AttachmentSetExpired {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AttachmentSetExpired {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AttachmentSetExpired")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for AttachmentSetExpired {}
/// See [`AttachmentSetExpired`](crate::error::AttachmentSetExpired)
pub mod attachment_set_expired {
    /// A builder for [`AttachmentSetExpired`](crate::error::AttachmentSetExpired)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The expiration time of the attachment set has passed. The set expires one hour after
        /// it is created.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachmentSetExpired`](crate::error::AttachmentSetExpired)
        pub fn build(self) -> crate::error::AttachmentSetExpired {
            crate::error::AttachmentSetExpired {
                message: self.message,
            }
        }
    }
}
impl AttachmentSetExpired {
    /// Creates a new builder-style object to manufacture [`AttachmentSetExpired`](crate::error::AttachmentSetExpired)
    pub fn builder() -> crate::error::attachment_set_expired::Builder {
        crate::error::attachment_set_expired::Builder::default()
    }
}

/// <p>A limit for the size of an attachment set has been exceeded. The limits are three
/// attachments and 5 MB per attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachmentSetSizeLimitExceeded {
    /// <p>A limit for the size of an attachment set has been exceeded. The limits are three
    /// attachments and 5 MB per attachment.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AttachmentSetSizeLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachmentSetSizeLimitExceeded");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AttachmentSetSizeLimitExceeded {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AttachmentSetSizeLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AttachmentSetSizeLimitExceeded")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for AttachmentSetSizeLimitExceeded {}
/// See [`AttachmentSetSizeLimitExceeded`](crate::error::AttachmentSetSizeLimitExceeded)
pub mod attachment_set_size_limit_exceeded {
    /// A builder for [`AttachmentSetSizeLimitExceeded`](crate::error::AttachmentSetSizeLimitExceeded)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A limit for the size of an attachment set has been exceeded. The limits are three
        /// attachments and 5 MB per attachment.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachmentSetSizeLimitExceeded`](crate::error::AttachmentSetSizeLimitExceeded)
        pub fn build(self) -> crate::error::AttachmentSetSizeLimitExceeded {
            crate::error::AttachmentSetSizeLimitExceeded {
                message: self.message,
            }
        }
    }
}
impl AttachmentSetSizeLimitExceeded {
    /// Creates a new builder-style object to manufacture [`AttachmentSetSizeLimitExceeded`](crate::error::AttachmentSetSizeLimitExceeded)
    pub fn builder() -> crate::error::attachment_set_size_limit_exceeded::Builder {
        crate::error::attachment_set_size_limit_exceeded::Builder::default()
    }
}

/// <p>The limit for the number of attachment sets created in a short period of time has been
/// exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachmentLimitExceeded {
    /// <p>The limit for the number of attachment sets created in a short period of time has been
    /// exceeded.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AttachmentLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachmentLimitExceeded");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AttachmentLimitExceeded {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AttachmentLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AttachmentLimitExceeded")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for AttachmentLimitExceeded {}
/// See [`AttachmentLimitExceeded`](crate::error::AttachmentLimitExceeded)
pub mod attachment_limit_exceeded {
    /// A builder for [`AttachmentLimitExceeded`](crate::error::AttachmentLimitExceeded)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The limit for the number of attachment sets created in a short period of time has been
        /// exceeded.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachmentLimitExceeded`](crate::error::AttachmentLimitExceeded)
        pub fn build(self) -> crate::error::AttachmentLimitExceeded {
            crate::error::AttachmentLimitExceeded {
                message: self.message,
            }
        }
    }
}
impl AttachmentLimitExceeded {
    /// Creates a new builder-style object to manufacture [`AttachmentLimitExceeded`](crate::error::AttachmentLimitExceeded)
    pub fn builder() -> crate::error::attachment_limit_exceeded::Builder {
        crate::error::attachment_limit_exceeded::Builder::default()
    }
}
