// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_delete_builds_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchDeleteBuildsOutput, crate::error::BatchDeleteBuildsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::BatchDeleteBuildsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::BatchDeleteBuildsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::BatchDeleteBuildsError { meta: generic, kind: crate::error::BatchDeleteBuildsErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDeleteBuildsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchDeleteBuildsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_delete_builds_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchDeleteBuildsOutput, crate::error::BatchDeleteBuildsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_delete_builds_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_batch_delete_builds(response.body().as_ref(), output).map_err(crate::error::BatchDeleteBuildsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_build_batches_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchGetBuildBatchesOutput, crate::error::BatchGetBuildBatchesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::BatchGetBuildBatchesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::BatchGetBuildBatchesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::BatchGetBuildBatchesError { meta: generic, kind: crate::error::BatchGetBuildBatchesErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetBuildBatchesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchGetBuildBatchesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_build_batches_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchGetBuildBatchesOutput, crate::error::BatchGetBuildBatchesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_get_build_batches_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_batch_get_build_batches(response.body().as_ref(), output).map_err(crate::error::BatchGetBuildBatchesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_builds_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchGetBuildsOutput, crate::error::BatchGetBuildsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::BatchGetBuildsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::BatchGetBuildsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::BatchGetBuildsError { meta: generic, kind: crate::error::BatchGetBuildsErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetBuildsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchGetBuildsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_builds_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchGetBuildsOutput, crate::error::BatchGetBuildsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_get_builds_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_batch_get_builds(response.body().as_ref(), output).map_err(crate::error::BatchGetBuildsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_projects_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchGetProjectsOutput, crate::error::BatchGetProjectsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::BatchGetProjectsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::BatchGetProjectsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::BatchGetProjectsError { meta: generic, kind: crate::error::BatchGetProjectsErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetProjectsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchGetProjectsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_projects_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchGetProjectsOutput, crate::error::BatchGetProjectsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_get_projects_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_batch_get_projects(response.body().as_ref(), output).map_err(crate::error::BatchGetProjectsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_report_groups_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchGetReportGroupsOutput, crate::error::BatchGetReportGroupsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::BatchGetReportGroupsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::BatchGetReportGroupsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::BatchGetReportGroupsError { meta: generic, kind: crate::error::BatchGetReportGroupsErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetReportGroupsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchGetReportGroupsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_report_groups_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchGetReportGroupsOutput, crate::error::BatchGetReportGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_get_report_groups_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_batch_get_report_groups(response.body().as_ref(), output).map_err(crate::error::BatchGetReportGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_reports_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchGetReportsOutput, crate::error::BatchGetReportsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::BatchGetReportsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::BatchGetReportsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::BatchGetReportsError { meta: generic, kind: crate::error::BatchGetReportsErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetReportsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchGetReportsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_reports_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchGetReportsOutput, crate::error::BatchGetReportsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_get_reports_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_batch_get_reports(response.body().as_ref(), output).map_err(crate::error::BatchGetReportsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_project_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateProjectOutput, crate::error::CreateProjectError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateProjectError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateProjectError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AccountLimitExceededException" => crate::error::CreateProjectError { meta: generic, kind: crate::error::CreateProjectErrorKind::AccountLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::account_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_account_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateProjectError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidInputException" => crate::error::CreateProjectError { meta: generic, kind: crate::error::CreateProjectErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateProjectError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceAlreadyExistsException" => crate::error::CreateProjectError { meta: generic, kind: crate::error::CreateProjectErrorKind::ResourceAlreadyExistsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateProjectError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateProjectError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_project_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateProjectOutput, crate::error::CreateProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_project_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_project(response.body().as_ref(), output).map_err(crate::error::CreateProjectError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_report_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateReportGroupOutput, crate::error::CreateReportGroupError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateReportGroupError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateReportGroupError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AccountLimitExceededException" => crate::error::CreateReportGroupError { meta: generic, kind: crate::error::CreateReportGroupErrorKind::AccountLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::account_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_account_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateReportGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidInputException" => crate::error::CreateReportGroupError { meta: generic, kind: crate::error::CreateReportGroupErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateReportGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceAlreadyExistsException" => crate::error::CreateReportGroupError { meta: generic, kind: crate::error::CreateReportGroupErrorKind::ResourceAlreadyExistsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateReportGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateReportGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_report_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateReportGroupOutput, crate::error::CreateReportGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_report_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_report_group(response.body().as_ref(), output).map_err(crate::error::CreateReportGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_webhook_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateWebhookOutput, crate::error::CreateWebhookError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateWebhookError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateWebhookError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::CreateWebhookError { meta: generic, kind: crate::error::CreateWebhookErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateWebhookError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OAuthProviderException" => crate::error::CreateWebhookError { meta: generic, kind: crate::error::CreateWebhookErrorKind::OAuthProviderException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::o_auth_provider_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_o_auth_provider_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateWebhookError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceAlreadyExistsException" => crate::error::CreateWebhookError { meta: generic, kind: crate::error::CreateWebhookErrorKind::ResourceAlreadyExistsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateWebhookError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::CreateWebhookError { meta: generic, kind: crate::error::CreateWebhookErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateWebhookError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateWebhookError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_webhook_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateWebhookOutput, crate::error::CreateWebhookError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_webhook_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_webhook(response.body().as_ref(), output).map_err(crate::error::CreateWebhookError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_build_batch_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteBuildBatchOutput, crate::error::DeleteBuildBatchError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteBuildBatchError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteBuildBatchError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::DeleteBuildBatchError { meta: generic, kind: crate::error::DeleteBuildBatchErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBuildBatchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteBuildBatchError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_build_batch_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteBuildBatchOutput, crate::error::DeleteBuildBatchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_build_batch_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_build_batch(response.body().as_ref(), output).map_err(crate::error::DeleteBuildBatchError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_project_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteProjectOutput, crate::error::DeleteProjectError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteProjectError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteProjectError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::DeleteProjectError { meta: generic, kind: crate::error::DeleteProjectErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteProjectError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteProjectError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_project_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteProjectOutput, crate::error::DeleteProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_project_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_report_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteReportOutput, crate::error::DeleteReportError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteReportError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteReportError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::DeleteReportError { meta: generic, kind: crate::error::DeleteReportErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteReportError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteReportError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_report_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteReportOutput, crate::error::DeleteReportError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_report_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_report_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteReportGroupOutput, crate::error::DeleteReportGroupError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteReportGroupError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteReportGroupError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::DeleteReportGroupError { meta: generic, kind: crate::error::DeleteReportGroupErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteReportGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteReportGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_report_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteReportGroupOutput, crate::error::DeleteReportGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_report_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteResourcePolicyOutput, crate::error::DeleteResourcePolicyError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteResourcePolicyError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteResourcePolicyError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::DeleteResourcePolicyError { meta: generic, kind: crate::error::DeleteResourcePolicyErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourcePolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteResourcePolicyError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteResourcePolicyOutput, crate::error::DeleteResourcePolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_resource_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_source_credentials_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteSourceCredentialsOutput, crate::error::DeleteSourceCredentialsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteSourceCredentialsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteSourceCredentialsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::DeleteSourceCredentialsError { meta: generic, kind: crate::error::DeleteSourceCredentialsErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteSourceCredentialsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::DeleteSourceCredentialsError { meta: generic, kind: crate::error::DeleteSourceCredentialsErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteSourceCredentialsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteSourceCredentialsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_source_credentials_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteSourceCredentialsOutput, crate::error::DeleteSourceCredentialsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_source_credentials_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_source_credentials(response.body().as_ref(), output).map_err(crate::error::DeleteSourceCredentialsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_webhook_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteWebhookOutput, crate::error::DeleteWebhookError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteWebhookError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteWebhookError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::DeleteWebhookError { meta: generic, kind: crate::error::DeleteWebhookErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteWebhookError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OAuthProviderException" => crate::error::DeleteWebhookError { meta: generic, kind: crate::error::DeleteWebhookErrorKind::OAuthProviderException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::o_auth_provider_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_o_auth_provider_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteWebhookError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::DeleteWebhookError { meta: generic, kind: crate::error::DeleteWebhookErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteWebhookError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteWebhookError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_webhook_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteWebhookOutput, crate::error::DeleteWebhookError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_webhook_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_code_coverages_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeCodeCoveragesOutput, crate::error::DescribeCodeCoveragesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeCodeCoveragesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeCodeCoveragesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::DescribeCodeCoveragesError { meta: generic, kind: crate::error::DescribeCodeCoveragesErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeCodeCoveragesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeCodeCoveragesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_code_coverages_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeCodeCoveragesOutput, crate::error::DescribeCodeCoveragesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_code_coverages_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_code_coverages(response.body().as_ref(), output).map_err(crate::error::DescribeCodeCoveragesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_test_cases_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTestCasesOutput, crate::error::DescribeTestCasesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeTestCasesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeTestCasesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::DescribeTestCasesError { meta: generic, kind: crate::error::DescribeTestCasesErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeTestCasesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::DescribeTestCasesError { meta: generic, kind: crate::error::DescribeTestCasesErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeTestCasesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeTestCasesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_test_cases_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTestCasesOutput, crate::error::DescribeTestCasesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_test_cases_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_test_cases(response.body().as_ref(), output).map_err(crate::error::DescribeTestCasesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_report_group_trend_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetReportGroupTrendOutput, crate::error::GetReportGroupTrendError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetReportGroupTrendError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetReportGroupTrendError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::GetReportGroupTrendError { meta: generic, kind: crate::error::GetReportGroupTrendErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetReportGroupTrendError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::GetReportGroupTrendError { meta: generic, kind: crate::error::GetReportGroupTrendErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetReportGroupTrendError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetReportGroupTrendError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_report_group_trend_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetReportGroupTrendOutput, crate::error::GetReportGroupTrendError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_report_group_trend_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_report_group_trend(response.body().as_ref(), output).map_err(crate::error::GetReportGroupTrendError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resource_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetResourcePolicyOutput, crate::error::GetResourcePolicyError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetResourcePolicyError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetResourcePolicyError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::GetResourcePolicyError { meta: generic, kind: crate::error::GetResourcePolicyErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetResourcePolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::GetResourcePolicyError { meta: generic, kind: crate::error::GetResourcePolicyErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetResourcePolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetResourcePolicyError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resource_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetResourcePolicyOutput, crate::error::GetResourcePolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_resource_policy_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_resource_policy(response.body().as_ref(), output).map_err(crate::error::GetResourcePolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_source_credentials_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ImportSourceCredentialsOutput, crate::error::ImportSourceCredentialsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ImportSourceCredentialsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ImportSourceCredentialsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AccountLimitExceededException" => crate::error::ImportSourceCredentialsError { meta: generic, kind: crate::error::ImportSourceCredentialsErrorKind::AccountLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::account_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_account_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ImportSourceCredentialsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidInputException" => crate::error::ImportSourceCredentialsError { meta: generic, kind: crate::error::ImportSourceCredentialsErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ImportSourceCredentialsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceAlreadyExistsException" => crate::error::ImportSourceCredentialsError { meta: generic, kind: crate::error::ImportSourceCredentialsErrorKind::ResourceAlreadyExistsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ImportSourceCredentialsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ImportSourceCredentialsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_source_credentials_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ImportSourceCredentialsOutput, crate::error::ImportSourceCredentialsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_source_credentials_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_import_source_credentials(response.body().as_ref(), output).map_err(crate::error::ImportSourceCredentialsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_invalidate_project_cache_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::InvalidateProjectCacheOutput, crate::error::InvalidateProjectCacheError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::InvalidateProjectCacheError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::InvalidateProjectCacheError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::InvalidateProjectCacheError { meta: generic, kind: crate::error::InvalidateProjectCacheErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::InvalidateProjectCacheError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::InvalidateProjectCacheError { meta: generic, kind: crate::error::InvalidateProjectCacheErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::InvalidateProjectCacheError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::InvalidateProjectCacheError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_invalidate_project_cache_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::InvalidateProjectCacheOutput, crate::error::InvalidateProjectCacheError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::invalidate_project_cache_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_build_batches_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListBuildBatchesOutput, crate::error::ListBuildBatchesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListBuildBatchesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListBuildBatchesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListBuildBatchesError { meta: generic, kind: crate::error::ListBuildBatchesErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBuildBatchesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListBuildBatchesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_build_batches_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListBuildBatchesOutput, crate::error::ListBuildBatchesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_build_batches_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_build_batches(response.body().as_ref(), output).map_err(crate::error::ListBuildBatchesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_build_batches_for_project_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListBuildBatchesForProjectOutput, crate::error::ListBuildBatchesForProjectError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListBuildBatchesForProjectError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListBuildBatchesForProjectError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListBuildBatchesForProjectError { meta: generic, kind: crate::error::ListBuildBatchesForProjectErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBuildBatchesForProjectError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::ListBuildBatchesForProjectError { meta: generic, kind: crate::error::ListBuildBatchesForProjectErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBuildBatchesForProjectError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListBuildBatchesForProjectError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_build_batches_for_project_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListBuildBatchesForProjectOutput, crate::error::ListBuildBatchesForProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_build_batches_for_project_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_build_batches_for_project(response.body().as_ref(), output).map_err(crate::error::ListBuildBatchesForProjectError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_builds_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListBuildsOutput, crate::error::ListBuildsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListBuildsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListBuildsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListBuildsError { meta: generic, kind: crate::error::ListBuildsErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBuildsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListBuildsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_builds_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListBuildsOutput, crate::error::ListBuildsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_builds_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_builds(response.body().as_ref(), output).map_err(crate::error::ListBuildsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_builds_for_project_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListBuildsForProjectOutput, crate::error::ListBuildsForProjectError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListBuildsForProjectError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListBuildsForProjectError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListBuildsForProjectError { meta: generic, kind: crate::error::ListBuildsForProjectErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBuildsForProjectError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::ListBuildsForProjectError { meta: generic, kind: crate::error::ListBuildsForProjectErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBuildsForProjectError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListBuildsForProjectError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_builds_for_project_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListBuildsForProjectOutput, crate::error::ListBuildsForProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_builds_for_project_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_builds_for_project(response.body().as_ref(), output).map_err(crate::error::ListBuildsForProjectError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_curated_environment_images_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListCuratedEnvironmentImagesOutput, crate::error::ListCuratedEnvironmentImagesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListCuratedEnvironmentImagesError::unhandled)?;
    Err(crate::error::ListCuratedEnvironmentImagesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_curated_environment_images_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListCuratedEnvironmentImagesOutput, crate::error::ListCuratedEnvironmentImagesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_curated_environment_images_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_curated_environment_images(response.body().as_ref(), output).map_err(crate::error::ListCuratedEnvironmentImagesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_projects_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListProjectsOutput, crate::error::ListProjectsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListProjectsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListProjectsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListProjectsError { meta: generic, kind: crate::error::ListProjectsErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListProjectsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListProjectsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_projects_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListProjectsOutput, crate::error::ListProjectsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_projects_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_projects(response.body().as_ref(), output).map_err(crate::error::ListProjectsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_report_groups_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListReportGroupsOutput, crate::error::ListReportGroupsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListReportGroupsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListReportGroupsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListReportGroupsError { meta: generic, kind: crate::error::ListReportGroupsErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListReportGroupsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListReportGroupsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_report_groups_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListReportGroupsOutput, crate::error::ListReportGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_report_groups_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_report_groups(response.body().as_ref(), output).map_err(crate::error::ListReportGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_reports_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListReportsOutput, crate::error::ListReportsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListReportsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListReportsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListReportsError { meta: generic, kind: crate::error::ListReportsErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListReportsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListReportsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_reports_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListReportsOutput, crate::error::ListReportsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_reports_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_reports(response.body().as_ref(), output).map_err(crate::error::ListReportsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_reports_for_report_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListReportsForReportGroupOutput, crate::error::ListReportsForReportGroupError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListReportsForReportGroupError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListReportsForReportGroupError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListReportsForReportGroupError { meta: generic, kind: crate::error::ListReportsForReportGroupErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListReportsForReportGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::ListReportsForReportGroupError { meta: generic, kind: crate::error::ListReportsForReportGroupErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListReportsForReportGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListReportsForReportGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_reports_for_report_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListReportsForReportGroupOutput, crate::error::ListReportsForReportGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_reports_for_report_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_reports_for_report_group(response.body().as_ref(), output).map_err(crate::error::ListReportsForReportGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_shared_projects_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListSharedProjectsOutput, crate::error::ListSharedProjectsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListSharedProjectsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListSharedProjectsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListSharedProjectsError { meta: generic, kind: crate::error::ListSharedProjectsErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListSharedProjectsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListSharedProjectsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_shared_projects_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListSharedProjectsOutput, crate::error::ListSharedProjectsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_shared_projects_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_shared_projects(response.body().as_ref(), output).map_err(crate::error::ListSharedProjectsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_shared_report_groups_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListSharedReportGroupsOutput, crate::error::ListSharedReportGroupsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListSharedReportGroupsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListSharedReportGroupsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListSharedReportGroupsError { meta: generic, kind: crate::error::ListSharedReportGroupsErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListSharedReportGroupsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListSharedReportGroupsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_shared_report_groups_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListSharedReportGroupsOutput, crate::error::ListSharedReportGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_shared_report_groups_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_shared_report_groups(response.body().as_ref(), output).map_err(crate::error::ListSharedReportGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_source_credentials_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListSourceCredentialsOutput, crate::error::ListSourceCredentialsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListSourceCredentialsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListSourceCredentialsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListSourceCredentialsError { meta: generic, kind: crate::error::ListSourceCredentialsErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListSourceCredentialsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListSourceCredentialsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_source_credentials_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListSourceCredentialsOutput, crate::error::ListSourceCredentialsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_source_credentials_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_source_credentials(response.body().as_ref(), output).map_err(crate::error::ListSourceCredentialsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_resource_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutResourcePolicyOutput, crate::error::PutResourcePolicyError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::PutResourcePolicyError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::PutResourcePolicyError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::PutResourcePolicyError { meta: generic, kind: crate::error::PutResourcePolicyErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::PutResourcePolicyError { meta: generic, kind: crate::error::PutResourcePolicyErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutResourcePolicyError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_resource_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutResourcePolicyOutput, crate::error::PutResourcePolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_resource_policy_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_resource_policy(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_retry_build_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RetryBuildOutput, crate::error::RetryBuildError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::RetryBuildError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::RetryBuildError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AccountLimitExceededException" => crate::error::RetryBuildError { meta: generic, kind: crate::error::RetryBuildErrorKind::AccountLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::account_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_account_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RetryBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidInputException" => crate::error::RetryBuildError { meta: generic, kind: crate::error::RetryBuildErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RetryBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::RetryBuildError { meta: generic, kind: crate::error::RetryBuildErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RetryBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RetryBuildError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_retry_build_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RetryBuildOutput, crate::error::RetryBuildError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::retry_build_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_retry_build(response.body().as_ref(), output).map_err(crate::error::RetryBuildError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_retry_build_batch_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RetryBuildBatchOutput, crate::error::RetryBuildBatchError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::RetryBuildBatchError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::RetryBuildBatchError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::RetryBuildBatchError { meta: generic, kind: crate::error::RetryBuildBatchErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RetryBuildBatchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::RetryBuildBatchError { meta: generic, kind: crate::error::RetryBuildBatchErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RetryBuildBatchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RetryBuildBatchError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_retry_build_batch_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RetryBuildBatchOutput, crate::error::RetryBuildBatchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::retry_build_batch_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_retry_build_batch(response.body().as_ref(), output).map_err(crate::error::RetryBuildBatchError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_build_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartBuildOutput, crate::error::StartBuildError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::StartBuildError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StartBuildError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AccountLimitExceededException" => crate::error::StartBuildError { meta: generic, kind: crate::error::StartBuildErrorKind::AccountLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::account_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_account_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidInputException" => crate::error::StartBuildError { meta: generic, kind: crate::error::StartBuildErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::StartBuildError { meta: generic, kind: crate::error::StartBuildErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StartBuildError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_build_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartBuildOutput, crate::error::StartBuildError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_build_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_build(response.body().as_ref(), output).map_err(crate::error::StartBuildError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_build_batch_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartBuildBatchOutput, crate::error::StartBuildBatchError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::StartBuildBatchError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StartBuildBatchError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::StartBuildBatchError { meta: generic, kind: crate::error::StartBuildBatchErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartBuildBatchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::StartBuildBatchError { meta: generic, kind: crate::error::StartBuildBatchErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartBuildBatchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StartBuildBatchError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_build_batch_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartBuildBatchOutput, crate::error::StartBuildBatchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_build_batch_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_build_batch(response.body().as_ref(), output).map_err(crate::error::StartBuildBatchError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_build_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopBuildOutput, crate::error::StopBuildError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::StopBuildError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StopBuildError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::StopBuildError { meta: generic, kind: crate::error::StopBuildErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::StopBuildError { meta: generic, kind: crate::error::StopBuildErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopBuildError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StopBuildError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_build_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopBuildOutput, crate::error::StopBuildError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_build_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_stop_build(response.body().as_ref(), output).map_err(crate::error::StopBuildError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_build_batch_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopBuildBatchOutput, crate::error::StopBuildBatchError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::StopBuildBatchError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StopBuildBatchError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::StopBuildBatchError { meta: generic, kind: crate::error::StopBuildBatchErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopBuildBatchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::StopBuildBatchError { meta: generic, kind: crate::error::StopBuildBatchErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopBuildBatchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StopBuildBatchError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_build_batch_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopBuildBatchOutput, crate::error::StopBuildBatchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_build_batch_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_stop_build_batch(response.body().as_ref(), output).map_err(crate::error::StopBuildBatchError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_project_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateProjectOutput, crate::error::UpdateProjectError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateProjectError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateProjectError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::UpdateProjectError { meta: generic, kind: crate::error::UpdateProjectErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateProjectError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::UpdateProjectError { meta: generic, kind: crate::error::UpdateProjectErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateProjectError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateProjectError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_project_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateProjectOutput, crate::error::UpdateProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_project_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_project(response.body().as_ref(), output).map_err(crate::error::UpdateProjectError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_project_visibility_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateProjectVisibilityOutput, crate::error::UpdateProjectVisibilityError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateProjectVisibilityError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateProjectVisibilityError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::UpdateProjectVisibilityError { meta: generic, kind: crate::error::UpdateProjectVisibilityErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateProjectVisibilityError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::UpdateProjectVisibilityError { meta: generic, kind: crate::error::UpdateProjectVisibilityErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateProjectVisibilityError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateProjectVisibilityError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_project_visibility_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateProjectVisibilityOutput, crate::error::UpdateProjectVisibilityError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_project_visibility_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_project_visibility(response.body().as_ref(), output).map_err(crate::error::UpdateProjectVisibilityError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_report_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateReportGroupOutput, crate::error::UpdateReportGroupError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateReportGroupError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateReportGroupError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::UpdateReportGroupError { meta: generic, kind: crate::error::UpdateReportGroupErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateReportGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::UpdateReportGroupError { meta: generic, kind: crate::error::UpdateReportGroupErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateReportGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateReportGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_report_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateReportGroupOutput, crate::error::UpdateReportGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_report_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_report_group(response.body().as_ref(), output).map_err(crate::error::UpdateReportGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_webhook_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateWebhookOutput, crate::error::UpdateWebhookError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateWebhookError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateWebhookError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::UpdateWebhookError { meta: generic, kind: crate::error::UpdateWebhookErrorKind::InvalidInputException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_input_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateWebhookError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OAuthProviderException" => crate::error::UpdateWebhookError { meta: generic, kind: crate::error::UpdateWebhookErrorKind::OAuthProviderException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::o_auth_provider_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_o_auth_provider_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateWebhookError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::UpdateWebhookError { meta: generic, kind: crate::error::UpdateWebhookErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateWebhookError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateWebhookError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_webhook_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateWebhookOutput, crate::error::UpdateWebhookError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_webhook_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_webhook(response.body().as_ref(), output).map_err(crate::error::UpdateWebhookError::unhandled)?;
        output.build()
    })
}

