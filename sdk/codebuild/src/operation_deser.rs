// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_delete_builds_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::BatchDeleteBuildsOutput, crate::error::BatchDeleteBuildsError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::BatchDeleteBuildsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::BatchDeleteBuildsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::BatchDeleteBuildsError {
            meta: generic,
            kind: crate::error::BatchDeleteBuildsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::BatchDeleteBuildsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::BatchDeleteBuildsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_delete_builds_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::BatchDeleteBuildsOutput, crate::error::BatchDeleteBuildsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_delete_builds_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_batch_delete_builds(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::BatchDeleteBuildsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_build_batches_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchGetBuildBatchesOutput,
    crate::error::BatchGetBuildBatchesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::BatchGetBuildBatchesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::BatchGetBuildBatchesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::BatchGetBuildBatchesError {
            meta: generic,
            kind: crate::error::BatchGetBuildBatchesErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::BatchGetBuildBatchesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::BatchGetBuildBatchesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_build_batches_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchGetBuildBatchesOutput,
    crate::error::BatchGetBuildBatchesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_get_build_batches_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_batch_get_build_batches(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::BatchGetBuildBatchesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_builds_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::BatchGetBuildsOutput, crate::error::BatchGetBuildsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::BatchGetBuildsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::BatchGetBuildsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::BatchGetBuildsError {
            meta: generic,
            kind: crate::error::BatchGetBuildsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::BatchGetBuildsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::BatchGetBuildsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_builds_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::BatchGetBuildsOutput, crate::error::BatchGetBuildsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_get_builds_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_batch_get_builds(response.body().as_ref(), output)
                .map_err(crate::error::BatchGetBuildsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_projects_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::BatchGetProjectsOutput, crate::error::BatchGetProjectsError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::BatchGetProjectsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::BatchGetProjectsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::BatchGetProjectsError {
            meta: generic,
            kind: crate::error::BatchGetProjectsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::BatchGetProjectsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::BatchGetProjectsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_projects_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::BatchGetProjectsOutput, crate::error::BatchGetProjectsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_get_projects_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_batch_get_projects(response.body().as_ref(), output)
                .map_err(crate::error::BatchGetProjectsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_report_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchGetReportGroupsOutput,
    crate::error::BatchGetReportGroupsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::BatchGetReportGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::BatchGetReportGroupsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::BatchGetReportGroupsError {
            meta: generic,
            kind: crate::error::BatchGetReportGroupsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::BatchGetReportGroupsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::BatchGetReportGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_report_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchGetReportGroupsOutput,
    crate::error::BatchGetReportGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_get_report_groups_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_batch_get_report_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::BatchGetReportGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_reports_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::BatchGetReportsOutput, crate::error::BatchGetReportsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::BatchGetReportsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::BatchGetReportsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::BatchGetReportsError {
            meta: generic,
            kind: crate::error::BatchGetReportsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::BatchGetReportsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::BatchGetReportsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_reports_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::BatchGetReportsOutput, crate::error::BatchGetReportsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_get_reports_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_batch_get_reports(response.body().as_ref(), output)
                .map_err(crate::error::BatchGetReportsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateProjectOutput, crate::error::CreateProjectError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateProjectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccountLimitExceededException" => crate::error::CreateProjectError {
            meta: generic,
            kind: crate::error::CreateProjectErrorKind::AccountLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::account_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_account_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInputException" => crate::error::CreateProjectError {
            meta: generic,
            kind: crate::error::CreateProjectErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceAlreadyExistsException" => crate::error::CreateProjectError {
            meta: generic,
            kind: crate::error::CreateProjectErrorKind::ResourceAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_resource_already_exists_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateProjectOutput, crate::error::CreateProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_project_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_create_project(response.body().as_ref(), output)
                .map_err(crate::error::CreateProjectError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_report_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateReportGroupOutput, crate::error::CreateReportGroupError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateReportGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateReportGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccountLimitExceededException" => crate::error::CreateReportGroupError {
            meta: generic,
            kind: crate::error::CreateReportGroupErrorKind::AccountLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::account_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_account_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateReportGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInputException" => crate::error::CreateReportGroupError {
            meta: generic,
            kind: crate::error::CreateReportGroupErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateReportGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceAlreadyExistsException" => crate::error::CreateReportGroupError {
            meta: generic,
            kind: crate::error::CreateReportGroupErrorKind::ResourceAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_resource_already_exists_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateReportGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateReportGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_report_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateReportGroupOutput, crate::error::CreateReportGroupError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_report_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_report_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateReportGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_webhook_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateWebhookOutput, crate::error::CreateWebhookError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateWebhookError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateWebhookError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::CreateWebhookError {
            meta: generic,
            kind: crate::error::CreateWebhookErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateWebhookError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OAuthProviderException" => crate::error::CreateWebhookError {
            meta: generic,
            kind: crate::error::CreateWebhookErrorKind::OAuthProviderException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::o_auth_provider_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_o_auth_provider_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateWebhookError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceAlreadyExistsException" => crate::error::CreateWebhookError {
            meta: generic,
            kind: crate::error::CreateWebhookErrorKind::ResourceAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_resource_already_exists_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateWebhookError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::CreateWebhookError {
                meta: generic,
                kind: crate::error::CreateWebhookErrorKind::ResourceNotFoundException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_not_found_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateWebhookError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::CreateWebhookError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_webhook_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateWebhookOutput, crate::error::CreateWebhookError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_webhook_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_create_webhook(response.body().as_ref(), output)
                .map_err(crate::error::CreateWebhookError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_build_batch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteBuildBatchOutput, crate::error::DeleteBuildBatchError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteBuildBatchError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteBuildBatchError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::DeleteBuildBatchError {
            meta: generic,
            kind: crate::error::DeleteBuildBatchErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteBuildBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteBuildBatchError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_build_batch_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteBuildBatchOutput, crate::error::DeleteBuildBatchError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_build_batch_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_delete_build_batch(response.body().as_ref(), output)
                .map_err(crate::error::DeleteBuildBatchError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteProjectOutput, crate::error::DeleteProjectError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteProjectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::DeleteProjectError {
            meta: generic,
            kind: crate::error::DeleteProjectErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteProjectOutput, crate::error::DeleteProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_project_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_report_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteReportOutput, crate::error::DeleteReportError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteReportError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteReportError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::DeleteReportError {
            meta: generic,
            kind: crate::error::DeleteReportErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteReportError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteReportError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_report_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteReportOutput, crate::error::DeleteReportError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_report_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_report_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteReportGroupOutput, crate::error::DeleteReportGroupError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteReportGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteReportGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::DeleteReportGroupError {
            meta: generic,
            kind: crate::error::DeleteReportGroupErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteReportGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteReportGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_report_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteReportGroupOutput, crate::error::DeleteReportGroupError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_report_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteResourcePolicyOutput,
    crate::error::DeleteResourcePolicyError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteResourcePolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteResourcePolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::DeleteResourcePolicyError {
            meta: generic,
            kind: crate::error::DeleteResourcePolicyErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteResourcePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteResourcePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteResourcePolicyOutput,
    crate::error::DeleteResourcePolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_resource_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_source_credentials_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSourceCredentialsOutput,
    crate::error::DeleteSourceCredentialsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteSourceCredentialsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteSourceCredentialsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::DeleteSourceCredentialsError {
            meta: generic,
            kind: crate::error::DeleteSourceCredentialsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteSourceCredentialsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::DeleteSourceCredentialsError {
                meta: generic,
                kind: crate::error::DeleteSourceCredentialsErrorKind::ResourceNotFoundException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_not_found_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteSourceCredentialsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DeleteSourceCredentialsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_source_credentials_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSourceCredentialsOutput,
    crate::error::DeleteSourceCredentialsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_source_credentials_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_delete_source_credentials(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteSourceCredentialsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_webhook_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteWebhookOutput, crate::error::DeleteWebhookError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteWebhookError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteWebhookError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::DeleteWebhookError {
            meta: generic,
            kind: crate::error::DeleteWebhookErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteWebhookError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OAuthProviderException" => crate::error::DeleteWebhookError {
            meta: generic,
            kind: crate::error::DeleteWebhookErrorKind::OAuthProviderException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::o_auth_provider_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_o_auth_provider_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteWebhookError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::DeleteWebhookError {
                meta: generic,
                kind: crate::error::DeleteWebhookErrorKind::ResourceNotFoundException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_not_found_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteWebhookError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DeleteWebhookError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_webhook_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteWebhookOutput, crate::error::DeleteWebhookError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_webhook_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_code_coverages_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCodeCoveragesOutput,
    crate::error::DescribeCodeCoveragesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeCodeCoveragesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeCodeCoveragesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::DescribeCodeCoveragesError {
            meta: generic,
            kind: crate::error::DescribeCodeCoveragesErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeCodeCoveragesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeCodeCoveragesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_code_coverages_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCodeCoveragesOutput,
    crate::error::DescribeCodeCoveragesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_code_coverages_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_code_coverages(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeCodeCoveragesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_test_cases_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeTestCasesOutput, crate::error::DescribeTestCasesError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeTestCasesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeTestCasesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::DescribeTestCasesError {
            meta: generic,
            kind: crate::error::DescribeTestCasesErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeTestCasesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::DescribeTestCasesError {
                meta: generic,
                kind: crate::error::DescribeTestCasesErrorKind::ResourceNotFoundException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_not_found_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeTestCasesError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeTestCasesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_test_cases_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeTestCasesOutput, crate::error::DescribeTestCasesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_test_cases_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_test_cases(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeTestCasesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_report_group_trend_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetReportGroupTrendOutput,
    crate::error::GetReportGroupTrendError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetReportGroupTrendError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetReportGroupTrendError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::GetReportGroupTrendError {
            meta: generic,
            kind: crate::error::GetReportGroupTrendErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetReportGroupTrendError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::GetReportGroupTrendError {
                meta: generic,
                kind: crate::error::GetReportGroupTrendErrorKind::ResourceNotFoundException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_not_found_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetReportGroupTrendError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::GetReportGroupTrendError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_report_group_trend_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetReportGroupTrendOutput,
    crate::error::GetReportGroupTrendError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_report_group_trend_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_report_group_trend(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetReportGroupTrendError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resource_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetResourcePolicyOutput, crate::error::GetResourcePolicyError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetResourcePolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetResourcePolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::GetResourcePolicyError {
            meta: generic,
            kind: crate::error::GetResourcePolicyErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetResourcePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::GetResourcePolicyError {
                meta: generic,
                kind: crate::error::GetResourcePolicyErrorKind::ResourceNotFoundException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_not_found_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetResourcePolicyError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::GetResourcePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resource_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetResourcePolicyOutput, crate::error::GetResourcePolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_resource_policy_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_resource_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetResourcePolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_source_credentials_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ImportSourceCredentialsOutput,
    crate::error::ImportSourceCredentialsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ImportSourceCredentialsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ImportSourceCredentialsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccountLimitExceededException" => crate::error::ImportSourceCredentialsError {
            meta: generic,
            kind: crate::error::ImportSourceCredentialsErrorKind::AccountLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::account_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_account_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ImportSourceCredentialsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInputException" => crate::error::ImportSourceCredentialsError {
            meta: generic,
            kind: crate::error::ImportSourceCredentialsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ImportSourceCredentialsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceAlreadyExistsException" => crate::error::ImportSourceCredentialsError {
            meta: generic,
            kind: crate::error::ImportSourceCredentialsErrorKind::ResourceAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_resource_already_exists_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ImportSourceCredentialsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ImportSourceCredentialsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_source_credentials_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ImportSourceCredentialsOutput,
    crate::error::ImportSourceCredentialsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_source_credentials_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_import_source_credentials(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ImportSourceCredentialsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_invalidate_project_cache_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::InvalidateProjectCacheOutput,
    crate::error::InvalidateProjectCacheError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::InvalidateProjectCacheError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::InvalidateProjectCacheError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::InvalidateProjectCacheError {
            meta: generic,
            kind: crate::error::InvalidateProjectCacheErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::InvalidateProjectCacheError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::InvalidateProjectCacheError {
                meta: generic,
                kind: crate::error::InvalidateProjectCacheErrorKind::ResourceNotFoundException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_not_found_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::InvalidateProjectCacheError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::InvalidateProjectCacheError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_invalidate_project_cache_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::InvalidateProjectCacheOutput,
    crate::error::InvalidateProjectCacheError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::invalidate_project_cache_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_build_batches_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListBuildBatchesOutput, crate::error::ListBuildBatchesError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListBuildBatchesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListBuildBatchesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListBuildBatchesError {
            meta: generic,
            kind: crate::error::ListBuildBatchesErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListBuildBatchesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListBuildBatchesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_build_batches_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListBuildBatchesOutput, crate::error::ListBuildBatchesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_build_batches_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_list_build_batches(response.body().as_ref(), output)
                .map_err(crate::error::ListBuildBatchesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_build_batches_for_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListBuildBatchesForProjectOutput,
    crate::error::ListBuildBatchesForProjectError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListBuildBatchesForProjectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListBuildBatchesForProjectError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListBuildBatchesForProjectError {
            meta: generic,
            kind: crate::error::ListBuildBatchesForProjectErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListBuildBatchesForProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::ListBuildBatchesForProjectError {
                meta: generic,
                kind: crate::error::ListBuildBatchesForProjectErrorKind::ResourceNotFoundException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::resource_not_found_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListBuildBatchesForProjectError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
            }
        }
        _ => crate::error::ListBuildBatchesForProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_build_batches_for_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListBuildBatchesForProjectOutput,
    crate::error::ListBuildBatchesForProjectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_build_batches_for_project_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_build_batches_for_project(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListBuildBatchesForProjectError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_builds_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListBuildsOutput, crate::error::ListBuildsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListBuildsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListBuildsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListBuildsError {
            meta: generic,
            kind: crate::error::ListBuildsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListBuildsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListBuildsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_builds_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListBuildsOutput, crate::error::ListBuildsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_builds_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_builds(response.body().as_ref(), output)
            .map_err(crate::error::ListBuildsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_builds_for_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListBuildsForProjectOutput,
    crate::error::ListBuildsForProjectError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListBuildsForProjectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListBuildsForProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListBuildsForProjectError {
            meta: generic,
            kind: crate::error::ListBuildsForProjectErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListBuildsForProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::ListBuildsForProjectError {
                meta: generic,
                kind: crate::error::ListBuildsForProjectErrorKind::ResourceNotFoundException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_not_found_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListBuildsForProjectError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::ListBuildsForProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_builds_for_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListBuildsForProjectOutput,
    crate::error::ListBuildsForProjectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_builds_for_project_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_builds_for_project(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListBuildsForProjectError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_curated_environment_images_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCuratedEnvironmentImagesOutput,
    crate::error::ListCuratedEnvironmentImagesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListCuratedEnvironmentImagesError::unhandled)?;
    Err(crate::error::ListCuratedEnvironmentImagesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_curated_environment_images_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCuratedEnvironmentImagesOutput,
    crate::error::ListCuratedEnvironmentImagesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_curated_environment_images_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_curated_environment_images(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListCuratedEnvironmentImagesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_projects_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListProjectsOutput, crate::error::ListProjectsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListProjectsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListProjectsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListProjectsError {
            meta: generic,
            kind: crate::error::ListProjectsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListProjectsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListProjectsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_projects_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListProjectsOutput, crate::error::ListProjectsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_projects_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_projects(response.body().as_ref(), output)
            .map_err(crate::error::ListProjectsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_report_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListReportGroupsOutput, crate::error::ListReportGroupsError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListReportGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListReportGroupsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListReportGroupsError {
            meta: generic,
            kind: crate::error::ListReportGroupsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListReportGroupsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListReportGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_report_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListReportGroupsOutput, crate::error::ListReportGroupsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_report_groups_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_list_report_groups(response.body().as_ref(), output)
                .map_err(crate::error::ListReportGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_reports_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListReportsOutput, crate::error::ListReportsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListReportsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListReportsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListReportsError {
            meta: generic,
            kind: crate::error::ListReportsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListReportsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListReportsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_reports_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListReportsOutput, crate::error::ListReportsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_reports_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_reports(response.body().as_ref(), output)
            .map_err(crate::error::ListReportsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_reports_for_report_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListReportsForReportGroupOutput,
    crate::error::ListReportsForReportGroupError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListReportsForReportGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListReportsForReportGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListReportsForReportGroupError {
            meta: generic,
            kind: crate::error::ListReportsForReportGroupErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListReportsForReportGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::ListReportsForReportGroupError {
                meta: generic,
                kind: crate::error::ListReportsForReportGroupErrorKind::ResourceNotFoundException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::resource_not_found_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListReportsForReportGroupError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
            }
        }
        _ => crate::error::ListReportsForReportGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_reports_for_report_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListReportsForReportGroupOutput,
    crate::error::ListReportsForReportGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_reports_for_report_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_reports_for_report_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListReportsForReportGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_shared_projects_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSharedProjectsOutput,
    crate::error::ListSharedProjectsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListSharedProjectsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListSharedProjectsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListSharedProjectsError {
            meta: generic,
            kind: crate::error::ListSharedProjectsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListSharedProjectsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListSharedProjectsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_shared_projects_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSharedProjectsOutput,
    crate::error::ListSharedProjectsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_shared_projects_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_shared_projects(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSharedProjectsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_shared_report_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSharedReportGroupsOutput,
    crate::error::ListSharedReportGroupsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListSharedReportGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListSharedReportGroupsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListSharedReportGroupsError {
            meta: generic,
            kind: crate::error::ListSharedReportGroupsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListSharedReportGroupsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListSharedReportGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_shared_report_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSharedReportGroupsOutput,
    crate::error::ListSharedReportGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_shared_report_groups_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_shared_report_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSharedReportGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_source_credentials_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSourceCredentialsOutput,
    crate::error::ListSourceCredentialsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListSourceCredentialsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListSourceCredentialsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::ListSourceCredentialsError {
            meta: generic,
            kind: crate::error::ListSourceCredentialsErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListSourceCredentialsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListSourceCredentialsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_source_credentials_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSourceCredentialsOutput,
    crate::error::ListSourceCredentialsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_source_credentials_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_source_credentials(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSourceCredentialsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_resource_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutResourcePolicyOutput, crate::error::PutResourcePolicyError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutResourcePolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutResourcePolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::PutResourcePolicyError {
            meta: generic,
            kind: crate::error::PutResourcePolicyErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PutResourcePolicyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::PutResourcePolicyError {
                meta: generic,
                kind: crate::error::PutResourcePolicyErrorKind::ResourceNotFoundException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_not_found_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::PutResourcePolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_resource_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutResourcePolicyOutput, crate::error::PutResourcePolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_resource_policy_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_put_resource_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutResourcePolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_retry_build_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RetryBuildOutput, crate::error::RetryBuildError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::RetryBuildError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RetryBuildError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccountLimitExceededException" => crate::error::RetryBuildError {
            meta: generic,
            kind: crate::error::RetryBuildErrorKind::AccountLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::account_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_account_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::RetryBuildError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInputException" => crate::error::RetryBuildError {
            meta: generic,
            kind: crate::error::RetryBuildErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::RetryBuildError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::RetryBuildError {
                meta: generic,
                kind: crate::error::RetryBuildErrorKind::ResourceNotFoundException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_not_found_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::RetryBuildError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::RetryBuildError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_retry_build_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RetryBuildOutput, crate::error::RetryBuildError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::retry_build_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_retry_build(response.body().as_ref(), output)
            .map_err(crate::error::RetryBuildError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_retry_build_batch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RetryBuildBatchOutput, crate::error::RetryBuildBatchError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::RetryBuildBatchError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RetryBuildBatchError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::RetryBuildBatchError {
            meta: generic,
            kind: crate::error::RetryBuildBatchErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::RetryBuildBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::RetryBuildBatchError {
                meta: generic,
                kind: crate::error::RetryBuildBatchErrorKind::ResourceNotFoundException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_not_found_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::RetryBuildBatchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::RetryBuildBatchError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_retry_build_batch_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RetryBuildBatchOutput, crate::error::RetryBuildBatchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::retry_build_batch_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_retry_build_batch(response.body().as_ref(), output)
                .map_err(crate::error::RetryBuildBatchError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_build_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartBuildOutput, crate::error::StartBuildError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::StartBuildError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StartBuildError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccountLimitExceededException" => crate::error::StartBuildError {
            meta: generic,
            kind: crate::error::StartBuildErrorKind::AccountLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::account_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_account_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::StartBuildError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidInputException" => crate::error::StartBuildError {
            meta: generic,
            kind: crate::error::StartBuildErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StartBuildError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::StartBuildError {
                meta: generic,
                kind: crate::error::StartBuildErrorKind::ResourceNotFoundException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_not_found_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::StartBuildError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::StartBuildError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_build_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartBuildOutput, crate::error::StartBuildError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_build_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_start_build(response.body().as_ref(), output)
            .map_err(crate::error::StartBuildError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_build_batch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartBuildBatchOutput, crate::error::StartBuildBatchError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::StartBuildBatchError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StartBuildBatchError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::StartBuildBatchError {
            meta: generic,
            kind: crate::error::StartBuildBatchErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StartBuildBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::StartBuildBatchError {
                meta: generic,
                kind: crate::error::StartBuildBatchErrorKind::ResourceNotFoundException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_not_found_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::StartBuildBatchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::StartBuildBatchError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_build_batch_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartBuildBatchOutput, crate::error::StartBuildBatchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_build_batch_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_start_build_batch(response.body().as_ref(), output)
                .map_err(crate::error::StartBuildBatchError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_build_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopBuildOutput, crate::error::StopBuildError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::StopBuildError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopBuildError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::StopBuildError {
            meta: generic,
            kind: crate::error::StopBuildErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopBuildError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::StopBuildError {
                meta: generic,
                kind: crate::error::StopBuildErrorKind::ResourceNotFoundException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_not_found_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::StopBuildError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::StopBuildError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_build_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopBuildOutput, crate::error::StopBuildError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_build_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_stop_build(response.body().as_ref(), output)
            .map_err(crate::error::StopBuildError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_build_batch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopBuildBatchOutput, crate::error::StopBuildBatchError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::StopBuildBatchError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopBuildBatchError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::StopBuildBatchError {
            meta: generic,
            kind: crate::error::StopBuildBatchErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopBuildBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::StopBuildBatchError {
                meta: generic,
                kind: crate::error::StopBuildBatchErrorKind::ResourceNotFoundException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_not_found_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::StopBuildBatchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::StopBuildBatchError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_build_batch_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopBuildBatchOutput, crate::error::StopBuildBatchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_build_batch_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_stop_build_batch(response.body().as_ref(), output)
                .map_err(crate::error::StopBuildBatchError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateProjectOutput, crate::error::UpdateProjectError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateProjectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::UpdateProjectError {
            meta: generic,
            kind: crate::error::UpdateProjectErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::UpdateProjectError {
                meta: generic,
                kind: crate::error::UpdateProjectErrorKind::ResourceNotFoundException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_not_found_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateProjectError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::UpdateProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateProjectOutput, crate::error::UpdateProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_project_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_update_project(response.body().as_ref(), output)
                .map_err(crate::error::UpdateProjectError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_report_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateReportGroupOutput, crate::error::UpdateReportGroupError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateReportGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateReportGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::UpdateReportGroupError {
            meta: generic,
            kind: crate::error::UpdateReportGroupErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateReportGroupError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::UpdateReportGroupError {
                meta: generic,
                kind: crate::error::UpdateReportGroupErrorKind::ResourceNotFoundException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_not_found_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateReportGroupError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::UpdateReportGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_report_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateReportGroupOutput, crate::error::UpdateReportGroupError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_report_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_report_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateReportGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_webhook_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateWebhookOutput, crate::error::UpdateWebhookError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateWebhookError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateWebhookError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInputException" => crate::error::UpdateWebhookError {
            meta: generic,
            kind: crate::error::UpdateWebhookErrorKind::InvalidInputException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_input_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateWebhookError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "OAuthProviderException" => crate::error::UpdateWebhookError {
            meta: generic,
            kind: crate::error::UpdateWebhookErrorKind::OAuthProviderException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::o_auth_provider_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_o_auth_provider_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateWebhookError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceNotFoundException" => {
            crate::error::UpdateWebhookError {
                meta: generic,
                kind: crate::error::UpdateWebhookErrorKind::ResourceNotFoundException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_not_found_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateWebhookError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::UpdateWebhookError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_webhook_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateWebhookOutput, crate::error::UpdateWebhookError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_webhook_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_update_webhook(response.body().as_ref(), output)
                .map_err(crate::error::UpdateWebhookError::unhandled)?;
        output.build()
    })
}
