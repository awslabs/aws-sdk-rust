// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Information about the cache for the build project.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProjectCache {
    /// <p>The type of cache used by the build project. Valid values include:</p>
    /// <ul>
    /// <li> <p> <code>NO_CACHE</code>: The build project does not use any cache.</p> </li>
    /// <li> <p> <code>S3</code>: The build project reads and writes from and to S3.</p> </li>
    /// <li> <p> <code>LOCAL</code>: The build project stores a cache locally on a build host that is only available to that build host.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::types::CacheType>,
    /// <p>Information about the cache location: </p>
    /// <ul>
    /// <li> <p> <code>NO_CACHE</code> or <code>LOCAL</code>: This value is ignored.</p> </li>
    /// <li> <p> <code>S3</code>: This is the S3 bucket name/prefix.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub location: std::option::Option<std::string::String>,
    /// <p>An array of strings that specify the local cache modes. You can use one or more local cache modes at the same time. This is only used for <code>LOCAL</code> cache types.</p>
    /// <p>Possible values are:</p>
    /// <dl>
    /// <dt>
    /// LOCAL_SOURCE_CACHE
    /// </dt>
    /// <dd>
    /// <p>Caches Git metadata for primary and secondary sources. After the cache is created, subsequent builds pull only the change between commits. This mode is a good choice for projects with a clean working directory and a source that is a large Git repository. If you choose this option and your project does not use a Git repository (GitHub, GitHub Enterprise, or Bitbucket), the option is ignored. </p>
    /// </dd>
    /// <dt>
    /// LOCAL_DOCKER_LAYER_CACHE
    /// </dt>
    /// <dd>
    /// <p>Caches existing Docker layers. This mode is a good choice for projects that build or pull large Docker images. It can prevent the performance issues caused by pulling large Docker images down from the network. </p> <note>
    /// <ul>
    /// <li> <p>You can use a Docker layer cache in the Linux environment only. </p> </li>
    /// <li> <p>The <code>privileged</code> flag must be set so that your project has the required Docker permissions. </p> </li>
    /// <li> <p>You should consider the security implications before you use a Docker layer cache. </p> </li>
    /// </ul>
    /// </note>
    /// </dd>
    /// <dt>
    /// LOCAL_CUSTOM_CACHE
    /// </dt>
    /// <dd>
    /// <p>Caches directories you specify in the buildspec file. This mode is a good choice if your build scenario is not suited to one of the other three local cache modes. If you use a custom cache: </p>
    /// <ul>
    /// <li> <p>Only directories can be specified for caching. You cannot specify individual files. </p> </li>
    /// <li> <p>Symlinks are used to reference cached directories. </p> </li>
    /// <li> <p>Cached directories are linked to your build before it downloads its project sources. Cached items are overridden if a source item has the same name. Directories are specified using cache paths in the buildspec file. </p> </li>
    /// </ul>
    /// </dd>
    /// </dl>
    #[doc(hidden)]
    pub modes: std::option::Option<std::vec::Vec<crate::types::CacheMode>>,
}
impl ProjectCache {
    /// <p>The type of cache used by the build project. Valid values include:</p>
    /// <ul>
    /// <li> <p> <code>NO_CACHE</code>: The build project does not use any cache.</p> </li>
    /// <li> <p> <code>S3</code>: The build project reads and writes from and to S3.</p> </li>
    /// <li> <p> <code>LOCAL</code>: The build project stores a cache locally on a build host that is only available to that build host.</p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&crate::types::CacheType> {
        self.r#type.as_ref()
    }
    /// <p>Information about the cache location: </p>
    /// <ul>
    /// <li> <p> <code>NO_CACHE</code> or <code>LOCAL</code>: This value is ignored.</p> </li>
    /// <li> <p> <code>S3</code>: This is the S3 bucket name/prefix.</p> </li>
    /// </ul>
    pub fn location(&self) -> std::option::Option<&str> {
        self.location.as_deref()
    }
    /// <p>An array of strings that specify the local cache modes. You can use one or more local cache modes at the same time. This is only used for <code>LOCAL</code> cache types.</p>
    /// <p>Possible values are:</p>
    /// <dl>
    /// <dt>
    /// LOCAL_SOURCE_CACHE
    /// </dt>
    /// <dd>
    /// <p>Caches Git metadata for primary and secondary sources. After the cache is created, subsequent builds pull only the change between commits. This mode is a good choice for projects with a clean working directory and a source that is a large Git repository. If you choose this option and your project does not use a Git repository (GitHub, GitHub Enterprise, or Bitbucket), the option is ignored. </p>
    /// </dd>
    /// <dt>
    /// LOCAL_DOCKER_LAYER_CACHE
    /// </dt>
    /// <dd>
    /// <p>Caches existing Docker layers. This mode is a good choice for projects that build or pull large Docker images. It can prevent the performance issues caused by pulling large Docker images down from the network. </p> <note>
    /// <ul>
    /// <li> <p>You can use a Docker layer cache in the Linux environment only. </p> </li>
    /// <li> <p>The <code>privileged</code> flag must be set so that your project has the required Docker permissions. </p> </li>
    /// <li> <p>You should consider the security implications before you use a Docker layer cache. </p> </li>
    /// </ul>
    /// </note>
    /// </dd>
    /// <dt>
    /// LOCAL_CUSTOM_CACHE
    /// </dt>
    /// <dd>
    /// <p>Caches directories you specify in the buildspec file. This mode is a good choice if your build scenario is not suited to one of the other three local cache modes. If you use a custom cache: </p>
    /// <ul>
    /// <li> <p>Only directories can be specified for caching. You cannot specify individual files. </p> </li>
    /// <li> <p>Symlinks are used to reference cached directories. </p> </li>
    /// <li> <p>Cached directories are linked to your build before it downloads its project sources. Cached items are overridden if a source item has the same name. Directories are specified using cache paths in the buildspec file. </p> </li>
    /// </ul>
    /// </dd>
    /// </dl>
    pub fn modes(&self) -> std::option::Option<&[crate::types::CacheMode]> {
        self.modes.as_deref()
    }
}
impl ProjectCache {
    /// Creates a new builder-style object to manufacture [`ProjectCache`](crate::types::ProjectCache).
    pub fn builder() -> crate::types::builders::ProjectCacheBuilder {
        crate::types::builders::ProjectCacheBuilder::default()
    }
}

/// A builder for [`ProjectCache`](crate::types::ProjectCache).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ProjectCacheBuilder {
    pub(crate) r#type: std::option::Option<crate::types::CacheType>,
    pub(crate) location: std::option::Option<std::string::String>,
    pub(crate) modes: std::option::Option<std::vec::Vec<crate::types::CacheMode>>,
}
impl ProjectCacheBuilder {
    /// <p>The type of cache used by the build project. Valid values include:</p>
    /// <ul>
    /// <li> <p> <code>NO_CACHE</code>: The build project does not use any cache.</p> </li>
    /// <li> <p> <code>S3</code>: The build project reads and writes from and to S3.</p> </li>
    /// <li> <p> <code>LOCAL</code>: The build project stores a cache locally on a build host that is only available to that build host.</p> </li>
    /// </ul>
    pub fn r#type(mut self, input: crate::types::CacheType) -> Self {
        self.r#type = Some(input);
        self
    }
    /// <p>The type of cache used by the build project. Valid values include:</p>
    /// <ul>
    /// <li> <p> <code>NO_CACHE</code>: The build project does not use any cache.</p> </li>
    /// <li> <p> <code>S3</code>: The build project reads and writes from and to S3.</p> </li>
    /// <li> <p> <code>LOCAL</code>: The build project stores a cache locally on a build host that is only available to that build host.</p> </li>
    /// </ul>
    pub fn set_type(mut self, input: std::option::Option<crate::types::CacheType>) -> Self {
        self.r#type = input;
        self
    }
    /// <p>Information about the cache location: </p>
    /// <ul>
    /// <li> <p> <code>NO_CACHE</code> or <code>LOCAL</code>: This value is ignored.</p> </li>
    /// <li> <p> <code>S3</code>: This is the S3 bucket name/prefix.</p> </li>
    /// </ul>
    pub fn location(mut self, input: impl Into<std::string::String>) -> Self {
        self.location = Some(input.into());
        self
    }
    /// <p>Information about the cache location: </p>
    /// <ul>
    /// <li> <p> <code>NO_CACHE</code> or <code>LOCAL</code>: This value is ignored.</p> </li>
    /// <li> <p> <code>S3</code>: This is the S3 bucket name/prefix.</p> </li>
    /// </ul>
    pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.location = input;
        self
    }
    /// Appends an item to `modes`.
    ///
    /// To override the contents of this collection use [`set_modes`](Self::set_modes).
    ///
    /// <p>An array of strings that specify the local cache modes. You can use one or more local cache modes at the same time. This is only used for <code>LOCAL</code> cache types.</p>
    /// <p>Possible values are:</p>
    /// <dl>
    /// <dt>
    /// LOCAL_SOURCE_CACHE
    /// </dt>
    /// <dd>
    /// <p>Caches Git metadata for primary and secondary sources. After the cache is created, subsequent builds pull only the change between commits. This mode is a good choice for projects with a clean working directory and a source that is a large Git repository. If you choose this option and your project does not use a Git repository (GitHub, GitHub Enterprise, or Bitbucket), the option is ignored. </p>
    /// </dd>
    /// <dt>
    /// LOCAL_DOCKER_LAYER_CACHE
    /// </dt>
    /// <dd>
    /// <p>Caches existing Docker layers. This mode is a good choice for projects that build or pull large Docker images. It can prevent the performance issues caused by pulling large Docker images down from the network. </p> <note>
    /// <ul>
    /// <li> <p>You can use a Docker layer cache in the Linux environment only. </p> </li>
    /// <li> <p>The <code>privileged</code> flag must be set so that your project has the required Docker permissions. </p> </li>
    /// <li> <p>You should consider the security implications before you use a Docker layer cache. </p> </li>
    /// </ul>
    /// </note>
    /// </dd>
    /// <dt>
    /// LOCAL_CUSTOM_CACHE
    /// </dt>
    /// <dd>
    /// <p>Caches directories you specify in the buildspec file. This mode is a good choice if your build scenario is not suited to one of the other three local cache modes. If you use a custom cache: </p>
    /// <ul>
    /// <li> <p>Only directories can be specified for caching. You cannot specify individual files. </p> </li>
    /// <li> <p>Symlinks are used to reference cached directories. </p> </li>
    /// <li> <p>Cached directories are linked to your build before it downloads its project sources. Cached items are overridden if a source item has the same name. Directories are specified using cache paths in the buildspec file. </p> </li>
    /// </ul>
    /// </dd>
    /// </dl>
    pub fn modes(mut self, input: crate::types::CacheMode) -> Self {
        let mut v = self.modes.unwrap_or_default();
        v.push(input);
        self.modes = Some(v);
        self
    }
    /// <p>An array of strings that specify the local cache modes. You can use one or more local cache modes at the same time. This is only used for <code>LOCAL</code> cache types.</p>
    /// <p>Possible values are:</p>
    /// <dl>
    /// <dt>
    /// LOCAL_SOURCE_CACHE
    /// </dt>
    /// <dd>
    /// <p>Caches Git metadata for primary and secondary sources. After the cache is created, subsequent builds pull only the change between commits. This mode is a good choice for projects with a clean working directory and a source that is a large Git repository. If you choose this option and your project does not use a Git repository (GitHub, GitHub Enterprise, or Bitbucket), the option is ignored. </p>
    /// </dd>
    /// <dt>
    /// LOCAL_DOCKER_LAYER_CACHE
    /// </dt>
    /// <dd>
    /// <p>Caches existing Docker layers. This mode is a good choice for projects that build or pull large Docker images. It can prevent the performance issues caused by pulling large Docker images down from the network. </p> <note>
    /// <ul>
    /// <li> <p>You can use a Docker layer cache in the Linux environment only. </p> </li>
    /// <li> <p>The <code>privileged</code> flag must be set so that your project has the required Docker permissions. </p> </li>
    /// <li> <p>You should consider the security implications before you use a Docker layer cache. </p> </li>
    /// </ul>
    /// </note>
    /// </dd>
    /// <dt>
    /// LOCAL_CUSTOM_CACHE
    /// </dt>
    /// <dd>
    /// <p>Caches directories you specify in the buildspec file. This mode is a good choice if your build scenario is not suited to one of the other three local cache modes. If you use a custom cache: </p>
    /// <ul>
    /// <li> <p>Only directories can be specified for caching. You cannot specify individual files. </p> </li>
    /// <li> <p>Symlinks are used to reference cached directories. </p> </li>
    /// <li> <p>Cached directories are linked to your build before it downloads its project sources. Cached items are overridden if a source item has the same name. Directories are specified using cache paths in the buildspec file. </p> </li>
    /// </ul>
    /// </dd>
    /// </dl>
    pub fn set_modes(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::CacheMode>>,
    ) -> Self {
        self.modes = input;
        self
    }
    /// Consumes the builder and constructs a [`ProjectCache`](crate::types::ProjectCache).
    pub fn build(self) -> crate::types::ProjectCache {
        crate::types::ProjectCache {
            r#type: self.r#type,
            location: self.location,
            modes: self.modes,
        }
    }
}
