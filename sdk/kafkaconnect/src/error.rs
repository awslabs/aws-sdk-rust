// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateConnectorError {
    pub kind: CreateConnectorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateConnectorErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateConnectorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateConnectorErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateConnectorErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateConnectorErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateConnectorErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateConnectorErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateConnectorErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateConnectorErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateConnectorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateConnectorError {
    fn code(&self) -> Option<&str> {
        CreateConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateConnectorError {
    pub fn new(kind: CreateConnectorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateConnectorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateConnectorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateConnectorErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateConnectorErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateConnectorErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectorErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateConnectorErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectorErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectorErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectorErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateConnectorErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateConnectorErrorKind::ConflictException(_inner) => Some(_inner),
            CreateConnectorErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateConnectorErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateConnectorErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateConnectorErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateConnectorErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateConnectorErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateConnectorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCustomPluginError {
    pub kind: CreateCustomPluginErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCustomPluginErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCustomPluginError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCustomPluginErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateCustomPluginErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateCustomPluginErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateCustomPluginErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateCustomPluginErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateCustomPluginErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateCustomPluginErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateCustomPluginErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateCustomPluginErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCustomPluginError {
    fn code(&self) -> Option<&str> {
        CreateCustomPluginError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCustomPluginError {
    pub fn new(kind: CreateCustomPluginErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCustomPluginErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCustomPluginErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomPluginErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomPluginErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomPluginErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomPluginErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomPluginErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomPluginErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomPluginErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomPluginErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateCustomPluginError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCustomPluginErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateCustomPluginErrorKind::ConflictException(_inner) => Some(_inner),
            CreateCustomPluginErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateCustomPluginErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateCustomPluginErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateCustomPluginErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateCustomPluginErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateCustomPluginErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateCustomPluginErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateWorkerConfigurationError {
    pub kind: CreateWorkerConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateWorkerConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateWorkerConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateWorkerConfigurationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateWorkerConfigurationErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateWorkerConfigurationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateWorkerConfigurationErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            CreateWorkerConfigurationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateWorkerConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreateWorkerConfigurationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateWorkerConfigurationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateWorkerConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateWorkerConfigurationError {
    fn code(&self) -> Option<&str> {
        CreateWorkerConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateWorkerConfigurationError {
    pub fn new(kind: CreateWorkerConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateWorkerConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateWorkerConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkerConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkerConfigurationErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkerConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkerConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkerConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkerConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkerConfigurationErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWorkerConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateWorkerConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateWorkerConfigurationErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateWorkerConfigurationErrorKind::ConflictException(_inner) => Some(_inner),
            CreateWorkerConfigurationErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateWorkerConfigurationErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            CreateWorkerConfigurationErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateWorkerConfigurationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateWorkerConfigurationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateWorkerConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateWorkerConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteConnectorError {
    pub kind: DeleteConnectorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteConnectorErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteConnectorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteConnectorErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteConnectorErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteConnectorErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteConnectorErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteConnectorErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteConnectorErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteConnectorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteConnectorError {
    fn code(&self) -> Option<&str> {
        DeleteConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteConnectorError {
    pub fn new(kind: DeleteConnectorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteConnectorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteConnectorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteConnectorErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteConnectorErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConnectorErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteConnectorErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConnectorErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConnectorErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConnectorErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteConnectorErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteConnectorErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteConnectorErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteConnectorErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteConnectorErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteConnectorErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteConnectorErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteConnectorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConnectorError {
    pub kind: DescribeConnectorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConnectorErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConnectorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeConnectorErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeConnectorErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeConnectorErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeConnectorErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeConnectorErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeConnectorErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeConnectorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeConnectorError {
    fn code(&self) -> Option<&str> {
        DescribeConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConnectorError {
    pub fn new(kind: DescribeConnectorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConnectorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConnectorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectorErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectorErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectorErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DescribeConnectorErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectorErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectorErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectorErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConnectorErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeConnectorErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeConnectorErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeConnectorErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeConnectorErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeConnectorErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeConnectorErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeConnectorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCustomPluginError {
    pub kind: DescribeCustomPluginErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCustomPluginErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCustomPluginError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCustomPluginErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeCustomPluginErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeCustomPluginErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeCustomPluginErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeCustomPluginErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeCustomPluginErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeCustomPluginErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeCustomPluginErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCustomPluginError {
    fn code(&self) -> Option<&str> {
        DescribeCustomPluginError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCustomPluginError {
    pub fn new(kind: DescribeCustomPluginErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCustomPluginErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCustomPluginErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomPluginErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomPluginErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomPluginErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomPluginErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomPluginErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomPluginErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomPluginErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeCustomPluginError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCustomPluginErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeCustomPluginErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeCustomPluginErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeCustomPluginErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeCustomPluginErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeCustomPluginErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeCustomPluginErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeCustomPluginErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeWorkerConfigurationError {
    pub kind: DescribeWorkerConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeWorkerConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeWorkerConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeWorkerConfigurationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeWorkerConfigurationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeWorkerConfigurationErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            DescribeWorkerConfigurationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeWorkerConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DescribeWorkerConfigurationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeWorkerConfigurationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeWorkerConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeWorkerConfigurationError {
    fn code(&self) -> Option<&str> {
        DescribeWorkerConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeWorkerConfigurationError {
    pub fn new(kind: DescribeWorkerConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeWorkerConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeWorkerConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkerConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkerConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkerConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkerConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkerConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkerConfigurationErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkerConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeWorkerConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeWorkerConfigurationErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeWorkerConfigurationErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeWorkerConfigurationErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            DescribeWorkerConfigurationErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeWorkerConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            DescribeWorkerConfigurationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeWorkerConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeWorkerConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListConnectorsError {
    pub kind: ListConnectorsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListConnectorsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListConnectorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListConnectorsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListConnectorsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListConnectorsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListConnectorsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListConnectorsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListConnectorsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListConnectorsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListConnectorsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListConnectorsError {
    fn code(&self) -> Option<&str> {
        ListConnectorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListConnectorsError {
    pub fn new(kind: ListConnectorsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListConnectorsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListConnectorsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListConnectorsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListConnectorsErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConnectorsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListConnectorsErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConnectorsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConnectorsErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConnectorsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListConnectorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListConnectorsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListConnectorsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListConnectorsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListConnectorsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListConnectorsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListConnectorsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListConnectorsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListConnectorsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCustomPluginsError {
    pub kind: ListCustomPluginsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCustomPluginsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCustomPluginsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCustomPluginsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListCustomPluginsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListCustomPluginsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListCustomPluginsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListCustomPluginsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListCustomPluginsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListCustomPluginsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListCustomPluginsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListCustomPluginsError {
    fn code(&self) -> Option<&str> {
        ListCustomPluginsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCustomPluginsError {
    pub fn new(kind: ListCustomPluginsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCustomPluginsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCustomPluginsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCustomPluginsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCustomPluginsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCustomPluginsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListCustomPluginsErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCustomPluginsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCustomPluginsErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCustomPluginsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListCustomPluginsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCustomPluginsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListCustomPluginsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListCustomPluginsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListCustomPluginsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListCustomPluginsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListCustomPluginsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListCustomPluginsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListCustomPluginsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListWorkerConfigurationsError {
    pub kind: ListWorkerConfigurationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListWorkerConfigurationsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListWorkerConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListWorkerConfigurationsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListWorkerConfigurationsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListWorkerConfigurationsErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            ListWorkerConfigurationsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListWorkerConfigurationsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListWorkerConfigurationsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListWorkerConfigurationsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListWorkerConfigurationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListWorkerConfigurationsError {
    fn code(&self) -> Option<&str> {
        ListWorkerConfigurationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListWorkerConfigurationsError {
    pub fn new(kind: ListWorkerConfigurationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListWorkerConfigurationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListWorkerConfigurationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWorkerConfigurationsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWorkerConfigurationsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWorkerConfigurationsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWorkerConfigurationsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWorkerConfigurationsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWorkerConfigurationsErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWorkerConfigurationsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListWorkerConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListWorkerConfigurationsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListWorkerConfigurationsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListWorkerConfigurationsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListWorkerConfigurationsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListWorkerConfigurationsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListWorkerConfigurationsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListWorkerConfigurationsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListWorkerConfigurationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateConnectorError {
    pub kind: UpdateConnectorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateConnectorErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateConnectorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateConnectorErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateConnectorErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateConnectorErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateConnectorErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateConnectorErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateConnectorErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateConnectorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateConnectorError {
    fn code(&self) -> Option<&str> {
        UpdateConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateConnectorError {
    pub fn new(kind: UpdateConnectorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateConnectorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateConnectorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateConnectorErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateConnectorErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectorErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateConnectorErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectorErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectorErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectorErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateConnectorErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateConnectorErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateConnectorErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateConnectorErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateConnectorErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateConnectorErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateConnectorErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateConnectorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>HTTP Status Code 401: Unauthorized request. The provided credentials couldn't be validated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnauthorizedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnauthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnauthorizedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnauthorizedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnauthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthorizedException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnauthorizedException {}
/// See [`UnauthorizedException`](crate::error::UnauthorizedException)
pub mod unauthorized_exception {
    /// A builder for [`UnauthorizedException`](crate::error::UnauthorizedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedException`](crate::error::UnauthorizedException)
        pub fn build(self) -> crate::error::UnauthorizedException {
            crate::error::UnauthorizedException {
                message: self.message,
            }
        }
    }
}
impl UnauthorizedException {
    /// Creates a new builder-style object to manufacture [`UnauthorizedException`](crate::error::UnauthorizedException)
    pub fn builder() -> crate::error::unauthorized_exception::Builder {
        crate::error::unauthorized_exception::Builder::default()
    }
}

/// <p>HTTP Status Code 429: Limit exceeded. Resource limit reached.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyRequestsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyRequestsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyRequestsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyRequestsException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyRequestsException {}
/// See [`TooManyRequestsException`](crate::error::TooManyRequestsException)
pub mod too_many_requests_exception {
    /// A builder for [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyRequestsException`](crate::error::TooManyRequestsException)
        pub fn build(self) -> crate::error::TooManyRequestsException {
            crate::error::TooManyRequestsException {
                message: self.message,
            }
        }
    }
}
impl TooManyRequestsException {
    /// Creates a new builder-style object to manufacture [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    pub fn builder() -> crate::error::too_many_requests_exception::Builder {
        crate::error::too_many_requests_exception::Builder::default()
    }
}

/// <p>HTTP Status Code 503: Service Unavailable. Retrying your request in some time might resolve the issue.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceUnavailableException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceUnavailableException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceUnavailableException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableException {}
/// See [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
pub mod service_unavailable_exception {
    /// A builder for [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
        pub fn build(self) -> crate::error::ServiceUnavailableException {
            crate::error::ServiceUnavailableException {
                message: self.message,
            }
        }
    }
}
impl ServiceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    pub fn builder() -> crate::error::service_unavailable_exception::Builder {
        crate::error::service_unavailable_exception::Builder::default()
    }
}

/// <p>HTTP Status Code 404: Resource not found due to incorrect input. Correct your request and then retry it.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundException {}
/// See [`NotFoundException`](crate::error::NotFoundException)
pub mod not_found_exception {
    /// A builder for [`NotFoundException`](crate::error::NotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundException`](crate::error::NotFoundException)
        pub fn build(self) -> crate::error::NotFoundException {
            crate::error::NotFoundException {
                message: self.message,
            }
        }
    }
}
impl NotFoundException {
    /// Creates a new builder-style object to manufacture [`NotFoundException`](crate::error::NotFoundException)
    pub fn builder() -> crate::error::not_found_exception::Builder {
        crate::error::not_found_exception::Builder::default()
    }
}

/// <p>HTTP Status Code 500: Unexpected internal server error. Retrying your request might resolve the issue.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerErrorException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerErrorException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServerErrorException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerErrorException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerErrorException {}
/// See [`InternalServerErrorException`](crate::error::InternalServerErrorException)
pub mod internal_server_error_exception {
    /// A builder for [`InternalServerErrorException`](crate::error::InternalServerErrorException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerErrorException`](crate::error::InternalServerErrorException)
        pub fn build(self) -> crate::error::InternalServerErrorException {
            crate::error::InternalServerErrorException {
                message: self.message,
            }
        }
    }
}
impl InternalServerErrorException {
    /// Creates a new builder-style object to manufacture [`InternalServerErrorException`](crate::error::InternalServerErrorException)
    pub fn builder() -> crate::error::internal_server_error_exception::Builder {
        crate::error::internal_server_error_exception::Builder::default()
    }
}

/// <p>HTTP Status Code 403: Access forbidden. Correct your credentials and then retry your request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ForbiddenException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ForbiddenException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ForbiddenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ForbiddenException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ForbiddenException {}
/// See [`ForbiddenException`](crate::error::ForbiddenException)
pub mod forbidden_exception {
    /// A builder for [`ForbiddenException`](crate::error::ForbiddenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ForbiddenException`](crate::error::ForbiddenException)
        pub fn build(self) -> crate::error::ForbiddenException {
            crate::error::ForbiddenException {
                message: self.message,
            }
        }
    }
}
impl ForbiddenException {
    /// Creates a new builder-style object to manufacture [`ForbiddenException`](crate::error::ForbiddenException)
    pub fn builder() -> crate::error::forbidden_exception::Builder {
        crate::error::forbidden_exception::Builder::default()
    }
}

/// <p>HTTP Status Code 400: Bad request due to incorrect input. Correct your request and then retry it.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestException {}
/// See [`BadRequestException`](crate::error::BadRequestException)
pub mod bad_request_exception {
    /// A builder for [`BadRequestException`](crate::error::BadRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestException`](crate::error::BadRequestException)
        pub fn build(self) -> crate::error::BadRequestException {
            crate::error::BadRequestException {
                message: self.message,
            }
        }
    }
}
impl BadRequestException {
    /// Creates a new builder-style object to manufacture [`BadRequestException`](crate::error::BadRequestException)
    pub fn builder() -> crate::error::bad_request_exception::Builder {
        crate::error::bad_request_exception::Builder::default()
    }
}

/// <p>HTTP Status Code 409: Conflict. A resource with this name already exists. Retry your request with another name.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}
