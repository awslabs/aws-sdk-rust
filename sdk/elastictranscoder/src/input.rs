// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`CancelJobInput`](crate::input::CancelJobInput)
pub mod cancel_job_input {
    /// A builder for [`CancelJobInput`](crate::input::CancelJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the job that you want to cancel.</p>
        /// <p>To get a list of the jobs (including their <code>jobId</code>) that have a status of
        /// <code>Submitted</code>, use the <a>ListJobsByStatus</a> API action.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`CancelJobInput`](crate::input::CancelJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::CancelJobInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CancelJobInput { id: self.id })
        }
    }
}
#[doc(hidden)]
pub type CancelJobInputOperationOutputAlias = crate::operation::CancelJob;
#[doc(hidden)]
pub type CancelJobInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CancelJobInput {
    /// Consumes the builder and constructs an Operation<[`CancelJob`](crate::operation::CancelJob)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CancelJob,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::CancelJob::new())
                    .with_metadata(smithy_http::operation::Metadata::new(
                        "CancelJob",
                        "elastictranscoder",
                    ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_1 = &self.id;
        let input_1 = input_1
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "id",
                details: "cannot be empty or unset",
            })?;
        let id = smithy_http::label::fmt_string(input_1, false);
        if id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "id",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/2012-09-25/jobs/{Id}", Id = id).expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CancelJobInput`](crate::input::CancelJobInput)
    pub fn builder() -> crate::input::cancel_job_input::Builder {
        crate::input::cancel_job_input::Builder::default()
    }
}

/// See [`CreateJobInput`](crate::input::CreateJobInput)
pub mod create_job_input {
    /// A builder for [`CreateJobInput`](crate::input::CreateJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pipeline_id: std::option::Option<std::string::String>,
        pub(crate) input: std::option::Option<crate::model::JobInput>,
        pub(crate) inputs: std::option::Option<std::vec::Vec<crate::model::JobInput>>,
        pub(crate) output: std::option::Option<crate::output::CreateJobOutput>,
        pub(crate) outputs: std::option::Option<std::vec::Vec<crate::output::CreateJobOutput>>,
        pub(crate) output_key_prefix: std::option::Option<std::string::String>,
        pub(crate) playlists: std::option::Option<std::vec::Vec<crate::model::CreateJobPlaylist>>,
        pub(crate) user_metadata: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The <code>Id</code> of the pipeline that you want Elastic Transcoder to use for
        /// transcoding. The pipeline determines several settings, including the Amazon S3 bucket
        /// from which Elastic Transcoder gets the files to transcode and the bucket into which
        /// Elastic Transcoder puts the transcoded files.</p>
        pub fn pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_id = Some(input.into());
            self
        }
        pub fn set_pipeline_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pipeline_id = input;
            self
        }
        /// <p>A section of the request body that provides information about the file that is being
        /// transcoded.</p>
        pub fn input(mut self, input: crate::model::JobInput) -> Self {
            self.input = Some(input);
            self
        }
        pub fn set_input(mut self, input: std::option::Option<crate::model::JobInput>) -> Self {
            self.input = input;
            self
        }
        pub fn inputs(mut self, input: impl Into<crate::model::JobInput>) -> Self {
            let mut v = self.inputs.unwrap_or_default();
            v.push(input.into());
            self.inputs = Some(v);
            self
        }
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::JobInput>>,
        ) -> Self {
            self.inputs = input;
            self
        }
        /// <p> A section of the request body that provides information about the transcoded (target)
        /// file. We strongly recommend that you use the <code>Outputs</code> syntax instead of the
        /// <code>Output</code> syntax. </p>
        pub fn output(mut self, input: crate::output::CreateJobOutput) -> Self {
            self.output = Some(input);
            self
        }
        pub fn set_output(
            mut self,
            input: std::option::Option<crate::output::CreateJobOutput>,
        ) -> Self {
            self.output = input;
            self
        }
        pub fn outputs(mut self, input: impl Into<crate::output::CreateJobOutput>) -> Self {
            let mut v = self.outputs.unwrap_or_default();
            v.push(input.into());
            self.outputs = Some(v);
            self
        }
        pub fn set_outputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::output::CreateJobOutput>>,
        ) -> Self {
            self.outputs = input;
            self
        }
        /// <p>The value, if any, that you want Elastic Transcoder to prepend to the names of all files that this
        /// job creates, including output files, thumbnails, and playlists.</p>
        pub fn output_key_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_key_prefix = Some(input.into());
            self
        }
        pub fn set_output_key_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_key_prefix = input;
            self
        }
        pub fn playlists(mut self, input: impl Into<crate::model::CreateJobPlaylist>) -> Self {
            let mut v = self.playlists.unwrap_or_default();
            v.push(input.into());
            self.playlists = Some(v);
            self
        }
        pub fn set_playlists(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CreateJobPlaylist>>,
        ) -> Self {
            self.playlists = input;
            self
        }
        pub fn user_metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.user_metadata.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.user_metadata = Some(hash_map);
            self
        }
        pub fn set_user_metadata(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.user_metadata = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateJobInput`](crate::input::CreateJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::CreateJobInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateJobInput {
                pipeline_id: self.pipeline_id,
                input: self.input,
                inputs: self.inputs,
                output: self.output,
                outputs: self.outputs,
                output_key_prefix: self.output_key_prefix,
                playlists: self.playlists,
                user_metadata: self.user_metadata,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateJobInputOperationOutputAlias = crate::operation::CreateJob;
#[doc(hidden)]
pub type CreateJobInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateJobInput {
    /// Consumes the builder and constructs an Operation<[`CreateJob`](crate::operation::CreateJob)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateJob,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_create_job(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::CreateJob::new())
                    .with_metadata(smithy_http::operation::Metadata::new(
                        "CreateJob",
                        "elastictranscoder",
                    ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/2012-09-25/jobs").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateJobInput`](crate::input::CreateJobInput)
    pub fn builder() -> crate::input::create_job_input::Builder {
        crate::input::create_job_input::Builder::default()
    }
}

/// See [`CreatePipelineInput`](crate::input::CreatePipelineInput)
pub mod create_pipeline_input {
    /// A builder for [`CreatePipelineInput`](crate::input::CreatePipelineInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) input_bucket: std::option::Option<std::string::String>,
        pub(crate) output_bucket: std::option::Option<std::string::String>,
        pub(crate) role: std::option::Option<std::string::String>,
        pub(crate) aws_kms_key_arn: std::option::Option<std::string::String>,
        pub(crate) notifications: std::option::Option<crate::model::Notifications>,
        pub(crate) content_config: std::option::Option<crate::model::PipelineOutputConfig>,
        pub(crate) thumbnail_config: std::option::Option<crate::model::PipelineOutputConfig>,
    }
    impl Builder {
        /// <p>The name of the pipeline. We recommend that the name be unique within the AWS account,
        /// but uniqueness is not enforced.</p>
        /// <p>Constraints: Maximum 40 characters.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon S3 bucket in which you saved the media files that you want to transcode.</p>
        pub fn input_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_bucket = Some(input.into());
            self
        }
        pub fn set_input_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input_bucket = input;
            self
        }
        /// <p>The Amazon S3 bucket in which you want Elastic Transcoder to save the transcoded files. (Use
        /// this, or use ContentConfig:Bucket plus ThumbnailConfig:Bucket.)</p>
        /// <p>Specify this value when all of the following are true:</p>
        /// <ul>
        /// <li>
        /// <p>You want to save transcoded files, thumbnails (if any), and playlists (if any)
        /// together in one bucket.</p>
        /// </li>
        /// <li>
        /// <p>You do not want to specify the users or groups who have access to the transcoded
        /// files, thumbnails, and playlists.</p>
        /// </li>
        /// <li>
        /// <p>You do not want to specify the permissions that Elastic Transcoder grants to the   
        /// files. </p>
        /// <important>
        /// <p>When Elastic Transcoder saves files in
        /// <code>OutputBucket</code>, it grants full control over the files only to
        /// the AWS account that owns the role that is specified by
        /// <code>Role</code>.</p>
        /// </important>
        /// </li>
        /// <li>
        /// <p>You want to associate the transcoded files and thumbnails with the Amazon S3
        /// Standard storage class.</p>
        /// </li>
        /// </ul>
        /// <p>If you want to save transcoded files and playlists in one bucket and thumbnails in
        /// another bucket, specify which users can access the transcoded files or the permissions
        /// the users have, or change the Amazon S3 storage class, omit <code>OutputBucket</code>
        /// and specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>
        /// instead.</p>
        pub fn output_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_bucket = Some(input.into());
            self
        }
        pub fn set_output_bucket(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_bucket = input;
            self
        }
        /// <p>The IAM Amazon Resource Name (ARN) for the role that you want Elastic Transcoder to use to create the pipeline.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.role = Some(input.into());
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role = input;
            self
        }
        /// <p>The AWS Key Management Service (AWS KMS) key that you want to use with this pipeline.</p>
        /// <p>If you use either <code>s3</code> or <code>s3-aws-kms</code> as your
        /// <code>Encryption:Mode</code>, you don't need to provide a key with
        /// your job because a default key, known as an AWS-KMS key, is created for you automatically.
        /// You need to provide an AWS-KMS key only if you want to use a non-default AWS-KMS key, or if you are
        /// using an <code>Encryption:Mode</code> of <code>aes-cbc-pkcs7</code>, <code>aes-ctr</code>,
        /// or <code>aes-gcm</code>.</p>
        pub fn aws_kms_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_kms_key_arn = Some(input.into());
            self
        }
        pub fn set_aws_kms_key_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.aws_kms_key_arn = input;
            self
        }
        /// <p>The Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status.</p>
        /// <important>
        /// <p>To receive notifications, you must also subscribe to the new topic in the Amazon SNS console.</p>
        /// </important>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Progressing</b>: The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to
        /// notify when Elastic Transcoder has started to process a job in this pipeline. This is the ARN that
        /// Amazon SNS returned when you created the topic. For more information, see Create a
        /// Topic in the Amazon Simple Notification Service Developer Guide.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Complete</b>: The topic ARN for the Amazon SNS topic that you want to notify when
        /// Elastic Transcoder has finished processing a job in this pipeline. This is the ARN that Amazon SNS
        /// returned when you created the topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Warning</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
        /// encounters a warning condition while processing a job in this pipeline. This is the
        /// ARN that Amazon SNS returned when you created the topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Error</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
        /// encounters an error condition while processing a job in this pipeline. This is the
        /// ARN that Amazon SNS returned when you created the topic.</p>
        /// </li>
        /// </ul>
        pub fn notifications(mut self, input: crate::model::Notifications) -> Self {
            self.notifications = Some(input);
            self
        }
        pub fn set_notifications(
            mut self,
            input: std::option::Option<crate::model::Notifications>,
        ) -> Self {
            self.notifications = input;
            self
        }
        /// <p>The optional <code>ContentConfig</code> object specifies information about the Amazon S3
        /// bucket in which you want Elastic Transcoder to save transcoded files and playlists:
        /// which bucket to use, which users you want to have access to the files, the type of
        /// access you want users to have, and the storage class that you want to assign to the
        /// files.</p>
        /// <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
        /// <code>ThumbnailConfig</code>.</p>
        /// <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
        /// omit the <code>OutputBucket</code> object.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
        /// transcoded files and playlists.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Permissions</b> (Optional): The Permissions object specifies which users you want
        /// to have access to transcoded files and the type of access you want them to have. You
        /// can grant permissions to a maximum of 30 users and/or predefined Amazon S3
        /// groups.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Grantee Type</b>: Specify the type of value that appears in the
        /// <code>Grantee</code> object: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
        /// canonical user ID for an AWS account or an origin access identity for an
        /// Amazon CloudFront distribution. For more information about canonical user
        /// IDs, see Access Control List (ACL) Overview in the Amazon Simple Storage
        /// Service Developer Guide. For more information about using CloudFront origin
        /// access identities to require that users use CloudFront URLs instead of
        /// Amazon S3 URLs, see Using an Origin Access Identity to Restrict Access to
        /// Your Amazon S3 Content.</p>
        /// <important>
        /// <p>A canonical user ID is not the same as an
        /// AWS account number.</p>
        /// </important>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Email</b>: The value in the <code>Grantee</code> object is the registered
        /// email address of an AWS account.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Group</b>: The value in the <code>Grantee</code> object is one of the
        /// following predefined Amazon S3 groups: <code>AllUsers</code>,
        /// <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Grantee</b>: The AWS user or group that you want to have access to transcoded
        /// files and playlists. To identify the user or group, you can specify the canonical
        /// user ID for an AWS account, an origin access identity for a CloudFront distribution,
        /// the registered email address of an AWS account, or a predefined Amazon S3 group </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Access</b>: The permission that you want to give to the AWS user that you
        /// specified in <code>Grantee</code>. Permissions are granted on the files that Elastic
        /// Transcoder adds to the bucket, including playlists and video files. Valid values
        /// include: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>READ</code>: The grantee can read the objects and metadata for objects
        /// that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>READ_ACP</code>: The grantee can read the object ACL for objects that
        /// Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WRITE_ACP</code>: The grantee can write the ACL for the objects that
        /// Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
        /// <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
        /// objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
        /// <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
        /// the video files and playlists that it stores in your Amazon S3 bucket.</p>
        /// </li>
        /// </ul>
        pub fn content_config(mut self, input: crate::model::PipelineOutputConfig) -> Self {
            self.content_config = Some(input);
            self
        }
        pub fn set_content_config(
            mut self,
            input: std::option::Option<crate::model::PipelineOutputConfig>,
        ) -> Self {
            self.content_config = input;
            self
        }
        /// <p>The <code>ThumbnailConfig</code> object specifies several values, including the Amazon S3
        /// bucket in which you want Elastic Transcoder to save thumbnail files, which users you want to have
        /// access to the files, the type of access you want users to have, and the storage class
        /// that you want to assign to the files.</p>
        /// <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
        /// <code>ThumbnailConfig</code> even if you don't want to create thumbnails.</p>
        /// <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
        /// omit the <code>OutputBucket</code> object.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
        /// thumbnail files.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Permissions</b> (Optional): The <code>Permissions</code> object specifies which
        /// users and/or predefined Amazon S3 groups you want to have access to thumbnail files,
        /// and the type of access you want them to have. You can grant permissions to a maximum
        /// of 30 users and/or predefined Amazon S3 groups.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>GranteeType</b>: Specify the type of value that appears in the Grantee object: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
        /// canonical user ID for an AWS account or an origin access identity for an
        /// Amazon CloudFront distribution.</p>
        /// <important>
        /// <p>A canonical user ID is not the
        /// same as an AWS account number.</p>
        /// </important>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Email</b>: The value in the <code>Grantee</code> object is the registered
        /// email address of an AWS account. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Group</b>: The value in the <code>Grantee</code> object is one of the
        /// following predefined Amazon S3 groups: <code>AllUsers</code>,
        /// <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Grantee</b>: The AWS user or group that you want to have access to thumbnail
        /// files. To identify the user or group, you can specify the canonical user ID for an
        /// AWS account, an origin access identity for a CloudFront distribution, the registered
        /// email address of an AWS account, or a predefined Amazon S3 group. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Access</b>: The permission that you want to give to the AWS user that you
        /// specified in <code>Grantee</code>. Permissions are granted on the thumbnail files
        /// that Elastic Transcoder adds to the bucket. Valid values include: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>READ</code>: The grantee can read the thumbnails and metadata for
        /// objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>READ_ACP</code>: The grantee can read the object ACL for thumbnails
        /// that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WRITE_ACP</code>: The grantee can write the ACL for the thumbnails
        /// that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
        /// <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
        /// thumbnails that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
        /// <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
        /// the thumbnails that it stores in your Amazon S3 bucket.</p>
        /// </li>
        /// </ul>
        pub fn thumbnail_config(mut self, input: crate::model::PipelineOutputConfig) -> Self {
            self.thumbnail_config = Some(input);
            self
        }
        pub fn set_thumbnail_config(
            mut self,
            input: std::option::Option<crate::model::PipelineOutputConfig>,
        ) -> Self {
            self.thumbnail_config = input;
            self
        }
        /// Consumes the builder and constructs a [`CreatePipelineInput`](crate::input::CreatePipelineInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreatePipelineInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreatePipelineInput {
                name: self.name,
                input_bucket: self.input_bucket,
                output_bucket: self.output_bucket,
                role: self.role,
                aws_kms_key_arn: self.aws_kms_key_arn,
                notifications: self.notifications,
                content_config: self.content_config,
                thumbnail_config: self.thumbnail_config,
            })
        }
    }
}
#[doc(hidden)]
pub type CreatePipelineInputOperationOutputAlias = crate::operation::CreatePipeline;
#[doc(hidden)]
pub type CreatePipelineInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreatePipelineInput {
    /// Consumes the builder and constructs an Operation<[`CreatePipeline`](crate::operation::CreatePipeline)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreatePipeline,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_create_pipeline(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreatePipeline::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreatePipeline",
                "elastictranscoder",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/2012-09-25/pipelines").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreatePipelineInput`](crate::input::CreatePipelineInput)
    pub fn builder() -> crate::input::create_pipeline_input::Builder {
        crate::input::create_pipeline_input::Builder::default()
    }
}

/// See [`CreatePresetInput`](crate::input::CreatePresetInput)
pub mod create_preset_input {
    /// A builder for [`CreatePresetInput`](crate::input::CreatePresetInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) container: std::option::Option<std::string::String>,
        pub(crate) video: std::option::Option<crate::model::VideoParameters>,
        pub(crate) audio: std::option::Option<crate::model::AudioParameters>,
        pub(crate) thumbnails: std::option::Option<crate::model::Thumbnails>,
    }
    impl Builder {
        /// <p>The name of the preset. We recommend that the name be unique within the AWS account, but uniqueness is not enforced.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A description of the preset.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The container type for the output file. Valid values include <code>flac</code>,
        /// <code>flv</code>, <code>fmp4</code>,
        /// <code>gif</code>, <code>mp3</code>,
        /// <code>mp4</code>, <code>mpg</code>, <code>mxf</code>, <code>oga</code>,
        /// <code>ogg</code>, <code>ts</code>, and <code>webm</code>.</p>
        pub fn container(mut self, input: impl Into<std::string::String>) -> Self {
            self.container = Some(input.into());
            self
        }
        pub fn set_container(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.container = input;
            self
        }
        /// <p>A section of the request body that specifies the video parameters.</p>
        pub fn video(mut self, input: crate::model::VideoParameters) -> Self {
            self.video = Some(input);
            self
        }
        pub fn set_video(
            mut self,
            input: std::option::Option<crate::model::VideoParameters>,
        ) -> Self {
            self.video = input;
            self
        }
        /// <p>A section of the request body that specifies the audio parameters.</p>
        pub fn audio(mut self, input: crate::model::AudioParameters) -> Self {
            self.audio = Some(input);
            self
        }
        pub fn set_audio(
            mut self,
            input: std::option::Option<crate::model::AudioParameters>,
        ) -> Self {
            self.audio = input;
            self
        }
        /// <p>A section of the request body that specifies the thumbnail parameters, if any.</p>
        pub fn thumbnails(mut self, input: crate::model::Thumbnails) -> Self {
            self.thumbnails = Some(input);
            self
        }
        pub fn set_thumbnails(
            mut self,
            input: std::option::Option<crate::model::Thumbnails>,
        ) -> Self {
            self.thumbnails = input;
            self
        }
        /// Consumes the builder and constructs a [`CreatePresetInput`](crate::input::CreatePresetInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::CreatePresetInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreatePresetInput {
                name: self.name,
                description: self.description,
                container: self.container,
                video: self.video,
                audio: self.audio,
                thumbnails: self.thumbnails,
            })
        }
    }
}
#[doc(hidden)]
pub type CreatePresetInputOperationOutputAlias = crate::operation::CreatePreset;
#[doc(hidden)]
pub type CreatePresetInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreatePresetInput {
    /// Consumes the builder and constructs an Operation<[`CreatePreset`](crate::operation::CreatePreset)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreatePreset,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_create_preset(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreatePreset::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreatePreset",
                "elastictranscoder",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/2012-09-25/presets").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreatePresetInput`](crate::input::CreatePresetInput)
    pub fn builder() -> crate::input::create_preset_input::Builder {
        crate::input::create_preset_input::Builder::default()
    }
}

/// See [`DeletePipelineInput`](crate::input::DeletePipelineInput)
pub mod delete_pipeline_input {
    /// A builder for [`DeletePipelineInput`](crate::input::DeletePipelineInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the pipeline that you want to delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeletePipelineInput`](crate::input::DeletePipelineInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeletePipelineInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeletePipelineInput { id: self.id })
        }
    }
}
#[doc(hidden)]
pub type DeletePipelineInputOperationOutputAlias = crate::operation::DeletePipeline;
#[doc(hidden)]
pub type DeletePipelineInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeletePipelineInput {
    /// Consumes the builder and constructs an Operation<[`DeletePipeline`](crate::operation::DeletePipeline)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeletePipeline,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeletePipeline::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeletePipeline",
                "elastictranscoder",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_2 = &self.id;
        let input_2 = input_2
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "id",
                details: "cannot be empty or unset",
            })?;
        let id = smithy_http::label::fmt_string(input_2, false);
        if id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "id",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/2012-09-25/pipelines/{Id}", Id = id).expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeletePipelineInput`](crate::input::DeletePipelineInput)
    pub fn builder() -> crate::input::delete_pipeline_input::Builder {
        crate::input::delete_pipeline_input::Builder::default()
    }
}

/// See [`DeletePresetInput`](crate::input::DeletePresetInput)
pub mod delete_preset_input {
    /// A builder for [`DeletePresetInput`](crate::input::DeletePresetInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the preset for which you want to get detailed information.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeletePresetInput`](crate::input::DeletePresetInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::DeletePresetInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeletePresetInput { id: self.id })
        }
    }
}
#[doc(hidden)]
pub type DeletePresetInputOperationOutputAlias = crate::operation::DeletePreset;
#[doc(hidden)]
pub type DeletePresetInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeletePresetInput {
    /// Consumes the builder and constructs an Operation<[`DeletePreset`](crate::operation::DeletePreset)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeletePreset,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeletePreset::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeletePreset",
                "elastictranscoder",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_3 = &self.id;
        let input_3 = input_3
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "id",
                details: "cannot be empty or unset",
            })?;
        let id = smithy_http::label::fmt_string(input_3, false);
        if id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "id",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/2012-09-25/presets/{Id}", Id = id).expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("DELETE").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeletePresetInput`](crate::input::DeletePresetInput)
    pub fn builder() -> crate::input::delete_preset_input::Builder {
        crate::input::delete_preset_input::Builder::default()
    }
}

/// See [`ListJobsByPipelineInput`](crate::input::ListJobsByPipelineInput)
pub mod list_jobs_by_pipeline_input {
    /// A builder for [`ListJobsByPipelineInput`](crate::input::ListJobsByPipelineInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pipeline_id: std::option::Option<std::string::String>,
        pub(crate) ascending: std::option::Option<std::string::String>,
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the pipeline for which you want to get job information.</p>
        pub fn pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_id = Some(input.into());
            self
        }
        pub fn set_pipeline_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pipeline_id = input;
            self
        }
        /// <p> To list jobs in chronological order by the date and time that they were submitted, enter
        /// <code>true</code>. To list jobs in reverse chronological order, enter
        /// <code>false</code>. </p>
        pub fn ascending(mut self, input: impl Into<std::string::String>) -> Self {
            self.ascending = Some(input.into());
            self
        }
        pub fn set_ascending(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ascending = input;
            self
        }
        /// <p> When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
        /// subsequent <code>GET</code> requests to get each successive page of results. </p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListJobsByPipelineInput`](crate::input::ListJobsByPipelineInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListJobsByPipelineInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListJobsByPipelineInput {
                pipeline_id: self.pipeline_id,
                ascending: self.ascending,
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListJobsByPipelineInputOperationOutputAlias = crate::operation::ListJobsByPipeline;
#[doc(hidden)]
pub type ListJobsByPipelineInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListJobsByPipelineInput {
    /// Consumes the builder and constructs an Operation<[`ListJobsByPipeline`](crate::operation::ListJobsByPipeline)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListJobsByPipeline,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListJobsByPipeline::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListJobsByPipeline",
                "elastictranscoder",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_4 = &self.pipeline_id;
        let input_4 = input_4
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "pipeline_id",
                details: "cannot be empty or unset",
            })?;
        let pipeline_id = smithy_http::label::fmt_string(input_4, false);
        if pipeline_id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "pipeline_id",
                details: "cannot be empty or unset",
            });
        }
        write!(
            output,
            "/2012-09-25/jobsByPipeline/{PipelineId}",
            PipelineId = pipeline_id
        )
        .expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_5) = &self.ascending {
            query.push_kv("Ascending", &smithy_http::query::fmt_string(&inner_5));
        }
        if let Some(inner_6) = &self.page_token {
            query.push_kv("PageToken", &smithy_http::query::fmt_string(&inner_6));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListJobsByPipelineInput`](crate::input::ListJobsByPipelineInput)
    pub fn builder() -> crate::input::list_jobs_by_pipeline_input::Builder {
        crate::input::list_jobs_by_pipeline_input::Builder::default()
    }
}

/// See [`ListJobsByStatusInput`](crate::input::ListJobsByStatusInput)
pub mod list_jobs_by_status_input {
    /// A builder for [`ListJobsByStatusInput`](crate::input::ListJobsByStatusInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) ascending: std::option::Option<std::string::String>,
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>To get information about all of the jobs associated with the current AWS account that
        /// have a given status, specify the following status: <code>Submitted</code>,
        /// <code>Progressing</code>, <code>Complete</code>, <code>Canceled</code>, or
        /// <code>Error</code>.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p> To list jobs in chronological order by the date and time that they were submitted, enter
        /// <code>true</code>. To list jobs in reverse chronological order, enter
        /// <code>false</code>. </p>
        pub fn ascending(mut self, input: impl Into<std::string::String>) -> Self {
            self.ascending = Some(input.into());
            self
        }
        pub fn set_ascending(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ascending = input;
            self
        }
        /// <p> When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
        /// subsequent <code>GET</code> requests to get each successive page of results. </p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListJobsByStatusInput`](crate::input::ListJobsByStatusInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListJobsByStatusInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListJobsByStatusInput {
                status: self.status,
                ascending: self.ascending,
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListJobsByStatusInputOperationOutputAlias = crate::operation::ListJobsByStatus;
#[doc(hidden)]
pub type ListJobsByStatusInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListJobsByStatusInput {
    /// Consumes the builder and constructs an Operation<[`ListJobsByStatus`](crate::operation::ListJobsByStatus)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListJobsByStatus,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListJobsByStatus::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListJobsByStatus",
                "elastictranscoder",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_7 = &self.status;
        let input_7 = input_7
            .as_ref()
            .ok_or(smithy_http::operation::BuildError::MissingField {
                field: "status",
                details: "cannot be empty or unset",
            })?;
        let status = smithy_http::label::fmt_string(input_7, false);
        if status.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "status",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/2012-09-25/jobsByStatus/{Status}", Status = status)
            .expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_8) = &self.ascending {
            query.push_kv("Ascending", &smithy_http::query::fmt_string(&inner_8));
        }
        if let Some(inner_9) = &self.page_token {
            query.push_kv("PageToken", &smithy_http::query::fmt_string(&inner_9));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListJobsByStatusInput`](crate::input::ListJobsByStatusInput)
    pub fn builder() -> crate::input::list_jobs_by_status_input::Builder {
        crate::input::list_jobs_by_status_input::Builder::default()
    }
}

/// See [`ListPipelinesInput`](crate::input::ListPipelinesInput)
pub mod list_pipelines_input {
    /// A builder for [`ListPipelinesInput`](crate::input::ListPipelinesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ascending: std::option::Option<std::string::String>,
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>To list pipelines in chronological order by the date and time that they were created, enter
        /// <code>true</code>. To list pipelines in reverse chronological order, enter
        /// <code>false</code>.</p>
        pub fn ascending(mut self, input: impl Into<std::string::String>) -> Self {
            self.ascending = Some(input.into());
            self
        }
        pub fn set_ascending(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ascending = input;
            self
        }
        /// <p>When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
        /// subsequent <code>GET</code> requests to get each successive page of results. </p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPipelinesInput`](crate::input::ListPipelinesInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListPipelinesInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListPipelinesInput {
                ascending: self.ascending,
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListPipelinesInputOperationOutputAlias = crate::operation::ListPipelines;
#[doc(hidden)]
pub type ListPipelinesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListPipelinesInput {
    /// Consumes the builder and constructs an Operation<[`ListPipelines`](crate::operation::ListPipelines)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListPipelines,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListPipelines::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListPipelines",
                "elastictranscoder",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/2012-09-25/pipelines").expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_10) = &self.ascending {
            query.push_kv("Ascending", &smithy_http::query::fmt_string(&inner_10));
        }
        if let Some(inner_11) = &self.page_token {
            query.push_kv("PageToken", &smithy_http::query::fmt_string(&inner_11));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListPipelinesInput`](crate::input::ListPipelinesInput)
    pub fn builder() -> crate::input::list_pipelines_input::Builder {
        crate::input::list_pipelines_input::Builder::default()
    }
}

/// See [`ListPresetsInput`](crate::input::ListPresetsInput)
pub mod list_presets_input {
    /// A builder for [`ListPresetsInput`](crate::input::ListPresetsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ascending: std::option::Option<std::string::String>,
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>To list presets in chronological order by the date and time that they were created, enter
        /// <code>true</code>. To list presets in reverse chronological order, enter
        /// <code>false</code>.</p>
        pub fn ascending(mut self, input: impl Into<std::string::String>) -> Self {
            self.ascending = Some(input.into());
            self
        }
        pub fn set_ascending(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ascending = input;
            self
        }
        /// <p>When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
        /// subsequent <code>GET</code> requests to get each successive page of results. </p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPresetsInput`](crate::input::ListPresetsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListPresetsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListPresetsInput {
                ascending: self.ascending,
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListPresetsInputOperationOutputAlias = crate::operation::ListPresets;
#[doc(hidden)]
pub type ListPresetsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListPresetsInput {
    /// Consumes the builder and constructs an Operation<[`ListPresets`](crate::operation::ListPresets)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListPresets,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListPresets::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListPresets",
                "elastictranscoder",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/2012-09-25/presets").expect("formatting should succeed");
        Ok(())
    }
    fn uri_query(&self, mut output: &mut String) {
        let mut query = smithy_http::query::Writer::new(&mut output);
        if let Some(inner_12) = &self.ascending {
            query.push_kv("Ascending", &smithy_http::query::fmt_string(&inner_12));
        }
        if let Some(inner_13) = &self.page_token {
            query.push_kv("PageToken", &smithy_http::query::fmt_string(&inner_13));
        }
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        self.uri_query(&mut uri);
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListPresetsInput`](crate::input::ListPresetsInput)
    pub fn builder() -> crate::input::list_presets_input::Builder {
        crate::input::list_presets_input::Builder::default()
    }
}

/// See [`ReadJobInput`](crate::input::ReadJobInput)
pub mod read_job_input {
    /// A builder for [`ReadJobInput`](crate::input::ReadJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the job for which you want to get detailed information.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`ReadJobInput`](crate::input::ReadJobInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ReadJobInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ReadJobInput { id: self.id })
        }
    }
}
#[doc(hidden)]
pub type ReadJobInputOperationOutputAlias = crate::operation::ReadJob;
#[doc(hidden)]
pub type ReadJobInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ReadJobInput {
    /// Consumes the builder and constructs an Operation<[`ReadJob`](crate::operation::ReadJob)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<crate::operation::ReadJob, aws_http::AwsErrorRetryPolicy>,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::ReadJob::new())
                    .with_metadata(smithy_http::operation::Metadata::new(
                        "ReadJob",
                        "elastictranscoder",
                    ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_14 = &self.id;
        let input_14 =
            input_14
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "id",
                    details: "cannot be empty or unset",
                })?;
        let id = smithy_http::label::fmt_string(input_14, false);
        if id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "id",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/2012-09-25/jobs/{Id}", Id = id).expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ReadJobInput`](crate::input::ReadJobInput)
    pub fn builder() -> crate::input::read_job_input::Builder {
        crate::input::read_job_input::Builder::default()
    }
}

/// See [`ReadPipelineInput`](crate::input::ReadPipelineInput)
pub mod read_pipeline_input {
    /// A builder for [`ReadPipelineInput`](crate::input::ReadPipelineInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the pipeline to read.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`ReadPipelineInput`](crate::input::ReadPipelineInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ReadPipelineInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ReadPipelineInput { id: self.id })
        }
    }
}
#[doc(hidden)]
pub type ReadPipelineInputOperationOutputAlias = crate::operation::ReadPipeline;
#[doc(hidden)]
pub type ReadPipelineInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ReadPipelineInput {
    /// Consumes the builder and constructs an Operation<[`ReadPipeline`](crate::operation::ReadPipeline)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ReadPipeline,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ReadPipeline::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ReadPipeline",
                "elastictranscoder",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_15 = &self.id;
        let input_15 =
            input_15
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "id",
                    details: "cannot be empty or unset",
                })?;
        let id = smithy_http::label::fmt_string(input_15, false);
        if id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "id",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/2012-09-25/pipelines/{Id}", Id = id).expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ReadPipelineInput`](crate::input::ReadPipelineInput)
    pub fn builder() -> crate::input::read_pipeline_input::Builder {
        crate::input::read_pipeline_input::Builder::default()
    }
}

/// See [`ReadPresetInput`](crate::input::ReadPresetInput)
pub mod read_preset_input {
    /// A builder for [`ReadPresetInput`](crate::input::ReadPresetInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the preset for which you want to get detailed information.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`ReadPresetInput`](crate::input::ReadPresetInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ReadPresetInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ReadPresetInput { id: self.id })
        }
    }
}
#[doc(hidden)]
pub type ReadPresetInputOperationOutputAlias = crate::operation::ReadPreset;
#[doc(hidden)]
pub type ReadPresetInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ReadPresetInput {
    /// Consumes the builder and constructs an Operation<[`ReadPreset`](crate::operation::ReadPreset)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ReadPreset,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = smithy_http::body::SdkBody::from("");
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ReadPreset::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ReadPreset",
                "elastictranscoder",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_16 = &self.id;
        let input_16 =
            input_16
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "id",
                    details: "cannot be empty or unset",
                })?;
        let id = smithy_http::label::fmt_string(input_16, false);
        if id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "id",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/2012-09-25/presets/{Id}", Id = id).expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("GET").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ReadPresetInput`](crate::input::ReadPresetInput)
    pub fn builder() -> crate::input::read_preset_input::Builder {
        crate::input::read_preset_input::Builder::default()
    }
}

/// See [`TestRoleInput`](crate::input::TestRoleInput)
pub mod test_role_input {
    /// A builder for [`TestRoleInput`](crate::input::TestRoleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role: std::option::Option<std::string::String>,
        pub(crate) input_bucket: std::option::Option<std::string::String>,
        pub(crate) output_bucket: std::option::Option<std::string::String>,
        pub(crate) topics: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The IAM Amazon Resource Name (ARN) for the role that you want Elastic Transcoder to test.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.role = Some(input.into());
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role = input;
            self
        }
        /// <p>The Amazon S3 bucket that contains media files to be transcoded. The action attempts to read from this bucket.</p>
        pub fn input_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_bucket = Some(input.into());
            self
        }
        pub fn set_input_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input_bucket = input;
            self
        }
        /// <p>The Amazon S3 bucket that Elastic Transcoder writes transcoded media files to. The action attempts to read from this bucket.</p>
        pub fn output_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_bucket = Some(input.into());
            self
        }
        pub fn set_output_bucket(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_bucket = input;
            self
        }
        pub fn topics(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.topics.unwrap_or_default();
            v.push(input.into());
            self.topics = Some(v);
            self
        }
        pub fn set_topics(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.topics = input;
            self
        }
        /// Consumes the builder and constructs a [`TestRoleInput`](crate::input::TestRoleInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::TestRoleInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::TestRoleInput {
                role: self.role,
                input_bucket: self.input_bucket,
                output_bucket: self.output_bucket,
                topics: self.topics,
            })
        }
    }
}
#[doc(hidden)]
pub type TestRoleInputOperationOutputAlias = crate::operation::TestRole;
#[doc(hidden)]
pub type TestRoleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TestRoleInput {
    /// Consumes the builder and constructs an Operation<[`TestRole`](crate::operation::TestRole)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::TestRole,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_test_role(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::TestRole::new())
                    .with_metadata(smithy_http::operation::Metadata::new(
                        "TestRole",
                        "elastictranscoder",
                    ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/2012-09-25/roleTests").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TestRoleInput`](crate::input::TestRoleInput)
    pub fn builder() -> crate::input::test_role_input::Builder {
        crate::input::test_role_input::Builder::default()
    }
}

/// See [`UpdatePipelineInput`](crate::input::UpdatePipelineInput)
pub mod update_pipeline_input {
    /// A builder for [`UpdatePipelineInput`](crate::input::UpdatePipelineInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) input_bucket: std::option::Option<std::string::String>,
        pub(crate) role: std::option::Option<std::string::String>,
        pub(crate) aws_kms_key_arn: std::option::Option<std::string::String>,
        pub(crate) notifications: std::option::Option<crate::model::Notifications>,
        pub(crate) content_config: std::option::Option<crate::model::PipelineOutputConfig>,
        pub(crate) thumbnail_config: std::option::Option<crate::model::PipelineOutputConfig>,
    }
    impl Builder {
        /// <p>The ID of the pipeline that you want to update.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the pipeline. We recommend that the name be unique within the AWS account, but
        /// uniqueness is not enforced.</p>
        /// <p>Constraints: Maximum 40 characters</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon S3 bucket in which you saved the media files that you want to transcode and the graphics
        /// that you want to use as watermarks.</p>
        pub fn input_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_bucket = Some(input.into());
            self
        }
        pub fn set_input_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input_bucket = input;
            self
        }
        /// <p>The IAM Amazon Resource Name (ARN) for the role that you want Elastic Transcoder to use to transcode jobs for
        /// this pipeline.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.role = Some(input.into());
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role = input;
            self
        }
        /// <p>The AWS Key Management Service (AWS KMS) key that you want to use with this pipeline.</p>
        /// <p>If you use either <code>s3</code> or <code>s3-aws-kms</code> as your <code>Encryption:Mode</code>,
        /// you don't need to provide a key with your job because a default key, known as an AWS-KMS key, is
        /// created for you automatically. You need to provide an AWS-KMS key only if you want to use a non-default
        /// AWS-KMS key, or if you are using an <code>Encryption:Mode</code> of <code>aes-cbc-pkcs7</code>, <code>aes-ctr</code>,
        /// or <code>aes-gcm</code>.</p>
        pub fn aws_kms_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_kms_key_arn = Some(input.into());
            self
        }
        pub fn set_aws_kms_key_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.aws_kms_key_arn = input;
            self
        }
        /// <p>The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status.</p>
        /// <important>
        /// <p>To receive notifications, you must also subscribe to the new topic in the Amazon SNS console.</p>
        /// </important>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Progressing</b>: The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to
        /// notify when Elastic Transcoder has started to process jobs that are added to this pipeline. This
        /// is the ARN that Amazon SNS returned when you created the topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Complete</b>: The topic ARN for the Amazon SNS topic that you want to notify when
        /// Elastic Transcoder has finished processing a job. This is the ARN that Amazon SNS returned when
        /// you created the topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Warning</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
        /// encounters a warning condition. This is the ARN that Amazon SNS returned when you
        /// created the topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Error</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
        /// encounters an error condition. This is the ARN that Amazon SNS returned when you
        /// created the topic.</p>
        /// </li>
        /// </ul>
        pub fn notifications(mut self, input: crate::model::Notifications) -> Self {
            self.notifications = Some(input);
            self
        }
        pub fn set_notifications(
            mut self,
            input: std::option::Option<crate::model::Notifications>,
        ) -> Self {
            self.notifications = input;
            self
        }
        /// <p>The optional <code>ContentConfig</code> object specifies information about the Amazon S3
        /// bucket in which you want Elastic Transcoder to save transcoded files and playlists:
        /// which bucket to use, which users you want to have access to the files, the type of
        /// access you want users to have, and the storage class that you want to assign to the
        /// files.</p>
        /// <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
        /// <code>ThumbnailConfig</code>.</p>
        /// <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
        /// omit the <code>OutputBucket</code> object.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
        /// transcoded files and playlists.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Permissions</b> (Optional): The Permissions object specifies which users you want
        /// to have access to transcoded files and the type of access you want them to have. You
        /// can grant permissions to a maximum of 30 users and/or predefined Amazon S3
        /// groups.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Grantee Type</b>: Specify the type of value that appears in the
        /// <code>Grantee</code> object:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
        /// canonical user ID for an AWS account or an origin access identity for an
        /// Amazon CloudFront distribution. For more information about canonical user
        /// IDs, see Access Control List (ACL) Overview in the Amazon Simple Storage
        /// Service Developer Guide. For more information about using CloudFront origin
        /// access identities to require that users use CloudFront URLs instead of
        /// Amazon S3 URLs, see Using an Origin Access Identity to Restrict Access to
        /// Your Amazon S3 Content.</p>
        /// <important>
        /// <p>A canonical user ID is not the same as an
        /// AWS account number.</p>
        /// </important>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Email</b>: The value in the <code>Grantee</code> object is the registered
        /// email address of an AWS account.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Group</b>: The value in the <code>Grantee</code> object is one of the
        /// following predefined Amazon S3 groups: <code>AllUsers</code>,
        /// <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Grantee</b>: The AWS user or group that you want to have access to transcoded
        /// files and playlists. To identify the user or group, you can specify the canonical
        /// user ID for an AWS account, an origin access identity for a CloudFront distribution,
        /// the registered email address of an AWS account, or a predefined Amazon S3 group </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Access</b>: The permission that you want to give to the AWS user that you
        /// specified in <code>Grantee</code>. Permissions are granted on the files that Elastic
        /// Transcoder adds to the bucket, including playlists and video files. Valid values
        /// include: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>READ</code>: The grantee can read the objects and metadata for objects
        /// that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>READ_ACP</code>: The grantee can read the object ACL for objects that
        /// Elastic Transcoder adds to the Amazon S3 bucket. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WRITE_ACP</code>: The grantee can write the ACL for the objects that
        /// Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
        /// <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
        /// objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
        /// <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
        /// the video files and playlists that it stores in your Amazon S3 bucket.</p>
        /// </li>
        /// </ul>
        pub fn content_config(mut self, input: crate::model::PipelineOutputConfig) -> Self {
            self.content_config = Some(input);
            self
        }
        pub fn set_content_config(
            mut self,
            input: std::option::Option<crate::model::PipelineOutputConfig>,
        ) -> Self {
            self.content_config = input;
            self
        }
        /// <p>The <code>ThumbnailConfig</code> object specifies several values, including the Amazon S3
        /// bucket in which you want Elastic Transcoder to save thumbnail files, which users you want to have
        /// access to the files, the type of access you want users to have, and the storage class
        /// that you want to assign to the files.</p>
        /// <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
        /// <code>ThumbnailConfig</code> even if you don't want to create thumbnails.</p>
        /// <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
        /// omit the <code>OutputBucket</code> object.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
        /// thumbnail files.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Permissions</b> (Optional): The <code>Permissions</code> object specifies which
        /// users and/or predefined Amazon S3 groups you want to have access to thumbnail files,
        /// and the type of access you want them to have. You can grant permissions to a maximum
        /// of 30 users and/or predefined Amazon S3 groups.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>GranteeType</b>: Specify the type of value that appears in the Grantee object:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
        /// canonical user ID for an AWS account or an origin access identity for an
        /// Amazon CloudFront distribution.</p>
        /// <important>
        /// <p>A canonical user ID is not the
        /// same as an AWS account number.</p>
        /// </important>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Email</b>: The value in the <code>Grantee</code> object is the registered
        /// email address of an AWS account.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Group</b>: The value in the <code>Grantee</code> object is one of the
        /// following predefined Amazon S3 groups: <code>AllUsers</code>,
        /// <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Grantee</b>: The AWS user or group that you want to have access to thumbnail
        /// files. To identify the user or group, you can specify the canonical user ID for an
        /// AWS account, an origin access identity for a CloudFront distribution, the registered
        /// email address of an AWS account, or a predefined Amazon S3 group. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Access</b>: The permission that you want to give to the AWS user that you
        /// specified in <code>Grantee</code>. Permissions are granted on the thumbnail files
        /// that Elastic Transcoder adds to the bucket. Valid values include: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>READ</code>: The grantee can read the thumbnails and metadata for
        /// objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>READ_ACP</code>: The grantee can read the object ACL for thumbnails
        /// that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WRITE_ACP</code>: The grantee can write the ACL for the thumbnails
        /// that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
        /// <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
        /// thumbnails that Elastic Transcoder adds to the Amazon S3 bucket. </p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
        /// <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
        /// the thumbnails that it stores in your Amazon S3 bucket.</p>
        /// </li>
        /// </ul>
        pub fn thumbnail_config(mut self, input: crate::model::PipelineOutputConfig) -> Self {
            self.thumbnail_config = Some(input);
            self
        }
        pub fn set_thumbnail_config(
            mut self,
            input: std::option::Option<crate::model::PipelineOutputConfig>,
        ) -> Self {
            self.thumbnail_config = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdatePipelineInput`](crate::input::UpdatePipelineInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdatePipelineInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdatePipelineInput {
                id: self.id,
                name: self.name,
                input_bucket: self.input_bucket,
                role: self.role,
                aws_kms_key_arn: self.aws_kms_key_arn,
                notifications: self.notifications,
                content_config: self.content_config,
                thumbnail_config: self.thumbnail_config,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdatePipelineInputOperationOutputAlias = crate::operation::UpdatePipeline;
#[doc(hidden)]
pub type UpdatePipelineInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdatePipelineInput {
    /// Consumes the builder and constructs an Operation<[`UpdatePipeline`](crate::operation::UpdatePipeline)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdatePipeline,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_update_pipeline(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdatePipeline::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdatePipeline",
                "elastictranscoder",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_17 = &self.id;
        let input_17 =
            input_17
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "id",
                    details: "cannot be empty or unset",
                })?;
        let id = smithy_http::label::fmt_string(input_17, false);
        if id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "id",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/2012-09-25/pipelines/{Id}", Id = id).expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("PUT").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdatePipelineInput`](crate::input::UpdatePipelineInput)
    pub fn builder() -> crate::input::update_pipeline_input::Builder {
        crate::input::update_pipeline_input::Builder::default()
    }
}

/// See [`UpdatePipelineNotificationsInput`](crate::input::UpdatePipelineNotificationsInput)
pub mod update_pipeline_notifications_input {
    /// A builder for [`UpdatePipelineNotificationsInput`](crate::input::UpdatePipelineNotificationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) notifications: std::option::Option<crate::model::Notifications>,
    }
    impl Builder {
        /// <p>The identifier of the pipeline for which you want to change notification settings.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status.</p>
        /// <important>
        /// <p>To receive notifications, you must also subscribe to the new topic in the Amazon SNS console.</p>
        /// </important>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Progressing</b>: The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to
        /// notify when Elastic Transcoder has started to process jobs that are added to this pipeline. This
        /// is the ARN that Amazon SNS returned when you created the topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Complete</b>: The topic ARN for the Amazon SNS topic that you want to notify when
        /// Elastic Transcoder has finished processing a job. This is the ARN that Amazon SNS returned when
        /// you created the topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Warning</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
        /// encounters a warning condition. This is the ARN that Amazon SNS returned when you
        /// created the topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Error</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
        /// encounters an error condition. This is the ARN that Amazon SNS returned when you
        /// created the topic.</p>
        /// </li>
        /// </ul>
        pub fn notifications(mut self, input: crate::model::Notifications) -> Self {
            self.notifications = Some(input);
            self
        }
        pub fn set_notifications(
            mut self,
            input: std::option::Option<crate::model::Notifications>,
        ) -> Self {
            self.notifications = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdatePipelineNotificationsInput`](crate::input::UpdatePipelineNotificationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdatePipelineNotificationsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdatePipelineNotificationsInput {
                id: self.id,
                notifications: self.notifications,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdatePipelineNotificationsInputOperationOutputAlias =
    crate::operation::UpdatePipelineNotifications;
#[doc(hidden)]
pub type UpdatePipelineNotificationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdatePipelineNotificationsInput {
    /// Consumes the builder and constructs an Operation<[`UpdatePipelineNotifications`](crate::operation::UpdatePipelineNotifications)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdatePipelineNotifications,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_update_pipeline_notifications(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdatePipelineNotifications::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdatePipelineNotifications",
                "elastictranscoder",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_18 = &self.id;
        let input_18 =
            input_18
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "id",
                    details: "cannot be empty or unset",
                })?;
        let id = smithy_http::label::fmt_string(input_18, false);
        if id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "id",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/2012-09-25/pipelines/{Id}/notifications", Id = id)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdatePipelineNotificationsInput`](crate::input::UpdatePipelineNotificationsInput)
    pub fn builder() -> crate::input::update_pipeline_notifications_input::Builder {
        crate::input::update_pipeline_notifications_input::Builder::default()
    }
}

/// See [`UpdatePipelineStatusInput`](crate::input::UpdatePipelineStatusInput)
pub mod update_pipeline_status_input {
    /// A builder for [`UpdatePipelineStatusInput`](crate::input::UpdatePipelineStatusInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the pipeline to update.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The desired status of the pipeline:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Active</code>: The pipeline is processing jobs.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Paused</code>: The pipeline is not currently processing jobs.</p>
        /// </li>
        /// </ul>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdatePipelineStatusInput`](crate::input::UpdatePipelineStatusInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdatePipelineStatusInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdatePipelineStatusInput {
                id: self.id,
                status: self.status,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdatePipelineStatusInputOperationOutputAlias = crate::operation::UpdatePipelineStatus;
#[doc(hidden)]
pub type UpdatePipelineStatusInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdatePipelineStatusInput {
    /// Consumes the builder and constructs an Operation<[`UpdatePipelineStatus`](crate::operation::UpdatePipelineStatus)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdatePipelineStatus,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_update_pipeline_status(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdatePipelineStatus::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdatePipelineStatus",
                "elastictranscoder",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        let input_19 = &self.id;
        let input_19 =
            input_19
                .as_ref()
                .ok_or(smithy_http::operation::BuildError::MissingField {
                    field: "id",
                    details: "cannot be empty or unset",
                })?;
        let id = smithy_http::label::fmt_string(input_19, false);
        if id.is_empty() {
            return Err(smithy_http::operation::BuildError::MissingField {
                field: "id",
                details: "cannot be empty or unset",
            });
        }
        write!(output, "/2012-09-25/pipelines/{Id}/status", Id = id)
            .expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder =
            smithy_http::header::set_header_if_absent(builder, "content-type", "application/json");
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdatePipelineStatusInput`](crate::input::UpdatePipelineStatusInput)
    pub fn builder() -> crate::input::update_pipeline_status_input::Builder {
        crate::input::update_pipeline_status_input::Builder::default()
    }
}

/// <p>The <code>UpdatePipelineStatusRequest</code> structure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdatePipelineStatusInput {
    /// <p>The identifier of the pipeline to update.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The desired status of the pipeline:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Active</code>: The pipeline is processing jobs.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Paused</code>: The pipeline is not currently processing jobs.</p>
    /// </li>
    /// </ul>
    pub status: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdatePipelineStatusInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdatePipelineStatusInput");
        formatter.field("id", &self.id);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}

/// <p>The <code>UpdatePipelineNotificationsRequest</code> structure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdatePipelineNotificationsInput {
    /// <p>The identifier of the pipeline for which you want to change notification settings.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status.</p>
    /// <important>
    /// <p>To receive notifications, you must also subscribe to the new topic in the Amazon SNS console.</p>
    /// </important>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Progressing</b>: The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to
    /// notify when Elastic Transcoder has started to process jobs that are added to this pipeline. This
    /// is the ARN that Amazon SNS returned when you created the topic.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Complete</b>: The topic ARN for the Amazon SNS topic that you want to notify when
    /// Elastic Transcoder has finished processing a job. This is the ARN that Amazon SNS returned when
    /// you created the topic.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Warning</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
    /// encounters a warning condition. This is the ARN that Amazon SNS returned when you
    /// created the topic.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Error</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
    /// encounters an error condition. This is the ARN that Amazon SNS returned when you
    /// created the topic.</p>
    /// </li>
    /// </ul>
    pub notifications: std::option::Option<crate::model::Notifications>,
}
impl std::fmt::Debug for UpdatePipelineNotificationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdatePipelineNotificationsInput");
        formatter.field("id", &self.id);
        formatter.field("notifications", &self.notifications);
        formatter.finish()
    }
}

/// <p>The <code>UpdatePipelineRequest</code> structure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdatePipelineInput {
    /// <p>The ID of the pipeline that you want to update.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the pipeline. We recommend that the name be unique within the AWS account, but
    /// uniqueness is not enforced.</p>
    /// <p>Constraints: Maximum 40 characters</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 bucket in which you saved the media files that you want to transcode and the graphics
    /// that you want to use as watermarks.</p>
    pub input_bucket: std::option::Option<std::string::String>,
    /// <p>The IAM Amazon Resource Name (ARN) for the role that you want Elastic Transcoder to use to transcode jobs for
    /// this pipeline.</p>
    pub role: std::option::Option<std::string::String>,
    /// <p>The AWS Key Management Service (AWS KMS) key that you want to use with this pipeline.</p>
    /// <p>If you use either <code>s3</code> or <code>s3-aws-kms</code> as your <code>Encryption:Mode</code>,
    /// you don't need to provide a key with your job because a default key, known as an AWS-KMS key, is
    /// created for you automatically. You need to provide an AWS-KMS key only if you want to use a non-default
    /// AWS-KMS key, or if you are using an <code>Encryption:Mode</code> of <code>aes-cbc-pkcs7</code>, <code>aes-ctr</code>,
    /// or <code>aes-gcm</code>.</p>
    pub aws_kms_key_arn: std::option::Option<std::string::String>,
    /// <p>The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status.</p>
    /// <important>
    /// <p>To receive notifications, you must also subscribe to the new topic in the Amazon SNS console.</p>
    /// </important>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Progressing</b>: The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to
    /// notify when Elastic Transcoder has started to process jobs that are added to this pipeline. This
    /// is the ARN that Amazon SNS returned when you created the topic.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Complete</b>: The topic ARN for the Amazon SNS topic that you want to notify when
    /// Elastic Transcoder has finished processing a job. This is the ARN that Amazon SNS returned when
    /// you created the topic.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Warning</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
    /// encounters a warning condition. This is the ARN that Amazon SNS returned when you
    /// created the topic.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Error</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
    /// encounters an error condition. This is the ARN that Amazon SNS returned when you
    /// created the topic.</p>
    /// </li>
    /// </ul>
    pub notifications: std::option::Option<crate::model::Notifications>,
    /// <p>The optional <code>ContentConfig</code> object specifies information about the Amazon S3
    /// bucket in which you want Elastic Transcoder to save transcoded files and playlists:
    /// which bucket to use, which users you want to have access to the files, the type of
    /// access you want users to have, and the storage class that you want to assign to the
    /// files.</p>
    /// <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
    /// <code>ThumbnailConfig</code>.</p>
    /// <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
    /// omit the <code>OutputBucket</code> object.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
    /// transcoded files and playlists.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Permissions</b> (Optional): The Permissions object specifies which users you want
    /// to have access to transcoded files and the type of access you want them to have. You
    /// can grant permissions to a maximum of 30 users and/or predefined Amazon S3
    /// groups.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Grantee Type</b>: Specify the type of value that appears in the
    /// <code>Grantee</code> object:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
    /// canonical user ID for an AWS account or an origin access identity for an
    /// Amazon CloudFront distribution. For more information about canonical user
    /// IDs, see Access Control List (ACL) Overview in the Amazon Simple Storage
    /// Service Developer Guide. For more information about using CloudFront origin
    /// access identities to require that users use CloudFront URLs instead of
    /// Amazon S3 URLs, see Using an Origin Access Identity to Restrict Access to
    /// Your Amazon S3 Content.</p>
    /// <important>
    /// <p>A canonical user ID is not the same as an
    /// AWS account number.</p>
    /// </important>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Email</b>: The value in the <code>Grantee</code> object is the registered
    /// email address of an AWS account.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Group</b>: The value in the <code>Grantee</code> object is one of the
    /// following predefined Amazon S3 groups: <code>AllUsers</code>,
    /// <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Grantee</b>: The AWS user or group that you want to have access to transcoded
    /// files and playlists. To identify the user or group, you can specify the canonical
    /// user ID for an AWS account, an origin access identity for a CloudFront distribution,
    /// the registered email address of an AWS account, or a predefined Amazon S3 group </p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Access</b>: The permission that you want to give to the AWS user that you
    /// specified in <code>Grantee</code>. Permissions are granted on the files that Elastic
    /// Transcoder adds to the bucket, including playlists and video files. Valid values
    /// include: </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>READ</code>: The grantee can read the objects and metadata for objects
    /// that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>READ_ACP</code>: The grantee can read the object ACL for objects that
    /// Elastic Transcoder adds to the Amazon S3 bucket. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>WRITE_ACP</code>: The grantee can write the ACL for the objects that
    /// Elastic Transcoder adds to the Amazon S3 bucket.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
    /// <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
    /// objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
    /// <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
    /// the video files and playlists that it stores in your Amazon S3 bucket.</p>
    /// </li>
    /// </ul>
    pub content_config: std::option::Option<crate::model::PipelineOutputConfig>,
    /// <p>The <code>ThumbnailConfig</code> object specifies several values, including the Amazon S3
    /// bucket in which you want Elastic Transcoder to save thumbnail files, which users you want to have
    /// access to the files, the type of access you want users to have, and the storage class
    /// that you want to assign to the files.</p>
    /// <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
    /// <code>ThumbnailConfig</code> even if you don't want to create thumbnails.</p>
    /// <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
    /// omit the <code>OutputBucket</code> object.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
    /// thumbnail files.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Permissions</b> (Optional): The <code>Permissions</code> object specifies which
    /// users and/or predefined Amazon S3 groups you want to have access to thumbnail files,
    /// and the type of access you want them to have. You can grant permissions to a maximum
    /// of 30 users and/or predefined Amazon S3 groups.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>GranteeType</b>: Specify the type of value that appears in the Grantee object:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
    /// canonical user ID for an AWS account or an origin access identity for an
    /// Amazon CloudFront distribution.</p>
    /// <important>
    /// <p>A canonical user ID is not the
    /// same as an AWS account number.</p>
    /// </important>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Email</b>: The value in the <code>Grantee</code> object is the registered
    /// email address of an AWS account.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Group</b>: The value in the <code>Grantee</code> object is one of the
    /// following predefined Amazon S3 groups: <code>AllUsers</code>,
    /// <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Grantee</b>: The AWS user or group that you want to have access to thumbnail
    /// files. To identify the user or group, you can specify the canonical user ID for an
    /// AWS account, an origin access identity for a CloudFront distribution, the registered
    /// email address of an AWS account, or a predefined Amazon S3 group. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Access</b>: The permission that you want to give to the AWS user that you
    /// specified in <code>Grantee</code>. Permissions are granted on the thumbnail files
    /// that Elastic Transcoder adds to the bucket. Valid values include: </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>READ</code>: The grantee can read the thumbnails and metadata for
    /// objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>READ_ACP</code>: The grantee can read the object ACL for thumbnails
    /// that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>WRITE_ACP</code>: The grantee can write the ACL for the thumbnails
    /// that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
    /// <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
    /// thumbnails that Elastic Transcoder adds to the Amazon S3 bucket. </p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
    /// <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
    /// the thumbnails that it stores in your Amazon S3 bucket.</p>
    /// </li>
    /// </ul>
    pub thumbnail_config: std::option::Option<crate::model::PipelineOutputConfig>,
}
impl std::fmt::Debug for UpdatePipelineInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdatePipelineInput");
        formatter.field("id", &self.id);
        formatter.field("name", &self.name);
        formatter.field("input_bucket", &self.input_bucket);
        formatter.field("role", &self.role);
        formatter.field("aws_kms_key_arn", &self.aws_kms_key_arn);
        formatter.field("notifications", &self.notifications);
        formatter.field("content_config", &self.content_config);
        formatter.field("thumbnail_config", &self.thumbnail_config);
        formatter.finish()
    }
}

/// <p> The <code>TestRoleRequest</code> structure. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TestRoleInput {
    /// <p>The IAM Amazon Resource Name (ARN) for the role that you want Elastic Transcoder to test.</p>
    pub role: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 bucket that contains media files to be transcoded. The action attempts to read from this bucket.</p>
    pub input_bucket: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 bucket that Elastic Transcoder writes transcoded media files to. The action attempts to read from this bucket.</p>
    pub output_bucket: std::option::Option<std::string::String>,
    /// <p>The ARNs of one or more Amazon Simple Notification Service (Amazon SNS) topics that you want the action to send a test notification to.</p>
    pub topics: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for TestRoleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TestRoleInput");
        formatter.field("role", &self.role);
        formatter.field("input_bucket", &self.input_bucket);
        formatter.field("output_bucket", &self.output_bucket);
        formatter.field("topics", &self.topics);
        formatter.finish()
    }
}

/// <p>The <code>ReadPresetRequest</code> structure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReadPresetInput {
    /// <p>The identifier of the preset for which you want to get detailed information.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReadPresetInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReadPresetInput");
        formatter.field("id", &self.id);
        formatter.finish()
    }
}

/// <p>The <code>ReadPipelineRequest</code> structure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReadPipelineInput {
    /// <p>The identifier of the pipeline to read.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReadPipelineInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReadPipelineInput");
        formatter.field("id", &self.id);
        formatter.finish()
    }
}

/// <p>The <code>ReadJobRequest</code> structure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReadJobInput {
    /// <p>The identifier of the job for which you want to get detailed information.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReadJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReadJobInput");
        formatter.field("id", &self.id);
        formatter.finish()
    }
}

/// <p>The <code>ListPresetsRequest</code> structure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPresetsInput {
    /// <p>To list presets in chronological order by the date and time that they were created, enter
    /// <code>true</code>. To list presets in reverse chronological order, enter
    /// <code>false</code>.</p>
    pub ascending: std::option::Option<std::string::String>,
    /// <p>When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
    /// subsequent <code>GET</code> requests to get each successive page of results. </p>
    pub page_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListPresetsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPresetsInput");
        formatter.field("ascending", &self.ascending);
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

/// <p>The <code>ListPipelineRequest</code> structure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPipelinesInput {
    /// <p>To list pipelines in chronological order by the date and time that they were created, enter
    /// <code>true</code>. To list pipelines in reverse chronological order, enter
    /// <code>false</code>.</p>
    pub ascending: std::option::Option<std::string::String>,
    /// <p>When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
    /// subsequent <code>GET</code> requests to get each successive page of results. </p>
    pub page_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListPipelinesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPipelinesInput");
        formatter.field("ascending", &self.ascending);
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

/// <p>The <code>ListJobsByStatusRequest</code> structure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListJobsByStatusInput {
    /// <p>To get information about all of the jobs associated with the current AWS account that
    /// have a given status, specify the following status: <code>Submitted</code>,
    /// <code>Progressing</code>, <code>Complete</code>, <code>Canceled</code>, or
    /// <code>Error</code>.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p> To list jobs in chronological order by the date and time that they were submitted, enter
    /// <code>true</code>. To list jobs in reverse chronological order, enter
    /// <code>false</code>. </p>
    pub ascending: std::option::Option<std::string::String>,
    /// <p> When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
    /// subsequent <code>GET</code> requests to get each successive page of results. </p>
    pub page_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListJobsByStatusInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListJobsByStatusInput");
        formatter.field("status", &self.status);
        formatter.field("ascending", &self.ascending);
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

/// <p>The <code>ListJobsByPipelineRequest</code> structure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListJobsByPipelineInput {
    /// <p>The ID of the pipeline for which you want to get job information.</p>
    pub pipeline_id: std::option::Option<std::string::String>,
    /// <p> To list jobs in chronological order by the date and time that they were submitted, enter
    /// <code>true</code>. To list jobs in reverse chronological order, enter
    /// <code>false</code>. </p>
    pub ascending: std::option::Option<std::string::String>,
    /// <p> When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
    /// subsequent <code>GET</code> requests to get each successive page of results. </p>
    pub page_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListJobsByPipelineInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListJobsByPipelineInput");
        formatter.field("pipeline_id", &self.pipeline_id);
        formatter.field("ascending", &self.ascending);
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

/// <p>The <code>DeletePresetRequest</code> structure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePresetInput {
    /// <p>The identifier of the preset for which you want to get detailed information.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeletePresetInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePresetInput");
        formatter.field("id", &self.id);
        formatter.finish()
    }
}

/// <p>The <code>DeletePipelineRequest</code> structure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePipelineInput {
    /// <p>The identifier of the pipeline that you want to delete.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeletePipelineInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePipelineInput");
        formatter.field("id", &self.id);
        formatter.finish()
    }
}

/// <p>The <code>CreatePresetRequest</code> structure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePresetInput {
    /// <p>The name of the preset. We recommend that the name be unique within the AWS account, but uniqueness is not enforced.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A description of the preset.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The container type for the output file. Valid values include <code>flac</code>,
    /// <code>flv</code>, <code>fmp4</code>,
    /// <code>gif</code>, <code>mp3</code>,
    /// <code>mp4</code>, <code>mpg</code>, <code>mxf</code>, <code>oga</code>,
    /// <code>ogg</code>, <code>ts</code>, and <code>webm</code>.</p>
    pub container: std::option::Option<std::string::String>,
    /// <p>A section of the request body that specifies the video parameters.</p>
    pub video: std::option::Option<crate::model::VideoParameters>,
    /// <p>A section of the request body that specifies the audio parameters.</p>
    pub audio: std::option::Option<crate::model::AudioParameters>,
    /// <p>A section of the request body that specifies the thumbnail parameters, if any.</p>
    pub thumbnails: std::option::Option<crate::model::Thumbnails>,
}
impl std::fmt::Debug for CreatePresetInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePresetInput");
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("container", &self.container);
        formatter.field("video", &self.video);
        formatter.field("audio", &self.audio);
        formatter.field("thumbnails", &self.thumbnails);
        formatter.finish()
    }
}

/// <p>The <code>CreatePipelineRequest</code> structure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePipelineInput {
    /// <p>The name of the pipeline. We recommend that the name be unique within the AWS account,
    /// but uniqueness is not enforced.</p>
    /// <p>Constraints: Maximum 40 characters.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 bucket in which you saved the media files that you want to transcode.</p>
    pub input_bucket: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 bucket in which you want Elastic Transcoder to save the transcoded files. (Use
    /// this, or use ContentConfig:Bucket plus ThumbnailConfig:Bucket.)</p>
    /// <p>Specify this value when all of the following are true:</p>
    /// <ul>
    /// <li>
    /// <p>You want to save transcoded files, thumbnails (if any), and playlists (if any)
    /// together in one bucket.</p>
    /// </li>
    /// <li>
    /// <p>You do not want to specify the users or groups who have access to the transcoded
    /// files, thumbnails, and playlists.</p>
    /// </li>
    /// <li>
    /// <p>You do not want to specify the permissions that Elastic Transcoder grants to the   
    /// files. </p>
    /// <important>
    /// <p>When Elastic Transcoder saves files in
    /// <code>OutputBucket</code>, it grants full control over the files only to
    /// the AWS account that owns the role that is specified by
    /// <code>Role</code>.</p>
    /// </important>
    /// </li>
    /// <li>
    /// <p>You want to associate the transcoded files and thumbnails with the Amazon S3
    /// Standard storage class.</p>
    /// </li>
    /// </ul>
    /// <p>If you want to save transcoded files and playlists in one bucket and thumbnails in
    /// another bucket, specify which users can access the transcoded files or the permissions
    /// the users have, or change the Amazon S3 storage class, omit <code>OutputBucket</code>
    /// and specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>
    /// instead.</p>
    pub output_bucket: std::option::Option<std::string::String>,
    /// <p>The IAM Amazon Resource Name (ARN) for the role that you want Elastic Transcoder to use to create the pipeline.</p>
    pub role: std::option::Option<std::string::String>,
    /// <p>The AWS Key Management Service (AWS KMS) key that you want to use with this pipeline.</p>
    /// <p>If you use either <code>s3</code> or <code>s3-aws-kms</code> as your
    /// <code>Encryption:Mode</code>, you don't need to provide a key with
    /// your job because a default key, known as an AWS-KMS key, is created for you automatically.
    /// You need to provide an AWS-KMS key only if you want to use a non-default AWS-KMS key, or if you are
    /// using an <code>Encryption:Mode</code> of <code>aes-cbc-pkcs7</code>, <code>aes-ctr</code>,
    /// or <code>aes-gcm</code>.</p>
    pub aws_kms_key_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status.</p>
    /// <important>
    /// <p>To receive notifications, you must also subscribe to the new topic in the Amazon SNS console.</p>
    /// </important>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Progressing</b>: The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to
    /// notify when Elastic Transcoder has started to process a job in this pipeline. This is the ARN that
    /// Amazon SNS returned when you created the topic. For more information, see Create a
    /// Topic in the Amazon Simple Notification Service Developer Guide.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Complete</b>: The topic ARN for the Amazon SNS topic that you want to notify when
    /// Elastic Transcoder has finished processing a job in this pipeline. This is the ARN that Amazon SNS
    /// returned when you created the topic.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Warning</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
    /// encounters a warning condition while processing a job in this pipeline. This is the
    /// ARN that Amazon SNS returned when you created the topic.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Error</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
    /// encounters an error condition while processing a job in this pipeline. This is the
    /// ARN that Amazon SNS returned when you created the topic.</p>
    /// </li>
    /// </ul>
    pub notifications: std::option::Option<crate::model::Notifications>,
    /// <p>The optional <code>ContentConfig</code> object specifies information about the Amazon S3
    /// bucket in which you want Elastic Transcoder to save transcoded files and playlists:
    /// which bucket to use, which users you want to have access to the files, the type of
    /// access you want users to have, and the storage class that you want to assign to the
    /// files.</p>
    /// <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
    /// <code>ThumbnailConfig</code>.</p>
    /// <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
    /// omit the <code>OutputBucket</code> object.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
    /// transcoded files and playlists.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Permissions</b> (Optional): The Permissions object specifies which users you want
    /// to have access to transcoded files and the type of access you want them to have. You
    /// can grant permissions to a maximum of 30 users and/or predefined Amazon S3
    /// groups.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Grantee Type</b>: Specify the type of value that appears in the
    /// <code>Grantee</code> object: </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
    /// canonical user ID for an AWS account or an origin access identity for an
    /// Amazon CloudFront distribution. For more information about canonical user
    /// IDs, see Access Control List (ACL) Overview in the Amazon Simple Storage
    /// Service Developer Guide. For more information about using CloudFront origin
    /// access identities to require that users use CloudFront URLs instead of
    /// Amazon S3 URLs, see Using an Origin Access Identity to Restrict Access to
    /// Your Amazon S3 Content.</p>
    /// <important>
    /// <p>A canonical user ID is not the same as an
    /// AWS account number.</p>
    /// </important>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Email</b>: The value in the <code>Grantee</code> object is the registered
    /// email address of an AWS account.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Group</b>: The value in the <code>Grantee</code> object is one of the
    /// following predefined Amazon S3 groups: <code>AllUsers</code>,
    /// <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Grantee</b>: The AWS user or group that you want to have access to transcoded
    /// files and playlists. To identify the user or group, you can specify the canonical
    /// user ID for an AWS account, an origin access identity for a CloudFront distribution,
    /// the registered email address of an AWS account, or a predefined Amazon S3 group </p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Access</b>: The permission that you want to give to the AWS user that you
    /// specified in <code>Grantee</code>. Permissions are granted on the files that Elastic
    /// Transcoder adds to the bucket, including playlists and video files. Valid values
    /// include: </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>READ</code>: The grantee can read the objects and metadata for objects
    /// that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>READ_ACP</code>: The grantee can read the object ACL for objects that
    /// Elastic Transcoder adds to the Amazon S3 bucket.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>WRITE_ACP</code>: The grantee can write the ACL for the objects that
    /// Elastic Transcoder adds to the Amazon S3 bucket.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
    /// <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
    /// objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
    /// <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
    /// the video files and playlists that it stores in your Amazon S3 bucket.</p>
    /// </li>
    /// </ul>
    pub content_config: std::option::Option<crate::model::PipelineOutputConfig>,
    /// <p>The <code>ThumbnailConfig</code> object specifies several values, including the Amazon S3
    /// bucket in which you want Elastic Transcoder to save thumbnail files, which users you want to have
    /// access to the files, the type of access you want users to have, and the storage class
    /// that you want to assign to the files.</p>
    /// <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
    /// <code>ThumbnailConfig</code> even if you don't want to create thumbnails.</p>
    /// <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
    /// omit the <code>OutputBucket</code> object.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
    /// thumbnail files.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Permissions</b> (Optional): The <code>Permissions</code> object specifies which
    /// users and/or predefined Amazon S3 groups you want to have access to thumbnail files,
    /// and the type of access you want them to have. You can grant permissions to a maximum
    /// of 30 users and/or predefined Amazon S3 groups.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>GranteeType</b>: Specify the type of value that appears in the Grantee object: </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
    /// canonical user ID for an AWS account or an origin access identity for an
    /// Amazon CloudFront distribution.</p>
    /// <important>
    /// <p>A canonical user ID is not the
    /// same as an AWS account number.</p>
    /// </important>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Email</b>: The value in the <code>Grantee</code> object is the registered
    /// email address of an AWS account. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Group</b>: The value in the <code>Grantee</code> object is one of the
    /// following predefined Amazon S3 groups: <code>AllUsers</code>,
    /// <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Grantee</b>: The AWS user or group that you want to have access to thumbnail
    /// files. To identify the user or group, you can specify the canonical user ID for an
    /// AWS account, an origin access identity for a CloudFront distribution, the registered
    /// email address of an AWS account, or a predefined Amazon S3 group. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Access</b>: The permission that you want to give to the AWS user that you
    /// specified in <code>Grantee</code>. Permissions are granted on the thumbnail files
    /// that Elastic Transcoder adds to the bucket. Valid values include: </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>READ</code>: The grantee can read the thumbnails and metadata for
    /// objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>READ_ACP</code>: The grantee can read the object ACL for thumbnails
    /// that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>WRITE_ACP</code>: The grantee can write the ACL for the thumbnails
    /// that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
    /// <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
    /// thumbnails that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
    /// <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
    /// the thumbnails that it stores in your Amazon S3 bucket.</p>
    /// </li>
    /// </ul>
    pub thumbnail_config: std::option::Option<crate::model::PipelineOutputConfig>,
}
impl std::fmt::Debug for CreatePipelineInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePipelineInput");
        formatter.field("name", &self.name);
        formatter.field("input_bucket", &self.input_bucket);
        formatter.field("output_bucket", &self.output_bucket);
        formatter.field("role", &self.role);
        formatter.field("aws_kms_key_arn", &self.aws_kms_key_arn);
        formatter.field("notifications", &self.notifications);
        formatter.field("content_config", &self.content_config);
        formatter.field("thumbnail_config", &self.thumbnail_config);
        formatter.finish()
    }
}

/// <p>The <code>CreateJobRequest</code> structure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateJobInput {
    /// <p>The <code>Id</code> of the pipeline that you want Elastic Transcoder to use for
    /// transcoding. The pipeline determines several settings, including the Amazon S3 bucket
    /// from which Elastic Transcoder gets the files to transcode and the bucket into which
    /// Elastic Transcoder puts the transcoded files.</p>
    pub pipeline_id: std::option::Option<std::string::String>,
    /// <p>A section of the request body that provides information about the file that is being
    /// transcoded.</p>
    pub input: std::option::Option<crate::model::JobInput>,
    /// <p>A section of the request body that provides information about the files that are being
    /// transcoded.</p>
    pub inputs: std::option::Option<std::vec::Vec<crate::model::JobInput>>,
    /// <p> A section of the request body that provides information about the transcoded (target)
    /// file. We strongly recommend that you use the <code>Outputs</code> syntax instead of the
    /// <code>Output</code> syntax. </p>
    pub output: std::option::Option<crate::output::CreateJobOutput>,
    /// <p> A section of the request body that provides information about the transcoded (target)
    /// files. We recommend that you use the <code>Outputs</code> syntax instead of the
    /// <code>Output</code> syntax. </p>
    pub outputs: std::option::Option<std::vec::Vec<crate::output::CreateJobOutput>>,
    /// <p>The value, if any, that you want Elastic Transcoder to prepend to the names of all files that this
    /// job creates, including output files, thumbnails, and playlists.</p>
    pub output_key_prefix: std::option::Option<std::string::String>,
    /// <p>If you specify a preset in <code>PresetId</code> for which the value of
    /// <code>Container</code> is fmp4 (Fragmented MP4) or ts (MPEG-TS), Playlists contains
    /// information about the master playlists that you want Elastic Transcoder to create.</p>
    /// <p>The maximum number of master playlists in a job is 30.</p>
    pub playlists: std::option::Option<std::vec::Vec<crate::model::CreateJobPlaylist>>,
    /// <p>User-defined metadata that you want to associate with an Elastic Transcoder job. You specify metadata in
    /// <code>key/value</code> pairs, and you can add up to 10 <code>key/value</code> pairs per job.
    /// Elastic Transcoder does not guarantee that <code>key/value</code> pairs are returned in the same
    /// order in which you specify them.</p>
    pub user_metadata:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for CreateJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateJobInput");
        formatter.field("pipeline_id", &self.pipeline_id);
        formatter.field("input", &self.input);
        formatter.field("inputs", &self.inputs);
        formatter.field("output", &self.output);
        formatter.field("outputs", &self.outputs);
        formatter.field("output_key_prefix", &self.output_key_prefix);
        formatter.field("playlists", &self.playlists);
        formatter.field("user_metadata", &self.user_metadata);
        formatter.finish()
    }
}

/// <p>The <code>CancelJobRequest</code> structure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelJobInput {
    /// <p>The identifier of the job that you want to cancel.</p>
    /// <p>To get a list of the jobs (including their <code>jobId</code>) that have a status of
    /// <code>Submitted</code>, use the <a>ListJobsByStatus</a> API action.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CancelJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelJobInput");
        formatter.field("id", &self.id);
        formatter.finish()
    }
}
