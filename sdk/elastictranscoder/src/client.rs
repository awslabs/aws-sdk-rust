// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn cancel_job(&self) -> fluent_builders::CancelJob<C> {
        fluent_builders::CancelJob::new(self.handle.clone())
    }
    pub fn create_job(&self) -> fluent_builders::CreateJob<C> {
        fluent_builders::CreateJob::new(self.handle.clone())
    }
    pub fn create_pipeline(&self) -> fluent_builders::CreatePipeline<C> {
        fluent_builders::CreatePipeline::new(self.handle.clone())
    }
    pub fn create_preset(&self) -> fluent_builders::CreatePreset<C> {
        fluent_builders::CreatePreset::new(self.handle.clone())
    }
    pub fn delete_pipeline(&self) -> fluent_builders::DeletePipeline<C> {
        fluent_builders::DeletePipeline::new(self.handle.clone())
    }
    pub fn delete_preset(&self) -> fluent_builders::DeletePreset<C> {
        fluent_builders::DeletePreset::new(self.handle.clone())
    }
    pub fn list_jobs_by_pipeline(&self) -> fluent_builders::ListJobsByPipeline<C> {
        fluent_builders::ListJobsByPipeline::new(self.handle.clone())
    }
    pub fn list_jobs_by_status(&self) -> fluent_builders::ListJobsByStatus<C> {
        fluent_builders::ListJobsByStatus::new(self.handle.clone())
    }
    pub fn list_pipelines(&self) -> fluent_builders::ListPipelines<C> {
        fluent_builders::ListPipelines::new(self.handle.clone())
    }
    pub fn list_presets(&self) -> fluent_builders::ListPresets<C> {
        fluent_builders::ListPresets::new(self.handle.clone())
    }
    pub fn read_job(&self) -> fluent_builders::ReadJob<C> {
        fluent_builders::ReadJob::new(self.handle.clone())
    }
    pub fn read_pipeline(&self) -> fluent_builders::ReadPipeline<C> {
        fluent_builders::ReadPipeline::new(self.handle.clone())
    }
    pub fn read_preset(&self) -> fluent_builders::ReadPreset<C> {
        fluent_builders::ReadPreset::new(self.handle.clone())
    }
    pub fn test_role(&self) -> fluent_builders::TestRole<C> {
        fluent_builders::TestRole::new(self.handle.clone())
    }
    pub fn update_pipeline(&self) -> fluent_builders::UpdatePipeline<C> {
        fluent_builders::UpdatePipeline::new(self.handle.clone())
    }
    pub fn update_pipeline_notifications(&self) -> fluent_builders::UpdatePipelineNotifications<C> {
        fluent_builders::UpdatePipelineNotifications::new(self.handle.clone())
    }
    pub fn update_pipeline_status(&self) -> fluent_builders::UpdatePipelineStatus<C> {
        fluent_builders::UpdatePipelineStatus::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CancelJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_job_input::Builder,
    }
    impl<C> CancelJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelJobOutput,
            smithy_http::result::SdkError<crate::error::CancelJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the job that you want to cancel.</p>
        /// <p>To get a list of the jobs (including their <code>jobId</code>) that have a status of
        /// <code>Submitted</code>, use the <a>ListJobsByStatus</a> API action.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_job_input::Builder,
    }
    impl<C> CreateJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateJobOutput,
            smithy_http::result::SdkError<crate::error::CreateJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>Id</code> of the pipeline that you want Elastic Transcoder to use for
        /// transcoding. The pipeline determines several settings, including the Amazon S3 bucket
        /// from which Elastic Transcoder gets the files to transcode and the bucket into which
        /// Elastic Transcoder puts the transcoded files.</p>
        pub fn pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_id(input);
            self
        }
        pub fn set_pipeline_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pipeline_id(input);
            self
        }
        /// <p>A section of the request body that provides information about the file that is being
        /// transcoded.</p>
        pub fn input(mut self, input: crate::model::JobInput) -> Self {
            self.inner = self.inner.input(input);
            self
        }
        pub fn set_input(mut self, input: std::option::Option<crate::model::JobInput>) -> Self {
            self.inner = self.inner.set_input(input);
            self
        }
        /// <p>A section of the request body that provides information about the files that are being
        /// transcoded.</p>
        pub fn inputs(mut self, inp: impl Into<crate::model::JobInput>) -> Self {
            self.inner = self.inner.inputs(inp);
            self
        }
        pub fn set_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::JobInput>>,
        ) -> Self {
            self.inner = self.inner.set_inputs(input);
            self
        }
        /// <p> A section of the request body that provides information about the transcoded (target)
        /// file. We strongly recommend that you use the <code>Outputs</code> syntax instead of the
        /// <code>Output</code> syntax. </p>
        pub fn output(mut self, input: crate::output::CreateJobOutput) -> Self {
            self.inner = self.inner.output(input);
            self
        }
        pub fn set_output(
            mut self,
            input: std::option::Option<crate::output::CreateJobOutput>,
        ) -> Self {
            self.inner = self.inner.set_output(input);
            self
        }
        /// <p> A section of the request body that provides information about the transcoded (target)
        /// files. We recommend that you use the <code>Outputs</code> syntax instead of the
        /// <code>Output</code> syntax. </p>
        pub fn outputs(mut self, inp: impl Into<crate::output::CreateJobOutput>) -> Self {
            self.inner = self.inner.outputs(inp);
            self
        }
        pub fn set_outputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::output::CreateJobOutput>>,
        ) -> Self {
            self.inner = self.inner.set_outputs(input);
            self
        }
        /// <p>The value, if any, that you want Elastic Transcoder to prepend to the names of all files that this
        /// job creates, including output files, thumbnails, and playlists.</p>
        pub fn output_key_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.output_key_prefix(input);
            self
        }
        pub fn set_output_key_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_output_key_prefix(input);
            self
        }
        /// <p>If you specify a preset in <code>PresetId</code> for which the value of
        /// <code>Container</code> is fmp4 (Fragmented MP4) or ts (MPEG-TS), Playlists contains
        /// information about the master playlists that you want Elastic Transcoder to create.</p>
        /// <p>The maximum number of master playlists in a job is 30.</p>
        pub fn playlists(mut self, inp: impl Into<crate::model::CreateJobPlaylist>) -> Self {
            self.inner = self.inner.playlists(inp);
            self
        }
        pub fn set_playlists(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CreateJobPlaylist>>,
        ) -> Self {
            self.inner = self.inner.set_playlists(input);
            self
        }
        /// <p>User-defined metadata that you want to associate with an Elastic Transcoder job. You specify metadata in
        /// <code>key/value</code> pairs, and you can add up to 10 <code>key/value</code> pairs per job.
        /// Elastic Transcoder does not guarantee that <code>key/value</code> pairs are returned in the same
        /// order in which you specify them.</p>
        pub fn user_metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.user_metadata(k, v);
            self
        }
        pub fn set_user_metadata(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_user_metadata(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_pipeline_input::Builder,
    }
    impl<C> CreatePipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePipelineOutput,
            smithy_http::result::SdkError<crate::error::CreatePipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the pipeline. We recommend that the name be unique within the AWS account,
        /// but uniqueness is not enforced.</p>
        /// <p>Constraints: Maximum 40 characters.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The Amazon S3 bucket in which you saved the media files that you want to transcode.</p>
        pub fn input_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_bucket(input);
            self
        }
        pub fn set_input_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_input_bucket(input);
            self
        }
        /// <p>The Amazon S3 bucket in which you want Elastic Transcoder to save the transcoded files. (Use
        /// this, or use ContentConfig:Bucket plus ThumbnailConfig:Bucket.)</p>
        /// <p>Specify this value when all of the following are true:</p>
        /// <ul>
        /// <li>
        /// <p>You want to save transcoded files, thumbnails (if any), and playlists (if any)
        /// together in one bucket.</p>
        /// </li>
        /// <li>
        /// <p>You do not want to specify the users or groups who have access to the transcoded
        /// files, thumbnails, and playlists.</p>
        /// </li>
        /// <li>
        /// <p>You do not want to specify the permissions that Elastic Transcoder grants to the   
        /// files. </p>
        /// <important>
        /// <p>When Elastic Transcoder saves files in
        /// <code>OutputBucket</code>, it grants full control over the files only to
        /// the AWS account that owns the role that is specified by
        /// <code>Role</code>.</p>
        /// </important>
        /// </li>
        /// <li>
        /// <p>You want to associate the transcoded files and thumbnails with the Amazon S3
        /// Standard storage class.</p>
        /// </li>
        /// </ul>
        /// <p>If you want to save transcoded files and playlists in one bucket and thumbnails in
        /// another bucket, specify which users can access the transcoded files or the permissions
        /// the users have, or change the Amazon S3 storage class, omit <code>OutputBucket</code>
        /// and specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>
        /// instead.</p>
        pub fn output_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.output_bucket(input);
            self
        }
        pub fn set_output_bucket(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_output_bucket(input);
            self
        }
        /// <p>The IAM Amazon Resource Name (ARN) for the role that you want Elastic Transcoder to use to create the pipeline.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(input);
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(input);
            self
        }
        /// <p>The AWS Key Management Service (AWS KMS) key that you want to use with this pipeline.</p>
        /// <p>If you use either <code>s3</code> or <code>s3-aws-kms</code> as your
        /// <code>Encryption:Mode</code>, you don't need to provide a key with
        /// your job because a default key, known as an AWS-KMS key, is created for you automatically.
        /// You need to provide an AWS-KMS key only if you want to use a non-default AWS-KMS key, or if you are
        /// using an <code>Encryption:Mode</code> of <code>aes-cbc-pkcs7</code>, <code>aes-ctr</code>,
        /// or <code>aes-gcm</code>.</p>
        pub fn aws_kms_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.aws_kms_key_arn(input);
            self
        }
        pub fn set_aws_kms_key_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_aws_kms_key_arn(input);
            self
        }
        /// <p>The Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status.</p>
        /// <important>
        /// <p>To receive notifications, you must also subscribe to the new topic in the Amazon SNS console.</p>
        /// </important>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Progressing</b>: The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to
        /// notify when Elastic Transcoder has started to process a job in this pipeline. This is the ARN that
        /// Amazon SNS returned when you created the topic. For more information, see Create a
        /// Topic in the Amazon Simple Notification Service Developer Guide.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Complete</b>: The topic ARN for the Amazon SNS topic that you want to notify when
        /// Elastic Transcoder has finished processing a job in this pipeline. This is the ARN that Amazon SNS
        /// returned when you created the topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Warning</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
        /// encounters a warning condition while processing a job in this pipeline. This is the
        /// ARN that Amazon SNS returned when you created the topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Error</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
        /// encounters an error condition while processing a job in this pipeline. This is the
        /// ARN that Amazon SNS returned when you created the topic.</p>
        /// </li>
        /// </ul>
        pub fn notifications(mut self, input: crate::model::Notifications) -> Self {
            self.inner = self.inner.notifications(input);
            self
        }
        pub fn set_notifications(
            mut self,
            input: std::option::Option<crate::model::Notifications>,
        ) -> Self {
            self.inner = self.inner.set_notifications(input);
            self
        }
        /// <p>The optional <code>ContentConfig</code> object specifies information about the Amazon S3
        /// bucket in which you want Elastic Transcoder to save transcoded files and playlists:
        /// which bucket to use, which users you want to have access to the files, the type of
        /// access you want users to have, and the storage class that you want to assign to the
        /// files.</p>
        /// <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
        /// <code>ThumbnailConfig</code>.</p>
        /// <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
        /// omit the <code>OutputBucket</code> object.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
        /// transcoded files and playlists.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Permissions</b> (Optional): The Permissions object specifies which users you want
        /// to have access to transcoded files and the type of access you want them to have. You
        /// can grant permissions to a maximum of 30 users and/or predefined Amazon S3
        /// groups.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Grantee Type</b>: Specify the type of value that appears in the
        /// <code>Grantee</code> object: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
        /// canonical user ID for an AWS account or an origin access identity for an
        /// Amazon CloudFront distribution. For more information about canonical user
        /// IDs, see Access Control List (ACL) Overview in the Amazon Simple Storage
        /// Service Developer Guide. For more information about using CloudFront origin
        /// access identities to require that users use CloudFront URLs instead of
        /// Amazon S3 URLs, see Using an Origin Access Identity to Restrict Access to
        /// Your Amazon S3 Content.</p>
        /// <important>
        /// <p>A canonical user ID is not the same as an
        /// AWS account number.</p>
        /// </important>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Email</b>: The value in the <code>Grantee</code> object is the registered
        /// email address of an AWS account.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Group</b>: The value in the <code>Grantee</code> object is one of the
        /// following predefined Amazon S3 groups: <code>AllUsers</code>,
        /// <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Grantee</b>: The AWS user or group that you want to have access to transcoded
        /// files and playlists. To identify the user or group, you can specify the canonical
        /// user ID for an AWS account, an origin access identity for a CloudFront distribution,
        /// the registered email address of an AWS account, or a predefined Amazon S3 group </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Access</b>: The permission that you want to give to the AWS user that you
        /// specified in <code>Grantee</code>. Permissions are granted on the files that Elastic
        /// Transcoder adds to the bucket, including playlists and video files. Valid values
        /// include: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>READ</code>: The grantee can read the objects and metadata for objects
        /// that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>READ_ACP</code>: The grantee can read the object ACL for objects that
        /// Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WRITE_ACP</code>: The grantee can write the ACL for the objects that
        /// Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
        /// <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
        /// objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
        /// <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
        /// the video files and playlists that it stores in your Amazon S3 bucket.</p>
        /// </li>
        /// </ul>
        pub fn content_config(mut self, input: crate::model::PipelineOutputConfig) -> Self {
            self.inner = self.inner.content_config(input);
            self
        }
        pub fn set_content_config(
            mut self,
            input: std::option::Option<crate::model::PipelineOutputConfig>,
        ) -> Self {
            self.inner = self.inner.set_content_config(input);
            self
        }
        /// <p>The <code>ThumbnailConfig</code> object specifies several values, including the Amazon S3
        /// bucket in which you want Elastic Transcoder to save thumbnail files, which users you want to have
        /// access to the files, the type of access you want users to have, and the storage class
        /// that you want to assign to the files.</p>
        /// <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
        /// <code>ThumbnailConfig</code> even if you don't want to create thumbnails.</p>
        /// <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
        /// omit the <code>OutputBucket</code> object.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
        /// thumbnail files.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Permissions</b> (Optional): The <code>Permissions</code> object specifies which
        /// users and/or predefined Amazon S3 groups you want to have access to thumbnail files,
        /// and the type of access you want them to have. You can grant permissions to a maximum
        /// of 30 users and/or predefined Amazon S3 groups.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>GranteeType</b>: Specify the type of value that appears in the Grantee object: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
        /// canonical user ID for an AWS account or an origin access identity for an
        /// Amazon CloudFront distribution.</p>
        /// <important>
        /// <p>A canonical user ID is not the
        /// same as an AWS account number.</p>
        /// </important>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Email</b>: The value in the <code>Grantee</code> object is the registered
        /// email address of an AWS account. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Group</b>: The value in the <code>Grantee</code> object is one of the
        /// following predefined Amazon S3 groups: <code>AllUsers</code>,
        /// <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Grantee</b>: The AWS user or group that you want to have access to thumbnail
        /// files. To identify the user or group, you can specify the canonical user ID for an
        /// AWS account, an origin access identity for a CloudFront distribution, the registered
        /// email address of an AWS account, or a predefined Amazon S3 group. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Access</b>: The permission that you want to give to the AWS user that you
        /// specified in <code>Grantee</code>. Permissions are granted on the thumbnail files
        /// that Elastic Transcoder adds to the bucket. Valid values include: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>READ</code>: The grantee can read the thumbnails and metadata for
        /// objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>READ_ACP</code>: The grantee can read the object ACL for thumbnails
        /// that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WRITE_ACP</code>: The grantee can write the ACL for the thumbnails
        /// that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
        /// <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
        /// thumbnails that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
        /// <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
        /// the thumbnails that it stores in your Amazon S3 bucket.</p>
        /// </li>
        /// </ul>
        pub fn thumbnail_config(mut self, input: crate::model::PipelineOutputConfig) -> Self {
            self.inner = self.inner.thumbnail_config(input);
            self
        }
        pub fn set_thumbnail_config(
            mut self,
            input: std::option::Option<crate::model::PipelineOutputConfig>,
        ) -> Self {
            self.inner = self.inner.set_thumbnail_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePreset<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_preset_input::Builder,
    }
    impl<C> CreatePreset<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePresetOutput,
            smithy_http::result::SdkError<crate::error::CreatePresetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the preset. We recommend that the name be unique within the AWS account, but uniqueness is not enforced.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A description of the preset.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The container type for the output file. Valid values include <code>flac</code>,
        /// <code>flv</code>, <code>fmp4</code>,
        /// <code>gif</code>, <code>mp3</code>,
        /// <code>mp4</code>, <code>mpg</code>, <code>mxf</code>, <code>oga</code>,
        /// <code>ogg</code>, <code>ts</code>, and <code>webm</code>.</p>
        pub fn container(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.container(input);
            self
        }
        pub fn set_container(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_container(input);
            self
        }
        /// <p>A section of the request body that specifies the video parameters.</p>
        pub fn video(mut self, input: crate::model::VideoParameters) -> Self {
            self.inner = self.inner.video(input);
            self
        }
        pub fn set_video(
            mut self,
            input: std::option::Option<crate::model::VideoParameters>,
        ) -> Self {
            self.inner = self.inner.set_video(input);
            self
        }
        /// <p>A section of the request body that specifies the audio parameters.</p>
        pub fn audio(mut self, input: crate::model::AudioParameters) -> Self {
            self.inner = self.inner.audio(input);
            self
        }
        pub fn set_audio(
            mut self,
            input: std::option::Option<crate::model::AudioParameters>,
        ) -> Self {
            self.inner = self.inner.set_audio(input);
            self
        }
        /// <p>A section of the request body that specifies the thumbnail parameters, if any.</p>
        pub fn thumbnails(mut self, input: crate::model::Thumbnails) -> Self {
            self.inner = self.inner.thumbnails(input);
            self
        }
        pub fn set_thumbnails(
            mut self,
            input: std::option::Option<crate::model::Thumbnails>,
        ) -> Self {
            self.inner = self.inner.set_thumbnails(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_pipeline_input::Builder,
    }
    impl<C> DeletePipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePipelineOutput,
            smithy_http::result::SdkError<crate::error::DeletePipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the pipeline that you want to delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePreset<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_preset_input::Builder,
    }
    impl<C> DeletePreset<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePresetOutput,
            smithy_http::result::SdkError<crate::error::DeletePresetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the preset for which you want to get detailed information.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListJobsByPipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_jobs_by_pipeline_input::Builder,
    }
    impl<C> ListJobsByPipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListJobsByPipelineOutput,
            smithy_http::result::SdkError<crate::error::ListJobsByPipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the pipeline for which you want to get job information.</p>
        pub fn pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_id(input);
            self
        }
        pub fn set_pipeline_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pipeline_id(input);
            self
        }
        /// <p> To list jobs in chronological order by the date and time that they were submitted, enter
        /// <code>true</code>. To list jobs in reverse chronological order, enter
        /// <code>false</code>. </p>
        pub fn ascending(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ascending(input);
            self
        }
        pub fn set_ascending(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ascending(input);
            self
        }
        /// <p> When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
        /// subsequent <code>GET</code> requests to get each successive page of results. </p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListJobsByStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_jobs_by_status_input::Builder,
    }
    impl<C> ListJobsByStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListJobsByStatusOutput,
            smithy_http::result::SdkError<crate::error::ListJobsByStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To get information about all of the jobs associated with the current AWS account that
        /// have a given status, specify the following status: <code>Submitted</code>,
        /// <code>Progressing</code>, <code>Complete</code>, <code>Canceled</code>, or
        /// <code>Error</code>.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p> To list jobs in chronological order by the date and time that they were submitted, enter
        /// <code>true</code>. To list jobs in reverse chronological order, enter
        /// <code>false</code>. </p>
        pub fn ascending(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ascending(input);
            self
        }
        pub fn set_ascending(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ascending(input);
            self
        }
        /// <p> When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
        /// subsequent <code>GET</code> requests to get each successive page of results. </p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPipelines<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_pipelines_input::Builder,
    }
    impl<C> ListPipelines<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPipelinesOutput,
            smithy_http::result::SdkError<crate::error::ListPipelinesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To list pipelines in chronological order by the date and time that they were created, enter
        /// <code>true</code>. To list pipelines in reverse chronological order, enter
        /// <code>false</code>.</p>
        pub fn ascending(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ascending(input);
            self
        }
        pub fn set_ascending(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ascending(input);
            self
        }
        /// <p>When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
        /// subsequent <code>GET</code> requests to get each successive page of results. </p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPresets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_presets_input::Builder,
    }
    impl<C> ListPresets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPresetsOutput,
            smithy_http::result::SdkError<crate::error::ListPresetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To list presets in chronological order by the date and time that they were created, enter
        /// <code>true</code>. To list presets in reverse chronological order, enter
        /// <code>false</code>.</p>
        pub fn ascending(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ascending(input);
            self
        }
        pub fn set_ascending(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ascending(input);
            self
        }
        /// <p>When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
        /// subsequent <code>GET</code> requests to get each successive page of results. </p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ReadJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::read_job_input::Builder,
    }
    impl<C> ReadJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ReadJobOutput,
            smithy_http::result::SdkError<crate::error::ReadJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the job for which you want to get detailed information.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ReadPipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::read_pipeline_input::Builder,
    }
    impl<C> ReadPipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ReadPipelineOutput,
            smithy_http::result::SdkError<crate::error::ReadPipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the pipeline to read.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ReadPreset<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::read_preset_input::Builder,
    }
    impl<C> ReadPreset<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ReadPresetOutput,
            smithy_http::result::SdkError<crate::error::ReadPresetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the preset for which you want to get detailed information.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TestRole<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::test_role_input::Builder,
    }
    impl<C> TestRole<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TestRoleOutput,
            smithy_http::result::SdkError<crate::error::TestRoleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IAM Amazon Resource Name (ARN) for the role that you want Elastic Transcoder to test.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(input);
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(input);
            self
        }
        /// <p>The Amazon S3 bucket that contains media files to be transcoded. The action attempts to read from this bucket.</p>
        pub fn input_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_bucket(input);
            self
        }
        pub fn set_input_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_input_bucket(input);
            self
        }
        /// <p>The Amazon S3 bucket that Elastic Transcoder writes transcoded media files to. The action attempts to read from this bucket.</p>
        pub fn output_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.output_bucket(input);
            self
        }
        pub fn set_output_bucket(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_output_bucket(input);
            self
        }
        /// <p>The ARNs of one or more Amazon Simple Notification Service (Amazon SNS) topics that you want the action to send a test notification to.</p>
        pub fn topics(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.topics(inp);
            self
        }
        pub fn set_topics(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_topics(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdatePipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_pipeline_input::Builder,
    }
    impl<C> UpdatePipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdatePipelineOutput,
            smithy_http::result::SdkError<crate::error::UpdatePipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the pipeline that you want to update.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The name of the pipeline. We recommend that the name be unique within the AWS account, but
        /// uniqueness is not enforced.</p>
        /// <p>Constraints: Maximum 40 characters</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The Amazon S3 bucket in which you saved the media files that you want to transcode and the graphics
        /// that you want to use as watermarks.</p>
        pub fn input_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input_bucket(input);
            self
        }
        pub fn set_input_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_input_bucket(input);
            self
        }
        /// <p>The IAM Amazon Resource Name (ARN) for the role that you want Elastic Transcoder to use to transcode jobs for
        /// this pipeline.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(input);
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(input);
            self
        }
        /// <p>The AWS Key Management Service (AWS KMS) key that you want to use with this pipeline.</p>
        /// <p>If you use either <code>s3</code> or <code>s3-aws-kms</code> as your <code>Encryption:Mode</code>,
        /// you don't need to provide a key with your job because a default key, known as an AWS-KMS key, is
        /// created for you automatically. You need to provide an AWS-KMS key only if you want to use a non-default
        /// AWS-KMS key, or if you are using an <code>Encryption:Mode</code> of <code>aes-cbc-pkcs7</code>, <code>aes-ctr</code>,
        /// or <code>aes-gcm</code>.</p>
        pub fn aws_kms_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.aws_kms_key_arn(input);
            self
        }
        pub fn set_aws_kms_key_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_aws_kms_key_arn(input);
            self
        }
        /// <p>The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status.</p>
        /// <important>
        /// <p>To receive notifications, you must also subscribe to the new topic in the Amazon SNS console.</p>
        /// </important>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Progressing</b>: The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to
        /// notify when Elastic Transcoder has started to process jobs that are added to this pipeline. This
        /// is the ARN that Amazon SNS returned when you created the topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Complete</b>: The topic ARN for the Amazon SNS topic that you want to notify when
        /// Elastic Transcoder has finished processing a job. This is the ARN that Amazon SNS returned when
        /// you created the topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Warning</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
        /// encounters a warning condition. This is the ARN that Amazon SNS returned when you
        /// created the topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Error</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
        /// encounters an error condition. This is the ARN that Amazon SNS returned when you
        /// created the topic.</p>
        /// </li>
        /// </ul>
        pub fn notifications(mut self, input: crate::model::Notifications) -> Self {
            self.inner = self.inner.notifications(input);
            self
        }
        pub fn set_notifications(
            mut self,
            input: std::option::Option<crate::model::Notifications>,
        ) -> Self {
            self.inner = self.inner.set_notifications(input);
            self
        }
        /// <p>The optional <code>ContentConfig</code> object specifies information about the Amazon S3
        /// bucket in which you want Elastic Transcoder to save transcoded files and playlists:
        /// which bucket to use, which users you want to have access to the files, the type of
        /// access you want users to have, and the storage class that you want to assign to the
        /// files.</p>
        /// <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
        /// <code>ThumbnailConfig</code>.</p>
        /// <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
        /// omit the <code>OutputBucket</code> object.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
        /// transcoded files and playlists.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Permissions</b> (Optional): The Permissions object specifies which users you want
        /// to have access to transcoded files and the type of access you want them to have. You
        /// can grant permissions to a maximum of 30 users and/or predefined Amazon S3
        /// groups.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Grantee Type</b>: Specify the type of value that appears in the
        /// <code>Grantee</code> object:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
        /// canonical user ID for an AWS account or an origin access identity for an
        /// Amazon CloudFront distribution. For more information about canonical user
        /// IDs, see Access Control List (ACL) Overview in the Amazon Simple Storage
        /// Service Developer Guide. For more information about using CloudFront origin
        /// access identities to require that users use CloudFront URLs instead of
        /// Amazon S3 URLs, see Using an Origin Access Identity to Restrict Access to
        /// Your Amazon S3 Content.</p>
        /// <important>
        /// <p>A canonical user ID is not the same as an
        /// AWS account number.</p>
        /// </important>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Email</b>: The value in the <code>Grantee</code> object is the registered
        /// email address of an AWS account.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Group</b>: The value in the <code>Grantee</code> object is one of the
        /// following predefined Amazon S3 groups: <code>AllUsers</code>,
        /// <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Grantee</b>: The AWS user or group that you want to have access to transcoded
        /// files and playlists. To identify the user or group, you can specify the canonical
        /// user ID for an AWS account, an origin access identity for a CloudFront distribution,
        /// the registered email address of an AWS account, or a predefined Amazon S3 group </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Access</b>: The permission that you want to give to the AWS user that you
        /// specified in <code>Grantee</code>. Permissions are granted on the files that Elastic
        /// Transcoder adds to the bucket, including playlists and video files. Valid values
        /// include: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>READ</code>: The grantee can read the objects and metadata for objects
        /// that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>READ_ACP</code>: The grantee can read the object ACL for objects that
        /// Elastic Transcoder adds to the Amazon S3 bucket. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WRITE_ACP</code>: The grantee can write the ACL for the objects that
        /// Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
        /// <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
        /// objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
        /// <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
        /// the video files and playlists that it stores in your Amazon S3 bucket.</p>
        /// </li>
        /// </ul>
        pub fn content_config(mut self, input: crate::model::PipelineOutputConfig) -> Self {
            self.inner = self.inner.content_config(input);
            self
        }
        pub fn set_content_config(
            mut self,
            input: std::option::Option<crate::model::PipelineOutputConfig>,
        ) -> Self {
            self.inner = self.inner.set_content_config(input);
            self
        }
        /// <p>The <code>ThumbnailConfig</code> object specifies several values, including the Amazon S3
        /// bucket in which you want Elastic Transcoder to save thumbnail files, which users you want to have
        /// access to the files, the type of access you want users to have, and the storage class
        /// that you want to assign to the files.</p>
        /// <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
        /// <code>ThumbnailConfig</code> even if you don't want to create thumbnails.</p>
        /// <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
        /// omit the <code>OutputBucket</code> object.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
        /// thumbnail files.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Permissions</b> (Optional): The <code>Permissions</code> object specifies which
        /// users and/or predefined Amazon S3 groups you want to have access to thumbnail files,
        /// and the type of access you want them to have. You can grant permissions to a maximum
        /// of 30 users and/or predefined Amazon S3 groups.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>GranteeType</b>: Specify the type of value that appears in the Grantee object:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
        /// canonical user ID for an AWS account or an origin access identity for an
        /// Amazon CloudFront distribution.</p>
        /// <important>
        /// <p>A canonical user ID is not the
        /// same as an AWS account number.</p>
        /// </important>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Email</b>: The value in the <code>Grantee</code> object is the registered
        /// email address of an AWS account.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Group</b>: The value in the <code>Grantee</code> object is one of the
        /// following predefined Amazon S3 groups: <code>AllUsers</code>,
        /// <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Grantee</b>: The AWS user or group that you want to have access to thumbnail
        /// files. To identify the user or group, you can specify the canonical user ID for an
        /// AWS account, an origin access identity for a CloudFront distribution, the registered
        /// email address of an AWS account, or a predefined Amazon S3 group. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Access</b>: The permission that you want to give to the AWS user that you
        /// specified in <code>Grantee</code>. Permissions are granted on the thumbnail files
        /// that Elastic Transcoder adds to the bucket. Valid values include: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>READ</code>: The grantee can read the thumbnails and metadata for
        /// objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>READ_ACP</code>: The grantee can read the object ACL for thumbnails
        /// that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WRITE_ACP</code>: The grantee can write the ACL for the thumbnails
        /// that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
        /// <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
        /// thumbnails that Elastic Transcoder adds to the Amazon S3 bucket. </p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
        /// <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
        /// the thumbnails that it stores in your Amazon S3 bucket.</p>
        /// </li>
        /// </ul>
        pub fn thumbnail_config(mut self, input: crate::model::PipelineOutputConfig) -> Self {
            self.inner = self.inner.thumbnail_config(input);
            self
        }
        pub fn set_thumbnail_config(
            mut self,
            input: std::option::Option<crate::model::PipelineOutputConfig>,
        ) -> Self {
            self.inner = self.inner.set_thumbnail_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdatePipelineNotifications<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_pipeline_notifications_input::Builder,
    }
    impl<C> UpdatePipelineNotifications<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdatePipelineNotificationsOutput,
            smithy_http::result::SdkError<crate::error::UpdatePipelineNotificationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the pipeline for which you want to change notification settings.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status.</p>
        /// <important>
        /// <p>To receive notifications, you must also subscribe to the new topic in the Amazon SNS console.</p>
        /// </important>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Progressing</b>: The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to
        /// notify when Elastic Transcoder has started to process jobs that are added to this pipeline. This
        /// is the ARN that Amazon SNS returned when you created the topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Complete</b>: The topic ARN for the Amazon SNS topic that you want to notify when
        /// Elastic Transcoder has finished processing a job. This is the ARN that Amazon SNS returned when
        /// you created the topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Warning</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
        /// encounters a warning condition. This is the ARN that Amazon SNS returned when you
        /// created the topic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Error</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
        /// encounters an error condition. This is the ARN that Amazon SNS returned when you
        /// created the topic.</p>
        /// </li>
        /// </ul>
        pub fn notifications(mut self, input: crate::model::Notifications) -> Self {
            self.inner = self.inner.notifications(input);
            self
        }
        pub fn set_notifications(
            mut self,
            input: std::option::Option<crate::model::Notifications>,
        ) -> Self {
            self.inner = self.inner.set_notifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdatePipelineStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_pipeline_status_input::Builder,
    }
    impl<C> UpdatePipelineStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdatePipelineStatusOutput,
            smithy_http::result::SdkError<crate::error::UpdatePipelineStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the pipeline to update.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>The desired status of the pipeline:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Active</code>: The pipeline is processing jobs.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Paused</code>: The pipeline is not currently processing jobs.</p>
        /// </li>
        /// </ul>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
    }
}
