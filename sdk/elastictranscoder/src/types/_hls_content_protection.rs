// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The HLS content protection settings, if any, that you want Elastic Transcoder to apply to your output files.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HlsContentProtection {
    /// <p>The content protection method for your output. The only valid value is: <code>aes-128</code>.</p>
    /// <p>This value is written into the method attribute of the <code>EXT-X-KEY</code> metadata tag in the output playlist.</p>
    #[doc(hidden)]
    pub method: std::option::Option<std::string::String>,
    /// <p>If you want Elastic Transcoder to generate a key for you, leave this field blank.</p>
    /// <p>If you choose to supply your own key, you must encrypt the key by using AWS KMS. The key must be base64-encoded, and it must be one of the following bit lengths before being base64-encoded:</p>
    /// <p> <code>128</code>, <code>192</code>, or <code>256</code>. </p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>If Elastic Transcoder is generating your key for you, you must leave this field blank.</p>
    /// <p>The MD5 digest of the key that you want Elastic Transcoder to use to encrypt your output file, and that you want Elastic Transcoder to use as a checksum to make sure your key was not corrupted in transit. The key MD5 must be base64-encoded, and it must be exactly 16 bytes before being base64- encoded.</p>
    #[doc(hidden)]
    pub key_md5: std::option::Option<std::string::String>,
    /// <p>If Elastic Transcoder is generating your key for you, you must leave this field blank.</p>
    /// <p>The series of random bits created by a random bit generator, unique for every encryption operation, that you want Elastic Transcoder to use to encrypt your output files. The initialization vector must be base64-encoded, and it must be exactly 16 bytes before being base64-encoded.</p>
    #[doc(hidden)]
    pub initialization_vector: std::option::Option<std::string::String>,
    /// <p>The location of the license key required to decrypt your HLS playlist. The URL must be an absolute path, and is referenced in the URI attribute of the EXT-X-KEY metadata tag in the playlist file.</p>
    #[doc(hidden)]
    pub license_acquisition_url: std::option::Option<std::string::String>,
    /// <p>Specify whether you want Elastic Transcoder to write your HLS license key to an Amazon S3 bucket. If you choose <code>WithVariantPlaylists</code>, <code>LicenseAcquisitionUrl</code> must be left blank and Elastic Transcoder writes your data key into the same bucket as the associated playlist.</p>
    #[doc(hidden)]
    pub key_storage_policy: std::option::Option<std::string::String>,
}
impl HlsContentProtection {
    /// <p>The content protection method for your output. The only valid value is: <code>aes-128</code>.</p>
    /// <p>This value is written into the method attribute of the <code>EXT-X-KEY</code> metadata tag in the output playlist.</p>
    pub fn method(&self) -> std::option::Option<&str> {
        self.method.as_deref()
    }
    /// <p>If you want Elastic Transcoder to generate a key for you, leave this field blank.</p>
    /// <p>If you choose to supply your own key, you must encrypt the key by using AWS KMS. The key must be base64-encoded, and it must be one of the following bit lengths before being base64-encoded:</p>
    /// <p> <code>128</code>, <code>192</code>, or <code>256</code>. </p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>If Elastic Transcoder is generating your key for you, you must leave this field blank.</p>
    /// <p>The MD5 digest of the key that you want Elastic Transcoder to use to encrypt your output file, and that you want Elastic Transcoder to use as a checksum to make sure your key was not corrupted in transit. The key MD5 must be base64-encoded, and it must be exactly 16 bytes before being base64- encoded.</p>
    pub fn key_md5(&self) -> std::option::Option<&str> {
        self.key_md5.as_deref()
    }
    /// <p>If Elastic Transcoder is generating your key for you, you must leave this field blank.</p>
    /// <p>The series of random bits created by a random bit generator, unique for every encryption operation, that you want Elastic Transcoder to use to encrypt your output files. The initialization vector must be base64-encoded, and it must be exactly 16 bytes before being base64-encoded.</p>
    pub fn initialization_vector(&self) -> std::option::Option<&str> {
        self.initialization_vector.as_deref()
    }
    /// <p>The location of the license key required to decrypt your HLS playlist. The URL must be an absolute path, and is referenced in the URI attribute of the EXT-X-KEY metadata tag in the playlist file.</p>
    pub fn license_acquisition_url(&self) -> std::option::Option<&str> {
        self.license_acquisition_url.as_deref()
    }
    /// <p>Specify whether you want Elastic Transcoder to write your HLS license key to an Amazon S3 bucket. If you choose <code>WithVariantPlaylists</code>, <code>LicenseAcquisitionUrl</code> must be left blank and Elastic Transcoder writes your data key into the same bucket as the associated playlist.</p>
    pub fn key_storage_policy(&self) -> std::option::Option<&str> {
        self.key_storage_policy.as_deref()
    }
}
impl HlsContentProtection {
    /// Creates a new builder-style object to manufacture [`HlsContentProtection`](crate::types::HlsContentProtection).
    pub fn builder() -> crate::types::builders::HlsContentProtectionBuilder {
        crate::types::builders::HlsContentProtectionBuilder::default()
    }
}

/// A builder for [`HlsContentProtection`](crate::types::HlsContentProtection).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct HlsContentProtectionBuilder {
    pub(crate) method: std::option::Option<std::string::String>,
    pub(crate) key: std::option::Option<std::string::String>,
    pub(crate) key_md5: std::option::Option<std::string::String>,
    pub(crate) initialization_vector: std::option::Option<std::string::String>,
    pub(crate) license_acquisition_url: std::option::Option<std::string::String>,
    pub(crate) key_storage_policy: std::option::Option<std::string::String>,
}
impl HlsContentProtectionBuilder {
    /// <p>The content protection method for your output. The only valid value is: <code>aes-128</code>.</p>
    /// <p>This value is written into the method attribute of the <code>EXT-X-KEY</code> metadata tag in the output playlist.</p>
    pub fn method(mut self, input: impl Into<std::string::String>) -> Self {
        self.method = Some(input.into());
        self
    }
    /// <p>The content protection method for your output. The only valid value is: <code>aes-128</code>.</p>
    /// <p>This value is written into the method attribute of the <code>EXT-X-KEY</code> metadata tag in the output playlist.</p>
    pub fn set_method(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.method = input;
        self
    }
    /// <p>If you want Elastic Transcoder to generate a key for you, leave this field blank.</p>
    /// <p>If you choose to supply your own key, you must encrypt the key by using AWS KMS. The key must be base64-encoded, and it must be one of the following bit lengths before being base64-encoded:</p>
    /// <p> <code>128</code>, <code>192</code>, or <code>256</code>. </p>
    pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
        self.key = Some(input.into());
        self
    }
    /// <p>If you want Elastic Transcoder to generate a key for you, leave this field blank.</p>
    /// <p>If you choose to supply your own key, you must encrypt the key by using AWS KMS. The key must be base64-encoded, and it must be one of the following bit lengths before being base64-encoded:</p>
    /// <p> <code>128</code>, <code>192</code>, or <code>256</code>. </p>
    pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.key = input;
        self
    }
    /// <p>If Elastic Transcoder is generating your key for you, you must leave this field blank.</p>
    /// <p>The MD5 digest of the key that you want Elastic Transcoder to use to encrypt your output file, and that you want Elastic Transcoder to use as a checksum to make sure your key was not corrupted in transit. The key MD5 must be base64-encoded, and it must be exactly 16 bytes before being base64- encoded.</p>
    pub fn key_md5(mut self, input: impl Into<std::string::String>) -> Self {
        self.key_md5 = Some(input.into());
        self
    }
    /// <p>If Elastic Transcoder is generating your key for you, you must leave this field blank.</p>
    /// <p>The MD5 digest of the key that you want Elastic Transcoder to use to encrypt your output file, and that you want Elastic Transcoder to use as a checksum to make sure your key was not corrupted in transit. The key MD5 must be base64-encoded, and it must be exactly 16 bytes before being base64- encoded.</p>
    pub fn set_key_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.key_md5 = input;
        self
    }
    /// <p>If Elastic Transcoder is generating your key for you, you must leave this field blank.</p>
    /// <p>The series of random bits created by a random bit generator, unique for every encryption operation, that you want Elastic Transcoder to use to encrypt your output files. The initialization vector must be base64-encoded, and it must be exactly 16 bytes before being base64-encoded.</p>
    pub fn initialization_vector(mut self, input: impl Into<std::string::String>) -> Self {
        self.initialization_vector = Some(input.into());
        self
    }
    /// <p>If Elastic Transcoder is generating your key for you, you must leave this field blank.</p>
    /// <p>The series of random bits created by a random bit generator, unique for every encryption operation, that you want Elastic Transcoder to use to encrypt your output files. The initialization vector must be base64-encoded, and it must be exactly 16 bytes before being base64-encoded.</p>
    pub fn set_initialization_vector(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.initialization_vector = input;
        self
    }
    /// <p>The location of the license key required to decrypt your HLS playlist. The URL must be an absolute path, and is referenced in the URI attribute of the EXT-X-KEY metadata tag in the playlist file.</p>
    pub fn license_acquisition_url(mut self, input: impl Into<std::string::String>) -> Self {
        self.license_acquisition_url = Some(input.into());
        self
    }
    /// <p>The location of the license key required to decrypt your HLS playlist. The URL must be an absolute path, and is referenced in the URI attribute of the EXT-X-KEY metadata tag in the playlist file.</p>
    pub fn set_license_acquisition_url(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.license_acquisition_url = input;
        self
    }
    /// <p>Specify whether you want Elastic Transcoder to write your HLS license key to an Amazon S3 bucket. If you choose <code>WithVariantPlaylists</code>, <code>LicenseAcquisitionUrl</code> must be left blank and Elastic Transcoder writes your data key into the same bucket as the associated playlist.</p>
    pub fn key_storage_policy(mut self, input: impl Into<std::string::String>) -> Self {
        self.key_storage_policy = Some(input.into());
        self
    }
    /// <p>Specify whether you want Elastic Transcoder to write your HLS license key to an Amazon S3 bucket. If you choose <code>WithVariantPlaylists</code>, <code>LicenseAcquisitionUrl</code> must be left blank and Elastic Transcoder writes your data key into the same bucket as the associated playlist.</p>
    pub fn set_key_storage_policy(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.key_storage_policy = input;
        self
    }
    /// Consumes the builder and constructs a [`HlsContentProtection`](crate::types::HlsContentProtection).
    pub fn build(self) -> crate::types::HlsContentProtection {
        crate::types::HlsContentProtection {
            method: self.method,
            key: self.key,
            key_md5: self.key_md5,
            initialization_vector: self.initialization_vector,
            license_acquisition_url: self.license_acquisition_url,
            key_storage_policy: self.key_storage_policy,
        }
    }
}
