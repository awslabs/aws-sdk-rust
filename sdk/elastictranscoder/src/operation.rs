// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>The CancelJob operation cancels an unfinished job.</p>
/// <note>
/// <p>You can only cancel a job that has a status of <code>Submitted</code>. To prevent a
/// pipeline from starting to process a job while you're getting the job identifier, use
/// <a>UpdatePipelineStatus</a> to temporarily pause the pipeline.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelJob {
    _private: (),
}
impl CancelJob {
    /// Creates a new builder-style object to manufacture [`CancelJobInput`](crate::input::CancelJobInput)
    pub fn builder() -> crate::input::cancel_job_input::Builder {
        crate::input::cancel_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelJob {
    type Output = std::result::Result<crate::output::CancelJobOutput, crate::error::CancelJobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_ser::parse_cancel_job_error(response)
        } else {
            crate::operation_ser::parse_cancel_job_response(response)
        }
    }
}

/// <p>When you create a job, Elastic Transcoder returns JSON data that includes the values that you specified
/// plus information about the job that is created.</p>
/// <p>If you have specified more than one output for your jobs (for example, one output for the
/// Kindle Fire and another output for the Apple iPhone 4s), you currently must use the Elastic Transcoder API to
/// list the jobs (as opposed to the AWS Console).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateJob {
    _private: (),
}
impl CreateJob {
    /// Creates a new builder-style object to manufacture [`CreateJobInput`](crate::input::CreateJobInput)
    pub fn builder() -> crate::input::create_job_input::Builder {
        crate::input::create_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateJob {
    type Output = std::result::Result<crate::output::CreateJobOutput, crate::error::CreateJobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_ser::parse_create_job_error(response)
        } else {
            crate::operation_ser::parse_create_job_response(response)
        }
    }
}

/// <p>The CreatePipeline operation creates a pipeline with settings that you specify.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreatePipeline {
    _private: (),
}
impl CreatePipeline {
    /// Creates a new builder-style object to manufacture [`CreatePipelineInput`](crate::input::CreatePipelineInput)
    pub fn builder() -> crate::input::create_pipeline_input::Builder {
        crate::input::create_pipeline_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreatePipeline {
    type Output =
        std::result::Result<crate::output::CreatePipelineOutput, crate::error::CreatePipelineError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_ser::parse_create_pipeline_error(response)
        } else {
            crate::operation_ser::parse_create_pipeline_response(response)
        }
    }
}

/// <p>The CreatePreset operation creates a preset with settings that you specify.</p>
/// <important>
/// <p>Elastic Transcoder checks the CreatePreset settings to ensure that they meet Elastic Transcoder requirements
/// and to determine whether they comply with H.264 standards. If your settings are not
/// valid for Elastic Transcoder, Elastic Transcoder returns an HTTP 400 response (<code>ValidationException</code>) and
/// does not create the preset. If the settings are valid for Elastic Transcoder but aren't strictly
/// compliant with the H.264 standard, Elastic Transcoder creates the preset and returns a warning message
/// in the response. This helps you determine whether your settings comply with the H.264
/// standard while giving you greater flexibility with respect to the video that Elastic Transcoder
/// produces.</p>
/// </important>
/// <p>Elastic Transcoder uses the H.264 video-compression format. For more information, see the International
/// Telecommunication Union publication <i>Recommendation ITU-T H.264: Advanced video coding
/// for generic audiovisual services</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreatePreset {
    _private: (),
}
impl CreatePreset {
    /// Creates a new builder-style object to manufacture [`CreatePresetInput`](crate::input::CreatePresetInput)
    pub fn builder() -> crate::input::create_preset_input::Builder {
        crate::input::create_preset_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreatePreset {
    type Output =
        std::result::Result<crate::output::CreatePresetOutput, crate::error::CreatePresetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_ser::parse_create_preset_error(response)
        } else {
            crate::operation_ser::parse_create_preset_response(response)
        }
    }
}

/// <p>The DeletePipeline operation removes a pipeline.</p>
/// <p> You can only delete a pipeline that has never been used or that is not currently in use
/// (doesn't contain any active jobs). If the pipeline is currently in use,
/// <code>DeletePipeline</code> returns an error. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeletePipeline {
    _private: (),
}
impl DeletePipeline {
    /// Creates a new builder-style object to manufacture [`DeletePipelineInput`](crate::input::DeletePipelineInput)
    pub fn builder() -> crate::input::delete_pipeline_input::Builder {
        crate::input::delete_pipeline_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeletePipeline {
    type Output =
        std::result::Result<crate::output::DeletePipelineOutput, crate::error::DeletePipelineError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_ser::parse_delete_pipeline_error(response)
        } else {
            crate::operation_ser::parse_delete_pipeline_response(response)
        }
    }
}

/// <p>The DeletePreset operation removes a preset that you've added in an AWS region.</p>
/// <note>
/// <p>You can't delete the default presets that are included with Elastic Transcoder.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeletePreset {
    _private: (),
}
impl DeletePreset {
    /// Creates a new builder-style object to manufacture [`DeletePresetInput`](crate::input::DeletePresetInput)
    pub fn builder() -> crate::input::delete_preset_input::Builder {
        crate::input::delete_preset_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeletePreset {
    type Output =
        std::result::Result<crate::output::DeletePresetOutput, crate::error::DeletePresetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 202 {
            crate::operation_ser::parse_delete_preset_error(response)
        } else {
            crate::operation_ser::parse_delete_preset_response(response)
        }
    }
}

/// <p>The ListJobsByPipeline operation gets a list of the jobs currently in a pipeline.</p>
/// <p>Elastic Transcoder returns all of the jobs currently in the specified pipeline. The response body contains
/// one element for each job that satisfies the search criteria.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListJobsByPipeline {
    _private: (),
}
impl ListJobsByPipeline {
    /// Creates a new builder-style object to manufacture [`ListJobsByPipelineInput`](crate::input::ListJobsByPipelineInput)
    pub fn builder() -> crate::input::list_jobs_by_pipeline_input::Builder {
        crate::input::list_jobs_by_pipeline_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListJobsByPipeline {
    type Output = std::result::Result<
        crate::output::ListJobsByPipelineOutput,
        crate::error::ListJobsByPipelineError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_jobs_by_pipeline_error(response)
        } else {
            crate::operation_ser::parse_list_jobs_by_pipeline_response(response)
        }
    }
}

/// <p>The ListJobsByStatus operation gets a list of jobs that have a specified status. The response
/// body contains one element for each job that satisfies the search criteria.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListJobsByStatus {
    _private: (),
}
impl ListJobsByStatus {
    /// Creates a new builder-style object to manufacture [`ListJobsByStatusInput`](crate::input::ListJobsByStatusInput)
    pub fn builder() -> crate::input::list_jobs_by_status_input::Builder {
        crate::input::list_jobs_by_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListJobsByStatus {
    type Output = std::result::Result<
        crate::output::ListJobsByStatusOutput,
        crate::error::ListJobsByStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_jobs_by_status_error(response)
        } else {
            crate::operation_ser::parse_list_jobs_by_status_response(response)
        }
    }
}

/// <p>The ListPipelines operation gets a list of the pipelines associated with the current AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListPipelines {
    _private: (),
}
impl ListPipelines {
    /// Creates a new builder-style object to manufacture [`ListPipelinesInput`](crate::input::ListPipelinesInput)
    pub fn builder() -> crate::input::list_pipelines_input::Builder {
        crate::input::list_pipelines_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListPipelines {
    type Output =
        std::result::Result<crate::output::ListPipelinesOutput, crate::error::ListPipelinesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_pipelines_error(response)
        } else {
            crate::operation_ser::parse_list_pipelines_response(response)
        }
    }
}

/// <p>The ListPresets operation gets a list of the default presets included with Elastic Transcoder and the presets that
/// you've added in an AWS region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListPresets {
    _private: (),
}
impl ListPresets {
    /// Creates a new builder-style object to manufacture [`ListPresetsInput`](crate::input::ListPresetsInput)
    pub fn builder() -> crate::input::list_presets_input::Builder {
        crate::input::list_presets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListPresets {
    type Output =
        std::result::Result<crate::output::ListPresetsOutput, crate::error::ListPresetsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_presets_error(response)
        } else {
            crate::operation_ser::parse_list_presets_response(response)
        }
    }
}

/// <p>The ReadJob operation returns detailed information about a job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ReadJob {
    _private: (),
}
impl ReadJob {
    /// Creates a new builder-style object to manufacture [`ReadJobInput`](crate::input::ReadJobInput)
    pub fn builder() -> crate::input::read_job_input::Builder {
        crate::input::read_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ReadJob {
    type Output = std::result::Result<crate::output::ReadJobOutput, crate::error::ReadJobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_read_job_error(response)
        } else {
            crate::operation_ser::parse_read_job_response(response)
        }
    }
}

/// <p>The ReadPipeline operation gets detailed information about a pipeline.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ReadPipeline {
    _private: (),
}
impl ReadPipeline {
    /// Creates a new builder-style object to manufacture [`ReadPipelineInput`](crate::input::ReadPipelineInput)
    pub fn builder() -> crate::input::read_pipeline_input::Builder {
        crate::input::read_pipeline_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ReadPipeline {
    type Output =
        std::result::Result<crate::output::ReadPipelineOutput, crate::error::ReadPipelineError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_read_pipeline_error(response)
        } else {
            crate::operation_ser::parse_read_pipeline_response(response)
        }
    }
}

/// <p>The ReadPreset operation gets detailed information about a preset.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ReadPreset {
    _private: (),
}
impl ReadPreset {
    /// Creates a new builder-style object to manufacture [`ReadPresetInput`](crate::input::ReadPresetInput)
    pub fn builder() -> crate::input::read_preset_input::Builder {
        crate::input::read_preset_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ReadPreset {
    type Output =
        std::result::Result<crate::output::ReadPresetOutput, crate::error::ReadPresetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_read_preset_error(response)
        } else {
            crate::operation_ser::parse_read_preset_response(response)
        }
    }
}

/// <p>The TestRole operation tests the IAM role used to create the pipeline.</p>
/// <p>The <code>TestRole</code> action lets you determine whether the IAM role you are using
/// has sufficient permissions to let Elastic Transcoder perform tasks associated with the transcoding
/// process. The action attempts to assume the specified IAM role, checks read access to the
/// input and output buckets, and tries to send a test notification to Amazon SNS topics
/// that you specify.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TestRole {
    _private: (),
}
impl TestRole {
    /// Creates a new builder-style object to manufacture [`TestRoleInput`](crate::input::TestRoleInput)
    pub fn builder() -> crate::input::test_role_input::Builder {
        crate::input::test_role_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TestRole {
    type Output = std::result::Result<crate::output::TestRoleOutput, crate::error::TestRoleError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_test_role_error(response)
        } else {
            crate::operation_ser::parse_test_role_response(response)
        }
    }
}

/// <p> Use the <code>UpdatePipeline</code> operation to update settings for a pipeline.</p>
/// <important>
/// <p>When you change pipeline settings, your changes take effect immediately.
/// Jobs that you have already submitted and that Elastic Transcoder has not started to process are
/// affected in addition to jobs that you submit after you change settings. </p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdatePipeline {
    _private: (),
}
impl UpdatePipeline {
    /// Creates a new builder-style object to manufacture [`UpdatePipelineInput`](crate::input::UpdatePipelineInput)
    pub fn builder() -> crate::input::update_pipeline_input::Builder {
        crate::input::update_pipeline_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdatePipeline {
    type Output =
        std::result::Result<crate::output::UpdatePipelineOutput, crate::error::UpdatePipelineError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_pipeline_error(response)
        } else {
            crate::operation_ser::parse_update_pipeline_response(response)
        }
    }
}

/// <p>With the UpdatePipelineNotifications operation, you can update Amazon Simple Notification Service (Amazon SNS) notifications for a pipeline.</p>
/// <p>When you update notifications for a pipeline, Elastic Transcoder returns the values that you specified in the request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdatePipelineNotifications {
    _private: (),
}
impl UpdatePipelineNotifications {
    /// Creates a new builder-style object to manufacture [`UpdatePipelineNotificationsInput`](crate::input::UpdatePipelineNotificationsInput)
    pub fn builder() -> crate::input::update_pipeline_notifications_input::Builder {
        crate::input::update_pipeline_notifications_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdatePipelineNotifications {
    type Output = std::result::Result<
        crate::output::UpdatePipelineNotificationsOutput,
        crate::error::UpdatePipelineNotificationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_pipeline_notifications_error(response)
        } else {
            crate::operation_ser::parse_update_pipeline_notifications_response(response)
        }
    }
}

/// <p>The UpdatePipelineStatus operation pauses or reactivates a pipeline, so that the pipeline
/// stops or restarts the processing of jobs.</p>
/// <p>Changing the pipeline status is useful if you want to cancel one or more jobs. You can't
/// cancel jobs after Elastic Transcoder has started processing them; if you pause the pipeline to which
/// you submitted the jobs, you have more time to get the job IDs for the jobs that you want
/// to cancel, and to send a <a>CancelJob</a> request. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdatePipelineStatus {
    _private: (),
}
impl UpdatePipelineStatus {
    /// Creates a new builder-style object to manufacture [`UpdatePipelineStatusInput`](crate::input::UpdatePipelineStatusInput)
    pub fn builder() -> crate::input::update_pipeline_status_input::Builder {
        crate::input::update_pipeline_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdatePipelineStatus {
    type Output = std::result::Result<
        crate::output::UpdatePipelineStatusOutput,
        crate::error::UpdatePipelineStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_pipeline_status_error(response)
        } else {
            crate::operation_ser::parse_update_pipeline_status_response(response)
        }
    }
}
