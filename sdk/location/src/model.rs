// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>The input failed to meet the constraints specified by the AWS service in a specified
/// field. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidationExceptionField {
    /// <p>The field name where the invalid entry was detected.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A message with the reason for the validation exception error.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ValidationExceptionField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidationExceptionField");
        formatter.field("name", &self.name);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`ValidationExceptionField`](crate::model::ValidationExceptionField)
pub mod validation_exception_field {
    /// A builder for [`ValidationExceptionField`](crate::model::ValidationExceptionField)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The field name where the invalid entry was detected.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A message with the reason for the validation exception error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationExceptionField`](crate::model::ValidationExceptionField)
        pub fn build(self) -> crate::model::ValidationExceptionField {
            crate::model::ValidationExceptionField {
                name: self.name,
                message: self.message,
            }
        }
    }
}
impl ValidationExceptionField {
    /// Creates a new builder-style object to manufacture [`ValidationExceptionField`](crate::model::ValidationExceptionField)
    pub fn builder() -> crate::model::validation_exception_field::Builder {
        crate::model::validation_exception_field::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub struct ValidationExceptionReason(String);
impl ValidationExceptionReason {
    pub fn as_str(&self) -> &str {
        &self.0
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "CannotParse",
            "FieldValidationFailed",
            "Missing",
            "Other",
            "UnknownOperation",
        ]
    }
}
impl<T> std::convert::From<T> for ValidationExceptionReason
where
    T: std::convert::AsRef<str>,
{
    fn from(s: T) -> Self {
        ValidationExceptionReason(s.as_ref().to_owned())
    }
}

/// <p>Contains the tracker resource details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDevicePositionsResponseEntry {
    /// <p>The ID of the device for this position.</p>
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The timestamp at which the device position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a>
    /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>.</p>
    pub sample_time: std::option::Option<smithy_types::Instant>,
    /// <p>The last known device position. Empty if no positions currently stored.</p>
    pub position: std::option::Option<std::vec::Vec<f64>>,
}
impl std::fmt::Debug for ListDevicePositionsResponseEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDevicePositionsResponseEntry");
        formatter.field("device_id", &self.device_id);
        formatter.field("sample_time", &self.sample_time);
        formatter.field("position", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`ListDevicePositionsResponseEntry`](crate::model::ListDevicePositionsResponseEntry)
pub mod list_device_positions_response_entry {
    /// A builder for [`ListDevicePositionsResponseEntry`](crate::model::ListDevicePositionsResponseEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) sample_time: std::option::Option<smithy_types::Instant>,
        pub(crate) position: std::option::Option<std::vec::Vec<f64>>,
    }
    impl Builder {
        /// <p>The ID of the device for this position.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The timestamp at which the device position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>.</p>
        pub fn sample_time(mut self, input: smithy_types::Instant) -> Self {
            self.sample_time = Some(input);
            self
        }
        pub fn set_sample_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.sample_time = input;
            self
        }
        pub fn position(mut self, input: impl Into<f64>) -> Self {
            let mut v = self.position.unwrap_or_default();
            v.push(input.into());
            self.position = Some(v);
            self
        }
        pub fn set_position(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.position = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDevicePositionsResponseEntry`](crate::model::ListDevicePositionsResponseEntry)
        pub fn build(self) -> crate::model::ListDevicePositionsResponseEntry {
            crate::model::ListDevicePositionsResponseEntry {
                device_id: self.device_id,
                sample_time: self.sample_time,
                position: self.position,
            }
        }
    }
}
impl ListDevicePositionsResponseEntry {
    /// Creates a new builder-style object to manufacture [`ListDevicePositionsResponseEntry`](crate::model::ListDevicePositionsResponseEntry)
    pub fn builder() -> crate::model::list_device_positions_response_entry::Builder {
        crate::model::list_device_positions_response_entry::Builder::default()
    }
}

/// <p>Contains the device position details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DevicePosition {
    /// <p>The device whose position you retrieved.</p>
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The timestamp at which the device's position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a>
    /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. </p>
    pub sample_time: std::option::Option<smithy_types::Instant>,
    /// <p>The timestamp for when the tracker resource received the device position in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a>
    /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. </p>
    pub received_time: std::option::Option<smithy_types::Instant>,
    /// <p>The last known device position.</p>
    pub position: std::option::Option<std::vec::Vec<f64>>,
}
impl std::fmt::Debug for DevicePosition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DevicePosition");
        formatter.field("device_id", &self.device_id);
        formatter.field("sample_time", &self.sample_time);
        formatter.field("received_time", &self.received_time);
        formatter.field("position", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`DevicePosition`](crate::model::DevicePosition)
pub mod device_position {
    /// A builder for [`DevicePosition`](crate::model::DevicePosition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) sample_time: std::option::Option<smithy_types::Instant>,
        pub(crate) received_time: std::option::Option<smithy_types::Instant>,
        pub(crate) position: std::option::Option<std::vec::Vec<f64>>,
    }
    impl Builder {
        /// <p>The device whose position you retrieved.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The timestamp at which the device's position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. </p>
        pub fn sample_time(mut self, input: smithy_types::Instant) -> Self {
            self.sample_time = Some(input);
            self
        }
        pub fn set_sample_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.sample_time = input;
            self
        }
        /// <p>The timestamp for when the tracker resource received the device position in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. </p>
        pub fn received_time(mut self, input: smithy_types::Instant) -> Self {
            self.received_time = Some(input);
            self
        }
        pub fn set_received_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.received_time = input;
            self
        }
        pub fn position(mut self, input: impl Into<f64>) -> Self {
            let mut v = self.position.unwrap_or_default();
            v.push(input.into());
            self.position = Some(v);
            self
        }
        pub fn set_position(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.position = input;
            self
        }
        /// Consumes the builder and constructs a [`DevicePosition`](crate::model::DevicePosition)
        pub fn build(self) -> crate::model::DevicePosition {
            crate::model::DevicePosition {
                device_id: self.device_id,
                sample_time: self.sample_time,
                received_time: self.received_time,
                position: self.position,
            }
        }
    }
}
impl DevicePosition {
    /// Creates a new builder-style object to manufacture [`DevicePosition`](crate::model::DevicePosition)
    pub fn builder() -> crate::model::device_position::Builder {
        crate::model::device_position::Builder::default()
    }
}

/// <p>Contains  error details for each device that failed to update its position.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchUpdateDevicePositionError {
    /// <p>The device associated with the failed location update.</p>
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The timestamp at which the device position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a>
    /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. </p>
    pub sample_time: std::option::Option<smithy_types::Instant>,
    /// <p>Contains details related to the error code such as the error code and error
    /// message.</p>
    pub error: std::option::Option<crate::model::BatchItemError>,
}
impl std::fmt::Debug for BatchUpdateDevicePositionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchUpdateDevicePositionError");
        formatter.field("device_id", &self.device_id);
        formatter.field("sample_time", &self.sample_time);
        formatter.field("error", &self.error);
        formatter.finish()
    }
}
/// See [`BatchUpdateDevicePositionError`](crate::model::BatchUpdateDevicePositionError)
pub mod batch_update_device_position_error {
    /// A builder for [`BatchUpdateDevicePositionError`](crate::model::BatchUpdateDevicePositionError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) sample_time: std::option::Option<smithy_types::Instant>,
        pub(crate) error: std::option::Option<crate::model::BatchItemError>,
    }
    impl Builder {
        /// <p>The device associated with the failed location update.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The timestamp at which the device position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. </p>
        pub fn sample_time(mut self, input: smithy_types::Instant) -> Self {
            self.sample_time = Some(input);
            self
        }
        pub fn set_sample_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.sample_time = input;
            self
        }
        /// <p>Contains details related to the error code such as the error code and error
        /// message.</p>
        pub fn error(mut self, input: crate::model::BatchItemError) -> Self {
            self.error = Some(input);
            self
        }
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::BatchItemError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchUpdateDevicePositionError`](crate::model::BatchUpdateDevicePositionError)
        pub fn build(self) -> crate::model::BatchUpdateDevicePositionError {
            crate::model::BatchUpdateDevicePositionError {
                device_id: self.device_id,
                sample_time: self.sample_time,
                error: self.error,
            }
        }
    }
}
impl BatchUpdateDevicePositionError {
    /// Creates a new builder-style object to manufacture [`BatchUpdateDevicePositionError`](crate::model::BatchUpdateDevicePositionError)
    pub fn builder() -> crate::model::batch_update_device_position_error::Builder {
        crate::model::batch_update_device_position_error::Builder::default()
    }
}

/// <p>Contains the batch request error details associated with the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchItemError {
    /// <p>The error code associated with the batch request error.</p>
    pub code: std::option::Option<crate::model::BatchItemErrorCode>,
    /// <p>A message with the reason for the batch request error.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BatchItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchItemError");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`BatchItemError`](crate::model::BatchItemError)
pub mod batch_item_error {
    /// A builder for [`BatchItemError`](crate::model::BatchItemError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::BatchItemErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code associated with the batch request error.</p>
        pub fn code(mut self, input: crate::model::BatchItemErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::BatchItemErrorCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>A message with the reason for the batch request error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchItemError`](crate::model::BatchItemError)
        pub fn build(self) -> crate::model::BatchItemError {
            crate::model::BatchItemError {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl BatchItemError {
    /// Creates a new builder-style object to manufacture [`BatchItemError`](crate::model::BatchItemError)
    pub fn builder() -> crate::model::batch_item_error::Builder {
        crate::model::batch_item_error::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub struct BatchItemErrorCode(String);
impl BatchItemErrorCode {
    pub fn as_str(&self) -> &str {
        &self.0
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "AccessDeniedError",
            "ConflictError",
            "InternalServerError",
            "ResourceNotFoundError",
            "ThrottlingError",
            "ValidationError",
        ]
    }
}
impl<T> std::convert::From<T> for BatchItemErrorCode
where
    T: std::convert::AsRef<str>,
{
    fn from(s: T) -> Self {
        BatchItemErrorCode(s.as_ref().to_owned())
    }
}

/// <p>Contains the position update details for a device.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DevicePositionUpdate {
    /// <p>The device associated to the position update.</p>
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The timestamp at which the device's position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
    /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>
    /// </p>
    pub sample_time: std::option::Option<smithy_types::Instant>,
    /// <p>The latest device position defined in <a href="https://earth-info.nga.mil/GandG/wgs84/index.html">WGS 84</a> format:
    /// <code>[X or longitude, Y or latitude]</code>.</p>
    pub position: std::option::Option<std::vec::Vec<f64>>,
}
impl std::fmt::Debug for DevicePositionUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DevicePositionUpdate");
        formatter.field("device_id", &self.device_id);
        formatter.field("sample_time", &self.sample_time);
        formatter.field("position", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`DevicePositionUpdate`](crate::model::DevicePositionUpdate)
pub mod device_position_update {
    /// A builder for [`DevicePositionUpdate`](crate::model::DevicePositionUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) sample_time: std::option::Option<smithy_types::Instant>,
        pub(crate) position: std::option::Option<std::vec::Vec<f64>>,
    }
    impl Builder {
        /// <p>The device associated to the position update.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The timestamp at which the device's position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>
        /// </p>
        pub fn sample_time(mut self, input: smithy_types::Instant) -> Self {
            self.sample_time = Some(input);
            self
        }
        pub fn set_sample_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.sample_time = input;
            self
        }
        pub fn position(mut self, input: impl Into<f64>) -> Self {
            let mut v = self.position.unwrap_or_default();
            v.push(input.into());
            self.position = Some(v);
            self
        }
        pub fn set_position(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.position = input;
            self
        }
        /// Consumes the builder and constructs a [`DevicePositionUpdate`](crate::model::DevicePositionUpdate)
        pub fn build(self) -> crate::model::DevicePositionUpdate {
            crate::model::DevicePositionUpdate {
                device_id: self.device_id,
                sample_time: self.sample_time,
                position: self.position,
            }
        }
    }
}
impl DevicePositionUpdate {
    /// Creates a new builder-style object to manufacture [`DevicePositionUpdate`](crate::model::DevicePositionUpdate)
    pub fn builder() -> crate::model::device_position_update::Builder {
        crate::model::device_position_update::Builder::default()
    }
}

/// <p>Contains error details for each device that didn't return a position.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchGetDevicePositionError {
    /// <p>The ID of the device that didn't return a position.</p>
    pub device_id: std::option::Option<std::string::String>,
    /// <p>Contains details related to the error code.</p>
    pub error: std::option::Option<crate::model::BatchItemError>,
}
impl std::fmt::Debug for BatchGetDevicePositionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchGetDevicePositionError");
        formatter.field("device_id", &self.device_id);
        formatter.field("error", &self.error);
        formatter.finish()
    }
}
/// See [`BatchGetDevicePositionError`](crate::model::BatchGetDevicePositionError)
pub mod batch_get_device_position_error {
    /// A builder for [`BatchGetDevicePositionError`](crate::model::BatchGetDevicePositionError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) error: std::option::Option<crate::model::BatchItemError>,
    }
    impl Builder {
        /// <p>The ID of the device that didn't return a position.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>Contains details related to the error code.</p>
        pub fn error(mut self, input: crate::model::BatchItemError) -> Self {
            self.error = Some(input);
            self
        }
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::BatchItemError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetDevicePositionError`](crate::model::BatchGetDevicePositionError)
        pub fn build(self) -> crate::model::BatchGetDevicePositionError {
            crate::model::BatchGetDevicePositionError {
                device_id: self.device_id,
                error: self.error,
            }
        }
    }
}
impl BatchGetDevicePositionError {
    /// Creates a new builder-style object to manufacture [`BatchGetDevicePositionError`](crate::model::BatchGetDevicePositionError)
    pub fn builder() -> crate::model::batch_get_device_position_error::Builder {
        crate::model::batch_get_device_position_error::Builder::default()
    }
}

/// <p>Contains the tracker resource details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchDeleteDevicePositionHistoryError {
    /// <p>The ID of the device for this position.</p>
    pub device_id: std::option::Option<std::string::String>,
    /// <p>Contains the batch request error details associated with the request.</p>
    pub error: std::option::Option<crate::model::BatchItemError>,
}
impl std::fmt::Debug for BatchDeleteDevicePositionHistoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchDeleteDevicePositionHistoryError");
        formatter.field("device_id", &self.device_id);
        formatter.field("error", &self.error);
        formatter.finish()
    }
}
/// See [`BatchDeleteDevicePositionHistoryError`](crate::model::BatchDeleteDevicePositionHistoryError)
pub mod batch_delete_device_position_history_error {
    /// A builder for [`BatchDeleteDevicePositionHistoryError`](crate::model::BatchDeleteDevicePositionHistoryError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) error: std::option::Option<crate::model::BatchItemError>,
    }
    impl Builder {
        /// <p>The ID of the device for this position.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>Contains the batch request error details associated with the request.</p>
        pub fn error(mut self, input: crate::model::BatchItemError) -> Self {
            self.error = Some(input);
            self
        }
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::BatchItemError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDeleteDevicePositionHistoryError`](crate::model::BatchDeleteDevicePositionHistoryError)
        pub fn build(self) -> crate::model::BatchDeleteDevicePositionHistoryError {
            crate::model::BatchDeleteDevicePositionHistoryError {
                device_id: self.device_id,
                error: self.error,
            }
        }
    }
}
impl BatchDeleteDevicePositionHistoryError {
    /// Creates a new builder-style object to manufacture [`BatchDeleteDevicePositionHistoryError`](crate::model::BatchDeleteDevicePositionHistoryError)
    pub fn builder() -> crate::model::batch_delete_device_position_history_error::Builder {
        crate::model::batch_delete_device_position_history_error::Builder::default()
    }
}

/// <p>Contains the tracker resource details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTrackersResponseEntry {
    /// <p>The name of the tracker resource.</p>
    pub tracker_name: std::option::Option<std::string::String>,
    /// <p>The description for the tracker resource.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The pricing plan for the specified tracker resource.</p>
    /// <p>For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
    /// page</a>.</p>
    pub pricing_plan: std::option::Option<crate::model::PricingPlan>,
    /// <p>The specified data provider for the tracker resource.</p>
    pub pricing_plan_data_source: std::option::Option<std::string::String>,
    /// <p>The timestamp for when the tracker resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a>
    /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. </p>
    pub create_time: std::option::Option<smithy_types::Instant>,
    /// <p>The timestamp at which the device's position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a>
    /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. </p>
    pub update_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ListTrackersResponseEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTrackersResponseEntry");
        formatter.field("tracker_name", &self.tracker_name);
        formatter.field("description", &self.description);
        formatter.field("pricing_plan", &self.pricing_plan);
        formatter.field("pricing_plan_data_source", &self.pricing_plan_data_source);
        formatter.field("create_time", &self.create_time);
        formatter.field("update_time", &self.update_time);
        formatter.finish()
    }
}
/// See [`ListTrackersResponseEntry`](crate::model::ListTrackersResponseEntry)
pub mod list_trackers_response_entry {
    /// A builder for [`ListTrackersResponseEntry`](crate::model::ListTrackersResponseEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tracker_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) pricing_plan: std::option::Option<crate::model::PricingPlan>,
        pub(crate) pricing_plan_data_source: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<smithy_types::Instant>,
        pub(crate) update_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the tracker resource.</p>
        pub fn tracker_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.tracker_name = Some(input.into());
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tracker_name = input;
            self
        }
        /// <p>The description for the tracker resource.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The pricing plan for the specified tracker resource.</p>
        /// <p>For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
        /// page</a>.</p>
        pub fn pricing_plan(mut self, input: crate::model::PricingPlan) -> Self {
            self.pricing_plan = Some(input);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.pricing_plan = input;
            self
        }
        /// <p>The specified data provider for the tracker resource.</p>
        pub fn pricing_plan_data_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.pricing_plan_data_source = Some(input.into());
            self
        }
        pub fn set_pricing_plan_data_source(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pricing_plan_data_source = input;
            self
        }
        /// <p>The timestamp for when the tracker resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. </p>
        pub fn create_time(mut self, input: smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        pub fn set_create_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The timestamp at which the device's position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. </p>
        pub fn update_time(mut self, input: smithy_types::Instant) -> Self {
            self.update_time = Some(input);
            self
        }
        pub fn set_update_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTrackersResponseEntry`](crate::model::ListTrackersResponseEntry)
        pub fn build(self) -> crate::model::ListTrackersResponseEntry {
            crate::model::ListTrackersResponseEntry {
                tracker_name: self.tracker_name,
                description: self.description,
                pricing_plan: self.pricing_plan,
                pricing_plan_data_source: self.pricing_plan_data_source,
                create_time: self.create_time,
                update_time: self.update_time,
            }
        }
    }
}
impl ListTrackersResponseEntry {
    /// Creates a new builder-style object to manufacture [`ListTrackersResponseEntry`](crate::model::ListTrackersResponseEntry)
    pub fn builder() -> crate::model::list_trackers_response_entry::Builder {
        crate::model::list_trackers_response_entry::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub struct PricingPlan(String);
impl PricingPlan {
    pub fn as_str(&self) -> &str {
        &self.0
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "MobileAssetManagement",
            "MobileAssetTracking",
            "RequestBasedUsage",
        ]
    }
}
impl<T> std::convert::From<T> for PricingPlan
where
    T: std::convert::AsRef<str>,
{
    fn from(s: T) -> Self {
        PricingPlan(s.as_ref().to_owned())
    }
}

/// <p>A summary of the calculated route.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CalculateRouteSummary {
    /// <p>Specifies a geographical box surrounding a route. Used to zoom into a route when
    /// displaying it in a map. For example, <code>[min x, min y, max x, max y]</code>
    /// </p>
    /// <p>The first 2 <code>bbox</code> parameters describe the lower southwest corner: </p>
    /// <ul>
    /// <li>
    /// <p>The first <code>bbox</code> position is the X coordinate or longitude of the
    /// lower southwest corner. </p>
    /// </li>
    /// <li>
    /// <p>The second <code>bbox</code> position is the Y coordinate or latitude of the
    /// lower southwest corner. </p>
    /// </li>
    /// </ul>
    /// <p>The next 2 <code>bbox</code> parameters describe the upper northeast corner: </p>
    /// <ul>
    /// <li>
    /// <p>The third <code>bbox</code> position is the X coordinate, or longitude of the
    /// upper northeast corner. </p>
    /// </li>
    /// <li>
    /// <p>The fourth <code>bbox</code> position is the Y coordinate, or longitude of the
    /// upper northeast corner. </p>
    /// </li>
    /// </ul>
    pub route_b_box: std::option::Option<std::vec::Vec<f64>>,
    /// <p>The data provider of traffic and road network data used to calculate the route.
    /// Indicates one of the available providers:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Esri</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Here</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>For more information about data providers, see <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Amazon Location Service data providers</a>.</p>
    pub data_source: std::option::Option<std::string::String>,
    /// <p>The total distance covered by the route. The sum of the distance travelled between
    /// every stop on the route.</p>
    /// <note>
    /// <p>The route <code>distance</code> can't be greater than 250 km. If the route exceeds
    /// 250 km, the response returns a <code>400 RoutesValidationException</code>
    /// error.</p>
    /// </note>
    pub distance: std::option::Option<f64>,
    /// <p>The total travel time for the route measured in seconds. The sum of the travel time
    /// between every stop on the
    /// route.</p>
    pub duration_seconds: std::option::Option<f64>,
    /// <p>The unit of measurement for the distance.</p>
    pub distance_unit: std::option::Option<crate::model::DistanceUnit>,
}
impl std::fmt::Debug for CalculateRouteSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CalculateRouteSummary");
        formatter.field("route_b_box", &"*** Sensitive Data Redacted ***");
        formatter.field("data_source", &self.data_source);
        formatter.field("distance", &self.distance);
        formatter.field("duration_seconds", &self.duration_seconds);
        formatter.field("distance_unit", &self.distance_unit);
        formatter.finish()
    }
}
/// See [`CalculateRouteSummary`](crate::model::CalculateRouteSummary)
pub mod calculate_route_summary {
    /// A builder for [`CalculateRouteSummary`](crate::model::CalculateRouteSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) route_b_box: std::option::Option<std::vec::Vec<f64>>,
        pub(crate) data_source: std::option::Option<std::string::String>,
        pub(crate) distance: std::option::Option<f64>,
        pub(crate) duration_seconds: std::option::Option<f64>,
        pub(crate) distance_unit: std::option::Option<crate::model::DistanceUnit>,
    }
    impl Builder {
        pub fn route_b_box(mut self, input: impl Into<f64>) -> Self {
            let mut v = self.route_b_box.unwrap_or_default();
            v.push(input.into());
            self.route_b_box = Some(v);
            self
        }
        pub fn set_route_b_box(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.route_b_box = input;
            self
        }
        /// <p>The data provider of traffic and road network data used to calculate the route.
        /// Indicates one of the available providers:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Esri</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Here</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For more information about data providers, see <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Amazon Location Service data providers</a>.</p>
        pub fn data_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_source = Some(input.into());
            self
        }
        pub fn set_data_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_source = input;
            self
        }
        /// <p>The total distance covered by the route. The sum of the distance travelled between
        /// every stop on the route.</p>
        /// <note>
        /// <p>The route <code>distance</code> can't be greater than 250 km. If the route exceeds
        /// 250 km, the response returns a <code>400 RoutesValidationException</code>
        /// error.</p>
        /// </note>
        pub fn distance(mut self, input: f64) -> Self {
            self.distance = Some(input);
            self
        }
        pub fn set_distance(mut self, input: std::option::Option<f64>) -> Self {
            self.distance = input;
            self
        }
        /// <p>The total travel time for the route measured in seconds. The sum of the travel time
        /// between every stop on the
        /// route.</p>
        pub fn duration_seconds(mut self, input: f64) -> Self {
            self.duration_seconds = Some(input);
            self
        }
        pub fn set_duration_seconds(mut self, input: std::option::Option<f64>) -> Self {
            self.duration_seconds = input;
            self
        }
        /// <p>The unit of measurement for the distance.</p>
        pub fn distance_unit(mut self, input: crate::model::DistanceUnit) -> Self {
            self.distance_unit = Some(input);
            self
        }
        pub fn set_distance_unit(
            mut self,
            input: std::option::Option<crate::model::DistanceUnit>,
        ) -> Self {
            self.distance_unit = input;
            self
        }
        /// Consumes the builder and constructs a [`CalculateRouteSummary`](crate::model::CalculateRouteSummary)
        pub fn build(self) -> crate::model::CalculateRouteSummary {
            crate::model::CalculateRouteSummary {
                route_b_box: self.route_b_box,
                data_source: self.data_source,
                distance: self.distance,
                duration_seconds: self.duration_seconds,
                distance_unit: self.distance_unit,
            }
        }
    }
}
impl CalculateRouteSummary {
    /// Creates a new builder-style object to manufacture [`CalculateRouteSummary`](crate::model::CalculateRouteSummary)
    pub fn builder() -> crate::model::calculate_route_summary::Builder {
        crate::model::calculate_route_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub struct DistanceUnit(String);
impl DistanceUnit {
    pub fn as_str(&self) -> &str {
        &self.0
    }
    pub fn values() -> &'static [&'static str] {
        &["Kilometers", "Miles"]
    }
}
impl<T> std::convert::From<T> for DistanceUnit
where
    T: std::convert::AsRef<str>,
{
    fn from(s: T) -> Self {
        DistanceUnit(s.as_ref().to_owned())
    }
}

/// <p>Contains the calculated route's details for each path between a pair of positions. The
/// number of legs returned corresponds to one less than the total number of positions in
/// the request. </p>
/// <p>For example, a route with a departure position and destination position returns one
/// leg with the positions <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#snap-to-nearby-road">snapped to a nearby road</a>:</p>
/// <ul>
/// <li>
/// <p>The <code>StartPosition</code> is the departure position.</p>
/// </li>
/// <li>
/// <p>The <code>EndPosition</code> is the destination position.</p>
/// </li>
/// </ul>
/// <p>A route with a waypoint between the departure and destination position returns two
/// legs with the positions snapped to a nearby road.:</p>
/// <ul>
/// <li>
/// <p>Leg 1: The <code>StartPosition</code> is the departure position . The
/// <code>EndPosition</code> is the waypoint positon.</p>
/// </li>
/// <li>
/// <p>Leg 2: The <code>StartPosition</code> is the waypoint position. The
/// <code>EndPosition</code> is the destination position.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Leg {
    /// <p>The starting position of the leg. Follows the format
    /// <code>[longitude,latitude]</code>.</p>
    /// <note>
    /// <p>If the <code>StartPosition</code> isn't located on a road, it's <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#snap-to-nearby-road">snapped to a nearby road</a>. </p>
    /// </note>
    pub start_position: std::option::Option<std::vec::Vec<f64>>,
    /// <p>The terminating position of the leg. Follows the format
    /// <code>[longitude,latitude]</code>.</p>
    /// <note>
    /// <p>If the <code>EndPosition</code> isn't located on a road, it's <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#snap-to-nearby-road">snapped to a nearby road</a>. </p>
    /// </note>
    pub end_position: std::option::Option<std::vec::Vec<f64>>,
    /// <p>The distance between the leg's <code>StartPosition</code> and <code>EndPosition</code>
    /// along a calculated route. </p>
    /// <ul>
    /// <li>
    /// <p>The default measurement is <code>Kilometers</code> unless the request
    /// specifies a <code>DistanceUnit</code> of <code>Miles</code>.</p>
    /// </li>
    /// </ul>
    pub distance: std::option::Option<f64>,
    /// <p>The estimated travel time between the leg's <code>StartPosition</code> and
    /// <code>EndPosition</code>. The travel mode and departure time that you specify in the
    /// request determines the calculated time.</p>
    pub duration_seconds: std::option::Option<f64>,
    /// <p>Contains the calculated route's path as a linestring geometry.</p>
    pub geometry: std::option::Option<crate::model::LegGeometry>,
    /// <p>Contains a list of steps, which represent subsections of a leg. Each step provides
    /// instructions for how to move to the next step in the leg such as the step's start
    /// position, end position, travel distance, travel duration, and geometry offset.</p>
    pub steps: std::option::Option<std::vec::Vec<crate::model::Step>>,
}
impl std::fmt::Debug for Leg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Leg");
        formatter.field("start_position", &"*** Sensitive Data Redacted ***");
        formatter.field("end_position", &"*** Sensitive Data Redacted ***");
        formatter.field("distance", &self.distance);
        formatter.field("duration_seconds", &self.duration_seconds);
        formatter.field("geometry", &self.geometry);
        formatter.field("steps", &self.steps);
        formatter.finish()
    }
}
/// See [`Leg`](crate::model::Leg)
pub mod leg {
    /// A builder for [`Leg`](crate::model::Leg)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_position: std::option::Option<std::vec::Vec<f64>>,
        pub(crate) end_position: std::option::Option<std::vec::Vec<f64>>,
        pub(crate) distance: std::option::Option<f64>,
        pub(crate) duration_seconds: std::option::Option<f64>,
        pub(crate) geometry: std::option::Option<crate::model::LegGeometry>,
        pub(crate) steps: std::option::Option<std::vec::Vec<crate::model::Step>>,
    }
    impl Builder {
        pub fn start_position(mut self, input: impl Into<f64>) -> Self {
            let mut v = self.start_position.unwrap_or_default();
            v.push(input.into());
            self.start_position = Some(v);
            self
        }
        pub fn set_start_position(
            mut self,
            input: std::option::Option<std::vec::Vec<f64>>,
        ) -> Self {
            self.start_position = input;
            self
        }
        pub fn end_position(mut self, input: impl Into<f64>) -> Self {
            let mut v = self.end_position.unwrap_or_default();
            v.push(input.into());
            self.end_position = Some(v);
            self
        }
        pub fn set_end_position(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.end_position = input;
            self
        }
        /// <p>The distance between the leg's <code>StartPosition</code> and <code>EndPosition</code>
        /// along a calculated route. </p>
        /// <ul>
        /// <li>
        /// <p>The default measurement is <code>Kilometers</code> unless the request
        /// specifies a <code>DistanceUnit</code> of <code>Miles</code>.</p>
        /// </li>
        /// </ul>
        pub fn distance(mut self, input: f64) -> Self {
            self.distance = Some(input);
            self
        }
        pub fn set_distance(mut self, input: std::option::Option<f64>) -> Self {
            self.distance = input;
            self
        }
        /// <p>The estimated travel time between the leg's <code>StartPosition</code> and
        /// <code>EndPosition</code>. The travel mode and departure time that you specify in the
        /// request determines the calculated time.</p>
        pub fn duration_seconds(mut self, input: f64) -> Self {
            self.duration_seconds = Some(input);
            self
        }
        pub fn set_duration_seconds(mut self, input: std::option::Option<f64>) -> Self {
            self.duration_seconds = input;
            self
        }
        /// <p>Contains the calculated route's path as a linestring geometry.</p>
        pub fn geometry(mut self, input: crate::model::LegGeometry) -> Self {
            self.geometry = Some(input);
            self
        }
        pub fn set_geometry(
            mut self,
            input: std::option::Option<crate::model::LegGeometry>,
        ) -> Self {
            self.geometry = input;
            self
        }
        pub fn steps(mut self, input: impl Into<crate::model::Step>) -> Self {
            let mut v = self.steps.unwrap_or_default();
            v.push(input.into());
            self.steps = Some(v);
            self
        }
        pub fn set_steps(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Step>>,
        ) -> Self {
            self.steps = input;
            self
        }
        /// Consumes the builder and constructs a [`Leg`](crate::model::Leg)
        pub fn build(self) -> crate::model::Leg {
            crate::model::Leg {
                start_position: self.start_position,
                end_position: self.end_position,
                distance: self.distance,
                duration_seconds: self.duration_seconds,
                geometry: self.geometry,
                steps: self.steps,
            }
        }
    }
}
impl Leg {
    /// Creates a new builder-style object to manufacture [`Leg`](crate::model::Leg)
    pub fn builder() -> crate::model::leg::Builder {
        crate::model::leg::Builder::default()
    }
}

/// <p> Represents an element of a leg within a route. A step contains instructions for how
/// to move to the next step in the leg. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Step {
    /// <p>The starting position of a step. If the position is the first step in the leg, this
    /// position is the same as the start position of the leg.</p>
    pub start_position: std::option::Option<std::vec::Vec<f64>>,
    /// <p>The end position of a step. If the position the last step in the leg, this position is
    /// the same as the end position of the leg.</p>
    pub end_position: std::option::Option<std::vec::Vec<f64>>,
    /// <p>The travel distance between the step's <code>StartPosition</code> and
    /// <code>EndPosition</code>.</p>
    pub distance: std::option::Option<f64>,
    /// <p>The estimated travel time, in seconds, from the step's <code>StartPosition</code> to
    /// the <code>EndPosition</code>. . The travel mode and departure time that you specify in
    /// the request determines the calculated time.</p>
    pub duration_seconds: std::option::Option<f64>,
    /// <p>Represents the start position, or index, in a sequence of steps within the leg's line
    /// string geometry. For example, the index of the first step in a leg geometry is
    /// <code>0</code>. </p>
    /// <p>Included in the response for queries that set <code>IncludeLegGeometry</code> to
    /// <code>True</code>. </p>
    pub geometry_offset: std::option::Option<i32>,
}
impl std::fmt::Debug for Step {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Step");
        formatter.field("start_position", &"*** Sensitive Data Redacted ***");
        formatter.field("end_position", &"*** Sensitive Data Redacted ***");
        formatter.field("distance", &self.distance);
        formatter.field("duration_seconds", &self.duration_seconds);
        formatter.field("geometry_offset", &self.geometry_offset);
        formatter.finish()
    }
}
/// See [`Step`](crate::model::Step)
pub mod step {
    /// A builder for [`Step`](crate::model::Step)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_position: std::option::Option<std::vec::Vec<f64>>,
        pub(crate) end_position: std::option::Option<std::vec::Vec<f64>>,
        pub(crate) distance: std::option::Option<f64>,
        pub(crate) duration_seconds: std::option::Option<f64>,
        pub(crate) geometry_offset: std::option::Option<i32>,
    }
    impl Builder {
        pub fn start_position(mut self, input: impl Into<f64>) -> Self {
            let mut v = self.start_position.unwrap_or_default();
            v.push(input.into());
            self.start_position = Some(v);
            self
        }
        pub fn set_start_position(
            mut self,
            input: std::option::Option<std::vec::Vec<f64>>,
        ) -> Self {
            self.start_position = input;
            self
        }
        pub fn end_position(mut self, input: impl Into<f64>) -> Self {
            let mut v = self.end_position.unwrap_or_default();
            v.push(input.into());
            self.end_position = Some(v);
            self
        }
        pub fn set_end_position(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.end_position = input;
            self
        }
        /// <p>The travel distance between the step's <code>StartPosition</code> and
        /// <code>EndPosition</code>.</p>
        pub fn distance(mut self, input: f64) -> Self {
            self.distance = Some(input);
            self
        }
        pub fn set_distance(mut self, input: std::option::Option<f64>) -> Self {
            self.distance = input;
            self
        }
        /// <p>The estimated travel time, in seconds, from the step's <code>StartPosition</code> to
        /// the <code>EndPosition</code>. . The travel mode and departure time that you specify in
        /// the request determines the calculated time.</p>
        pub fn duration_seconds(mut self, input: f64) -> Self {
            self.duration_seconds = Some(input);
            self
        }
        pub fn set_duration_seconds(mut self, input: std::option::Option<f64>) -> Self {
            self.duration_seconds = input;
            self
        }
        /// <p>Represents the start position, or index, in a sequence of steps within the leg's line
        /// string geometry. For example, the index of the first step in a leg geometry is
        /// <code>0</code>. </p>
        /// <p>Included in the response for queries that set <code>IncludeLegGeometry</code> to
        /// <code>True</code>. </p>
        pub fn geometry_offset(mut self, input: i32) -> Self {
            self.geometry_offset = Some(input);
            self
        }
        pub fn set_geometry_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.geometry_offset = input;
            self
        }
        /// Consumes the builder and constructs a [`Step`](crate::model::Step)
        pub fn build(self) -> crate::model::Step {
            crate::model::Step {
                start_position: self.start_position,
                end_position: self.end_position,
                distance: self.distance,
                duration_seconds: self.duration_seconds,
                geometry_offset: self.geometry_offset,
            }
        }
    }
}
impl Step {
    /// Creates a new builder-style object to manufacture [`Step`](crate::model::Step)
    pub fn builder() -> crate::model::step::Builder {
        crate::model::step::Builder::default()
    }
}

/// <p>Contains the geometry details for each path between a pair of positions. Used in
/// plotting a route leg on a map.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LegGeometry {
    /// <p>An ordered list of positions used to plot a route on a map. </p>
    /// <p>The first position is closest to the start position for the leg, and the last position
    /// is the closest to the end position for the leg.</p>
    /// <ul>
    /// <li>
    /// <p>For example, <code>[[-123.117, 49.284],[-123.115, 49.285],[-123.115,
    /// 49.285]]</code>
    /// </p>
    /// </li>
    /// </ul>
    pub line_string: std::option::Option<std::vec::Vec<std::vec::Vec<f64>>>,
}
impl std::fmt::Debug for LegGeometry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LegGeometry");
        formatter.field("line_string", &self.line_string);
        formatter.finish()
    }
}
/// See [`LegGeometry`](crate::model::LegGeometry)
pub mod leg_geometry {
    /// A builder for [`LegGeometry`](crate::model::LegGeometry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) line_string: std::option::Option<std::vec::Vec<std::vec::Vec<f64>>>,
    }
    impl Builder {
        pub fn line_string(mut self, input: impl Into<std::vec::Vec<f64>>) -> Self {
            let mut v = self.line_string.unwrap_or_default();
            v.push(input.into());
            self.line_string = Some(v);
            self
        }
        pub fn set_line_string(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<f64>>>,
        ) -> Self {
            self.line_string = input;
            self
        }
        /// Consumes the builder and constructs a [`LegGeometry`](crate::model::LegGeometry)
        pub fn build(self) -> crate::model::LegGeometry {
            crate::model::LegGeometry {
                line_string: self.line_string,
            }
        }
    }
}
impl LegGeometry {
    /// Creates a new builder-style object to manufacture [`LegGeometry`](crate::model::LegGeometry)
    pub fn builder() -> crate::model::leg_geometry::Builder {
        crate::model::leg_geometry::Builder::default()
    }
}

/// <p>Contains details about additional route preferences for requests that specify
/// <code>TravelMode</code> as <code>Truck</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CalculateRouteTruckModeOptions {
    /// <p>Avoids ferries when calculating routes.</p>
    /// <p>Default Value: <code>false</code>
    /// </p>
    /// <p>Valid Values: <code>false</code> | <code>true</code>
    /// </p>
    pub avoid_ferries: std::option::Option<bool>,
    /// <p>Avoids ferries when calculating routes.</p>
    /// <p>Default Value: <code>false</code>
    /// </p>
    /// <p>Valid Values: <code>false</code> | <code>true</code>
    /// </p>
    pub avoid_tolls: std::option::Option<bool>,
    /// <p>Specifies the truck's dimension specifications including length, height, width, and
    /// unit of measurement. Used to avoid roads that can't support the truck's
    /// dimensions.</p>
    pub dimensions: std::option::Option<crate::model::TruckDimensions>,
    /// <p>Specifies the truck's weight specifications including total weight and unit of
    /// measurement. Used to avoid roads that can't support the truck's weight.</p>
    pub weight: std::option::Option<crate::model::TruckWeight>,
}
impl std::fmt::Debug for CalculateRouteTruckModeOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CalculateRouteTruckModeOptions");
        formatter.field("avoid_ferries", &self.avoid_ferries);
        formatter.field("avoid_tolls", &self.avoid_tolls);
        formatter.field("dimensions", &self.dimensions);
        formatter.field("weight", &self.weight);
        formatter.finish()
    }
}
/// See [`CalculateRouteTruckModeOptions`](crate::model::CalculateRouteTruckModeOptions)
pub mod calculate_route_truck_mode_options {
    /// A builder for [`CalculateRouteTruckModeOptions`](crate::model::CalculateRouteTruckModeOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) avoid_ferries: std::option::Option<bool>,
        pub(crate) avoid_tolls: std::option::Option<bool>,
        pub(crate) dimensions: std::option::Option<crate::model::TruckDimensions>,
        pub(crate) weight: std::option::Option<crate::model::TruckWeight>,
    }
    impl Builder {
        /// <p>Avoids ferries when calculating routes.</p>
        /// <p>Default Value: <code>false</code>
        /// </p>
        /// <p>Valid Values: <code>false</code> | <code>true</code>
        /// </p>
        pub fn avoid_ferries(mut self, input: bool) -> Self {
            self.avoid_ferries = Some(input);
            self
        }
        pub fn set_avoid_ferries(mut self, input: std::option::Option<bool>) -> Self {
            self.avoid_ferries = input;
            self
        }
        /// <p>Avoids ferries when calculating routes.</p>
        /// <p>Default Value: <code>false</code>
        /// </p>
        /// <p>Valid Values: <code>false</code> | <code>true</code>
        /// </p>
        pub fn avoid_tolls(mut self, input: bool) -> Self {
            self.avoid_tolls = Some(input);
            self
        }
        pub fn set_avoid_tolls(mut self, input: std::option::Option<bool>) -> Self {
            self.avoid_tolls = input;
            self
        }
        /// <p>Specifies the truck's dimension specifications including length, height, width, and
        /// unit of measurement. Used to avoid roads that can't support the truck's
        /// dimensions.</p>
        pub fn dimensions(mut self, input: crate::model::TruckDimensions) -> Self {
            self.dimensions = Some(input);
            self
        }
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<crate::model::TruckDimensions>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// <p>Specifies the truck's weight specifications including total weight and unit of
        /// measurement. Used to avoid roads that can't support the truck's weight.</p>
        pub fn weight(mut self, input: crate::model::TruckWeight) -> Self {
            self.weight = Some(input);
            self
        }
        pub fn set_weight(mut self, input: std::option::Option<crate::model::TruckWeight>) -> Self {
            self.weight = input;
            self
        }
        /// Consumes the builder and constructs a [`CalculateRouteTruckModeOptions`](crate::model::CalculateRouteTruckModeOptions)
        pub fn build(self) -> crate::model::CalculateRouteTruckModeOptions {
            crate::model::CalculateRouteTruckModeOptions {
                avoid_ferries: self.avoid_ferries,
                avoid_tolls: self.avoid_tolls,
                dimensions: self.dimensions,
                weight: self.weight,
            }
        }
    }
}
impl CalculateRouteTruckModeOptions {
    /// Creates a new builder-style object to manufacture [`CalculateRouteTruckModeOptions`](crate::model::CalculateRouteTruckModeOptions)
    pub fn builder() -> crate::model::calculate_route_truck_mode_options::Builder {
        crate::model::calculate_route_truck_mode_options::Builder::default()
    }
}

/// <p>Contains details about the truck's weight specifications. Used to avoid roads that
/// can't support or allow the total weight for requests that specify
/// <code>TravelMode</code> as <code>Truck</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TruckWeight {
    /// <p>The total weight of the truck. </p>
    /// <ul>
    /// <li>
    /// <p>For example, <code>3500</code>.</p>
    /// </li>
    /// </ul>
    pub total: std::option::Option<f64>,
    /// <p>The unit of measurement to use for the truck weight.</p>
    /// <p>Default Value: <code>Kilograms</code>
    /// </p>
    pub unit: std::option::Option<crate::model::VehicleWeightUnit>,
}
impl std::fmt::Debug for TruckWeight {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TruckWeight");
        formatter.field("total", &self.total);
        formatter.field("unit", &self.unit);
        formatter.finish()
    }
}
/// See [`TruckWeight`](crate::model::TruckWeight)
pub mod truck_weight {
    /// A builder for [`TruckWeight`](crate::model::TruckWeight)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total: std::option::Option<f64>,
        pub(crate) unit: std::option::Option<crate::model::VehicleWeightUnit>,
    }
    impl Builder {
        /// <p>The total weight of the truck. </p>
        /// <ul>
        /// <li>
        /// <p>For example, <code>3500</code>.</p>
        /// </li>
        /// </ul>
        pub fn total(mut self, input: f64) -> Self {
            self.total = Some(input);
            self
        }
        pub fn set_total(mut self, input: std::option::Option<f64>) -> Self {
            self.total = input;
            self
        }
        /// <p>The unit of measurement to use for the truck weight.</p>
        /// <p>Default Value: <code>Kilograms</code>
        /// </p>
        pub fn unit(mut self, input: crate::model::VehicleWeightUnit) -> Self {
            self.unit = Some(input);
            self
        }
        pub fn set_unit(
            mut self,
            input: std::option::Option<crate::model::VehicleWeightUnit>,
        ) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`TruckWeight`](crate::model::TruckWeight)
        pub fn build(self) -> crate::model::TruckWeight {
            crate::model::TruckWeight {
                total: self.total,
                unit: self.unit,
            }
        }
    }
}
impl TruckWeight {
    /// Creates a new builder-style object to manufacture [`TruckWeight`](crate::model::TruckWeight)
    pub fn builder() -> crate::model::truck_weight::Builder {
        crate::model::truck_weight::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub struct VehicleWeightUnit(String);
impl VehicleWeightUnit {
    pub fn as_str(&self) -> &str {
        &self.0
    }
    pub fn values() -> &'static [&'static str] {
        &["Kilograms", "Pounds"]
    }
}
impl<T> std::convert::From<T> for VehicleWeightUnit
where
    T: std::convert::AsRef<str>,
{
    fn from(s: T) -> Self {
        VehicleWeightUnit(s.as_ref().to_owned())
    }
}

/// <p>Contains details about the truck dimensions in the unit of measurement that you
/// specify. Used to filter out roads that can't support or allow the specified dimensions
/// for requests that specify <code>TravelMode</code> as <code>Truck</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TruckDimensions {
    /// <p>The length of the truck.</p>
    /// <ul>
    /// <li>
    /// <p>For example, <code>15.5</code>.</p>
    /// </li>
    /// </ul>
    pub length: std::option::Option<f64>,
    /// <p>The height of the truck.</p>
    /// <ul>
    /// <li>
    /// <p>For example, <code>4.5</code>.</p>
    /// </li>
    /// </ul>
    pub height: std::option::Option<f64>,
    /// <p>The width of the truck.</p>
    /// <ul>
    /// <li>
    /// <p>For example, <code>4.5</code>.</p>
    /// </li>
    /// </ul>
    pub width: std::option::Option<f64>,
    /// <p> Specifies the unit of measurement for the truck dimensions.</p>
    /// <p>Default Value: <code>Meters</code>
    /// </p>
    pub unit: std::option::Option<crate::model::DimensionUnit>,
}
impl std::fmt::Debug for TruckDimensions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TruckDimensions");
        formatter.field("length", &self.length);
        formatter.field("height", &self.height);
        formatter.field("width", &self.width);
        formatter.field("unit", &self.unit);
        formatter.finish()
    }
}
/// See [`TruckDimensions`](crate::model::TruckDimensions)
pub mod truck_dimensions {
    /// A builder for [`TruckDimensions`](crate::model::TruckDimensions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) length: std::option::Option<f64>,
        pub(crate) height: std::option::Option<f64>,
        pub(crate) width: std::option::Option<f64>,
        pub(crate) unit: std::option::Option<crate::model::DimensionUnit>,
    }
    impl Builder {
        /// <p>The length of the truck.</p>
        /// <ul>
        /// <li>
        /// <p>For example, <code>15.5</code>.</p>
        /// </li>
        /// </ul>
        pub fn length(mut self, input: f64) -> Self {
            self.length = Some(input);
            self
        }
        pub fn set_length(mut self, input: std::option::Option<f64>) -> Self {
            self.length = input;
            self
        }
        /// <p>The height of the truck.</p>
        /// <ul>
        /// <li>
        /// <p>For example, <code>4.5</code>.</p>
        /// </li>
        /// </ul>
        pub fn height(mut self, input: f64) -> Self {
            self.height = Some(input);
            self
        }
        pub fn set_height(mut self, input: std::option::Option<f64>) -> Self {
            self.height = input;
            self
        }
        /// <p>The width of the truck.</p>
        /// <ul>
        /// <li>
        /// <p>For example, <code>4.5</code>.</p>
        /// </li>
        /// </ul>
        pub fn width(mut self, input: f64) -> Self {
            self.width = Some(input);
            self
        }
        pub fn set_width(mut self, input: std::option::Option<f64>) -> Self {
            self.width = input;
            self
        }
        /// <p> Specifies the unit of measurement for the truck dimensions.</p>
        /// <p>Default Value: <code>Meters</code>
        /// </p>
        pub fn unit(mut self, input: crate::model::DimensionUnit) -> Self {
            self.unit = Some(input);
            self
        }
        pub fn set_unit(mut self, input: std::option::Option<crate::model::DimensionUnit>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`TruckDimensions`](crate::model::TruckDimensions)
        pub fn build(self) -> crate::model::TruckDimensions {
            crate::model::TruckDimensions {
                length: self.length,
                height: self.height,
                width: self.width,
                unit: self.unit,
            }
        }
    }
}
impl TruckDimensions {
    /// Creates a new builder-style object to manufacture [`TruckDimensions`](crate::model::TruckDimensions)
    pub fn builder() -> crate::model::truck_dimensions::Builder {
        crate::model::truck_dimensions::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub struct DimensionUnit(String);
impl DimensionUnit {
    pub fn as_str(&self) -> &str {
        &self.0
    }
    pub fn values() -> &'static [&'static str] {
        &["Feet", "Meters"]
    }
}
impl<T> std::convert::From<T> for DimensionUnit
where
    T: std::convert::AsRef<str>,
{
    fn from(s: T) -> Self {
        DimensionUnit(s.as_ref().to_owned())
    }
}

/// <p>Contains details about additional route preferences for requests that specify
/// <code>TravelMode</code> as <code>Car</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CalculateRouteCarModeOptions {
    /// <p>Avoids ferries when calculating routes.</p>
    /// <p>Default Value: <code>false</code>
    /// </p>
    /// <p>Valid Values: <code>false</code> | <code>true</code>
    /// </p>
    pub avoid_ferries: std::option::Option<bool>,
    /// <p>Avoids tolls when calculating routes.</p>
    /// <p>Default Value: <code>false</code>
    /// </p>
    /// <p>Valid Values: <code>false</code> | <code>true</code>
    /// </p>
    pub avoid_tolls: std::option::Option<bool>,
}
impl std::fmt::Debug for CalculateRouteCarModeOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CalculateRouteCarModeOptions");
        formatter.field("avoid_ferries", &self.avoid_ferries);
        formatter.field("avoid_tolls", &self.avoid_tolls);
        formatter.finish()
    }
}
/// See [`CalculateRouteCarModeOptions`](crate::model::CalculateRouteCarModeOptions)
pub mod calculate_route_car_mode_options {
    /// A builder for [`CalculateRouteCarModeOptions`](crate::model::CalculateRouteCarModeOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) avoid_ferries: std::option::Option<bool>,
        pub(crate) avoid_tolls: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Avoids ferries when calculating routes.</p>
        /// <p>Default Value: <code>false</code>
        /// </p>
        /// <p>Valid Values: <code>false</code> | <code>true</code>
        /// </p>
        pub fn avoid_ferries(mut self, input: bool) -> Self {
            self.avoid_ferries = Some(input);
            self
        }
        pub fn set_avoid_ferries(mut self, input: std::option::Option<bool>) -> Self {
            self.avoid_ferries = input;
            self
        }
        /// <p>Avoids tolls when calculating routes.</p>
        /// <p>Default Value: <code>false</code>
        /// </p>
        /// <p>Valid Values: <code>false</code> | <code>true</code>
        /// </p>
        pub fn avoid_tolls(mut self, input: bool) -> Self {
            self.avoid_tolls = Some(input);
            self
        }
        pub fn set_avoid_tolls(mut self, input: std::option::Option<bool>) -> Self {
            self.avoid_tolls = input;
            self
        }
        /// Consumes the builder and constructs a [`CalculateRouteCarModeOptions`](crate::model::CalculateRouteCarModeOptions)
        pub fn build(self) -> crate::model::CalculateRouteCarModeOptions {
            crate::model::CalculateRouteCarModeOptions {
                avoid_ferries: self.avoid_ferries,
                avoid_tolls: self.avoid_tolls,
            }
        }
    }
}
impl CalculateRouteCarModeOptions {
    /// Creates a new builder-style object to manufacture [`CalculateRouteCarModeOptions`](crate::model::CalculateRouteCarModeOptions)
    pub fn builder() -> crate::model::calculate_route_car_mode_options::Builder {
        crate::model::calculate_route_car_mode_options::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub struct TravelMode(String);
impl TravelMode {
    pub fn as_str(&self) -> &str {
        &self.0
    }
    pub fn values() -> &'static [&'static str] {
        &["Car", "Truck", "Walking"]
    }
}
impl<T> std::convert::From<T> for TravelMode
where
    T: std::convert::AsRef<str>,
{
    fn from(s: T) -> Self {
        TravelMode(s.as_ref().to_owned())
    }
}

/// <p>A route calculator resource listed in your AWS account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRouteCalculatorsResponseEntry {
    /// <p>The name of the route calculator resource.</p>
    pub calculator_name: std::option::Option<std::string::String>,
    /// <p>The optional description of the route calculator resource.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The data provider of traffic and road network data. Indicates one of the available
    /// providers:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Esri</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Here</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>For more information about data providers, see <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Amazon Location Service data providers</a>.</p>
    pub data_source: std::option::Option<std::string::String>,
    /// <p>The pricing plan for the specified route calculator resource.</p>
    /// <p>For additional details and restrictions on each pricing plan option, see <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing</a>.</p>
    pub pricing_plan: std::option::Option<crate::model::PricingPlan>,
    /// <p>The timestamp when the route calculator resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
    /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. </p>
    /// <ul>
    /// <li>
    /// <p>For example, <code>2020–07-2T12:15:20.000Z+01:00</code>
    /// </p>
    /// </li>
    /// </ul>
    pub create_time: std::option::Option<smithy_types::Instant>,
    /// <p>The timestamp when the route calculator resource was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
    /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. </p>
    /// <ul>
    /// <li>
    /// <p>For example, <code>2020–07-2T12:15:20.000Z+01:00</code>
    /// </p>
    /// </li>
    /// </ul>
    pub update_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ListRouteCalculatorsResponseEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListRouteCalculatorsResponseEntry");
        formatter.field("calculator_name", &self.calculator_name);
        formatter.field("description", &self.description);
        formatter.field("data_source", &self.data_source);
        formatter.field("pricing_plan", &self.pricing_plan);
        formatter.field("create_time", &self.create_time);
        formatter.field("update_time", &self.update_time);
        formatter.finish()
    }
}
/// See [`ListRouteCalculatorsResponseEntry`](crate::model::ListRouteCalculatorsResponseEntry)
pub mod list_route_calculators_response_entry {
    /// A builder for [`ListRouteCalculatorsResponseEntry`](crate::model::ListRouteCalculatorsResponseEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) calculator_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) data_source: std::option::Option<std::string::String>,
        pub(crate) pricing_plan: std::option::Option<crate::model::PricingPlan>,
        pub(crate) create_time: std::option::Option<smithy_types::Instant>,
        pub(crate) update_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the route calculator resource.</p>
        pub fn calculator_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.calculator_name = Some(input.into());
            self
        }
        pub fn set_calculator_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.calculator_name = input;
            self
        }
        /// <p>The optional description of the route calculator resource.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The data provider of traffic and road network data. Indicates one of the available
        /// providers:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Esri</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Here</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For more information about data providers, see <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Amazon Location Service data providers</a>.</p>
        pub fn data_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_source = Some(input.into());
            self
        }
        pub fn set_data_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_source = input;
            self
        }
        /// <p>The pricing plan for the specified route calculator resource.</p>
        /// <p>For additional details and restrictions on each pricing plan option, see <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing</a>.</p>
        pub fn pricing_plan(mut self, input: crate::model::PricingPlan) -> Self {
            self.pricing_plan = Some(input);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.pricing_plan = input;
            self
        }
        /// <p>The timestamp when the route calculator resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. </p>
        /// <ul>
        /// <li>
        /// <p>For example, <code>2020–07-2T12:15:20.000Z+01:00</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn create_time(mut self, input: smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        pub fn set_create_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The timestamp when the route calculator resource was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. </p>
        /// <ul>
        /// <li>
        /// <p>For example, <code>2020–07-2T12:15:20.000Z+01:00</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn update_time(mut self, input: smithy_types::Instant) -> Self {
            self.update_time = Some(input);
            self
        }
        pub fn set_update_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRouteCalculatorsResponseEntry`](crate::model::ListRouteCalculatorsResponseEntry)
        pub fn build(self) -> crate::model::ListRouteCalculatorsResponseEntry {
            crate::model::ListRouteCalculatorsResponseEntry {
                calculator_name: self.calculator_name,
                description: self.description,
                data_source: self.data_source,
                pricing_plan: self.pricing_plan,
                create_time: self.create_time,
                update_time: self.update_time,
            }
        }
    }
}
impl ListRouteCalculatorsResponseEntry {
    /// Creates a new builder-style object to manufacture [`ListRouteCalculatorsResponseEntry`](crate::model::ListRouteCalculatorsResponseEntry)
    pub fn builder() -> crate::model::list_route_calculators_response_entry::Builder {
        crate::model::list_route_calculators_response_entry::Builder::default()
    }
}

/// <p>Contains relevant Places returned by calling
/// <code>SearchPlaceIndexForText</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchForTextResult {
    /// <p>Contains details about the relevant point of interest.</p>
    pub place: std::option::Option<crate::model::Place>,
}
impl std::fmt::Debug for SearchForTextResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SearchForTextResult");
        formatter.field("place", &self.place);
        formatter.finish()
    }
}
/// See [`SearchForTextResult`](crate::model::SearchForTextResult)
pub mod search_for_text_result {
    /// A builder for [`SearchForTextResult`](crate::model::SearchForTextResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) place: std::option::Option<crate::model::Place>,
    }
    impl Builder {
        /// <p>Contains details about the relevant point of interest.</p>
        pub fn place(mut self, input: crate::model::Place) -> Self {
            self.place = Some(input);
            self
        }
        pub fn set_place(mut self, input: std::option::Option<crate::model::Place>) -> Self {
            self.place = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchForTextResult`](crate::model::SearchForTextResult)
        pub fn build(self) -> crate::model::SearchForTextResult {
            crate::model::SearchForTextResult { place: self.place }
        }
    }
}
impl SearchForTextResult {
    /// Creates a new builder-style object to manufacture [`SearchForTextResult`](crate::model::SearchForTextResult)
    pub fn builder() -> crate::model::search_for_text_result::Builder {
        crate::model::search_for_text_result::Builder::default()
    }
}

/// <p>Contains details about addresses or points of interest that match the search
/// criteria.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Place {
    /// <p>The full name and address of the point of interest such as a city,
    /// region, or country. For example, <code>123 Any Street, Any Town, USA</code>.</p>
    pub label: std::option::Option<std::string::String>,
    /// <p>Places uses a point geometry to specify a location or a Place.</p>
    pub geometry: std::option::Option<crate::model::PlaceGeometry>,
    /// <p>The numerical portion of an address, such as a building number. </p>
    pub address_number: std::option::Option<std::string::String>,
    /// <p>The name for a street or a road to identify a location. For example, <code>Main
    /// Street</code>.</p>
    pub street: std::option::Option<std::string::String>,
    /// <p>The name of a community district. For example, <code>Downtown</code>.</p>
    pub neighborhood: std::option::Option<std::string::String>,
    /// <p>A name for a local area, such as a city or town name. For example,
    /// <code>Toronto</code>.</p>
    pub municipality: std::option::Option<std::string::String>,
    /// <p>A country, or an area that's part of a larger region .  For example, <code>Metro
    /// Vancouver</code>.</p>
    pub sub_region: std::option::Option<std::string::String>,
    /// <p>A name for an area or geographical division, such as a province or state name. For
    /// example, <code>British Columbia</code>.</p>
    pub region: std::option::Option<std::string::String>,
    /// <p>A country/region specified using <a href="https://www.iso.org/iso-3166-country-codes.html">ISO 3166</a> 3-digit
    /// country/region code. For example, <code>CAN</code>.</p>
    pub country: std::option::Option<std::string::String>,
    /// <p>A group of numbers and letters in a country-specific format, which accompanies the
    /// address for the purpose of identifying a location. </p>
    pub postal_code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Place {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Place");
        formatter.field("label", &self.label);
        formatter.field("geometry", &self.geometry);
        formatter.field("address_number", &self.address_number);
        formatter.field("street", &self.street);
        formatter.field("neighborhood", &self.neighborhood);
        formatter.field("municipality", &self.municipality);
        formatter.field("sub_region", &self.sub_region);
        formatter.field("region", &self.region);
        formatter.field("country", &self.country);
        formatter.field("postal_code", &self.postal_code);
        formatter.finish()
    }
}
/// See [`Place`](crate::model::Place)
pub mod place {
    /// A builder for [`Place`](crate::model::Place)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) label: std::option::Option<std::string::String>,
        pub(crate) geometry: std::option::Option<crate::model::PlaceGeometry>,
        pub(crate) address_number: std::option::Option<std::string::String>,
        pub(crate) street: std::option::Option<std::string::String>,
        pub(crate) neighborhood: std::option::Option<std::string::String>,
        pub(crate) municipality: std::option::Option<std::string::String>,
        pub(crate) sub_region: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) country: std::option::Option<std::string::String>,
        pub(crate) postal_code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The full name and address of the point of interest such as a city,
        /// region, or country. For example, <code>123 Any Street, Any Town, USA</code>.</p>
        pub fn label(mut self, input: impl Into<std::string::String>) -> Self {
            self.label = Some(input.into());
            self
        }
        pub fn set_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.label = input;
            self
        }
        /// <p>Places uses a point geometry to specify a location or a Place.</p>
        pub fn geometry(mut self, input: crate::model::PlaceGeometry) -> Self {
            self.geometry = Some(input);
            self
        }
        pub fn set_geometry(
            mut self,
            input: std::option::Option<crate::model::PlaceGeometry>,
        ) -> Self {
            self.geometry = input;
            self
        }
        /// <p>The numerical portion of an address, such as a building number. </p>
        pub fn address_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.address_number = Some(input.into());
            self
        }
        pub fn set_address_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.address_number = input;
            self
        }
        /// <p>The name for a street or a road to identify a location. For example, <code>Main
        /// Street</code>.</p>
        pub fn street(mut self, input: impl Into<std::string::String>) -> Self {
            self.street = Some(input.into());
            self
        }
        pub fn set_street(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.street = input;
            self
        }
        /// <p>The name of a community district. For example, <code>Downtown</code>.</p>
        pub fn neighborhood(mut self, input: impl Into<std::string::String>) -> Self {
            self.neighborhood = Some(input.into());
            self
        }
        pub fn set_neighborhood(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.neighborhood = input;
            self
        }
        /// <p>A name for a local area, such as a city or town name. For example,
        /// <code>Toronto</code>.</p>
        pub fn municipality(mut self, input: impl Into<std::string::String>) -> Self {
            self.municipality = Some(input.into());
            self
        }
        pub fn set_municipality(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.municipality = input;
            self
        }
        /// <p>A country, or an area that's part of a larger region .  For example, <code>Metro
        /// Vancouver</code>.</p>
        pub fn sub_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.sub_region = Some(input.into());
            self
        }
        pub fn set_sub_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sub_region = input;
            self
        }
        /// <p>A name for an area or geographical division, such as a province or state name. For
        /// example, <code>British Columbia</code>.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// <p>A country/region specified using <a href="https://www.iso.org/iso-3166-country-codes.html">ISO 3166</a> 3-digit
        /// country/region code. For example, <code>CAN</code>.</p>
        pub fn country(mut self, input: impl Into<std::string::String>) -> Self {
            self.country = Some(input.into());
            self
        }
        pub fn set_country(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.country = input;
            self
        }
        /// <p>A group of numbers and letters in a country-specific format, which accompanies the
        /// address for the purpose of identifying a location. </p>
        pub fn postal_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.postal_code = Some(input.into());
            self
        }
        pub fn set_postal_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.postal_code = input;
            self
        }
        /// Consumes the builder and constructs a [`Place`](crate::model::Place)
        pub fn build(self) -> crate::model::Place {
            crate::model::Place {
                label: self.label,
                geometry: self.geometry,
                address_number: self.address_number,
                street: self.street,
                neighborhood: self.neighborhood,
                municipality: self.municipality,
                sub_region: self.sub_region,
                region: self.region,
                country: self.country,
                postal_code: self.postal_code,
            }
        }
    }
}
impl Place {
    /// Creates a new builder-style object to manufacture [`Place`](crate::model::Place)
    pub fn builder() -> crate::model::place::Builder {
        crate::model::place::Builder::default()
    }
}

/// <p>Places uses a point geometry to specify a location or a Place.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PlaceGeometry {
    /// <p>A single point geometry specifies a location for a Place using <a href="https://gisgeography.com/wgs84-world-geodetic-system/">WGS 84</a>
    /// coordinates:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <i>x</i> — Specifies the x coordinate or longitude. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>y</i> — Specifies the y coordinate or latitude. </p>
    /// </li>
    /// </ul>
    pub point: std::option::Option<std::vec::Vec<f64>>,
}
impl std::fmt::Debug for PlaceGeometry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PlaceGeometry");
        formatter.field("point", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`PlaceGeometry`](crate::model::PlaceGeometry)
pub mod place_geometry {
    /// A builder for [`PlaceGeometry`](crate::model::PlaceGeometry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) point: std::option::Option<std::vec::Vec<f64>>,
    }
    impl Builder {
        pub fn point(mut self, input: impl Into<f64>) -> Self {
            let mut v = self.point.unwrap_or_default();
            v.push(input.into());
            self.point = Some(v);
            self
        }
        pub fn set_point(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.point = input;
            self
        }
        /// Consumes the builder and constructs a [`PlaceGeometry`](crate::model::PlaceGeometry)
        pub fn build(self) -> crate::model::PlaceGeometry {
            crate::model::PlaceGeometry { point: self.point }
        }
    }
}
impl PlaceGeometry {
    /// Creates a new builder-style object to manufacture [`PlaceGeometry`](crate::model::PlaceGeometry)
    pub fn builder() -> crate::model::place_geometry::Builder {
        crate::model::place_geometry::Builder::default()
    }
}

/// <p>A summary of the geocoding request sent using <code>SearchPlaceIndexForText</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchPlaceIndexForTextSummary {
    /// <p>The address, name, city or region to be used in the geocoding request. In free-form text
    /// format. For example, <code>Vancouver</code>.</p>
    pub text: std::option::Option<std::string::String>,
    /// <p>Contains the coordinates for the bias position entered in the geocoding request.</p>
    pub bias_position: std::option::Option<std::vec::Vec<f64>>,
    /// <p>Contains the coordinates for the optional bounding box coordinated entered in the
    /// geocoding request.</p>
    pub filter_b_box: std::option::Option<std::vec::Vec<f64>>,
    /// <p>Contains the country filter entered in the geocoding request.</p>
    pub filter_countries: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Contains the maximum number of results indicated for the request.</p>
    pub max_results: i32,
    /// <p>A bounding box that contains the search results within the specified area indicated by
    /// <code>FilterBBox</code>. A subset of bounding box specified using
    /// <code>FilterBBox</code>.</p>
    pub result_b_box: std::option::Option<std::vec::Vec<f64>>,
    /// <p>The data provider of geospatial data. Indicates one of the available providers:</p>
    /// <ul>
    /// <li>
    /// <p>Esri</p>
    /// </li>
    /// <li>
    /// <p>HERE</p>
    /// </li>
    /// </ul>
    /// <p>For additional details on data providers, see the <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Amazon Location Service data providers page</a>.</p>
    pub data_source: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SearchPlaceIndexForTextSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SearchPlaceIndexForTextSummary");
        formatter.field("text", &"*** Sensitive Data Redacted ***");
        formatter.field("bias_position", &"*** Sensitive Data Redacted ***");
        formatter.field("filter_b_box", &"*** Sensitive Data Redacted ***");
        formatter.field("filter_countries", &self.filter_countries);
        formatter.field("max_results", &self.max_results);
        formatter.field("result_b_box", &"*** Sensitive Data Redacted ***");
        formatter.field("data_source", &self.data_source);
        formatter.finish()
    }
}
/// See [`SearchPlaceIndexForTextSummary`](crate::model::SearchPlaceIndexForTextSummary)
pub mod search_place_index_for_text_summary {
    /// A builder for [`SearchPlaceIndexForTextSummary`](crate::model::SearchPlaceIndexForTextSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) text: std::option::Option<std::string::String>,
        pub(crate) bias_position: std::option::Option<std::vec::Vec<f64>>,
        pub(crate) filter_b_box: std::option::Option<std::vec::Vec<f64>>,
        pub(crate) filter_countries: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) result_b_box: std::option::Option<std::vec::Vec<f64>>,
        pub(crate) data_source: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The address, name, city or region to be used in the geocoding request. In free-form text
        /// format. For example, <code>Vancouver</code>.</p>
        pub fn text(mut self, input: impl Into<std::string::String>) -> Self {
            self.text = Some(input.into());
            self
        }
        pub fn set_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text = input;
            self
        }
        pub fn bias_position(mut self, input: impl Into<f64>) -> Self {
            let mut v = self.bias_position.unwrap_or_default();
            v.push(input.into());
            self.bias_position = Some(v);
            self
        }
        pub fn set_bias_position(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.bias_position = input;
            self
        }
        pub fn filter_b_box(mut self, input: impl Into<f64>) -> Self {
            let mut v = self.filter_b_box.unwrap_or_default();
            v.push(input.into());
            self.filter_b_box = Some(v);
            self
        }
        pub fn set_filter_b_box(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.filter_b_box = input;
            self
        }
        pub fn filter_countries(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.filter_countries.unwrap_or_default();
            v.push(input.into());
            self.filter_countries = Some(v);
            self
        }
        pub fn set_filter_countries(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.filter_countries = input;
            self
        }
        /// <p>Contains the maximum number of results indicated for the request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        pub fn result_b_box(mut self, input: impl Into<f64>) -> Self {
            let mut v = self.result_b_box.unwrap_or_default();
            v.push(input.into());
            self.result_b_box = Some(v);
            self
        }
        pub fn set_result_b_box(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.result_b_box = input;
            self
        }
        /// <p>The data provider of geospatial data. Indicates one of the available providers:</p>
        /// <ul>
        /// <li>
        /// <p>Esri</p>
        /// </li>
        /// <li>
        /// <p>HERE</p>
        /// </li>
        /// </ul>
        /// <p>For additional details on data providers, see the <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Amazon Location Service data providers page</a>.</p>
        pub fn data_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_source = Some(input.into());
            self
        }
        pub fn set_data_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_source = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchPlaceIndexForTextSummary`](crate::model::SearchPlaceIndexForTextSummary)
        pub fn build(self) -> crate::model::SearchPlaceIndexForTextSummary {
            crate::model::SearchPlaceIndexForTextSummary {
                text: self.text,
                bias_position: self.bias_position,
                filter_b_box: self.filter_b_box,
                filter_countries: self.filter_countries,
                max_results: self.max_results.unwrap_or_default(),
                result_b_box: self.result_b_box,
                data_source: self.data_source,
            }
        }
    }
}
impl SearchPlaceIndexForTextSummary {
    /// Creates a new builder-style object to manufacture [`SearchPlaceIndexForTextSummary`](crate::model::SearchPlaceIndexForTextSummary)
    pub fn builder() -> crate::model::search_place_index_for_text_summary::Builder {
        crate::model::search_place_index_for_text_summary::Builder::default()
    }
}

/// <p>Specifies a single point of interest, or Place as a result of a search query obtained
/// from a dataset configured in the place index resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchForPositionResult {
    /// <p>Contains details about the relevant point of interest.</p>
    pub place: std::option::Option<crate::model::Place>,
}
impl std::fmt::Debug for SearchForPositionResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SearchForPositionResult");
        formatter.field("place", &self.place);
        formatter.finish()
    }
}
/// See [`SearchForPositionResult`](crate::model::SearchForPositionResult)
pub mod search_for_position_result {
    /// A builder for [`SearchForPositionResult`](crate::model::SearchForPositionResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) place: std::option::Option<crate::model::Place>,
    }
    impl Builder {
        /// <p>Contains details about the relevant point of interest.</p>
        pub fn place(mut self, input: crate::model::Place) -> Self {
            self.place = Some(input);
            self
        }
        pub fn set_place(mut self, input: std::option::Option<crate::model::Place>) -> Self {
            self.place = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchForPositionResult`](crate::model::SearchForPositionResult)
        pub fn build(self) -> crate::model::SearchForPositionResult {
            crate::model::SearchForPositionResult { place: self.place }
        }
    }
}
impl SearchForPositionResult {
    /// Creates a new builder-style object to manufacture [`SearchForPositionResult`](crate::model::SearchForPositionResult)
    pub fn builder() -> crate::model::search_for_position_result::Builder {
        crate::model::search_for_position_result::Builder::default()
    }
}

/// <p>A summary of the reverse geocoding request sent using <code>SearchPlaceIndexForPosition</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchPlaceIndexForPositionSummary {
    /// <p>The position given in the reverse geocoding request.</p>
    pub position: std::option::Option<std::vec::Vec<f64>>,
    /// <p>An optional parameter. The maximum number of results returned per request. </p>
    /// <p>Default value: <code>50</code>
    /// </p>
    pub max_results: i32,
    /// <p>The data provider of geospatial data. Indicates one of the available providers:</p>
    /// <ul>
    /// <li>
    /// <p>Esri</p>
    /// </li>
    /// <li>
    /// <p>HERE</p>
    /// </li>
    /// </ul>
    /// <p>For additional details on data providers, see the <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Amazon Location Service data providers page</a>.</p>
    pub data_source: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SearchPlaceIndexForPositionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SearchPlaceIndexForPositionSummary");
        formatter.field("position", &"*** Sensitive Data Redacted ***");
        formatter.field("max_results", &self.max_results);
        formatter.field("data_source", &self.data_source);
        formatter.finish()
    }
}
/// See [`SearchPlaceIndexForPositionSummary`](crate::model::SearchPlaceIndexForPositionSummary)
pub mod search_place_index_for_position_summary {
    /// A builder for [`SearchPlaceIndexForPositionSummary`](crate::model::SearchPlaceIndexForPositionSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) position: std::option::Option<std::vec::Vec<f64>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) data_source: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn position(mut self, input: impl Into<f64>) -> Self {
            let mut v = self.position.unwrap_or_default();
            v.push(input.into());
            self.position = Some(v);
            self
        }
        pub fn set_position(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.position = input;
            self
        }
        /// <p>An optional parameter. The maximum number of results returned per request. </p>
        /// <p>Default value: <code>50</code>
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The data provider of geospatial data. Indicates one of the available providers:</p>
        /// <ul>
        /// <li>
        /// <p>Esri</p>
        /// </li>
        /// <li>
        /// <p>HERE</p>
        /// </li>
        /// </ul>
        /// <p>For additional details on data providers, see the <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Amazon Location Service data providers page</a>.</p>
        pub fn data_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_source = Some(input.into());
            self
        }
        pub fn set_data_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_source = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchPlaceIndexForPositionSummary`](crate::model::SearchPlaceIndexForPositionSummary)
        pub fn build(self) -> crate::model::SearchPlaceIndexForPositionSummary {
            crate::model::SearchPlaceIndexForPositionSummary {
                position: self.position,
                max_results: self.max_results.unwrap_or_default(),
                data_source: self.data_source,
            }
        }
    }
}
impl SearchPlaceIndexForPositionSummary {
    /// Creates a new builder-style object to manufacture [`SearchPlaceIndexForPositionSummary`](crate::model::SearchPlaceIndexForPositionSummary)
    pub fn builder() -> crate::model::search_place_index_for_position_summary::Builder {
        crate::model::search_place_index_for_position_summary::Builder::default()
    }
}

/// <p>A place index resource listed in your AWS account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPlaceIndexesResponseEntry {
    /// <p>The name of the place index resource.</p>
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The optional description for the place index resource.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The data provider of geospatial data. Indicates one of the available providers:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Esri</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Here</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>For additional details on data providers, see the <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Amazon Location Service data providers page</a>.</p>
    pub data_source: std::option::Option<std::string::String>,
    /// <p>The pricing plan for the specified place index resource.</p>
    /// <p>For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
    /// page</a>.</p>
    pub pricing_plan: std::option::Option<crate::model::PricingPlan>,
    /// <p>The timestamp for when the place index resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a> format:
    /// <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. </p>
    pub create_time: std::option::Option<smithy_types::Instant>,
    /// <p>The timestamp for when the place index resource was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a> format:
    /// <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. </p>
    pub update_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ListPlaceIndexesResponseEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPlaceIndexesResponseEntry");
        formatter.field("index_name", &self.index_name);
        formatter.field("description", &self.description);
        formatter.field("data_source", &self.data_source);
        formatter.field("pricing_plan", &self.pricing_plan);
        formatter.field("create_time", &self.create_time);
        formatter.field("update_time", &self.update_time);
        formatter.finish()
    }
}
/// See [`ListPlaceIndexesResponseEntry`](crate::model::ListPlaceIndexesResponseEntry)
pub mod list_place_indexes_response_entry {
    /// A builder for [`ListPlaceIndexesResponseEntry`](crate::model::ListPlaceIndexesResponseEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) data_source: std::option::Option<std::string::String>,
        pub(crate) pricing_plan: std::option::Option<crate::model::PricingPlan>,
        pub(crate) create_time: std::option::Option<smithy_types::Instant>,
        pub(crate) update_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the place index resource.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.index_name = Some(input.into());
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.index_name = input;
            self
        }
        /// <p>The optional description for the place index resource.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The data provider of geospatial data. Indicates one of the available providers:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Esri</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Here</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For additional details on data providers, see the <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Amazon Location Service data providers page</a>.</p>
        pub fn data_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_source = Some(input.into());
            self
        }
        pub fn set_data_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_source = input;
            self
        }
        /// <p>The pricing plan for the specified place index resource.</p>
        /// <p>For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
        /// page</a>.</p>
        pub fn pricing_plan(mut self, input: crate::model::PricingPlan) -> Self {
            self.pricing_plan = Some(input);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.pricing_plan = input;
            self
        }
        /// <p>The timestamp for when the place index resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a> format:
        /// <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. </p>
        pub fn create_time(mut self, input: smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        pub fn set_create_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The timestamp for when the place index resource was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a> format:
        /// <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. </p>
        pub fn update_time(mut self, input: smithy_types::Instant) -> Self {
            self.update_time = Some(input);
            self
        }
        pub fn set_update_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPlaceIndexesResponseEntry`](crate::model::ListPlaceIndexesResponseEntry)
        pub fn build(self) -> crate::model::ListPlaceIndexesResponseEntry {
            crate::model::ListPlaceIndexesResponseEntry {
                index_name: self.index_name,
                description: self.description,
                data_source: self.data_source,
                pricing_plan: self.pricing_plan,
                create_time: self.create_time,
                update_time: self.update_time,
            }
        }
    }
}
impl ListPlaceIndexesResponseEntry {
    /// Creates a new builder-style object to manufacture [`ListPlaceIndexesResponseEntry`](crate::model::ListPlaceIndexesResponseEntry)
    pub fn builder() -> crate::model::list_place_indexes_response_entry::Builder {
        crate::model::list_place_indexes_response_entry::Builder::default()
    }
}

/// <p>Specifies the data storage option chosen for requesting Places.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataSourceConfiguration {
    /// <p>Specifies how the results of an operation will be stored by the caller. </p>
    /// <p>Valid values include:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>SingleUse</code> specifies that the results won't be stored. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Storage</code> specifies that the result can be cached or stored in a database.</p>
    /// <important>
    /// <p>Place index resources using HERE as a data provider can't be configured to
    /// store results for locations in Japan when choosing <code>Storage</code> for the
    /// <code>IntendedUse</code> parameter.</p>
    /// </important>
    /// </li>
    /// </ul>
    /// <p>Default value:  <code>SingleUse</code>
    /// </p>
    pub intended_use: std::option::Option<crate::model::IntendedUse>,
}
impl std::fmt::Debug for DataSourceConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataSourceConfiguration");
        formatter.field("intended_use", &self.intended_use);
        formatter.finish()
    }
}
/// See [`DataSourceConfiguration`](crate::model::DataSourceConfiguration)
pub mod data_source_configuration {
    /// A builder for [`DataSourceConfiguration`](crate::model::DataSourceConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) intended_use: std::option::Option<crate::model::IntendedUse>,
    }
    impl Builder {
        /// <p>Specifies how the results of an operation will be stored by the caller. </p>
        /// <p>Valid values include:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SingleUse</code> specifies that the results won't be stored. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Storage</code> specifies that the result can be cached or stored in a database.</p>
        /// <important>
        /// <p>Place index resources using HERE as a data provider can't be configured to
        /// store results for locations in Japan when choosing <code>Storage</code> for the
        /// <code>IntendedUse</code> parameter.</p>
        /// </important>
        /// </li>
        /// </ul>
        /// <p>Default value:  <code>SingleUse</code>
        /// </p>
        pub fn intended_use(mut self, input: crate::model::IntendedUse) -> Self {
            self.intended_use = Some(input);
            self
        }
        pub fn set_intended_use(
            mut self,
            input: std::option::Option<crate::model::IntendedUse>,
        ) -> Self {
            self.intended_use = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSourceConfiguration`](crate::model::DataSourceConfiguration)
        pub fn build(self) -> crate::model::DataSourceConfiguration {
            crate::model::DataSourceConfiguration {
                intended_use: self.intended_use,
            }
        }
    }
}
impl DataSourceConfiguration {
    /// Creates a new builder-style object to manufacture [`DataSourceConfiguration`](crate::model::DataSourceConfiguration)
    pub fn builder() -> crate::model::data_source_configuration::Builder {
        crate::model::data_source_configuration::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub struct IntendedUse(String);
impl IntendedUse {
    pub fn as_str(&self) -> &str {
        &self.0
    }
    pub fn values() -> &'static [&'static str] {
        &["SingleUse", "Storage"]
    }
}
impl<T> std::convert::From<T> for IntendedUse
where
    T: std::convert::AsRef<str>,
{
    fn from(s: T) -> Self {
        IntendedUse(s.as_ref().to_owned())
    }
}

/// <p>Contains details of an existing map resource in your AWS account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMapsResponseEntry {
    /// <p>The name of the associated map resource.</p>
    pub map_name: std::option::Option<std::string::String>,
    /// <p>The description for the map resource.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Specifies the data provider for the associated map tiles.</p>
    pub data_source: std::option::Option<std::string::String>,
    /// <p>The pricing plan for the specified map resource.</p>
    /// <p>For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
    /// page</a>.</p>
    pub pricing_plan: std::option::Option<crate::model::PricingPlan>,
    /// <p>The timestamp for when the map resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
    /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>.</p>
    pub create_time: std::option::Option<smithy_types::Instant>,
    /// <p>The timestamp for when the map resource was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
    /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>.</p>
    pub update_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ListMapsResponseEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMapsResponseEntry");
        formatter.field("map_name", &self.map_name);
        formatter.field("description", &self.description);
        formatter.field("data_source", &self.data_source);
        formatter.field("pricing_plan", &self.pricing_plan);
        formatter.field("create_time", &self.create_time);
        formatter.field("update_time", &self.update_time);
        formatter.finish()
    }
}
/// See [`ListMapsResponseEntry`](crate::model::ListMapsResponseEntry)
pub mod list_maps_response_entry {
    /// A builder for [`ListMapsResponseEntry`](crate::model::ListMapsResponseEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) map_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) data_source: std::option::Option<std::string::String>,
        pub(crate) pricing_plan: std::option::Option<crate::model::PricingPlan>,
        pub(crate) create_time: std::option::Option<smithy_types::Instant>,
        pub(crate) update_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the associated map resource.</p>
        pub fn map_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.map_name = Some(input.into());
            self
        }
        pub fn set_map_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.map_name = input;
            self
        }
        /// <p>The description for the map resource.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Specifies the data provider for the associated map tiles.</p>
        pub fn data_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_source = Some(input.into());
            self
        }
        pub fn set_data_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_source = input;
            self
        }
        /// <p>The pricing plan for the specified map resource.</p>
        /// <p>For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
        /// page</a>.</p>
        pub fn pricing_plan(mut self, input: crate::model::PricingPlan) -> Self {
            self.pricing_plan = Some(input);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.pricing_plan = input;
            self
        }
        /// <p>The timestamp for when the map resource was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>.</p>
        pub fn create_time(mut self, input: smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        pub fn set_create_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The timestamp for when the map resource was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>.</p>
        pub fn update_time(mut self, input: smithy_types::Instant) -> Self {
            self.update_time = Some(input);
            self
        }
        pub fn set_update_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ListMapsResponseEntry`](crate::model::ListMapsResponseEntry)
        pub fn build(self) -> crate::model::ListMapsResponseEntry {
            crate::model::ListMapsResponseEntry {
                map_name: self.map_name,
                description: self.description,
                data_source: self.data_source,
                pricing_plan: self.pricing_plan,
                create_time: self.create_time,
                update_time: self.update_time,
            }
        }
    }
}
impl ListMapsResponseEntry {
    /// Creates a new builder-style object to manufacture [`ListMapsResponseEntry`](crate::model::ListMapsResponseEntry)
    pub fn builder() -> crate::model::list_maps_response_entry::Builder {
        crate::model::list_maps_response_entry::Builder::default()
    }
}

/// <p>Specifies the map tile style selected from an available provider.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MapConfiguration {
    /// <p>Specifies the map style selected from an available data provider.</p>
    /// <p>Valid styles: <code>RasterEsriImagery</code>, <code>VectorEsriStreets</code>,
    /// <code>VectorEsriTopographic</code>, <code>VectorEsriNavigation</code>,
    /// <code>VectorEsriDarkGrayCanvas</code>, <code>VectorEsriLightGrayCanvas</code>,
    /// <code>VectorHereBerlin</code>.</p>
    /// <note>
    /// <p>When using HERE as your data provider, and selecting the Style
    /// <code>VectorHereBerlin</code>, you may not use HERE Maps for Asset Management.
    /// See the <a href="https://aws.amazon.com/service-terms/">AWS Service Terms</a> for Amazon Location Service.</p>
    /// </note>
    pub style: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MapConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MapConfiguration");
        formatter.field("style", &self.style);
        formatter.finish()
    }
}
/// See [`MapConfiguration`](crate::model::MapConfiguration)
pub mod map_configuration {
    /// A builder for [`MapConfiguration`](crate::model::MapConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) style: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the map style selected from an available data provider.</p>
        /// <p>Valid styles: <code>RasterEsriImagery</code>, <code>VectorEsriStreets</code>,
        /// <code>VectorEsriTopographic</code>, <code>VectorEsriNavigation</code>,
        /// <code>VectorEsriDarkGrayCanvas</code>, <code>VectorEsriLightGrayCanvas</code>,
        /// <code>VectorHereBerlin</code>.</p>
        /// <note>
        /// <p>When using HERE as your data provider, and selecting the Style
        /// <code>VectorHereBerlin</code>, you may not use HERE Maps for Asset Management.
        /// See the <a href="https://aws.amazon.com/service-terms/">AWS Service Terms</a> for Amazon Location Service.</p>
        /// </note>
        pub fn style(mut self, input: impl Into<std::string::String>) -> Self {
            self.style = Some(input.into());
            self
        }
        pub fn set_style(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.style = input;
            self
        }
        /// Consumes the builder and constructs a [`MapConfiguration`](crate::model::MapConfiguration)
        pub fn build(self) -> crate::model::MapConfiguration {
            crate::model::MapConfiguration { style: self.style }
        }
    }
}
impl MapConfiguration {
    /// Creates a new builder-style object to manufacture [`MapConfiguration`](crate::model::MapConfiguration)
    pub fn builder() -> crate::model::map_configuration::Builder {
        crate::model::map_configuration::Builder::default()
    }
}

/// <p>Contains the geofence geometry details.</p>
/// <note>
/// <p>Amazon Location doesn't currently support polygons with holes, multipolygons, polygons
/// that are wound clockwise, or that cross the antimeridian. </p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GeofenceGeometry {
    /// <p>An array of 1 or more linear rings. A linear ring is an array of 4 or more vertices,
    /// where the first and last vertex are the same to form a closed boundary. Each vertex is a
    /// 2-dimensional point of the form: <code>[longitude, latitude]</code>. </p>
    /// <p>The first linear ring is an outer ring, describing the polygon's boundary. Subsequent
    /// linear rings may be inner or outer rings to describe holes and islands. Outer rings must
    /// list their vertices in counter-clockwise order around the ring's center, where the left
    /// side is the polygon's exterior. Inner rings must list their vertices in clockwise order,
    /// where the left side is the polygon's interior.</p>
    pub polygon: std::option::Option<std::vec::Vec<std::vec::Vec<std::vec::Vec<f64>>>>,
}
impl std::fmt::Debug for GeofenceGeometry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GeofenceGeometry");
        formatter.field("polygon", &self.polygon);
        formatter.finish()
    }
}
/// See [`GeofenceGeometry`](crate::model::GeofenceGeometry)
pub mod geofence_geometry {
    /// A builder for [`GeofenceGeometry`](crate::model::GeofenceGeometry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) polygon: std::option::Option<std::vec::Vec<std::vec::Vec<std::vec::Vec<f64>>>>,
    }
    impl Builder {
        pub fn polygon(mut self, input: impl Into<std::vec::Vec<std::vec::Vec<f64>>>) -> Self {
            let mut v = self.polygon.unwrap_or_default();
            v.push(input.into());
            self.polygon = Some(v);
            self
        }
        pub fn set_polygon(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<std::vec::Vec<f64>>>>,
        ) -> Self {
            self.polygon = input;
            self
        }
        /// Consumes the builder and constructs a [`GeofenceGeometry`](crate::model::GeofenceGeometry)
        pub fn build(self) -> crate::model::GeofenceGeometry {
            crate::model::GeofenceGeometry {
                polygon: self.polygon,
            }
        }
    }
}
impl GeofenceGeometry {
    /// Creates a new builder-style object to manufacture [`GeofenceGeometry`](crate::model::GeofenceGeometry)
    pub fn builder() -> crate::model::geofence_geometry::Builder {
        crate::model::geofence_geometry::Builder::default()
    }
}

/// <p>Contains a list of geofences stored in a given geofence collection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListGeofenceResponseEntry {
    /// <p>The geofence identifier.</p>
    pub geofence_id: std::option::Option<std::string::String>,
    /// <p>Contains the geofence geometry details describing a polygon.</p>
    pub geometry: std::option::Option<crate::model::GeofenceGeometry>,
    /// <p>Identifies the state of the geofence. A geofence will hold one of the following
    /// states:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>ACTIVE</code> — The geofence has been indexed by the system. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PENDING</code> — The geofence is being processed by the system.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FAILED</code> — The geofence failed to be indexed by the system.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETED</code> — The geofence has been deleted from the system
    /// index.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETING</code> — The geofence is being deleted from the system
    /// index.</p>
    /// </li>
    /// </ul>
    pub status: std::option::Option<std::string::String>,
    /// <p>The timestamp for when the geofence was stored in a geofence collection in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
    /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>
    /// </p>
    pub create_time: std::option::Option<smithy_types::Instant>,
    /// <p>The timestamp for when the geofence was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
    /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>
    /// </p>
    pub update_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ListGeofenceResponseEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListGeofenceResponseEntry");
        formatter.field("geofence_id", &self.geofence_id);
        formatter.field("geometry", &self.geometry);
        formatter.field("status", &self.status);
        formatter.field("create_time", &self.create_time);
        formatter.field("update_time", &self.update_time);
        formatter.finish()
    }
}
/// See [`ListGeofenceResponseEntry`](crate::model::ListGeofenceResponseEntry)
pub mod list_geofence_response_entry {
    /// A builder for [`ListGeofenceResponseEntry`](crate::model::ListGeofenceResponseEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) geofence_id: std::option::Option<std::string::String>,
        pub(crate) geometry: std::option::Option<crate::model::GeofenceGeometry>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<smithy_types::Instant>,
        pub(crate) update_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The geofence identifier.</p>
        pub fn geofence_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.geofence_id = Some(input.into());
            self
        }
        pub fn set_geofence_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.geofence_id = input;
            self
        }
        /// <p>Contains the geofence geometry details describing a polygon.</p>
        pub fn geometry(mut self, input: crate::model::GeofenceGeometry) -> Self {
            self.geometry = Some(input);
            self
        }
        pub fn set_geometry(
            mut self,
            input: std::option::Option<crate::model::GeofenceGeometry>,
        ) -> Self {
            self.geometry = input;
            self
        }
        /// <p>Identifies the state of the geofence. A geofence will hold one of the following
        /// states:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ACTIVE</code> — The geofence has been indexed by the system. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PENDING</code> — The geofence is being processed by the system.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FAILED</code> — The geofence failed to be indexed by the system.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETED</code> — The geofence has been deleted from the system
        /// index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETING</code> — The geofence is being deleted from the system
        /// index.</p>
        /// </li>
        /// </ul>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The timestamp for when the geofence was stored in a geofence collection in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>
        /// </p>
        pub fn create_time(mut self, input: smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        pub fn set_create_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The timestamp for when the geofence was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>
        /// </p>
        pub fn update_time(mut self, input: smithy_types::Instant) -> Self {
            self.update_time = Some(input);
            self
        }
        pub fn set_update_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ListGeofenceResponseEntry`](crate::model::ListGeofenceResponseEntry)
        pub fn build(self) -> crate::model::ListGeofenceResponseEntry {
            crate::model::ListGeofenceResponseEntry {
                geofence_id: self.geofence_id,
                geometry: self.geometry,
                status: self.status,
                create_time: self.create_time,
                update_time: self.update_time,
            }
        }
    }
}
impl ListGeofenceResponseEntry {
    /// Creates a new builder-style object to manufacture [`ListGeofenceResponseEntry`](crate::model::ListGeofenceResponseEntry)
    pub fn builder() -> crate::model::list_geofence_response_entry::Builder {
        crate::model::list_geofence_response_entry::Builder::default()
    }
}

/// <p>Contains error details for each geofence that failed to be stored in a given geofence
/// collection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchPutGeofenceError {
    /// <p>The geofence associated with the error message.</p>
    pub geofence_id: std::option::Option<std::string::String>,
    /// <p>Contains details associated to the batch error.</p>
    pub error: std::option::Option<crate::model::BatchItemError>,
}
impl std::fmt::Debug for BatchPutGeofenceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchPutGeofenceError");
        formatter.field("geofence_id", &self.geofence_id);
        formatter.field("error", &self.error);
        formatter.finish()
    }
}
/// See [`BatchPutGeofenceError`](crate::model::BatchPutGeofenceError)
pub mod batch_put_geofence_error {
    /// A builder for [`BatchPutGeofenceError`](crate::model::BatchPutGeofenceError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) geofence_id: std::option::Option<std::string::String>,
        pub(crate) error: std::option::Option<crate::model::BatchItemError>,
    }
    impl Builder {
        /// <p>The geofence associated with the error message.</p>
        pub fn geofence_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.geofence_id = Some(input.into());
            self
        }
        pub fn set_geofence_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.geofence_id = input;
            self
        }
        /// <p>Contains details associated to the batch error.</p>
        pub fn error(mut self, input: crate::model::BatchItemError) -> Self {
            self.error = Some(input);
            self
        }
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::BatchItemError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchPutGeofenceError`](crate::model::BatchPutGeofenceError)
        pub fn build(self) -> crate::model::BatchPutGeofenceError {
            crate::model::BatchPutGeofenceError {
                geofence_id: self.geofence_id,
                error: self.error,
            }
        }
    }
}
impl BatchPutGeofenceError {
    /// Creates a new builder-style object to manufacture [`BatchPutGeofenceError`](crate::model::BatchPutGeofenceError)
    pub fn builder() -> crate::model::batch_put_geofence_error::Builder {
        crate::model::batch_put_geofence_error::Builder::default()
    }
}

/// <p>Contains a summary of each geofence that was successfully stored in a given geofence
/// collection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchPutGeofenceSuccess {
    /// <p>The geofence successfully stored in a geofence collection.</p>
    pub geofence_id: std::option::Option<std::string::String>,
    /// <p>The timestamp for when the geofence was stored in a geofence collection in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
    /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>
    /// </p>
    pub create_time: std::option::Option<smithy_types::Instant>,
    /// <p>The timestamp for when the geofence was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
    /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>
    /// </p>
    pub update_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for BatchPutGeofenceSuccess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchPutGeofenceSuccess");
        formatter.field("geofence_id", &self.geofence_id);
        formatter.field("create_time", &self.create_time);
        formatter.field("update_time", &self.update_time);
        formatter.finish()
    }
}
/// See [`BatchPutGeofenceSuccess`](crate::model::BatchPutGeofenceSuccess)
pub mod batch_put_geofence_success {
    /// A builder for [`BatchPutGeofenceSuccess`](crate::model::BatchPutGeofenceSuccess)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) geofence_id: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<smithy_types::Instant>,
        pub(crate) update_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The geofence successfully stored in a geofence collection.</p>
        pub fn geofence_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.geofence_id = Some(input.into());
            self
        }
        pub fn set_geofence_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.geofence_id = input;
            self
        }
        /// <p>The timestamp for when the geofence was stored in a geofence collection in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>
        /// </p>
        pub fn create_time(mut self, input: smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        pub fn set_create_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The timestamp for when the geofence was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>
        /// </p>
        pub fn update_time(mut self, input: smithy_types::Instant) -> Self {
            self.update_time = Some(input);
            self
        }
        pub fn set_update_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchPutGeofenceSuccess`](crate::model::BatchPutGeofenceSuccess)
        pub fn build(self) -> crate::model::BatchPutGeofenceSuccess {
            crate::model::BatchPutGeofenceSuccess {
                geofence_id: self.geofence_id,
                create_time: self.create_time,
                update_time: self.update_time,
            }
        }
    }
}
impl BatchPutGeofenceSuccess {
    /// Creates a new builder-style object to manufacture [`BatchPutGeofenceSuccess`](crate::model::BatchPutGeofenceSuccess)
    pub fn builder() -> crate::model::batch_put_geofence_success::Builder {
        crate::model::batch_put_geofence_success::Builder::default()
    }
}

/// <p>Contains geofence geometry details. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchPutGeofenceRequestEntry {
    /// <p>The identifier for the geofence to be stored in a given geofence collection.</p>
    pub geofence_id: std::option::Option<std::string::String>,
    /// <p>Contains the polygon details to specify the position of the geofence.</p>
    /// <note>
    /// <p>Each <a href="https://docs.aws.amazon.com/location-geofences/latest/APIReference/API_GeofenceGeometry.html">geofence polygon</a> can have a maximum of 1,000 vertices.</p>
    /// </note>
    pub geometry: std::option::Option<crate::model::GeofenceGeometry>,
}
impl std::fmt::Debug for BatchPutGeofenceRequestEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchPutGeofenceRequestEntry");
        formatter.field("geofence_id", &self.geofence_id);
        formatter.field("geometry", &self.geometry);
        formatter.finish()
    }
}
/// See [`BatchPutGeofenceRequestEntry`](crate::model::BatchPutGeofenceRequestEntry)
pub mod batch_put_geofence_request_entry {
    /// A builder for [`BatchPutGeofenceRequestEntry`](crate::model::BatchPutGeofenceRequestEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) geofence_id: std::option::Option<std::string::String>,
        pub(crate) geometry: std::option::Option<crate::model::GeofenceGeometry>,
    }
    impl Builder {
        /// <p>The identifier for the geofence to be stored in a given geofence collection.</p>
        pub fn geofence_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.geofence_id = Some(input.into());
            self
        }
        pub fn set_geofence_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.geofence_id = input;
            self
        }
        /// <p>Contains the polygon details to specify the position of the geofence.</p>
        /// <note>
        /// <p>Each <a href="https://docs.aws.amazon.com/location-geofences/latest/APIReference/API_GeofenceGeometry.html">geofence polygon</a> can have a maximum of 1,000 vertices.</p>
        /// </note>
        pub fn geometry(mut self, input: crate::model::GeofenceGeometry) -> Self {
            self.geometry = Some(input);
            self
        }
        pub fn set_geometry(
            mut self,
            input: std::option::Option<crate::model::GeofenceGeometry>,
        ) -> Self {
            self.geometry = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchPutGeofenceRequestEntry`](crate::model::BatchPutGeofenceRequestEntry)
        pub fn build(self) -> crate::model::BatchPutGeofenceRequestEntry {
            crate::model::BatchPutGeofenceRequestEntry {
                geofence_id: self.geofence_id,
                geometry: self.geometry,
            }
        }
    }
}
impl BatchPutGeofenceRequestEntry {
    /// Creates a new builder-style object to manufacture [`BatchPutGeofenceRequestEntry`](crate::model::BatchPutGeofenceRequestEntry)
    pub fn builder() -> crate::model::batch_put_geofence_request_entry::Builder {
        crate::model::batch_put_geofence_request_entry::Builder::default()
    }
}

/// <p>Contains error details for each device that failed to evaluate its position against
/// the geofences in a given geofence collection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchEvaluateGeofencesError {
    /// <p>The device associated with the position evaluation error.</p>
    pub device_id: std::option::Option<std::string::String>,
    /// <p>Specifies a timestamp for when the error occurred in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
    /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>
    /// </p>
    pub sample_time: std::option::Option<smithy_types::Instant>,
    /// <p>Contains details associated to the batch error.</p>
    pub error: std::option::Option<crate::model::BatchItemError>,
}
impl std::fmt::Debug for BatchEvaluateGeofencesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchEvaluateGeofencesError");
        formatter.field("device_id", &self.device_id);
        formatter.field("sample_time", &self.sample_time);
        formatter.field("error", &self.error);
        formatter.finish()
    }
}
/// See [`BatchEvaluateGeofencesError`](crate::model::BatchEvaluateGeofencesError)
pub mod batch_evaluate_geofences_error {
    /// A builder for [`BatchEvaluateGeofencesError`](crate::model::BatchEvaluateGeofencesError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) sample_time: std::option::Option<smithy_types::Instant>,
        pub(crate) error: std::option::Option<crate::model::BatchItemError>,
    }
    impl Builder {
        /// <p>The device associated with the position evaluation error.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>Specifies a timestamp for when the error occurred in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>
        /// </p>
        pub fn sample_time(mut self, input: smithy_types::Instant) -> Self {
            self.sample_time = Some(input);
            self
        }
        pub fn set_sample_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.sample_time = input;
            self
        }
        /// <p>Contains details associated to the batch error.</p>
        pub fn error(mut self, input: crate::model::BatchItemError) -> Self {
            self.error = Some(input);
            self
        }
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::BatchItemError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchEvaluateGeofencesError`](crate::model::BatchEvaluateGeofencesError)
        pub fn build(self) -> crate::model::BatchEvaluateGeofencesError {
            crate::model::BatchEvaluateGeofencesError {
                device_id: self.device_id,
                sample_time: self.sample_time,
                error: self.error,
            }
        }
    }
}
impl BatchEvaluateGeofencesError {
    /// Creates a new builder-style object to manufacture [`BatchEvaluateGeofencesError`](crate::model::BatchEvaluateGeofencesError)
    pub fn builder() -> crate::model::batch_evaluate_geofences_error::Builder {
        crate::model::batch_evaluate_geofences_error::Builder::default()
    }
}

/// <p>Contains error details for each geofence that failed to delete from the geofence
/// collection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchDeleteGeofenceError {
    /// <p>The geofence associated with the error message.</p>
    pub geofence_id: std::option::Option<std::string::String>,
    /// <p>Contains details associated to the batch error.</p>
    pub error: std::option::Option<crate::model::BatchItemError>,
}
impl std::fmt::Debug for BatchDeleteGeofenceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchDeleteGeofenceError");
        formatter.field("geofence_id", &self.geofence_id);
        formatter.field("error", &self.error);
        formatter.finish()
    }
}
/// See [`BatchDeleteGeofenceError`](crate::model::BatchDeleteGeofenceError)
pub mod batch_delete_geofence_error {
    /// A builder for [`BatchDeleteGeofenceError`](crate::model::BatchDeleteGeofenceError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) geofence_id: std::option::Option<std::string::String>,
        pub(crate) error: std::option::Option<crate::model::BatchItemError>,
    }
    impl Builder {
        /// <p>The geofence associated with the error message.</p>
        pub fn geofence_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.geofence_id = Some(input.into());
            self
        }
        pub fn set_geofence_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.geofence_id = input;
            self
        }
        /// <p>Contains details associated to the batch error.</p>
        pub fn error(mut self, input: crate::model::BatchItemError) -> Self {
            self.error = Some(input);
            self
        }
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::BatchItemError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDeleteGeofenceError`](crate::model::BatchDeleteGeofenceError)
        pub fn build(self) -> crate::model::BatchDeleteGeofenceError {
            crate::model::BatchDeleteGeofenceError {
                geofence_id: self.geofence_id,
                error: self.error,
            }
        }
    }
}
impl BatchDeleteGeofenceError {
    /// Creates a new builder-style object to manufacture [`BatchDeleteGeofenceError`](crate::model::BatchDeleteGeofenceError)
    pub fn builder() -> crate::model::batch_delete_geofence_error::Builder {
        crate::model::batch_delete_geofence_error::Builder::default()
    }
}

/// <p>Contains the geofence collection details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListGeofenceCollectionsResponseEntry {
    /// <p>The name of the geofence collection.</p>
    pub collection_name: std::option::Option<std::string::String>,
    /// <p>The description for the geofence collection</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The pricing plan for the specified geofence collection.</p>
    /// <p>For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
    /// page</a>.</p>
    pub pricing_plan: std::option::Option<crate::model::PricingPlan>,
    /// <p>The specified data provider for the geofence collection.</p>
    pub pricing_plan_data_source: std::option::Option<std::string::String>,
    /// <p>The timestamp for when the geofence collection was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
    /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>
    /// </p>
    pub create_time: std::option::Option<smithy_types::Instant>,
    /// <p>Specifies a timestamp for when the resource was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
    /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>
    /// </p>
    pub update_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ListGeofenceCollectionsResponseEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListGeofenceCollectionsResponseEntry");
        formatter.field("collection_name", &self.collection_name);
        formatter.field("description", &self.description);
        formatter.field("pricing_plan", &self.pricing_plan);
        formatter.field("pricing_plan_data_source", &self.pricing_plan_data_source);
        formatter.field("create_time", &self.create_time);
        formatter.field("update_time", &self.update_time);
        formatter.finish()
    }
}
/// See [`ListGeofenceCollectionsResponseEntry`](crate::model::ListGeofenceCollectionsResponseEntry)
pub mod list_geofence_collections_response_entry {
    /// A builder for [`ListGeofenceCollectionsResponseEntry`](crate::model::ListGeofenceCollectionsResponseEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) collection_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) pricing_plan: std::option::Option<crate::model::PricingPlan>,
        pub(crate) pricing_plan_data_source: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<smithy_types::Instant>,
        pub(crate) update_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the geofence collection.</p>
        pub fn collection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.collection_name = Some(input.into());
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collection_name = input;
            self
        }
        /// <p>The description for the geofence collection</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The pricing plan for the specified geofence collection.</p>
        /// <p>For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
        /// page</a>.</p>
        pub fn pricing_plan(mut self, input: crate::model::PricingPlan) -> Self {
            self.pricing_plan = Some(input);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.pricing_plan = input;
            self
        }
        /// <p>The specified data provider for the geofence collection.</p>
        pub fn pricing_plan_data_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.pricing_plan_data_source = Some(input.into());
            self
        }
        pub fn set_pricing_plan_data_source(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pricing_plan_data_source = input;
            self
        }
        /// <p>The timestamp for when the geofence collection was created in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>
        /// </p>
        pub fn create_time(mut self, input: smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        pub fn set_create_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>Specifies a timestamp for when the resource was last updated in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>
        /// </p>
        pub fn update_time(mut self, input: smithy_types::Instant) -> Self {
            self.update_time = Some(input);
            self
        }
        pub fn set_update_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ListGeofenceCollectionsResponseEntry`](crate::model::ListGeofenceCollectionsResponseEntry)
        pub fn build(self) -> crate::model::ListGeofenceCollectionsResponseEntry {
            crate::model::ListGeofenceCollectionsResponseEntry {
                collection_name: self.collection_name,
                description: self.description,
                pricing_plan: self.pricing_plan,
                pricing_plan_data_source: self.pricing_plan_data_source,
                create_time: self.create_time,
                update_time: self.update_time,
            }
        }
    }
}
impl ListGeofenceCollectionsResponseEntry {
    /// Creates a new builder-style object to manufacture [`ListGeofenceCollectionsResponseEntry`](crate::model::ListGeofenceCollectionsResponseEntry)
    pub fn builder() -> crate::model::list_geofence_collections_response_entry::Builder {
        crate::model::list_geofence_collections_response_entry::Builder::default()
    }
}
