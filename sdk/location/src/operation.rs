// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Creates an association between a geofence collection and a tracker resource. This
/// allows the tracker resource to communicate location data to the linked geofence
/// collection. </p>
/// <p>You can associate up to five geofence collections to each tracker resource.</p>
/// <note>
/// <p>Currently not supported — Cross-account configurations, such as creating associations between a tracker resource in one account and a geofence collection in another account.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociateTrackerConsumer {
    _private: (),
}
impl AssociateTrackerConsumer {
    /// Creates a new builder-style object to manufacture [`AssociateTrackerConsumerInput`](crate::input::AssociateTrackerConsumerInput)
    pub fn builder() -> crate::input::associate_tracker_consumer_input::Builder {
        crate::input::associate_tracker_consumer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociateTrackerConsumer {
    type Output = std::result::Result<
        crate::output::AssociateTrackerConsumerOutput,
        crate::error::AssociateTrackerConsumerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_associate_tracker_consumer_error(response)
        } else {
            crate::operation_ser::parse_associate_tracker_consumer_response(response)
        }
    }
}

/// <p>Deletes the position history of one or more devices from a tracker resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDeleteDevicePositionHistory {
    _private: (),
}
impl BatchDeleteDevicePositionHistory {
    /// Creates a new builder-style object to manufacture [`BatchDeleteDevicePositionHistoryInput`](crate::input::BatchDeleteDevicePositionHistoryInput)
    pub fn builder() -> crate::input::batch_delete_device_position_history_input::Builder {
        crate::input::batch_delete_device_position_history_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDeleteDevicePositionHistory {
    type Output = std::result::Result<
        crate::output::BatchDeleteDevicePositionHistoryOutput,
        crate::error::BatchDeleteDevicePositionHistoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_batch_delete_device_position_history_error(response)
        } else {
            crate::operation_ser::parse_batch_delete_device_position_history_response(response)
        }
    }
}

/// <p>Deletes a batch of geofences from a geofence collection.</p>
/// <note>
/// <p>This operation deletes the resource permanently.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDeleteGeofence {
    _private: (),
}
impl BatchDeleteGeofence {
    /// Creates a new builder-style object to manufacture [`BatchDeleteGeofenceInput`](crate::input::BatchDeleteGeofenceInput)
    pub fn builder() -> crate::input::batch_delete_geofence_input::Builder {
        crate::input::batch_delete_geofence_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDeleteGeofence {
    type Output = std::result::Result<
        crate::output::BatchDeleteGeofenceOutput,
        crate::error::BatchDeleteGeofenceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_batch_delete_geofence_error(response)
        } else {
            crate::operation_ser::parse_batch_delete_geofence_response(response)
        }
    }
}

/// <p>Evaluates device positions against the geofence geometries from a given geofence
/// collection.</p>
/// <p>This operation always returns an empty response because geofences are asynchronously
/// evaluated. The evaluation determines if the device has entered or exited a geofenced
/// area, and then publishes one of the following events to Amazon EventBridge:</p>
/// <ul>
/// <li>
/// <p>
/// <code>ENTER</code> if Amazon Location determines that the tracked device has entered
/// a geofenced area.</p>
/// </li>
/// <li>
/// <p>
/// <code>EXIT</code> if Amazon Location determines that the tracked device has exited a
/// geofenced area.</p>
/// </li>
/// </ul>
/// <note>
/// <p>The last geofence that a device was observed within is tracked for 30 days after
/// the most recent device position update.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchEvaluateGeofences {
    _private: (),
}
impl BatchEvaluateGeofences {
    /// Creates a new builder-style object to manufacture [`BatchEvaluateGeofencesInput`](crate::input::BatchEvaluateGeofencesInput)
    pub fn builder() -> crate::input::batch_evaluate_geofences_input::Builder {
        crate::input::batch_evaluate_geofences_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchEvaluateGeofences {
    type Output = std::result::Result<
        crate::output::BatchEvaluateGeofencesOutput,
        crate::error::BatchEvaluateGeofencesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_batch_evaluate_geofences_error(response)
        } else {
            crate::operation_ser::parse_batch_evaluate_geofences_response(response)
        }
    }
}

/// <p>Lists the latest device positions for requested devices.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetDevicePosition {
    _private: (),
}
impl BatchGetDevicePosition {
    /// Creates a new builder-style object to manufacture [`BatchGetDevicePositionInput`](crate::input::BatchGetDevicePositionInput)
    pub fn builder() -> crate::input::batch_get_device_position_input::Builder {
        crate::input::batch_get_device_position_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetDevicePosition {
    type Output = std::result::Result<
        crate::output::BatchGetDevicePositionOutput,
        crate::error::BatchGetDevicePositionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_batch_get_device_position_error(response)
        } else {
            crate::operation_ser::parse_batch_get_device_position_response(response)
        }
    }
}

/// <p>A batch request for storing geofence geometries into a given geofence collection, or
/// updates the geometry of an existing geofence if a geofence ID is included in the request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchPutGeofence {
    _private: (),
}
impl BatchPutGeofence {
    /// Creates a new builder-style object to manufacture [`BatchPutGeofenceInput`](crate::input::BatchPutGeofenceInput)
    pub fn builder() -> crate::input::batch_put_geofence_input::Builder {
        crate::input::batch_put_geofence_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchPutGeofence {
    type Output = std::result::Result<
        crate::output::BatchPutGeofenceOutput,
        crate::error::BatchPutGeofenceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_batch_put_geofence_error(response)
        } else {
            crate::operation_ser::parse_batch_put_geofence_response(response)
        }
    }
}

/// <p>Uploads position update data for one or more devices to a tracker resource. Amazon Location
/// uses the data when it reports the last known device position and position history. Amazon Location retains location data for 30
/// days.</p>
/// <note>
/// <p>Position updates are handled based on the <code>PositionFiltering</code> property of the tracker.
/// When <code>PositionFiltering</code> is set to <code>TimeBased</code>, updates are evaluated against linked geofence collections,
/// and location data is stored at a maximum of one position per 30 second interval. If your update frequency is more often than
/// every 30 seconds, only one update per 30 seconds is stored for each unique device ID.
/// When <code>PositionFiltering</code> is set to <code>DistanceBased</code> filtering, location data is stored and evaluated against linked geofence
/// collections only if the device has moved more than 30 m (98.4 ft).</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchUpdateDevicePosition {
    _private: (),
}
impl BatchUpdateDevicePosition {
    /// Creates a new builder-style object to manufacture [`BatchUpdateDevicePositionInput`](crate::input::BatchUpdateDevicePositionInput)
    pub fn builder() -> crate::input::batch_update_device_position_input::Builder {
        crate::input::batch_update_device_position_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchUpdateDevicePosition {
    type Output = std::result::Result<
        crate::output::BatchUpdateDevicePositionOutput,
        crate::error::BatchUpdateDevicePositionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_batch_update_device_position_error(response)
        } else {
            crate::operation_ser::parse_batch_update_device_position_response(response)
        }
    }
}

/// <p>
/// <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html">Calculates a route</a> given the following required parameters:
/// <code>DeparturePostiton</code> and <code>DestinationPosition</code>. Requires that
/// you first <a href="https://docs.aws.amazon.com/location-routes/latest/APIReference/API_CreateRouteCalculator.html">create a
/// route calculator resource</a>
/// </p>
/// <p>By default, a request that doesn't specify a departure time uses the best time of day
/// to travel with the best traffic conditions when calculating the route.</p>
/// <p>Additional options include:</p>
/// <ul>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#departure-time">Specifying a departure time</a> using either <code>DepartureTime</code> or
/// <code>DepartureNow</code>. This calculates a route based on predictive
/// traffic data at the given time. </p>
/// <note>
/// <p>You can't specify both <code>DepartureTime</code> and
/// <code>DepartureNow</code> in a single request. Specifying both
/// parameters returns an error message.</p>
/// </note>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#travel-mode">Specifying a travel mode</a> using TravelMode. This lets you specify an
/// additional route preference such as <code>CarModeOptions</code> if traveling by
/// <code>Car</code>, or <code>TruckModeOptions</code> if traveling by
/// <code>Truck</code>.</p>
/// </li>
/// </ul>
/// <p>
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CalculateRoute {
    _private: (),
}
impl CalculateRoute {
    /// Creates a new builder-style object to manufacture [`CalculateRouteInput`](crate::input::CalculateRouteInput)
    pub fn builder() -> crate::input::calculate_route_input::Builder {
        crate::input::calculate_route_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CalculateRoute {
    type Output =
        std::result::Result<crate::output::CalculateRouteOutput, crate::error::CalculateRouteError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_calculate_route_error(response)
        } else {
            crate::operation_ser::parse_calculate_route_response(response)
        }
    }
}

/// <p>Creates a geofence collection, which manages and stores geofences.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateGeofenceCollection {
    _private: (),
}
impl CreateGeofenceCollection {
    /// Creates a new builder-style object to manufacture [`CreateGeofenceCollectionInput`](crate::input::CreateGeofenceCollectionInput)
    pub fn builder() -> crate::input::create_geofence_collection_input::Builder {
        crate::input::create_geofence_collection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateGeofenceCollection {
    type Output = std::result::Result<
        crate::output::CreateGeofenceCollectionOutput,
        crate::error::CreateGeofenceCollectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_geofence_collection_error(response)
        } else {
            crate::operation_ser::parse_create_geofence_collection_response(response)
        }
    }
}

/// <p>Creates a map resource in your AWS account, which provides map tiles of different
/// styles sourced from global location data providers.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateMap {
    _private: (),
}
impl CreateMap {
    /// Creates a new builder-style object to manufacture [`CreateMapInput`](crate::input::CreateMapInput)
    pub fn builder() -> crate::input::create_map_input::Builder {
        crate::input::create_map_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateMap {
    type Output = std::result::Result<crate::output::CreateMapOutput, crate::error::CreateMapError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_map_error(response)
        } else {
            crate::operation_ser::parse_create_map_response(response)
        }
    }
}

/// <p>Creates a place index resource in your AWS account, which supports functions with
/// geospatial data sourced from your chosen data provider.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreatePlaceIndex {
    _private: (),
}
impl CreatePlaceIndex {
    /// Creates a new builder-style object to manufacture [`CreatePlaceIndexInput`](crate::input::CreatePlaceIndexInput)
    pub fn builder() -> crate::input::create_place_index_input::Builder {
        crate::input::create_place_index_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreatePlaceIndex {
    type Output = std::result::Result<
        crate::output::CreatePlaceIndexOutput,
        crate::error::CreatePlaceIndexError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_place_index_error(response)
        } else {
            crate::operation_ser::parse_create_place_index_response(response)
        }
    }
}

/// <p>Creates a route calculator resource in your AWS account.</p>
/// <p>You can send requests to a route calculator resource to estimate travel time,
/// distance, and get directions. A route calculator sources traffic and road network data
/// from your chosen data provider.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateRouteCalculator {
    _private: (),
}
impl CreateRouteCalculator {
    /// Creates a new builder-style object to manufacture [`CreateRouteCalculatorInput`](crate::input::CreateRouteCalculatorInput)
    pub fn builder() -> crate::input::create_route_calculator_input::Builder {
        crate::input::create_route_calculator_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateRouteCalculator {
    type Output = std::result::Result<
        crate::output::CreateRouteCalculatorOutput,
        crate::error::CreateRouteCalculatorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_route_calculator_error(response)
        } else {
            crate::operation_ser::parse_create_route_calculator_response(response)
        }
    }
}

/// <p>Creates a tracker resource in your AWS account, which lets you retrieve current and
/// historical location of devices.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateTracker {
    _private: (),
}
impl CreateTracker {
    /// Creates a new builder-style object to manufacture [`CreateTrackerInput`](crate::input::CreateTrackerInput)
    pub fn builder() -> crate::input::create_tracker_input::Builder {
        crate::input::create_tracker_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateTracker {
    type Output =
        std::result::Result<crate::output::CreateTrackerOutput, crate::error::CreateTrackerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_tracker_error(response)
        } else {
            crate::operation_ser::parse_create_tracker_response(response)
        }
    }
}

/// <p>Deletes a geofence collection from your AWS account.</p>
/// <note>
/// <p>This operation deletes the resource permanently. If the geofence collection is the
/// target of a tracker resource, the devices will no longer be monitored.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteGeofenceCollection {
    _private: (),
}
impl DeleteGeofenceCollection {
    /// Creates a new builder-style object to manufacture [`DeleteGeofenceCollectionInput`](crate::input::DeleteGeofenceCollectionInput)
    pub fn builder() -> crate::input::delete_geofence_collection_input::Builder {
        crate::input::delete_geofence_collection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteGeofenceCollection {
    type Output = std::result::Result<
        crate::output::DeleteGeofenceCollectionOutput,
        crate::error::DeleteGeofenceCollectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_geofence_collection_error(response)
        } else {
            crate::operation_ser::parse_delete_geofence_collection_response(response)
        }
    }
}

/// <p>Deletes a map resource from your AWS account.</p>
/// <note>
/// <p>This operation deletes the resource permanently. If the map is being used in an application,
/// the map may not render.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteMap {
    _private: (),
}
impl DeleteMap {
    /// Creates a new builder-style object to manufacture [`DeleteMapInput`](crate::input::DeleteMapInput)
    pub fn builder() -> crate::input::delete_map_input::Builder {
        crate::input::delete_map_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteMap {
    type Output = std::result::Result<crate::output::DeleteMapOutput, crate::error::DeleteMapError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_map_error(response)
        } else {
            crate::operation_ser::parse_delete_map_response(response)
        }
    }
}

/// <p>Deletes a place index resource from your AWS account.</p>
/// <note>
/// <p>This operation deletes the resource permanently.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeletePlaceIndex {
    _private: (),
}
impl DeletePlaceIndex {
    /// Creates a new builder-style object to manufacture [`DeletePlaceIndexInput`](crate::input::DeletePlaceIndexInput)
    pub fn builder() -> crate::input::delete_place_index_input::Builder {
        crate::input::delete_place_index_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeletePlaceIndex {
    type Output = std::result::Result<
        crate::output::DeletePlaceIndexOutput,
        crate::error::DeletePlaceIndexError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_place_index_error(response)
        } else {
            crate::operation_ser::parse_delete_place_index_response(response)
        }
    }
}

/// <p>Deletes a route calculator resource from your AWS account.</p>
/// <note>
/// <p>This operation deletes the resource permanently.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRouteCalculator {
    _private: (),
}
impl DeleteRouteCalculator {
    /// Creates a new builder-style object to manufacture [`DeleteRouteCalculatorInput`](crate::input::DeleteRouteCalculatorInput)
    pub fn builder() -> crate::input::delete_route_calculator_input::Builder {
        crate::input::delete_route_calculator_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRouteCalculator {
    type Output = std::result::Result<
        crate::output::DeleteRouteCalculatorOutput,
        crate::error::DeleteRouteCalculatorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_route_calculator_error(response)
        } else {
            crate::operation_ser::parse_delete_route_calculator_response(response)
        }
    }
}

/// <p>Deletes a tracker resource from your AWS account.</p>
/// <note>
/// <p>This operation deletes the resource permanently. If the tracker resource is in use, you may
/// encounter an error. Make sure that the target resource isn't a dependency for your
/// applications.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTracker {
    _private: (),
}
impl DeleteTracker {
    /// Creates a new builder-style object to manufacture [`DeleteTrackerInput`](crate::input::DeleteTrackerInput)
    pub fn builder() -> crate::input::delete_tracker_input::Builder {
        crate::input::delete_tracker_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTracker {
    type Output =
        std::result::Result<crate::output::DeleteTrackerOutput, crate::error::DeleteTrackerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_tracker_error(response)
        } else {
            crate::operation_ser::parse_delete_tracker_response(response)
        }
    }
}

/// <p>Retrieves the geofence collection details.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeGeofenceCollection {
    _private: (),
}
impl DescribeGeofenceCollection {
    /// Creates a new builder-style object to manufacture [`DescribeGeofenceCollectionInput`](crate::input::DescribeGeofenceCollectionInput)
    pub fn builder() -> crate::input::describe_geofence_collection_input::Builder {
        crate::input::describe_geofence_collection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeGeofenceCollection {
    type Output = std::result::Result<
        crate::output::DescribeGeofenceCollectionOutput,
        crate::error::DescribeGeofenceCollectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_geofence_collection_error(response)
        } else {
            crate::operation_ser::parse_describe_geofence_collection_response(response)
        }
    }
}

/// <p>Retrieves the map resource details.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeMap {
    _private: (),
}
impl DescribeMap {
    /// Creates a new builder-style object to manufacture [`DescribeMapInput`](crate::input::DescribeMapInput)
    pub fn builder() -> crate::input::describe_map_input::Builder {
        crate::input::describe_map_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeMap {
    type Output =
        std::result::Result<crate::output::DescribeMapOutput, crate::error::DescribeMapError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_map_error(response)
        } else {
            crate::operation_ser::parse_describe_map_response(response)
        }
    }
}

/// <p>Retrieves the place index resource details.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribePlaceIndex {
    _private: (),
}
impl DescribePlaceIndex {
    /// Creates a new builder-style object to manufacture [`DescribePlaceIndexInput`](crate::input::DescribePlaceIndexInput)
    pub fn builder() -> crate::input::describe_place_index_input::Builder {
        crate::input::describe_place_index_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribePlaceIndex {
    type Output = std::result::Result<
        crate::output::DescribePlaceIndexOutput,
        crate::error::DescribePlaceIndexError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_place_index_error(response)
        } else {
            crate::operation_ser::parse_describe_place_index_response(response)
        }
    }
}

/// <p>Retrieves the route calculator resource details.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeRouteCalculator {
    _private: (),
}
impl DescribeRouteCalculator {
    /// Creates a new builder-style object to manufacture [`DescribeRouteCalculatorInput`](crate::input::DescribeRouteCalculatorInput)
    pub fn builder() -> crate::input::describe_route_calculator_input::Builder {
        crate::input::describe_route_calculator_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeRouteCalculator {
    type Output = std::result::Result<
        crate::output::DescribeRouteCalculatorOutput,
        crate::error::DescribeRouteCalculatorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_route_calculator_error(response)
        } else {
            crate::operation_ser::parse_describe_route_calculator_response(response)
        }
    }
}

/// <p>Retrieves the tracker resource details.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTracker {
    _private: (),
}
impl DescribeTracker {
    /// Creates a new builder-style object to manufacture [`DescribeTrackerInput`](crate::input::DescribeTrackerInput)
    pub fn builder() -> crate::input::describe_tracker_input::Builder {
        crate::input::describe_tracker_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTracker {
    type Output = std::result::Result<
        crate::output::DescribeTrackerOutput,
        crate::error::DescribeTrackerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_tracker_error(response)
        } else {
            crate::operation_ser::parse_describe_tracker_response(response)
        }
    }
}

/// <p>Removes the association between a tracker resource and a geofence collection.</p>
/// <note>
/// <p>Once you unlink a tracker resource from a geofence collection, the tracker
/// positions will no longer be automatically evaluated against geofences.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisassociateTrackerConsumer {
    _private: (),
}
impl DisassociateTrackerConsumer {
    /// Creates a new builder-style object to manufacture [`DisassociateTrackerConsumerInput`](crate::input::DisassociateTrackerConsumerInput)
    pub fn builder() -> crate::input::disassociate_tracker_consumer_input::Builder {
        crate::input::disassociate_tracker_consumer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisassociateTrackerConsumer {
    type Output = std::result::Result<
        crate::output::DisassociateTrackerConsumerOutput,
        crate::error::DisassociateTrackerConsumerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_disassociate_tracker_consumer_error(response)
        } else {
            crate::operation_ser::parse_disassociate_tracker_consumer_response(response)
        }
    }
}

/// <p>Retrieves a device's most recent position according to its sample time.</p>
/// <note>
/// <p>Device positions are deleted after 30 days.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDevicePosition {
    _private: (),
}
impl GetDevicePosition {
    /// Creates a new builder-style object to manufacture [`GetDevicePositionInput`](crate::input::GetDevicePositionInput)
    pub fn builder() -> crate::input::get_device_position_input::Builder {
        crate::input::get_device_position_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDevicePosition {
    type Output = std::result::Result<
        crate::output::GetDevicePositionOutput,
        crate::error::GetDevicePositionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_device_position_error(response)
        } else {
            crate::operation_ser::parse_get_device_position_response(response)
        }
    }
}

/// <p>Retrieves the device position history from a tracker resource within a specified range
/// of time.</p>
/// <note>
/// <p>Device positions are deleted after 30 days.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDevicePositionHistory {
    _private: (),
}
impl GetDevicePositionHistory {
    /// Creates a new builder-style object to manufacture [`GetDevicePositionHistoryInput`](crate::input::GetDevicePositionHistoryInput)
    pub fn builder() -> crate::input::get_device_position_history_input::Builder {
        crate::input::get_device_position_history_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDevicePositionHistory {
    type Output = std::result::Result<
        crate::output::GetDevicePositionHistoryOutput,
        crate::error::GetDevicePositionHistoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_device_position_history_error(response)
        } else {
            crate::operation_ser::parse_get_device_position_history_response(response)
        }
    }
}

/// <p>Retrieves the geofence details from a geofence collection.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetGeofence {
    _private: (),
}
impl GetGeofence {
    /// Creates a new builder-style object to manufacture [`GetGeofenceInput`](crate::input::GetGeofenceInput)
    pub fn builder() -> crate::input::get_geofence_input::Builder {
        crate::input::get_geofence_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetGeofence {
    type Output =
        std::result::Result<crate::output::GetGeofenceOutput, crate::error::GetGeofenceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_geofence_error(response)
        } else {
            crate::operation_ser::parse_get_geofence_response(response)
        }
    }
}

/// <p>Retrieves glyphs used to display labels on a map.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetMapGlyphs {
    _private: (),
}
impl GetMapGlyphs {
    /// Creates a new builder-style object to manufacture [`GetMapGlyphsInput`](crate::input::GetMapGlyphsInput)
    pub fn builder() -> crate::input::get_map_glyphs_input::Builder {
        crate::input::get_map_glyphs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetMapGlyphs {
    type Output =
        std::result::Result<crate::output::GetMapGlyphsOutput, crate::error::GetMapGlyphsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_map_glyphs_error(response)
        } else {
            crate::operation_ser::parse_get_map_glyphs_response(response)
        }
    }
}

/// <p>Retrieves the sprite sheet corresponding to a map resource. The sprite sheet is a PNG
/// image paired with a JSON document describing the offsets of individual icons that will
/// be displayed on a rendered map.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetMapSprites {
    _private: (),
}
impl GetMapSprites {
    /// Creates a new builder-style object to manufacture [`GetMapSpritesInput`](crate::input::GetMapSpritesInput)
    pub fn builder() -> crate::input::get_map_sprites_input::Builder {
        crate::input::get_map_sprites_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetMapSprites {
    type Output =
        std::result::Result<crate::output::GetMapSpritesOutput, crate::error::GetMapSpritesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_map_sprites_error(response)
        } else {
            crate::operation_ser::parse_get_map_sprites_response(response)
        }
    }
}

/// <p>Retrieves the map style descriptor from a map resource. </p>
/// <p>The style descriptor contains speciﬁcations on how features render on a map. For
/// example, what data to display, what order to display the data in, and the style for the
/// data. Style descriptors follow the Mapbox Style Specification.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetMapStyleDescriptor {
    _private: (),
}
impl GetMapStyleDescriptor {
    /// Creates a new builder-style object to manufacture [`GetMapStyleDescriptorInput`](crate::input::GetMapStyleDescriptorInput)
    pub fn builder() -> crate::input::get_map_style_descriptor_input::Builder {
        crate::input::get_map_style_descriptor_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetMapStyleDescriptor {
    type Output = std::result::Result<
        crate::output::GetMapStyleDescriptorOutput,
        crate::error::GetMapStyleDescriptorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_map_style_descriptor_error(response)
        } else {
            crate::operation_ser::parse_get_map_style_descriptor_response(response)
        }
    }
}

/// <p>Retrieves a vector data tile from the map resource. Map tiles are used by clients to
/// render a map. they're addressed using a grid arrangement with an X coordinate, Y
/// coordinate, and Z (zoom) level. </p>
/// <p>The origin (0, 0) is the top left of the map. Increasing the zoom level by 1 doubles
/// both the X and Y dimensions, so a tile containing data for the entire world at (0/0/0)
/// will be split into 4 tiles at zoom 1 (1/0/0, 1/0/1, 1/1/0, 1/1/1).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetMapTile {
    _private: (),
}
impl GetMapTile {
    /// Creates a new builder-style object to manufacture [`GetMapTileInput`](crate::input::GetMapTileInput)
    pub fn builder() -> crate::input::get_map_tile_input::Builder {
        crate::input::get_map_tile_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetMapTile {
    type Output =
        std::result::Result<crate::output::GetMapTileOutput, crate::error::GetMapTileError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_map_tile_error(response)
        } else {
            crate::operation_ser::parse_get_map_tile_response(response)
        }
    }
}

/// <p>A batch request to retrieve all device positions.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDevicePositions {
    _private: (),
}
impl ListDevicePositions {
    /// Creates a new builder-style object to manufacture [`ListDevicePositionsInput`](crate::input::ListDevicePositionsInput)
    pub fn builder() -> crate::input::list_device_positions_input::Builder {
        crate::input::list_device_positions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDevicePositions {
    type Output = std::result::Result<
        crate::output::ListDevicePositionsOutput,
        crate::error::ListDevicePositionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_device_positions_error(response)
        } else {
            crate::operation_ser::parse_list_device_positions_response(response)
        }
    }
}

/// <p>Lists geofence collections in your AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListGeofenceCollections {
    _private: (),
}
impl ListGeofenceCollections {
    /// Creates a new builder-style object to manufacture [`ListGeofenceCollectionsInput`](crate::input::ListGeofenceCollectionsInput)
    pub fn builder() -> crate::input::list_geofence_collections_input::Builder {
        crate::input::list_geofence_collections_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListGeofenceCollections {
    type Output = std::result::Result<
        crate::output::ListGeofenceCollectionsOutput,
        crate::error::ListGeofenceCollectionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_geofence_collections_error(response)
        } else {
            crate::operation_ser::parse_list_geofence_collections_response(response)
        }
    }
}

/// <p>Lists geofences stored in a given geofence collection.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListGeofences {
    _private: (),
}
impl ListGeofences {
    /// Creates a new builder-style object to manufacture [`ListGeofencesInput`](crate::input::ListGeofencesInput)
    pub fn builder() -> crate::input::list_geofences_input::Builder {
        crate::input::list_geofences_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListGeofences {
    type Output =
        std::result::Result<crate::output::ListGeofencesOutput, crate::error::ListGeofencesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_geofences_error(response)
        } else {
            crate::operation_ser::parse_list_geofences_response(response)
        }
    }
}

/// <p>Lists map resources in your AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListMaps {
    _private: (),
}
impl ListMaps {
    /// Creates a new builder-style object to manufacture [`ListMapsInput`](crate::input::ListMapsInput)
    pub fn builder() -> crate::input::list_maps_input::Builder {
        crate::input::list_maps_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListMaps {
    type Output = std::result::Result<crate::output::ListMapsOutput, crate::error::ListMapsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_maps_error(response)
        } else {
            crate::operation_ser::parse_list_maps_response(response)
        }
    }
}

/// <p>Lists place index resources in your AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListPlaceIndexes {
    _private: (),
}
impl ListPlaceIndexes {
    /// Creates a new builder-style object to manufacture [`ListPlaceIndexesInput`](crate::input::ListPlaceIndexesInput)
    pub fn builder() -> crate::input::list_place_indexes_input::Builder {
        crate::input::list_place_indexes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListPlaceIndexes {
    type Output = std::result::Result<
        crate::output::ListPlaceIndexesOutput,
        crate::error::ListPlaceIndexesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_place_indexes_error(response)
        } else {
            crate::operation_ser::parse_list_place_indexes_response(response)
        }
    }
}

/// <p>Lists route calculator resources in your AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListRouteCalculators {
    _private: (),
}
impl ListRouteCalculators {
    /// Creates a new builder-style object to manufacture [`ListRouteCalculatorsInput`](crate::input::ListRouteCalculatorsInput)
    pub fn builder() -> crate::input::list_route_calculators_input::Builder {
        crate::input::list_route_calculators_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListRouteCalculators {
    type Output = std::result::Result<
        crate::output::ListRouteCalculatorsOutput,
        crate::error::ListRouteCalculatorsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_route_calculators_error(response)
        } else {
            crate::operation_ser::parse_list_route_calculators_response(response)
        }
    }
}

/// <p>Returns a list of tags that are applied to the specified Amazon Location resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_ser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Lists geofence collections currently associated to the given tracker resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTrackerConsumers {
    _private: (),
}
impl ListTrackerConsumers {
    /// Creates a new builder-style object to manufacture [`ListTrackerConsumersInput`](crate::input::ListTrackerConsumersInput)
    pub fn builder() -> crate::input::list_tracker_consumers_input::Builder {
        crate::input::list_tracker_consumers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTrackerConsumers {
    type Output = std::result::Result<
        crate::output::ListTrackerConsumersOutput,
        crate::error::ListTrackerConsumersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_tracker_consumers_error(response)
        } else {
            crate::operation_ser::parse_list_tracker_consumers_response(response)
        }
    }
}

/// <p>Lists tracker resources in your AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTrackers {
    _private: (),
}
impl ListTrackers {
    /// Creates a new builder-style object to manufacture [`ListTrackersInput`](crate::input::ListTrackersInput)
    pub fn builder() -> crate::input::list_trackers_input::Builder {
        crate::input::list_trackers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTrackers {
    type Output =
        std::result::Result<crate::output::ListTrackersOutput, crate::error::ListTrackersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_trackers_error(response)
        } else {
            crate::operation_ser::parse_list_trackers_response(response)
        }
    }
}

/// <p>Stores a geofence geometry in a given geofence collection, or updates the geometry of
/// an existing geofence if a geofence ID is included in the request. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutGeofence {
    _private: (),
}
impl PutGeofence {
    /// Creates a new builder-style object to manufacture [`PutGeofenceInput`](crate::input::PutGeofenceInput)
    pub fn builder() -> crate::input::put_geofence_input::Builder {
        crate::input::put_geofence_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutGeofence {
    type Output =
        std::result::Result<crate::output::PutGeofenceOutput, crate::error::PutGeofenceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_put_geofence_error(response)
        } else {
            crate::operation_ser::parse_put_geofence_response(response)
        }
    }
}

/// <p>Reverse geocodes a given coordinate and returns a legible address. Allows you to search
/// for Places or points of interest near a given position.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SearchPlaceIndexForPosition {
    _private: (),
}
impl SearchPlaceIndexForPosition {
    /// Creates a new builder-style object to manufacture [`SearchPlaceIndexForPositionInput`](crate::input::SearchPlaceIndexForPositionInput)
    pub fn builder() -> crate::input::search_place_index_for_position_input::Builder {
        crate::input::search_place_index_for_position_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SearchPlaceIndexForPosition {
    type Output = std::result::Result<
        crate::output::SearchPlaceIndexForPositionOutput,
        crate::error::SearchPlaceIndexForPositionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_search_place_index_for_position_error(response)
        } else {
            crate::operation_ser::parse_search_place_index_for_position_response(response)
        }
    }
}

/// <p>Geocodes free-form text, such as an address, name, city, or region to allow you to
/// search for Places or points of interest. </p>
/// <p>Includes the option to apply additional parameters to narrow your list of
/// results.</p>
/// <note>
/// <p>You can search for places near a given position using <code>BiasPosition</code>, or
/// filter results within a bounding box using <code>FilterBBox</code>. Providing both
/// parameters simultaneously returns an error.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SearchPlaceIndexForText {
    _private: (),
}
impl SearchPlaceIndexForText {
    /// Creates a new builder-style object to manufacture [`SearchPlaceIndexForTextInput`](crate::input::SearchPlaceIndexForTextInput)
    pub fn builder() -> crate::input::search_place_index_for_text_input::Builder {
        crate::input::search_place_index_for_text_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SearchPlaceIndexForText {
    type Output = std::result::Result<
        crate::output::SearchPlaceIndexForTextOutput,
        crate::error::SearchPlaceIndexForTextError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_search_place_index_for_text_error(response)
        } else {
            crate::operation_ser::parse_search_place_index_for_text_response(response)
        }
    }
}

/// <p>Assigns one or more tags (key-value pairs) to the specified Amazon
/// Location Service resource.</p>
/// <p>Tags can help you organize and categorize your resources.
/// You can also use them to scope user permissions, by granting a user
/// permission to access or change only resources with certain tag values.</p>
/// <p>You can use the <code>TagResource</code> operation with an Amazon Location Service
/// resource that already has tags. If you specify a new tag key for the resource, this tag
/// is appended to the tags already associated with the resource. If you specify a tag key
/// that's already associated with the resource, the new tag value that you specify replaces
/// the previous value for that tag. </p>
/// <p>You can associate up to 50 tags with a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_tag_resource_error(response)
        } else {
            crate::operation_ser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes one or more tags from the specified Amazon Location resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_untag_resource_error(response)
        } else {
            crate::operation_ser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates the specified properties of a given geofence collection.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateGeofenceCollection {
    _private: (),
}
impl UpdateGeofenceCollection {
    /// Creates a new builder-style object to manufacture [`UpdateGeofenceCollectionInput`](crate::input::UpdateGeofenceCollectionInput)
    pub fn builder() -> crate::input::update_geofence_collection_input::Builder {
        crate::input::update_geofence_collection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateGeofenceCollection {
    type Output = std::result::Result<
        crate::output::UpdateGeofenceCollectionOutput,
        crate::error::UpdateGeofenceCollectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_geofence_collection_error(response)
        } else {
            crate::operation_ser::parse_update_geofence_collection_response(response)
        }
    }
}

/// <p>Updates the specified properties of a given map resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateMap {
    _private: (),
}
impl UpdateMap {
    /// Creates a new builder-style object to manufacture [`UpdateMapInput`](crate::input::UpdateMapInput)
    pub fn builder() -> crate::input::update_map_input::Builder {
        crate::input::update_map_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateMap {
    type Output = std::result::Result<crate::output::UpdateMapOutput, crate::error::UpdateMapError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_map_error(response)
        } else {
            crate::operation_ser::parse_update_map_response(response)
        }
    }
}

/// <p>Updates the specified properties of a given place index resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdatePlaceIndex {
    _private: (),
}
impl UpdatePlaceIndex {
    /// Creates a new builder-style object to manufacture [`UpdatePlaceIndexInput`](crate::input::UpdatePlaceIndexInput)
    pub fn builder() -> crate::input::update_place_index_input::Builder {
        crate::input::update_place_index_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdatePlaceIndex {
    type Output = std::result::Result<
        crate::output::UpdatePlaceIndexOutput,
        crate::error::UpdatePlaceIndexError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_place_index_error(response)
        } else {
            crate::operation_ser::parse_update_place_index_response(response)
        }
    }
}

/// <p>Updates the specified properties for a given route calculator resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateRouteCalculator {
    _private: (),
}
impl UpdateRouteCalculator {
    /// Creates a new builder-style object to manufacture [`UpdateRouteCalculatorInput`](crate::input::UpdateRouteCalculatorInput)
    pub fn builder() -> crate::input::update_route_calculator_input::Builder {
        crate::input::update_route_calculator_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateRouteCalculator {
    type Output = std::result::Result<
        crate::output::UpdateRouteCalculatorOutput,
        crate::error::UpdateRouteCalculatorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_route_calculator_error(response)
        } else {
            crate::operation_ser::parse_update_route_calculator_response(response)
        }
    }
}

/// <p>Updates the specified properties of a given tracker resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateTracker {
    _private: (),
}
impl UpdateTracker {
    /// Creates a new builder-style object to manufacture [`UpdateTrackerInput`](crate::input::UpdateTrackerInput)
    pub fn builder() -> crate::input::update_tracker_input::Builder {
        crate::input::update_tracker_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateTracker {
    type Output =
        std::result::Result<crate::output::UpdateTrackerOutput, crate::error::UpdateTrackerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_tracker_error(response)
        } else {
            crate::operation_ser::parse_update_tracker_response(response)
        }
    }
}
