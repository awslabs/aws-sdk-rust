// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains the calculated route's details for each path between a pair of positions. The number of legs returned corresponds to one fewer than the total number of positions in the request. </p> 
/// <p>For example, a route with a departure position and destination position returns one leg with the positions <a href="https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html">snapped to a nearby road</a>:</p> 
/// <ul> 
/// <li> <p>The <code>StartPosition</code> is the departure position.</p> </li> 
/// <li> <p>The <code>EndPosition</code> is the destination position.</p> </li> 
/// </ul> 
/// <p>A route with a waypoint between the departure and destination position returns two legs with the positions snapped to a nearby road:</p> 
/// <ul> 
/// <li> <p>Leg 1: The <code>StartPosition</code> is the departure position . The <code>EndPosition</code> is the waypoint positon.</p> </li> 
/// <li> <p>Leg 2: The <code>StartPosition</code> is the waypoint position. The <code>EndPosition</code> is the destination position.</p> </li> 
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Leg  {
    /// <p>The starting position of the leg. Follows the format <code>[longitude,latitude]</code>.</p> <note> 
    /// <p>If the <code>StartPosition</code> isn't located on a road, it's <a href="https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html">snapped to a nearby road</a>. </p> 
    /// </note>
    #[doc(hidden)]
    pub start_position: std::option::Option<std::vec::Vec<f64>>,
    /// <p>The terminating position of the leg. Follows the format <code>[longitude,latitude]</code>.</p> <note> 
    /// <p>If the <code>EndPosition</code> isn't located on a road, it's <a href="https://docs.aws.amazon.com/location/latest/developerguide/nap-to-nearby-road.html">snapped to a nearby road</a>. </p> 
    /// </note>
    #[doc(hidden)]
    pub end_position: std::option::Option<std::vec::Vec<f64>>,
    /// <p>The distance between the leg's <code>StartPosition</code> and <code>EndPosition</code> along a calculated route. </p> 
    /// <ul> 
    /// <li> <p>The default measurement is <code>Kilometers</code> unless the request specifies a <code>DistanceUnit</code> of <code>Miles</code>.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub distance: std::option::Option<f64>,
    /// <p>The estimated travel time between the leg's <code>StartPosition</code> and <code>EndPosition</code>. The travel mode and departure time that you specify in the request determines the calculated time.</p>
    #[doc(hidden)]
    pub duration_seconds: std::option::Option<f64>,
    /// <p>Contains the calculated route's path as a linestring geometry.</p>
    #[doc(hidden)]
    pub geometry: std::option::Option<crate::types::LegGeometry>,
    /// <p>Contains a list of steps, which represent subsections of a leg. Each step provides instructions for how to move to the next step in the leg such as the step's start position, end position, travel distance, travel duration, and geometry offset.</p>
    #[doc(hidden)]
    pub steps: std::option::Option<std::vec::Vec<crate::types::Step>>,
}
impl Leg {
    /// <p>The starting position of the leg. Follows the format <code>[longitude,latitude]</code>.</p> <note> 
    /// <p>If the <code>StartPosition</code> isn't located on a road, it's <a href="https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html">snapped to a nearby road</a>. </p> 
    /// </note>
    pub fn start_position(&self) -> std::option::Option<& [f64]> {
        self.start_position.as_deref()
    }
    /// <p>The terminating position of the leg. Follows the format <code>[longitude,latitude]</code>.</p> <note> 
    /// <p>If the <code>EndPosition</code> isn't located on a road, it's <a href="https://docs.aws.amazon.com/location/latest/developerguide/nap-to-nearby-road.html">snapped to a nearby road</a>. </p> 
    /// </note>
    pub fn end_position(&self) -> std::option::Option<& [f64]> {
        self.end_position.as_deref()
    }
    /// <p>The distance between the leg's <code>StartPosition</code> and <code>EndPosition</code> along a calculated route. </p> 
    /// <ul> 
    /// <li> <p>The default measurement is <code>Kilometers</code> unless the request specifies a <code>DistanceUnit</code> of <code>Miles</code>.</p> </li> 
    /// </ul>
    pub fn distance(&self) -> std::option::Option<f64> {
        self.distance
    }
    /// <p>The estimated travel time between the leg's <code>StartPosition</code> and <code>EndPosition</code>. The travel mode and departure time that you specify in the request determines the calculated time.</p>
    pub fn duration_seconds(&self) -> std::option::Option<f64> {
        self.duration_seconds
    }
    /// <p>Contains the calculated route's path as a linestring geometry.</p>
    pub fn geometry(&self) -> std::option::Option<& crate::types::LegGeometry> {
        self.geometry.as_ref()
    }
    /// <p>Contains a list of steps, which represent subsections of a leg. Each step provides instructions for how to move to the next step in the leg such as the step's start position, end position, travel distance, travel duration, and geometry offset.</p>
    pub fn steps(&self) -> std::option::Option<& [crate::types::Step]> {
        self.steps.as_deref()
    }
}
impl  std::fmt::Debug for Leg  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Leg");
        formatter.field("start_position", &"*** Sensitive Data Redacted ***");
        formatter.field("end_position", &"*** Sensitive Data Redacted ***");
        formatter.field("distance", &self.distance);
        formatter.field("duration_seconds", &self.duration_seconds);
        formatter.field("geometry", &self.geometry);
        formatter.field("steps", &self.steps);
        formatter.finish()
    }
}
impl Leg {
    /// Creates a new builder-style object to manufacture [`Leg`](crate::types::Leg).
    pub fn builder() -> crate::types::builders::LegBuilder {
        crate::types::builders::LegBuilder::default()
    }
}

/// A builder for [`Leg`](crate::types::Leg).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
pub struct LegBuilder {
    pub(crate) start_position: std::option::Option<std::vec::Vec<f64>>,
    pub(crate) end_position: std::option::Option<std::vec::Vec<f64>>,
    pub(crate) distance: std::option::Option<f64>,
    pub(crate) duration_seconds: std::option::Option<f64>,
    pub(crate) geometry: std::option::Option<crate::types::LegGeometry>,
    pub(crate) steps: std::option::Option<std::vec::Vec<crate::types::Step>>,
}
impl LegBuilder {
    /// Appends an item to `start_position`.
    ///
    /// To override the contents of this collection use [`set_start_position`](Self::set_start_position).
    ///
    /// <p>The starting position of the leg. Follows the format <code>[longitude,latitude]</code>.</p> <note> 
    /// <p>If the <code>StartPosition</code> isn't located on a road, it's <a href="https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html">snapped to a nearby road</a>. </p> 
    /// </note>
    pub fn start_position(mut self, input: f64) -> Self {
        let mut v = self.start_position.unwrap_or_default();
                        v.push(input);
                        self.start_position = Some(v);
                        self
    }
    /// <p>The starting position of the leg. Follows the format <code>[longitude,latitude]</code>.</p> <note> 
    /// <p>If the <code>StartPosition</code> isn't located on a road, it's <a href="https://docs.aws.amazon.com/location/latest/developerguide/snap-to-nearby-road.html">snapped to a nearby road</a>. </p> 
    /// </note>
    pub fn set_start_position(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
        self.start_position = input; self
    }
    /// Appends an item to `end_position`.
    ///
    /// To override the contents of this collection use [`set_end_position`](Self::set_end_position).
    ///
    /// <p>The terminating position of the leg. Follows the format <code>[longitude,latitude]</code>.</p> <note> 
    /// <p>If the <code>EndPosition</code> isn't located on a road, it's <a href="https://docs.aws.amazon.com/location/latest/developerguide/nap-to-nearby-road.html">snapped to a nearby road</a>. </p> 
    /// </note>
    pub fn end_position(mut self, input: f64) -> Self {
        let mut v = self.end_position.unwrap_or_default();
                        v.push(input);
                        self.end_position = Some(v);
                        self
    }
    /// <p>The terminating position of the leg. Follows the format <code>[longitude,latitude]</code>.</p> <note> 
    /// <p>If the <code>EndPosition</code> isn't located on a road, it's <a href="https://docs.aws.amazon.com/location/latest/developerguide/nap-to-nearby-road.html">snapped to a nearby road</a>. </p> 
    /// </note>
    pub fn set_end_position(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
        self.end_position = input; self
    }
    /// <p>The distance between the leg's <code>StartPosition</code> and <code>EndPosition</code> along a calculated route. </p> 
    /// <ul> 
    /// <li> <p>The default measurement is <code>Kilometers</code> unless the request specifies a <code>DistanceUnit</code> of <code>Miles</code>.</p> </li> 
    /// </ul>
    pub fn distance(mut self, input: f64) -> Self {
        self.distance = Some(input);
        self
    }
    /// <p>The distance between the leg's <code>StartPosition</code> and <code>EndPosition</code> along a calculated route. </p> 
    /// <ul> 
    /// <li> <p>The default measurement is <code>Kilometers</code> unless the request specifies a <code>DistanceUnit</code> of <code>Miles</code>.</p> </li> 
    /// </ul>
    pub fn set_distance(mut self, input: std::option::Option<f64>) -> Self {
        self.distance = input; self
    }
    /// <p>The estimated travel time between the leg's <code>StartPosition</code> and <code>EndPosition</code>. The travel mode and departure time that you specify in the request determines the calculated time.</p>
    pub fn duration_seconds(mut self, input: f64) -> Self {
        self.duration_seconds = Some(input);
        self
    }
    /// <p>The estimated travel time between the leg's <code>StartPosition</code> and <code>EndPosition</code>. The travel mode and departure time that you specify in the request determines the calculated time.</p>
    pub fn set_duration_seconds(mut self, input: std::option::Option<f64>) -> Self {
        self.duration_seconds = input; self
    }
    /// <p>Contains the calculated route's path as a linestring geometry.</p>
    pub fn geometry(mut self, input: crate::types::LegGeometry) -> Self {
        self.geometry = Some(input);
        self
    }
    /// <p>Contains the calculated route's path as a linestring geometry.</p>
    pub fn set_geometry(mut self, input: std::option::Option<crate::types::LegGeometry>) -> Self {
        self.geometry = input; self
    }
    /// Appends an item to `steps`.
    ///
    /// To override the contents of this collection use [`set_steps`](Self::set_steps).
    ///
    /// <p>Contains a list of steps, which represent subsections of a leg. Each step provides instructions for how to move to the next step in the leg such as the step's start position, end position, travel distance, travel duration, and geometry offset.</p>
    pub fn steps(mut self, input: crate::types::Step) -> Self {
        let mut v = self.steps.unwrap_or_default();
                        v.push(input);
                        self.steps = Some(v);
                        self
    }
    /// <p>Contains a list of steps, which represent subsections of a leg. Each step provides instructions for how to move to the next step in the leg such as the step's start position, end position, travel distance, travel duration, and geometry offset.</p>
    pub fn set_steps(mut self, input: std::option::Option<std::vec::Vec<crate::types::Step>>) -> Self {
        self.steps = input; self
    }
    /// Consumes the builder and constructs a [`Leg`](crate::types::Leg).
    pub fn build(self) -> crate::types::Leg {
        crate::types::Leg {
            start_position: self.start_position
            ,
            end_position: self.end_position
            ,
            distance: self.distance
            ,
            duration_seconds: self.duration_seconds
            ,
            geometry: self.geometry
            ,
            steps: self.steps
            ,
        }
    }
}
impl std::fmt::Debug for LegBuilder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LegBuilder");
        formatter.field("start_position", &"*** Sensitive Data Redacted ***");
        formatter.field("end_position", &"*** Sensitive Data Redacted ***");
        formatter.field("distance", &self.distance);
        formatter.field("duration_seconds", &self.duration_seconds);
        formatter.field("geometry", &self.geometry);
        formatter.field("steps", &self.steps);
        formatter.finish()
    }
}

