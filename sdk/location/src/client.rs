// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn associate_tracker_consumer(&self) -> fluent_builders::AssociateTrackerConsumer<C> {
        fluent_builders::AssociateTrackerConsumer::new(self.handle.clone())
    }
    pub fn batch_delete_device_position_history(
        &self,
    ) -> fluent_builders::BatchDeleteDevicePositionHistory<C> {
        fluent_builders::BatchDeleteDevicePositionHistory::new(self.handle.clone())
    }
    pub fn batch_delete_geofence(&self) -> fluent_builders::BatchDeleteGeofence<C> {
        fluent_builders::BatchDeleteGeofence::new(self.handle.clone())
    }
    pub fn batch_evaluate_geofences(&self) -> fluent_builders::BatchEvaluateGeofences<C> {
        fluent_builders::BatchEvaluateGeofences::new(self.handle.clone())
    }
    pub fn batch_get_device_position(&self) -> fluent_builders::BatchGetDevicePosition<C> {
        fluent_builders::BatchGetDevicePosition::new(self.handle.clone())
    }
    pub fn batch_put_geofence(&self) -> fluent_builders::BatchPutGeofence<C> {
        fluent_builders::BatchPutGeofence::new(self.handle.clone())
    }
    pub fn batch_update_device_position(&self) -> fluent_builders::BatchUpdateDevicePosition<C> {
        fluent_builders::BatchUpdateDevicePosition::new(self.handle.clone())
    }
    pub fn calculate_route(&self) -> fluent_builders::CalculateRoute<C> {
        fluent_builders::CalculateRoute::new(self.handle.clone())
    }
    pub fn create_geofence_collection(&self) -> fluent_builders::CreateGeofenceCollection<C> {
        fluent_builders::CreateGeofenceCollection::new(self.handle.clone())
    }
    pub fn create_map(&self) -> fluent_builders::CreateMap<C> {
        fluent_builders::CreateMap::new(self.handle.clone())
    }
    pub fn create_place_index(&self) -> fluent_builders::CreatePlaceIndex<C> {
        fluent_builders::CreatePlaceIndex::new(self.handle.clone())
    }
    pub fn create_route_calculator(&self) -> fluent_builders::CreateRouteCalculator<C> {
        fluent_builders::CreateRouteCalculator::new(self.handle.clone())
    }
    pub fn create_tracker(&self) -> fluent_builders::CreateTracker<C> {
        fluent_builders::CreateTracker::new(self.handle.clone())
    }
    pub fn delete_geofence_collection(&self) -> fluent_builders::DeleteGeofenceCollection<C> {
        fluent_builders::DeleteGeofenceCollection::new(self.handle.clone())
    }
    pub fn delete_map(&self) -> fluent_builders::DeleteMap<C> {
        fluent_builders::DeleteMap::new(self.handle.clone())
    }
    pub fn delete_place_index(&self) -> fluent_builders::DeletePlaceIndex<C> {
        fluent_builders::DeletePlaceIndex::new(self.handle.clone())
    }
    pub fn delete_route_calculator(&self) -> fluent_builders::DeleteRouteCalculator<C> {
        fluent_builders::DeleteRouteCalculator::new(self.handle.clone())
    }
    pub fn delete_tracker(&self) -> fluent_builders::DeleteTracker<C> {
        fluent_builders::DeleteTracker::new(self.handle.clone())
    }
    pub fn describe_geofence_collection(&self) -> fluent_builders::DescribeGeofenceCollection<C> {
        fluent_builders::DescribeGeofenceCollection::new(self.handle.clone())
    }
    pub fn describe_map(&self) -> fluent_builders::DescribeMap<C> {
        fluent_builders::DescribeMap::new(self.handle.clone())
    }
    pub fn describe_place_index(&self) -> fluent_builders::DescribePlaceIndex<C> {
        fluent_builders::DescribePlaceIndex::new(self.handle.clone())
    }
    pub fn describe_route_calculator(&self) -> fluent_builders::DescribeRouteCalculator<C> {
        fluent_builders::DescribeRouteCalculator::new(self.handle.clone())
    }
    pub fn describe_tracker(&self) -> fluent_builders::DescribeTracker<C> {
        fluent_builders::DescribeTracker::new(self.handle.clone())
    }
    pub fn disassociate_tracker_consumer(&self) -> fluent_builders::DisassociateTrackerConsumer<C> {
        fluent_builders::DisassociateTrackerConsumer::new(self.handle.clone())
    }
    pub fn get_device_position(&self) -> fluent_builders::GetDevicePosition<C> {
        fluent_builders::GetDevicePosition::new(self.handle.clone())
    }
    pub fn get_device_position_history(&self) -> fluent_builders::GetDevicePositionHistory<C> {
        fluent_builders::GetDevicePositionHistory::new(self.handle.clone())
    }
    pub fn get_geofence(&self) -> fluent_builders::GetGeofence<C> {
        fluent_builders::GetGeofence::new(self.handle.clone())
    }
    pub fn get_map_glyphs(&self) -> fluent_builders::GetMapGlyphs<C> {
        fluent_builders::GetMapGlyphs::new(self.handle.clone())
    }
    pub fn get_map_sprites(&self) -> fluent_builders::GetMapSprites<C> {
        fluent_builders::GetMapSprites::new(self.handle.clone())
    }
    pub fn get_map_style_descriptor(&self) -> fluent_builders::GetMapStyleDescriptor<C> {
        fluent_builders::GetMapStyleDescriptor::new(self.handle.clone())
    }
    pub fn get_map_tile(&self) -> fluent_builders::GetMapTile<C> {
        fluent_builders::GetMapTile::new(self.handle.clone())
    }
    pub fn list_device_positions(&self) -> fluent_builders::ListDevicePositions<C> {
        fluent_builders::ListDevicePositions::new(self.handle.clone())
    }
    pub fn list_geofence_collections(&self) -> fluent_builders::ListGeofenceCollections<C> {
        fluent_builders::ListGeofenceCollections::new(self.handle.clone())
    }
    pub fn list_geofences(&self) -> fluent_builders::ListGeofences<C> {
        fluent_builders::ListGeofences::new(self.handle.clone())
    }
    pub fn list_maps(&self) -> fluent_builders::ListMaps<C> {
        fluent_builders::ListMaps::new(self.handle.clone())
    }
    pub fn list_place_indexes(&self) -> fluent_builders::ListPlaceIndexes<C> {
        fluent_builders::ListPlaceIndexes::new(self.handle.clone())
    }
    pub fn list_route_calculators(&self) -> fluent_builders::ListRouteCalculators<C> {
        fluent_builders::ListRouteCalculators::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_tracker_consumers(&self) -> fluent_builders::ListTrackerConsumers<C> {
        fluent_builders::ListTrackerConsumers::new(self.handle.clone())
    }
    pub fn list_trackers(&self) -> fluent_builders::ListTrackers<C> {
        fluent_builders::ListTrackers::new(self.handle.clone())
    }
    pub fn put_geofence(&self) -> fluent_builders::PutGeofence<C> {
        fluent_builders::PutGeofence::new(self.handle.clone())
    }
    pub fn search_place_index_for_position(
        &self,
    ) -> fluent_builders::SearchPlaceIndexForPosition<C> {
        fluent_builders::SearchPlaceIndexForPosition::new(self.handle.clone())
    }
    pub fn search_place_index_for_text(&self) -> fluent_builders::SearchPlaceIndexForText<C> {
        fluent_builders::SearchPlaceIndexForText::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AssociateTrackerConsumer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_tracker_consumer_input::Builder,
    }
    impl<C> AssociateTrackerConsumer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateTrackerConsumerOutput,
            smithy_http::result::SdkError<crate::error::AssociateTrackerConsumerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the tracker resource to be associated with a geofence collection.</p>
        pub fn tracker_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(input);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the geofence collection to be associated to tracker
        /// resource. Used when you need to specify a resource across all AWS.</p>
        /// <ul>
        /// <li>
        /// <p>Format example:
        /// <code>arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn consumer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.consumer_arn(input);
            self
        }
        pub fn set_consumer_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_consumer_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchDeleteDevicePositionHistory<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_delete_device_position_history_input::Builder,
    }
    impl<C> BatchDeleteDevicePositionHistory<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchDeleteDevicePositionHistoryOutput,
            smithy_http::result::SdkError<crate::error::BatchDeleteDevicePositionHistoryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the tracker resource to delete the device position history from.</p>
        pub fn tracker_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(input);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// <p>Devices whose position history you want to delete.</p>
        /// <ul>
        /// <li>
        /// <p>For example, for two devices:
        /// <code>“DeviceIds” : [DeviceId1,DeviceId2]</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn device_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.device_ids(inp);
            self
        }
        pub fn set_device_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_device_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchDeleteGeofence<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_delete_geofence_input::Builder,
    }
    impl<C> BatchDeleteGeofence<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchDeleteGeofenceOutput,
            smithy_http::result::SdkError<crate::error::BatchDeleteGeofenceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The geofence collection storing the geofences to be deleted.</p>
        pub fn collection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_name(input);
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_name(input);
            self
        }
        /// <p>The batch of geofences to be deleted.</p>
        pub fn geofence_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.geofence_ids(inp);
            self
        }
        pub fn set_geofence_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_geofence_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchEvaluateGeofences<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_evaluate_geofences_input::Builder,
    }
    impl<C> BatchEvaluateGeofences<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchEvaluateGeofencesOutput,
            smithy_http::result::SdkError<crate::error::BatchEvaluateGeofencesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The geofence collection used in evaluating the position of devices against its
        /// geofences.</p>
        pub fn collection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_name(input);
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_name(input);
            self
        }
        /// <p>Contains device details for each device to be evaluated against the given geofence
        /// collection.</p>
        pub fn device_position_updates(
            mut self,
            inp: impl Into<crate::model::DevicePositionUpdate>,
        ) -> Self {
            self.inner = self.inner.device_position_updates(inp);
            self
        }
        pub fn set_device_position_updates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DevicePositionUpdate>>,
        ) -> Self {
            self.inner = self.inner.set_device_position_updates(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetDevicePosition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_device_position_input::Builder,
    }
    impl<C> BatchGetDevicePosition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetDevicePositionOutput,
            smithy_http::result::SdkError<crate::error::BatchGetDevicePositionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The tracker resource retrieving the device position.</p>
        pub fn tracker_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(input);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// <p>Devices whose position you want to retrieve.</p>
        /// <ul>
        /// <li>
        /// <p>For example, for two devices:
        /// <code>device-ids=DeviceId1&amp;device-ids=DeviceId2</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn device_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.device_ids(inp);
            self
        }
        pub fn set_device_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_device_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchPutGeofence<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_put_geofence_input::Builder,
    }
    impl<C> BatchPutGeofence<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchPutGeofenceOutput,
            smithy_http::result::SdkError<crate::error::BatchPutGeofenceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The geofence collection storing the geofences.</p>
        pub fn collection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_name(input);
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_name(input);
            self
        }
        /// <p>The batch of geofences to be stored in a geofence collection.</p>
        pub fn entries(
            mut self,
            inp: impl Into<crate::model::BatchPutGeofenceRequestEntry>,
        ) -> Self {
            self.inner = self.inner.entries(inp);
            self
        }
        pub fn set_entries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchPutGeofenceRequestEntry>>,
        ) -> Self {
            self.inner = self.inner.set_entries(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchUpdateDevicePosition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_update_device_position_input::Builder,
    }
    impl<C> BatchUpdateDevicePosition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchUpdateDevicePositionOutput,
            smithy_http::result::SdkError<crate::error::BatchUpdateDevicePositionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the tracker resource to update.</p>
        pub fn tracker_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(input);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// <p>Contains the position update details for each device.</p>
        pub fn updates(mut self, inp: impl Into<crate::model::DevicePositionUpdate>) -> Self {
            self.inner = self.inner.updates(inp);
            self
        }
        pub fn set_updates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DevicePositionUpdate>>,
        ) -> Self {
            self.inner = self.inner.set_updates(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CalculateRoute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::calculate_route_input::Builder,
    }
    impl<C> CalculateRoute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CalculateRouteOutput,
            smithy_http::result::SdkError<crate::error::CalculateRouteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the route calculator resource that you want to use to calculate a route. </p>
        pub fn calculator_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.calculator_name(input);
            self
        }
        pub fn set_calculator_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_calculator_name(input);
            self
        }
        /// <p>The start position for the route. Defined in <a href="https://earth-info.nga.mil/GandG/wgs84/index.html">WGS 84</a> format:
        /// <code>[longitude, latitude]</code>.</p>
        /// <ul>
        /// <li>
        /// <p>For example, <code>[-123.115, 49.285]</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>If you specify a departure that's not located on a road, Amazon Location <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#snap-to-nearby-road">moves the
        /// position to the nearest road</a>.</p>
        /// </note>
        /// <p>Valid Values: <code>[-180 to 180,-90 to 90]</code>
        /// </p>
        pub fn departure_position(mut self, inp: impl Into<f64>) -> Self {
            self.inner = self.inner.departure_position(inp);
            self
        }
        pub fn set_departure_position(
            mut self,
            input: std::option::Option<std::vec::Vec<f64>>,
        ) -> Self {
            self.inner = self.inner.set_departure_position(input);
            self
        }
        /// <p>The finish position for the route. Defined in <a href="https://earth-info.nga.mil/GandG/wgs84/index.html">WGS 84</a> format:
        /// <code>[longitude, latitude]</code>.</p>
        /// <ul>
        /// <li>
        /// <p> For example, <code>[-122.339, 47.615]</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>If you specify a destination that's not located on a road, Amazon Location <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#snap-to-nearby-road">moves the position to the nearest road</a>. </p>
        /// </note>
        /// <p>Valid Values: <code>[-180 to 180,-90 to 90]</code>
        /// </p>
        pub fn destination_position(mut self, inp: impl Into<f64>) -> Self {
            self.inner = self.inner.destination_position(inp);
            self
        }
        pub fn set_destination_position(
            mut self,
            input: std::option::Option<std::vec::Vec<f64>>,
        ) -> Self {
            self.inner = self.inner.set_destination_position(input);
            self
        }
        /// <p>Specifies an ordered list of up to 23 intermediate positions to include along a route
        /// between the departure position and destination position. </p>
        /// <ul>
        /// <li>
        /// <p>For example, from the <code>DeparturePosition</code>
        /// <code>[-123.115, 49.285]</code>, the route follows the order that the waypoint
        /// positions are given <code>[[-122.757, 49.0021],[-122.349, 47.620]]</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>If you specify a waypoint position that's not located on a road, Amazon Location <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#snap-to-nearby-road">moves the position to the nearest road</a>. </p>
        /// <p>Specifying more than 23 waypoints returns a <code>400 ValidationException</code>
        /// error.</p>
        /// </note>
        /// <p>Valid Values: <code>[-180 to 180,-90 to 90]</code>
        /// </p>
        pub fn waypoint_positions(mut self, inp: impl Into<std::vec::Vec<f64>>) -> Self {
            self.inner = self.inner.waypoint_positions(inp);
            self
        }
        pub fn set_waypoint_positions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<f64>>>,
        ) -> Self {
            self.inner = self.inner.set_waypoint_positions(input);
            self
        }
        /// <p>Specifies the mode of transport when calculating a route. Used in estimating the speed
        /// of travel and road compatibility.</p>
        /// <p>The <code>TravelMode</code> you specify determines how you specify route preferences: </p>
        /// <ul>
        /// <li>
        /// <p>If traveling by <code>Car</code> use the <code>CarModeOptions</code>
        /// parameter.</p>
        /// </li>
        /// <li>
        /// <p>If traveling by <code>Truck</code> use the <code>TruckModeOptions</code>
        /// parameter.</p>
        /// </li>
        /// </ul>
        /// <p>Default Value: <code>Car</code>
        /// </p>
        pub fn travel_mode(mut self, input: crate::model::TravelMode) -> Self {
            self.inner = self.inner.travel_mode(input);
            self
        }
        pub fn set_travel_mode(
            mut self,
            input: std::option::Option<crate::model::TravelMode>,
        ) -> Self {
            self.inner = self.inner.set_travel_mode(input);
            self
        }
        /// <p>Specifies the desired time of departure. Uses the given time to calculate a route.
        /// Otherwise, the best time of day to travel with the best traffic conditions is used to
        /// calculate the route.</p>
        /// <note>
        /// <p>Setting a departure time in the past returns a <code>400
        /// ValidationException</code> error.</p>
        /// </note>
        /// <ul>
        /// <li>
        /// <p>In <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO
        /// 8601</a> format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. For example,
        /// <code>2020–07-2T12:15:20.000Z+01:00</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn departure_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.departure_time(input);
            self
        }
        pub fn set_departure_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_departure_time(input);
            self
        }
        /// <p>Sets the time of departure as the current time. Uses the current time to calculate a
        /// route. Otherwise, the best time of day to travel with the best traffic conditions is
        /// used to calculate the route.</p>
        /// <p>Default Value: <code>false</code>
        /// </p>
        /// <p>Valid Values: <code>false</code> | <code>true</code>
        /// </p>
        pub fn depart_now(mut self, input: bool) -> Self {
            self.inner = self.inner.depart_now(input);
            self
        }
        pub fn set_depart_now(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_depart_now(input);
            self
        }
        /// <p>Set the unit system to specify the distance.</p>
        /// <p>Default Value: <code>Kilometers</code>
        /// </p>
        pub fn distance_unit(mut self, input: crate::model::DistanceUnit) -> Self {
            self.inner = self.inner.distance_unit(input);
            self
        }
        pub fn set_distance_unit(
            mut self,
            input: std::option::Option<crate::model::DistanceUnit>,
        ) -> Self {
            self.inner = self.inner.set_distance_unit(input);
            self
        }
        /// <p>Set to include the geometry details in the result for each path between a pair of
        /// positions.</p>
        /// <p>Default Value: <code>false</code>
        /// </p>
        /// <p>Valid Values: <code>false</code> | <code>true</code>
        /// </p>
        pub fn include_leg_geometry(mut self, input: bool) -> Self {
            self.inner = self.inner.include_leg_geometry(input);
            self
        }
        pub fn set_include_leg_geometry(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_leg_geometry(input);
            self
        }
        /// <p>Specifies route preferences when traveling by <code>Car</code>, such as avoiding
        /// routes that use ferries or tolls.</p>
        /// <p>Requirements: <code>TravelMode</code> must be specified as <code>Car</code>.</p>
        pub fn car_mode_options(
            mut self,
            input: crate::model::CalculateRouteCarModeOptions,
        ) -> Self {
            self.inner = self.inner.car_mode_options(input);
            self
        }
        pub fn set_car_mode_options(
            mut self,
            input: std::option::Option<crate::model::CalculateRouteCarModeOptions>,
        ) -> Self {
            self.inner = self.inner.set_car_mode_options(input);
            self
        }
        /// <p>Specifies route preferences when traveling by <code>Truck</code>, such as avoiding
        /// routes that use ferries or tolls, and truck specifications to consider when choosing an
        /// optimal road.</p>
        /// <p>Requirements: <code>TravelMode</code> must be specified as <code>Truck</code>.</p>
        pub fn truck_mode_options(
            mut self,
            input: crate::model::CalculateRouteTruckModeOptions,
        ) -> Self {
            self.inner = self.inner.truck_mode_options(input);
            self
        }
        pub fn set_truck_mode_options(
            mut self,
            input: std::option::Option<crate::model::CalculateRouteTruckModeOptions>,
        ) -> Self {
            self.inner = self.inner.set_truck_mode_options(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateGeofenceCollection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_geofence_collection_input::Builder,
    }
    impl<C> CreateGeofenceCollection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateGeofenceCollectionOutput,
            smithy_http::result::SdkError<crate::error::CreateGeofenceCollectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A custom name for the geofence collection.</p>
        /// <p>Requirements:</p>
        /// <ul>
        /// <li>
        /// <p>Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods
        /// (.), and underscores (_). </p>
        /// </li>
        /// <li>
        /// <p>Must be a unique geofence collection name.</p>
        /// </li>
        /// <li>
        /// <p>No spaces allowed. For example, <code>ExampleGeofenceCollection</code>.</p>
        /// </li>
        /// </ul>
        pub fn collection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_name(input);
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_name(input);
            self
        }
        /// <p>Specifies the pricing plan for the geofence collection.</p>
        /// <p>For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
        /// page</a>.</p>
        pub fn pricing_plan(mut self, input: crate::model::PricingPlan) -> Self {
            self.inner = self.inner.pricing_plan(input);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan(input);
            self
        }
        /// <p>Specifies the data provider for the geofence collection.</p>
        /// <ul>
        /// <li>
        /// <p>Required value for the following pricing plans: <code>MobileAssetTracking
        /// </code>| <code>MobileAssetManagement</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For more information about <a href="https://aws.amazon.com/location/data-providers/">Data Providers</a>, and <a href="https://aws.amazon.com/location/pricing/">Pricing plans</a>, see the Amazon Location
        /// Service product page.</p>
        /// <note>
        /// <p>Amazon Location Service only uses <code>PricingPlanDataSource</code> to calculate billing for
        /// your geofence collection. Your data won't be shared with the data provider, and will
        /// remain in your AWS account or Region unless you move it.</p>
        /// </note>
        /// <p>Valid Values: <code>Esri </code>| <code>Here</code>
        /// </p>
        pub fn pricing_plan_data_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pricing_plan_data_source(input);
            self
        }
        pub fn set_pricing_plan_data_source(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan_data_source(input);
            self
        }
        /// <p>An optional description for the geofence collection.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Applies one or more tags to the geofence collection. A tag is a key-value pair helps
        /// manage, identify, search, and filter your resources by labelling them.</p>
        /// <p>Format: <code>"key" : "value"</code>
        /// </p>
        /// <p>Restrictions:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum 50 tags per resource</p>
        /// </li>
        /// <li>
        /// <p>Each resource tag must be unique with a maximum of one value.</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length: 128 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length: 256 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters:
        /// + - = . _ : / @. </p>
        /// </li>
        /// </ul>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>A key identifier for an <a href="https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html">AWS KMS customer managed key</a>. Enter a key ID, key ARN, alias name, or alias ARN.
        /// </p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(input);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateMap<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_map_input::Builder,
    }
    impl<C> CreateMap<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateMapOutput,
            smithy_http::result::SdkError<crate::error::CreateMapError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name for the map resource.</p>
        /// <p>Requirements:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_). </p>
        /// </li>
        /// <li>
        /// <p>Must be a unique map resource name. </p>
        /// </li>
        /// <li>
        /// <p>No spaces allowed. For example, <code>ExampleMap</code>.</p>
        /// </li>
        /// </ul>
        pub fn map_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.map_name(input);
            self
        }
        pub fn set_map_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_map_name(input);
            self
        }
        /// <p>Specifies the map style selected from an available data provider.</p>
        pub fn configuration(mut self, input: crate::model::MapConfiguration) -> Self {
            self.inner = self.inner.configuration(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::MapConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
        /// <p>Specifies the pricing plan for your map resource.</p>
        /// <p>For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
        /// page</a>.</p>
        pub fn pricing_plan(mut self, input: crate::model::PricingPlan) -> Self {
            self.inner = self.inner.pricing_plan(input);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan(input);
            self
        }
        /// <p>An optional description for the map resource.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Applies one or more tags to the map resource. A tag is a key-value pair helps manage,
        /// identify, search, and filter your resources by labelling them.</p>
        /// <p>Format: <code>"key" : "value"</code>
        /// </p>
        /// <p>Restrictions:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum 50 tags per resource</p>
        /// </li>
        /// <li>
        /// <p>Each resource tag must be unique with a maximum of one value.</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length: 128 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length:  256 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : /
        /// @. </p>
        /// </li>
        /// </ul>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePlaceIndex<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_place_index_input::Builder,
    }
    impl<C> CreatePlaceIndex<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePlaceIndexOutput,
            smithy_http::result::SdkError<crate::error::CreatePlaceIndexError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the place index resource. </p>
        /// <p>Requirements:</p>
        /// <ul>
        /// <li>
        /// <p>Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and
        /// underscores (_).</p>
        /// </li>
        /// <li>
        /// <p>Must be a unique place index resource name.</p>
        /// </li>
        /// <li>
        /// <p>No spaces allowed. For example, <code>ExamplePlaceIndex</code>.</p>
        /// </li>
        /// </ul>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_name(input);
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_name(input);
            self
        }
        /// <p>Specifies the data provider of geospatial data.</p>
        /// <note>
        /// <p>This field is case-sensitive. Enter the valid values as shown. For example, entering
        /// <code>HERE</code> will return an error.</p>
        /// </note>
        /// <p>Valid values include:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Esri</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Here</code>
        /// </p>
        /// <important>
        /// <p>Place index resources using HERE as a data provider can't be used to <a href="https://docs.aws.amazon.com/location-places/latest/APIReference/API_DataSourceConfiguration.html">store</a>
        /// results for locations in Japan. For more information, see the <a href="https://aws.amazon.com/service-terms/">AWS Service Terms</a> for
        /// Amazon Location Service.</p>
        /// </important>
        /// </li>
        /// </ul>
        /// <p>For additional details on data providers, see the <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Amazon Location Service data providers page</a>.</p>
        pub fn data_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.data_source(input);
            self
        }
        pub fn set_data_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_data_source(input);
            self
        }
        /// <p>Specifies the pricing plan for your place index resource.</p>
        /// <p>For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
        /// page</a>.</p>
        pub fn pricing_plan(mut self, input: crate::model::PricingPlan) -> Self {
            self.inner = self.inner.pricing_plan(input);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan(input);
            self
        }
        /// <p>The optional description for the place index resource.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Specifies the data storage option for requesting Places.</p>
        pub fn data_source_configuration(
            mut self,
            input: crate::model::DataSourceConfiguration,
        ) -> Self {
            self.inner = self.inner.data_source_configuration(input);
            self
        }
        pub fn set_data_source_configuration(
            mut self,
            input: std::option::Option<crate::model::DataSourceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_data_source_configuration(input);
            self
        }
        /// <p>Applies one or more tags to the place index resource. A tag is a key-value pair helps
        /// manage, identify, search, and filter your resources by labelling them.</p>
        /// <p>Format: <code>"key" : "value"</code>
        /// </p>
        /// <p>Restrictions:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum 50 tags per resource</p>
        /// </li>
        /// <li>
        /// <p>Each resource tag must be unique with a maximum of one value.</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length: 128 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length: 256 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + -
        /// = . _ : / @. </p>
        /// </li>
        /// </ul>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRouteCalculator<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_route_calculator_input::Builder,
    }
    impl<C> CreateRouteCalculator<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRouteCalculatorOutput,
            smithy_http::result::SdkError<crate::error::CreateRouteCalculatorError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the route calculator resource. </p>
        /// <p>Requirements:</p>
        /// <ul>
        /// <li>
        /// <p>Can use alphanumeric characters (A–Z, a–z, 0–9) , hyphens (-), periods (.), and underscores
        /// (_).</p>
        /// </li>
        /// <li>
        /// <p>Must be a unique Route calculator resource name.</p>
        /// </li>
        /// <li>
        /// <p>No spaces allowed. For example, <code>ExampleRouteCalculator</code>.</p>
        /// </li>
        /// </ul>
        pub fn calculator_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.calculator_name(input);
            self
        }
        pub fn set_calculator_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_calculator_name(input);
            self
        }
        /// <p>Specifies the data provider of traffic and road network data.</p>
        /// <note>
        /// <p>This field is case-sensitive. Enter the valid values as shown. For example,
        /// entering <code>HERE</code> returns an error.</p>
        /// </note>
        /// <p>Valid Values: <code>Esri</code> | <code>Here</code>
        /// </p>
        /// <p>For more information about data providers, see <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Amazon Location Service data providers</a>.</p>
        pub fn data_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.data_source(input);
            self
        }
        pub fn set_data_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_data_source(input);
            self
        }
        /// <p>Specifies the pricing plan for your route calculator resource.</p>
        /// <p>For additional details and restrictions on each pricing plan option, see <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing</a>.</p>
        pub fn pricing_plan(mut self, input: crate::model::PricingPlan) -> Self {
            self.inner = self.inner.pricing_plan(input);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan(input);
            self
        }
        /// <p>The optional description for the route calculator resource.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Applies one or more tags to the route calculator resource. A tag is a key-value pair
        /// helps manage, identify, search, and filter your resources by labelling them.</p>
        /// <ul>
        /// <li>
        /// <p>For example: { <code>"tag1" : "value1"</code>, <code>"tag2" :
        /// "value2"</code>}</p>
        /// </li>
        /// </ul>
        /// <p>Format: <code>"key" : "value"</code>
        /// </p>
        /// <p>Restrictions:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum 50 tags per resource</p>
        /// </li>
        /// <li>
        /// <p>Each resource tag must be unique with a maximum of one value.</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length: 128 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length: 256 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters:
        /// + - = . _ : / @. </p>
        /// </li>
        /// </ul>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTracker<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_tracker_input::Builder,
    }
    impl<C> CreateTracker<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTrackerOutput,
            smithy_http::result::SdkError<crate::error::CreateTrackerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name for the tracker resource.</p>
        /// <p>Requirements:</p>
        /// <ul>
        /// <li>
        /// <p>Contain only alphanumeric characters (A-Z, a-z, 0-9) , hyphens (-), periods (.), and underscores (_).</p>
        /// </li>
        /// <li>
        /// <p>Must be a unique tracker resource name.</p>
        /// </li>
        /// <li>
        /// <p>No spaces allowed. For example, <code>ExampleTracker</code>.</p>
        /// </li>
        /// </ul>
        pub fn tracker_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(input);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// <p>Specifies the pricing plan for the tracker resource.</p>
        /// <p>For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
        /// page</a>.</p>
        pub fn pricing_plan(mut self, input: crate::model::PricingPlan) -> Self {
            self.inner = self.inner.pricing_plan(input);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan(input);
            self
        }
        /// <p>A key identifier for an <a href="https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html">AWS KMS customer managed key</a>. Enter a key ID, key ARN, alias name, or alias ARN.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(input);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
        /// <p>Specifies the data provider for the tracker resource.</p>
        /// <ul>
        /// <li>
        /// <p>Required value for the following pricing plans: <code>MobileAssetTracking
        /// </code>| <code>MobileAssetManagement</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For more information about <a href="https://aws.amazon.com/location/data-providers/">Data Providers</a>, and <a href="https://aws.amazon.com/location/pricing/">Pricing plans</a>, see the Amazon Location
        /// Service product page.</p>
        /// <note>
        /// <p>Amazon Location Service only uses <code>PricingPlanDataSource</code> to calculate billing for your tracker resource. Your data will not be shared with the data provider, and will remain in your AWS account or Region unless you move it.</p>
        /// </note>
        /// <p>Valid Values: <code>Esri</code> | <code>Here</code>
        /// </p>
        pub fn pricing_plan_data_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pricing_plan_data_source(input);
            self
        }
        pub fn set_pricing_plan_data_source(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan_data_source(input);
            self
        }
        /// <p>An optional description for the tracker resource.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Applies one or more tags to the tracker resource. A tag is a key-value pair helps
        /// manage, identify, search, and filter your resources by labelling them.</p>
        /// <p>Format: <code>"key" : "value"</code>
        /// </p>
        /// <p>Restrictions:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum 50 tags per resource</p>
        /// </li>
        /// <li>
        /// <p>Each resource tag must be unique with a maximum of one value.</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length: 128 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length: 256 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters:
        /// + - = . _ : / @. </p>
        /// </li>
        /// </ul>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteGeofenceCollection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_geofence_collection_input::Builder,
    }
    impl<C> DeleteGeofenceCollection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteGeofenceCollectionOutput,
            smithy_http::result::SdkError<crate::error::DeleteGeofenceCollectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the geofence collection to be deleted.</p>
        pub fn collection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_name(input);
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteMap<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_map_input::Builder,
    }
    impl<C> DeleteMap<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteMapOutput,
            smithy_http::result::SdkError<crate::error::DeleteMapError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the map resource to be deleted.</p>
        pub fn map_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.map_name(input);
            self
        }
        pub fn set_map_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_map_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePlaceIndex<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_place_index_input::Builder,
    }
    impl<C> DeletePlaceIndex<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePlaceIndexOutput,
            smithy_http::result::SdkError<crate::error::DeletePlaceIndexError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the place index resource to be deleted.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_name(input);
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRouteCalculator<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_route_calculator_input::Builder,
    }
    impl<C> DeleteRouteCalculator<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRouteCalculatorOutput,
            smithy_http::result::SdkError<crate::error::DeleteRouteCalculatorError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the route calculator resource to be deleted.</p>
        pub fn calculator_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.calculator_name(input);
            self
        }
        pub fn set_calculator_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_calculator_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTracker<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_tracker_input::Builder,
    }
    impl<C> DeleteTracker<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTrackerOutput,
            smithy_http::result::SdkError<crate::error::DeleteTrackerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the tracker resource to be deleted.</p>
        pub fn tracker_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(input);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeGeofenceCollection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_geofence_collection_input::Builder,
    }
    impl<C> DescribeGeofenceCollection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeGeofenceCollectionOutput,
            smithy_http::result::SdkError<crate::error::DescribeGeofenceCollectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the geofence collection.</p>
        pub fn collection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_name(input);
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeMap<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_map_input::Builder,
    }
    impl<C> DescribeMap<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeMapOutput,
            smithy_http::result::SdkError<crate::error::DescribeMapError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the map resource.</p>
        pub fn map_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.map_name(input);
            self
        }
        pub fn set_map_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_map_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribePlaceIndex<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_place_index_input::Builder,
    }
    impl<C> DescribePlaceIndex<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribePlaceIndexOutput,
            smithy_http::result::SdkError<crate::error::DescribePlaceIndexError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the place index resource.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_name(input);
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeRouteCalculator<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_route_calculator_input::Builder,
    }
    impl<C> DescribeRouteCalculator<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeRouteCalculatorOutput,
            smithy_http::result::SdkError<crate::error::DescribeRouteCalculatorError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the route calculator resource.</p>
        pub fn calculator_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.calculator_name(input);
            self
        }
        pub fn set_calculator_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_calculator_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTracker<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_tracker_input::Builder,
    }
    impl<C> DescribeTracker<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTrackerOutput,
            smithy_http::result::SdkError<crate::error::DescribeTrackerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the tracker resource.</p>
        pub fn tracker_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(input);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateTrackerConsumer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_tracker_consumer_input::Builder,
    }
    impl<C> DisassociateTrackerConsumer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateTrackerConsumerOutput,
            smithy_http::result::SdkError<crate::error::DisassociateTrackerConsumerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the tracker resource to be dissociated from the consumer.</p>
        pub fn tracker_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(input);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the geofence collection to be disassociated from
        /// the tracker resource. Used when you need to specify a resource across all AWS. </p>
        /// <ul>
        /// <li>
        /// <p>Format example:
        /// <code>arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn consumer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.consumer_arn(input);
            self
        }
        pub fn set_consumer_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_consumer_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDevicePosition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_device_position_input::Builder,
    }
    impl<C> GetDevicePosition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDevicePositionOutput,
            smithy_http::result::SdkError<crate::error::GetDevicePositionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The tracker resource receiving the position update.</p>
        pub fn tracker_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(input);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// <p>The device whose position you want to retrieve.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.device_id(input);
            self
        }
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_device_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDevicePositionHistory<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_device_position_history_input::Builder,
    }
    impl<C> GetDevicePositionHistory<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDevicePositionHistoryOutput,
            smithy_http::result::SdkError<crate::error::GetDevicePositionHistoryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The tracker resource receiving the request for the device position history.</p>
        pub fn tracker_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(input);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// <p>The device whose position history you want to retrieve.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.device_id(input);
            self
        }
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_device_id(input);
            self
        }
        /// <p>The pagination token specifying which page of results to return in the response. If no
        /// token is provided, the default page is the first page. </p>
        /// <p>Default value: <code>null</code>
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Specify the start time for the position history in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. By default, the value will be 24 hours
        /// prior to the time that the request is made.</p>
        /// <p>Requirement:</p>
        /// <ul>
        /// <li>
        /// <p>The time specified for <code>StartTimeInclusive</code> must be before
        /// <code>EndTimeExclusive</code>.</p>
        /// </li>
        /// </ul>
        pub fn start_time_inclusive(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time_inclusive(input);
            self
        }
        pub fn set_start_time_inclusive(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_start_time_inclusive(input);
            self
        }
        /// <p>Specify the end time for the position history in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. By default, the value will be the time
        /// that the request is made.</p>
        /// <p>Requirement:</p>
        /// <ul>
        /// <li>
        /// <p>The time specified for <code>EndTimeExclusive</code> must be after the time for
        /// <code>StartTimeInclusive</code>.</p>
        /// </li>
        /// </ul>
        pub fn end_time_exclusive(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time_exclusive(input);
            self
        }
        pub fn set_end_time_exclusive(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_end_time_exclusive(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetGeofence<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_geofence_input::Builder,
    }
    impl<C> GetGeofence<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetGeofenceOutput,
            smithy_http::result::SdkError<crate::error::GetGeofenceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The geofence collection storing the target geofence.</p>
        pub fn collection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_name(input);
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_name(input);
            self
        }
        /// <p>The geofence you're retrieving details for.</p>
        pub fn geofence_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.geofence_id(input);
            self
        }
        pub fn set_geofence_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_geofence_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMapGlyphs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_map_glyphs_input::Builder,
    }
    impl<C> GetMapGlyphs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMapGlyphsOutput,
            smithy_http::result::SdkError<crate::error::GetMapGlyphsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The map resource associated with the glyph ﬁle.</p>
        pub fn map_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.map_name(input);
            self
        }
        pub fn set_map_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_map_name(input);
            self
        }
        /// <p>A comma-separated list of fonts to load glyphs from in order of preference.. For
        /// example, <code>Noto Sans, Arial Unicode</code>.</p>
        pub fn font_stack(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.font_stack(input);
            self
        }
        pub fn set_font_stack(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_font_stack(input);
            self
        }
        /// <p>A Unicode range of characters to download glyphs for. Each response will contain 256
        /// characters. For example, 0–255 includes all characters from range <code>U+0000</code> to
        /// <code>00FF</code>. Must be aligned to multiples of 256.</p>
        pub fn font_unicode_range(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.font_unicode_range(input);
            self
        }
        pub fn set_font_unicode_range(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_font_unicode_range(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMapSprites<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_map_sprites_input::Builder,
    }
    impl<C> GetMapSprites<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMapSpritesOutput,
            smithy_http::result::SdkError<crate::error::GetMapSpritesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The map resource associated with the sprite ﬁle.</p>
        pub fn map_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.map_name(input);
            self
        }
        pub fn set_map_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_map_name(input);
            self
        }
        /// <p>The name of the sprite ﬁle. Use the following ﬁle names for the sprite sheet:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>sprites.png</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>sprites@2x.png</code> for high pixel density displays</p>
        /// </li>
        /// </ul>
        /// <p>For the JSON document contain image offsets. Use the following ﬁle names:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>sprites.json</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>sprites@2x.json</code> for high pixel density displays</p>
        /// </li>
        /// </ul>
        pub fn file_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_name(input);
            self
        }
        pub fn set_file_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_file_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMapStyleDescriptor<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_map_style_descriptor_input::Builder,
    }
    impl<C> GetMapStyleDescriptor<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMapStyleDescriptorOutput,
            smithy_http::result::SdkError<crate::error::GetMapStyleDescriptorError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The map resource to retrieve the style descriptor from.</p>
        pub fn map_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.map_name(input);
            self
        }
        pub fn set_map_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_map_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMapTile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_map_tile_input::Builder,
    }
    impl<C> GetMapTile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMapTileOutput,
            smithy_http::result::SdkError<crate::error::GetMapTileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The map resource to retrieve the map tiles from.</p>
        pub fn map_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.map_name(input);
            self
        }
        pub fn set_map_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_map_name(input);
            self
        }
        /// <p>The zoom value for the map tile.</p>
        pub fn z(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.z(input);
            self
        }
        pub fn set_z(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_z(input);
            self
        }
        /// <p>The X axis value for the map tile.</p>
        pub fn x(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.x(input);
            self
        }
        pub fn set_x(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_x(input);
            self
        }
        /// <p>The Y axis value for the map tile. </p>
        pub fn y(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.y(input);
            self
        }
        pub fn set_y(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_y(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDevicePositions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_device_positions_input::Builder,
    }
    impl<C> ListDevicePositions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDevicePositionsOutput,
            smithy_http::result::SdkError<crate::error::ListDevicePositionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The tracker resource containing the requested devices.</p>
        pub fn tracker_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(input);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// <p>An optional limit for the number of entries returned in a single call.</p>
        /// <p>Default value: <code>100</code>
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token specifying which page of results to return in the response. If no
        /// token is provided, the default page is the first page.</p>
        /// <p>Default value: <code>null</code>
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListGeofenceCollections<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_geofence_collections_input::Builder,
    }
    impl<C> ListGeofenceCollections<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListGeofenceCollectionsOutput,
            smithy_http::result::SdkError<crate::error::ListGeofenceCollectionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional limit for the number of resources returned in a single call. </p>
        /// <p>Default value: <code>100</code>
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token specifying which page of results to return in the response. If no
        /// token is provided, the default page is the first page. </p>
        /// <p>Default value: <code>null</code>
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListGeofences<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_geofences_input::Builder,
    }
    impl<C> ListGeofences<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListGeofencesOutput,
            smithy_http::result::SdkError<crate::error::ListGeofencesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the geofence collection storing the list of geofences.</p>
        pub fn collection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_name(input);
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_name(input);
            self
        }
        /// <p>The pagination token specifying which page of results to return in the response. If no
        /// token is provided, the default page is the first page. </p>
        /// <p>Default value: <code>null</code>
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListMaps<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_maps_input::Builder,
    }
    impl<C> ListMaps<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListMapsOutput,
            smithy_http::result::SdkError<crate::error::ListMapsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional limit for the number of resources returned in a single call. </p>
        /// <p>Default value: <code>100</code>
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token specifying which page of results to return in the response. If no
        /// token is provided, the default page is the first page.</p>
        /// <p>Default value: <code>null</code>
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPlaceIndexes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_place_indexes_input::Builder,
    }
    impl<C> ListPlaceIndexes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPlaceIndexesOutput,
            smithy_http::result::SdkError<crate::error::ListPlaceIndexesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional limit for the maximum number of results returned in a single call.</p>
        /// <p>Default value: <code>100</code>
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token specifying which page of results to return in the response. If no
        /// token is provided, the default page is the first page.</p>
        /// <p>Default value: <code>null</code>
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRouteCalculators<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_route_calculators_input::Builder,
    }
    impl<C> ListRouteCalculators<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRouteCalculatorsOutput,
            smithy_http::result::SdkError<crate::error::ListRouteCalculatorsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional maximum number of results returned in a single call.</p>
        /// <p>Default Value: <code>100</code>
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token specifying which page of results to return in the response. If no
        /// token is provided, the default page is the first page.</p>
        /// <p>Default Value: <code>null</code>
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTrackerConsumers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tracker_consumers_input::Builder,
    }
    impl<C> ListTrackerConsumers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTrackerConsumersOutput,
            smithy_http::result::SdkError<crate::error::ListTrackerConsumersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The tracker resource whose associated geofence collections you want to list.</p>
        pub fn tracker_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(input);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// <p>An optional limit for the number of resources returned in a single call. </p>
        /// <p>Default value: <code>100</code>
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token specifying which page of results to return in the response. If no
        /// token is provided, the default page is the first page. </p>
        /// <p>Default value: <code>null</code>
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTrackers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_trackers_input::Builder,
    }
    impl<C> ListTrackers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTrackersOutput,
            smithy_http::result::SdkError<crate::error::ListTrackersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional limit for the number of resources returned in a single call. </p>
        /// <p>Default value: <code>100</code>
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token specifying which page of results to return in the response. If no
        /// token is provided, the default page is the first page. </p>
        /// <p>Default value: <code>null</code>
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutGeofence<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_geofence_input::Builder,
    }
    impl<C> PutGeofence<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutGeofenceOutput,
            smithy_http::result::SdkError<crate::error::PutGeofenceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The geofence collection to store the geofence in.</p>
        pub fn collection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_name(input);
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_name(input);
            self
        }
        /// <p>An identifier for the geofence. For example, <code>ExampleGeofence-1</code>.</p>
        pub fn geofence_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.geofence_id(input);
            self
        }
        pub fn set_geofence_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_geofence_id(input);
            self
        }
        /// <p>Contains the polygon details to specify the position of the geofence.</p>
        /// <note>
        /// <p>Each <a href="https://docs.aws.amazon.com/location-geofences/latest/APIReference/API_GeofenceGeometry.html">geofence polygon</a> can have a maximum of 1,000 vertices.</p>
        /// </note>
        pub fn geometry(mut self, input: crate::model::GeofenceGeometry) -> Self {
            self.inner = self.inner.geometry(input);
            self
        }
        pub fn set_geometry(
            mut self,
            input: std::option::Option<crate::model::GeofenceGeometry>,
        ) -> Self {
            self.inner = self.inner.set_geometry(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SearchPlaceIndexForPosition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::search_place_index_for_position_input::Builder,
    }
    impl<C> SearchPlaceIndexForPosition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SearchPlaceIndexForPositionOutput,
            smithy_http::result::SdkError<crate::error::SearchPlaceIndexForPositionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the place index resource you want to use for the search.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_name(input);
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_name(input);
            self
        }
        /// <p>Specifies a coordinate for the query defined by a longitude, and latitude.</p>
        /// <ul>
        /// <li>
        /// <p>The first position is the X coordinate, or longitude.</p>
        /// </li>
        /// <li>
        /// <p>The second position is the Y coordinate, or latitude. </p>
        /// </li>
        /// </ul>
        /// <p>For example, <code>position=xLongitude&amp;position=yLatitude</code> .</p>
        pub fn position(mut self, inp: impl Into<f64>) -> Self {
            self.inner = self.inner.position(inp);
            self
        }
        pub fn set_position(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.inner = self.inner.set_position(input);
            self
        }
        /// <p>An optional paramer. The maximum number of results returned per request. </p>
        /// <p>Default value: <code>50</code>
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SearchPlaceIndexForText<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::search_place_index_for_text_input::Builder,
    }
    impl<C> SearchPlaceIndexForText<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SearchPlaceIndexForTextOutput,
            smithy_http::result::SdkError<crate::error::SearchPlaceIndexForTextError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the place index resource you want to use for the search.</p>
        pub fn index_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_name(input);
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_name(input);
            self
        }
        /// <p>The address, name,
        /// city, or region to be used in the search. In free-form text format. For example, <code>123 Any
        /// Street</code>.</p>
        pub fn text(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.text(input);
            self
        }
        pub fn set_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_text(input);
            self
        }
        /// <p>Searches for results closest to the given position. An optional parameter defined by
        /// longitude, and latitude.</p>
        /// <ul>
        /// <li>
        /// <p>The first <code>bias</code> position is the X coordinate, or longitude.</p>
        /// </li>
        /// <li>
        /// <p>The second <code>bias</code> position is the Y coordinate, or latitude. </p>
        /// </li>
        /// </ul>
        /// <p>For example, <code>bias=xLongitude&amp;bias=yLatitude</code>.</p>
        pub fn bias_position(mut self, inp: impl Into<f64>) -> Self {
            self.inner = self.inner.bias_position(inp);
            self
        }
        pub fn set_bias_position(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.inner = self.inner.set_bias_position(input);
            self
        }
        /// <p>Filters the results by returning only Places within the provided bounding box. An
        /// optional parameter.</p>
        /// <p>The first 2 <code>bbox</code> parameters describe the lower southwest corner:</p>
        /// <ul>
        /// <li>
        /// <p>The first <code>bbox</code> position is the X coordinate or longitude of the lower
        /// southwest corner.</p>
        /// </li>
        /// <li>
        /// <p>The second <code>bbox</code> position is the Y coordinate or latitude of the lower
        /// southwest corner.</p>
        /// </li>
        /// </ul>
        /// <p>For example, <code>bbox=xLongitudeSW&amp;bbox=yLatitudeSW</code>.</p>
        /// <p>The next <code>bbox</code> parameters describe the upper northeast corner:</p>
        /// <ul>
        /// <li>
        /// <p>The third <code>bbox</code> position is the X coordinate, or longitude of the
        /// upper northeast corner.</p>
        /// </li>
        /// <li>
        /// <p>The fourth <code>bbox</code> position is the Y coordinate, or longitude of the
        /// upper northeast corner.</p>
        /// </li>
        /// </ul>
        /// <p>For example, <code>bbox=xLongitudeNE&amp;bbox=yLatitudeNE</code>
        /// </p>
        pub fn filter_b_box(mut self, inp: impl Into<f64>) -> Self {
            self.inner = self.inner.filter_b_box(inp);
            self
        }
        pub fn set_filter_b_box(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.inner = self.inner.set_filter_b_box(input);
            self
        }
        /// <p>Limits the search to the given a list of countries/regions. An optional
        /// parameter.</p>
        /// <ul>
        /// <li>
        /// <p>Use the <a href="https://www.iso.org/iso-3166-country-codes.html">ISO 3166</a> 3-digit
        /// country code. For example, Australia uses three upper-case characters:
        /// <code>AUS</code>.</p>
        /// </li>
        /// </ul>
        pub fn filter_countries(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_countries(inp);
            self
        }
        pub fn set_filter_countries(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_filter_countries(input);
            self
        }
        /// <p>An optional parameter. The maximum number of results returned per request. </p>
        /// <p>The default: <code>50</code>
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource whose tags you want to update.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The mapping from tag key to tag value for each tag associated with the specified resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource from which you want to remove tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The list of tag keys to remove from the resource.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
}
