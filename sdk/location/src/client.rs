// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    client: smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `LocationService`.
///
/// This client allows ergonomic access to a `LocationService`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use smithy_client::Builder;

impl<C, M, R> From<smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    pub fn with_config(client: smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: smithy_client::bounds::SmithyConnector,
    M: smithy_client::bounds::SmithyMiddleware<C>,
    R: smithy_client::retry::NewRequestPolicy,
{
    pub fn associate_tracker_consumer(&self) -> fluent_builders::AssociateTrackerConsumer<C, M, R> {
        fluent_builders::AssociateTrackerConsumer::new(self.handle.clone())
    }
    pub fn batch_delete_device_position_history(
        &self,
    ) -> fluent_builders::BatchDeleteDevicePositionHistory<C, M, R> {
        fluent_builders::BatchDeleteDevicePositionHistory::new(self.handle.clone())
    }
    pub fn batch_delete_geofence(&self) -> fluent_builders::BatchDeleteGeofence<C, M, R> {
        fluent_builders::BatchDeleteGeofence::new(self.handle.clone())
    }
    pub fn batch_evaluate_geofences(&self) -> fluent_builders::BatchEvaluateGeofences<C, M, R> {
        fluent_builders::BatchEvaluateGeofences::new(self.handle.clone())
    }
    pub fn batch_get_device_position(&self) -> fluent_builders::BatchGetDevicePosition<C, M, R> {
        fluent_builders::BatchGetDevicePosition::new(self.handle.clone())
    }
    pub fn batch_put_geofence(&self) -> fluent_builders::BatchPutGeofence<C, M, R> {
        fluent_builders::BatchPutGeofence::new(self.handle.clone())
    }
    pub fn batch_update_device_position(
        &self,
    ) -> fluent_builders::BatchUpdateDevicePosition<C, M, R> {
        fluent_builders::BatchUpdateDevicePosition::new(self.handle.clone())
    }
    pub fn calculate_route(&self) -> fluent_builders::CalculateRoute<C, M, R> {
        fluent_builders::CalculateRoute::new(self.handle.clone())
    }
    pub fn create_geofence_collection(&self) -> fluent_builders::CreateGeofenceCollection<C, M, R> {
        fluent_builders::CreateGeofenceCollection::new(self.handle.clone())
    }
    pub fn create_map(&self) -> fluent_builders::CreateMap<C, M, R> {
        fluent_builders::CreateMap::new(self.handle.clone())
    }
    pub fn create_place_index(&self) -> fluent_builders::CreatePlaceIndex<C, M, R> {
        fluent_builders::CreatePlaceIndex::new(self.handle.clone())
    }
    pub fn create_route_calculator(&self) -> fluent_builders::CreateRouteCalculator<C, M, R> {
        fluent_builders::CreateRouteCalculator::new(self.handle.clone())
    }
    pub fn create_tracker(&self) -> fluent_builders::CreateTracker<C, M, R> {
        fluent_builders::CreateTracker::new(self.handle.clone())
    }
    pub fn delete_geofence_collection(&self) -> fluent_builders::DeleteGeofenceCollection<C, M, R> {
        fluent_builders::DeleteGeofenceCollection::new(self.handle.clone())
    }
    pub fn delete_map(&self) -> fluent_builders::DeleteMap<C, M, R> {
        fluent_builders::DeleteMap::new(self.handle.clone())
    }
    pub fn delete_place_index(&self) -> fluent_builders::DeletePlaceIndex<C, M, R> {
        fluent_builders::DeletePlaceIndex::new(self.handle.clone())
    }
    pub fn delete_route_calculator(&self) -> fluent_builders::DeleteRouteCalculator<C, M, R> {
        fluent_builders::DeleteRouteCalculator::new(self.handle.clone())
    }
    pub fn delete_tracker(&self) -> fluent_builders::DeleteTracker<C, M, R> {
        fluent_builders::DeleteTracker::new(self.handle.clone())
    }
    pub fn describe_geofence_collection(
        &self,
    ) -> fluent_builders::DescribeGeofenceCollection<C, M, R> {
        fluent_builders::DescribeGeofenceCollection::new(self.handle.clone())
    }
    pub fn describe_map(&self) -> fluent_builders::DescribeMap<C, M, R> {
        fluent_builders::DescribeMap::new(self.handle.clone())
    }
    pub fn describe_place_index(&self) -> fluent_builders::DescribePlaceIndex<C, M, R> {
        fluent_builders::DescribePlaceIndex::new(self.handle.clone())
    }
    pub fn describe_route_calculator(&self) -> fluent_builders::DescribeRouteCalculator<C, M, R> {
        fluent_builders::DescribeRouteCalculator::new(self.handle.clone())
    }
    pub fn describe_tracker(&self) -> fluent_builders::DescribeTracker<C, M, R> {
        fluent_builders::DescribeTracker::new(self.handle.clone())
    }
    pub fn disassociate_tracker_consumer(
        &self,
    ) -> fluent_builders::DisassociateTrackerConsumer<C, M, R> {
        fluent_builders::DisassociateTrackerConsumer::new(self.handle.clone())
    }
    pub fn get_device_position(&self) -> fluent_builders::GetDevicePosition<C, M, R> {
        fluent_builders::GetDevicePosition::new(self.handle.clone())
    }
    pub fn get_device_position_history(
        &self,
    ) -> fluent_builders::GetDevicePositionHistory<C, M, R> {
        fluent_builders::GetDevicePositionHistory::new(self.handle.clone())
    }
    pub fn get_geofence(&self) -> fluent_builders::GetGeofence<C, M, R> {
        fluent_builders::GetGeofence::new(self.handle.clone())
    }
    pub fn get_map_glyphs(&self) -> fluent_builders::GetMapGlyphs<C, M, R> {
        fluent_builders::GetMapGlyphs::new(self.handle.clone())
    }
    pub fn get_map_sprites(&self) -> fluent_builders::GetMapSprites<C, M, R> {
        fluent_builders::GetMapSprites::new(self.handle.clone())
    }
    pub fn get_map_style_descriptor(&self) -> fluent_builders::GetMapStyleDescriptor<C, M, R> {
        fluent_builders::GetMapStyleDescriptor::new(self.handle.clone())
    }
    pub fn get_map_tile(&self) -> fluent_builders::GetMapTile<C, M, R> {
        fluent_builders::GetMapTile::new(self.handle.clone())
    }
    pub fn list_device_positions(&self) -> fluent_builders::ListDevicePositions<C, M, R> {
        fluent_builders::ListDevicePositions::new(self.handle.clone())
    }
    pub fn list_geofence_collections(&self) -> fluent_builders::ListGeofenceCollections<C, M, R> {
        fluent_builders::ListGeofenceCollections::new(self.handle.clone())
    }
    pub fn list_geofences(&self) -> fluent_builders::ListGeofences<C, M, R> {
        fluent_builders::ListGeofences::new(self.handle.clone())
    }
    pub fn list_maps(&self) -> fluent_builders::ListMaps<C, M, R> {
        fluent_builders::ListMaps::new(self.handle.clone())
    }
    pub fn list_place_indexes(&self) -> fluent_builders::ListPlaceIndexes<C, M, R> {
        fluent_builders::ListPlaceIndexes::new(self.handle.clone())
    }
    pub fn list_route_calculators(&self) -> fluent_builders::ListRouteCalculators<C, M, R> {
        fluent_builders::ListRouteCalculators::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C, M, R> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_tracker_consumers(&self) -> fluent_builders::ListTrackerConsumers<C, M, R> {
        fluent_builders::ListTrackerConsumers::new(self.handle.clone())
    }
    pub fn list_trackers(&self) -> fluent_builders::ListTrackers<C, M, R> {
        fluent_builders::ListTrackers::new(self.handle.clone())
    }
    pub fn put_geofence(&self) -> fluent_builders::PutGeofence<C, M, R> {
        fluent_builders::PutGeofence::new(self.handle.clone())
    }
    pub fn search_place_index_for_position(
        &self,
    ) -> fluent_builders::SearchPlaceIndexForPosition<C, M, R> {
        fluent_builders::SearchPlaceIndexForPosition::new(self.handle.clone())
    }
    pub fn search_place_index_for_text(&self) -> fluent_builders::SearchPlaceIndexForText<C, M, R> {
        fluent_builders::SearchPlaceIndexForText::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C, M, R> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C, M, R> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_geofence_collection(&self) -> fluent_builders::UpdateGeofenceCollection<C, M, R> {
        fluent_builders::UpdateGeofenceCollection::new(self.handle.clone())
    }
    pub fn update_map(&self) -> fluent_builders::UpdateMap<C, M, R> {
        fluent_builders::UpdateMap::new(self.handle.clone())
    }
    pub fn update_place_index(&self) -> fluent_builders::UpdatePlaceIndex<C, M, R> {
        fluent_builders::UpdatePlaceIndex::new(self.handle.clone())
    }
    pub fn update_route_calculator(&self) -> fluent_builders::UpdateRouteCalculator<C, M, R> {
        fluent_builders::UpdateRouteCalculator::new(self.handle.clone())
    }
    pub fn update_tracker(&self) -> fluent_builders::UpdateTracker<C, M, R> {
        fluent_builders::UpdateTracker::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AssociateTrackerConsumer<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::associate_tracker_consumer_input::Builder,
    }
    impl<C, M, R> AssociateTrackerConsumer<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateTrackerConsumerOutput,
            smithy_http::result::SdkError<crate::error::AssociateTrackerConsumerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::AssociateTrackerConsumerInputOperationOutputAlias,
                crate::output::AssociateTrackerConsumerOutput,
                crate::error::AssociateTrackerConsumerError,
                crate::input::AssociateTrackerConsumerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the tracker resource to be associated with a geofence collection.</p>
        pub fn tracker_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(inp);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the geofence collection to be associated to tracker
        /// resource. Used when you need to specify a resource across all AWS.</p>
        /// <ul>
        /// <li>
        /// <p>Format example:
        /// <code>arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn consumer_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.consumer_arn(inp);
            self
        }
        pub fn set_consumer_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_consumer_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchDeleteDevicePositionHistory<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::batch_delete_device_position_history_input::Builder,
    }
    impl<C, M, R> BatchDeleteDevicePositionHistory<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchDeleteDevicePositionHistoryOutput,
            smithy_http::result::SdkError<crate::error::BatchDeleteDevicePositionHistoryError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::BatchDeleteDevicePositionHistoryInputOperationOutputAlias,
                crate::output::BatchDeleteDevicePositionHistoryOutput,
                crate::error::BatchDeleteDevicePositionHistoryError,
                crate::input::BatchDeleteDevicePositionHistoryInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the tracker resource to delete the device position history from.</p>
        pub fn tracker_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(inp);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// Appends an item to `DeviceIds`.
        ///
        /// To override the contents of this collection use [`set_device_ids`](Self::set_device_ids).
        /// <p>Devices whose position history you want to delete.</p>
        /// <ul>
        /// <li>
        /// <p>For example, for two devices:
        /// <code>“DeviceIds” : [DeviceId1,DeviceId2]</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn device_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.device_ids(inp);
            self
        }
        pub fn set_device_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_device_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchDeleteGeofence<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::batch_delete_geofence_input::Builder,
    }
    impl<C, M, R> BatchDeleteGeofence<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchDeleteGeofenceOutput,
            smithy_http::result::SdkError<crate::error::BatchDeleteGeofenceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::BatchDeleteGeofenceInputOperationOutputAlias,
                crate::output::BatchDeleteGeofenceOutput,
                crate::error::BatchDeleteGeofenceError,
                crate::input::BatchDeleteGeofenceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The geofence collection storing the geofences to be deleted.</p>
        pub fn collection_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_name(inp);
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_name(input);
            self
        }
        /// Appends an item to `GeofenceIds`.
        ///
        /// To override the contents of this collection use [`set_geofence_ids`](Self::set_geofence_ids).
        /// <p>The batch of geofences to be deleted.</p>
        pub fn geofence_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.geofence_ids(inp);
            self
        }
        pub fn set_geofence_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_geofence_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchEvaluateGeofences<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::batch_evaluate_geofences_input::Builder,
    }
    impl<C, M, R> BatchEvaluateGeofences<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchEvaluateGeofencesOutput,
            smithy_http::result::SdkError<crate::error::BatchEvaluateGeofencesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::BatchEvaluateGeofencesInputOperationOutputAlias,
                crate::output::BatchEvaluateGeofencesOutput,
                crate::error::BatchEvaluateGeofencesError,
                crate::input::BatchEvaluateGeofencesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The geofence collection used in evaluating the position of devices against its
        /// geofences.</p>
        pub fn collection_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_name(inp);
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_name(input);
            self
        }
        /// Appends an item to `DevicePositionUpdates`.
        ///
        /// To override the contents of this collection use [`set_device_position_updates`](Self::set_device_position_updates).
        /// <p>Contains device details for each device to be evaluated against the given geofence
        /// collection.</p>
        pub fn device_position_updates(
            mut self,
            inp: impl Into<crate::model::DevicePositionUpdate>,
        ) -> Self {
            self.inner = self.inner.device_position_updates(inp);
            self
        }
        pub fn set_device_position_updates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DevicePositionUpdate>>,
        ) -> Self {
            self.inner = self.inner.set_device_position_updates(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetDevicePosition<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::batch_get_device_position_input::Builder,
    }
    impl<C, M, R> BatchGetDevicePosition<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetDevicePositionOutput,
            smithy_http::result::SdkError<crate::error::BatchGetDevicePositionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::BatchGetDevicePositionInputOperationOutputAlias,
                crate::output::BatchGetDevicePositionOutput,
                crate::error::BatchGetDevicePositionError,
                crate::input::BatchGetDevicePositionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The tracker resource retrieving the device position.</p>
        pub fn tracker_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(inp);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// Appends an item to `DeviceIds`.
        ///
        /// To override the contents of this collection use [`set_device_ids`](Self::set_device_ids).
        /// <p>Devices whose position you want to retrieve.</p>
        /// <ul>
        /// <li>
        /// <p>For example, for two devices:
        /// <code>device-ids=DeviceId1&amp;device-ids=DeviceId2</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn device_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.device_ids(inp);
            self
        }
        pub fn set_device_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_device_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchPutGeofence<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::batch_put_geofence_input::Builder,
    }
    impl<C, M, R> BatchPutGeofence<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchPutGeofenceOutput,
            smithy_http::result::SdkError<crate::error::BatchPutGeofenceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::BatchPutGeofenceInputOperationOutputAlias,
                crate::output::BatchPutGeofenceOutput,
                crate::error::BatchPutGeofenceError,
                crate::input::BatchPutGeofenceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The geofence collection storing the geofences.</p>
        pub fn collection_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_name(inp);
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_name(input);
            self
        }
        /// Appends an item to `Entries`.
        ///
        /// To override the contents of this collection use [`set_entries`](Self::set_entries).
        /// <p>The batch of geofences to be stored in a geofence collection.</p>
        pub fn entries(
            mut self,
            inp: impl Into<crate::model::BatchPutGeofenceRequestEntry>,
        ) -> Self {
            self.inner = self.inner.entries(inp);
            self
        }
        pub fn set_entries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchPutGeofenceRequestEntry>>,
        ) -> Self {
            self.inner = self.inner.set_entries(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchUpdateDevicePosition<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::batch_update_device_position_input::Builder,
    }
    impl<C, M, R> BatchUpdateDevicePosition<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchUpdateDevicePositionOutput,
            smithy_http::result::SdkError<crate::error::BatchUpdateDevicePositionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::BatchUpdateDevicePositionInputOperationOutputAlias,
                crate::output::BatchUpdateDevicePositionOutput,
                crate::error::BatchUpdateDevicePositionError,
                crate::input::BatchUpdateDevicePositionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the tracker resource to update.</p>
        pub fn tracker_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(inp);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// Appends an item to `Updates`.
        ///
        /// To override the contents of this collection use [`set_updates`](Self::set_updates).
        /// <p>Contains the position update details for each device.</p>
        pub fn updates(mut self, inp: impl Into<crate::model::DevicePositionUpdate>) -> Self {
            self.inner = self.inner.updates(inp);
            self
        }
        pub fn set_updates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DevicePositionUpdate>>,
        ) -> Self {
            self.inner = self.inner.set_updates(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CalculateRoute<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::calculate_route_input::Builder,
    }
    impl<C, M, R> CalculateRoute<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CalculateRouteOutput,
            smithy_http::result::SdkError<crate::error::CalculateRouteError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CalculateRouteInputOperationOutputAlias,
                crate::output::CalculateRouteOutput,
                crate::error::CalculateRouteError,
                crate::input::CalculateRouteInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the route calculator resource that you want to use to calculate a route. </p>
        pub fn calculator_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.calculator_name(inp);
            self
        }
        pub fn set_calculator_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_calculator_name(input);
            self
        }
        /// Appends an item to `DeparturePosition`.
        ///
        /// To override the contents of this collection use [`set_departure_position`](Self::set_departure_position).
        /// <p>The start position for the route. Defined in <a href="https://earth-info.nga.mil/GandG/wgs84/index.html">WGS 84</a> format:
        /// <code>[longitude, latitude]</code>.</p>
        /// <ul>
        /// <li>
        /// <p>For example, <code>[-123.115, 49.285]</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>If you specify a departure that's not located on a road, Amazon Location <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#snap-to-nearby-road">moves the
        /// position to the nearest road</a>.</p>
        /// </note>
        /// <p>Valid Values: <code>[-180 to 180,-90 to 90]</code>
        /// </p>
        pub fn departure_position(mut self, inp: impl Into<f64>) -> Self {
            self.inner = self.inner.departure_position(inp);
            self
        }
        pub fn set_departure_position(
            mut self,
            input: std::option::Option<std::vec::Vec<f64>>,
        ) -> Self {
            self.inner = self.inner.set_departure_position(input);
            self
        }
        /// Appends an item to `DestinationPosition`.
        ///
        /// To override the contents of this collection use [`set_destination_position`](Self::set_destination_position).
        /// <p>The finish position for the route. Defined in <a href="https://earth-info.nga.mil/GandG/wgs84/index.html">WGS 84</a> format:
        /// <code>[longitude, latitude]</code>.</p>
        /// <ul>
        /// <li>
        /// <p> For example, <code>[-122.339, 47.615]</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>If you specify a destination that's not located on a road, Amazon Location <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#snap-to-nearby-road">moves the position to the nearest road</a>. </p>
        /// </note>
        /// <p>Valid Values: <code>[-180 to 180,-90 to 90]</code>
        /// </p>
        pub fn destination_position(mut self, inp: impl Into<f64>) -> Self {
            self.inner = self.inner.destination_position(inp);
            self
        }
        pub fn set_destination_position(
            mut self,
            input: std::option::Option<std::vec::Vec<f64>>,
        ) -> Self {
            self.inner = self.inner.set_destination_position(input);
            self
        }
        /// Appends an item to `WaypointPositions`.
        ///
        /// To override the contents of this collection use [`set_waypoint_positions`](Self::set_waypoint_positions).
        /// <p>Specifies an ordered list of up to 23 intermediate positions to include along a route
        /// between the departure position and destination position. </p>
        /// <ul>
        /// <li>
        /// <p>For example, from the <code>DeparturePosition</code>
        /// <code>[-123.115, 49.285]</code>, the route follows the order that the waypoint
        /// positions are given <code>[[-122.757, 49.0021],[-122.349, 47.620]]</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>If you specify a waypoint position that's not located on a road, Amazon Location <a href="https://docs.aws.amazon.com/location/latest/developerguide/calculate-route.html#snap-to-nearby-road">moves the position to the nearest road</a>. </p>
        /// <p>Specifying more than 23 waypoints returns a <code>400 ValidationException</code>
        /// error.</p>
        /// </note>
        /// <p>Valid Values: <code>[-180 to 180,-90 to 90]</code>
        /// </p>
        pub fn waypoint_positions(mut self, inp: impl Into<std::vec::Vec<f64>>) -> Self {
            self.inner = self.inner.waypoint_positions(inp);
            self
        }
        pub fn set_waypoint_positions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<f64>>>,
        ) -> Self {
            self.inner = self.inner.set_waypoint_positions(input);
            self
        }
        /// <p>Specifies the mode of transport when calculating a route. Used in estimating the speed
        /// of travel and road compatibility.</p>
        /// <p>The <code>TravelMode</code> you specify determines how you specify route preferences: </p>
        /// <ul>
        /// <li>
        /// <p>If traveling by <code>Car</code> use the <code>CarModeOptions</code>
        /// parameter.</p>
        /// </li>
        /// <li>
        /// <p>If traveling by <code>Truck</code> use the <code>TruckModeOptions</code>
        /// parameter.</p>
        /// </li>
        /// </ul>
        /// <p>Default Value: <code>Car</code>
        /// </p>
        pub fn travel_mode(mut self, inp: crate::model::TravelMode) -> Self {
            self.inner = self.inner.travel_mode(inp);
            self
        }
        pub fn set_travel_mode(
            mut self,
            input: std::option::Option<crate::model::TravelMode>,
        ) -> Self {
            self.inner = self.inner.set_travel_mode(input);
            self
        }
        /// <p>Specifies the desired time of departure. Uses the given time to calculate a route.
        /// Otherwise, the best time of day to travel with the best traffic conditions is used to
        /// calculate the route.</p>
        /// <note>
        /// <p>Setting a departure time in the past returns a <code>400
        /// ValidationException</code> error.</p>
        /// </note>
        /// <ul>
        /// <li>
        /// <p>In <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO
        /// 8601</a> format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. For example,
        /// <code>2020–07-2T12:15:20.000Z+01:00</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn departure_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.departure_time(inp);
            self
        }
        pub fn set_departure_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_departure_time(input);
            self
        }
        /// <p>Sets the time of departure as the current time. Uses the current time to calculate a
        /// route. Otherwise, the best time of day to travel with the best traffic conditions is
        /// used to calculate the route.</p>
        /// <p>Default Value: <code>false</code>
        /// </p>
        /// <p>Valid Values: <code>false</code> | <code>true</code>
        /// </p>
        pub fn depart_now(mut self, inp: bool) -> Self {
            self.inner = self.inner.depart_now(inp);
            self
        }
        pub fn set_depart_now(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_depart_now(input);
            self
        }
        /// <p>Set the unit system to specify the distance.</p>
        /// <p>Default Value: <code>Kilometers</code>
        /// </p>
        pub fn distance_unit(mut self, inp: crate::model::DistanceUnit) -> Self {
            self.inner = self.inner.distance_unit(inp);
            self
        }
        pub fn set_distance_unit(
            mut self,
            input: std::option::Option<crate::model::DistanceUnit>,
        ) -> Self {
            self.inner = self.inner.set_distance_unit(input);
            self
        }
        /// <p>Set to include the geometry details in the result for each path between a pair of
        /// positions.</p>
        /// <p>Default Value: <code>false</code>
        /// </p>
        /// <p>Valid Values: <code>false</code> | <code>true</code>
        /// </p>
        pub fn include_leg_geometry(mut self, inp: bool) -> Self {
            self.inner = self.inner.include_leg_geometry(inp);
            self
        }
        pub fn set_include_leg_geometry(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_leg_geometry(input);
            self
        }
        /// <p>Specifies route preferences when traveling by <code>Car</code>, such as avoiding
        /// routes that use ferries or tolls.</p>
        /// <p>Requirements: <code>TravelMode</code> must be specified as <code>Car</code>.</p>
        pub fn car_mode_options(mut self, inp: crate::model::CalculateRouteCarModeOptions) -> Self {
            self.inner = self.inner.car_mode_options(inp);
            self
        }
        pub fn set_car_mode_options(
            mut self,
            input: std::option::Option<crate::model::CalculateRouteCarModeOptions>,
        ) -> Self {
            self.inner = self.inner.set_car_mode_options(input);
            self
        }
        /// <p>Specifies route preferences when traveling by <code>Truck</code>, such as avoiding
        /// routes that use ferries or tolls, and truck specifications to consider when choosing an
        /// optimal road.</p>
        /// <p>Requirements: <code>TravelMode</code> must be specified as <code>Truck</code>.</p>
        pub fn truck_mode_options(
            mut self,
            inp: crate::model::CalculateRouteTruckModeOptions,
        ) -> Self {
            self.inner = self.inner.truck_mode_options(inp);
            self
        }
        pub fn set_truck_mode_options(
            mut self,
            input: std::option::Option<crate::model::CalculateRouteTruckModeOptions>,
        ) -> Self {
            self.inner = self.inner.set_truck_mode_options(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateGeofenceCollection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_geofence_collection_input::Builder,
    }
    impl<C, M, R> CreateGeofenceCollection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateGeofenceCollectionOutput,
            smithy_http::result::SdkError<crate::error::CreateGeofenceCollectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateGeofenceCollectionInputOperationOutputAlias,
                crate::output::CreateGeofenceCollectionOutput,
                crate::error::CreateGeofenceCollectionError,
                crate::input::CreateGeofenceCollectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A custom name for the geofence collection.</p>
        /// <p>Requirements:</p>
        /// <ul>
        /// <li>
        /// <p>Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods
        /// (.), and underscores (_). </p>
        /// </li>
        /// <li>
        /// <p>Must be a unique geofence collection name.</p>
        /// </li>
        /// <li>
        /// <p>No spaces allowed. For example, <code>ExampleGeofenceCollection</code>.</p>
        /// </li>
        /// </ul>
        pub fn collection_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_name(inp);
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_name(input);
            self
        }
        /// <p>Specifies the pricing plan for the geofence collection.</p>
        /// <p>For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
        /// page</a>.</p>
        pub fn pricing_plan(mut self, inp: crate::model::PricingPlan) -> Self {
            self.inner = self.inner.pricing_plan(inp);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan(input);
            self
        }
        /// <p>Specifies the data provider for the geofence collection.</p>
        /// <ul>
        /// <li>
        /// <p>Required value for the following pricing plans: <code>MobileAssetTracking
        /// </code>| <code>MobileAssetManagement</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For more information about <a href="https://aws.amazon.com/location/data-providers/">Data Providers</a>, and <a href="https://aws.amazon.com/location/pricing/">Pricing plans</a>, see the Amazon Location
        /// Service product page.</p>
        /// <note>
        /// <p>Amazon Location Service only uses <code>PricingPlanDataSource</code> to calculate billing for
        /// your geofence collection. Your data won't be shared with the data provider, and will
        /// remain in your AWS account or Region unless you move it.</p>
        /// </note>
        /// <p>Valid Values: <code>Esri </code>| <code>Here</code>
        /// </p>
        pub fn pricing_plan_data_source(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pricing_plan_data_source(inp);
            self
        }
        pub fn set_pricing_plan_data_source(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan_data_source(input);
            self
        }
        /// <p>An optional description for the geofence collection.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// Adds a key-value pair to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>Applies one or more tags to the geofence collection. A tag is a key-value pair helps
        /// manage, identify, search, and filter your resources by labelling them.</p>
        /// <p>Format: <code>"key" : "value"</code>
        /// </p>
        /// <p>Restrictions:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum 50 tags per resource</p>
        /// </li>
        /// <li>
        /// <p>Each resource tag must be unique with a maximum of one value.</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length: 128 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length: 256 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters:
        /// + - = . _ : / @. </p>
        /// </li>
        /// </ul>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>A key identifier for an <a href="https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html">AWS KMS customer managed key</a>. Enter a key ID, key ARN, alias name, or alias ARN.
        /// </p>
        pub fn kms_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(inp);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateMap<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_map_input::Builder,
    }
    impl<C, M, R> CreateMap<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateMapOutput,
            smithy_http::result::SdkError<crate::error::CreateMapError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateMapInputOperationOutputAlias,
                crate::output::CreateMapOutput,
                crate::error::CreateMapError,
                crate::input::CreateMapInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name for the map resource.</p>
        /// <p>Requirements:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and underscores (_). </p>
        /// </li>
        /// <li>
        /// <p>Must be a unique map resource name. </p>
        /// </li>
        /// <li>
        /// <p>No spaces allowed. For example, <code>ExampleMap</code>.</p>
        /// </li>
        /// </ul>
        pub fn map_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.map_name(inp);
            self
        }
        pub fn set_map_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_map_name(input);
            self
        }
        /// <p>Specifies the map style selected from an available data provider.</p>
        pub fn configuration(mut self, inp: crate::model::MapConfiguration) -> Self {
            self.inner = self.inner.configuration(inp);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::MapConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
        /// <p>Specifies the pricing plan for your map resource.</p>
        /// <p>For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
        /// page</a>.</p>
        pub fn pricing_plan(mut self, inp: crate::model::PricingPlan) -> Self {
            self.inner = self.inner.pricing_plan(inp);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan(input);
            self
        }
        /// <p>An optional description for the map resource.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// Adds a key-value pair to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>Applies one or more tags to the map resource. A tag is a key-value pair helps manage,
        /// identify, search, and filter your resources by labelling them.</p>
        /// <p>Format: <code>"key" : "value"</code>
        /// </p>
        /// <p>Restrictions:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum 50 tags per resource</p>
        /// </li>
        /// <li>
        /// <p>Each resource tag must be unique with a maximum of one value.</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length: 128 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length:  256 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + - = . _ : /
        /// @. </p>
        /// </li>
        /// </ul>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePlaceIndex<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_place_index_input::Builder,
    }
    impl<C, M, R> CreatePlaceIndex<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePlaceIndexOutput,
            smithy_http::result::SdkError<crate::error::CreatePlaceIndexError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreatePlaceIndexInputOperationOutputAlias,
                crate::output::CreatePlaceIndexOutput,
                crate::error::CreatePlaceIndexError,
                crate::input::CreatePlaceIndexInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the place index resource. </p>
        /// <p>Requirements:</p>
        /// <ul>
        /// <li>
        /// <p>Contain only alphanumeric characters (A–Z, a–z, 0–9), hyphens (-), periods (.), and
        /// underscores (_).</p>
        /// </li>
        /// <li>
        /// <p>Must be a unique place index resource name.</p>
        /// </li>
        /// <li>
        /// <p>No spaces allowed. For example, <code>ExamplePlaceIndex</code>.</p>
        /// </li>
        /// </ul>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_name(inp);
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_name(input);
            self
        }
        /// <p>Specifies the data provider of geospatial data.</p>
        /// <note>
        /// <p>This field is case-sensitive. Enter the valid values as shown. For example, entering
        /// <code>HERE</code> returns an error.</p>
        /// </note>
        /// <p>Valid values include:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Esri</code> – For additional information about <a href="https://docs.aws.amazon.com/location/latest/developerguide/esri.html">Esri</a>'s coverage in your
        /// region of interest, see <a href="https://developers.arcgis.com/rest/geocode/api-reference/geocode-coverage.htm">Esri details on geocoding coverage</a>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Here</code> – For additional information about <a href="https://docs.aws.amazon.com/location/latest/developerguide/HERE.html">HERE Technologies</a>'s
        /// coverage in your region of interest, see <a href="https://developer.here.com/documentation/geocoder/dev_guide/topics/coverage-geocoder.html">HERE details on goecoding coverage</a>.</p>
        /// <important>
        /// <p>Place index resources using HERE Technologies as a data provider can't <a href="https://docs.aws.amazon.com/location-places/latest/APIReference/API_DataSourceConfiguration.html">store results</a> for locations in Japan. For more information, see the
        /// <a href="https://aws.amazon.com/service-terms/">AWS Service Terms</a>
        /// for Amazon Location Service.</p>
        /// </important>
        /// </li>
        /// </ul>
        /// <p>For additional information , see <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Data providers</a>
        /// on the <i>Amazon Location Service Developer Guide</i>.</p>
        pub fn data_source(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.data_source(inp);
            self
        }
        pub fn set_data_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_data_source(input);
            self
        }
        /// <p>Specifies the pricing plan for your place index resource.</p>
        /// <p>For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
        /// page</a>.</p>
        pub fn pricing_plan(mut self, inp: crate::model::PricingPlan) -> Self {
            self.inner = self.inner.pricing_plan(inp);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan(input);
            self
        }
        /// <p>The optional description for the place index resource.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Specifies the data storage option requesting Places.</p>
        pub fn data_source_configuration(
            mut self,
            inp: crate::model::DataSourceConfiguration,
        ) -> Self {
            self.inner = self.inner.data_source_configuration(inp);
            self
        }
        pub fn set_data_source_configuration(
            mut self,
            input: std::option::Option<crate::model::DataSourceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_data_source_configuration(input);
            self
        }
        /// Adds a key-value pair to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>Applies one or more tags to the place index resource. A tag is a key-value pair helps
        /// manage, identify, search, and filter your resources by labelling them.</p>
        /// <p>Format: <code>"key" : "value"</code>
        /// </p>
        /// <p>Restrictions:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum 50 tags per resource</p>
        /// </li>
        /// <li>
        /// <p>Each resource tag must be unique with a maximum of one value.</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length: 128 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length: 256 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters: + -
        /// = . _ : / @. </p>
        /// </li>
        /// </ul>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRouteCalculator<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_route_calculator_input::Builder,
    }
    impl<C, M, R> CreateRouteCalculator<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRouteCalculatorOutput,
            smithy_http::result::SdkError<crate::error::CreateRouteCalculatorError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateRouteCalculatorInputOperationOutputAlias,
                crate::output::CreateRouteCalculatorOutput,
                crate::error::CreateRouteCalculatorError,
                crate::input::CreateRouteCalculatorInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the route calculator resource. </p>
        /// <p>Requirements:</p>
        /// <ul>
        /// <li>
        /// <p>Can use alphanumeric characters (A–Z, a–z, 0–9) , hyphens (-), periods (.), and underscores
        /// (_).</p>
        /// </li>
        /// <li>
        /// <p>Must be a unique Route calculator resource name.</p>
        /// </li>
        /// <li>
        /// <p>No spaces allowed. For example, <code>ExampleRouteCalculator</code>.</p>
        /// </li>
        /// </ul>
        pub fn calculator_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.calculator_name(inp);
            self
        }
        pub fn set_calculator_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_calculator_name(input);
            self
        }
        /// <p>Specifies the data provider of traffic and road network data.</p>
        /// <note>
        /// <p>This field is case-sensitive. Enter the valid values as shown. For example,
        /// entering <code>HERE</code> returns an error.</p>
        /// </note>
        /// <p>Valid values include:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Esri</code> – For additional information about <a href="https://docs.aws.amazon.com/location/latest/developerguide/esri.html">Esri</a>'s coverage in your region of interest, see <a href="https://doc.arcgis.com/en/arcgis-online/reference/network-coverage.htm">Esri details on street networks and traffic coverage</a>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Here</code> – For additional information about <a href="https://docs.aws.amazon.com/location/latest/developerguide/HERE.html">HERE
        /// Technologies</a>'s coverage in your region of interest, see <a href="https://developer.here.com/documentation/routing-api/dev_guide/topics/coverage/car-routing.html">HERE car routing coverage</a> and <a href="https://developer.here.com/documentation/routing-api/dev_guide/topics/coverage/truck-routing.html">HERE truck routing coverage</a>.</p>
        /// </li>
        /// </ul>
        /// <p>For additional information , see <a href="https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html">Data
        /// providers</a> on the <i>Amazon Location Service Developer Guide</i>.</p>
        pub fn data_source(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.data_source(inp);
            self
        }
        pub fn set_data_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_data_source(input);
            self
        }
        /// <p>Specifies the pricing plan for your route calculator resource.</p>
        /// <p>For additional details and restrictions on each pricing plan option, see <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing</a>.</p>
        pub fn pricing_plan(mut self, inp: crate::model::PricingPlan) -> Self {
            self.inner = self.inner.pricing_plan(inp);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan(input);
            self
        }
        /// <p>The optional description for the route calculator resource.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// Adds a key-value pair to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>Applies one or more tags to the route calculator resource. A tag is a key-value pair
        /// helps manage, identify, search, and filter your resources by labelling them.</p>
        /// <ul>
        /// <li>
        /// <p>For example: { <code>"tag1" : "value1"</code>, <code>"tag2" :
        /// "value2"</code>}</p>
        /// </li>
        /// </ul>
        /// <p>Format: <code>"key" : "value"</code>
        /// </p>
        /// <p>Restrictions:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum 50 tags per resource</p>
        /// </li>
        /// <li>
        /// <p>Each resource tag must be unique with a maximum of one value.</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length: 128 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length: 256 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters:
        /// + - = . _ : / @. </p>
        /// </li>
        /// </ul>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTracker<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_tracker_input::Builder,
    }
    impl<C, M, R> CreateTracker<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTrackerOutput,
            smithy_http::result::SdkError<crate::error::CreateTrackerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateTrackerInputOperationOutputAlias,
                crate::output::CreateTrackerOutput,
                crate::error::CreateTrackerError,
                crate::input::CreateTrackerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name for the tracker resource.</p>
        /// <p>Requirements:</p>
        /// <ul>
        /// <li>
        /// <p>Contain only alphanumeric characters (A-Z, a-z, 0-9) , hyphens (-), periods (.), and underscores (_).</p>
        /// </li>
        /// <li>
        /// <p>Must be a unique tracker resource name.</p>
        /// </li>
        /// <li>
        /// <p>No spaces allowed. For example, <code>ExampleTracker</code>.</p>
        /// </li>
        /// </ul>
        pub fn tracker_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(inp);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// <p>Specifies the pricing plan for the tracker resource.</p>
        /// <p>For additional details and restrictions on each pricing plan option, see the <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing
        /// page</a>.</p>
        pub fn pricing_plan(mut self, inp: crate::model::PricingPlan) -> Self {
            self.inner = self.inner.pricing_plan(inp);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan(input);
            self
        }
        /// <p>A key identifier for an <a href="https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html">AWS KMS customer managed key</a>. Enter a key ID, key ARN, alias name, or alias ARN.</p>
        pub fn kms_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(inp);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
        /// <p>Specifies the data provider for the tracker resource.</p>
        /// <ul>
        /// <li>
        /// <p>Required value for the following pricing plans: <code>MobileAssetTracking
        /// </code>| <code>MobileAssetManagement</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For more information about <a href="https://aws.amazon.com/location/data-providers/">Data Providers</a>, and <a href="https://aws.amazon.com/location/pricing/">Pricing plans</a>, see the Amazon Location
        /// Service product page.</p>
        /// <note>
        /// <p>Amazon Location Service only uses <code>PricingPlanDataSource</code> to calculate billing for your tracker resource. Your data will not be shared with the data provider, and will remain in your AWS account or Region unless you move it.</p>
        /// </note>
        /// <p>Valid Values: <code>Esri</code> | <code>Here</code>
        /// </p>
        pub fn pricing_plan_data_source(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pricing_plan_data_source(inp);
            self
        }
        pub fn set_pricing_plan_data_source(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan_data_source(input);
            self
        }
        /// <p>An optional description for the tracker resource.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// Adds a key-value pair to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>Applies one or more tags to the tracker resource. A tag is a key-value pair helps
        /// manage, identify, search, and filter your resources by labelling them.</p>
        /// <p>Format: <code>"key" : "value"</code>
        /// </p>
        /// <p>Restrictions:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum 50 tags per resource</p>
        /// </li>
        /// <li>
        /// <p>Each resource tag must be unique with a maximum of one value.</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length: 128 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length: 256 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Can use alphanumeric characters (A–Z, a–z, 0–9), and the following characters:
        /// + - = . _ : / @. </p>
        /// </li>
        /// </ul>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteGeofenceCollection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_geofence_collection_input::Builder,
    }
    impl<C, M, R> DeleteGeofenceCollection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteGeofenceCollectionOutput,
            smithy_http::result::SdkError<crate::error::DeleteGeofenceCollectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteGeofenceCollectionInputOperationOutputAlias,
                crate::output::DeleteGeofenceCollectionOutput,
                crate::error::DeleteGeofenceCollectionError,
                crate::input::DeleteGeofenceCollectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the geofence collection to be deleted.</p>
        pub fn collection_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_name(inp);
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteMap<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_map_input::Builder,
    }
    impl<C, M, R> DeleteMap<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteMapOutput,
            smithy_http::result::SdkError<crate::error::DeleteMapError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteMapInputOperationOutputAlias,
                crate::output::DeleteMapOutput,
                crate::error::DeleteMapError,
                crate::input::DeleteMapInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the map resource to be deleted.</p>
        pub fn map_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.map_name(inp);
            self
        }
        pub fn set_map_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_map_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePlaceIndex<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_place_index_input::Builder,
    }
    impl<C, M, R> DeletePlaceIndex<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePlaceIndexOutput,
            smithy_http::result::SdkError<crate::error::DeletePlaceIndexError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeletePlaceIndexInputOperationOutputAlias,
                crate::output::DeletePlaceIndexOutput,
                crate::error::DeletePlaceIndexError,
                crate::input::DeletePlaceIndexInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the place index resource to be deleted.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_name(inp);
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRouteCalculator<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_route_calculator_input::Builder,
    }
    impl<C, M, R> DeleteRouteCalculator<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRouteCalculatorOutput,
            smithy_http::result::SdkError<crate::error::DeleteRouteCalculatorError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteRouteCalculatorInputOperationOutputAlias,
                crate::output::DeleteRouteCalculatorOutput,
                crate::error::DeleteRouteCalculatorError,
                crate::input::DeleteRouteCalculatorInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the route calculator resource to be deleted.</p>
        pub fn calculator_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.calculator_name(inp);
            self
        }
        pub fn set_calculator_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_calculator_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTracker<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_tracker_input::Builder,
    }
    impl<C, M, R> DeleteTracker<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTrackerOutput,
            smithy_http::result::SdkError<crate::error::DeleteTrackerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteTrackerInputOperationOutputAlias,
                crate::output::DeleteTrackerOutput,
                crate::error::DeleteTrackerError,
                crate::input::DeleteTrackerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the tracker resource to be deleted.</p>
        pub fn tracker_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(inp);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeGeofenceCollection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_geofence_collection_input::Builder,
    }
    impl<C, M, R> DescribeGeofenceCollection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeGeofenceCollectionOutput,
            smithy_http::result::SdkError<crate::error::DescribeGeofenceCollectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeGeofenceCollectionInputOperationOutputAlias,
                crate::output::DescribeGeofenceCollectionOutput,
                crate::error::DescribeGeofenceCollectionError,
                crate::input::DescribeGeofenceCollectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the geofence collection.</p>
        pub fn collection_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_name(inp);
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeMap<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_map_input::Builder,
    }
    impl<C, M, R> DescribeMap<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeMapOutput,
            smithy_http::result::SdkError<crate::error::DescribeMapError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeMapInputOperationOutputAlias,
                crate::output::DescribeMapOutput,
                crate::error::DescribeMapError,
                crate::input::DescribeMapInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the map resource.</p>
        pub fn map_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.map_name(inp);
            self
        }
        pub fn set_map_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_map_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribePlaceIndex<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_place_index_input::Builder,
    }
    impl<C, M, R> DescribePlaceIndex<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribePlaceIndexOutput,
            smithy_http::result::SdkError<crate::error::DescribePlaceIndexError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribePlaceIndexInputOperationOutputAlias,
                crate::output::DescribePlaceIndexOutput,
                crate::error::DescribePlaceIndexError,
                crate::input::DescribePlaceIndexInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the place index resource.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_name(inp);
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeRouteCalculator<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_route_calculator_input::Builder,
    }
    impl<C, M, R> DescribeRouteCalculator<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeRouteCalculatorOutput,
            smithy_http::result::SdkError<crate::error::DescribeRouteCalculatorError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeRouteCalculatorInputOperationOutputAlias,
                crate::output::DescribeRouteCalculatorOutput,
                crate::error::DescribeRouteCalculatorError,
                crate::input::DescribeRouteCalculatorInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the route calculator resource.</p>
        pub fn calculator_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.calculator_name(inp);
            self
        }
        pub fn set_calculator_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_calculator_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTracker<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_tracker_input::Builder,
    }
    impl<C, M, R> DescribeTracker<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTrackerOutput,
            smithy_http::result::SdkError<crate::error::DescribeTrackerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeTrackerInputOperationOutputAlias,
                crate::output::DescribeTrackerOutput,
                crate::error::DescribeTrackerError,
                crate::input::DescribeTrackerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the tracker resource.</p>
        pub fn tracker_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(inp);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateTrackerConsumer<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::disassociate_tracker_consumer_input::Builder,
    }
    impl<C, M, R> DisassociateTrackerConsumer<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateTrackerConsumerOutput,
            smithy_http::result::SdkError<crate::error::DisassociateTrackerConsumerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DisassociateTrackerConsumerInputOperationOutputAlias,
                crate::output::DisassociateTrackerConsumerOutput,
                crate::error::DisassociateTrackerConsumerError,
                crate::input::DisassociateTrackerConsumerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the tracker resource to be dissociated from the consumer.</p>
        pub fn tracker_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(inp);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the geofence collection to be disassociated from
        /// the tracker resource. Used when you need to specify a resource across all AWS. </p>
        /// <ul>
        /// <li>
        /// <p>Format example:
        /// <code>arn:aws:geo:region:account-id:geofence-collection/ExampleGeofenceCollectionConsumer</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn consumer_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.consumer_arn(inp);
            self
        }
        pub fn set_consumer_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_consumer_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDevicePosition<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_device_position_input::Builder,
    }
    impl<C, M, R> GetDevicePosition<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDevicePositionOutput,
            smithy_http::result::SdkError<crate::error::GetDevicePositionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetDevicePositionInputOperationOutputAlias,
                crate::output::GetDevicePositionOutput,
                crate::error::GetDevicePositionError,
                crate::input::GetDevicePositionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The tracker resource receiving the position update.</p>
        pub fn tracker_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(inp);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// <p>The device whose position you want to retrieve.</p>
        pub fn device_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.device_id(inp);
            self
        }
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_device_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDevicePositionHistory<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_device_position_history_input::Builder,
    }
    impl<C, M, R> GetDevicePositionHistory<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDevicePositionHistoryOutput,
            smithy_http::result::SdkError<crate::error::GetDevicePositionHistoryError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetDevicePositionHistoryInputOperationOutputAlias,
                crate::output::GetDevicePositionHistoryOutput,
                crate::error::GetDevicePositionHistoryError,
                crate::input::GetDevicePositionHistoryInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The tracker resource receiving the request for the device position history.</p>
        pub fn tracker_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(inp);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// <p>The device whose position history you want to retrieve.</p>
        pub fn device_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.device_id(inp);
            self
        }
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_device_id(input);
            self
        }
        /// <p>The pagination token specifying which page of results to return in the response. If no
        /// token is provided, the default page is the first page. </p>
        /// <p>Default value: <code>null</code>
        /// </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Specify the start time for the position history in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. By default, the value will be 24 hours
        /// prior to the time that the request is made.</p>
        /// <p>Requirement:</p>
        /// <ul>
        /// <li>
        /// <p>The time specified for <code>StartTimeInclusive</code> must be before
        /// <code>EndTimeExclusive</code>.</p>
        /// </li>
        /// </ul>
        pub fn start_time_inclusive(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time_inclusive(inp);
            self
        }
        pub fn set_start_time_inclusive(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_start_time_inclusive(input);
            self
        }
        /// <p>Specify the end time for the position history in <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601</a>
        /// format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>. By default, the value will be the time
        /// that the request is made.</p>
        /// <p>Requirement:</p>
        /// <ul>
        /// <li>
        /// <p>The time specified for <code>EndTimeExclusive</code> must be after the time for
        /// <code>StartTimeInclusive</code>.</p>
        /// </li>
        /// </ul>
        pub fn end_time_exclusive(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time_exclusive(inp);
            self
        }
        pub fn set_end_time_exclusive(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_end_time_exclusive(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetGeofence<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_geofence_input::Builder,
    }
    impl<C, M, R> GetGeofence<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetGeofenceOutput,
            smithy_http::result::SdkError<crate::error::GetGeofenceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetGeofenceInputOperationOutputAlias,
                crate::output::GetGeofenceOutput,
                crate::error::GetGeofenceError,
                crate::input::GetGeofenceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The geofence collection storing the target geofence.</p>
        pub fn collection_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_name(inp);
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_name(input);
            self
        }
        /// <p>The geofence you're retrieving details for.</p>
        pub fn geofence_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.geofence_id(inp);
            self
        }
        pub fn set_geofence_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_geofence_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMapGlyphs<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_map_glyphs_input::Builder,
    }
    impl<C, M, R> GetMapGlyphs<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMapGlyphsOutput,
            smithy_http::result::SdkError<crate::error::GetMapGlyphsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetMapGlyphsInputOperationOutputAlias,
                crate::output::GetMapGlyphsOutput,
                crate::error::GetMapGlyphsError,
                crate::input::GetMapGlyphsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The map resource associated with the glyph ﬁle.</p>
        pub fn map_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.map_name(inp);
            self
        }
        pub fn set_map_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_map_name(input);
            self
        }
        /// <p>A comma-separated list of fonts to load glyphs from in order of preference. For
        /// example, <code>Noto Sans Regular, Arial Unicode</code>.</p>
        /// <p>Valid fonts for <a href="https://docs.aws.amazon.com/location/latest/developerguide/esri.html">Esri</a> styles: </p>
        /// <ul>
        /// <li>
        /// <p>VectorEsriDarkGrayCanvas – <code>Ubuntu Medium Italic</code> | <code>Ubuntu
        /// Medium</code> | <code>Ubuntu Italic</code> | <code>Ubuntu Regular</code> |
        /// <code>Ubuntu Bold</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>VectorEsriLightGrayCanvas – <code>Ubuntu Italic</code> | <code>Ubuntu
        /// Regular</code> | <code>Ubuntu Light</code> | <code>Ubuntu Bold</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>VectorEsriTopographic – <code>Noto Sans Italic</code> | <code>Noto Sans
        /// Regular</code> | <code>Noto Sans Bold</code> | <code>Noto Serif
        /// Regular</code> | <code>Roboto Condensed Light Italic</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>VectorEsriStreets – <code>Arial Regular</code> | <code>Arial Italic</code> |
        /// <code>Arial Bold</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>VectorEsriNavigation – <code>Arial Regular</code> | <code>Arial Italic</code>
        /// | <code>Arial Bold</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>Valid fonts for <a href="https://docs.aws.amazon.com/location/latest/developerguide/HERE.html">HERE Technologies</a> styles: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>VectorHereBerlin</code> – <code>Fira GO Regular</code> | <code>Fira GO
        /// Bold</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn font_stack(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.font_stack(inp);
            self
        }
        pub fn set_font_stack(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_font_stack(input);
            self
        }
        /// <p>A Unicode range of characters to download glyphs for. Each response will contain 256
        /// characters. For example, 0–255 includes all characters from range <code>U+0000</code> to
        /// <code>00FF</code>. Must be aligned to multiples of 256.</p>
        pub fn font_unicode_range(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.font_unicode_range(inp);
            self
        }
        pub fn set_font_unicode_range(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_font_unicode_range(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMapSprites<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_map_sprites_input::Builder,
    }
    impl<C, M, R> GetMapSprites<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMapSpritesOutput,
            smithy_http::result::SdkError<crate::error::GetMapSpritesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetMapSpritesInputOperationOutputAlias,
                crate::output::GetMapSpritesOutput,
                crate::error::GetMapSpritesError,
                crate::input::GetMapSpritesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The map resource associated with the sprite ﬁle.</p>
        pub fn map_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.map_name(inp);
            self
        }
        pub fn set_map_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_map_name(input);
            self
        }
        /// <p>The name of the sprite ﬁle. Use the following ﬁle names for the sprite sheet:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>sprites.png</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>sprites@2x.png</code> for high pixel density displays</p>
        /// </li>
        /// </ul>
        /// <p>For the JSON document contain image offsets. Use the following ﬁle names:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>sprites.json</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>sprites@2x.json</code> for high pixel density displays</p>
        /// </li>
        /// </ul>
        pub fn file_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_name(inp);
            self
        }
        pub fn set_file_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_file_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMapStyleDescriptor<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_map_style_descriptor_input::Builder,
    }
    impl<C, M, R> GetMapStyleDescriptor<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMapStyleDescriptorOutput,
            smithy_http::result::SdkError<crate::error::GetMapStyleDescriptorError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetMapStyleDescriptorInputOperationOutputAlias,
                crate::output::GetMapStyleDescriptorOutput,
                crate::error::GetMapStyleDescriptorError,
                crate::input::GetMapStyleDescriptorInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The map resource to retrieve the style descriptor from.</p>
        pub fn map_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.map_name(inp);
            self
        }
        pub fn set_map_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_map_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMapTile<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_map_tile_input::Builder,
    }
    impl<C, M, R> GetMapTile<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMapTileOutput,
            smithy_http::result::SdkError<crate::error::GetMapTileError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetMapTileInputOperationOutputAlias,
                crate::output::GetMapTileOutput,
                crate::error::GetMapTileError,
                crate::input::GetMapTileInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The map resource to retrieve the map tiles from.</p>
        pub fn map_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.map_name(inp);
            self
        }
        pub fn set_map_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_map_name(input);
            self
        }
        /// <p>The zoom value for the map tile.</p>
        pub fn z(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.z(inp);
            self
        }
        pub fn set_z(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_z(input);
            self
        }
        /// <p>The X axis value for the map tile.</p>
        pub fn x(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.x(inp);
            self
        }
        pub fn set_x(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_x(input);
            self
        }
        /// <p>The Y axis value for the map tile. </p>
        pub fn y(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.y(inp);
            self
        }
        pub fn set_y(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_y(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDevicePositions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_device_positions_input::Builder,
    }
    impl<C, M, R> ListDevicePositions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDevicePositionsOutput,
            smithy_http::result::SdkError<crate::error::ListDevicePositionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListDevicePositionsInputOperationOutputAlias,
                crate::output::ListDevicePositionsOutput,
                crate::error::ListDevicePositionsError,
                crate::input::ListDevicePositionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The tracker resource containing the requested devices.</p>
        pub fn tracker_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(inp);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// <p>An optional limit for the number of entries returned in a single call.</p>
        /// <p>Default value: <code>100</code>
        /// </p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token specifying which page of results to return in the response. If no
        /// token is provided, the default page is the first page.</p>
        /// <p>Default value: <code>null</code>
        /// </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListGeofenceCollections<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_geofence_collections_input::Builder,
    }
    impl<C, M, R> ListGeofenceCollections<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListGeofenceCollectionsOutput,
            smithy_http::result::SdkError<crate::error::ListGeofenceCollectionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListGeofenceCollectionsInputOperationOutputAlias,
                crate::output::ListGeofenceCollectionsOutput,
                crate::error::ListGeofenceCollectionsError,
                crate::input::ListGeofenceCollectionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional limit for the number of resources returned in a single call. </p>
        /// <p>Default value: <code>100</code>
        /// </p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token specifying which page of results to return in the response. If no
        /// token is provided, the default page is the first page. </p>
        /// <p>Default value: <code>null</code>
        /// </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListGeofences<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_geofences_input::Builder,
    }
    impl<C, M, R> ListGeofences<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListGeofencesOutput,
            smithy_http::result::SdkError<crate::error::ListGeofencesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListGeofencesInputOperationOutputAlias,
                crate::output::ListGeofencesOutput,
                crate::error::ListGeofencesError,
                crate::input::ListGeofencesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the geofence collection storing the list of geofences.</p>
        pub fn collection_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_name(inp);
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_name(input);
            self
        }
        /// <p>The pagination token specifying which page of results to return in the response. If no
        /// token is provided, the default page is the first page. </p>
        /// <p>Default value: <code>null</code>
        /// </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListMaps<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_maps_input::Builder,
    }
    impl<C, M, R> ListMaps<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListMapsOutput,
            smithy_http::result::SdkError<crate::error::ListMapsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListMapsInputOperationOutputAlias,
                crate::output::ListMapsOutput,
                crate::error::ListMapsError,
                crate::input::ListMapsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional limit for the number of resources returned in a single call. </p>
        /// <p>Default value: <code>100</code>
        /// </p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token specifying which page of results to return in the response. If no
        /// token is provided, the default page is the first page.</p>
        /// <p>Default value: <code>null</code>
        /// </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPlaceIndexes<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_place_indexes_input::Builder,
    }
    impl<C, M, R> ListPlaceIndexes<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPlaceIndexesOutput,
            smithy_http::result::SdkError<crate::error::ListPlaceIndexesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListPlaceIndexesInputOperationOutputAlias,
                crate::output::ListPlaceIndexesOutput,
                crate::error::ListPlaceIndexesError,
                crate::input::ListPlaceIndexesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional limit for the maximum number of results returned in a single call.</p>
        /// <p>Default value: <code>100</code>
        /// </p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token specifying which page of results to return in the response. If no
        /// token is provided, the default page is the first page.</p>
        /// <p>Default value: <code>null</code>
        /// </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRouteCalculators<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_route_calculators_input::Builder,
    }
    impl<C, M, R> ListRouteCalculators<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRouteCalculatorsOutput,
            smithy_http::result::SdkError<crate::error::ListRouteCalculatorsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListRouteCalculatorsInputOperationOutputAlias,
                crate::output::ListRouteCalculatorsOutput,
                crate::error::ListRouteCalculatorsError,
                crate::input::ListRouteCalculatorsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional maximum number of results returned in a single call.</p>
        /// <p>Default Value: <code>100</code>
        /// </p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token specifying which page of results to return in the response. If no
        /// token is provided, the default page is the first page.</p>
        /// <p>Default Value: <code>null</code>
        /// </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C, M, R> ListTagsForResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListTagsForResourceInputOperationOutputAlias,
                crate::output::ListTagsForResourceOutput,
                crate::error::ListTagsForResourceError,
                crate::input::ListTagsForResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.</p>
        /// <ul>
        /// <li>
        /// <p>Format example: <code>arn:aws:geo:region:account-id:resourcetype/ExampleResource</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTrackerConsumers<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_tracker_consumers_input::Builder,
    }
    impl<C, M, R> ListTrackerConsumers<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTrackerConsumersOutput,
            smithy_http::result::SdkError<crate::error::ListTrackerConsumersError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListTrackerConsumersInputOperationOutputAlias,
                crate::output::ListTrackerConsumersOutput,
                crate::error::ListTrackerConsumersError,
                crate::input::ListTrackerConsumersInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The tracker resource whose associated geofence collections you want to list.</p>
        pub fn tracker_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(inp);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// <p>An optional limit for the number of resources returned in a single call. </p>
        /// <p>Default value: <code>100</code>
        /// </p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token specifying which page of results to return in the response. If no
        /// token is provided, the default page is the first page. </p>
        /// <p>Default value: <code>null</code>
        /// </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTrackers<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_trackers_input::Builder,
    }
    impl<C, M, R> ListTrackers<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTrackersOutput,
            smithy_http::result::SdkError<crate::error::ListTrackersError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListTrackersInputOperationOutputAlias,
                crate::output::ListTrackersOutput,
                crate::error::ListTrackersError,
                crate::input::ListTrackersInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An optional limit for the number of resources returned in a single call. </p>
        /// <p>Default value: <code>100</code>
        /// </p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The pagination token specifying which page of results to return in the response. If no
        /// token is provided, the default page is the first page. </p>
        /// <p>Default value: <code>null</code>
        /// </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutGeofence<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::put_geofence_input::Builder,
    }
    impl<C, M, R> PutGeofence<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutGeofenceOutput,
            smithy_http::result::SdkError<crate::error::PutGeofenceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PutGeofenceInputOperationOutputAlias,
                crate::output::PutGeofenceOutput,
                crate::error::PutGeofenceError,
                crate::input::PutGeofenceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The geofence collection to store the geofence in.</p>
        pub fn collection_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_name(inp);
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_name(input);
            self
        }
        /// <p>An identifier for the geofence. For example, <code>ExampleGeofence-1</code>.</p>
        pub fn geofence_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.geofence_id(inp);
            self
        }
        pub fn set_geofence_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_geofence_id(input);
            self
        }
        /// <p>Contains the polygon details to specify the position of the geofence.</p>
        /// <note>
        /// <p>Each <a href="https://docs.aws.amazon.com/location-geofences/latest/APIReference/API_GeofenceGeometry.html">geofence polygon</a> can have a maximum of 1,000 vertices.</p>
        /// </note>
        pub fn geometry(mut self, inp: crate::model::GeofenceGeometry) -> Self {
            self.inner = self.inner.geometry(inp);
            self
        }
        pub fn set_geometry(
            mut self,
            input: std::option::Option<crate::model::GeofenceGeometry>,
        ) -> Self {
            self.inner = self.inner.set_geometry(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SearchPlaceIndexForPosition<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::search_place_index_for_position_input::Builder,
    }
    impl<C, M, R> SearchPlaceIndexForPosition<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SearchPlaceIndexForPositionOutput,
            smithy_http::result::SdkError<crate::error::SearchPlaceIndexForPositionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::SearchPlaceIndexForPositionInputOperationOutputAlias,
                crate::output::SearchPlaceIndexForPositionOutput,
                crate::error::SearchPlaceIndexForPositionError,
                crate::input::SearchPlaceIndexForPositionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the place index resource you want to use for the search.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_name(inp);
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_name(input);
            self
        }
        /// Appends an item to `Position`.
        ///
        /// To override the contents of this collection use [`set_position`](Self::set_position).
        /// <p>Specifies a coordinate for the query defined by a longitude, and latitude.</p>
        /// <ul>
        /// <li>
        /// <p>The first position is the X coordinate, or longitude.</p>
        /// </li>
        /// <li>
        /// <p>The second position is the Y coordinate, or latitude. </p>
        /// </li>
        /// </ul>
        /// <p>For example, <code>position=xLongitude&amp;position=yLatitude</code> .</p>
        pub fn position(mut self, inp: impl Into<f64>) -> Self {
            self.inner = self.inner.position(inp);
            self
        }
        pub fn set_position(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.inner = self.inner.set_position(input);
            self
        }
        /// <p>An optional paramer. The maximum number of results returned per request. </p>
        /// <p>Default value: <code>50</code>
        /// </p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SearchPlaceIndexForText<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::search_place_index_for_text_input::Builder,
    }
    impl<C, M, R> SearchPlaceIndexForText<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SearchPlaceIndexForTextOutput,
            smithy_http::result::SdkError<crate::error::SearchPlaceIndexForTextError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::SearchPlaceIndexForTextInputOperationOutputAlias,
                crate::output::SearchPlaceIndexForTextOutput,
                crate::error::SearchPlaceIndexForTextError,
                crate::input::SearchPlaceIndexForTextInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the place index resource you want to use for the search.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_name(inp);
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_name(input);
            self
        }
        /// <p>The address, name,
        /// city, or region to be used in the search. In free-form text format. For example, <code>123 Any
        /// Street</code>.</p>
        pub fn text(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.text(inp);
            self
        }
        pub fn set_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_text(input);
            self
        }
        /// Appends an item to `BiasPosition`.
        ///
        /// To override the contents of this collection use [`set_bias_position`](Self::set_bias_position).
        /// <p>Searches for results closest to the given position. An optional parameter defined by
        /// longitude, and latitude.</p>
        /// <ul>
        /// <li>
        /// <p>The first <code>bias</code> position is the X coordinate, or longitude.</p>
        /// </li>
        /// <li>
        /// <p>The second <code>bias</code> position is the Y coordinate, or latitude. </p>
        /// </li>
        /// </ul>
        /// <p>For example, <code>bias=xLongitude&amp;bias=yLatitude</code>.</p>
        pub fn bias_position(mut self, inp: impl Into<f64>) -> Self {
            self.inner = self.inner.bias_position(inp);
            self
        }
        pub fn set_bias_position(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.inner = self.inner.set_bias_position(input);
            self
        }
        /// Appends an item to `FilterBBox`.
        ///
        /// To override the contents of this collection use [`set_filter_b_box`](Self::set_filter_b_box).
        /// <p>Filters the results by returning only Places within the provided bounding box. An
        /// optional parameter.</p>
        /// <p>The first 2 <code>bbox</code> parameters describe the lower southwest corner:</p>
        /// <ul>
        /// <li>
        /// <p>The first <code>bbox</code> position is the X coordinate or longitude of the lower
        /// southwest corner.</p>
        /// </li>
        /// <li>
        /// <p>The second <code>bbox</code> position is the Y coordinate or latitude of the lower
        /// southwest corner.</p>
        /// </li>
        /// </ul>
        /// <p>For example, <code>bbox=xLongitudeSW&amp;bbox=yLatitudeSW</code>.</p>
        /// <p>The next <code>bbox</code> parameters describe the upper northeast corner:</p>
        /// <ul>
        /// <li>
        /// <p>The third <code>bbox</code> position is the X coordinate, or longitude of the
        /// upper northeast corner.</p>
        /// </li>
        /// <li>
        /// <p>The fourth <code>bbox</code> position is the Y coordinate, or longitude of the
        /// upper northeast corner.</p>
        /// </li>
        /// </ul>
        /// <p>For example, <code>bbox=xLongitudeNE&amp;bbox=yLatitudeNE</code>
        /// </p>
        pub fn filter_b_box(mut self, inp: impl Into<f64>) -> Self {
            self.inner = self.inner.filter_b_box(inp);
            self
        }
        pub fn set_filter_b_box(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.inner = self.inner.set_filter_b_box(input);
            self
        }
        /// Appends an item to `FilterCountries`.
        ///
        /// To override the contents of this collection use [`set_filter_countries`](Self::set_filter_countries).
        /// <p>Limits the search to the given a list of countries/regions. An optional
        /// parameter.</p>
        /// <ul>
        /// <li>
        /// <p>Use the <a href="https://www.iso.org/iso-3166-country-codes.html">ISO 3166</a> 3-digit
        /// country code. For example, Australia uses three upper-case characters:
        /// <code>AUS</code>.</p>
        /// </li>
        /// </ul>
        pub fn filter_countries(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_countries(inp);
            self
        }
        pub fn set_filter_countries(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_filter_countries(input);
            self
        }
        /// <p>An optional parameter. The maximum number of results returned per request. </p>
        /// <p>The default: <code>50</code>
        /// </p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C, M, R> TagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::TagResourceInputOperationOutputAlias,
                crate::output::TagResourceOutput,
                crate::error::TagResourceError,
                crate::input::TagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource whose tags you want to update.</p>
        /// <ul>
        /// <li>
        /// <p>Format example: <code>arn:aws:geo:region:account-id:resourcetype/ExampleResource</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// Adds a key-value pair to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>Tags that have been applied to the specified resource. Tags are mapped from the tag key to the tag value: <code>"TagKey" : "TagValue"</code>.</p>
        /// <ul>
        /// <li>
        /// <p>Format example: <code>{"tag1" : "value1", "tag2" : "value2"} </code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C, M, R> UntagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UntagResourceInputOperationOutputAlias,
                crate::output::UntagResourceOutput,
                crate::error::UntagResourceError,
                crate::input::UntagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource from which you want to remove tags.</p>
        /// <ul>
        /// <li>
        /// <p>Format example: <code>arn:aws:geo:region:account-id:resourcetype/ExampleResource</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// Appends an item to `TagKeys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        /// <p>The list of tag keys to remove from the specified resource.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateGeofenceCollection<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_geofence_collection_input::Builder,
    }
    impl<C, M, R> UpdateGeofenceCollection<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateGeofenceCollectionOutput,
            smithy_http::result::SdkError<crate::error::UpdateGeofenceCollectionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateGeofenceCollectionInputOperationOutputAlias,
                crate::output::UpdateGeofenceCollectionOutput,
                crate::error::UpdateGeofenceCollectionError,
                crate::input::UpdateGeofenceCollectionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the geofence collection to update.</p>
        pub fn collection_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.collection_name(inp);
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_collection_name(input);
            self
        }
        /// <p>Updates the pricing plan for the geofence collection.</p>
        /// <p>For more information about each pricing plan option restrictions, see <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service
        /// pricing</a>.</p>
        pub fn pricing_plan(mut self, inp: crate::model::PricingPlan) -> Self {
            self.inner = self.inner.pricing_plan(inp);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan(input);
            self
        }
        /// <p>Updates the data provider for the geofence collection. </p>
        /// <p>A required value for the following pricing plans: <code>MobileAssetTracking</code>|
        /// <code>MobileAssetManagement</code>
        /// </p>
        /// <p>For more information about <a href="https://aws.amazon.com/location/data-providers/">data providers</a> and
        /// <a href="https://aws.amazon.com/location/pricing/">pricing plans</a>, see the
        /// Amazon Location Service product page.</p>
        /// <note>
        /// <p>This can only be updated when updating the <code>PricingPlan</code> in the same
        /// request.</p>
        /// <p>Amazon Location Service uses <code>PricingPlanDataSource</code> to calculate
        /// billing for your geofence collection. Your data won't be shared with the data
        /// provider, and will remain in your AWS account and Region unless you move it.</p>
        /// </note>
        pub fn pricing_plan_data_source(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pricing_plan_data_source(inp);
            self
        }
        pub fn set_pricing_plan_data_source(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan_data_source(input);
            self
        }
        /// <p>Updates the description for the geofence collection.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateMap<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_map_input::Builder,
    }
    impl<C, M, R> UpdateMap<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateMapOutput,
            smithy_http::result::SdkError<crate::error::UpdateMapError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateMapInputOperationOutputAlias,
                crate::output::UpdateMapOutput,
                crate::error::UpdateMapError,
                crate::input::UpdateMapInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the map resource to update.</p>
        pub fn map_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.map_name(inp);
            self
        }
        pub fn set_map_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_map_name(input);
            self
        }
        /// <p>Updates the pricing plan for the map resource.</p>
        /// <p>For more information about each pricing plan option restrictions, see <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing</a>.</p>
        pub fn pricing_plan(mut self, inp: crate::model::PricingPlan) -> Self {
            self.inner = self.inner.pricing_plan(inp);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan(input);
            self
        }
        /// <p>Updates the description for the map resource.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdatePlaceIndex<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_place_index_input::Builder,
    }
    impl<C, M, R> UpdatePlaceIndex<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdatePlaceIndexOutput,
            smithy_http::result::SdkError<crate::error::UpdatePlaceIndexError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdatePlaceIndexInputOperationOutputAlias,
                crate::output::UpdatePlaceIndexOutput,
                crate::error::UpdatePlaceIndexError,
                crate::input::UpdatePlaceIndexInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the place index resource to update.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.index_name(inp);
            self
        }
        pub fn set_index_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_index_name(input);
            self
        }
        /// <p>Updates the pricing plan for the place index resource.</p>
        /// <p>For more information about each pricing plan option restrictions, see <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service pricing</a>.</p>
        pub fn pricing_plan(mut self, inp: crate::model::PricingPlan) -> Self {
            self.inner = self.inner.pricing_plan(inp);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan(input);
            self
        }
        /// <p>Updates the description for the place index resource.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Updates the data storage option for the place index resource.</p>
        pub fn data_source_configuration(
            mut self,
            inp: crate::model::DataSourceConfiguration,
        ) -> Self {
            self.inner = self.inner.data_source_configuration(inp);
            self
        }
        pub fn set_data_source_configuration(
            mut self,
            input: std::option::Option<crate::model::DataSourceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_data_source_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRouteCalculator<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_route_calculator_input::Builder,
    }
    impl<C, M, R> UpdateRouteCalculator<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateRouteCalculatorOutput,
            smithy_http::result::SdkError<crate::error::UpdateRouteCalculatorError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateRouteCalculatorInputOperationOutputAlias,
                crate::output::UpdateRouteCalculatorOutput,
                crate::error::UpdateRouteCalculatorError,
                crate::input::UpdateRouteCalculatorInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the route calculator resource to update.</p>
        pub fn calculator_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.calculator_name(inp);
            self
        }
        pub fn set_calculator_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_calculator_name(input);
            self
        }
        /// <p>Updates the pricing plan for the route calculator resource.</p>
        /// <p>For more information about each pricing plan option restrictions, see <a href="https://aws.amazon.com/location/pricing/">Amazon Location
        /// Service pricing</a>.</p>
        pub fn pricing_plan(mut self, inp: crate::model::PricingPlan) -> Self {
            self.inner = self.inner.pricing_plan(inp);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan(input);
            self
        }
        /// <p>Updates the description for the route calculator resource.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateTracker<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_tracker_input::Builder,
    }
    impl<C, M, R> UpdateTracker<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateTrackerOutput,
            smithy_http::result::SdkError<crate::error::UpdateTrackerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateTrackerInputOperationOutputAlias,
                crate::output::UpdateTrackerOutput,
                crate::error::UpdateTrackerError,
                crate::input::UpdateTrackerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the tracker resource to update.</p>
        pub fn tracker_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tracker_name(inp);
            self
        }
        pub fn set_tracker_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tracker_name(input);
            self
        }
        /// <p>Updates the pricing plan for the tracker resource.</p>
        /// <p>For more information about each pricing plan option restrictions, see <a href="https://aws.amazon.com/location/pricing/">Amazon Location Service
        /// pricing</a>.</p>
        pub fn pricing_plan(mut self, inp: crate::model::PricingPlan) -> Self {
            self.inner = self.inner.pricing_plan(inp);
            self
        }
        pub fn set_pricing_plan(
            mut self,
            input: std::option::Option<crate::model::PricingPlan>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan(input);
            self
        }
        /// <p>Updates the data provider for the tracker resource. </p>
        /// <p>A required value for the following pricing plans: <code>MobileAssetTracking</code>| <code>MobileAssetManagement</code>
        /// </p>
        /// <p>For more information about <a href="https://aws.amazon.com/location/data-providers/">data providers</a> and <a href="https://aws.amazon.com/location/pricing/">pricing plans</a>, see the Amazon Location Service product
        /// page</p>
        /// <note>
        /// <p>This can only be updated when updating the <code>PricingPlan</code> in the same
        /// request.</p>
        /// <p>Amazon Location Service uses <code>PricingPlanDataSource</code> to calculate
        /// billing for your tracker resource. Your data won't be shared with the data provider,
        /// and will remain in your AWS account and Region unless you move it.</p>
        /// </note>
        pub fn pricing_plan_data_source(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pricing_plan_data_source(inp);
            self
        }
        pub fn set_pricing_plan_data_source(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pricing_plan_data_source(input);
            self
        }
        /// <p>Updates the description for the tracker resource.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, smithy_client::retry::Standard> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        smithy_client::retry::Standard,
    >
{
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
