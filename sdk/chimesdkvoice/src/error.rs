// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `ValidateE911Address` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateE911AddressError {
    /// Kind of error that occurred.
                    pub kind: ValidateE911AddressErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ValidateE911AddressError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ValidateE911AddressErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ValidateE911Address` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateE911AddressErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ValidateE911AddressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ValidateE911AddressErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            ValidateE911AddressErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            ValidateE911AddressErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ValidateE911AddressErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            ValidateE911AddressErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            ValidateE911AddressErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            ValidateE911AddressErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            ValidateE911AddressErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ValidateE911AddressError {
    fn code(&self) -> Option<&str> {
        ValidateE911AddressError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ValidateE911AddressError {
    /// Creates a new `ValidateE911AddressError`.
                    pub fn new(kind: ValidateE911AddressErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ValidateE911AddressError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ValidateE911AddressErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ValidateE911AddressError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ValidateE911AddressErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ValidateE911AddressErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ValidateE911AddressErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `ValidateE911AddressErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ValidateE911AddressErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `ValidateE911AddressErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ValidateE911AddressErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `ValidateE911AddressErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, ValidateE911AddressErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `ValidateE911AddressErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, ValidateE911AddressErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `ValidateE911AddressErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, ValidateE911AddressErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `ValidateE911AddressErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, ValidateE911AddressErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for ValidateE911AddressError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ValidateE911AddressErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            ValidateE911AddressErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            ValidateE911AddressErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            ValidateE911AddressErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            ValidateE911AddressErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            ValidateE911AddressErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            ValidateE911AddressErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            ValidateE911AddressErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnauthorizedClientException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl UnauthorizedClientException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<& crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl UnauthorizedClientException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for UnauthorizedClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthorizedClientException")?;
        if let Some(inner_1) = &self.message {
             {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UnauthorizedClientException {}
/// See [`UnauthorizedClientException`](crate::error::UnauthorizedClientException).
pub mod unauthorized_client_exception {
    
    /// A builder for [`UnauthorizedClientException`](crate::error::UnauthorizedClientException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`UnauthorizedClientException`](crate::error::UnauthorizedClientException).
        pub fn build(self) -> crate::error::UnauthorizedClientException {
            crate::error::UnauthorizedClientException {
                code: self.code
                ,
                message: self.message
                ,
            }
        }
    }
    
    
}
impl UnauthorizedClientException {
    /// Creates a new builder-style object to manufacture [`UnauthorizedClientException`](crate::error::UnauthorizedClientException).
    pub fn builder() -> crate::error::unauthorized_client_exception::Builder {
        crate::error::unauthorized_client_exception::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThrottledClientException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ThrottledClientException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<& crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl ThrottledClientException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ThrottledClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottledClientException")?;
        if let Some(inner_2) = &self.message {
             {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ThrottledClientException {}
/// See [`ThrottledClientException`](crate::error::ThrottledClientException).
pub mod throttled_client_exception {
    
    /// A builder for [`ThrottledClientException`](crate::error::ThrottledClientException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ThrottledClientException`](crate::error::ThrottledClientException).
        pub fn build(self) -> crate::error::ThrottledClientException {
            crate::error::ThrottledClientException {
                code: self.code
                ,
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ThrottledClientException {
    /// Creates a new builder-style object to manufacture [`ThrottledClientException`](crate::error::ThrottledClientException).
    pub fn builder() -> crate::error::throttled_client_exception::Builder {
        crate::error::throttled_client_exception::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceUnavailableException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ServiceUnavailableException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<& crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl ServiceUnavailableException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableException")?;
        if let Some(inner_3) = &self.message {
             {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableException {}
/// See [`ServiceUnavailableException`](crate::error::ServiceUnavailableException).
pub mod service_unavailable_exception {
    
    /// A builder for [`ServiceUnavailableException`](crate::error::ServiceUnavailableException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableException`](crate::error::ServiceUnavailableException).
        pub fn build(self) -> crate::error::ServiceUnavailableException {
            crate::error::ServiceUnavailableException {
                code: self.code
                ,
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ServiceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableException`](crate::error::ServiceUnavailableException).
    pub fn builder() -> crate::error::service_unavailable_exception::Builder {
        crate::error::service_unavailable_exception::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceFailureException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ServiceFailureException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<& crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl ServiceFailureException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ServiceFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceFailureException")?;
        if let Some(inner_4) = &self.message {
             {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ServiceFailureException {}
/// See [`ServiceFailureException`](crate::error::ServiceFailureException).
pub mod service_failure_exception {
    
    /// A builder for [`ServiceFailureException`](crate::error::ServiceFailureException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ServiceFailureException`](crate::error::ServiceFailureException).
        pub fn build(self) -> crate::error::ServiceFailureException {
            crate::error::ServiceFailureException {
                code: self.code
                ,
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ServiceFailureException {
    /// Creates a new builder-style object to manufacture [`ServiceFailureException`](crate::error::ServiceFailureException).
    pub fn builder() -> crate::error::service_failure_exception::Builder {
        crate::error::service_failure_exception::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NotFoundException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl NotFoundException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<& crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl NotFoundException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundException")?;
        if let Some(inner_5) = &self.message {
             {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundException {}
/// See [`NotFoundException`](crate::error::NotFoundException).
pub mod not_found_exception {
    
    /// A builder for [`NotFoundException`](crate::error::NotFoundException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`NotFoundException`](crate::error::NotFoundException).
        pub fn build(self) -> crate::error::NotFoundException {
            crate::error::NotFoundException {
                code: self.code
                ,
                message: self.message
                ,
            }
        }
    }
    
    
}
impl NotFoundException {
    /// Creates a new builder-style object to manufacture [`NotFoundException`](crate::error::NotFoundException).
    pub fn builder() -> crate::error::not_found_exception::Builder {
        crate::error::not_found_exception::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ForbiddenException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ForbiddenException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<& crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl ForbiddenException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ForbiddenException")?;
        if let Some(inner_6) = &self.message {
             {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ForbiddenException {}
/// See [`ForbiddenException`](crate::error::ForbiddenException).
pub mod forbidden_exception {
    
    /// A builder for [`ForbiddenException`](crate::error::ForbiddenException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ForbiddenException`](crate::error::ForbiddenException).
        pub fn build(self) -> crate::error::ForbiddenException {
            crate::error::ForbiddenException {
                code: self.code
                ,
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ForbiddenException {
    /// Creates a new builder-style object to manufacture [`ForbiddenException`](crate::error::ForbiddenException).
    pub fn builder() -> crate::error::forbidden_exception::Builder {
        crate::error::forbidden_exception::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BadRequestException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl BadRequestException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<& crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl BadRequestException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestException")?;
        if let Some(inner_7) = &self.message {
             {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestException {}
/// See [`BadRequestException`](crate::error::BadRequestException).
pub mod bad_request_exception {
    
    /// A builder for [`BadRequestException`](crate::error::BadRequestException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`BadRequestException`](crate::error::BadRequestException).
        pub fn build(self) -> crate::error::BadRequestException {
            crate::error::BadRequestException {
                code: self.code
                ,
                message: self.message
                ,
            }
        }
    }
    
    
}
impl BadRequestException {
    /// Creates a new builder-style object to manufacture [`BadRequestException`](crate::error::BadRequestException).
    pub fn builder() -> crate::error::bad_request_exception::Builder {
        crate::error::bad_request_exception::Builder::default()
    }
}

/// Error type for the `UpdateVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVoiceConnectorGroupError {
    /// Kind of error that occurred.
                    pub kind: UpdateVoiceConnectorGroupErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateVoiceConnectorGroupError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVoiceConnectorGroupErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateVoiceConnectorGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVoiceConnectorGroupErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateVoiceConnectorGroupErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateVoiceConnectorGroupErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateVoiceConnectorGroupErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateVoiceConnectorGroupError {
    fn code(&self) -> Option<&str> {
        UpdateVoiceConnectorGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateVoiceConnectorGroupError {
    /// Creates a new `UpdateVoiceConnectorGroupError`.
                    pub fn new(kind: UpdateVoiceConnectorGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateVoiceConnectorGroupError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateVoiceConnectorGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorGroupErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateVoiceConnectorGroupErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorGroupErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateVoiceConnectorGroupErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorGroupErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateVoiceConnectorGroupErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorGroupErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateVoiceConnectorGroupErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorGroupErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, UpdateVoiceConnectorGroupErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorGroupErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, UpdateVoiceConnectorGroupErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorGroupErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateVoiceConnectorGroupErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorGroupErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateVoiceConnectorGroupErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for UpdateVoiceConnectorGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVoiceConnectorGroupErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            UpdateVoiceConnectorGroupErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            UpdateVoiceConnectorGroupErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            UpdateVoiceConnectorGroupErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdateVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            UpdateVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            UpdateVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            UpdateVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            UpdateVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConflictException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ConflictException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<& crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl ConflictException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_8) = &self.message {
             {
                write!(f, ": {}", inner_8)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException).
pub mod conflict_exception {
    
    /// A builder for [`ConflictException`](crate::error::ConflictException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException).
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                code: self.code
                ,
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException).
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// Error type for the `UpdateVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVoiceConnectorError {
    /// Kind of error that occurred.
                    pub kind: UpdateVoiceConnectorErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateVoiceConnectorError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVoiceConnectorErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateVoiceConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVoiceConnectorErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateVoiceConnectorErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateVoiceConnectorErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateVoiceConnectorErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateVoiceConnectorErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateVoiceConnectorErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateVoiceConnectorErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateVoiceConnectorErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateVoiceConnectorError {
    fn code(&self) -> Option<&str> {
        UpdateVoiceConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateVoiceConnectorError {
    /// Creates a new `UpdateVoiceConnectorError`.
                    pub fn new(kind: UpdateVoiceConnectorErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateVoiceConnectorError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateVoiceConnectorError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateVoiceConnectorErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateVoiceConnectorErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateVoiceConnectorErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, UpdateVoiceConnectorErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, UpdateVoiceConnectorErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateVoiceConnectorErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateVoiceConnectorErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for UpdateVoiceConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVoiceConnectorErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            UpdateVoiceConnectorErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            UpdateVoiceConnectorErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdateVoiceConnectorErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            UpdateVoiceConnectorErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            UpdateVoiceConnectorErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            UpdateVoiceConnectorErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            UpdateVoiceConnectorErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `UpdateSipRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSipRuleError {
    /// Kind of error that occurred.
                    pub kind: UpdateSipRuleErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateSipRuleError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateSipRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSipRuleErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateSipRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSipRuleErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipRuleErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipRuleErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipRuleErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipRuleErrorKind::ResourceLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipRuleErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipRuleErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipRuleErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipRuleErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipRuleErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateSipRuleError {
    fn code(&self) -> Option<&str> {
        UpdateSipRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSipRuleError {
    /// Creates a new `UpdateSipRuleError`.
                    pub fn new(kind: UpdateSipRuleErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateSipRuleError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateSipRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateSipRuleErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipRuleErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipRuleErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipRuleErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipRuleErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipRuleErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipRuleErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipRuleErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipRuleErrorKind::ResourceLimitExceededException`.
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipRuleErrorKind::ResourceLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipRuleErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipRuleErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipRuleErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipRuleErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipRuleErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipRuleErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipRuleErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipRuleErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for UpdateSipRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSipRuleErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            UpdateSipRuleErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            UpdateSipRuleErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            UpdateSipRuleErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdateSipRuleErrorKind::ResourceLimitExceededException(_inner) =>
            Some(_inner)
            ,
            UpdateSipRuleErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            UpdateSipRuleErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            UpdateSipRuleErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            UpdateSipRuleErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            UpdateSipRuleErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceLimitExceededException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ResourceLimitExceededException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<& crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl ResourceLimitExceededException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ResourceLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceLimitExceededException")?;
        if let Some(inner_9) = &self.message {
             {
                write!(f, ": {}", inner_9)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceLimitExceededException {}
/// See [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException).
pub mod resource_limit_exceeded_exception {
    
    /// A builder for [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException).
        pub fn build(self) -> crate::error::ResourceLimitExceededException {
            crate::error::ResourceLimitExceededException {
                code: self.code
                ,
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ResourceLimitExceededException {
    /// Creates a new builder-style object to manufacture [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException).
    pub fn builder() -> crate::error::resource_limit_exceeded_exception::Builder {
        crate::error::resource_limit_exceeded_exception::Builder::default()
    }
}

/// Error type for the `UpdateSipMediaApplicationCall` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSipMediaApplicationCallError {
    /// Kind of error that occurred.
                    pub kind: UpdateSipMediaApplicationCallErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateSipMediaApplicationCallError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateSipMediaApplicationCallErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateSipMediaApplicationCall` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSipMediaApplicationCallErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateSipMediaApplicationCallError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSipMediaApplicationCallErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipMediaApplicationCallErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipMediaApplicationCallErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipMediaApplicationCallErrorKind::ResourceLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipMediaApplicationCallErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipMediaApplicationCallErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipMediaApplicationCallErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipMediaApplicationCallErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipMediaApplicationCallErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateSipMediaApplicationCallError {
    fn code(&self) -> Option<&str> {
        UpdateSipMediaApplicationCallError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSipMediaApplicationCallError {
    /// Creates a new `UpdateSipMediaApplicationCallError`.
                    pub fn new(kind: UpdateSipMediaApplicationCallErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateSipMediaApplicationCallError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateSipMediaApplicationCallErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateSipMediaApplicationCallError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateSipMediaApplicationCallErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationCallErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipMediaApplicationCallErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationCallErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipMediaApplicationCallErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationCallErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipMediaApplicationCallErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationCallErrorKind::ResourceLimitExceededException`.
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipMediaApplicationCallErrorKind::ResourceLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationCallErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipMediaApplicationCallErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationCallErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipMediaApplicationCallErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationCallErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipMediaApplicationCallErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationCallErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipMediaApplicationCallErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for UpdateSipMediaApplicationCallError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSipMediaApplicationCallErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            UpdateSipMediaApplicationCallErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            UpdateSipMediaApplicationCallErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdateSipMediaApplicationCallErrorKind::ResourceLimitExceededException(_inner) =>
            Some(_inner)
            ,
            UpdateSipMediaApplicationCallErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            UpdateSipMediaApplicationCallErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            UpdateSipMediaApplicationCallErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            UpdateSipMediaApplicationCallErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            UpdateSipMediaApplicationCallErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `UpdateSipMediaApplication` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSipMediaApplicationError {
    /// Kind of error that occurred.
                    pub kind: UpdateSipMediaApplicationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateSipMediaApplicationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateSipMediaApplication` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSipMediaApplicationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateSipMediaApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSipMediaApplicationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipMediaApplicationErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipMediaApplicationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipMediaApplicationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipMediaApplicationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipMediaApplicationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateSipMediaApplicationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateSipMediaApplicationError {
    fn code(&self) -> Option<&str> {
        UpdateSipMediaApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSipMediaApplicationError {
    /// Creates a new `UpdateSipMediaApplicationError`.
                    pub fn new(kind: UpdateSipMediaApplicationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateSipMediaApplicationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateSipMediaApplicationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipMediaApplicationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipMediaApplicationErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipMediaApplicationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipMediaApplicationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipMediaApplicationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipMediaApplicationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipMediaApplicationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipMediaApplicationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for UpdateSipMediaApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSipMediaApplicationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            UpdateSipMediaApplicationErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            UpdateSipMediaApplicationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            UpdateSipMediaApplicationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdateSipMediaApplicationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            UpdateSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            UpdateSipMediaApplicationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            UpdateSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            UpdateSipMediaApplicationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `UpdateProxySession` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateProxySessionError {
    /// Kind of error that occurred.
                    pub kind: UpdateProxySessionErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateProxySessionError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateProxySession` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateProxySessionErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateProxySessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateProxySessionErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateProxySessionErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateProxySessionErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateProxySessionErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateProxySessionErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateProxySessionErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateProxySessionErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateProxySessionErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateProxySessionError {
    fn code(&self) -> Option<&str> {
        UpdateProxySessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateProxySessionError {
    /// Creates a new `UpdateProxySessionError`.
                    pub fn new(kind: UpdateProxySessionErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateProxySessionError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateProxySessionError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateProxySessionErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateProxySessionErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `UpdateProxySessionErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateProxySessionErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `UpdateProxySessionErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateProxySessionErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateProxySessionErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, UpdateProxySessionErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `UpdateProxySessionErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, UpdateProxySessionErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdateProxySessionErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateProxySessionErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `UpdateProxySessionErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateProxySessionErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for UpdateProxySessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateProxySessionErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            UpdateProxySessionErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            UpdateProxySessionErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdateProxySessionErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            UpdateProxySessionErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            UpdateProxySessionErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            UpdateProxySessionErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            UpdateProxySessionErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `UpdatePhoneNumberSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePhoneNumberSettingsError {
    /// Kind of error that occurred.
                    pub kind: UpdatePhoneNumberSettingsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdatePhoneNumberSettingsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdatePhoneNumberSettingsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdatePhoneNumberSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePhoneNumberSettingsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdatePhoneNumberSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePhoneNumberSettingsErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePhoneNumberSettingsErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePhoneNumberSettingsErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePhoneNumberSettingsErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePhoneNumberSettingsErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePhoneNumberSettingsErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePhoneNumberSettingsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdatePhoneNumberSettingsError {
    fn code(&self) -> Option<&str> {
        UpdatePhoneNumberSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePhoneNumberSettingsError {
    /// Creates a new `UpdatePhoneNumberSettingsError`.
                    pub fn new(kind: UpdatePhoneNumberSettingsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdatePhoneNumberSettingsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdatePhoneNumberSettingsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdatePhoneNumberSettingsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdatePhoneNumberSettingsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberSettingsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdatePhoneNumberSettingsErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberSettingsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdatePhoneNumberSettingsErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberSettingsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, UpdatePhoneNumberSettingsErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberSettingsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, UpdatePhoneNumberSettingsErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberSettingsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, UpdatePhoneNumberSettingsErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberSettingsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, UpdatePhoneNumberSettingsErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for UpdatePhoneNumberSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePhoneNumberSettingsErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            UpdatePhoneNumberSettingsErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            UpdatePhoneNumberSettingsErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            UpdatePhoneNumberSettingsErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            UpdatePhoneNumberSettingsErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            UpdatePhoneNumberSettingsErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            UpdatePhoneNumberSettingsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `UpdatePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePhoneNumberError {
    /// Kind of error that occurred.
                    pub kind: UpdatePhoneNumberErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdatePhoneNumberError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdatePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdatePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePhoneNumberErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdatePhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePhoneNumberErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePhoneNumberErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePhoneNumberErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePhoneNumberErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePhoneNumberErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePhoneNumberErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePhoneNumberErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePhoneNumberErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePhoneNumberErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdatePhoneNumberError {
    fn code(&self) -> Option<&str> {
        UpdatePhoneNumberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePhoneNumberError {
    /// Creates a new `UpdatePhoneNumberError`.
                    pub fn new(kind: UpdatePhoneNumberErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdatePhoneNumberError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdatePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdatePhoneNumberError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdatePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdatePhoneNumberErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdatePhoneNumberErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdatePhoneNumberErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdatePhoneNumberErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, UpdatePhoneNumberErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, UpdatePhoneNumberErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, UpdatePhoneNumberErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, UpdatePhoneNumberErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for UpdatePhoneNumberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePhoneNumberErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            UpdatePhoneNumberErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            UpdatePhoneNumberErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            UpdatePhoneNumberErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdatePhoneNumberErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            UpdatePhoneNumberErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            UpdatePhoneNumberErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            UpdatePhoneNumberErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            UpdatePhoneNumberErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `UpdateGlobalSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGlobalSettingsError {
    /// Kind of error that occurred.
                    pub kind: UpdateGlobalSettingsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateGlobalSettingsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateGlobalSettingsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateGlobalSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGlobalSettingsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateGlobalSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateGlobalSettingsErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateGlobalSettingsErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateGlobalSettingsErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateGlobalSettingsErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateGlobalSettingsErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateGlobalSettingsErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateGlobalSettingsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateGlobalSettingsError {
    fn code(&self) -> Option<&str> {
        UpdateGlobalSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateGlobalSettingsError {
    /// Creates a new `UpdateGlobalSettingsError`.
                    pub fn new(kind: UpdateGlobalSettingsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateGlobalSettingsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateGlobalSettingsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateGlobalSettingsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateGlobalSettingsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateGlobalSettingsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateGlobalSettingsErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `UpdateGlobalSettingsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateGlobalSettingsErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `UpdateGlobalSettingsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, UpdateGlobalSettingsErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `UpdateGlobalSettingsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, UpdateGlobalSettingsErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdateGlobalSettingsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateGlobalSettingsErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `UpdateGlobalSettingsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateGlobalSettingsErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for UpdateGlobalSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateGlobalSettingsErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            UpdateGlobalSettingsErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            UpdateGlobalSettingsErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            UpdateGlobalSettingsErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            UpdateGlobalSettingsErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            UpdateGlobalSettingsErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            UpdateGlobalSettingsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `SearchAvailablePhoneNumbers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SearchAvailablePhoneNumbersError {
    /// Kind of error that occurred.
                    pub kind: SearchAvailablePhoneNumbersErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for SearchAvailablePhoneNumbersError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: SearchAvailablePhoneNumbersErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `SearchAvailablePhoneNumbers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SearchAvailablePhoneNumbersErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for SearchAvailablePhoneNumbersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SearchAvailablePhoneNumbersErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            SearchAvailablePhoneNumbersErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            SearchAvailablePhoneNumbersErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            SearchAvailablePhoneNumbersErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            SearchAvailablePhoneNumbersErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            SearchAvailablePhoneNumbersErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            SearchAvailablePhoneNumbersErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            SearchAvailablePhoneNumbersErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for SearchAvailablePhoneNumbersError {
    fn code(&self) -> Option<&str> {
        SearchAvailablePhoneNumbersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl SearchAvailablePhoneNumbersError {
    /// Creates a new `SearchAvailablePhoneNumbersError`.
                    pub fn new(kind: SearchAvailablePhoneNumbersErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `SearchAvailablePhoneNumbersError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: SearchAvailablePhoneNumbersErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `SearchAvailablePhoneNumbersError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: SearchAvailablePhoneNumbersErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `SearchAvailablePhoneNumbersErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, SearchAvailablePhoneNumbersErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `SearchAvailablePhoneNumbersErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, SearchAvailablePhoneNumbersErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `SearchAvailablePhoneNumbersErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, SearchAvailablePhoneNumbersErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `SearchAvailablePhoneNumbersErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, SearchAvailablePhoneNumbersErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `SearchAvailablePhoneNumbersErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, SearchAvailablePhoneNumbersErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `SearchAvailablePhoneNumbersErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, SearchAvailablePhoneNumbersErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `SearchAvailablePhoneNumbersErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, SearchAvailablePhoneNumbersErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for SearchAvailablePhoneNumbersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SearchAvailablePhoneNumbersErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            SearchAvailablePhoneNumbersErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            SearchAvailablePhoneNumbersErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            SearchAvailablePhoneNumbersErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            SearchAvailablePhoneNumbersErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            SearchAvailablePhoneNumbersErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            SearchAvailablePhoneNumbersErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            SearchAvailablePhoneNumbersErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessDeniedException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl AccessDeniedException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<& crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl AccessDeniedException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_10) = &self.message {
             {
                write!(f, ": {}", inner_10)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException).
pub mod access_denied_exception {
    
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException).
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                code: self.code
                ,
                message: self.message
                ,
            }
        }
    }
    
    
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException).
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// Error type for the `RestorePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestorePhoneNumberError {
    /// Kind of error that occurred.
                    pub kind: RestorePhoneNumberErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for RestorePhoneNumberError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: RestorePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `RestorePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestorePhoneNumberErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for RestorePhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestorePhoneNumberErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            RestorePhoneNumberErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            RestorePhoneNumberErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            RestorePhoneNumberErrorKind::ResourceLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            RestorePhoneNumberErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            RestorePhoneNumberErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            RestorePhoneNumberErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            RestorePhoneNumberErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            RestorePhoneNumberErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RestorePhoneNumberError {
    fn code(&self) -> Option<&str> {
        RestorePhoneNumberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestorePhoneNumberError {
    /// Creates a new `RestorePhoneNumberError`.
                    pub fn new(kind: RestorePhoneNumberErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `RestorePhoneNumberError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: RestorePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `RestorePhoneNumberError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: RestorePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `RestorePhoneNumberErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, RestorePhoneNumberErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `RestorePhoneNumberErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, RestorePhoneNumberErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `RestorePhoneNumberErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, RestorePhoneNumberErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `RestorePhoneNumberErrorKind::ResourceLimitExceededException`.
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, RestorePhoneNumberErrorKind::ResourceLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `RestorePhoneNumberErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, RestorePhoneNumberErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `RestorePhoneNumberErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, RestorePhoneNumberErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `RestorePhoneNumberErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, RestorePhoneNumberErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `RestorePhoneNumberErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, RestorePhoneNumberErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for RestorePhoneNumberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestorePhoneNumberErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            RestorePhoneNumberErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            RestorePhoneNumberErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            RestorePhoneNumberErrorKind::ResourceLimitExceededException(_inner) =>
            Some(_inner)
            ,
            RestorePhoneNumberErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            RestorePhoneNumberErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            RestorePhoneNumberErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            RestorePhoneNumberErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            RestorePhoneNumberErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `PutVoiceConnectorTerminationCredentials` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorTerminationCredentialsError {
    /// Kind of error that occurred.
                    pub kind: PutVoiceConnectorTerminationCredentialsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for PutVoiceConnectorTerminationCredentialsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutVoiceConnectorTerminationCredentialsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `PutVoiceConnectorTerminationCredentials` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorTerminationCredentialsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutVoiceConnectorTerminationCredentialsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorTerminationCredentialsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutVoiceConnectorTerminationCredentialsError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorTerminationCredentialsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorTerminationCredentialsError {
    /// Creates a new `PutVoiceConnectorTerminationCredentialsError`.
                    pub fn new(kind: PutVoiceConnectorTerminationCredentialsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `PutVoiceConnectorTerminationCredentialsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: PutVoiceConnectorTerminationCredentialsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `PutVoiceConnectorTerminationCredentialsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: PutVoiceConnectorTerminationCredentialsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationCredentialsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationCredentialsErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for PutVoiceConnectorTerminationCredentialsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorTerminationCredentialsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `PutVoiceConnectorTermination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorTerminationError {
    /// Kind of error that occurred.
                    pub kind: PutVoiceConnectorTerminationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for PutVoiceConnectorTerminationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutVoiceConnectorTerminationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `PutVoiceConnectorTermination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorTerminationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutVoiceConnectorTerminationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorTerminationErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorTerminationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorTerminationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorTerminationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorTerminationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorTerminationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorTerminationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutVoiceConnectorTerminationError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorTerminationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorTerminationError {
    /// Creates a new `PutVoiceConnectorTerminationError`.
                    pub fn new(kind: PutVoiceConnectorTerminationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `PutVoiceConnectorTerminationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: PutVoiceConnectorTerminationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `PutVoiceConnectorTerminationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: PutVoiceConnectorTerminationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorTerminationErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorTerminationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorTerminationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorTerminationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorTerminationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorTerminationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for PutVoiceConnectorTerminationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorTerminationErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorTerminationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorTerminationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorTerminationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorTerminationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorTerminationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorTerminationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `PutVoiceConnectorStreamingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorStreamingConfigurationError {
    /// Kind of error that occurred.
                    pub kind: PutVoiceConnectorStreamingConfigurationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for PutVoiceConnectorStreamingConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutVoiceConnectorStreamingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `PutVoiceConnectorStreamingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorStreamingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutVoiceConnectorStreamingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorStreamingConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutVoiceConnectorStreamingConfigurationError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorStreamingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorStreamingConfigurationError {
    /// Creates a new `PutVoiceConnectorStreamingConfigurationError`.
                    pub fn new(kind: PutVoiceConnectorStreamingConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `PutVoiceConnectorStreamingConfigurationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: PutVoiceConnectorStreamingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `PutVoiceConnectorStreamingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: PutVoiceConnectorStreamingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `PutVoiceConnectorStreamingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorStreamingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for PutVoiceConnectorStreamingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorStreamingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `PutVoiceConnectorProxy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorProxyError {
    /// Kind of error that occurred.
                    pub kind: PutVoiceConnectorProxyErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for PutVoiceConnectorProxyError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutVoiceConnectorProxyErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `PutVoiceConnectorProxy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorProxyErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutVoiceConnectorProxyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorProxyErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorProxyErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorProxyErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorProxyErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorProxyErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorProxyErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorProxyErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorProxyErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorProxyErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutVoiceConnectorProxyError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorProxyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorProxyError {
    /// Creates a new `PutVoiceConnectorProxyError`.
                    pub fn new(kind: PutVoiceConnectorProxyErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `PutVoiceConnectorProxyError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: PutVoiceConnectorProxyErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `PutVoiceConnectorProxyError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: PutVoiceConnectorProxyErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `PutVoiceConnectorProxyErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorProxyErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorProxyErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorProxyErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorProxyErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorProxyErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorProxyErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorProxyErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorProxyErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorProxyErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorProxyErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorProxyErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorProxyErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorProxyErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorProxyErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorProxyErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for PutVoiceConnectorProxyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorProxyErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorProxyErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorProxyErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorProxyErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorProxyErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorProxyErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorProxyErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorProxyErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorProxyErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `PutVoiceConnectorOrigination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorOriginationError {
    /// Kind of error that occurred.
                    pub kind: PutVoiceConnectorOriginationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for PutVoiceConnectorOriginationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutVoiceConnectorOriginationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `PutVoiceConnectorOrigination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorOriginationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutVoiceConnectorOriginationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorOriginationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorOriginationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorOriginationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorOriginationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorOriginationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorOriginationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutVoiceConnectorOriginationError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorOriginationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorOriginationError {
    /// Creates a new `PutVoiceConnectorOriginationError`.
                    pub fn new(kind: PutVoiceConnectorOriginationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `PutVoiceConnectorOriginationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: PutVoiceConnectorOriginationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `PutVoiceConnectorOriginationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: PutVoiceConnectorOriginationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `PutVoiceConnectorOriginationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorOriginationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorOriginationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorOriginationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorOriginationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorOriginationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorOriginationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorOriginationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorOriginationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorOriginationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorOriginationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorOriginationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for PutVoiceConnectorOriginationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorOriginationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorOriginationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorOriginationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorOriginationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorOriginationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorOriginationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `PutVoiceConnectorLoggingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorLoggingConfigurationError {
    /// Kind of error that occurred.
                    pub kind: PutVoiceConnectorLoggingConfigurationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for PutVoiceConnectorLoggingConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutVoiceConnectorLoggingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `PutVoiceConnectorLoggingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorLoggingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutVoiceConnectorLoggingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorLoggingConfigurationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorLoggingConfigurationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorLoggingConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutVoiceConnectorLoggingConfigurationError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorLoggingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorLoggingConfigurationError {
    /// Creates a new `PutVoiceConnectorLoggingConfigurationError`.
                    pub fn new(kind: PutVoiceConnectorLoggingConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `PutVoiceConnectorLoggingConfigurationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: PutVoiceConnectorLoggingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `PutVoiceConnectorLoggingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: PutVoiceConnectorLoggingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `PutVoiceConnectorLoggingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorLoggingConfigurationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorLoggingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorLoggingConfigurationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for PutVoiceConnectorLoggingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorLoggingConfigurationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorLoggingConfigurationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorLoggingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `PutVoiceConnectorEmergencyCallingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorEmergencyCallingConfigurationError {
    /// Kind of error that occurred.
                    pub kind: PutVoiceConnectorEmergencyCallingConfigurationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for PutVoiceConnectorEmergencyCallingConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `PutVoiceConnectorEmergencyCallingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorEmergencyCallingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutVoiceConnectorEmergencyCallingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutVoiceConnectorEmergencyCallingConfigurationError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorEmergencyCallingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorEmergencyCallingConfigurationError {
    /// Creates a new `PutVoiceConnectorEmergencyCallingConfigurationError`.
                    pub fn new(kind: PutVoiceConnectorEmergencyCallingConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `PutVoiceConnectorEmergencyCallingConfigurationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: PutVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `PutVoiceConnectorEmergencyCallingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: PutVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `PutVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, PutVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for PutVoiceConnectorEmergencyCallingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `PutSipMediaApplicationLoggingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutSipMediaApplicationLoggingConfigurationError {
    /// Kind of error that occurred.
                    pub kind: PutSipMediaApplicationLoggingConfigurationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for PutSipMediaApplicationLoggingConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `PutSipMediaApplicationLoggingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutSipMediaApplicationLoggingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutSipMediaApplicationLoggingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            PutSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            PutSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            PutSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutSipMediaApplicationLoggingConfigurationError {
    fn code(&self) -> Option<&str> {
        PutSipMediaApplicationLoggingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutSipMediaApplicationLoggingConfigurationError {
    /// Creates a new `PutSipMediaApplicationLoggingConfigurationError`.
                    pub fn new(kind: PutSipMediaApplicationLoggingConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `PutSipMediaApplicationLoggingConfigurationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: PutSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `PutSipMediaApplicationLoggingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: PutSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, PutSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, PutSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, PutSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, PutSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for PutSipMediaApplicationLoggingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            PutSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            PutSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            PutSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            PutSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            PutSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `PutSipMediaApplicationAlexaSkillConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutSipMediaApplicationAlexaSkillConfigurationError {
    /// Kind of error that occurred.
                    pub kind: PutSipMediaApplicationAlexaSkillConfigurationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for PutSipMediaApplicationAlexaSkillConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `PutSipMediaApplicationAlexaSkillConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutSipMediaApplicationAlexaSkillConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutSipMediaApplicationAlexaSkillConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutSipMediaApplicationAlexaSkillConfigurationError {
    fn code(&self) -> Option<&str> {
        PutSipMediaApplicationAlexaSkillConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutSipMediaApplicationAlexaSkillConfigurationError {
    /// Creates a new `PutSipMediaApplicationAlexaSkillConfigurationError`.
                    pub fn new(kind: PutSipMediaApplicationAlexaSkillConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `PutSipMediaApplicationAlexaSkillConfigurationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: PutSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `PutSipMediaApplicationAlexaSkillConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: PutSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationAlexaSkillConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, PutSipMediaApplicationAlexaSkillConfigurationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationAlexaSkillConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutSipMediaApplicationAlexaSkillConfigurationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationAlexaSkillConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, PutSipMediaApplicationAlexaSkillConfigurationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for PutSipMediaApplicationAlexaSkillConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListVoiceConnectorTerminationCredentials` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVoiceConnectorTerminationCredentialsError {
    /// Kind of error that occurred.
                    pub kind: ListVoiceConnectorTerminationCredentialsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListVoiceConnectorTerminationCredentialsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListVoiceConnectorTerminationCredentialsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListVoiceConnectorTerminationCredentials` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVoiceConnectorTerminationCredentialsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListVoiceConnectorTerminationCredentialsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            ListVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            ListVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            ListVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            ListVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListVoiceConnectorTerminationCredentialsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListVoiceConnectorTerminationCredentialsError {
    fn code(&self) -> Option<&str> {
        ListVoiceConnectorTerminationCredentialsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVoiceConnectorTerminationCredentialsError {
    /// Creates a new `ListVoiceConnectorTerminationCredentialsError`.
                    pub fn new(kind: ListVoiceConnectorTerminationCredentialsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListVoiceConnectorTerminationCredentialsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListVoiceConnectorTerminationCredentialsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListVoiceConnectorTerminationCredentialsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListVoiceConnectorTerminationCredentialsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListVoiceConnectorTerminationCredentialsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorTerminationCredentialsErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, ListVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, ListVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, ListVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, ListVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for ListVoiceConnectorTerminationCredentialsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            ListVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            ListVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            ListVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            ListVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            ListVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            ListVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            ListVoiceConnectorTerminationCredentialsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListVoiceConnectors` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVoiceConnectorsError {
    /// Kind of error that occurred.
                    pub kind: ListVoiceConnectorsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListVoiceConnectorsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListVoiceConnectorsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListVoiceConnectors` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVoiceConnectorsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListVoiceConnectorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVoiceConnectorsErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            ListVoiceConnectorsErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            ListVoiceConnectorsErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            ListVoiceConnectorsErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            ListVoiceConnectorsErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListVoiceConnectorsErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListVoiceConnectorsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListVoiceConnectorsError {
    fn code(&self) -> Option<&str> {
        ListVoiceConnectorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVoiceConnectorsError {
    /// Creates a new `ListVoiceConnectorsError`.
                    pub fn new(kind: ListVoiceConnectorsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListVoiceConnectorsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListVoiceConnectorsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListVoiceConnectorsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListVoiceConnectorsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListVoiceConnectorsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListVoiceConnectorsErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListVoiceConnectorsErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, ListVoiceConnectorsErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, ListVoiceConnectorsErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, ListVoiceConnectorsErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, ListVoiceConnectorsErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for ListVoiceConnectorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVoiceConnectorsErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            ListVoiceConnectorsErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            ListVoiceConnectorsErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            ListVoiceConnectorsErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            ListVoiceConnectorsErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            ListVoiceConnectorsErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            ListVoiceConnectorsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListVoiceConnectorGroups` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVoiceConnectorGroupsError {
    /// Kind of error that occurred.
                    pub kind: ListVoiceConnectorGroupsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListVoiceConnectorGroupsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListVoiceConnectorGroupsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListVoiceConnectorGroups` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVoiceConnectorGroupsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListVoiceConnectorGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVoiceConnectorGroupsErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            ListVoiceConnectorGroupsErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            ListVoiceConnectorGroupsErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            ListVoiceConnectorGroupsErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            ListVoiceConnectorGroupsErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListVoiceConnectorGroupsErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListVoiceConnectorGroupsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListVoiceConnectorGroupsError {
    fn code(&self) -> Option<&str> {
        ListVoiceConnectorGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVoiceConnectorGroupsError {
    /// Creates a new `ListVoiceConnectorGroupsError`.
                    pub fn new(kind: ListVoiceConnectorGroupsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListVoiceConnectorGroupsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListVoiceConnectorGroupsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListVoiceConnectorGroupsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListVoiceConnectorGroupsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListVoiceConnectorGroupsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListVoiceConnectorGroupsErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorGroupsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListVoiceConnectorGroupsErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorGroupsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, ListVoiceConnectorGroupsErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorGroupsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, ListVoiceConnectorGroupsErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorGroupsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, ListVoiceConnectorGroupsErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorGroupsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, ListVoiceConnectorGroupsErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for ListVoiceConnectorGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVoiceConnectorGroupsErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            ListVoiceConnectorGroupsErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            ListVoiceConnectorGroupsErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            ListVoiceConnectorGroupsErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            ListVoiceConnectorGroupsErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            ListVoiceConnectorGroupsErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            ListVoiceConnectorGroupsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListSupportedPhoneNumberCountries` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSupportedPhoneNumberCountriesError {
    /// Kind of error that occurred.
                    pub kind: ListSupportedPhoneNumberCountriesErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListSupportedPhoneNumberCountriesError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListSupportedPhoneNumberCountriesErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListSupportedPhoneNumberCountries` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSupportedPhoneNumberCountriesErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListSupportedPhoneNumberCountriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSupportedPhoneNumberCountriesErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListSupportedPhoneNumberCountriesErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            ListSupportedPhoneNumberCountriesErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            ListSupportedPhoneNumberCountriesErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            ListSupportedPhoneNumberCountriesErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            ListSupportedPhoneNumberCountriesErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListSupportedPhoneNumberCountriesErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListSupportedPhoneNumberCountriesErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListSupportedPhoneNumberCountriesError {
    fn code(&self) -> Option<&str> {
        ListSupportedPhoneNumberCountriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSupportedPhoneNumberCountriesError {
    /// Creates a new `ListSupportedPhoneNumberCountriesError`.
                    pub fn new(kind: ListSupportedPhoneNumberCountriesErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListSupportedPhoneNumberCountriesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListSupportedPhoneNumberCountriesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListSupportedPhoneNumberCountriesError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListSupportedPhoneNumberCountriesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListSupportedPhoneNumberCountriesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListSupportedPhoneNumberCountriesErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListSupportedPhoneNumberCountriesErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListSupportedPhoneNumberCountriesErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `ListSupportedPhoneNumberCountriesErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListSupportedPhoneNumberCountriesErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `ListSupportedPhoneNumberCountriesErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, ListSupportedPhoneNumberCountriesErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `ListSupportedPhoneNumberCountriesErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, ListSupportedPhoneNumberCountriesErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `ListSupportedPhoneNumberCountriesErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, ListSupportedPhoneNumberCountriesErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `ListSupportedPhoneNumberCountriesErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, ListSupportedPhoneNumberCountriesErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for ListSupportedPhoneNumberCountriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSupportedPhoneNumberCountriesErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListSupportedPhoneNumberCountriesErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            ListSupportedPhoneNumberCountriesErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            ListSupportedPhoneNumberCountriesErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            ListSupportedPhoneNumberCountriesErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            ListSupportedPhoneNumberCountriesErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            ListSupportedPhoneNumberCountriesErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            ListSupportedPhoneNumberCountriesErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListSipRules` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSipRulesError {
    /// Kind of error that occurred.
                    pub kind: ListSipRulesErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListSipRulesError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListSipRulesErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListSipRules` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSipRulesErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListSipRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSipRulesErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            ListSipRulesErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            ListSipRulesErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            ListSipRulesErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            ListSipRulesErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListSipRulesErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListSipRulesErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListSipRulesError {
    fn code(&self) -> Option<&str> {
        ListSipRulesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSipRulesError {
    /// Creates a new `ListSipRulesError`.
                    pub fn new(kind: ListSipRulesErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListSipRulesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListSipRulesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListSipRulesError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListSipRulesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListSipRulesErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListSipRulesErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `ListSipRulesErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListSipRulesErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `ListSipRulesErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, ListSipRulesErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `ListSipRulesErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, ListSipRulesErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `ListSipRulesErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, ListSipRulesErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `ListSipRulesErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, ListSipRulesErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for ListSipRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSipRulesErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            ListSipRulesErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            ListSipRulesErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            ListSipRulesErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            ListSipRulesErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            ListSipRulesErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            ListSipRulesErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListSipMediaApplications` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSipMediaApplicationsError {
    /// Kind of error that occurred.
                    pub kind: ListSipMediaApplicationsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListSipMediaApplicationsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListSipMediaApplicationsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListSipMediaApplications` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSipMediaApplicationsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListSipMediaApplicationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSipMediaApplicationsErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            ListSipMediaApplicationsErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            ListSipMediaApplicationsErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            ListSipMediaApplicationsErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            ListSipMediaApplicationsErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListSipMediaApplicationsErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListSipMediaApplicationsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListSipMediaApplicationsError {
    fn code(&self) -> Option<&str> {
        ListSipMediaApplicationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSipMediaApplicationsError {
    /// Creates a new `ListSipMediaApplicationsError`.
                    pub fn new(kind: ListSipMediaApplicationsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListSipMediaApplicationsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListSipMediaApplicationsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListSipMediaApplicationsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListSipMediaApplicationsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListSipMediaApplicationsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListSipMediaApplicationsErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `ListSipMediaApplicationsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListSipMediaApplicationsErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `ListSipMediaApplicationsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, ListSipMediaApplicationsErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `ListSipMediaApplicationsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, ListSipMediaApplicationsErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `ListSipMediaApplicationsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, ListSipMediaApplicationsErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `ListSipMediaApplicationsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, ListSipMediaApplicationsErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for ListSipMediaApplicationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSipMediaApplicationsErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            ListSipMediaApplicationsErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            ListSipMediaApplicationsErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            ListSipMediaApplicationsErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            ListSipMediaApplicationsErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            ListSipMediaApplicationsErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            ListSipMediaApplicationsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListProxySessions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListProxySessionsError {
    /// Kind of error that occurred.
                    pub kind: ListProxySessionsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListProxySessionsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListProxySessionsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListProxySessions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListProxySessionsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListProxySessionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListProxySessionsErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            ListProxySessionsErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            ListProxySessionsErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListProxySessionsErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            ListProxySessionsErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            ListProxySessionsErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListProxySessionsErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListProxySessionsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListProxySessionsError {
    fn code(&self) -> Option<&str> {
        ListProxySessionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListProxySessionsError {
    /// Creates a new `ListProxySessionsError`.
                    pub fn new(kind: ListProxySessionsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListProxySessionsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListProxySessionsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListProxySessionsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListProxySessionsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListProxySessionsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListProxySessionsErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `ListProxySessionsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListProxySessionsErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `ListProxySessionsErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListProxySessionsErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListProxySessionsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, ListProxySessionsErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `ListProxySessionsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, ListProxySessionsErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `ListProxySessionsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, ListProxySessionsErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `ListProxySessionsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, ListProxySessionsErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for ListProxySessionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListProxySessionsErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            ListProxySessionsErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            ListProxySessionsErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            ListProxySessionsErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            ListProxySessionsErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            ListProxySessionsErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            ListProxySessionsErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            ListProxySessionsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListPhoneNumbers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPhoneNumbersError {
    /// Kind of error that occurred.
                    pub kind: ListPhoneNumbersErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListPhoneNumbersError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListPhoneNumbersErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListPhoneNumbers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPhoneNumbersErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListPhoneNumbersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPhoneNumbersErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            ListPhoneNumbersErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            ListPhoneNumbersErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListPhoneNumbersErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            ListPhoneNumbersErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            ListPhoneNumbersErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListPhoneNumbersErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListPhoneNumbersErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListPhoneNumbersError {
    fn code(&self) -> Option<&str> {
        ListPhoneNumbersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPhoneNumbersError {
    /// Creates a new `ListPhoneNumbersError`.
                    pub fn new(kind: ListPhoneNumbersErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListPhoneNumbersError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListPhoneNumbersErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListPhoneNumbersError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListPhoneNumbersErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListPhoneNumbersErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListPhoneNumbersErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `ListPhoneNumbersErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListPhoneNumbersErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `ListPhoneNumbersErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListPhoneNumbersErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListPhoneNumbersErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, ListPhoneNumbersErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `ListPhoneNumbersErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, ListPhoneNumbersErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `ListPhoneNumbersErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, ListPhoneNumbersErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `ListPhoneNumbersErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, ListPhoneNumbersErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for ListPhoneNumbersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPhoneNumbersErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            ListPhoneNumbersErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            ListPhoneNumbersErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            ListPhoneNumbersErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            ListPhoneNumbersErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            ListPhoneNumbersErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            ListPhoneNumbersErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            ListPhoneNumbersErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListPhoneNumberOrders` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPhoneNumberOrdersError {
    /// Kind of error that occurred.
                    pub kind: ListPhoneNumberOrdersErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListPhoneNumberOrdersError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListPhoneNumberOrdersErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListPhoneNumberOrders` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPhoneNumberOrdersErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListPhoneNumberOrdersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPhoneNumberOrdersErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            ListPhoneNumberOrdersErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            ListPhoneNumberOrdersErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            ListPhoneNumberOrdersErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            ListPhoneNumberOrdersErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListPhoneNumberOrdersErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListPhoneNumberOrdersErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListPhoneNumberOrdersError {
    fn code(&self) -> Option<&str> {
        ListPhoneNumberOrdersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPhoneNumberOrdersError {
    /// Creates a new `ListPhoneNumberOrdersError`.
                    pub fn new(kind: ListPhoneNumberOrdersErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListPhoneNumberOrdersError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListPhoneNumberOrdersErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListPhoneNumberOrdersError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListPhoneNumberOrdersErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListPhoneNumberOrdersErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListPhoneNumberOrdersErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `ListPhoneNumberOrdersErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListPhoneNumberOrdersErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `ListPhoneNumberOrdersErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, ListPhoneNumberOrdersErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `ListPhoneNumberOrdersErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, ListPhoneNumberOrdersErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `ListPhoneNumberOrdersErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, ListPhoneNumberOrdersErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `ListPhoneNumberOrdersErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, ListPhoneNumberOrdersErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for ListPhoneNumberOrdersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPhoneNumberOrdersErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            ListPhoneNumberOrdersErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            ListPhoneNumberOrdersErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            ListPhoneNumberOrdersErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            ListPhoneNumberOrdersErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            ListPhoneNumberOrdersErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            ListPhoneNumberOrdersErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListAvailableVoiceConnectorRegions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAvailableVoiceConnectorRegionsError {
    /// Kind of error that occurred.
                    pub kind: ListAvailableVoiceConnectorRegionsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListAvailableVoiceConnectorRegionsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListAvailableVoiceConnectorRegionsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListAvailableVoiceConnectorRegions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAvailableVoiceConnectorRegionsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListAvailableVoiceConnectorRegionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAvailableVoiceConnectorRegionsErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            ListAvailableVoiceConnectorRegionsErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            ListAvailableVoiceConnectorRegionsErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            ListAvailableVoiceConnectorRegionsErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            ListAvailableVoiceConnectorRegionsErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListAvailableVoiceConnectorRegionsErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            ListAvailableVoiceConnectorRegionsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAvailableVoiceConnectorRegionsError {
    fn code(&self) -> Option<&str> {
        ListAvailableVoiceConnectorRegionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAvailableVoiceConnectorRegionsError {
    /// Creates a new `ListAvailableVoiceConnectorRegionsError`.
                    pub fn new(kind: ListAvailableVoiceConnectorRegionsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListAvailableVoiceConnectorRegionsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListAvailableVoiceConnectorRegionsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListAvailableVoiceConnectorRegionsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListAvailableVoiceConnectorRegionsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListAvailableVoiceConnectorRegionsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListAvailableVoiceConnectorRegionsErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `ListAvailableVoiceConnectorRegionsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListAvailableVoiceConnectorRegionsErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `ListAvailableVoiceConnectorRegionsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, ListAvailableVoiceConnectorRegionsErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `ListAvailableVoiceConnectorRegionsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, ListAvailableVoiceConnectorRegionsErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `ListAvailableVoiceConnectorRegionsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, ListAvailableVoiceConnectorRegionsErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `ListAvailableVoiceConnectorRegionsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, ListAvailableVoiceConnectorRegionsErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for ListAvailableVoiceConnectorRegionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAvailableVoiceConnectorRegionsErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            ListAvailableVoiceConnectorRegionsErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            ListAvailableVoiceConnectorRegionsErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            ListAvailableVoiceConnectorRegionsErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            ListAvailableVoiceConnectorRegionsErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            ListAvailableVoiceConnectorRegionsErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            ListAvailableVoiceConnectorRegionsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetVoiceConnectorTerminationHealth` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorTerminationHealthError {
    /// Kind of error that occurred.
                    pub kind: GetVoiceConnectorTerminationHealthErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetVoiceConnectorTerminationHealthError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetVoiceConnectorTerminationHealthErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetVoiceConnectorTerminationHealth` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorTerminationHealthErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetVoiceConnectorTerminationHealthError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorTerminationHealthErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorTerminationHealthErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorTerminationHealthErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorTerminationHealthErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorTerminationHealthErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorTerminationHealthErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorTerminationHealthErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorTerminationHealthErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetVoiceConnectorTerminationHealthError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorTerminationHealthError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorTerminationHealthError {
    /// Creates a new `GetVoiceConnectorTerminationHealthError`.
                    pub fn new(kind: GetVoiceConnectorTerminationHealthErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetVoiceConnectorTerminationHealthError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetVoiceConnectorTerminationHealthErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetVoiceConnectorTerminationHealthError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetVoiceConnectorTerminationHealthErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationHealthErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorTerminationHealthErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationHealthErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorTerminationHealthErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationHealthErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorTerminationHealthErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationHealthErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorTerminationHealthErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationHealthErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorTerminationHealthErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationHealthErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorTerminationHealthErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationHealthErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorTerminationHealthErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetVoiceConnectorTerminationHealthError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorTerminationHealthErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorTerminationHealthErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorTerminationHealthErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorTerminationHealthErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorTerminationHealthErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorTerminationHealthErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorTerminationHealthErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorTerminationHealthErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetVoiceConnectorTermination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorTerminationError {
    /// Kind of error that occurred.
                    pub kind: GetVoiceConnectorTerminationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetVoiceConnectorTerminationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetVoiceConnectorTerminationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetVoiceConnectorTermination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorTerminationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetVoiceConnectorTerminationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorTerminationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorTerminationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorTerminationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorTerminationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorTerminationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorTerminationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetVoiceConnectorTerminationError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorTerminationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorTerminationError {
    /// Creates a new `GetVoiceConnectorTerminationError`.
                    pub fn new(kind: GetVoiceConnectorTerminationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetVoiceConnectorTerminationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetVoiceConnectorTerminationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetVoiceConnectorTerminationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetVoiceConnectorTerminationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorTerminationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorTerminationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorTerminationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorTerminationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorTerminationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetVoiceConnectorTerminationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorTerminationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorTerminationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorTerminationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorTerminationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorTerminationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorTerminationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetVoiceConnectorStreamingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorStreamingConfigurationError {
    /// Kind of error that occurred.
                    pub kind: GetVoiceConnectorStreamingConfigurationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetVoiceConnectorStreamingConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetVoiceConnectorStreamingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetVoiceConnectorStreamingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorStreamingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetVoiceConnectorStreamingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorStreamingConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetVoiceConnectorStreamingConfigurationError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorStreamingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorStreamingConfigurationError {
    /// Creates a new `GetVoiceConnectorStreamingConfigurationError`.
                    pub fn new(kind: GetVoiceConnectorStreamingConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetVoiceConnectorStreamingConfigurationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetVoiceConnectorStreamingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetVoiceConnectorStreamingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetVoiceConnectorStreamingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetVoiceConnectorStreamingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorStreamingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetVoiceConnectorStreamingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorStreamingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetVoiceConnectorProxy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorProxyError {
    /// Kind of error that occurred.
                    pub kind: GetVoiceConnectorProxyErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetVoiceConnectorProxyError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetVoiceConnectorProxyErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetVoiceConnectorProxy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorProxyErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetVoiceConnectorProxyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorProxyErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorProxyErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorProxyErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorProxyErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorProxyErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorProxyErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorProxyErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorProxyErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetVoiceConnectorProxyError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorProxyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorProxyError {
    /// Creates a new `GetVoiceConnectorProxyError`.
                    pub fn new(kind: GetVoiceConnectorProxyErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetVoiceConnectorProxyError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetVoiceConnectorProxyErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetVoiceConnectorProxyError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetVoiceConnectorProxyErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetVoiceConnectorProxyErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorProxyErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorProxyErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorProxyErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorProxyErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorProxyErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorProxyErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorProxyErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorProxyErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorProxyErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorProxyErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorProxyErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorProxyErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorProxyErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetVoiceConnectorProxyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorProxyErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorProxyErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorProxyErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorProxyErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorProxyErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorProxyErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorProxyErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorProxyErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetVoiceConnectorOrigination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorOriginationError {
    /// Kind of error that occurred.
                    pub kind: GetVoiceConnectorOriginationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetVoiceConnectorOriginationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetVoiceConnectorOriginationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetVoiceConnectorOrigination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorOriginationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetVoiceConnectorOriginationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorOriginationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorOriginationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorOriginationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorOriginationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorOriginationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorOriginationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetVoiceConnectorOriginationError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorOriginationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorOriginationError {
    /// Creates a new `GetVoiceConnectorOriginationError`.
                    pub fn new(kind: GetVoiceConnectorOriginationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetVoiceConnectorOriginationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetVoiceConnectorOriginationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetVoiceConnectorOriginationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetVoiceConnectorOriginationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetVoiceConnectorOriginationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorOriginationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorOriginationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorOriginationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorOriginationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorOriginationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorOriginationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorOriginationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorOriginationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorOriginationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorOriginationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorOriginationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetVoiceConnectorOriginationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorOriginationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorOriginationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorOriginationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorOriginationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorOriginationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorOriginationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetVoiceConnectorLoggingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorLoggingConfigurationError {
    /// Kind of error that occurred.
                    pub kind: GetVoiceConnectorLoggingConfigurationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetVoiceConnectorLoggingConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetVoiceConnectorLoggingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetVoiceConnectorLoggingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorLoggingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetVoiceConnectorLoggingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorLoggingConfigurationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorLoggingConfigurationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorLoggingConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetVoiceConnectorLoggingConfigurationError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorLoggingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorLoggingConfigurationError {
    /// Creates a new `GetVoiceConnectorLoggingConfigurationError`.
                    pub fn new(kind: GetVoiceConnectorLoggingConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetVoiceConnectorLoggingConfigurationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetVoiceConnectorLoggingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetVoiceConnectorLoggingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetVoiceConnectorLoggingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetVoiceConnectorLoggingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorLoggingConfigurationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorLoggingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorLoggingConfigurationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetVoiceConnectorLoggingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorLoggingConfigurationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorLoggingConfigurationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorLoggingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorGroupError {
    /// Kind of error that occurred.
                    pub kind: GetVoiceConnectorGroupErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetVoiceConnectorGroupError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorGroupErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetVoiceConnectorGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorGroupErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorGroupErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorGroupErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetVoiceConnectorGroupError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorGroupError {
    /// Creates a new `GetVoiceConnectorGroupError`.
                    pub fn new(kind: GetVoiceConnectorGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetVoiceConnectorGroupError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetVoiceConnectorGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetVoiceConnectorGroupErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorGroupErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorGroupErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorGroupErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorGroupErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorGroupErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorGroupErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorGroupErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorGroupErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorGroupErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorGroupErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorGroupErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorGroupErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorGroupErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetVoiceConnectorGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorGroupErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorGroupErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorGroupErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetVoiceConnectorEmergencyCallingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorEmergencyCallingConfigurationError {
    /// Kind of error that occurred.
                    pub kind: GetVoiceConnectorEmergencyCallingConfigurationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetVoiceConnectorEmergencyCallingConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetVoiceConnectorEmergencyCallingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorEmergencyCallingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetVoiceConnectorEmergencyCallingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetVoiceConnectorEmergencyCallingConfigurationError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorEmergencyCallingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorEmergencyCallingConfigurationError {
    /// Creates a new `GetVoiceConnectorEmergencyCallingConfigurationError`.
                    pub fn new(kind: GetVoiceConnectorEmergencyCallingConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetVoiceConnectorEmergencyCallingConfigurationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetVoiceConnectorEmergencyCallingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetVoiceConnectorEmergencyCallingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorError {
    /// Kind of error that occurred.
                    pub kind: GetVoiceConnectorErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetVoiceConnectorError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetVoiceConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetVoiceConnectorError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorError {
    /// Creates a new `GetVoiceConnectorError`.
                    pub fn new(kind: GetVoiceConnectorErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetVoiceConnectorError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetVoiceConnectorError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetVoiceConnectorErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetVoiceConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetSipRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSipRuleError {
    /// Kind of error that occurred.
                    pub kind: GetSipRuleErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetSipRuleError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetSipRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSipRuleErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetSipRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSipRuleErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipRuleErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipRuleErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipRuleErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipRuleErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipRuleErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipRuleErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipRuleErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetSipRuleError {
    fn code(&self) -> Option<&str> {
        GetSipRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSipRuleError {
    /// Creates a new `GetSipRuleError`.
                    pub fn new(kind: GetSipRuleErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetSipRuleError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetSipRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetSipRuleErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetSipRuleErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetSipRuleErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetSipRuleErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetSipRuleErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSipRuleErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetSipRuleErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetSipRuleErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `GetSipRuleErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetSipRuleErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetSipRuleErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetSipRuleErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `GetSipRuleErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetSipRuleErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetSipRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSipRuleErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetSipRuleErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetSipRuleErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            GetSipRuleErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetSipRuleErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetSipRuleErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetSipRuleErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetSipRuleErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetSipMediaApplicationLoggingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSipMediaApplicationLoggingConfigurationError {
    /// Kind of error that occurred.
                    pub kind: GetSipMediaApplicationLoggingConfigurationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetSipMediaApplicationLoggingConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetSipMediaApplicationLoggingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSipMediaApplicationLoggingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetSipMediaApplicationLoggingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetSipMediaApplicationLoggingConfigurationError {
    fn code(&self) -> Option<&str> {
        GetSipMediaApplicationLoggingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSipMediaApplicationLoggingConfigurationError {
    /// Creates a new `GetSipMediaApplicationLoggingConfigurationError`.
                    pub fn new(kind: GetSipMediaApplicationLoggingConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetSipMediaApplicationLoggingConfigurationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetSipMediaApplicationLoggingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetSipMediaApplicationLoggingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetSipMediaApplicationAlexaSkillConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSipMediaApplicationAlexaSkillConfigurationError {
    /// Kind of error that occurred.
                    pub kind: GetSipMediaApplicationAlexaSkillConfigurationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetSipMediaApplicationAlexaSkillConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetSipMediaApplicationAlexaSkillConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSipMediaApplicationAlexaSkillConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetSipMediaApplicationAlexaSkillConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetSipMediaApplicationAlexaSkillConfigurationError {
    fn code(&self) -> Option<&str> {
        GetSipMediaApplicationAlexaSkillConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSipMediaApplicationAlexaSkillConfigurationError {
    /// Creates a new `GetSipMediaApplicationAlexaSkillConfigurationError`.
                    pub fn new(kind: GetSipMediaApplicationAlexaSkillConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetSipMediaApplicationAlexaSkillConfigurationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetSipMediaApplicationAlexaSkillConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationAlexaSkillConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationAlexaSkillConfigurationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationAlexaSkillConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationAlexaSkillConfigurationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationAlexaSkillConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationAlexaSkillConfigurationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetSipMediaApplicationAlexaSkillConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetSipMediaApplication` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSipMediaApplicationError {
    /// Kind of error that occurred.
                    pub kind: GetSipMediaApplicationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetSipMediaApplicationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetSipMediaApplication` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSipMediaApplicationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetSipMediaApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSipMediaApplicationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetSipMediaApplicationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetSipMediaApplicationError {
    fn code(&self) -> Option<&str> {
        GetSipMediaApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSipMediaApplicationError {
    /// Creates a new `GetSipMediaApplicationError`.
                    pub fn new(kind: GetSipMediaApplicationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetSipMediaApplicationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetSipMediaApplicationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetSipMediaApplicationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetSipMediaApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSipMediaApplicationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetSipMediaApplicationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetProxySession` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetProxySessionError {
    /// Kind of error that occurred.
                    pub kind: GetProxySessionErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetProxySessionError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetProxySession` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetProxySessionErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetProxySessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetProxySessionErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetProxySessionErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetProxySessionErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetProxySessionErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetProxySessionErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetProxySessionErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetProxySessionErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetProxySessionErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetProxySessionError {
    fn code(&self) -> Option<&str> {
        GetProxySessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetProxySessionError {
    /// Creates a new `GetProxySessionError`.
                    pub fn new(kind: GetProxySessionErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetProxySessionError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetProxySessionError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetProxySessionErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetProxySessionErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetProxySessionErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetProxySessionErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetProxySessionErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetProxySessionErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetProxySessionErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetProxySessionErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `GetProxySessionErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetProxySessionErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetProxySessionErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetProxySessionErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `GetProxySessionErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetProxySessionErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetProxySessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetProxySessionErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetProxySessionErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetProxySessionErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            GetProxySessionErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetProxySessionErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetProxySessionErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetProxySessionErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetProxySessionErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetPhoneNumberSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPhoneNumberSettingsError {
    /// Kind of error that occurred.
                    pub kind: GetPhoneNumberSettingsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetPhoneNumberSettingsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetPhoneNumberSettingsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetPhoneNumberSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPhoneNumberSettingsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetPhoneNumberSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPhoneNumberSettingsErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberSettingsErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberSettingsErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberSettingsErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberSettingsErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberSettingsErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberSettingsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPhoneNumberSettingsError {
    fn code(&self) -> Option<&str> {
        GetPhoneNumberSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPhoneNumberSettingsError {
    /// Creates a new `GetPhoneNumberSettingsError`.
                    pub fn new(kind: GetPhoneNumberSettingsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetPhoneNumberSettingsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetPhoneNumberSettingsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetPhoneNumberSettingsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetPhoneNumberSettingsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetPhoneNumberSettingsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberSettingsErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberSettingsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberSettingsErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberSettingsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberSettingsErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberSettingsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberSettingsErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberSettingsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberSettingsErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberSettingsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberSettingsErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetPhoneNumberSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPhoneNumberSettingsErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberSettingsErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberSettingsErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberSettingsErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberSettingsErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberSettingsErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberSettingsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetPhoneNumberOrder` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPhoneNumberOrderError {
    /// Kind of error that occurred.
                    pub kind: GetPhoneNumberOrderErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetPhoneNumberOrderError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetPhoneNumberOrderErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetPhoneNumberOrder` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPhoneNumberOrderErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetPhoneNumberOrderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPhoneNumberOrderErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberOrderErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberOrderErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberOrderErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberOrderErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberOrderErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberOrderErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberOrderErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPhoneNumberOrderError {
    fn code(&self) -> Option<&str> {
        GetPhoneNumberOrderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPhoneNumberOrderError {
    /// Creates a new `GetPhoneNumberOrderError`.
                    pub fn new(kind: GetPhoneNumberOrderErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetPhoneNumberOrderError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetPhoneNumberOrderErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetPhoneNumberOrderError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetPhoneNumberOrderErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetPhoneNumberOrderErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberOrderErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberOrderErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberOrderErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberOrderErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberOrderErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberOrderErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberOrderErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberOrderErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberOrderErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberOrderErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberOrderErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberOrderErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberOrderErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetPhoneNumberOrderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPhoneNumberOrderErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberOrderErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberOrderErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberOrderErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberOrderErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberOrderErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberOrderErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberOrderErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetPhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPhoneNumberError {
    /// Kind of error that occurred.
                    pub kind: GetPhoneNumberErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetPhoneNumberError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetPhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetPhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPhoneNumberErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetPhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPhoneNumberErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetPhoneNumberErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPhoneNumberError {
    fn code(&self) -> Option<&str> {
        GetPhoneNumberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPhoneNumberError {
    /// Creates a new `GetPhoneNumberError`.
                    pub fn new(kind: GetPhoneNumberErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetPhoneNumberError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetPhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetPhoneNumberError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetPhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetPhoneNumberErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetPhoneNumberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPhoneNumberErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetPhoneNumberErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetGlobalSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGlobalSettingsError {
    /// Kind of error that occurred.
                    pub kind: GetGlobalSettingsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetGlobalSettingsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetGlobalSettingsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetGlobalSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGlobalSettingsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetGlobalSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetGlobalSettingsErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetGlobalSettingsErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetGlobalSettingsErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetGlobalSettingsErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetGlobalSettingsErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetGlobalSettingsErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetGlobalSettingsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetGlobalSettingsError {
    fn code(&self) -> Option<&str> {
        GetGlobalSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetGlobalSettingsError {
    /// Creates a new `GetGlobalSettingsError`.
                    pub fn new(kind: GetGlobalSettingsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetGlobalSettingsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetGlobalSettingsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetGlobalSettingsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetGlobalSettingsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetGlobalSettingsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetGlobalSettingsErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetGlobalSettingsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetGlobalSettingsErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetGlobalSettingsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetGlobalSettingsErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `GetGlobalSettingsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetGlobalSettingsErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetGlobalSettingsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetGlobalSettingsErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `GetGlobalSettingsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetGlobalSettingsErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetGlobalSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetGlobalSettingsErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetGlobalSettingsErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetGlobalSettingsErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetGlobalSettingsErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetGlobalSettingsErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetGlobalSettingsErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetGlobalSettingsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DisassociatePhoneNumbersFromVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociatePhoneNumbersFromVoiceConnectorGroupError {
    /// Kind of error that occurred.
                    pub kind: DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DisassociatePhoneNumbersFromVoiceConnectorGroupError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DisassociatePhoneNumbersFromVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DisassociatePhoneNumbersFromVoiceConnectorGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DisassociatePhoneNumbersFromVoiceConnectorGroupError {
    fn code(&self) -> Option<&str> {
        DisassociatePhoneNumbersFromVoiceConnectorGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociatePhoneNumbersFromVoiceConnectorGroupError {
    /// Creates a new `DisassociatePhoneNumbersFromVoiceConnectorGroupError`.
                    pub fn new(kind: DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DisassociatePhoneNumbersFromVoiceConnectorGroupError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DisassociatePhoneNumbersFromVoiceConnectorGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for DisassociatePhoneNumbersFromVoiceConnectorGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DisassociatePhoneNumbersFromVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociatePhoneNumbersFromVoiceConnectorError {
    /// Kind of error that occurred.
                    pub kind: DisassociatePhoneNumbersFromVoiceConnectorErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DisassociatePhoneNumbersFromVoiceConnectorError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DisassociatePhoneNumbersFromVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DisassociatePhoneNumbersFromVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociatePhoneNumbersFromVoiceConnectorErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DisassociatePhoneNumbersFromVoiceConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DisassociatePhoneNumbersFromVoiceConnectorError {
    fn code(&self) -> Option<&str> {
        DisassociatePhoneNumbersFromVoiceConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociatePhoneNumbersFromVoiceConnectorError {
    /// Creates a new `DisassociatePhoneNumbersFromVoiceConnectorError`.
                    pub fn new(kind: DisassociatePhoneNumbersFromVoiceConnectorErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DisassociatePhoneNumbersFromVoiceConnectorError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DisassociatePhoneNumbersFromVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DisassociatePhoneNumbersFromVoiceConnectorError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DisassociatePhoneNumbersFromVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DisassociatePhoneNumbersFromVoiceConnectorErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DisassociatePhoneNumbersFromVoiceConnectorErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, DisassociatePhoneNumbersFromVoiceConnectorErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for DisassociatePhoneNumbersFromVoiceConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteVoiceConnectorTerminationCredentials` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorTerminationCredentialsError {
    /// Kind of error that occurred.
                    pub kind: DeleteVoiceConnectorTerminationCredentialsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteVoiceConnectorTerminationCredentialsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteVoiceConnectorTerminationCredentialsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteVoiceConnectorTerminationCredentials` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorTerminationCredentialsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteVoiceConnectorTerminationCredentialsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorTerminationCredentialsError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorTerminationCredentialsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorTerminationCredentialsError {
    /// Creates a new `DeleteVoiceConnectorTerminationCredentialsError`.
                    pub fn new(kind: DeleteVoiceConnectorTerminationCredentialsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteVoiceConnectorTerminationCredentialsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteVoiceConnectorTerminationCredentialsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteVoiceConnectorTerminationCredentialsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteVoiceConnectorTerminationCredentialsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationCredentialsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationCredentialsErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for DeleteVoiceConnectorTerminationCredentialsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteVoiceConnectorTermination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorTerminationError {
    /// Kind of error that occurred.
                    pub kind: DeleteVoiceConnectorTerminationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteVoiceConnectorTerminationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteVoiceConnectorTerminationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteVoiceConnectorTermination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorTerminationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteVoiceConnectorTerminationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorTerminationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorTerminationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorTerminationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorTerminationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorTerminationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorTerminationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorTerminationError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorTerminationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorTerminationError {
    /// Creates a new `DeleteVoiceConnectorTerminationError`.
                    pub fn new(kind: DeleteVoiceConnectorTerminationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteVoiceConnectorTerminationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteVoiceConnectorTerminationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteVoiceConnectorTerminationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteVoiceConnectorTerminationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorTerminationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorTerminationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorTerminationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorTerminationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorTerminationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for DeleteVoiceConnectorTerminationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorTerminationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorTerminationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorTerminationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorTerminationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorTerminationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorTerminationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteVoiceConnectorStreamingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorStreamingConfigurationError {
    /// Kind of error that occurred.
                    pub kind: DeleteVoiceConnectorStreamingConfigurationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteVoiceConnectorStreamingConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteVoiceConnectorStreamingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteVoiceConnectorStreamingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorStreamingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteVoiceConnectorStreamingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorStreamingConfigurationError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorStreamingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorStreamingConfigurationError {
    /// Creates a new `DeleteVoiceConnectorStreamingConfigurationError`.
                    pub fn new(kind: DeleteVoiceConnectorStreamingConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteVoiceConnectorStreamingConfigurationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteVoiceConnectorStreamingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteVoiceConnectorStreamingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteVoiceConnectorStreamingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorStreamingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorStreamingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for DeleteVoiceConnectorStreamingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteVoiceConnectorProxy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorProxyError {
    /// Kind of error that occurred.
                    pub kind: DeleteVoiceConnectorProxyErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteVoiceConnectorProxyError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteVoiceConnectorProxyErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteVoiceConnectorProxy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorProxyErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteVoiceConnectorProxyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorProxyErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorProxyErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorProxyErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorProxyErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorProxyErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorProxyErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorProxyErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorProxyErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorProxyError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorProxyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorProxyError {
    /// Creates a new `DeleteVoiceConnectorProxyError`.
                    pub fn new(kind: DeleteVoiceConnectorProxyErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteVoiceConnectorProxyError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteVoiceConnectorProxyErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteVoiceConnectorProxyError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteVoiceConnectorProxyErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorProxyErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorProxyErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorProxyErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorProxyErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorProxyErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorProxyErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorProxyErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorProxyErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorProxyErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorProxyErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorProxyErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorProxyErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorProxyErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorProxyErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for DeleteVoiceConnectorProxyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorProxyErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorProxyErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorProxyErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorProxyErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorProxyErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorProxyErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorProxyErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorProxyErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteVoiceConnectorOrigination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorOriginationError {
    /// Kind of error that occurred.
                    pub kind: DeleteVoiceConnectorOriginationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteVoiceConnectorOriginationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteVoiceConnectorOriginationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteVoiceConnectorOrigination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorOriginationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteVoiceConnectorOriginationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorOriginationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorOriginationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorOriginationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorOriginationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorOriginationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorOriginationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorOriginationError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorOriginationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorOriginationError {
    /// Creates a new `DeleteVoiceConnectorOriginationError`.
                    pub fn new(kind: DeleteVoiceConnectorOriginationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteVoiceConnectorOriginationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteVoiceConnectorOriginationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteVoiceConnectorOriginationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteVoiceConnectorOriginationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorOriginationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorOriginationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorOriginationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorOriginationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorOriginationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorOriginationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorOriginationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorOriginationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorOriginationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorOriginationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorOriginationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorOriginationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for DeleteVoiceConnectorOriginationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorOriginationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorOriginationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorOriginationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorOriginationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorOriginationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorOriginationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorGroupError {
    /// Kind of error that occurred.
                    pub kind: DeleteVoiceConnectorGroupErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteVoiceConnectorGroupError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorGroupErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteVoiceConnectorGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorGroupErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorGroupErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorGroupErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorGroupErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorGroupError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorGroupError {
    /// Creates a new `DeleteVoiceConnectorGroupError`.
                    pub fn new(kind: DeleteVoiceConnectorGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteVoiceConnectorGroupError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteVoiceConnectorGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorGroupErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorGroupErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorGroupErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorGroupErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorGroupErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorGroupErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorGroupErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorGroupErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorGroupErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorGroupErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorGroupErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorGroupErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorGroupErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorGroupErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorGroupErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorGroupErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for DeleteVoiceConnectorGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorGroupErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorGroupErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorGroupErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorGroupErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteVoiceConnectorEmergencyCallingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorEmergencyCallingConfigurationError {
    /// Kind of error that occurred.
                    pub kind: DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteVoiceConnectorEmergencyCallingConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteVoiceConnectorEmergencyCallingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteVoiceConnectorEmergencyCallingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorEmergencyCallingConfigurationError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorEmergencyCallingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorEmergencyCallingConfigurationError {
    /// Creates a new `DeleteVoiceConnectorEmergencyCallingConfigurationError`.
                    pub fn new(kind: DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteVoiceConnectorEmergencyCallingConfigurationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteVoiceConnectorEmergencyCallingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for DeleteVoiceConnectorEmergencyCallingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorError {
    /// Kind of error that occurred.
                    pub kind: DeleteVoiceConnectorErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteVoiceConnectorError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteVoiceConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorError {
    /// Creates a new `DeleteVoiceConnectorError`.
                    pub fn new(kind: DeleteVoiceConnectorErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteVoiceConnectorError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteVoiceConnectorError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteVoiceConnectorErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for DeleteVoiceConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteSipRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSipRuleError {
    /// Kind of error that occurred.
                    pub kind: DeleteSipRuleErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteSipRuleError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteSipRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSipRuleErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteSipRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSipRuleErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteSipRuleErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteSipRuleErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteSipRuleErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteSipRuleErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteSipRuleErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteSipRuleErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteSipRuleErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteSipRuleErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteSipRuleError {
    fn code(&self) -> Option<&str> {
        DeleteSipRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSipRuleError {
    /// Creates a new `DeleteSipRuleError`.
                    pub fn new(kind: DeleteSipRuleErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteSipRuleError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteSipRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteSipRuleErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipRuleErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `DeleteSipRuleErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipRuleErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DeleteSipRuleErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipRuleErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `DeleteSipRuleErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipRuleErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteSipRuleErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipRuleErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `DeleteSipRuleErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipRuleErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteSipRuleErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipRuleErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `DeleteSipRuleErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipRuleErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for DeleteSipRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSipRuleErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            DeleteSipRuleErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            DeleteSipRuleErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            DeleteSipRuleErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteSipRuleErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            DeleteSipRuleErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            DeleteSipRuleErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            DeleteSipRuleErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            DeleteSipRuleErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteSipMediaApplication` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSipMediaApplicationError {
    /// Kind of error that occurred.
                    pub kind: DeleteSipMediaApplicationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteSipMediaApplicationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteSipMediaApplication` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSipMediaApplicationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteSipMediaApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSipMediaApplicationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteSipMediaApplicationErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteSipMediaApplicationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteSipMediaApplicationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteSipMediaApplicationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteSipMediaApplicationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteSipMediaApplicationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteSipMediaApplicationError {
    fn code(&self) -> Option<&str> {
        DeleteSipMediaApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSipMediaApplicationError {
    /// Creates a new `DeleteSipMediaApplicationError`.
                    pub fn new(kind: DeleteSipMediaApplicationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteSipMediaApplicationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteSipMediaApplicationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteSipMediaApplicationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipMediaApplicationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `DeleteSipMediaApplicationErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipMediaApplicationErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DeleteSipMediaApplicationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipMediaApplicationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `DeleteSipMediaApplicationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipMediaApplicationErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteSipMediaApplicationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipMediaApplicationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `DeleteSipMediaApplicationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipMediaApplicationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteSipMediaApplicationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipMediaApplicationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `DeleteSipMediaApplicationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipMediaApplicationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for DeleteSipMediaApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSipMediaApplicationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            DeleteSipMediaApplicationErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            DeleteSipMediaApplicationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            DeleteSipMediaApplicationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteSipMediaApplicationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            DeleteSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            DeleteSipMediaApplicationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            DeleteSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            DeleteSipMediaApplicationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteProxySession` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteProxySessionError {
    /// Kind of error that occurred.
                    pub kind: DeleteProxySessionErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteProxySessionError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeleteProxySession` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteProxySessionErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteProxySessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteProxySessionErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteProxySessionErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteProxySessionErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteProxySessionErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteProxySessionErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteProxySessionErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteProxySessionErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteProxySessionErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteProxySessionError {
    fn code(&self) -> Option<&str> {
        DeleteProxySessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteProxySessionError {
    /// Creates a new `DeleteProxySessionError`.
                    pub fn new(kind: DeleteProxySessionErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeleteProxySessionError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeleteProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeleteProxySessionError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeleteProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeleteProxySessionErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteProxySessionErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `DeleteProxySessionErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteProxySessionErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `DeleteProxySessionErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteProxySessionErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteProxySessionErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, DeleteProxySessionErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `DeleteProxySessionErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, DeleteProxySessionErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteProxySessionErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteProxySessionErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `DeleteProxySessionErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteProxySessionErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for DeleteProxySessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteProxySessionErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            DeleteProxySessionErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            DeleteProxySessionErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteProxySessionErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            DeleteProxySessionErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            DeleteProxySessionErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            DeleteProxySessionErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            DeleteProxySessionErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeletePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePhoneNumberError {
    /// Kind of error that occurred.
                    pub kind: DeletePhoneNumberErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for DeletePhoneNumberError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeletePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `DeletePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePhoneNumberErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeletePhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePhoneNumberErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePhoneNumberErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePhoneNumberErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePhoneNumberErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePhoneNumberErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePhoneNumberErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePhoneNumberErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePhoneNumberErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeletePhoneNumberError {
    fn code(&self) -> Option<&str> {
        DeletePhoneNumberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePhoneNumberError {
    /// Creates a new `DeletePhoneNumberError`.
                    pub fn new(kind: DeletePhoneNumberErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `DeletePhoneNumberError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: DeletePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `DeletePhoneNumberError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: DeletePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `DeletePhoneNumberErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeletePhoneNumberErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `DeletePhoneNumberErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeletePhoneNumberErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `DeletePhoneNumberErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeletePhoneNumberErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeletePhoneNumberErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, DeletePhoneNumberErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `DeletePhoneNumberErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, DeletePhoneNumberErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeletePhoneNumberErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, DeletePhoneNumberErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `DeletePhoneNumberErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, DeletePhoneNumberErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for DeletePhoneNumberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePhoneNumberErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            DeletePhoneNumberErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            DeletePhoneNumberErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            DeletePhoneNumberErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            DeletePhoneNumberErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            DeletePhoneNumberErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            DeletePhoneNumberErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            DeletePhoneNumberErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreateVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVoiceConnectorGroupError {
    /// Kind of error that occurred.
                    pub kind: CreateVoiceConnectorGroupErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreateVoiceConnectorGroupError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreateVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVoiceConnectorGroupErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateVoiceConnectorGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVoiceConnectorGroupErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateVoiceConnectorGroupErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            CreateVoiceConnectorGroupErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            CreateVoiceConnectorGroupErrorKind::ResourceLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            CreateVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            CreateVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            CreateVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            CreateVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateVoiceConnectorGroupError {
    fn code(&self) -> Option<&str> {
        CreateVoiceConnectorGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateVoiceConnectorGroupError {
    /// Creates a new `CreateVoiceConnectorGroupError`.
                    pub fn new(kind: CreateVoiceConnectorGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreateVoiceConnectorGroupError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreateVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreateVoiceConnectorGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreateVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorGroupErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateVoiceConnectorGroupErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorGroupErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateVoiceConnectorGroupErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorGroupErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateVoiceConnectorGroupErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorGroupErrorKind::ResourceLimitExceededException`.
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateVoiceConnectorGroupErrorKind::ResourceLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorGroupErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, CreateVoiceConnectorGroupErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorGroupErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, CreateVoiceConnectorGroupErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorGroupErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, CreateVoiceConnectorGroupErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorGroupErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, CreateVoiceConnectorGroupErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for CreateVoiceConnectorGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVoiceConnectorGroupErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateVoiceConnectorGroupErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            CreateVoiceConnectorGroupErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            CreateVoiceConnectorGroupErrorKind::ResourceLimitExceededException(_inner) =>
            Some(_inner)
            ,
            CreateVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            CreateVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            CreateVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            CreateVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            CreateVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreateVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVoiceConnectorError {
    /// Kind of error that occurred.
                    pub kind: CreateVoiceConnectorErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreateVoiceConnectorError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreateVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVoiceConnectorErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateVoiceConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVoiceConnectorErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateVoiceConnectorErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            CreateVoiceConnectorErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            CreateVoiceConnectorErrorKind::ResourceLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateVoiceConnectorErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            CreateVoiceConnectorErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            CreateVoiceConnectorErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            CreateVoiceConnectorErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            CreateVoiceConnectorErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateVoiceConnectorError {
    fn code(&self) -> Option<&str> {
        CreateVoiceConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateVoiceConnectorError {
    /// Creates a new `CreateVoiceConnectorError`.
                    pub fn new(kind: CreateVoiceConnectorErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreateVoiceConnectorError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreateVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreateVoiceConnectorError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreateVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateVoiceConnectorErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateVoiceConnectorErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateVoiceConnectorErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorErrorKind::ResourceLimitExceededException`.
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateVoiceConnectorErrorKind::ResourceLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, CreateVoiceConnectorErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, CreateVoiceConnectorErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, CreateVoiceConnectorErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, CreateVoiceConnectorErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for CreateVoiceConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVoiceConnectorErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateVoiceConnectorErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            CreateVoiceConnectorErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            CreateVoiceConnectorErrorKind::ResourceLimitExceededException(_inner) =>
            Some(_inner)
            ,
            CreateVoiceConnectorErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            CreateVoiceConnectorErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            CreateVoiceConnectorErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            CreateVoiceConnectorErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            CreateVoiceConnectorErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreateSipRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSipRuleError {
    /// Kind of error that occurred.
                    pub kind: CreateSipRuleErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreateSipRuleError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreateSipRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSipRuleErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateSipRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSipRuleErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipRuleErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipRuleErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipRuleErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipRuleErrorKind::ResourceLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipRuleErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipRuleErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipRuleErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipRuleErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipRuleErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateSipRuleError {
    fn code(&self) -> Option<&str> {
        CreateSipRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSipRuleError {
    /// Creates a new `CreateSipRuleError`.
                    pub fn new(kind: CreateSipRuleErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreateSipRuleError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreateSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreateSipRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreateSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreateSipRuleErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateSipRuleErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateSipRuleErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateSipRuleErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateSipRuleErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateSipRuleErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateSipRuleErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateSipRuleErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `CreateSipRuleErrorKind::ResourceLimitExceededException`.
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateSipRuleErrorKind::ResourceLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateSipRuleErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, CreateSipRuleErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `CreateSipRuleErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, CreateSipRuleErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateSipRuleErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, CreateSipRuleErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `CreateSipRuleErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, CreateSipRuleErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for CreateSipRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSipRuleErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateSipRuleErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            CreateSipRuleErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            CreateSipRuleErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            CreateSipRuleErrorKind::ResourceLimitExceededException(_inner) =>
            Some(_inner)
            ,
            CreateSipRuleErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            CreateSipRuleErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            CreateSipRuleErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            CreateSipRuleErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            CreateSipRuleErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreateSipMediaApplicationCall` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSipMediaApplicationCallError {
    /// Kind of error that occurred.
                    pub kind: CreateSipMediaApplicationCallErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreateSipMediaApplicationCallError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateSipMediaApplicationCallErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreateSipMediaApplicationCall` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSipMediaApplicationCallErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateSipMediaApplicationCallError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSipMediaApplicationCallErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipMediaApplicationCallErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipMediaApplicationCallErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipMediaApplicationCallErrorKind::ResourceLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipMediaApplicationCallErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipMediaApplicationCallErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipMediaApplicationCallErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipMediaApplicationCallErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipMediaApplicationCallErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateSipMediaApplicationCallError {
    fn code(&self) -> Option<&str> {
        CreateSipMediaApplicationCallError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSipMediaApplicationCallError {
    /// Creates a new `CreateSipMediaApplicationCallError`.
                    pub fn new(kind: CreateSipMediaApplicationCallErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreateSipMediaApplicationCallError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreateSipMediaApplicationCallErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreateSipMediaApplicationCallError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreateSipMediaApplicationCallErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationCallErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateSipMediaApplicationCallErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationCallErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateSipMediaApplicationCallErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationCallErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateSipMediaApplicationCallErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationCallErrorKind::ResourceLimitExceededException`.
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateSipMediaApplicationCallErrorKind::ResourceLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationCallErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, CreateSipMediaApplicationCallErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationCallErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, CreateSipMediaApplicationCallErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationCallErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, CreateSipMediaApplicationCallErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationCallErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, CreateSipMediaApplicationCallErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for CreateSipMediaApplicationCallError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSipMediaApplicationCallErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateSipMediaApplicationCallErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            CreateSipMediaApplicationCallErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            CreateSipMediaApplicationCallErrorKind::ResourceLimitExceededException(_inner) =>
            Some(_inner)
            ,
            CreateSipMediaApplicationCallErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            CreateSipMediaApplicationCallErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            CreateSipMediaApplicationCallErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            CreateSipMediaApplicationCallErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            CreateSipMediaApplicationCallErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreateSipMediaApplication` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSipMediaApplicationError {
    /// Kind of error that occurred.
                    pub kind: CreateSipMediaApplicationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreateSipMediaApplicationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreateSipMediaApplication` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSipMediaApplicationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateSipMediaApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSipMediaApplicationErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipMediaApplicationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipMediaApplicationErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipMediaApplicationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipMediaApplicationErrorKind::ResourceLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipMediaApplicationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipMediaApplicationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            CreateSipMediaApplicationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateSipMediaApplicationError {
    fn code(&self) -> Option<&str> {
        CreateSipMediaApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSipMediaApplicationError {
    /// Creates a new `CreateSipMediaApplicationError`.
                    pub fn new(kind: CreateSipMediaApplicationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreateSipMediaApplicationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreateSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreateSipMediaApplicationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreateSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateSipMediaApplicationErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateSipMediaApplicationErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateSipMediaApplicationErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateSipMediaApplicationErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationErrorKind::ResourceLimitExceededException`.
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateSipMediaApplicationErrorKind::ResourceLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, CreateSipMediaApplicationErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, CreateSipMediaApplicationErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, CreateSipMediaApplicationErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, CreateSipMediaApplicationErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for CreateSipMediaApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSipMediaApplicationErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateSipMediaApplicationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            CreateSipMediaApplicationErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            CreateSipMediaApplicationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            CreateSipMediaApplicationErrorKind::ResourceLimitExceededException(_inner) =>
            Some(_inner)
            ,
            CreateSipMediaApplicationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            CreateSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            CreateSipMediaApplicationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            CreateSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            CreateSipMediaApplicationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreateProxySession` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateProxySessionError {
    /// Kind of error that occurred.
                    pub kind: CreateProxySessionErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreateProxySessionError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreateProxySession` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateProxySessionErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateProxySessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateProxySessionErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            CreateProxySessionErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            CreateProxySessionErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            CreateProxySessionErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            CreateProxySessionErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            CreateProxySessionErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            CreateProxySessionErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            CreateProxySessionErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateProxySessionError {
    fn code(&self) -> Option<&str> {
        CreateProxySessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateProxySessionError {
    /// Creates a new `CreateProxySessionError`.
                    pub fn new(kind: CreateProxySessionErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreateProxySessionError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreateProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreateProxySessionError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreateProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreateProxySessionErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateProxySessionErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateProxySessionErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateProxySessionErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `CreateProxySessionErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateProxySessionErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateProxySessionErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, CreateProxySessionErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `CreateProxySessionErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, CreateProxySessionErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateProxySessionErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, CreateProxySessionErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `CreateProxySessionErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, CreateProxySessionErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for CreateProxySessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateProxySessionErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            CreateProxySessionErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            CreateProxySessionErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            CreateProxySessionErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            CreateProxySessionErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            CreateProxySessionErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            CreateProxySessionErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            CreateProxySessionErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreatePhoneNumberOrder` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePhoneNumberOrderError {
    /// Kind of error that occurred.
                    pub kind: CreatePhoneNumberOrderErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreatePhoneNumberOrderError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreatePhoneNumberOrderErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreatePhoneNumberOrder` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePhoneNumberOrderErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreatePhoneNumberOrderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePhoneNumberOrderErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreatePhoneNumberOrderErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            CreatePhoneNumberOrderErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            CreatePhoneNumberOrderErrorKind::ResourceLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreatePhoneNumberOrderErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            CreatePhoneNumberOrderErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            CreatePhoneNumberOrderErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            CreatePhoneNumberOrderErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            CreatePhoneNumberOrderErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreatePhoneNumberOrderError {
    fn code(&self) -> Option<&str> {
        CreatePhoneNumberOrderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePhoneNumberOrderError {
    /// Creates a new `CreatePhoneNumberOrderError`.
                    pub fn new(kind: CreatePhoneNumberOrderErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreatePhoneNumberOrderError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreatePhoneNumberOrderErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreatePhoneNumberOrderError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreatePhoneNumberOrderErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreatePhoneNumberOrderErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreatePhoneNumberOrderErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreatePhoneNumberOrderErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreatePhoneNumberOrderErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `CreatePhoneNumberOrderErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreatePhoneNumberOrderErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `CreatePhoneNumberOrderErrorKind::ResourceLimitExceededException`.
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreatePhoneNumberOrderErrorKind::ResourceLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreatePhoneNumberOrderErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, CreatePhoneNumberOrderErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `CreatePhoneNumberOrderErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, CreatePhoneNumberOrderErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreatePhoneNumberOrderErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, CreatePhoneNumberOrderErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `CreatePhoneNumberOrderErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, CreatePhoneNumberOrderErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for CreatePhoneNumberOrderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePhoneNumberOrderErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreatePhoneNumberOrderErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            CreatePhoneNumberOrderErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            CreatePhoneNumberOrderErrorKind::ResourceLimitExceededException(_inner) =>
            Some(_inner)
            ,
            CreatePhoneNumberOrderErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            CreatePhoneNumberOrderErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            CreatePhoneNumberOrderErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            CreatePhoneNumberOrderErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            CreatePhoneNumberOrderErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `BatchUpdatePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchUpdatePhoneNumberError {
    /// Kind of error that occurred.
                    pub kind: BatchUpdatePhoneNumberErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for BatchUpdatePhoneNumberError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: BatchUpdatePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `BatchUpdatePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchUpdatePhoneNumberErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for BatchUpdatePhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchUpdatePhoneNumberErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            BatchUpdatePhoneNumberErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            BatchUpdatePhoneNumberErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            BatchUpdatePhoneNumberErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            BatchUpdatePhoneNumberErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            BatchUpdatePhoneNumberErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            BatchUpdatePhoneNumberErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            BatchUpdatePhoneNumberErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchUpdatePhoneNumberError {
    fn code(&self) -> Option<&str> {
        BatchUpdatePhoneNumberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchUpdatePhoneNumberError {
    /// Creates a new `BatchUpdatePhoneNumberError`.
                    pub fn new(kind: BatchUpdatePhoneNumberErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `BatchUpdatePhoneNumberError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: BatchUpdatePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `BatchUpdatePhoneNumberError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: BatchUpdatePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `BatchUpdatePhoneNumberErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, BatchUpdatePhoneNumberErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `BatchUpdatePhoneNumberErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, BatchUpdatePhoneNumberErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `BatchUpdatePhoneNumberErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, BatchUpdatePhoneNumberErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `BatchUpdatePhoneNumberErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, BatchUpdatePhoneNumberErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `BatchUpdatePhoneNumberErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, BatchUpdatePhoneNumberErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `BatchUpdatePhoneNumberErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, BatchUpdatePhoneNumberErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `BatchUpdatePhoneNumberErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, BatchUpdatePhoneNumberErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for BatchUpdatePhoneNumberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchUpdatePhoneNumberErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            BatchUpdatePhoneNumberErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            BatchUpdatePhoneNumberErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            BatchUpdatePhoneNumberErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            BatchUpdatePhoneNumberErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            BatchUpdatePhoneNumberErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            BatchUpdatePhoneNumberErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            BatchUpdatePhoneNumberErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `BatchDeletePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDeletePhoneNumberError {
    /// Kind of error that occurred.
                    pub kind: BatchDeletePhoneNumberErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for BatchDeletePhoneNumberError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: BatchDeletePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `BatchDeletePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDeletePhoneNumberErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for BatchDeletePhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDeletePhoneNumberErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDeletePhoneNumberErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDeletePhoneNumberErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDeletePhoneNumberErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDeletePhoneNumberErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDeletePhoneNumberErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDeletePhoneNumberErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDeletePhoneNumberErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchDeletePhoneNumberError {
    fn code(&self) -> Option<&str> {
        BatchDeletePhoneNumberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDeletePhoneNumberError {
    /// Creates a new `BatchDeletePhoneNumberError`.
                    pub fn new(kind: BatchDeletePhoneNumberErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `BatchDeletePhoneNumberError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: BatchDeletePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `BatchDeletePhoneNumberError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: BatchDeletePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `BatchDeletePhoneNumberErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, BatchDeletePhoneNumberErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `BatchDeletePhoneNumberErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, BatchDeletePhoneNumberErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `BatchDeletePhoneNumberErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, BatchDeletePhoneNumberErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `BatchDeletePhoneNumberErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, BatchDeletePhoneNumberErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `BatchDeletePhoneNumberErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, BatchDeletePhoneNumberErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `BatchDeletePhoneNumberErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, BatchDeletePhoneNumberErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `BatchDeletePhoneNumberErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, BatchDeletePhoneNumberErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for BatchDeletePhoneNumberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDeletePhoneNumberErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            BatchDeletePhoneNumberErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            BatchDeletePhoneNumberErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            BatchDeletePhoneNumberErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            BatchDeletePhoneNumberErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            BatchDeletePhoneNumberErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            BatchDeletePhoneNumberErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            BatchDeletePhoneNumberErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `AssociatePhoneNumbersWithVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociatePhoneNumbersWithVoiceConnectorGroupError {
    /// Kind of error that occurred.
                    pub kind: AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for AssociatePhoneNumbersWithVoiceConnectorGroupError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `AssociatePhoneNumbersWithVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for AssociatePhoneNumbersWithVoiceConnectorGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AssociatePhoneNumbersWithVoiceConnectorGroupError {
    fn code(&self) -> Option<&str> {
        AssociatePhoneNumbersWithVoiceConnectorGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociatePhoneNumbersWithVoiceConnectorGroupError {
    /// Creates a new `AssociatePhoneNumbersWithVoiceConnectorGroupError`.
                    pub fn new(kind: AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `AssociatePhoneNumbersWithVoiceConnectorGroupError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `AssociatePhoneNumbersWithVoiceConnectorGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for AssociatePhoneNumbersWithVoiceConnectorGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `AssociatePhoneNumbersWithVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociatePhoneNumbersWithVoiceConnectorError {
    /// Kind of error that occurred.
                    pub kind: AssociatePhoneNumbersWithVoiceConnectorErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for AssociatePhoneNumbersWithVoiceConnectorError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: AssociatePhoneNumbersWithVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `AssociatePhoneNumbersWithVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociatePhoneNumbersWithVoiceConnectorErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for AssociatePhoneNumbersWithVoiceConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AssociatePhoneNumbersWithVoiceConnectorError {
    fn code(&self) -> Option<&str> {
        AssociatePhoneNumbersWithVoiceConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociatePhoneNumbersWithVoiceConnectorError {
    /// Creates a new `AssociatePhoneNumbersWithVoiceConnectorError`.
                    pub fn new(kind: AssociatePhoneNumbersWithVoiceConnectorErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `AssociatePhoneNumbersWithVoiceConnectorError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: AssociatePhoneNumbersWithVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `AssociatePhoneNumbersWithVoiceConnectorError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: AssociatePhoneNumbersWithVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, AssociatePhoneNumbersWithVoiceConnectorErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, AssociatePhoneNumbersWithVoiceConnectorErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, AssociatePhoneNumbersWithVoiceConnectorErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, AssociatePhoneNumbersWithVoiceConnectorErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, AssociatePhoneNumbersWithVoiceConnectorErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, AssociatePhoneNumbersWithVoiceConnectorErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for AssociatePhoneNumbersWithVoiceConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// 
/// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
/// 
/// When logging an error from the SDK, it is recommended that you either wrap the error in
/// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
/// error reporter library that visits the error's cause/source chain, or call
/// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
/// 
#[derive(Debug)]
        pub struct Unhandled {
            source: Box<dyn std::error::Error + Send + Sync + 'static>,
        }
        impl Unhandled {
            #[allow(unused)]
            pub(crate) fn new(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
                Self { source }
            }
        }
        impl std::fmt::Display for Unhandled {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                write!(f, "unhandled error")
            }
        }
        impl std::error::Error for Unhandled {
            fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                Some(self.source.as_ref() as _)
            }
        }

