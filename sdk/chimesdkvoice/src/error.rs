// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `ValidateE911Address` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateE911AddressError {
    /// Kind of error that occurred.
    pub kind: ValidateE911AddressErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for ValidateE911AddressError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ValidateE911AddressErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `ValidateE911Address` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateE911AddressErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ValidateE911AddressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ValidateE911AddressErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ValidateE911AddressErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ValidateE911AddressErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ValidateE911AddressErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ValidateE911AddressErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ValidateE911AddressErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ValidateE911AddressErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ValidateE911AddressErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ValidateE911AddressError {
    fn code(&self) -> Option<&str> {
        ValidateE911AddressError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ValidateE911AddressError {
    /// Creates a new `ValidateE911AddressError`.
    pub fn new(kind: ValidateE911AddressErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ValidateE911AddressError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ValidateE911AddressErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `ValidateE911AddressError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ValidateE911AddressErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ValidateE911AddressErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidateE911AddressErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ValidateE911AddressErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidateE911AddressErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `ValidateE911AddressErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidateE911AddressErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ValidateE911AddressErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidateE911AddressErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ValidateE911AddressErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidateE911AddressErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ValidateE911AddressErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidateE911AddressErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `ValidateE911AddressErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidateE911AddressErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ValidateE911AddressError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ValidateE911AddressErrorKind::BadRequestException(_inner) => Some(_inner),
            ValidateE911AddressErrorKind::ForbiddenException(_inner) => Some(_inner),
            ValidateE911AddressErrorKind::NotFoundException(_inner) => Some(_inner),
            ValidateE911AddressErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ValidateE911AddressErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ValidateE911AddressErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ValidateE911AddressErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ValidateE911AddressErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnauthorizedClientException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl UnauthorizedClientException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<&crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl UnauthorizedClientException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnauthorizedClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthorizedClientException")?;
        if let Some(inner_1) = &self.message {
            {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UnauthorizedClientException {}
/// See [`UnauthorizedClientException`](crate::error::UnauthorizedClientException).
pub mod unauthorized_client_exception {

    /// A builder for [`UnauthorizedClientException`](crate::error::UnauthorizedClientException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedClientException`](crate::error::UnauthorizedClientException).
        pub fn build(self) -> crate::error::UnauthorizedClientException {
            crate::error::UnauthorizedClientException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl UnauthorizedClientException {
    /// Creates a new builder-style object to manufacture [`UnauthorizedClientException`](crate::error::UnauthorizedClientException).
    pub fn builder() -> crate::error::unauthorized_client_exception::Builder {
        crate::error::unauthorized_client_exception::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThrottledClientException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ThrottledClientException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<&crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl ThrottledClientException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottledClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottledClientException")?;
        if let Some(inner_2) = &self.message {
            {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ThrottledClientException {}
/// See [`ThrottledClientException`](crate::error::ThrottledClientException).
pub mod throttled_client_exception {

    /// A builder for [`ThrottledClientException`](crate::error::ThrottledClientException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ThrottledClientException`](crate::error::ThrottledClientException).
        pub fn build(self) -> crate::error::ThrottledClientException {
            crate::error::ThrottledClientException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ThrottledClientException {
    /// Creates a new builder-style object to manufacture [`ThrottledClientException`](crate::error::ThrottledClientException).
    pub fn builder() -> crate::error::throttled_client_exception::Builder {
        crate::error::throttled_client_exception::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceUnavailableException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ServiceUnavailableException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<&crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl ServiceUnavailableException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableException")?;
        if let Some(inner_3) = &self.message {
            {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableException {}
/// See [`ServiceUnavailableException`](crate::error::ServiceUnavailableException).
pub mod service_unavailable_exception {

    /// A builder for [`ServiceUnavailableException`](crate::error::ServiceUnavailableException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableException`](crate::error::ServiceUnavailableException).
        pub fn build(self) -> crate::error::ServiceUnavailableException {
            crate::error::ServiceUnavailableException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ServiceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableException`](crate::error::ServiceUnavailableException).
    pub fn builder() -> crate::error::service_unavailable_exception::Builder {
        crate::error::service_unavailable_exception::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceFailureException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ServiceFailureException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<&crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl ServiceFailureException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceFailureException")?;
        if let Some(inner_4) = &self.message {
            {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ServiceFailureException {}
/// See [`ServiceFailureException`](crate::error::ServiceFailureException).
pub mod service_failure_exception {

    /// A builder for [`ServiceFailureException`](crate::error::ServiceFailureException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceFailureException`](crate::error::ServiceFailureException).
        pub fn build(self) -> crate::error::ServiceFailureException {
            crate::error::ServiceFailureException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ServiceFailureException {
    /// Creates a new builder-style object to manufacture [`ServiceFailureException`](crate::error::ServiceFailureException).
    pub fn builder() -> crate::error::service_failure_exception::Builder {
        crate::error::service_failure_exception::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NotFoundException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl NotFoundException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<&crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl NotFoundException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundException")?;
        if let Some(inner_5) = &self.message {
            {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundException {}
/// See [`NotFoundException`](crate::error::NotFoundException).
pub mod not_found_exception {

    /// A builder for [`NotFoundException`](crate::error::NotFoundException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundException`](crate::error::NotFoundException).
        pub fn build(self) -> crate::error::NotFoundException {
            crate::error::NotFoundException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl NotFoundException {
    /// Creates a new builder-style object to manufacture [`NotFoundException`](crate::error::NotFoundException).
    pub fn builder() -> crate::error::not_found_exception::Builder {
        crate::error::not_found_exception::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ForbiddenException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ForbiddenException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<&crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl ForbiddenException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ForbiddenException")?;
        if let Some(inner_6) = &self.message {
            {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ForbiddenException {}
/// See [`ForbiddenException`](crate::error::ForbiddenException).
pub mod forbidden_exception {

    /// A builder for [`ForbiddenException`](crate::error::ForbiddenException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ForbiddenException`](crate::error::ForbiddenException).
        pub fn build(self) -> crate::error::ForbiddenException {
            crate::error::ForbiddenException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ForbiddenException {
    /// Creates a new builder-style object to manufacture [`ForbiddenException`](crate::error::ForbiddenException).
    pub fn builder() -> crate::error::forbidden_exception::Builder {
        crate::error::forbidden_exception::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BadRequestException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl BadRequestException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<&crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl BadRequestException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestException")?;
        if let Some(inner_7) = &self.message {
            {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestException {}
/// See [`BadRequestException`](crate::error::BadRequestException).
pub mod bad_request_exception {

    /// A builder for [`BadRequestException`](crate::error::BadRequestException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestException`](crate::error::BadRequestException).
        pub fn build(self) -> crate::error::BadRequestException {
            crate::error::BadRequestException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl BadRequestException {
    /// Creates a new builder-style object to manufacture [`BadRequestException`](crate::error::BadRequestException).
    pub fn builder() -> crate::error::bad_request_exception::Builder {
        crate::error::bad_request_exception::Builder::default()
    }
}

/// Error type for the `UpdateVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVoiceConnectorGroupError {
    /// Kind of error that occurred.
    pub kind: UpdateVoiceConnectorGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateVoiceConnectorGroupError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `UpdateVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVoiceConnectorGroupErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateVoiceConnectorGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVoiceConnectorGroupErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorGroupErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorGroupErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            UpdateVoiceConnectorGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateVoiceConnectorGroupError {
    fn code(&self) -> Option<&str> {
        UpdateVoiceConnectorGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateVoiceConnectorGroupError {
    /// Creates a new `UpdateVoiceConnectorGroupError`.
    pub fn new(kind: UpdateVoiceConnectorGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateVoiceConnectorGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateVoiceConnectorGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorGroupErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorGroupErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorGroupErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorGroupErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorGroupErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorGroupErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorGroupErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorGroupErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorGroupErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorGroupErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorGroupErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorGroupErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorGroupErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorGroupErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorGroupErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorGroupErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateVoiceConnectorGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVoiceConnectorGroupErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateVoiceConnectorGroupErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateVoiceConnectorGroupErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateVoiceConnectorGroupErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConflictException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ConflictException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<&crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl ConflictException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_8) = &self.message {
            {
                write!(f, ": {}", inner_8)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException).
pub mod conflict_exception {

    /// A builder for [`ConflictException`](crate::error::ConflictException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException).
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException).
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// Error type for the `UpdateVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVoiceConnectorError {
    /// Kind of error that occurred.
    pub kind: UpdateVoiceConnectorErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateVoiceConnectorError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `UpdateVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVoiceConnectorErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateVoiceConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVoiceConnectorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateVoiceConnectorError {
    fn code(&self) -> Option<&str> {
        UpdateVoiceConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateVoiceConnectorError {
    /// Creates a new `UpdateVoiceConnectorError`.
    pub fn new(kind: UpdateVoiceConnectorErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateVoiceConnectorError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateVoiceConnectorError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateVoiceConnectorErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateVoiceConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVoiceConnectorErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateVoiceConnectorErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateVoiceConnectorErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateVoiceConnectorErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateVoiceConnectorErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateVoiceConnectorErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateVoiceConnectorErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateVoiceConnectorErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `UpdateSipRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSipRuleError {
    /// Kind of error that occurred.
    pub kind: UpdateSipRuleErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateSipRuleError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `UpdateSipRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSipRuleErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateSipRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSipRuleErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateSipRuleErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateSipRuleErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateSipRuleErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateSipRuleErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            UpdateSipRuleErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateSipRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateSipRuleErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateSipRuleErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateSipRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateSipRuleError {
    fn code(&self) -> Option<&str> {
        UpdateSipRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSipRuleError {
    /// Creates a new `UpdateSipRuleError`.
    pub fn new(kind: UpdateSipRuleErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateSipRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateSipRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateSipRuleErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipRuleErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipRuleErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipRuleErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipRuleErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipRuleErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipRuleErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipRuleErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateSipRuleErrorKind::ResourceLimitExceededException`.
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipRuleErrorKind::ResourceLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSipRuleErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipRuleErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSipRuleErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSipRuleErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipRuleErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSipRuleErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipRuleErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateSipRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSipRuleErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateSipRuleErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateSipRuleErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateSipRuleErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateSipRuleErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            UpdateSipRuleErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateSipRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateSipRuleErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateSipRuleErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateSipRuleErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceLimitExceededException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ResourceLimitExceededException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<&crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl ResourceLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceLimitExceededException")?;
        if let Some(inner_9) = &self.message {
            {
                write!(f, ": {}", inner_9)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceLimitExceededException {}
/// See [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException).
pub mod resource_limit_exceeded_exception {

    /// A builder for [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException).
        pub fn build(self) -> crate::error::ResourceLimitExceededException {
            crate::error::ResourceLimitExceededException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ResourceLimitExceededException {
    /// Creates a new builder-style object to manufacture [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException).
    pub fn builder() -> crate::error::resource_limit_exceeded_exception::Builder {
        crate::error::resource_limit_exceeded_exception::Builder::default()
    }
}

/// Error type for the `UpdateSipMediaApplicationCall` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSipMediaApplicationCallError {
    /// Kind of error that occurred.
    pub kind: UpdateSipMediaApplicationCallErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateSipMediaApplicationCallError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateSipMediaApplicationCallErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `UpdateSipMediaApplicationCall` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSipMediaApplicationCallErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateSipMediaApplicationCallError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSipMediaApplicationCallErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateSipMediaApplicationCallErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateSipMediaApplicationCallErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateSipMediaApplicationCallErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSipMediaApplicationCallErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSipMediaApplicationCallErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSipMediaApplicationCallErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSipMediaApplicationCallErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSipMediaApplicationCallErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateSipMediaApplicationCallError {
    fn code(&self) -> Option<&str> {
        UpdateSipMediaApplicationCallError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSipMediaApplicationCallError {
    /// Creates a new `UpdateSipMediaApplicationCallError`.
    pub fn new(
        kind: UpdateSipMediaApplicationCallErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateSipMediaApplicationCallError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSipMediaApplicationCallErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateSipMediaApplicationCallError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSipMediaApplicationCallErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationCallErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationCallErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationCallErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationCallErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationCallErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationCallErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationCallErrorKind::ResourceLimitExceededException`.
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationCallErrorKind::ResourceLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationCallErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationCallErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationCallErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationCallErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationCallErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationCallErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationCallErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationCallErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateSipMediaApplicationCallError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSipMediaApplicationCallErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateSipMediaApplicationCallErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateSipMediaApplicationCallErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateSipMediaApplicationCallErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            UpdateSipMediaApplicationCallErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateSipMediaApplicationCallErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            UpdateSipMediaApplicationCallErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            UpdateSipMediaApplicationCallErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            UpdateSipMediaApplicationCallErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `UpdateSipMediaApplication` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSipMediaApplicationError {
    /// Kind of error that occurred.
    pub kind: UpdateSipMediaApplicationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateSipMediaApplicationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `UpdateSipMediaApplication` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSipMediaApplicationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateSipMediaApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSipMediaApplicationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateSipMediaApplicationErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateSipMediaApplicationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateSipMediaApplicationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateSipMediaApplicationErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSipMediaApplicationErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSipMediaApplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateSipMediaApplicationError {
    fn code(&self) -> Option<&str> {
        UpdateSipMediaApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSipMediaApplicationError {
    /// Creates a new `UpdateSipMediaApplicationError`.
    pub fn new(kind: UpdateSipMediaApplicationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateSipMediaApplicationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateSipMediaApplicationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSipMediaApplicationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateSipMediaApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSipMediaApplicationErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateSipMediaApplicationErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateSipMediaApplicationErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateSipMediaApplicationErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateSipMediaApplicationErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateSipMediaApplicationErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateSipMediaApplicationErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `UpdateProxySession` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateProxySessionError {
    /// Kind of error that occurred.
    pub kind: UpdateProxySessionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateProxySessionError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `UpdateProxySession` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateProxySessionErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateProxySessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateProxySessionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateProxySessionErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateProxySessionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateProxySessionErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateProxySessionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateProxySessionErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateProxySessionErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateProxySessionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateProxySessionError {
    fn code(&self) -> Option<&str> {
        UpdateProxySessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateProxySessionError {
    /// Creates a new `UpdateProxySessionError`.
    pub fn new(kind: UpdateProxySessionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateProxySessionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateProxySessionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateProxySessionErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProxySessionErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateProxySessionErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProxySessionErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateProxySessionErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProxySessionErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateProxySessionErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProxySessionErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateProxySessionErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProxySessionErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateProxySessionErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProxySessionErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateProxySessionErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProxySessionErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateProxySessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateProxySessionErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateProxySessionErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateProxySessionErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateProxySessionErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateProxySessionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateProxySessionErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateProxySessionErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateProxySessionErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `UpdatePhoneNumberSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePhoneNumberSettingsError {
    /// Kind of error that occurred.
    pub kind: UpdatePhoneNumberSettingsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for UpdatePhoneNumberSettingsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdatePhoneNumberSettingsErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `UpdatePhoneNumberSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePhoneNumberSettingsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdatePhoneNumberSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePhoneNumberSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberSettingsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberSettingsErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePhoneNumberSettingsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberSettingsErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePhoneNumberSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdatePhoneNumberSettingsError {
    fn code(&self) -> Option<&str> {
        UpdatePhoneNumberSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePhoneNumberSettingsError {
    /// Creates a new `UpdatePhoneNumberSettingsError`.
    pub fn new(kind: UpdatePhoneNumberSettingsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdatePhoneNumberSettingsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdatePhoneNumberSettingsErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdatePhoneNumberSettingsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdatePhoneNumberSettingsErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberSettingsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberSettingsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberSettingsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberSettingsErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberSettingsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberSettingsErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberSettingsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberSettingsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberSettingsErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberSettingsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberSettingsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdatePhoneNumberSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePhoneNumberSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdatePhoneNumberSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdatePhoneNumberSettingsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdatePhoneNumberSettingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdatePhoneNumberSettingsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdatePhoneNumberSettingsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdatePhoneNumberSettingsErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `UpdatePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePhoneNumberError {
    /// Kind of error that occurred.
    pub kind: UpdatePhoneNumberErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for UpdatePhoneNumberError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdatePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `UpdatePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePhoneNumberErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdatePhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePhoneNumberErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdatePhoneNumberError {
    fn code(&self) -> Option<&str> {
        UpdatePhoneNumberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePhoneNumberError {
    /// Creates a new `UpdatePhoneNumberError`.
    pub fn new(kind: UpdatePhoneNumberErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdatePhoneNumberError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdatePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdatePhoneNumberError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdatePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdatePhoneNumberErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdatePhoneNumberErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePhoneNumberErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdatePhoneNumberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePhoneNumberErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdatePhoneNumberErrorKind::ConflictException(_inner) => Some(_inner),
            UpdatePhoneNumberErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdatePhoneNumberErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdatePhoneNumberErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdatePhoneNumberErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdatePhoneNumberErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdatePhoneNumberErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdatePhoneNumberErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `UpdateGlobalSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGlobalSettingsError {
    /// Kind of error that occurred.
    pub kind: UpdateGlobalSettingsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateGlobalSettingsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateGlobalSettingsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `UpdateGlobalSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGlobalSettingsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateGlobalSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateGlobalSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateGlobalSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateGlobalSettingsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateGlobalSettingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateGlobalSettingsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateGlobalSettingsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateGlobalSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateGlobalSettingsError {
    fn code(&self) -> Option<&str> {
        UpdateGlobalSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateGlobalSettingsError {
    /// Creates a new `UpdateGlobalSettingsError`.
    pub fn new(kind: UpdateGlobalSettingsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateGlobalSettingsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateGlobalSettingsErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateGlobalSettingsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateGlobalSettingsErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateGlobalSettingsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGlobalSettingsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateGlobalSettingsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGlobalSettingsErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateGlobalSettingsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGlobalSettingsErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateGlobalSettingsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGlobalSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateGlobalSettingsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGlobalSettingsErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateGlobalSettingsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGlobalSettingsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateGlobalSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateGlobalSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateGlobalSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateGlobalSettingsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateGlobalSettingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateGlobalSettingsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateGlobalSettingsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateGlobalSettingsErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `SearchAvailablePhoneNumbers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SearchAvailablePhoneNumbersError {
    /// Kind of error that occurred.
    pub kind: SearchAvailablePhoneNumbersErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for SearchAvailablePhoneNumbersError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: SearchAvailablePhoneNumbersErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `SearchAvailablePhoneNumbers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SearchAvailablePhoneNumbersErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for SearchAvailablePhoneNumbersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SearchAvailablePhoneNumbersErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            SearchAvailablePhoneNumbersErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            SearchAvailablePhoneNumbersErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            SearchAvailablePhoneNumbersErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            SearchAvailablePhoneNumbersErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            SearchAvailablePhoneNumbersErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            SearchAvailablePhoneNumbersErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            SearchAvailablePhoneNumbersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for SearchAvailablePhoneNumbersError {
    fn code(&self) -> Option<&str> {
        SearchAvailablePhoneNumbersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl SearchAvailablePhoneNumbersError {
    /// Creates a new `SearchAvailablePhoneNumbersError`.
    pub fn new(kind: SearchAvailablePhoneNumbersErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `SearchAvailablePhoneNumbersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SearchAvailablePhoneNumbersErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `SearchAvailablePhoneNumbersError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SearchAvailablePhoneNumbersErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `SearchAvailablePhoneNumbersErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchAvailablePhoneNumbersErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `SearchAvailablePhoneNumbersErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchAvailablePhoneNumbersErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `SearchAvailablePhoneNumbersErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchAvailablePhoneNumbersErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `SearchAvailablePhoneNumbersErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchAvailablePhoneNumbersErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `SearchAvailablePhoneNumbersErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchAvailablePhoneNumbersErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `SearchAvailablePhoneNumbersErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchAvailablePhoneNumbersErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `SearchAvailablePhoneNumbersErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchAvailablePhoneNumbersErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for SearchAvailablePhoneNumbersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SearchAvailablePhoneNumbersErrorKind::AccessDeniedException(_inner) => Some(_inner),
            SearchAvailablePhoneNumbersErrorKind::BadRequestException(_inner) => Some(_inner),
            SearchAvailablePhoneNumbersErrorKind::ForbiddenException(_inner) => Some(_inner),
            SearchAvailablePhoneNumbersErrorKind::ServiceFailureException(_inner) => Some(_inner),
            SearchAvailablePhoneNumbersErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            SearchAvailablePhoneNumbersErrorKind::ThrottledClientException(_inner) => Some(_inner),
            SearchAvailablePhoneNumbersErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            SearchAvailablePhoneNumbersErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessDeniedException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl AccessDeniedException {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<&crate::model::ErrorCode> {
        self.code.as_ref()
    }
}
impl AccessDeniedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_10) = &self.message {
            {
                write!(f, ": {}", inner_10)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException).
pub mod access_denied_exception {

    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException).
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException).
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// Error type for the `RestorePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestorePhoneNumberError {
    /// Kind of error that occurred.
    pub kind: RestorePhoneNumberErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for RestorePhoneNumberError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: RestorePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `RestorePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestorePhoneNumberErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for RestorePhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestorePhoneNumberErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            RestorePhoneNumberErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            RestorePhoneNumberErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            RestorePhoneNumberErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            RestorePhoneNumberErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            RestorePhoneNumberErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            RestorePhoneNumberErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            RestorePhoneNumberErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            RestorePhoneNumberErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RestorePhoneNumberError {
    fn code(&self) -> Option<&str> {
        RestorePhoneNumberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestorePhoneNumberError {
    /// Creates a new `RestorePhoneNumberError`.
    pub fn new(kind: RestorePhoneNumberErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `RestorePhoneNumberError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestorePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `RestorePhoneNumberError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestorePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `RestorePhoneNumberErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestorePhoneNumberErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `RestorePhoneNumberErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestorePhoneNumberErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `RestorePhoneNumberErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestorePhoneNumberErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `RestorePhoneNumberErrorKind::ResourceLimitExceededException`.
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestorePhoneNumberErrorKind::ResourceLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `RestorePhoneNumberErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestorePhoneNumberErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `RestorePhoneNumberErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestorePhoneNumberErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `RestorePhoneNumberErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestorePhoneNumberErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `RestorePhoneNumberErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestorePhoneNumberErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for RestorePhoneNumberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestorePhoneNumberErrorKind::BadRequestException(_inner) => Some(_inner),
            RestorePhoneNumberErrorKind::ForbiddenException(_inner) => Some(_inner),
            RestorePhoneNumberErrorKind::NotFoundException(_inner) => Some(_inner),
            RestorePhoneNumberErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            RestorePhoneNumberErrorKind::ServiceFailureException(_inner) => Some(_inner),
            RestorePhoneNumberErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            RestorePhoneNumberErrorKind::ThrottledClientException(_inner) => Some(_inner),
            RestorePhoneNumberErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            RestorePhoneNumberErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `PutVoiceConnectorTerminationCredentials` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorTerminationCredentialsError {
    /// Kind of error that occurred.
    pub kind: PutVoiceConnectorTerminationCredentialsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError
    for PutVoiceConnectorTerminationCredentialsError
{
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutVoiceConnectorTerminationCredentialsErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `PutVoiceConnectorTerminationCredentials` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorTerminationCredentialsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutVoiceConnectorTerminationCredentialsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            PutVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            PutVoiceConnectorTerminationCredentialsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutVoiceConnectorTerminationCredentialsError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorTerminationCredentialsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorTerminationCredentialsError {
    /// Creates a new `PutVoiceConnectorTerminationCredentialsError`.
    pub fn new(
        kind: PutVoiceConnectorTerminationCredentialsErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PutVoiceConnectorTerminationCredentialsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutVoiceConnectorTerminationCredentialsErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `PutVoiceConnectorTerminationCredentialsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutVoiceConnectorTerminationCredentialsErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationCredentialsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationCredentialsErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutVoiceConnectorTerminationCredentialsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            PutVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            PutVoiceConnectorTerminationCredentialsErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `PutVoiceConnectorTermination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorTerminationError {
    /// Kind of error that occurred.
    pub kind: PutVoiceConnectorTerminationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for PutVoiceConnectorTerminationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutVoiceConnectorTerminationErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `PutVoiceConnectorTermination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorTerminationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutVoiceConnectorTerminationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorTerminationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            PutVoiceConnectorTerminationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutVoiceConnectorTerminationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            PutVoiceConnectorTerminationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutVoiceConnectorTerminationErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            PutVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorTerminationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorTerminationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutVoiceConnectorTerminationError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorTerminationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorTerminationError {
    /// Creates a new `PutVoiceConnectorTerminationError`.
    pub fn new(kind: PutVoiceConnectorTerminationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PutVoiceConnectorTerminationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutVoiceConnectorTerminationErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `PutVoiceConnectorTerminationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutVoiceConnectorTerminationErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorTerminationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutVoiceConnectorTerminationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorTerminationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            PutVoiceConnectorTerminationErrorKind::BadRequestException(_inner) => Some(_inner),
            PutVoiceConnectorTerminationErrorKind::ForbiddenException(_inner) => Some(_inner),
            PutVoiceConnectorTerminationErrorKind::NotFoundException(_inner) => Some(_inner),
            PutVoiceConnectorTerminationErrorKind::ServiceFailureException(_inner) => Some(_inner),
            PutVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorTerminationErrorKind::ThrottledClientException(_inner) => Some(_inner),
            PutVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorTerminationErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `PutVoiceConnectorStreamingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorStreamingConfigurationError {
    /// Kind of error that occurred.
    pub kind: PutVoiceConnectorStreamingConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError
    for PutVoiceConnectorStreamingConfigurationError
{
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutVoiceConnectorStreamingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `PutVoiceConnectorStreamingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorStreamingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutVoiceConnectorStreamingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            PutVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            PutVoiceConnectorStreamingConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutVoiceConnectorStreamingConfigurationError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorStreamingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorStreamingConfigurationError {
    /// Creates a new `PutVoiceConnectorStreamingConfigurationError`.
    pub fn new(
        kind: PutVoiceConnectorStreamingConfigurationErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PutVoiceConnectorStreamingConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutVoiceConnectorStreamingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `PutVoiceConnectorStreamingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutVoiceConnectorStreamingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorStreamingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorStreamingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutVoiceConnectorStreamingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            PutVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            PutVoiceConnectorStreamingConfigurationErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `PutVoiceConnectorProxy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorProxyError {
    /// Kind of error that occurred.
    pub kind: PutVoiceConnectorProxyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for PutVoiceConnectorProxyError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutVoiceConnectorProxyErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `PutVoiceConnectorProxy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorProxyErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutVoiceConnectorProxyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorProxyErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            PutVoiceConnectorProxyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutVoiceConnectorProxyErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            PutVoiceConnectorProxyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutVoiceConnectorProxyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            PutVoiceConnectorProxyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            PutVoiceConnectorProxyErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            PutVoiceConnectorProxyErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            PutVoiceConnectorProxyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutVoiceConnectorProxyError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorProxyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorProxyError {
    /// Creates a new `PutVoiceConnectorProxyError`.
    pub fn new(kind: PutVoiceConnectorProxyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PutVoiceConnectorProxyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutVoiceConnectorProxyErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `PutVoiceConnectorProxyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutVoiceConnectorProxyErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorProxyErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorProxyErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorProxyErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorProxyErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorProxyErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorProxyErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorProxyErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorProxyErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorProxyErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorProxyErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorProxyErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorProxyErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorProxyErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorProxyErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorProxyErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorProxyErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutVoiceConnectorProxyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorProxyErrorKind::AccessDeniedException(_inner) => Some(_inner),
            PutVoiceConnectorProxyErrorKind::BadRequestException(_inner) => Some(_inner),
            PutVoiceConnectorProxyErrorKind::ForbiddenException(_inner) => Some(_inner),
            PutVoiceConnectorProxyErrorKind::NotFoundException(_inner) => Some(_inner),
            PutVoiceConnectorProxyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            PutVoiceConnectorProxyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            PutVoiceConnectorProxyErrorKind::ThrottledClientException(_inner) => Some(_inner),
            PutVoiceConnectorProxyErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            PutVoiceConnectorProxyErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `PutVoiceConnectorOrigination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorOriginationError {
    /// Kind of error that occurred.
    pub kind: PutVoiceConnectorOriginationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for PutVoiceConnectorOriginationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutVoiceConnectorOriginationErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `PutVoiceConnectorOrigination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorOriginationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutVoiceConnectorOriginationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorOriginationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutVoiceConnectorOriginationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            PutVoiceConnectorOriginationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutVoiceConnectorOriginationErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            PutVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorOriginationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorOriginationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutVoiceConnectorOriginationError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorOriginationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorOriginationError {
    /// Creates a new `PutVoiceConnectorOriginationError`.
    pub fn new(kind: PutVoiceConnectorOriginationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PutVoiceConnectorOriginationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutVoiceConnectorOriginationErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `PutVoiceConnectorOriginationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutVoiceConnectorOriginationErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorOriginationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorOriginationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorOriginationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorOriginationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorOriginationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorOriginationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorOriginationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorOriginationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorOriginationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorOriginationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorOriginationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorOriginationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutVoiceConnectorOriginationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorOriginationErrorKind::BadRequestException(_inner) => Some(_inner),
            PutVoiceConnectorOriginationErrorKind::ForbiddenException(_inner) => Some(_inner),
            PutVoiceConnectorOriginationErrorKind::NotFoundException(_inner) => Some(_inner),
            PutVoiceConnectorOriginationErrorKind::ServiceFailureException(_inner) => Some(_inner),
            PutVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorOriginationErrorKind::ThrottledClientException(_inner) => Some(_inner),
            PutVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorOriginationErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `PutVoiceConnectorLoggingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorLoggingConfigurationError {
    /// Kind of error that occurred.
    pub kind: PutVoiceConnectorLoggingConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for PutVoiceConnectorLoggingConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutVoiceConnectorLoggingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `PutVoiceConnectorLoggingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorLoggingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutVoiceConnectorLoggingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorLoggingConfigurationErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutVoiceConnectorLoggingConfigurationError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorLoggingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorLoggingConfigurationError {
    /// Creates a new `PutVoiceConnectorLoggingConfigurationError`.
    pub fn new(
        kind: PutVoiceConnectorLoggingConfigurationErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PutVoiceConnectorLoggingConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutVoiceConnectorLoggingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `PutVoiceConnectorLoggingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutVoiceConnectorLoggingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorLoggingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorLoggingConfigurationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorLoggingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorLoggingConfigurationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutVoiceConnectorLoggingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorLoggingConfigurationErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `PutVoiceConnectorEmergencyCallingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorEmergencyCallingConfigurationError {
    /// Kind of error that occurred.
    pub kind: PutVoiceConnectorEmergencyCallingConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError
    for PutVoiceConnectorEmergencyCallingConfigurationError
{
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `PutVoiceConnectorEmergencyCallingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorEmergencyCallingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutVoiceConnectorEmergencyCallingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for PutVoiceConnectorEmergencyCallingConfigurationError
{
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorEmergencyCallingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorEmergencyCallingConfigurationError {
    /// Creates a new `PutVoiceConnectorEmergencyCallingConfigurationError`.
    pub fn new(
        kind: PutVoiceConnectorEmergencyCallingConfigurationErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PutVoiceConnectorEmergencyCallingConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `PutVoiceConnectorEmergencyCallingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `PutVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutVoiceConnectorEmergencyCallingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `PutSipMediaApplicationLoggingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutSipMediaApplicationLoggingConfigurationError {
    /// Kind of error that occurred.
    pub kind: PutSipMediaApplicationLoggingConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError
    for PutSipMediaApplicationLoggingConfigurationError
{
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `PutSipMediaApplicationLoggingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutSipMediaApplicationLoggingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutSipMediaApplicationLoggingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            PutSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException(
                _inner,
            ) => _inner.fmt(f),
            PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            PutSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException(
                _inner,
            ) => _inner.fmt(f),
            PutSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            PutSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutSipMediaApplicationLoggingConfigurationError {
    fn code(&self) -> Option<&str> {
        PutSipMediaApplicationLoggingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutSipMediaApplicationLoggingConfigurationError {
    /// Creates a new `PutSipMediaApplicationLoggingConfigurationError`.
    pub fn new(
        kind: PutSipMediaApplicationLoggingConfigurationErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PutSipMediaApplicationLoggingConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `PutSipMediaApplicationLoggingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutSipMediaApplicationLoggingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            PutSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            PutSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException(
                _inner,
            ) => Some(_inner),
            PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            PutSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException(
                _inner,
            ) => Some(_inner),
            PutSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            PutSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `PutSipMediaApplicationAlexaSkillConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutSipMediaApplicationAlexaSkillConfigurationError {
    /// Kind of error that occurred.
    pub kind: PutSipMediaApplicationAlexaSkillConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError
    for PutSipMediaApplicationAlexaSkillConfigurationError
{
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `PutSipMediaApplicationAlexaSkillConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutSipMediaApplicationAlexaSkillConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutSipMediaApplicationAlexaSkillConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceFailureException(
                _inner,
            ) => _inner.fmt(f),
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ThrottledClientException(
                _inner,
            ) => _inner.fmt(f),
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for PutSipMediaApplicationAlexaSkillConfigurationError
{
    fn code(&self) -> Option<&str> {
        PutSipMediaApplicationAlexaSkillConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutSipMediaApplicationAlexaSkillConfigurationError {
    /// Creates a new `PutSipMediaApplicationAlexaSkillConfigurationError`.
    pub fn new(
        kind: PutSipMediaApplicationAlexaSkillConfigurationErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PutSipMediaApplicationAlexaSkillConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `PutSipMediaApplicationAlexaSkillConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationAlexaSkillConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationAlexaSkillConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `PutSipMediaApplicationAlexaSkillConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutSipMediaApplicationAlexaSkillConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceFailureException(
                _inner,
            ) => Some(_inner),
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::ThrottledClientException(
                _inner,
            ) => Some(_inner),
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            PutSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListVoiceConnectorTerminationCredentials` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVoiceConnectorTerminationCredentialsError {
    /// Kind of error that occurred.
    pub kind: ListVoiceConnectorTerminationCredentialsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError
    for ListVoiceConnectorTerminationCredentialsError
{
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListVoiceConnectorTerminationCredentialsErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `ListVoiceConnectorTerminationCredentials` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVoiceConnectorTerminationCredentialsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListVoiceConnectorTerminationCredentialsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            ListVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            ListVoiceConnectorTerminationCredentialsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListVoiceConnectorTerminationCredentialsError {
    fn code(&self) -> Option<&str> {
        ListVoiceConnectorTerminationCredentialsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVoiceConnectorTerminationCredentialsError {
    /// Creates a new `ListVoiceConnectorTerminationCredentialsError`.
    pub fn new(
        kind: ListVoiceConnectorTerminationCredentialsErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListVoiceConnectorTerminationCredentialsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVoiceConnectorTerminationCredentialsErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `ListVoiceConnectorTerminationCredentialsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVoiceConnectorTerminationCredentialsErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorTerminationCredentialsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorTerminationCredentialsErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListVoiceConnectorTerminationCredentialsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            ListVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            ListVoiceConnectorTerminationCredentialsErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `ListVoiceConnectors` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVoiceConnectorsError {
    /// Kind of error that occurred.
    pub kind: ListVoiceConnectorsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for ListVoiceConnectorsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListVoiceConnectorsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `ListVoiceConnectors` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVoiceConnectorsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListVoiceConnectorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVoiceConnectorsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListVoiceConnectorsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListVoiceConnectorsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListVoiceConnectorsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListVoiceConnectorsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListVoiceConnectorsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListVoiceConnectorsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListVoiceConnectorsError {
    fn code(&self) -> Option<&str> {
        ListVoiceConnectorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVoiceConnectorsError {
    /// Creates a new `ListVoiceConnectorsError`.
    pub fn new(kind: ListVoiceConnectorsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListVoiceConnectorsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVoiceConnectorsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `ListVoiceConnectorsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVoiceConnectorsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorsErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorsErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorsErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListVoiceConnectorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVoiceConnectorsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListVoiceConnectorsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListVoiceConnectorsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListVoiceConnectorsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListVoiceConnectorsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListVoiceConnectorsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListVoiceConnectorsErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `ListVoiceConnectorGroups` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVoiceConnectorGroupsError {
    /// Kind of error that occurred.
    pub kind: ListVoiceConnectorGroupsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for ListVoiceConnectorGroupsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListVoiceConnectorGroupsErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `ListVoiceConnectorGroups` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVoiceConnectorGroupsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListVoiceConnectorGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVoiceConnectorGroupsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListVoiceConnectorGroupsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListVoiceConnectorGroupsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListVoiceConnectorGroupsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListVoiceConnectorGroupsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListVoiceConnectorGroupsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListVoiceConnectorGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListVoiceConnectorGroupsError {
    fn code(&self) -> Option<&str> {
        ListVoiceConnectorGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVoiceConnectorGroupsError {
    /// Creates a new `ListVoiceConnectorGroupsError`.
    pub fn new(kind: ListVoiceConnectorGroupsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListVoiceConnectorGroupsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVoiceConnectorGroupsErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `ListVoiceConnectorGroupsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVoiceConnectorGroupsErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorGroupsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorGroupsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorGroupsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorGroupsErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorGroupsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorGroupsErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorGroupsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorGroupsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorGroupsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorGroupsErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `ListVoiceConnectorGroupsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorGroupsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListVoiceConnectorGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVoiceConnectorGroupsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListVoiceConnectorGroupsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListVoiceConnectorGroupsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListVoiceConnectorGroupsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListVoiceConnectorGroupsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListVoiceConnectorGroupsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListVoiceConnectorGroupsErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `ListSupportedPhoneNumberCountries` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSupportedPhoneNumberCountriesError {
    /// Kind of error that occurred.
    pub kind: ListSupportedPhoneNumberCountriesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for ListSupportedPhoneNumberCountriesError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListSupportedPhoneNumberCountriesErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `ListSupportedPhoneNumberCountries` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSupportedPhoneNumberCountriesErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListSupportedPhoneNumberCountriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSupportedPhoneNumberCountriesErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ListSupportedPhoneNumberCountriesErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListSupportedPhoneNumberCountriesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListSupportedPhoneNumberCountriesErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListSupportedPhoneNumberCountriesErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            ListSupportedPhoneNumberCountriesErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            ListSupportedPhoneNumberCountriesErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            ListSupportedPhoneNumberCountriesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListSupportedPhoneNumberCountriesError {
    fn code(&self) -> Option<&str> {
        ListSupportedPhoneNumberCountriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSupportedPhoneNumberCountriesError {
    /// Creates a new `ListSupportedPhoneNumberCountriesError`.
    pub fn new(
        kind: ListSupportedPhoneNumberCountriesErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListSupportedPhoneNumberCountriesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSupportedPhoneNumberCountriesErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `ListSupportedPhoneNumberCountriesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSupportedPhoneNumberCountriesErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListSupportedPhoneNumberCountriesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSupportedPhoneNumberCountriesErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSupportedPhoneNumberCountriesErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSupportedPhoneNumberCountriesErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSupportedPhoneNumberCountriesErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSupportedPhoneNumberCountriesErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSupportedPhoneNumberCountriesErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSupportedPhoneNumberCountriesErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSupportedPhoneNumberCountriesErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSupportedPhoneNumberCountriesErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSupportedPhoneNumberCountriesErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSupportedPhoneNumberCountriesErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSupportedPhoneNumberCountriesErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSupportedPhoneNumberCountriesErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListSupportedPhoneNumberCountriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSupportedPhoneNumberCountriesErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            ListSupportedPhoneNumberCountriesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListSupportedPhoneNumberCountriesErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListSupportedPhoneNumberCountriesErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            ListSupportedPhoneNumberCountriesErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            ListSupportedPhoneNumberCountriesErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            ListSupportedPhoneNumberCountriesErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            ListSupportedPhoneNumberCountriesErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `ListSipRules` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSipRulesError {
    /// Kind of error that occurred.
    pub kind: ListSipRulesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for ListSipRulesError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListSipRulesErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `ListSipRules` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSipRulesErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListSipRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSipRulesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListSipRulesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListSipRulesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListSipRulesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListSipRulesErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListSipRulesErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListSipRulesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListSipRulesError {
    fn code(&self) -> Option<&str> {
        ListSipRulesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSipRulesError {
    /// Creates a new `ListSipRulesError`.
    pub fn new(kind: ListSipRulesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListSipRulesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSipRulesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `ListSipRulesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSipRulesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListSipRulesErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListSipRulesErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `ListSipRulesErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListSipRulesErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `ListSipRulesErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipRulesErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSipRulesErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipRulesErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSipRulesErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipRulesErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSipRulesErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipRulesErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListSipRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSipRulesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListSipRulesErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListSipRulesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListSipRulesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListSipRulesErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListSipRulesErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListSipRulesErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `ListSipMediaApplications` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSipMediaApplicationsError {
    /// Kind of error that occurred.
    pub kind: ListSipMediaApplicationsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for ListSipMediaApplicationsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListSipMediaApplicationsErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `ListSipMediaApplications` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSipMediaApplicationsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListSipMediaApplicationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSipMediaApplicationsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListSipMediaApplicationsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListSipMediaApplicationsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListSipMediaApplicationsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListSipMediaApplicationsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListSipMediaApplicationsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListSipMediaApplicationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListSipMediaApplicationsError {
    fn code(&self) -> Option<&str> {
        ListSipMediaApplicationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSipMediaApplicationsError {
    /// Creates a new `ListSipMediaApplicationsError`.
    pub fn new(kind: ListSipMediaApplicationsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListSipMediaApplicationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSipMediaApplicationsErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `ListSipMediaApplicationsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSipMediaApplicationsErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListSipMediaApplicationsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipMediaApplicationsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSipMediaApplicationsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipMediaApplicationsErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSipMediaApplicationsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipMediaApplicationsErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSipMediaApplicationsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipMediaApplicationsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSipMediaApplicationsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipMediaApplicationsErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `ListSipMediaApplicationsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipMediaApplicationsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListSipMediaApplicationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSipMediaApplicationsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListSipMediaApplicationsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListSipMediaApplicationsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListSipMediaApplicationsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListSipMediaApplicationsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListSipMediaApplicationsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListSipMediaApplicationsErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `ListProxySessions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListProxySessionsError {
    /// Kind of error that occurred.
    pub kind: ListProxySessionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for ListProxySessionsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListProxySessionsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `ListProxySessions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListProxySessionsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListProxySessionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListProxySessionsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListProxySessionsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListProxySessionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListProxySessionsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListProxySessionsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListProxySessionsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListProxySessionsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListProxySessionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListProxySessionsError {
    fn code(&self) -> Option<&str> {
        ListProxySessionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListProxySessionsError {
    /// Creates a new `ListProxySessionsError`.
    pub fn new(kind: ListProxySessionsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListProxySessionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListProxySessionsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `ListProxySessionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListProxySessionsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListProxySessionsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProxySessionsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListProxySessionsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProxySessionsErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListProxySessionsErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListProxySessionsErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListProxySessionsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProxySessionsErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListProxySessionsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProxySessionsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListProxySessionsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProxySessionsErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `ListProxySessionsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProxySessionsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListProxySessionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListProxySessionsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListProxySessionsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListProxySessionsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListProxySessionsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListProxySessionsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListProxySessionsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListProxySessionsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListProxySessionsErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `ListPhoneNumbers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPhoneNumbersError {
    /// Kind of error that occurred.
    pub kind: ListPhoneNumbersErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for ListPhoneNumbersError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListPhoneNumbersErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `ListPhoneNumbers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPhoneNumbersErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListPhoneNumbersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPhoneNumbersErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListPhoneNumbersErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListPhoneNumbersErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListPhoneNumbersErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListPhoneNumbersErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListPhoneNumbersErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListPhoneNumbersErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListPhoneNumbersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListPhoneNumbersError {
    fn code(&self) -> Option<&str> {
        ListPhoneNumbersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPhoneNumbersError {
    /// Creates a new `ListPhoneNumbersError`.
    pub fn new(kind: ListPhoneNumbersErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListPhoneNumbersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPhoneNumbersErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `ListPhoneNumbersError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPhoneNumbersErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListPhoneNumbersErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumbersErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPhoneNumbersErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListPhoneNumbersErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `ListPhoneNumbersErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListPhoneNumbersErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListPhoneNumbersErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumbersErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPhoneNumbersErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumbersErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPhoneNumbersErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumbersErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPhoneNumbersErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumbersErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListPhoneNumbersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPhoneNumbersErrorKind::BadRequestException(_inner) => Some(_inner),
            ListPhoneNumbersErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListPhoneNumbersErrorKind::NotFoundException(_inner) => Some(_inner),
            ListPhoneNumbersErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListPhoneNumbersErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListPhoneNumbersErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListPhoneNumbersErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListPhoneNumbersErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `ListPhoneNumberOrders` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPhoneNumberOrdersError {
    /// Kind of error that occurred.
    pub kind: ListPhoneNumberOrdersErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for ListPhoneNumberOrdersError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListPhoneNumberOrdersErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `ListPhoneNumberOrders` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPhoneNumberOrdersErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListPhoneNumberOrdersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPhoneNumberOrdersErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListPhoneNumberOrdersErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListPhoneNumberOrdersErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListPhoneNumberOrdersErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListPhoneNumberOrdersErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListPhoneNumberOrdersErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListPhoneNumberOrdersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListPhoneNumberOrdersError {
    fn code(&self) -> Option<&str> {
        ListPhoneNumberOrdersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPhoneNumberOrdersError {
    /// Creates a new `ListPhoneNumberOrdersError`.
    pub fn new(kind: ListPhoneNumberOrdersErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListPhoneNumberOrdersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPhoneNumberOrdersErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `ListPhoneNumberOrdersError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPhoneNumberOrdersErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListPhoneNumberOrdersErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumberOrdersErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPhoneNumberOrdersErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumberOrdersErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPhoneNumberOrdersErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumberOrdersErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPhoneNumberOrdersErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumberOrdersErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPhoneNumberOrdersErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumberOrdersErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPhoneNumberOrdersErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumberOrdersErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListPhoneNumberOrdersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPhoneNumberOrdersErrorKind::BadRequestException(_inner) => Some(_inner),
            ListPhoneNumberOrdersErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListPhoneNumberOrdersErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListPhoneNumberOrdersErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListPhoneNumberOrdersErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListPhoneNumberOrdersErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListPhoneNumberOrdersErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `ListAvailableVoiceConnectorRegions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAvailableVoiceConnectorRegionsError {
    /// Kind of error that occurred.
    pub kind: ListAvailableVoiceConnectorRegionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for ListAvailableVoiceConnectorRegionsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListAvailableVoiceConnectorRegionsErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `ListAvailableVoiceConnectorRegions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAvailableVoiceConnectorRegionsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListAvailableVoiceConnectorRegionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAvailableVoiceConnectorRegionsErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListAvailableVoiceConnectorRegionsErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            ListAvailableVoiceConnectorRegionsErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListAvailableVoiceConnectorRegionsErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            ListAvailableVoiceConnectorRegionsErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            ListAvailableVoiceConnectorRegionsErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            ListAvailableVoiceConnectorRegionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListAvailableVoiceConnectorRegionsError {
    fn code(&self) -> Option<&str> {
        ListAvailableVoiceConnectorRegionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAvailableVoiceConnectorRegionsError {
    /// Creates a new `ListAvailableVoiceConnectorRegionsError`.
    pub fn new(
        kind: ListAvailableVoiceConnectorRegionsErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListAvailableVoiceConnectorRegionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAvailableVoiceConnectorRegionsErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `ListAvailableVoiceConnectorRegionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAvailableVoiceConnectorRegionsErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListAvailableVoiceConnectorRegionsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAvailableVoiceConnectorRegionsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAvailableVoiceConnectorRegionsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAvailableVoiceConnectorRegionsErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAvailableVoiceConnectorRegionsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAvailableVoiceConnectorRegionsErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAvailableVoiceConnectorRegionsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAvailableVoiceConnectorRegionsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAvailableVoiceConnectorRegionsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAvailableVoiceConnectorRegionsErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `ListAvailableVoiceConnectorRegionsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAvailableVoiceConnectorRegionsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListAvailableVoiceConnectorRegionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAvailableVoiceConnectorRegionsErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            ListAvailableVoiceConnectorRegionsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListAvailableVoiceConnectorRegionsErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            ListAvailableVoiceConnectorRegionsErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            ListAvailableVoiceConnectorRegionsErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            ListAvailableVoiceConnectorRegionsErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            ListAvailableVoiceConnectorRegionsErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `GetVoiceConnectorTerminationHealth` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorTerminationHealthError {
    /// Kind of error that occurred.
    pub kind: GetVoiceConnectorTerminationHealthErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for GetVoiceConnectorTerminationHealthError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetVoiceConnectorTerminationHealthErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `GetVoiceConnectorTerminationHealth` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorTerminationHealthErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetVoiceConnectorTerminationHealthError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorTerminationHealthErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorTerminationHealthErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorTerminationHealthErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVoiceConnectorTerminationHealthErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorTerminationHealthErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorTerminationHealthErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorTerminationHealthErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorTerminationHealthErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetVoiceConnectorTerminationHealthError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorTerminationHealthError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorTerminationHealthError {
    /// Creates a new `GetVoiceConnectorTerminationHealthError`.
    pub fn new(
        kind: GetVoiceConnectorTerminationHealthErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetVoiceConnectorTerminationHealthError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceConnectorTerminationHealthErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `GetVoiceConnectorTerminationHealthError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceConnectorTerminationHealthErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationHealthErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationHealthErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationHealthErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationHealthErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationHealthErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationHealthErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationHealthErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationHealthErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationHealthErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationHealthErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationHealthErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationHealthErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationHealthErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationHealthErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetVoiceConnectorTerminationHealthError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorTerminationHealthErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorTerminationHealthErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetVoiceConnectorTerminationHealthErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVoiceConnectorTerminationHealthErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorTerminationHealthErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorTerminationHealthErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorTerminationHealthErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorTerminationHealthErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `GetVoiceConnectorTermination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorTerminationError {
    /// Kind of error that occurred.
    pub kind: GetVoiceConnectorTerminationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for GetVoiceConnectorTerminationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetVoiceConnectorTerminationErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `GetVoiceConnectorTermination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorTerminationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetVoiceConnectorTerminationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorTerminationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetVoiceConnectorTerminationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetVoiceConnectorTerminationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVoiceConnectorTerminationErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorTerminationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorTerminationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetVoiceConnectorTerminationError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorTerminationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorTerminationError {
    /// Creates a new `GetVoiceConnectorTerminationError`.
    pub fn new(kind: GetVoiceConnectorTerminationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetVoiceConnectorTerminationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceConnectorTerminationErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `GetVoiceConnectorTerminationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceConnectorTerminationErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorTerminationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetVoiceConnectorTerminationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorTerminationErrorKind::BadRequestException(_inner) => Some(_inner),
            GetVoiceConnectorTerminationErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetVoiceConnectorTerminationErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVoiceConnectorTerminationErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorTerminationErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorTerminationErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `GetVoiceConnectorStreamingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorStreamingConfigurationError {
    /// Kind of error that occurred.
    pub kind: GetVoiceConnectorStreamingConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError
    for GetVoiceConnectorStreamingConfigurationError
{
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetVoiceConnectorStreamingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `GetVoiceConnectorStreamingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorStreamingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetVoiceConnectorStreamingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            GetVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            GetVoiceConnectorStreamingConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetVoiceConnectorStreamingConfigurationError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorStreamingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorStreamingConfigurationError {
    /// Creates a new `GetVoiceConnectorStreamingConfigurationError`.
    pub fn new(
        kind: GetVoiceConnectorStreamingConfigurationErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetVoiceConnectorStreamingConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceConnectorStreamingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `GetVoiceConnectorStreamingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceConnectorStreamingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorStreamingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorStreamingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetVoiceConnectorStreamingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            GetVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            GetVoiceConnectorStreamingConfigurationErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `GetVoiceConnectorProxy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorProxyError {
    /// Kind of error that occurred.
    pub kind: GetVoiceConnectorProxyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for GetVoiceConnectorProxyError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetVoiceConnectorProxyErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `GetVoiceConnectorProxy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorProxyErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetVoiceConnectorProxyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorProxyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetVoiceConnectorProxyErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetVoiceConnectorProxyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVoiceConnectorProxyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetVoiceConnectorProxyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetVoiceConnectorProxyErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetVoiceConnectorProxyErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetVoiceConnectorProxyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetVoiceConnectorProxyError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorProxyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorProxyError {
    /// Creates a new `GetVoiceConnectorProxyError`.
    pub fn new(kind: GetVoiceConnectorProxyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetVoiceConnectorProxyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceConnectorProxyErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `GetVoiceConnectorProxyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceConnectorProxyErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorProxyErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorProxyErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorProxyErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorProxyErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorProxyErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorProxyErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorProxyErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorProxyErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorProxyErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorProxyErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorProxyErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorProxyErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorProxyErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorProxyErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetVoiceConnectorProxyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorProxyErrorKind::BadRequestException(_inner) => Some(_inner),
            GetVoiceConnectorProxyErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetVoiceConnectorProxyErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVoiceConnectorProxyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetVoiceConnectorProxyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetVoiceConnectorProxyErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetVoiceConnectorProxyErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetVoiceConnectorProxyErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `GetVoiceConnectorOrigination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorOriginationError {
    /// Kind of error that occurred.
    pub kind: GetVoiceConnectorOriginationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for GetVoiceConnectorOriginationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetVoiceConnectorOriginationErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `GetVoiceConnectorOrigination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorOriginationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetVoiceConnectorOriginationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorOriginationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetVoiceConnectorOriginationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetVoiceConnectorOriginationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVoiceConnectorOriginationErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorOriginationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorOriginationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetVoiceConnectorOriginationError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorOriginationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorOriginationError {
    /// Creates a new `GetVoiceConnectorOriginationError`.
    pub fn new(kind: GetVoiceConnectorOriginationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetVoiceConnectorOriginationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceConnectorOriginationErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `GetVoiceConnectorOriginationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceConnectorOriginationErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorOriginationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorOriginationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorOriginationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorOriginationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorOriginationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorOriginationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorOriginationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorOriginationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorOriginationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorOriginationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorOriginationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorOriginationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetVoiceConnectorOriginationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorOriginationErrorKind::BadRequestException(_inner) => Some(_inner),
            GetVoiceConnectorOriginationErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetVoiceConnectorOriginationErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVoiceConnectorOriginationErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorOriginationErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorOriginationErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `GetVoiceConnectorLoggingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorLoggingConfigurationError {
    /// Kind of error that occurred.
    pub kind: GetVoiceConnectorLoggingConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for GetVoiceConnectorLoggingConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetVoiceConnectorLoggingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `GetVoiceConnectorLoggingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorLoggingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetVoiceConnectorLoggingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorLoggingConfigurationErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetVoiceConnectorLoggingConfigurationError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorLoggingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorLoggingConfigurationError {
    /// Creates a new `GetVoiceConnectorLoggingConfigurationError`.
    pub fn new(
        kind: GetVoiceConnectorLoggingConfigurationErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetVoiceConnectorLoggingConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceConnectorLoggingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `GetVoiceConnectorLoggingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceConnectorLoggingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorLoggingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorLoggingConfigurationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorLoggingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorLoggingConfigurationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetVoiceConnectorLoggingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorLoggingConfigurationErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `GetVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorGroupError {
    /// Kind of error that occurred.
    pub kind: GetVoiceConnectorGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for GetVoiceConnectorGroupError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `GetVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorGroupErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetVoiceConnectorGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorGroupErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetVoiceConnectorGroupErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetVoiceConnectorGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetVoiceConnectorGroupError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorGroupError {
    /// Creates a new `GetVoiceConnectorGroupError`.
    pub fn new(kind: GetVoiceConnectorGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetVoiceConnectorGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `GetVoiceConnectorGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorGroupErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorGroupErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorGroupErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorGroupErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorGroupErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorGroupErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorGroupErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorGroupErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorGroupErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorGroupErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorGroupErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorGroupErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorGroupErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorGroupErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetVoiceConnectorGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorGroupErrorKind::BadRequestException(_inner) => Some(_inner),
            GetVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetVoiceConnectorGroupErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetVoiceConnectorGroupErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `GetVoiceConnectorEmergencyCallingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorEmergencyCallingConfigurationError {
    /// Kind of error that occurred.
    pub kind: GetVoiceConnectorEmergencyCallingConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError
    for GetVoiceConnectorEmergencyCallingConfigurationError
{
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `GetVoiceConnectorEmergencyCallingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorEmergencyCallingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetVoiceConnectorEmergencyCallingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for GetVoiceConnectorEmergencyCallingConfigurationError
{
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorEmergencyCallingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorEmergencyCallingConfigurationError {
    /// Creates a new `GetVoiceConnectorEmergencyCallingConfigurationError`.
    pub fn new(
        kind: GetVoiceConnectorEmergencyCallingConfigurationErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetVoiceConnectorEmergencyCallingConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `GetVoiceConnectorEmergencyCallingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetVoiceConnectorEmergencyCallingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorError {
    /// Kind of error that occurred.
    pub kind: GetVoiceConnectorErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for GetVoiceConnectorError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `GetVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetVoiceConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetVoiceConnectorErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetVoiceConnectorErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVoiceConnectorErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetVoiceConnectorErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetVoiceConnectorErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetVoiceConnectorErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetVoiceConnectorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetVoiceConnectorError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorError {
    /// Creates a new `GetVoiceConnectorError`.
    pub fn new(kind: GetVoiceConnectorErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetVoiceConnectorError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `GetVoiceConnectorError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `GetVoiceConnectorErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetVoiceConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorErrorKind::BadRequestException(_inner) => Some(_inner),
            GetVoiceConnectorErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetVoiceConnectorErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVoiceConnectorErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetVoiceConnectorErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetVoiceConnectorErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetVoiceConnectorErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetVoiceConnectorErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `GetSipRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSipRuleError {
    /// Kind of error that occurred.
    pub kind: GetSipRuleErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for GetSipRuleError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `GetSipRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSipRuleErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetSipRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSipRuleErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSipRuleErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetSipRuleErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSipRuleErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetSipRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetSipRuleErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetSipRuleErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetSipRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetSipRuleError {
    fn code(&self) -> Option<&str> {
        GetSipRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSipRuleError {
    /// Creates a new `GetSipRuleError`.
    pub fn new(kind: GetSipRuleErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetSipRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `GetSipRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetSipRuleErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetSipRuleErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetSipRuleErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetSipRuleErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetSipRuleErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSipRuleErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetSipRuleErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetSipRuleErrorKind::ServiceFailureException(_))
    }
    /// Returns `true` if the error kind is `GetSipRuleErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSipRuleErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetSipRuleErrorKind::ThrottledClientException(_))
    }
    /// Returns `true` if the error kind is `GetSipRuleErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipRuleErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetSipRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSipRuleErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSipRuleErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetSipRuleErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSipRuleErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetSipRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetSipRuleErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetSipRuleErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetSipRuleErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `GetSipMediaApplicationLoggingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSipMediaApplicationLoggingConfigurationError {
    /// Kind of error that occurred.
    pub kind: GetSipMediaApplicationLoggingConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError
    for GetSipMediaApplicationLoggingConfigurationError
{
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `GetSipMediaApplicationLoggingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSipMediaApplicationLoggingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetSipMediaApplicationLoggingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            GetSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            GetSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException(
                _inner,
            ) => _inner.fmt(f),
            GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            GetSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException(
                _inner,
            ) => _inner.fmt(f),
            GetSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            GetSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetSipMediaApplicationLoggingConfigurationError {
    fn code(&self) -> Option<&str> {
        GetSipMediaApplicationLoggingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSipMediaApplicationLoggingConfigurationError {
    /// Creates a new `GetSipMediaApplicationLoggingConfigurationError`.
    pub fn new(
        kind: GetSipMediaApplicationLoggingConfigurationErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetSipMediaApplicationLoggingConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `GetSipMediaApplicationLoggingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetSipMediaApplicationLoggingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            GetSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            GetSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException(
                _inner,
            ) => Some(_inner),
            GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            GetSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException(
                _inner,
            ) => Some(_inner),
            GetSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            GetSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `GetSipMediaApplicationAlexaSkillConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSipMediaApplicationAlexaSkillConfigurationError {
    /// Kind of error that occurred.
    pub kind: GetSipMediaApplicationAlexaSkillConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError
    for GetSipMediaApplicationAlexaSkillConfigurationError
{
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `GetSipMediaApplicationAlexaSkillConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSipMediaApplicationAlexaSkillConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetSipMediaApplicationAlexaSkillConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceFailureException(
                _inner,
            ) => _inner.fmt(f),
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ThrottledClientException(
                _inner,
            ) => _inner.fmt(f),
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for GetSipMediaApplicationAlexaSkillConfigurationError
{
    fn code(&self) -> Option<&str> {
        GetSipMediaApplicationAlexaSkillConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSipMediaApplicationAlexaSkillConfigurationError {
    /// Creates a new `GetSipMediaApplicationAlexaSkillConfigurationError`.
    pub fn new(
        kind: GetSipMediaApplicationAlexaSkillConfigurationErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetSipMediaApplicationAlexaSkillConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `GetSipMediaApplicationAlexaSkillConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationAlexaSkillConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationAlexaSkillConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationAlexaSkillConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetSipMediaApplicationAlexaSkillConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceFailureException(
                _inner,
            ) => Some(_inner),
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::ThrottledClientException(
                _inner,
            ) => Some(_inner),
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            GetSipMediaApplicationAlexaSkillConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetSipMediaApplication` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSipMediaApplicationError {
    /// Kind of error that occurred.
    pub kind: GetSipMediaApplicationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for GetSipMediaApplicationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `GetSipMediaApplication` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSipMediaApplicationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetSipMediaApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSipMediaApplicationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSipMediaApplicationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetSipMediaApplicationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSipMediaApplicationErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetSipMediaApplicationErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetSipMediaApplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetSipMediaApplicationError {
    fn code(&self) -> Option<&str> {
        GetSipMediaApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSipMediaApplicationError {
    /// Creates a new `GetSipMediaApplicationError`.
    pub fn new(kind: GetSipMediaApplicationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetSipMediaApplicationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `GetSipMediaApplicationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `GetSipMediaApplicationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetSipMediaApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSipMediaApplicationErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSipMediaApplicationErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetSipMediaApplicationErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSipMediaApplicationErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetSipMediaApplicationErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetSipMediaApplicationErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `GetProxySession` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetProxySessionError {
    /// Kind of error that occurred.
    pub kind: GetProxySessionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for GetProxySessionError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `GetProxySession` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetProxySessionErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetProxySessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetProxySessionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetProxySessionErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetProxySessionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetProxySessionErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetProxySessionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetProxySessionErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetProxySessionErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetProxySessionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetProxySessionError {
    fn code(&self) -> Option<&str> {
        GetProxySessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetProxySessionError {
    /// Creates a new `GetProxySessionError`.
    pub fn new(kind: GetProxySessionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetProxySessionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `GetProxySessionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetProxySessionErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetProxySessionErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetProxySessionErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetProxySessionErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetProxySessionErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetProxySessionErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetProxySessionErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetProxySessionErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetProxySessionErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetProxySessionErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetProxySessionErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetProxySessionErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `GetProxySessionErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetProxySessionErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetProxySessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetProxySessionErrorKind::BadRequestException(_inner) => Some(_inner),
            GetProxySessionErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetProxySessionErrorKind::NotFoundException(_inner) => Some(_inner),
            GetProxySessionErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetProxySessionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetProxySessionErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetProxySessionErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetProxySessionErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `GetPhoneNumberSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPhoneNumberSettingsError {
    /// Kind of error that occurred.
    pub kind: GetPhoneNumberSettingsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for GetPhoneNumberSettingsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetPhoneNumberSettingsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `GetPhoneNumberSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPhoneNumberSettingsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetPhoneNumberSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPhoneNumberSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetPhoneNumberSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetPhoneNumberSettingsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetPhoneNumberSettingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetPhoneNumberSettingsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetPhoneNumberSettingsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetPhoneNumberSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPhoneNumberSettingsError {
    fn code(&self) -> Option<&str> {
        GetPhoneNumberSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPhoneNumberSettingsError {
    /// Creates a new `GetPhoneNumberSettingsError`.
    pub fn new(kind: GetPhoneNumberSettingsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetPhoneNumberSettingsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPhoneNumberSettingsErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `GetPhoneNumberSettingsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPhoneNumberSettingsErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetPhoneNumberSettingsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberSettingsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPhoneNumberSettingsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberSettingsErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPhoneNumberSettingsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberSettingsErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPhoneNumberSettingsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPhoneNumberSettingsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberSettingsErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPhoneNumberSettingsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberSettingsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetPhoneNumberSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPhoneNumberSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetPhoneNumberSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetPhoneNumberSettingsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetPhoneNumberSettingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetPhoneNumberSettingsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetPhoneNumberSettingsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetPhoneNumberSettingsErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `GetPhoneNumberOrder` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPhoneNumberOrderError {
    /// Kind of error that occurred.
    pub kind: GetPhoneNumberOrderErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for GetPhoneNumberOrderError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetPhoneNumberOrderErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `GetPhoneNumberOrder` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPhoneNumberOrderErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetPhoneNumberOrderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPhoneNumberOrderErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetPhoneNumberOrderErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetPhoneNumberOrderErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetPhoneNumberOrderErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetPhoneNumberOrderErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetPhoneNumberOrderErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetPhoneNumberOrderErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetPhoneNumberOrderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPhoneNumberOrderError {
    fn code(&self) -> Option<&str> {
        GetPhoneNumberOrderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPhoneNumberOrderError {
    /// Creates a new `GetPhoneNumberOrderError`.
    pub fn new(kind: GetPhoneNumberOrderErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetPhoneNumberOrderError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPhoneNumberOrderErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `GetPhoneNumberOrderError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPhoneNumberOrderErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetPhoneNumberOrderErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberOrderErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPhoneNumberOrderErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberOrderErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPhoneNumberOrderErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberOrderErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPhoneNumberOrderErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberOrderErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPhoneNumberOrderErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberOrderErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPhoneNumberOrderErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberOrderErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPhoneNumberOrderErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberOrderErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetPhoneNumberOrderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPhoneNumberOrderErrorKind::BadRequestException(_inner) => Some(_inner),
            GetPhoneNumberOrderErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetPhoneNumberOrderErrorKind::NotFoundException(_inner) => Some(_inner),
            GetPhoneNumberOrderErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetPhoneNumberOrderErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetPhoneNumberOrderErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetPhoneNumberOrderErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetPhoneNumberOrderErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `GetPhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPhoneNumberError {
    /// Kind of error that occurred.
    pub kind: GetPhoneNumberErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for GetPhoneNumberError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetPhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `GetPhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPhoneNumberErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetPhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPhoneNumberErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetPhoneNumberErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetPhoneNumberErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetPhoneNumberErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetPhoneNumberErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetPhoneNumberErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetPhoneNumberErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetPhoneNumberErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPhoneNumberError {
    fn code(&self) -> Option<&str> {
        GetPhoneNumberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPhoneNumberError {
    /// Creates a new `GetPhoneNumberError`.
    pub fn new(kind: GetPhoneNumberErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetPhoneNumberError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `GetPhoneNumberError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetPhoneNumberErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetPhoneNumberErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPhoneNumberErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPhoneNumberErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPhoneNumberErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetPhoneNumberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPhoneNumberErrorKind::BadRequestException(_inner) => Some(_inner),
            GetPhoneNumberErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetPhoneNumberErrorKind::NotFoundException(_inner) => Some(_inner),
            GetPhoneNumberErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetPhoneNumberErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetPhoneNumberErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetPhoneNumberErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetPhoneNumberErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `GetGlobalSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGlobalSettingsError {
    /// Kind of error that occurred.
    pub kind: GetGlobalSettingsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for GetGlobalSettingsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetGlobalSettingsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `GetGlobalSettings` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGlobalSettingsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetGlobalSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetGlobalSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetGlobalSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetGlobalSettingsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetGlobalSettingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetGlobalSettingsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetGlobalSettingsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetGlobalSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetGlobalSettingsError {
    fn code(&self) -> Option<&str> {
        GetGlobalSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetGlobalSettingsError {
    /// Creates a new `GetGlobalSettingsError`.
    pub fn new(kind: GetGlobalSettingsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetGlobalSettingsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetGlobalSettingsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `GetGlobalSettingsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetGlobalSettingsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetGlobalSettingsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGlobalSettingsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetGlobalSettingsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGlobalSettingsErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetGlobalSettingsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGlobalSettingsErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `GetGlobalSettingsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGlobalSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetGlobalSettingsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGlobalSettingsErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `GetGlobalSettingsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGlobalSettingsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetGlobalSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetGlobalSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetGlobalSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetGlobalSettingsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetGlobalSettingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetGlobalSettingsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetGlobalSettingsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetGlobalSettingsErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `DisassociatePhoneNumbersFromVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociatePhoneNumbersFromVoiceConnectorGroupError {
    /// Kind of error that occurred.
    pub kind: DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError
    for DisassociatePhoneNumbersFromVoiceConnectorGroupError
{
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `DisassociatePhoneNumbersFromVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DisassociatePhoneNumbersFromVoiceConnectorGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for DisassociatePhoneNumbersFromVoiceConnectorGroupError
{
    fn code(&self) -> Option<&str> {
        DisassociatePhoneNumbersFromVoiceConnectorGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociatePhoneNumbersFromVoiceConnectorGroupError {
    /// Creates a new `DisassociatePhoneNumbersFromVoiceConnectorGroupError`.
    pub fn new(
        kind: DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DisassociatePhoneNumbersFromVoiceConnectorGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `DisassociatePhoneNumbersFromVoiceConnectorGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceUnavailableException(
                _
            )
        )
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::UnauthorizedClientException(
                _
            )
        )
    }
}
impl std::error::Error for DisassociatePhoneNumbersFromVoiceConnectorGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DisassociatePhoneNumbersFromVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociatePhoneNumbersFromVoiceConnectorError {
    /// Kind of error that occurred.
    pub kind: DisassociatePhoneNumbersFromVoiceConnectorErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError
    for DisassociatePhoneNumbersFromVoiceConnectorError
{
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DisassociatePhoneNumbersFromVoiceConnectorErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `DisassociatePhoneNumbersFromVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociatePhoneNumbersFromVoiceConnectorErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DisassociatePhoneNumbersFromVoiceConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceFailureException(
                _inner,
            ) => _inner.fmt(f),
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ThrottledClientException(
                _inner,
            ) => _inner.fmt(f),
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DisassociatePhoneNumbersFromVoiceConnectorError {
    fn code(&self) -> Option<&str> {
        DisassociatePhoneNumbersFromVoiceConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociatePhoneNumbersFromVoiceConnectorError {
    /// Creates a new `DisassociatePhoneNumbersFromVoiceConnectorError`.
    pub fn new(
        kind: DisassociatePhoneNumbersFromVoiceConnectorErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DisassociatePhoneNumbersFromVoiceConnectorError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociatePhoneNumbersFromVoiceConnectorErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `DisassociatePhoneNumbersFromVoiceConnectorError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociatePhoneNumbersFromVoiceConnectorErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `DisassociatePhoneNumbersFromVoiceConnectorErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DisassociatePhoneNumbersFromVoiceConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceFailureException(
                _inner,
            ) => Some(_inner),
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ThrottledClientException(
                _inner,
            ) => Some(_inner),
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `DeleteVoiceConnectorTerminationCredentials` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorTerminationCredentialsError {
    /// Kind of error that occurred.
    pub kind: DeleteVoiceConnectorTerminationCredentialsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError
    for DeleteVoiceConnectorTerminationCredentialsError
{
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteVoiceConnectorTerminationCredentialsErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `DeleteVoiceConnectorTerminationCredentials` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorTerminationCredentialsErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteVoiceConnectorTerminationCredentialsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(
                _inner,
            ) => _inner.fmt(f),
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(
                _inner,
            ) => _inner.fmt(f),
            DeleteVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            DeleteVoiceConnectorTerminationCredentialsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorTerminationCredentialsError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorTerminationCredentialsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorTerminationCredentialsError {
    /// Creates a new `DeleteVoiceConnectorTerminationCredentialsError`.
    pub fn new(
        kind: DeleteVoiceConnectorTerminationCredentialsErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteVoiceConnectorTerminationCredentialsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVoiceConnectorTerminationCredentialsErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteVoiceConnectorTerminationCredentialsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVoiceConnectorTerminationCredentialsErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationCredentialsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationCredentialsErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteVoiceConnectorTerminationCredentialsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(
                _inner,
            ) => Some(_inner),
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(
                _inner,
            ) => Some(_inner),
            DeleteVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            DeleteVoiceConnectorTerminationCredentialsErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `DeleteVoiceConnectorTermination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorTerminationError {
    /// Kind of error that occurred.
    pub kind: DeleteVoiceConnectorTerminationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteVoiceConnectorTerminationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteVoiceConnectorTerminationErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `DeleteVoiceConnectorTermination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorTerminationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteVoiceConnectorTerminationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorTerminationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorTerminationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorTerminationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorTerminationErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorTerminationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorTerminationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorTerminationError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorTerminationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorTerminationError {
    /// Creates a new `DeleteVoiceConnectorTerminationError`.
    pub fn new(
        kind: DeleteVoiceConnectorTerminationErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteVoiceConnectorTerminationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVoiceConnectorTerminationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteVoiceConnectorTerminationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVoiceConnectorTerminationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorTerminationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteVoiceConnectorTerminationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorTerminationErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVoiceConnectorTerminationErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteVoiceConnectorTerminationErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVoiceConnectorTerminationErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorTerminationErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorTerminationErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `DeleteVoiceConnectorStreamingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorStreamingConfigurationError {
    /// Kind of error that occurred.
    pub kind: DeleteVoiceConnectorStreamingConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError
    for DeleteVoiceConnectorStreamingConfigurationError
{
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteVoiceConnectorStreamingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `DeleteVoiceConnectorStreamingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorStreamingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteVoiceConnectorStreamingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(
                _inner,
            ) => _inner.fmt(f),
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(
                _inner,
            ) => _inner.fmt(f),
            DeleteVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            DeleteVoiceConnectorStreamingConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorStreamingConfigurationError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorStreamingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorStreamingConfigurationError {
    /// Creates a new `DeleteVoiceConnectorStreamingConfigurationError`.
    pub fn new(
        kind: DeleteVoiceConnectorStreamingConfigurationErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteVoiceConnectorStreamingConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVoiceConnectorStreamingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteVoiceConnectorStreamingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVoiceConnectorStreamingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorStreamingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorStreamingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteVoiceConnectorStreamingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(
                _inner,
            ) => Some(_inner),
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(
                _inner,
            ) => Some(_inner),
            DeleteVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            DeleteVoiceConnectorStreamingConfigurationErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `DeleteVoiceConnectorProxy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorProxyError {
    /// Kind of error that occurred.
    pub kind: DeleteVoiceConnectorProxyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteVoiceConnectorProxyError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteVoiceConnectorProxyErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `DeleteVoiceConnectorProxy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorProxyErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteVoiceConnectorProxyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorProxyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorProxyErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorProxyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorProxyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorProxyErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorProxyErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorProxyErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorProxyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorProxyError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorProxyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorProxyError {
    /// Creates a new `DeleteVoiceConnectorProxyError`.
    pub fn new(kind: DeleteVoiceConnectorProxyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteVoiceConnectorProxyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVoiceConnectorProxyErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteVoiceConnectorProxyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVoiceConnectorProxyErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorProxyErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorProxyErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorProxyErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorProxyErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorProxyErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorProxyErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorProxyErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorProxyErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorProxyErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorProxyErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorProxyErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorProxyErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorProxyErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorProxyErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteVoiceConnectorProxyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorProxyErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVoiceConnectorProxyErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteVoiceConnectorProxyErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVoiceConnectorProxyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteVoiceConnectorProxyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteVoiceConnectorProxyErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteVoiceConnectorProxyErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteVoiceConnectorProxyErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `DeleteVoiceConnectorOrigination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorOriginationError {
    /// Kind of error that occurred.
    pub kind: DeleteVoiceConnectorOriginationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteVoiceConnectorOriginationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteVoiceConnectorOriginationErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `DeleteVoiceConnectorOrigination` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorOriginationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteVoiceConnectorOriginationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorOriginationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorOriginationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorOriginationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorOriginationErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorOriginationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorOriginationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorOriginationError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorOriginationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorOriginationError {
    /// Creates a new `DeleteVoiceConnectorOriginationError`.
    pub fn new(
        kind: DeleteVoiceConnectorOriginationErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteVoiceConnectorOriginationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVoiceConnectorOriginationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteVoiceConnectorOriginationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVoiceConnectorOriginationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorOriginationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorOriginationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorOriginationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorOriginationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorOriginationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorOriginationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorOriginationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorOriginationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorOriginationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorOriginationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorOriginationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorOriginationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteVoiceConnectorOriginationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorOriginationErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVoiceConnectorOriginationErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteVoiceConnectorOriginationErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVoiceConnectorOriginationErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorOriginationErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorOriginationErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `DeleteVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorGroupError {
    /// Kind of error that occurred.
    pub kind: DeleteVoiceConnectorGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteVoiceConnectorGroupError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `DeleteVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorGroupErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteVoiceConnectorGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorGroupErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorGroupErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorGroupErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorGroupError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorGroupError {
    /// Creates a new `DeleteVoiceConnectorGroupError`.
    pub fn new(kind: DeleteVoiceConnectorGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteVoiceConnectorGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteVoiceConnectorGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorGroupErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorGroupErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorGroupErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorGroupErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorGroupErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorGroupErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorGroupErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorGroupErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorGroupErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorGroupErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorGroupErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorGroupErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorGroupErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorGroupErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorGroupErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorGroupErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteVoiceConnectorGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorGroupErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVoiceConnectorGroupErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteVoiceConnectorGroupErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteVoiceConnectorGroupErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `DeleteVoiceConnectorEmergencyCallingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorEmergencyCallingConfigurationError {
    /// Kind of error that occurred.
    pub kind: DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError
    for DeleteVoiceConnectorEmergencyCallingConfigurationError
{
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `DeleteVoiceConnectorEmergencyCallingConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteVoiceConnectorEmergencyCallingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for DeleteVoiceConnectorEmergencyCallingConfigurationError
{
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorEmergencyCallingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorEmergencyCallingConfigurationError {
    /// Creates a new `DeleteVoiceConnectorEmergencyCallingConfigurationError`.
    pub fn new(
        kind: DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteVoiceConnectorEmergencyCallingConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteVoiceConnectorEmergencyCallingConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(
                _
            )
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(
                _
            )
        )
    }
}
impl std::error::Error for DeleteVoiceConnectorEmergencyCallingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `DeleteVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorError {
    /// Kind of error that occurred.
    pub kind: DeleteVoiceConnectorErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteVoiceConnectorError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `DeleteVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteVoiceConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorError {
    /// Creates a new `DeleteVoiceConnectorError`.
    pub fn new(kind: DeleteVoiceConnectorErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteVoiceConnectorError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteVoiceConnectorError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteVoiceConnectorErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteVoiceConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVoiceConnectorErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteVoiceConnectorErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteVoiceConnectorErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVoiceConnectorErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteVoiceConnectorErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteVoiceConnectorErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteVoiceConnectorErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteVoiceConnectorErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `DeleteSipRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSipRuleError {
    /// Kind of error that occurred.
    pub kind: DeleteSipRuleErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteSipRuleError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `DeleteSipRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSipRuleErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteSipRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSipRuleErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteSipRuleErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteSipRuleErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteSipRuleErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteSipRuleErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteSipRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteSipRuleErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteSipRuleErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteSipRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteSipRuleError {
    fn code(&self) -> Option<&str> {
        DeleteSipRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSipRuleError {
    /// Creates a new `DeleteSipRuleError`.
    pub fn new(kind: DeleteSipRuleErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteSipRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteSipRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteSipRuleErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipRuleErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `DeleteSipRuleErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipRuleErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DeleteSipRuleErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipRuleErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `DeleteSipRuleErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipRuleErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteSipRuleErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipRuleErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteSipRuleErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteSipRuleErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipRuleErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteSipRuleErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipRuleErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteSipRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSipRuleErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteSipRuleErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteSipRuleErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteSipRuleErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteSipRuleErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteSipRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteSipRuleErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteSipRuleErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteSipRuleErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `DeleteSipMediaApplication` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSipMediaApplicationError {
    /// Kind of error that occurred.
    pub kind: DeleteSipMediaApplicationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteSipMediaApplicationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `DeleteSipMediaApplication` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSipMediaApplicationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteSipMediaApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSipMediaApplicationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteSipMediaApplicationErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteSipMediaApplicationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteSipMediaApplicationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteSipMediaApplicationErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteSipMediaApplicationErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            DeleteSipMediaApplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteSipMediaApplicationError {
    fn code(&self) -> Option<&str> {
        DeleteSipMediaApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSipMediaApplicationError {
    /// Creates a new `DeleteSipMediaApplicationError`.
    pub fn new(kind: DeleteSipMediaApplicationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteSipMediaApplicationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteSipMediaApplicationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteSipMediaApplicationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipMediaApplicationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteSipMediaApplicationErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipMediaApplicationErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteSipMediaApplicationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipMediaApplicationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteSipMediaApplicationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipMediaApplicationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteSipMediaApplicationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipMediaApplicationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteSipMediaApplicationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipMediaApplicationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteSipMediaApplicationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipMediaApplicationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteSipMediaApplicationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipMediaApplicationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteSipMediaApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSipMediaApplicationErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteSipMediaApplicationErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteSipMediaApplicationErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteSipMediaApplicationErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteSipMediaApplicationErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteSipMediaApplicationErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteSipMediaApplicationErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `DeleteProxySession` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteProxySessionError {
    /// Kind of error that occurred.
    pub kind: DeleteProxySessionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteProxySessionError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeleteProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `DeleteProxySession` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteProxySessionErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeleteProxySessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteProxySessionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteProxySessionErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteProxySessionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteProxySessionErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteProxySessionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteProxySessionErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteProxySessionErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteProxySessionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteProxySessionError {
    fn code(&self) -> Option<&str> {
        DeleteProxySessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteProxySessionError {
    /// Creates a new `DeleteProxySessionError`.
    pub fn new(kind: DeleteProxySessionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteProxySessionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteProxySessionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteProxySessionErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProxySessionErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProxySessionErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProxySessionErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProxySessionErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProxySessionErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProxySessionErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProxySessionErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProxySessionErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProxySessionErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProxySessionErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProxySessionErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteProxySessionErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProxySessionErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteProxySessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteProxySessionErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteProxySessionErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteProxySessionErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteProxySessionErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteProxySessionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteProxySessionErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteProxySessionErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteProxySessionErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `DeletePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePhoneNumberError {
    /// Kind of error that occurred.
    pub kind: DeletePhoneNumberErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for DeletePhoneNumberError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: DeletePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `DeletePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePhoneNumberErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for DeletePhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePhoneNumberErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeletePhoneNumberErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeletePhoneNumberErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeletePhoneNumberErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeletePhoneNumberErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeletePhoneNumberErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeletePhoneNumberErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeletePhoneNumberErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeletePhoneNumberError {
    fn code(&self) -> Option<&str> {
        DeletePhoneNumberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePhoneNumberError {
    /// Creates a new `DeletePhoneNumberError`.
    pub fn new(kind: DeletePhoneNumberErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeletePhoneNumberError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `DeletePhoneNumberError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeletePhoneNumberErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePhoneNumberErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePhoneNumberErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePhoneNumberErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePhoneNumberErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeletePhoneNumberErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeletePhoneNumberErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePhoneNumberErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePhoneNumberErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePhoneNumberErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePhoneNumberErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePhoneNumberErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePhoneNumberErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePhoneNumberErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeletePhoneNumberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePhoneNumberErrorKind::BadRequestException(_inner) => Some(_inner),
            DeletePhoneNumberErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeletePhoneNumberErrorKind::NotFoundException(_inner) => Some(_inner),
            DeletePhoneNumberErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeletePhoneNumberErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeletePhoneNumberErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeletePhoneNumberErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeletePhoneNumberErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `CreateVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVoiceConnectorGroupError {
    /// Kind of error that occurred.
    pub kind: CreateVoiceConnectorGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for CreateVoiceConnectorGroupError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `CreateVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVoiceConnectorGroupErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateVoiceConnectorGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVoiceConnectorGroupErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorGroupErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorGroupErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreateVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            CreateVoiceConnectorGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateVoiceConnectorGroupError {
    fn code(&self) -> Option<&str> {
        CreateVoiceConnectorGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateVoiceConnectorGroupError {
    /// Creates a new `CreateVoiceConnectorGroupError`.
    pub fn new(kind: CreateVoiceConnectorGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateVoiceConnectorGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateVoiceConnectorGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateVoiceConnectorGroupErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorGroupErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorGroupErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorGroupErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorGroupErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorGroupErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorGroupErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorGroupErrorKind::ResourceLimitExceededException`.
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorGroupErrorKind::ResourceLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorGroupErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorGroupErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorGroupErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorGroupErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorGroupErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorGroupErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorGroupErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorGroupErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateVoiceConnectorGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVoiceConnectorGroupErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateVoiceConnectorGroupErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateVoiceConnectorGroupErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateVoiceConnectorGroupErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `CreateVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVoiceConnectorError {
    /// Kind of error that occurred.
    pub kind: CreateVoiceConnectorErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for CreateVoiceConnectorError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `CreateVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVoiceConnectorErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateVoiceConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVoiceConnectorErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateVoiceConnectorError {
    fn code(&self) -> Option<&str> {
        CreateVoiceConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateVoiceConnectorError {
    /// Creates a new `CreateVoiceConnectorError`.
    pub fn new(kind: CreateVoiceConnectorErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateVoiceConnectorError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateVoiceConnectorError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateVoiceConnectorErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorErrorKind::ResourceLimitExceededException`.
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorErrorKind::ResourceLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateVoiceConnectorErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateVoiceConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVoiceConnectorErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateVoiceConnectorErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateVoiceConnectorErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateVoiceConnectorErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateVoiceConnectorErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateVoiceConnectorErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateVoiceConnectorErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateVoiceConnectorErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateVoiceConnectorErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `CreateSipRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSipRuleError {
    /// Kind of error that occurred.
    pub kind: CreateSipRuleErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for CreateSipRuleError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `CreateSipRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSipRuleErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateSipRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSipRuleErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateSipRuleErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateSipRuleErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateSipRuleErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateSipRuleErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateSipRuleErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateSipRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateSipRuleErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateSipRuleErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateSipRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateSipRuleError {
    fn code(&self) -> Option<&str> {
        CreateSipRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSipRuleError {
    /// Creates a new `CreateSipRuleError`.
    pub fn new(kind: CreateSipRuleErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateSipRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateSipRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSipRuleErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateSipRuleErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateSipRuleErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateSipRuleErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateSipRuleErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateSipRuleErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateSipRuleErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateSipRuleErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateSipRuleErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `CreateSipRuleErrorKind::ResourceLimitExceededException`.
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipRuleErrorKind::ResourceLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSipRuleErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipRuleErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSipRuleErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSipRuleErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipRuleErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSipRuleErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipRuleErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateSipRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSipRuleErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateSipRuleErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateSipRuleErrorKind::ConflictException(_inner) => Some(_inner),
            CreateSipRuleErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateSipRuleErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateSipRuleErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateSipRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateSipRuleErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateSipRuleErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateSipRuleErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `CreateSipMediaApplicationCall` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSipMediaApplicationCallError {
    /// Kind of error that occurred.
    pub kind: CreateSipMediaApplicationCallErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for CreateSipMediaApplicationCallError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateSipMediaApplicationCallErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `CreateSipMediaApplicationCall` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSipMediaApplicationCallErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateSipMediaApplicationCallError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSipMediaApplicationCallErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateSipMediaApplicationCallErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateSipMediaApplicationCallErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateSipMediaApplicationCallErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateSipMediaApplicationCallErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            CreateSipMediaApplicationCallErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreateSipMediaApplicationCallErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            CreateSipMediaApplicationCallErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            CreateSipMediaApplicationCallErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateSipMediaApplicationCallError {
    fn code(&self) -> Option<&str> {
        CreateSipMediaApplicationCallError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSipMediaApplicationCallError {
    /// Creates a new `CreateSipMediaApplicationCallError`.
    pub fn new(
        kind: CreateSipMediaApplicationCallErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateSipMediaApplicationCallError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSipMediaApplicationCallErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateSipMediaApplicationCallError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSipMediaApplicationCallErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationCallErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationCallErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationCallErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationCallErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationCallErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationCallErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationCallErrorKind::ResourceLimitExceededException`.
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationCallErrorKind::ResourceLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationCallErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationCallErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationCallErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationCallErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationCallErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationCallErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationCallErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationCallErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateSipMediaApplicationCallError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSipMediaApplicationCallErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateSipMediaApplicationCallErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateSipMediaApplicationCallErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateSipMediaApplicationCallErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateSipMediaApplicationCallErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateSipMediaApplicationCallErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            CreateSipMediaApplicationCallErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            CreateSipMediaApplicationCallErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            CreateSipMediaApplicationCallErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `CreateSipMediaApplication` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSipMediaApplicationError {
    /// Kind of error that occurred.
    pub kind: CreateSipMediaApplicationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for CreateSipMediaApplicationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(
                source,
            )),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `CreateSipMediaApplication` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSipMediaApplicationErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ConflictException(crate::error::ConflictException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateSipMediaApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSipMediaApplicationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateSipMediaApplicationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateSipMediaApplicationErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateSipMediaApplicationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateSipMediaApplicationErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateSipMediaApplicationErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreateSipMediaApplicationErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            CreateSipMediaApplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateSipMediaApplicationError {
    fn code(&self) -> Option<&str> {
        CreateSipMediaApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSipMediaApplicationError {
    /// Creates a new `CreateSipMediaApplicationError`.
    pub fn new(kind: CreateSipMediaApplicationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateSipMediaApplicationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateSipMediaApplicationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSipMediaApplicationErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationErrorKind::ResourceLimitExceededException`.
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationErrorKind::ResourceLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateSipMediaApplicationErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateSipMediaApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSipMediaApplicationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateSipMediaApplicationErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateSipMediaApplicationErrorKind::ConflictException(_inner) => Some(_inner),
            CreateSipMediaApplicationErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateSipMediaApplicationErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateSipMediaApplicationErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateSipMediaApplicationErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateSipMediaApplicationErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `CreateProxySession` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateProxySessionError {
    /// Kind of error that occurred.
    pub kind: CreateProxySessionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for CreateProxySessionError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `CreateProxySession` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateProxySessionErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateProxySessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateProxySessionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateProxySessionErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateProxySessionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateProxySessionErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateProxySessionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateProxySessionErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateProxySessionErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateProxySessionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateProxySessionError {
    fn code(&self) -> Option<&str> {
        CreateProxySessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateProxySessionError {
    /// Creates a new `CreateProxySessionError`.
    pub fn new(kind: CreateProxySessionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateProxySessionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateProxySessionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateProxySessionErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateProxySessionErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProxySessionErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProxySessionErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProxySessionErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProxySessionErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProxySessionErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProxySessionErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProxySessionErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProxySessionErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProxySessionErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProxySessionErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProxySessionErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateProxySessionErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProxySessionErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateProxySessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateProxySessionErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateProxySessionErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateProxySessionErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateProxySessionErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateProxySessionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateProxySessionErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateProxySessionErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateProxySessionErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `CreatePhoneNumberOrder` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePhoneNumberOrderError {
    /// Kind of error that occurred.
    pub kind: CreatePhoneNumberOrderErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for CreatePhoneNumberOrderError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreatePhoneNumberOrderErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `CreatePhoneNumberOrder` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePhoneNumberOrderErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreatePhoneNumberOrderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePhoneNumberOrderErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreatePhoneNumberOrderErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreatePhoneNumberOrderErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreatePhoneNumberOrderErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreatePhoneNumberOrderErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreatePhoneNumberOrderErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreatePhoneNumberOrderErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreatePhoneNumberOrderErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreatePhoneNumberOrderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreatePhoneNumberOrderError {
    fn code(&self) -> Option<&str> {
        CreatePhoneNumberOrderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePhoneNumberOrderError {
    /// Creates a new `CreatePhoneNumberOrderError`.
    pub fn new(kind: CreatePhoneNumberOrderErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreatePhoneNumberOrderError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePhoneNumberOrderErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `CreatePhoneNumberOrderError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePhoneNumberOrderErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreatePhoneNumberOrderErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePhoneNumberOrderErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePhoneNumberOrderErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePhoneNumberOrderErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePhoneNumberOrderErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePhoneNumberOrderErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePhoneNumberOrderErrorKind::ResourceLimitExceededException`.
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePhoneNumberOrderErrorKind::ResourceLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePhoneNumberOrderErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePhoneNumberOrderErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePhoneNumberOrderErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePhoneNumberOrderErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePhoneNumberOrderErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePhoneNumberOrderErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePhoneNumberOrderErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePhoneNumberOrderErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreatePhoneNumberOrderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePhoneNumberOrderErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreatePhoneNumberOrderErrorKind::BadRequestException(_inner) => Some(_inner),
            CreatePhoneNumberOrderErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreatePhoneNumberOrderErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreatePhoneNumberOrderErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreatePhoneNumberOrderErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreatePhoneNumberOrderErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreatePhoneNumberOrderErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreatePhoneNumberOrderErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `BatchUpdatePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchUpdatePhoneNumberError {
    /// Kind of error that occurred.
    pub kind: BatchUpdatePhoneNumberErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for BatchUpdatePhoneNumberError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: BatchUpdatePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `BatchUpdatePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchUpdatePhoneNumberErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for BatchUpdatePhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchUpdatePhoneNumberErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            BatchUpdatePhoneNumberErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            BatchUpdatePhoneNumberErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            BatchUpdatePhoneNumberErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            BatchUpdatePhoneNumberErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            BatchUpdatePhoneNumberErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            BatchUpdatePhoneNumberErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            BatchUpdatePhoneNumberErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchUpdatePhoneNumberError {
    fn code(&self) -> Option<&str> {
        BatchUpdatePhoneNumberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchUpdatePhoneNumberError {
    /// Creates a new `BatchUpdatePhoneNumberError`.
    pub fn new(kind: BatchUpdatePhoneNumberErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `BatchUpdatePhoneNumberError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchUpdatePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `BatchUpdatePhoneNumberError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchUpdatePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `BatchUpdatePhoneNumberErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdatePhoneNumberErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchUpdatePhoneNumberErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdatePhoneNumberErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchUpdatePhoneNumberErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdatePhoneNumberErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchUpdatePhoneNumberErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdatePhoneNumberErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchUpdatePhoneNumberErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdatePhoneNumberErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchUpdatePhoneNumberErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdatePhoneNumberErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchUpdatePhoneNumberErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdatePhoneNumberErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for BatchUpdatePhoneNumberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchUpdatePhoneNumberErrorKind::BadRequestException(_inner) => Some(_inner),
            BatchUpdatePhoneNumberErrorKind::ForbiddenException(_inner) => Some(_inner),
            BatchUpdatePhoneNumberErrorKind::NotFoundException(_inner) => Some(_inner),
            BatchUpdatePhoneNumberErrorKind::ServiceFailureException(_inner) => Some(_inner),
            BatchUpdatePhoneNumberErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            BatchUpdatePhoneNumberErrorKind::ThrottledClientException(_inner) => Some(_inner),
            BatchUpdatePhoneNumberErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            BatchUpdatePhoneNumberErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `BatchDeletePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDeletePhoneNumberError {
    /// Kind of error that occurred.
    pub kind: BatchDeletePhoneNumberErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError for BatchDeletePhoneNumberError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: BatchDeletePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `BatchDeletePhoneNumber` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDeletePhoneNumberErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for BatchDeletePhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDeletePhoneNumberErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            BatchDeletePhoneNumberErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            BatchDeletePhoneNumberErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            BatchDeletePhoneNumberErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            BatchDeletePhoneNumberErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            BatchDeletePhoneNumberErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            BatchDeletePhoneNumberErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            BatchDeletePhoneNumberErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchDeletePhoneNumberError {
    fn code(&self) -> Option<&str> {
        BatchDeletePhoneNumberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDeletePhoneNumberError {
    /// Creates a new `BatchDeletePhoneNumberError`.
    pub fn new(kind: BatchDeletePhoneNumberErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `BatchDeletePhoneNumberError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchDeletePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
            meta: Default::default(),
        }
    }

    /// Creates the `BatchDeletePhoneNumberError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchDeletePhoneNumberErrorKind::Unhandled(crate::error::Unhandled::new(
                err.into(),
            )),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `BatchDeletePhoneNumberErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeletePhoneNumberErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDeletePhoneNumberErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeletePhoneNumberErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDeletePhoneNumberErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeletePhoneNumberErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDeletePhoneNumberErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeletePhoneNumberErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDeletePhoneNumberErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeletePhoneNumberErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDeletePhoneNumberErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeletePhoneNumberErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDeletePhoneNumberErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeletePhoneNumberErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for BatchDeletePhoneNumberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDeletePhoneNumberErrorKind::BadRequestException(_inner) => Some(_inner),
            BatchDeletePhoneNumberErrorKind::ForbiddenException(_inner) => Some(_inner),
            BatchDeletePhoneNumberErrorKind::NotFoundException(_inner) => Some(_inner),
            BatchDeletePhoneNumberErrorKind::ServiceFailureException(_inner) => Some(_inner),
            BatchDeletePhoneNumberErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            BatchDeletePhoneNumberErrorKind::ThrottledClientException(_inner) => Some(_inner),
            BatchDeletePhoneNumberErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            BatchDeletePhoneNumberErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Error type for the `AssociatePhoneNumbersWithVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociatePhoneNumbersWithVoiceConnectorGroupError {
    /// Kind of error that occurred.
    pub kind: AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError
    for AssociatePhoneNumbersWithVoiceConnectorGroupError
{
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `AssociatePhoneNumbersWithVoiceConnectorGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for AssociatePhoneNumbersWithVoiceConnectorGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::AccessDeniedException(
                _inner,
            ) => _inner.fmt(f),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceFailureException(
                _inner,
            ) => _inner.fmt(f),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ThrottledClientException(
                _inner,
            ) => _inner.fmt(f),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for AssociatePhoneNumbersWithVoiceConnectorGroupError
{
    fn code(&self) -> Option<&str> {
        AssociatePhoneNumbersWithVoiceConnectorGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociatePhoneNumbersWithVoiceConnectorGroupError {
    /// Creates a new `AssociatePhoneNumbersWithVoiceConnectorGroupError`.
    pub fn new(
        kind: AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `AssociatePhoneNumbersWithVoiceConnectorGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `AssociatePhoneNumbersWithVoiceConnectorGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for AssociatePhoneNumbersWithVoiceConnectorGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::AccessDeniedException(
                _inner,
            ) => Some(_inner),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceFailureException(
                _inner,
            ) => Some(_inner),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ThrottledClientException(
                _inner,
            ) => Some(_inner),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `AssociatePhoneNumbersWithVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociatePhoneNumbersWithVoiceConnectorError {
    /// Kind of error that occurred.
    pub kind: AssociatePhoneNumbersWithVoiceConnectorErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
impl aws_smithy_http::result::CreateUnhandledError
    for AssociatePhoneNumbersWithVoiceConnectorError
{
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: AssociatePhoneNumbersWithVoiceConnectorErrorKind::Unhandled(
                crate::error::Unhandled::new(source),
            ),
            meta: Default::default(),
        }
    }
}
/// Types of errors that can occur for the `AssociatePhoneNumbersWithVoiceConnector` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociatePhoneNumbersWithVoiceConnectorErrorKind {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    #[allow(missing_docs)] // documentation missing in model
    BadRequestException(crate::error::BadRequestException),
    #[allow(missing_docs)] // documentation missing in model
    ForbiddenException(crate::error::ForbiddenException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundException(crate::error::NotFoundException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailureException(crate::error::ServiceFailureException),
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    #[allow(missing_docs)] // documentation missing in model
    ThrottledClientException(crate::error::ThrottledClientException),
    #[allow(missing_docs)] // documentation missing in model
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    ///
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    ///
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    ///
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for AssociatePhoneNumbersWithVoiceConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AssociatePhoneNumbersWithVoiceConnectorError {
    fn code(&self) -> Option<&str> {
        AssociatePhoneNumbersWithVoiceConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociatePhoneNumbersWithVoiceConnectorError {
    /// Creates a new `AssociatePhoneNumbersWithVoiceConnectorError`.
    pub fn new(
        kind: AssociatePhoneNumbersWithVoiceConnectorErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `AssociatePhoneNumbersWithVoiceConnectorError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociatePhoneNumbersWithVoiceConnectorErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `AssociatePhoneNumbersWithVoiceConnectorError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociatePhoneNumbersWithVoiceConnectorErrorKind::Unhandled(
                crate::error::Unhandled::new(err.into()),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::AccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceFailureException`.
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceFailureException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorErrorKind::ThrottledClientException`.
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ThrottledClientException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociatePhoneNumbersWithVoiceConnectorErrorKind::UnauthorizedClientException`.
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for AssociatePhoneNumbersWithVoiceConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::Unhandled(_inner) => Some(_inner),
        }
    }
}

///
/// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
///
/// When logging an error from the SDK, it is recommended that you either wrap the error in
/// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
/// error reporter library that visits the error's cause/source chain, or call
/// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
///
#[derive(Debug)]
pub struct Unhandled {
    source: Box<dyn std::error::Error + Send + Sync + 'static>,
}
impl Unhandled {
    #[allow(unused)]
    pub(crate) fn new(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self { source }
    }
}
impl std::fmt::Display for Unhandled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(f, "unhandled error")
    }
}
impl std::error::Error for Unhandled {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        Some(self.source.as_ref() as _)
    }
}
