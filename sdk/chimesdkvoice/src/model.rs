// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `ErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let errorcode = unimplemented!();
/// match errorcode {
///     ErrorCode::AccessDenied => { /* ... */ },
///     ErrorCode::BadRequest => { /* ... */ },
///     ErrorCode::Conflict => { /* ... */ },
///     ErrorCode::Forbidden => { /* ... */ },
///     ErrorCode::Gone => { /* ... */ },
///     ErrorCode::NotFound => { /* ... */ },
///     ErrorCode::PhoneNumberAssociationsExist => { /* ... */ },
///     ErrorCode::PreconditionFailed => { /* ... */ },
///     ErrorCode::ResourceLimitExceeded => { /* ... */ },
///     ErrorCode::ServiceFailure => { /* ... */ },
///     ErrorCode::ServiceUnavailable => { /* ... */ },
///     ErrorCode::Throttled => { /* ... */ },
///     ErrorCode::Throttling => { /* ... */ },
///     ErrorCode::Unauthorized => { /* ... */ },
///     ErrorCode::Unprocessable => { /* ... */ },
///     ErrorCode::VoiceConnectorGroupAssociationsExist => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `errorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ErrorCode::NewFeature` is defined.
/// Specifically, when `errorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    AccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    BadRequest,
    #[allow(missing_docs)] // documentation missing in model
    Conflict,
    #[allow(missing_docs)] // documentation missing in model
    Forbidden,
    #[allow(missing_docs)] // documentation missing in model
    Gone,
    #[allow(missing_docs)] // documentation missing in model
    NotFound,
    #[allow(missing_docs)] // documentation missing in model
    PhoneNumberAssociationsExist,
    #[allow(missing_docs)] // documentation missing in model
    PreconditionFailed,
    #[allow(missing_docs)] // documentation missing in model
    ResourceLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    ServiceFailure,
    #[allow(missing_docs)] // documentation missing in model
    ServiceUnavailable,
    #[allow(missing_docs)] // documentation missing in model
    Throttled,
    #[allow(missing_docs)] // documentation missing in model
    Throttling,
    #[allow(missing_docs)] // documentation missing in model
    Unauthorized,
    #[allow(missing_docs)] // documentation missing in model
    Unprocessable,
    #[allow(missing_docs)] // documentation missing in model
    VoiceConnectorGroupAssociationsExist,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "AccessDenied" => ErrorCode::AccessDenied,
            "BadRequest" => ErrorCode::BadRequest,
            "Conflict" => ErrorCode::Conflict,
            "Forbidden" => ErrorCode::Forbidden,
            "Gone" => ErrorCode::Gone,
            "NotFound" => ErrorCode::NotFound,
            "PhoneNumberAssociationsExist" => ErrorCode::PhoneNumberAssociationsExist,
            "PreconditionFailed" => ErrorCode::PreconditionFailed,
            "ResourceLimitExceeded" => ErrorCode::ResourceLimitExceeded,
            "ServiceFailure" => ErrorCode::ServiceFailure,
            "ServiceUnavailable" => ErrorCode::ServiceUnavailable,
            "Throttled" => ErrorCode::Throttled,
            "Throttling" => ErrorCode::Throttling,
            "Unauthorized" => ErrorCode::Unauthorized,
            "Unprocessable" => ErrorCode::Unprocessable,
            "VoiceConnectorGroupAssociationsExist" => {
                ErrorCode::VoiceConnectorGroupAssociationsExist
            }
            other => ErrorCode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ErrorCode::from(s))
    }
}
impl ErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ErrorCode::AccessDenied => "AccessDenied",
            ErrorCode::BadRequest => "BadRequest",
            ErrorCode::Conflict => "Conflict",
            ErrorCode::Forbidden => "Forbidden",
            ErrorCode::Gone => "Gone",
            ErrorCode::NotFound => "NotFound",
            ErrorCode::PhoneNumberAssociationsExist => "PhoneNumberAssociationsExist",
            ErrorCode::PreconditionFailed => "PreconditionFailed",
            ErrorCode::ResourceLimitExceeded => "ResourceLimitExceeded",
            ErrorCode::ServiceFailure => "ServiceFailure",
            ErrorCode::ServiceUnavailable => "ServiceUnavailable",
            ErrorCode::Throttled => "Throttled",
            ErrorCode::Throttling => "Throttling",
            ErrorCode::Unauthorized => "Unauthorized",
            ErrorCode::Unprocessable => "Unprocessable",
            ErrorCode::VoiceConnectorGroupAssociationsExist => {
                "VoiceConnectorGroupAssociationsExist"
            }
            ErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AccessDenied",
            "BadRequest",
            "Conflict",
            "Forbidden",
            "Gone",
            "NotFound",
            "PhoneNumberAssociationsExist",
            "PreconditionFailed",
            "ResourceLimitExceeded",
            "ServiceFailure",
            "ServiceUnavailable",
            "Throttled",
            "Throttling",
            "Unauthorized",
            "Unprocessable",
            "VoiceConnectorGroupAssociationsExist",
        ]
    }
}
impl AsRef<str> for ErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CandidateAddress {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub street_info: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub street_number: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub city: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub state: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub postal_code: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub postal_code_plus4: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub country: std::option::Option<std::string::String>,
}
impl CandidateAddress {
    #[allow(missing_docs)] // documentation missing in model
    pub fn street_info(&self) -> std::option::Option<&str> {
        self.street_info.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn street_number(&self) -> std::option::Option<&str> {
        self.street_number.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn city(&self) -> std::option::Option<&str> {
        self.city.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn state(&self) -> std::option::Option<&str> {
        self.state.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn postal_code(&self) -> std::option::Option<&str> {
        self.postal_code.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn postal_code_plus4(&self) -> std::option::Option<&str> {
        self.postal_code_plus4.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn country(&self) -> std::option::Option<&str> {
        self.country.as_deref()
    }
}
impl std::fmt::Debug for CandidateAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CandidateAddress");
        formatter.field("street_info", &"*** Sensitive Data Redacted ***");
        formatter.field("street_number", &"*** Sensitive Data Redacted ***");
        formatter.field("city", &"*** Sensitive Data Redacted ***");
        formatter.field("state", &"*** Sensitive Data Redacted ***");
        formatter.field("postal_code", &"*** Sensitive Data Redacted ***");
        formatter.field("postal_code_plus4", &"*** Sensitive Data Redacted ***");
        formatter.field("country", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`CandidateAddress`](crate::model::CandidateAddress).
pub mod candidate_address {

    /// A builder for [`CandidateAddress`](crate::model::CandidateAddress).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) street_info: std::option::Option<std::string::String>,
        pub(crate) street_number: std::option::Option<std::string::String>,
        pub(crate) city: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<std::string::String>,
        pub(crate) postal_code: std::option::Option<std::string::String>,
        pub(crate) postal_code_plus4: std::option::Option<std::string::String>,
        pub(crate) country: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn street_info(mut self, input: impl Into<std::string::String>) -> Self {
            self.street_info = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_street_info(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.street_info = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn street_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.street_number = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_street_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.street_number = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn city(mut self, input: impl Into<std::string::String>) -> Self {
            self.city = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_city(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.city = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn postal_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.postal_code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_postal_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.postal_code = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn postal_code_plus4(mut self, input: impl Into<std::string::String>) -> Self {
            self.postal_code_plus4 = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_postal_code_plus4(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.postal_code_plus4 = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn country(mut self, input: impl Into<std::string::String>) -> Self {
            self.country = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_country(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.country = input;
            self
        }
        /// Consumes the builder and constructs a [`CandidateAddress`](crate::model::CandidateAddress).
        pub fn build(self) -> crate::model::CandidateAddress {
            crate::model::CandidateAddress {
                street_info: self.street_info,
                street_number: self.street_number,
                city: self.city,
                state: self.state,
                postal_code: self.postal_code,
                postal_code_plus4: self.postal_code_plus4,
                country: self.country,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("street_info", &"*** Sensitive Data Redacted ***");
            formatter.field("street_number", &"*** Sensitive Data Redacted ***");
            formatter.field("city", &"*** Sensitive Data Redacted ***");
            formatter.field("state", &"*** Sensitive Data Redacted ***");
            formatter.field("postal_code", &"*** Sensitive Data Redacted ***");
            formatter.field("postal_code_plus4", &"*** Sensitive Data Redacted ***");
            formatter.field("country", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl CandidateAddress {
    /// Creates a new builder-style object to manufacture [`CandidateAddress`](crate::model::CandidateAddress).
    pub fn builder() -> crate::model::candidate_address::Builder {
        crate::model::candidate_address::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Address {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub street_name: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub street_suffix: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub post_directional: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub pre_directional: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub street_number: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub city: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub state: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub postal_code: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub postal_code_plus4: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub country: std::option::Option<std::string::String>,
}
impl Address {
    #[allow(missing_docs)] // documentation missing in model
    pub fn street_name(&self) -> std::option::Option<&str> {
        self.street_name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn street_suffix(&self) -> std::option::Option<&str> {
        self.street_suffix.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn post_directional(&self) -> std::option::Option<&str> {
        self.post_directional.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn pre_directional(&self) -> std::option::Option<&str> {
        self.pre_directional.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn street_number(&self) -> std::option::Option<&str> {
        self.street_number.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn city(&self) -> std::option::Option<&str> {
        self.city.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn state(&self) -> std::option::Option<&str> {
        self.state.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn postal_code(&self) -> std::option::Option<&str> {
        self.postal_code.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn postal_code_plus4(&self) -> std::option::Option<&str> {
        self.postal_code_plus4.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn country(&self) -> std::option::Option<&str> {
        self.country.as_deref()
    }
}
impl std::fmt::Debug for Address {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Address");
        formatter.field("street_name", &"*** Sensitive Data Redacted ***");
        formatter.field("street_suffix", &"*** Sensitive Data Redacted ***");
        formatter.field("post_directional", &"*** Sensitive Data Redacted ***");
        formatter.field("pre_directional", &"*** Sensitive Data Redacted ***");
        formatter.field("street_number", &"*** Sensitive Data Redacted ***");
        formatter.field("city", &"*** Sensitive Data Redacted ***");
        formatter.field("state", &"*** Sensitive Data Redacted ***");
        formatter.field("postal_code", &"*** Sensitive Data Redacted ***");
        formatter.field("postal_code_plus4", &"*** Sensitive Data Redacted ***");
        formatter.field("country", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`Address`](crate::model::Address).
pub mod address {

    /// A builder for [`Address`](crate::model::Address).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) street_name: std::option::Option<std::string::String>,
        pub(crate) street_suffix: std::option::Option<std::string::String>,
        pub(crate) post_directional: std::option::Option<std::string::String>,
        pub(crate) pre_directional: std::option::Option<std::string::String>,
        pub(crate) street_number: std::option::Option<std::string::String>,
        pub(crate) city: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<std::string::String>,
        pub(crate) postal_code: std::option::Option<std::string::String>,
        pub(crate) postal_code_plus4: std::option::Option<std::string::String>,
        pub(crate) country: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn street_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.street_name = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_street_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.street_name = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn street_suffix(mut self, input: impl Into<std::string::String>) -> Self {
            self.street_suffix = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_street_suffix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.street_suffix = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn post_directional(mut self, input: impl Into<std::string::String>) -> Self {
            self.post_directional = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_post_directional(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.post_directional = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn pre_directional(mut self, input: impl Into<std::string::String>) -> Self {
            self.pre_directional = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_pre_directional(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pre_directional = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn street_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.street_number = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_street_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.street_number = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn city(mut self, input: impl Into<std::string::String>) -> Self {
            self.city = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_city(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.city = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn postal_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.postal_code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_postal_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.postal_code = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn postal_code_plus4(mut self, input: impl Into<std::string::String>) -> Self {
            self.postal_code_plus4 = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_postal_code_plus4(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.postal_code_plus4 = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn country(mut self, input: impl Into<std::string::String>) -> Self {
            self.country = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_country(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.country = input;
            self
        }
        /// Consumes the builder and constructs a [`Address`](crate::model::Address).
        pub fn build(self) -> crate::model::Address {
            crate::model::Address {
                street_name: self.street_name,
                street_suffix: self.street_suffix,
                post_directional: self.post_directional,
                pre_directional: self.pre_directional,
                street_number: self.street_number,
                city: self.city,
                state: self.state,
                postal_code: self.postal_code,
                postal_code_plus4: self.postal_code_plus4,
                country: self.country,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("street_name", &"*** Sensitive Data Redacted ***");
            formatter.field("street_suffix", &"*** Sensitive Data Redacted ***");
            formatter.field("post_directional", &"*** Sensitive Data Redacted ***");
            formatter.field("pre_directional", &"*** Sensitive Data Redacted ***");
            formatter.field("street_number", &"*** Sensitive Data Redacted ***");
            formatter.field("city", &"*** Sensitive Data Redacted ***");
            formatter.field("state", &"*** Sensitive Data Redacted ***");
            formatter.field("postal_code", &"*** Sensitive Data Redacted ***");
            formatter.field("postal_code_plus4", &"*** Sensitive Data Redacted ***");
            formatter.field("country", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl Address {
    /// Creates a new builder-style object to manufacture [`Address`](crate::model::Address).
    pub fn builder() -> crate::model::address::Builder {
        crate::model::address::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VoiceConnectorGroup {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub voice_connector_group_id: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub voice_connector_items: std::option::Option<std::vec::Vec<crate::model::VoiceConnectorItem>>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub voice_connector_group_arn: std::option::Option<std::string::String>,
}
impl VoiceConnectorGroup {
    #[allow(missing_docs)] // documentation missing in model
    pub fn voice_connector_group_id(&self) -> std::option::Option<&str> {
        self.voice_connector_group_id.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn voice_connector_items(
        &self,
    ) -> std::option::Option<&[crate::model::VoiceConnectorItem]> {
        self.voice_connector_items.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn created_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_timestamp.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn updated_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_timestamp.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn voice_connector_group_arn(&self) -> std::option::Option<&str> {
        self.voice_connector_group_arn.as_deref()
    }
}
/// See [`VoiceConnectorGroup`](crate::model::VoiceConnectorGroup).
pub mod voice_connector_group {

    /// A builder for [`VoiceConnectorGroup`](crate::model::VoiceConnectorGroup).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_group_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) voice_connector_items:
            std::option::Option<std::vec::Vec<crate::model::VoiceConnectorItem>>,
        pub(crate) created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) voice_connector_group_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn voice_connector_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_group_id = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_voice_connector_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_group_id = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `voice_connector_items`.
        ///
        /// To override the contents of this collection use [`set_voice_connector_items`](Self::set_voice_connector_items).
        ///
        pub fn voice_connector_items(mut self, input: crate::model::VoiceConnectorItem) -> Self {
            let mut v = self.voice_connector_items.unwrap_or_default();
            v.push(input);
            self.voice_connector_items = Some(v);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_voice_connector_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VoiceConnectorItem>>,
        ) -> Self {
            self.voice_connector_items = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn created_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_timestamp = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_created_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_timestamp = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn updated_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_timestamp = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_updated_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_timestamp = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn voice_connector_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_group_arn = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_voice_connector_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_group_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`VoiceConnectorGroup`](crate::model::VoiceConnectorGroup).
        pub fn build(self) -> crate::model::VoiceConnectorGroup {
            crate::model::VoiceConnectorGroup {
                voice_connector_group_id: self.voice_connector_group_id,
                name: self.name,
                voice_connector_items: self.voice_connector_items,
                created_timestamp: self.created_timestamp,
                updated_timestamp: self.updated_timestamp,
                voice_connector_group_arn: self.voice_connector_group_arn,
            }
        }
    }
}
impl VoiceConnectorGroup {
    /// Creates a new builder-style object to manufacture [`VoiceConnectorGroup`](crate::model::VoiceConnectorGroup).
    pub fn builder() -> crate::model::voice_connector_group::Builder {
        crate::model::voice_connector_group::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VoiceConnectorItem {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub voice_connector_id: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub priority: std::option::Option<i32>,
}
impl VoiceConnectorItem {
    #[allow(missing_docs)] // documentation missing in model
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn priority(&self) -> std::option::Option<i32> {
        self.priority
    }
}
/// See [`VoiceConnectorItem`](crate::model::VoiceConnectorItem).
pub mod voice_connector_item {

    /// A builder for [`VoiceConnectorItem`](crate::model::VoiceConnectorItem).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
        pub(crate) priority: std::option::Option<i32>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// Consumes the builder and constructs a [`VoiceConnectorItem`](crate::model::VoiceConnectorItem).
        pub fn build(self) -> crate::model::VoiceConnectorItem {
            crate::model::VoiceConnectorItem {
                voice_connector_id: self.voice_connector_id,
                priority: self.priority,
            }
        }
    }
}
impl VoiceConnectorItem {
    /// Creates a new builder-style object to manufacture [`VoiceConnectorItem`](crate::model::VoiceConnectorItem).
    pub fn builder() -> crate::model::voice_connector_item::Builder {
        crate::model::voice_connector_item::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VoiceConnector {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub voice_connector_id: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub aws_region: std::option::Option<crate::model::VoiceConnectorAwsRegion>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub outbound_host_name: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub require_encryption: std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub voice_connector_arn: std::option::Option<std::string::String>,
}
impl VoiceConnector {
    #[allow(missing_docs)] // documentation missing in model
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn aws_region(&self) -> std::option::Option<&crate::model::VoiceConnectorAwsRegion> {
        self.aws_region.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn outbound_host_name(&self) -> std::option::Option<&str> {
        self.outbound_host_name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn require_encryption(&self) -> std::option::Option<bool> {
        self.require_encryption
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn created_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_timestamp.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn updated_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_timestamp.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn voice_connector_arn(&self) -> std::option::Option<&str> {
        self.voice_connector_arn.as_deref()
    }
}
/// See [`VoiceConnector`](crate::model::VoiceConnector).
pub mod voice_connector {

    /// A builder for [`VoiceConnector`](crate::model::VoiceConnector).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<crate::model::VoiceConnectorAwsRegion>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) outbound_host_name: std::option::Option<std::string::String>,
        pub(crate) require_encryption: std::option::Option<bool>,
        pub(crate) created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) voice_connector_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn aws_region(mut self, input: crate::model::VoiceConnectorAwsRegion) -> Self {
            self.aws_region = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_aws_region(
            mut self,
            input: std::option::Option<crate::model::VoiceConnectorAwsRegion>,
        ) -> Self {
            self.aws_region = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn outbound_host_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.outbound_host_name = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_outbound_host_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.outbound_host_name = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn require_encryption(mut self, input: bool) -> Self {
            self.require_encryption = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_require_encryption(mut self, input: std::option::Option<bool>) -> Self {
            self.require_encryption = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn created_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_timestamp = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_created_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_timestamp = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn updated_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_timestamp = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_updated_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_timestamp = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn voice_connector_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_arn = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_voice_connector_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`VoiceConnector`](crate::model::VoiceConnector).
        pub fn build(self) -> crate::model::VoiceConnector {
            crate::model::VoiceConnector {
                voice_connector_id: self.voice_connector_id,
                aws_region: self.aws_region,
                name: self.name,
                outbound_host_name: self.outbound_host_name,
                require_encryption: self.require_encryption,
                created_timestamp: self.created_timestamp,
                updated_timestamp: self.updated_timestamp,
                voice_connector_arn: self.voice_connector_arn,
            }
        }
    }
}
impl VoiceConnector {
    /// Creates a new builder-style object to manufacture [`VoiceConnector`](crate::model::VoiceConnector).
    pub fn builder() -> crate::model::voice_connector::Builder {
        crate::model::voice_connector::Builder::default()
    }
}

/// When writing a match expression against `VoiceConnectorAwsRegion`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let voiceconnectorawsregion = unimplemented!();
/// match voiceconnectorawsregion {
///     VoiceConnectorAwsRegion::ApNortheast1 => { /* ... */ },
///     VoiceConnectorAwsRegion::ApNortheast2 => { /* ... */ },
///     VoiceConnectorAwsRegion::ApSoutheast1 => { /* ... */ },
///     VoiceConnectorAwsRegion::ApSoutheast2 => { /* ... */ },
///     VoiceConnectorAwsRegion::CaCentral1 => { /* ... */ },
///     VoiceConnectorAwsRegion::EuCentral1 => { /* ... */ },
///     VoiceConnectorAwsRegion::EuWest1 => { /* ... */ },
///     VoiceConnectorAwsRegion::EuWest2 => { /* ... */ },
///     VoiceConnectorAwsRegion::UsEast1 => { /* ... */ },
///     VoiceConnectorAwsRegion::UsWest2 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `voiceconnectorawsregion` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VoiceConnectorAwsRegion::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VoiceConnectorAwsRegion::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VoiceConnectorAwsRegion::NewFeature` is defined.
/// Specifically, when `voiceconnectorawsregion` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VoiceConnectorAwsRegion::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VoiceConnectorAwsRegion {
    #[allow(missing_docs)] // documentation missing in model
    ApNortheast1,
    #[allow(missing_docs)] // documentation missing in model
    ApNortheast2,
    #[allow(missing_docs)] // documentation missing in model
    ApSoutheast1,
    #[allow(missing_docs)] // documentation missing in model
    ApSoutheast2,
    #[allow(missing_docs)] // documentation missing in model
    CaCentral1,
    #[allow(missing_docs)] // documentation missing in model
    EuCentral1,
    #[allow(missing_docs)] // documentation missing in model
    EuWest1,
    #[allow(missing_docs)] // documentation missing in model
    EuWest2,
    #[allow(missing_docs)] // documentation missing in model
    UsEast1,
    #[allow(missing_docs)] // documentation missing in model
    UsWest2,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VoiceConnectorAwsRegion {
    fn from(s: &str) -> Self {
        match s {
            "ap-northeast-1" => VoiceConnectorAwsRegion::ApNortheast1,
            "ap-northeast-2" => VoiceConnectorAwsRegion::ApNortheast2,
            "ap-southeast-1" => VoiceConnectorAwsRegion::ApSoutheast1,
            "ap-southeast-2" => VoiceConnectorAwsRegion::ApSoutheast2,
            "ca-central-1" => VoiceConnectorAwsRegion::CaCentral1,
            "eu-central-1" => VoiceConnectorAwsRegion::EuCentral1,
            "eu-west-1" => VoiceConnectorAwsRegion::EuWest1,
            "eu-west-2" => VoiceConnectorAwsRegion::EuWest2,
            "us-east-1" => VoiceConnectorAwsRegion::UsEast1,
            "us-west-2" => VoiceConnectorAwsRegion::UsWest2,
            other => VoiceConnectorAwsRegion::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for VoiceConnectorAwsRegion {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VoiceConnectorAwsRegion::from(s))
    }
}
impl VoiceConnectorAwsRegion {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VoiceConnectorAwsRegion::ApNortheast1 => "ap-northeast-1",
            VoiceConnectorAwsRegion::ApNortheast2 => "ap-northeast-2",
            VoiceConnectorAwsRegion::ApSoutheast1 => "ap-southeast-1",
            VoiceConnectorAwsRegion::ApSoutheast2 => "ap-southeast-2",
            VoiceConnectorAwsRegion::CaCentral1 => "ca-central-1",
            VoiceConnectorAwsRegion::EuCentral1 => "eu-central-1",
            VoiceConnectorAwsRegion::EuWest1 => "eu-west-1",
            VoiceConnectorAwsRegion::EuWest2 => "eu-west-2",
            VoiceConnectorAwsRegion::UsEast1 => "us-east-1",
            VoiceConnectorAwsRegion::UsWest2 => "us-west-2",
            VoiceConnectorAwsRegion::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ap-northeast-1",
            "ap-northeast-2",
            "ap-southeast-1",
            "ap-southeast-2",
            "ca-central-1",
            "eu-central-1",
            "eu-west-1",
            "eu-west-2",
            "us-east-1",
            "us-west-2",
        ]
    }
}
impl AsRef<str> for VoiceConnectorAwsRegion {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SipRule {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub sip_rule_id: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub disabled: std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub trigger_type: std::option::Option<crate::model::SipRuleTriggerType>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub trigger_value: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub target_applications:
        std::option::Option<std::vec::Vec<crate::model::SipRuleTargetApplication>>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl SipRule {
    #[allow(missing_docs)] // documentation missing in model
    pub fn sip_rule_id(&self) -> std::option::Option<&str> {
        self.sip_rule_id.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn disabled(&self) -> std::option::Option<bool> {
        self.disabled
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn trigger_type(&self) -> std::option::Option<&crate::model::SipRuleTriggerType> {
        self.trigger_type.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn trigger_value(&self) -> std::option::Option<&str> {
        self.trigger_value.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn target_applications(
        &self,
    ) -> std::option::Option<&[crate::model::SipRuleTargetApplication]> {
        self.target_applications.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn created_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_timestamp.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn updated_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_timestamp.as_ref()
    }
}
/// See [`SipRule`](crate::model::SipRule).
pub mod sip_rule {

    /// A builder for [`SipRule`](crate::model::SipRule).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sip_rule_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) disabled: std::option::Option<bool>,
        pub(crate) trigger_type: std::option::Option<crate::model::SipRuleTriggerType>,
        pub(crate) trigger_value: std::option::Option<std::string::String>,
        pub(crate) target_applications:
            std::option::Option<std::vec::Vec<crate::model::SipRuleTargetApplication>>,
        pub(crate) created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn sip_rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sip_rule_id = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_sip_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sip_rule_id = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn disabled(mut self, input: bool) -> Self {
            self.disabled = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_disabled(mut self, input: std::option::Option<bool>) -> Self {
            self.disabled = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn trigger_type(mut self, input: crate::model::SipRuleTriggerType) -> Self {
            self.trigger_type = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_trigger_type(
            mut self,
            input: std::option::Option<crate::model::SipRuleTriggerType>,
        ) -> Self {
            self.trigger_type = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn trigger_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.trigger_value = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_trigger_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.trigger_value = input;
            self
        }
        /// Appends an item to `target_applications`.
        ///
        /// To override the contents of this collection use [`set_target_applications`](Self::set_target_applications).
        ///
        pub fn target_applications(
            mut self,
            input: crate::model::SipRuleTargetApplication,
        ) -> Self {
            let mut v = self.target_applications.unwrap_or_default();
            v.push(input);
            self.target_applications = Some(v);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_target_applications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SipRuleTargetApplication>>,
        ) -> Self {
            self.target_applications = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn created_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_timestamp = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_created_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_timestamp = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn updated_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_timestamp = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_updated_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`SipRule`](crate::model::SipRule).
        pub fn build(self) -> crate::model::SipRule {
            crate::model::SipRule {
                sip_rule_id: self.sip_rule_id,
                name: self.name,
                disabled: self.disabled,
                trigger_type: self.trigger_type,
                trigger_value: self.trigger_value,
                target_applications: self.target_applications,
                created_timestamp: self.created_timestamp,
                updated_timestamp: self.updated_timestamp,
            }
        }
    }
}
impl SipRule {
    /// Creates a new builder-style object to manufacture [`SipRule`](crate::model::SipRule).
    pub fn builder() -> crate::model::sip_rule::Builder {
        crate::model::sip_rule::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SipRuleTargetApplication {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub sip_media_application_id: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub priority: std::option::Option<i32>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub aws_region: std::option::Option<std::string::String>,
}
impl SipRuleTargetApplication {
    #[allow(missing_docs)] // documentation missing in model
    pub fn sip_media_application_id(&self) -> std::option::Option<&str> {
        self.sip_media_application_id.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn priority(&self) -> std::option::Option<i32> {
        self.priority
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
}
/// See [`SipRuleTargetApplication`](crate::model::SipRuleTargetApplication).
pub mod sip_rule_target_application {

    /// A builder for [`SipRuleTargetApplication`](crate::model::SipRuleTargetApplication).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sip_media_application_id: std::option::Option<std::string::String>,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn sip_media_application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sip_media_application_id = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_sip_media_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sip_media_application_id = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        /// Consumes the builder and constructs a [`SipRuleTargetApplication`](crate::model::SipRuleTargetApplication).
        pub fn build(self) -> crate::model::SipRuleTargetApplication {
            crate::model::SipRuleTargetApplication {
                sip_media_application_id: self.sip_media_application_id,
                priority: self.priority,
                aws_region: self.aws_region,
            }
        }
    }
}
impl SipRuleTargetApplication {
    /// Creates a new builder-style object to manufacture [`SipRuleTargetApplication`](crate::model::SipRuleTargetApplication).
    pub fn builder() -> crate::model::sip_rule_target_application::Builder {
        crate::model::sip_rule_target_application::Builder::default()
    }
}

/// When writing a match expression against `SipRuleTriggerType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sipruletriggertype = unimplemented!();
/// match sipruletriggertype {
///     SipRuleTriggerType::RequestUriHostname => { /* ... */ },
///     SipRuleTriggerType::ToPhoneNumber => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sipruletriggertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SipRuleTriggerType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SipRuleTriggerType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SipRuleTriggerType::NewFeature` is defined.
/// Specifically, when `sipruletriggertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SipRuleTriggerType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SipRuleTriggerType {
    #[allow(missing_docs)] // documentation missing in model
    RequestUriHostname,
    #[allow(missing_docs)] // documentation missing in model
    ToPhoneNumber,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SipRuleTriggerType {
    fn from(s: &str) -> Self {
        match s {
            "RequestUriHostname" => SipRuleTriggerType::RequestUriHostname,
            "ToPhoneNumber" => SipRuleTriggerType::ToPhoneNumber,
            other => {
                SipRuleTriggerType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SipRuleTriggerType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SipRuleTriggerType::from(s))
    }
}
impl SipRuleTriggerType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SipRuleTriggerType::RequestUriHostname => "RequestUriHostname",
            SipRuleTriggerType::ToPhoneNumber => "ToPhoneNumber",
            SipRuleTriggerType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["RequestUriHostname", "ToPhoneNumber"]
    }
}
impl AsRef<str> for SipRuleTriggerType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SipMediaApplicationCall {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub transaction_id: std::option::Option<std::string::String>,
}
impl SipMediaApplicationCall {
    #[allow(missing_docs)] // documentation missing in model
    pub fn transaction_id(&self) -> std::option::Option<&str> {
        self.transaction_id.as_deref()
    }
}
/// See [`SipMediaApplicationCall`](crate::model::SipMediaApplicationCall).
pub mod sip_media_application_call {

    /// A builder for [`SipMediaApplicationCall`](crate::model::SipMediaApplicationCall).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transaction_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn transaction_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transaction_id = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_transaction_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transaction_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SipMediaApplicationCall`](crate::model::SipMediaApplicationCall).
        pub fn build(self) -> crate::model::SipMediaApplicationCall {
            crate::model::SipMediaApplicationCall {
                transaction_id: self.transaction_id,
            }
        }
    }
}
impl SipMediaApplicationCall {
    /// Creates a new builder-style object to manufacture [`SipMediaApplicationCall`](crate::model::SipMediaApplicationCall).
    pub fn builder() -> crate::model::sip_media_application_call::Builder {
        crate::model::sip_media_application_call::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SipMediaApplication {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub sip_media_application_id: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub aws_region: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub endpoints: std::option::Option<std::vec::Vec<crate::model::SipMediaApplicationEndpoint>>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl SipMediaApplication {
    #[allow(missing_docs)] // documentation missing in model
    pub fn sip_media_application_id(&self) -> std::option::Option<&str> {
        self.sip_media_application_id.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn endpoints(&self) -> std::option::Option<&[crate::model::SipMediaApplicationEndpoint]> {
        self.endpoints.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn created_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_timestamp.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn updated_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_timestamp.as_ref()
    }
}
/// See [`SipMediaApplication`](crate::model::SipMediaApplication).
pub mod sip_media_application {

    /// A builder for [`SipMediaApplication`](crate::model::SipMediaApplication).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sip_media_application_id: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) endpoints:
            std::option::Option<std::vec::Vec<crate::model::SipMediaApplicationEndpoint>>,
        pub(crate) created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn sip_media_application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sip_media_application_id = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_sip_media_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sip_media_application_id = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `endpoints`.
        ///
        /// To override the contents of this collection use [`set_endpoints`](Self::set_endpoints).
        ///
        pub fn endpoints(mut self, input: crate::model::SipMediaApplicationEndpoint) -> Self {
            let mut v = self.endpoints.unwrap_or_default();
            v.push(input);
            self.endpoints = Some(v);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_endpoints(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SipMediaApplicationEndpoint>>,
        ) -> Self {
            self.endpoints = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn created_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_timestamp = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_created_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_timestamp = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn updated_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_timestamp = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_updated_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`SipMediaApplication`](crate::model::SipMediaApplication).
        pub fn build(self) -> crate::model::SipMediaApplication {
            crate::model::SipMediaApplication {
                sip_media_application_id: self.sip_media_application_id,
                aws_region: self.aws_region,
                name: self.name,
                endpoints: self.endpoints,
                created_timestamp: self.created_timestamp,
                updated_timestamp: self.updated_timestamp,
            }
        }
    }
}
impl SipMediaApplication {
    /// Creates a new builder-style object to manufacture [`SipMediaApplication`](crate::model::SipMediaApplication).
    pub fn builder() -> crate::model::sip_media_application::Builder {
        crate::model::sip_media_application::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SipMediaApplicationEndpoint {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub lambda_arn: std::option::Option<std::string::String>,
}
impl SipMediaApplicationEndpoint {
    #[allow(missing_docs)] // documentation missing in model
    pub fn lambda_arn(&self) -> std::option::Option<&str> {
        self.lambda_arn.as_deref()
    }
}
impl std::fmt::Debug for SipMediaApplicationEndpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SipMediaApplicationEndpoint");
        formatter.field("lambda_arn", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`SipMediaApplicationEndpoint`](crate::model::SipMediaApplicationEndpoint).
pub mod sip_media_application_endpoint {

    /// A builder for [`SipMediaApplicationEndpoint`](crate::model::SipMediaApplicationEndpoint).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) lambda_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn lambda_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lambda_arn = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_lambda_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lambda_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`SipMediaApplicationEndpoint`](crate::model::SipMediaApplicationEndpoint).
        pub fn build(self) -> crate::model::SipMediaApplicationEndpoint {
            crate::model::SipMediaApplicationEndpoint {
                lambda_arn: self.lambda_arn,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("lambda_arn", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl SipMediaApplicationEndpoint {
    /// Creates a new builder-style object to manufacture [`SipMediaApplicationEndpoint`](crate::model::SipMediaApplicationEndpoint).
    pub fn builder() -> crate::model::sip_media_application_endpoint::Builder {
        crate::model::sip_media_application_endpoint::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProxySession {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub voice_connector_id: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub proxy_session_id: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ProxySessionStatus>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub expiry_minutes: std::option::Option<i32>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub capabilities: std::option::Option<std::vec::Vec<crate::model::Capability>>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub ended_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub participants: std::option::Option<std::vec::Vec<crate::model::Participant>>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub number_selection_behavior: std::option::Option<crate::model::NumberSelectionBehavior>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub geo_match_level: std::option::Option<crate::model::GeoMatchLevel>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub geo_match_params: std::option::Option<crate::model::GeoMatchParams>,
}
impl ProxySession {
    #[allow(missing_docs)] // documentation missing in model
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn proxy_session_id(&self) -> std::option::Option<&str> {
        self.proxy_session_id.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn status(&self) -> std::option::Option<&crate::model::ProxySessionStatus> {
        self.status.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn expiry_minutes(&self) -> std::option::Option<i32> {
        self.expiry_minutes
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn capabilities(&self) -> std::option::Option<&[crate::model::Capability]> {
        self.capabilities.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn created_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_timestamp.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn updated_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_timestamp.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn ended_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.ended_timestamp.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn participants(&self) -> std::option::Option<&[crate::model::Participant]> {
        self.participants.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn number_selection_behavior(
        &self,
    ) -> std::option::Option<&crate::model::NumberSelectionBehavior> {
        self.number_selection_behavior.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn geo_match_level(&self) -> std::option::Option<&crate::model::GeoMatchLevel> {
        self.geo_match_level.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn geo_match_params(&self) -> std::option::Option<&crate::model::GeoMatchParams> {
        self.geo_match_params.as_ref()
    }
}
/// See [`ProxySession`](crate::model::ProxySession).
pub mod proxy_session {

    /// A builder for [`ProxySession`](crate::model::ProxySession).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
        pub(crate) proxy_session_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ProxySessionStatus>,
        pub(crate) expiry_minutes: std::option::Option<i32>,
        pub(crate) capabilities: std::option::Option<std::vec::Vec<crate::model::Capability>>,
        pub(crate) created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) ended_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) participants: std::option::Option<std::vec::Vec<crate::model::Participant>>,
        pub(crate) number_selection_behavior:
            std::option::Option<crate::model::NumberSelectionBehavior>,
        pub(crate) geo_match_level: std::option::Option<crate::model::GeoMatchLevel>,
        pub(crate) geo_match_params: std::option::Option<crate::model::GeoMatchParams>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn proxy_session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.proxy_session_id = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_proxy_session_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.proxy_session_id = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn status(mut self, input: crate::model::ProxySessionStatus) -> Self {
            self.status = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ProxySessionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn expiry_minutes(mut self, input: i32) -> Self {
            self.expiry_minutes = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_expiry_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.expiry_minutes = input;
            self
        }
        /// Appends an item to `capabilities`.
        ///
        /// To override the contents of this collection use [`set_capabilities`](Self::set_capabilities).
        ///
        pub fn capabilities(mut self, input: crate::model::Capability) -> Self {
            let mut v = self.capabilities.unwrap_or_default();
            v.push(input);
            self.capabilities = Some(v);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_capabilities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Capability>>,
        ) -> Self {
            self.capabilities = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn created_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_timestamp = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_created_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_timestamp = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn updated_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_timestamp = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_updated_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_timestamp = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn ended_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.ended_timestamp = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_ended_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.ended_timestamp = input;
            self
        }
        /// Appends an item to `participants`.
        ///
        /// To override the contents of this collection use [`set_participants`](Self::set_participants).
        ///
        pub fn participants(mut self, input: crate::model::Participant) -> Self {
            let mut v = self.participants.unwrap_or_default();
            v.push(input);
            self.participants = Some(v);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_participants(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Participant>>,
        ) -> Self {
            self.participants = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn number_selection_behavior(
            mut self,
            input: crate::model::NumberSelectionBehavior,
        ) -> Self {
            self.number_selection_behavior = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_number_selection_behavior(
            mut self,
            input: std::option::Option<crate::model::NumberSelectionBehavior>,
        ) -> Self {
            self.number_selection_behavior = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn geo_match_level(mut self, input: crate::model::GeoMatchLevel) -> Self {
            self.geo_match_level = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_geo_match_level(
            mut self,
            input: std::option::Option<crate::model::GeoMatchLevel>,
        ) -> Self {
            self.geo_match_level = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn geo_match_params(mut self, input: crate::model::GeoMatchParams) -> Self {
            self.geo_match_params = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_geo_match_params(
            mut self,
            input: std::option::Option<crate::model::GeoMatchParams>,
        ) -> Self {
            self.geo_match_params = input;
            self
        }
        /// Consumes the builder and constructs a [`ProxySession`](crate::model::ProxySession).
        pub fn build(self) -> crate::model::ProxySession {
            crate::model::ProxySession {
                voice_connector_id: self.voice_connector_id,
                proxy_session_id: self.proxy_session_id,
                name: self.name,
                status: self.status,
                expiry_minutes: self.expiry_minutes,
                capabilities: self.capabilities,
                created_timestamp: self.created_timestamp,
                updated_timestamp: self.updated_timestamp,
                ended_timestamp: self.ended_timestamp,
                participants: self.participants,
                number_selection_behavior: self.number_selection_behavior,
                geo_match_level: self.geo_match_level,
                geo_match_params: self.geo_match_params,
            }
        }
    }
}
impl ProxySession {
    /// Creates a new builder-style object to manufacture [`ProxySession`](crate::model::ProxySession).
    pub fn builder() -> crate::model::proxy_session::Builder {
        crate::model::proxy_session::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GeoMatchParams {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub country: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub area_code: std::option::Option<std::string::String>,
}
impl GeoMatchParams {
    #[allow(missing_docs)] // documentation missing in model
    pub fn country(&self) -> std::option::Option<&str> {
        self.country.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn area_code(&self) -> std::option::Option<&str> {
        self.area_code.as_deref()
    }
}
/// See [`GeoMatchParams`](crate::model::GeoMatchParams).
pub mod geo_match_params {

    /// A builder for [`GeoMatchParams`](crate::model::GeoMatchParams).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) country: std::option::Option<std::string::String>,
        pub(crate) area_code: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn country(mut self, input: impl Into<std::string::String>) -> Self {
            self.country = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_country(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.country = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn area_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.area_code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_area_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.area_code = input;
            self
        }
        /// Consumes the builder and constructs a [`GeoMatchParams`](crate::model::GeoMatchParams).
        pub fn build(self) -> crate::model::GeoMatchParams {
            crate::model::GeoMatchParams {
                country: self.country,
                area_code: self.area_code,
            }
        }
    }
}
impl GeoMatchParams {
    /// Creates a new builder-style object to manufacture [`GeoMatchParams`](crate::model::GeoMatchParams).
    pub fn builder() -> crate::model::geo_match_params::Builder {
        crate::model::geo_match_params::Builder::default()
    }
}

/// When writing a match expression against `GeoMatchLevel`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let geomatchlevel = unimplemented!();
/// match geomatchlevel {
///     GeoMatchLevel::AreaCode => { /* ... */ },
///     GeoMatchLevel::Country => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `geomatchlevel` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `GeoMatchLevel::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `GeoMatchLevel::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `GeoMatchLevel::NewFeature` is defined.
/// Specifically, when `geomatchlevel` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `GeoMatchLevel::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GeoMatchLevel {
    #[allow(missing_docs)] // documentation missing in model
    AreaCode,
    #[allow(missing_docs)] // documentation missing in model
    Country,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for GeoMatchLevel {
    fn from(s: &str) -> Self {
        match s {
            "AreaCode" => GeoMatchLevel::AreaCode,
            "Country" => GeoMatchLevel::Country,
            other => GeoMatchLevel::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for GeoMatchLevel {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(GeoMatchLevel::from(s))
    }
}
impl GeoMatchLevel {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            GeoMatchLevel::AreaCode => "AreaCode",
            GeoMatchLevel::Country => "Country",
            GeoMatchLevel::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AreaCode", "Country"]
    }
}
impl AsRef<str> for GeoMatchLevel {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `NumberSelectionBehavior`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let numberselectionbehavior = unimplemented!();
/// match numberselectionbehavior {
///     NumberSelectionBehavior::AvoidSticky => { /* ... */ },
///     NumberSelectionBehavior::PreferSticky => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `numberselectionbehavior` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NumberSelectionBehavior::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NumberSelectionBehavior::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NumberSelectionBehavior::NewFeature` is defined.
/// Specifically, when `numberselectionbehavior` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NumberSelectionBehavior::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NumberSelectionBehavior {
    #[allow(missing_docs)] // documentation missing in model
    AvoidSticky,
    #[allow(missing_docs)] // documentation missing in model
    PreferSticky,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NumberSelectionBehavior {
    fn from(s: &str) -> Self {
        match s {
            "AvoidSticky" => NumberSelectionBehavior::AvoidSticky,
            "PreferSticky" => NumberSelectionBehavior::PreferSticky,
            other => NumberSelectionBehavior::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for NumberSelectionBehavior {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NumberSelectionBehavior::from(s))
    }
}
impl NumberSelectionBehavior {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NumberSelectionBehavior::AvoidSticky => "AvoidSticky",
            NumberSelectionBehavior::PreferSticky => "PreferSticky",
            NumberSelectionBehavior::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AvoidSticky", "PreferSticky"]
    }
}
impl AsRef<str> for NumberSelectionBehavior {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Participant {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub phone_number: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub proxy_phone_number: std::option::Option<std::string::String>,
}
impl Participant {
    #[allow(missing_docs)] // documentation missing in model
    pub fn phone_number(&self) -> std::option::Option<&str> {
        self.phone_number.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn proxy_phone_number(&self) -> std::option::Option<&str> {
        self.proxy_phone_number.as_deref()
    }
}
impl std::fmt::Debug for Participant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Participant");
        formatter.field("phone_number", &"*** Sensitive Data Redacted ***");
        formatter.field("proxy_phone_number", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`Participant`](crate::model::Participant).
pub mod participant {

    /// A builder for [`Participant`](crate::model::Participant).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) phone_number: std::option::Option<std::string::String>,
        pub(crate) proxy_phone_number: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.phone_number = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn proxy_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.proxy_phone_number = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_proxy_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.proxy_phone_number = input;
            self
        }
        /// Consumes the builder and constructs a [`Participant`](crate::model::Participant).
        pub fn build(self) -> crate::model::Participant {
            crate::model::Participant {
                phone_number: self.phone_number,
                proxy_phone_number: self.proxy_phone_number,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("phone_number", &"*** Sensitive Data Redacted ***");
            formatter.field("proxy_phone_number", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl Participant {
    /// Creates a new builder-style object to manufacture [`Participant`](crate::model::Participant).
    pub fn builder() -> crate::model::participant::Builder {
        crate::model::participant::Builder::default()
    }
}

/// When writing a match expression against `Capability`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let capability = unimplemented!();
/// match capability {
///     Capability::Sms => { /* ... */ },
///     Capability::Voice => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `capability` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Capability::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Capability::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Capability::NewFeature` is defined.
/// Specifically, when `capability` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Capability::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Capability {
    #[allow(missing_docs)] // documentation missing in model
    Sms,
    #[allow(missing_docs)] // documentation missing in model
    Voice,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Capability {
    fn from(s: &str) -> Self {
        match s {
            "SMS" => Capability::Sms,
            "Voice" => Capability::Voice,
            other => Capability::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Capability {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Capability::from(s))
    }
}
impl Capability {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Capability::Sms => "SMS",
            Capability::Voice => "Voice",
            Capability::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SMS", "Voice"]
    }
}
impl AsRef<str> for Capability {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ProxySessionStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let proxysessionstatus = unimplemented!();
/// match proxysessionstatus {
///     ProxySessionStatus::Closed => { /* ... */ },
///     ProxySessionStatus::InProgress => { /* ... */ },
///     ProxySessionStatus::Open => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `proxysessionstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ProxySessionStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ProxySessionStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ProxySessionStatus::NewFeature` is defined.
/// Specifically, when `proxysessionstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ProxySessionStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProxySessionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Closed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Open,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ProxySessionStatus {
    fn from(s: &str) -> Self {
        match s {
            "Closed" => ProxySessionStatus::Closed,
            "InProgress" => ProxySessionStatus::InProgress,
            "Open" => ProxySessionStatus::Open,
            other => {
                ProxySessionStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ProxySessionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProxySessionStatus::from(s))
    }
}
impl ProxySessionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProxySessionStatus::Closed => "Closed",
            ProxySessionStatus::InProgress => "InProgress",
            ProxySessionStatus::Open => "Open",
            ProxySessionStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Closed", "InProgress", "Open"]
    }
}
impl AsRef<str> for ProxySessionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PhoneNumber {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub phone_number_id: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub e164_phone_number: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub country: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::PhoneNumberType>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub product_type: std::option::Option<crate::model::PhoneNumberProductType>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::PhoneNumberStatus>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub capabilities: std::option::Option<crate::model::PhoneNumberCapabilities>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub associations: std::option::Option<std::vec::Vec<crate::model::PhoneNumberAssociation>>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub calling_name: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub calling_name_status: std::option::Option<crate::model::CallingNameStatus>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub deletion_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub order_id: std::option::Option<std::string::String>,
}
impl PhoneNumber {
    #[allow(missing_docs)] // documentation missing in model
    pub fn phone_number_id(&self) -> std::option::Option<&str> {
        self.phone_number_id.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn e164_phone_number(&self) -> std::option::Option<&str> {
        self.e164_phone_number.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn country(&self) -> std::option::Option<&str> {
        self.country.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn r#type(&self) -> std::option::Option<&crate::model::PhoneNumberType> {
        self.r#type.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn product_type(&self) -> std::option::Option<&crate::model::PhoneNumberProductType> {
        self.product_type.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn status(&self) -> std::option::Option<&crate::model::PhoneNumberStatus> {
        self.status.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn capabilities(&self) -> std::option::Option<&crate::model::PhoneNumberCapabilities> {
        self.capabilities.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn associations(&self) -> std::option::Option<&[crate::model::PhoneNumberAssociation]> {
        self.associations.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn calling_name(&self) -> std::option::Option<&str> {
        self.calling_name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn calling_name_status(&self) -> std::option::Option<&crate::model::CallingNameStatus> {
        self.calling_name_status.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn created_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_timestamp.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn updated_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_timestamp.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn deletion_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.deletion_timestamp.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn order_id(&self) -> std::option::Option<&str> {
        self.order_id.as_deref()
    }
}
impl std::fmt::Debug for PhoneNumber {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PhoneNumber");
        formatter.field("phone_number_id", &"*** Sensitive Data Redacted ***");
        formatter.field("e164_phone_number", &"*** Sensitive Data Redacted ***");
        formatter.field("country", &self.country);
        formatter.field("r#type", &self.r#type);
        formatter.field("product_type", &self.product_type);
        formatter.field("status", &self.status);
        formatter.field("capabilities", &self.capabilities);
        formatter.field("associations", &self.associations);
        formatter.field("calling_name", &"*** Sensitive Data Redacted ***");
        formatter.field("calling_name_status", &self.calling_name_status);
        formatter.field("created_timestamp", &self.created_timestamp);
        formatter.field("updated_timestamp", &self.updated_timestamp);
        formatter.field("deletion_timestamp", &self.deletion_timestamp);
        formatter.field("order_id", &self.order_id);
        formatter.finish()
    }
}
/// See [`PhoneNumber`](crate::model::PhoneNumber).
pub mod phone_number {

    /// A builder for [`PhoneNumber`](crate::model::PhoneNumber).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) phone_number_id: std::option::Option<std::string::String>,
        pub(crate) e164_phone_number: std::option::Option<std::string::String>,
        pub(crate) country: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::PhoneNumberType>,
        pub(crate) product_type: std::option::Option<crate::model::PhoneNumberProductType>,
        pub(crate) status: std::option::Option<crate::model::PhoneNumberStatus>,
        pub(crate) capabilities: std::option::Option<crate::model::PhoneNumberCapabilities>,
        pub(crate) associations:
            std::option::Option<std::vec::Vec<crate::model::PhoneNumberAssociation>>,
        pub(crate) calling_name: std::option::Option<std::string::String>,
        pub(crate) calling_name_status: std::option::Option<crate::model::CallingNameStatus>,
        pub(crate) created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) deletion_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) order_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn phone_number_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_id = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_phone_number_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_id = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn e164_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.e164_phone_number = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_e164_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.e164_phone_number = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn country(mut self, input: impl Into<std::string::String>) -> Self {
            self.country = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_country(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.country = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn r#type(mut self, input: crate::model::PhoneNumberType) -> Self {
            self.r#type = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn product_type(mut self, input: crate::model::PhoneNumberProductType) -> Self {
            self.product_type = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_product_type(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberProductType>,
        ) -> Self {
            self.product_type = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn status(mut self, input: crate::model::PhoneNumberStatus) -> Self {
            self.status = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn capabilities(mut self, input: crate::model::PhoneNumberCapabilities) -> Self {
            self.capabilities = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_capabilities(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberCapabilities>,
        ) -> Self {
            self.capabilities = input;
            self
        }
        /// Appends an item to `associations`.
        ///
        /// To override the contents of this collection use [`set_associations`](Self::set_associations).
        ///
        pub fn associations(mut self, input: crate::model::PhoneNumberAssociation) -> Self {
            let mut v = self.associations.unwrap_or_default();
            v.push(input);
            self.associations = Some(v);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_associations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PhoneNumberAssociation>>,
        ) -> Self {
            self.associations = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn calling_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.calling_name = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_calling_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.calling_name = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn calling_name_status(mut self, input: crate::model::CallingNameStatus) -> Self {
            self.calling_name_status = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_calling_name_status(
            mut self,
            input: std::option::Option<crate::model::CallingNameStatus>,
        ) -> Self {
            self.calling_name_status = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn created_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_timestamp = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_created_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_timestamp = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn updated_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_timestamp = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_updated_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_timestamp = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn deletion_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.deletion_timestamp = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_deletion_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.deletion_timestamp = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn order_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.order_id = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_order_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.order_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PhoneNumber`](crate::model::PhoneNumber).
        pub fn build(self) -> crate::model::PhoneNumber {
            crate::model::PhoneNumber {
                phone_number_id: self.phone_number_id,
                e164_phone_number: self.e164_phone_number,
                country: self.country,
                r#type: self.r#type,
                product_type: self.product_type,
                status: self.status,
                capabilities: self.capabilities,
                associations: self.associations,
                calling_name: self.calling_name,
                calling_name_status: self.calling_name_status,
                created_timestamp: self.created_timestamp,
                updated_timestamp: self.updated_timestamp,
                deletion_timestamp: self.deletion_timestamp,
                order_id: self.order_id,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("phone_number_id", &"*** Sensitive Data Redacted ***");
            formatter.field("e164_phone_number", &"*** Sensitive Data Redacted ***");
            formatter.field("country", &self.country);
            formatter.field("r#type", &self.r#type);
            formatter.field("product_type", &self.product_type);
            formatter.field("status", &self.status);
            formatter.field("capabilities", &self.capabilities);
            formatter.field("associations", &self.associations);
            formatter.field("calling_name", &"*** Sensitive Data Redacted ***");
            formatter.field("calling_name_status", &self.calling_name_status);
            formatter.field("created_timestamp", &self.created_timestamp);
            formatter.field("updated_timestamp", &self.updated_timestamp);
            formatter.field("deletion_timestamp", &self.deletion_timestamp);
            formatter.field("order_id", &self.order_id);
            formatter.finish()
        }
    }
}
impl PhoneNumber {
    /// Creates a new builder-style object to manufacture [`PhoneNumber`](crate::model::PhoneNumber).
    pub fn builder() -> crate::model::phone_number::Builder {
        crate::model::phone_number::Builder::default()
    }
}

/// When writing a match expression against `CallingNameStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let callingnamestatus = unimplemented!();
/// match callingnamestatus {
///     CallingNameStatus::Unassigned => { /* ... */ },
///     CallingNameStatus::UpdateFailed => { /* ... */ },
///     CallingNameStatus::UpdateInProgress => { /* ... */ },
///     CallingNameStatus::UpdateSucceeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `callingnamestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CallingNameStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CallingNameStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CallingNameStatus::NewFeature` is defined.
/// Specifically, when `callingnamestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CallingNameStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CallingNameStatus {
    #[allow(missing_docs)] // documentation missing in model
    Unassigned,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    UpdateSucceeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CallingNameStatus {
    fn from(s: &str) -> Self {
        match s {
            "Unassigned" => CallingNameStatus::Unassigned,
            "UpdateFailed" => CallingNameStatus::UpdateFailed,
            "UpdateInProgress" => CallingNameStatus::UpdateInProgress,
            "UpdateSucceeded" => CallingNameStatus::UpdateSucceeded,
            other => {
                CallingNameStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for CallingNameStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CallingNameStatus::from(s))
    }
}
impl CallingNameStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CallingNameStatus::Unassigned => "Unassigned",
            CallingNameStatus::UpdateFailed => "UpdateFailed",
            CallingNameStatus::UpdateInProgress => "UpdateInProgress",
            CallingNameStatus::UpdateSucceeded => "UpdateSucceeded",
            CallingNameStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Unassigned",
            "UpdateFailed",
            "UpdateInProgress",
            "UpdateSucceeded",
        ]
    }
}
impl AsRef<str> for CallingNameStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PhoneNumberAssociation {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::PhoneNumberAssociationName>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub associated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl PhoneNumberAssociation {
    #[allow(missing_docs)] // documentation missing in model
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn name(&self) -> std::option::Option<&crate::model::PhoneNumberAssociationName> {
        self.name.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn associated_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.associated_timestamp.as_ref()
    }
}
/// See [`PhoneNumberAssociation`](crate::model::PhoneNumberAssociation).
pub mod phone_number_association {

    /// A builder for [`PhoneNumberAssociation`](crate::model::PhoneNumberAssociation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<crate::model::PhoneNumberAssociationName>,
        pub(crate) associated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn name(mut self, input: crate::model::PhoneNumberAssociationName) -> Self {
            self.name = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberAssociationName>,
        ) -> Self {
            self.name = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn associated_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.associated_timestamp = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_associated_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.associated_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`PhoneNumberAssociation`](crate::model::PhoneNumberAssociation).
        pub fn build(self) -> crate::model::PhoneNumberAssociation {
            crate::model::PhoneNumberAssociation {
                value: self.value,
                name: self.name,
                associated_timestamp: self.associated_timestamp,
            }
        }
    }
}
impl PhoneNumberAssociation {
    /// Creates a new builder-style object to manufacture [`PhoneNumberAssociation`](crate::model::PhoneNumberAssociation).
    pub fn builder() -> crate::model::phone_number_association::Builder {
        crate::model::phone_number_association::Builder::default()
    }
}

/// When writing a match expression against `PhoneNumberAssociationName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let phonenumberassociationname = unimplemented!();
/// match phonenumberassociationname {
///     PhoneNumberAssociationName::SipRuleId => { /* ... */ },
///     PhoneNumberAssociationName::VoiceConnectorGroupId => { /* ... */ },
///     PhoneNumberAssociationName::VoiceConnectorId => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `phonenumberassociationname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PhoneNumberAssociationName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PhoneNumberAssociationName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PhoneNumberAssociationName::NewFeature` is defined.
/// Specifically, when `phonenumberassociationname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PhoneNumberAssociationName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PhoneNumberAssociationName {
    #[allow(missing_docs)] // documentation missing in model
    SipRuleId,
    #[allow(missing_docs)] // documentation missing in model
    VoiceConnectorGroupId,
    #[allow(missing_docs)] // documentation missing in model
    VoiceConnectorId,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PhoneNumberAssociationName {
    fn from(s: &str) -> Self {
        match s {
            "SipRuleId" => PhoneNumberAssociationName::SipRuleId,
            "VoiceConnectorGroupId" => PhoneNumberAssociationName::VoiceConnectorGroupId,
            "VoiceConnectorId" => PhoneNumberAssociationName::VoiceConnectorId,
            other => PhoneNumberAssociationName::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for PhoneNumberAssociationName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PhoneNumberAssociationName::from(s))
    }
}
impl PhoneNumberAssociationName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PhoneNumberAssociationName::SipRuleId => "SipRuleId",
            PhoneNumberAssociationName::VoiceConnectorGroupId => "VoiceConnectorGroupId",
            PhoneNumberAssociationName::VoiceConnectorId => "VoiceConnectorId",
            PhoneNumberAssociationName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SipRuleId", "VoiceConnectorGroupId", "VoiceConnectorId"]
    }
}
impl AsRef<str> for PhoneNumberAssociationName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PhoneNumberCapabilities {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub inbound_call: std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub outbound_call: std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub inbound_sms: std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub outbound_sms: std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub inbound_mms: std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub outbound_mms: std::option::Option<bool>,
}
impl PhoneNumberCapabilities {
    #[allow(missing_docs)] // documentation missing in model
    pub fn inbound_call(&self) -> std::option::Option<bool> {
        self.inbound_call
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn outbound_call(&self) -> std::option::Option<bool> {
        self.outbound_call
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn inbound_sms(&self) -> std::option::Option<bool> {
        self.inbound_sms
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn outbound_sms(&self) -> std::option::Option<bool> {
        self.outbound_sms
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn inbound_mms(&self) -> std::option::Option<bool> {
        self.inbound_mms
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn outbound_mms(&self) -> std::option::Option<bool> {
        self.outbound_mms
    }
}
/// See [`PhoneNumberCapabilities`](crate::model::PhoneNumberCapabilities).
pub mod phone_number_capabilities {

    /// A builder for [`PhoneNumberCapabilities`](crate::model::PhoneNumberCapabilities).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) inbound_call: std::option::Option<bool>,
        pub(crate) outbound_call: std::option::Option<bool>,
        pub(crate) inbound_sms: std::option::Option<bool>,
        pub(crate) outbound_sms: std::option::Option<bool>,
        pub(crate) inbound_mms: std::option::Option<bool>,
        pub(crate) outbound_mms: std::option::Option<bool>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn inbound_call(mut self, input: bool) -> Self {
            self.inbound_call = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_inbound_call(mut self, input: std::option::Option<bool>) -> Self {
            self.inbound_call = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn outbound_call(mut self, input: bool) -> Self {
            self.outbound_call = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_outbound_call(mut self, input: std::option::Option<bool>) -> Self {
            self.outbound_call = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn inbound_sms(mut self, input: bool) -> Self {
            self.inbound_sms = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_inbound_sms(mut self, input: std::option::Option<bool>) -> Self {
            self.inbound_sms = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn outbound_sms(mut self, input: bool) -> Self {
            self.outbound_sms = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_outbound_sms(mut self, input: std::option::Option<bool>) -> Self {
            self.outbound_sms = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn inbound_mms(mut self, input: bool) -> Self {
            self.inbound_mms = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_inbound_mms(mut self, input: std::option::Option<bool>) -> Self {
            self.inbound_mms = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn outbound_mms(mut self, input: bool) -> Self {
            self.outbound_mms = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_outbound_mms(mut self, input: std::option::Option<bool>) -> Self {
            self.outbound_mms = input;
            self
        }
        /// Consumes the builder and constructs a [`PhoneNumberCapabilities`](crate::model::PhoneNumberCapabilities).
        pub fn build(self) -> crate::model::PhoneNumberCapabilities {
            crate::model::PhoneNumberCapabilities {
                inbound_call: self.inbound_call,
                outbound_call: self.outbound_call,
                inbound_sms: self.inbound_sms,
                outbound_sms: self.outbound_sms,
                inbound_mms: self.inbound_mms,
                outbound_mms: self.outbound_mms,
            }
        }
    }
}
impl PhoneNumberCapabilities {
    /// Creates a new builder-style object to manufacture [`PhoneNumberCapabilities`](crate::model::PhoneNumberCapabilities).
    pub fn builder() -> crate::model::phone_number_capabilities::Builder {
        crate::model::phone_number_capabilities::Builder::default()
    }
}

/// When writing a match expression against `PhoneNumberStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let phonenumberstatus = unimplemented!();
/// match phonenumberstatus {
///     PhoneNumberStatus::AcquireFailed => { /* ... */ },
///     PhoneNumberStatus::AcquireInProgress => { /* ... */ },
///     PhoneNumberStatus::Assigned => { /* ... */ },
///     PhoneNumberStatus::Cancelled => { /* ... */ },
///     PhoneNumberStatus::DeleteFailed => { /* ... */ },
///     PhoneNumberStatus::DeleteInProgress => { /* ... */ },
///     PhoneNumberStatus::PortinCancelRequested => { /* ... */ },
///     PhoneNumberStatus::PortinInProgress => { /* ... */ },
///     PhoneNumberStatus::ReleaseFailed => { /* ... */ },
///     PhoneNumberStatus::ReleaseInProgress => { /* ... */ },
///     PhoneNumberStatus::Unassigned => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `phonenumberstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PhoneNumberStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PhoneNumberStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PhoneNumberStatus::NewFeature` is defined.
/// Specifically, when `phonenumberstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PhoneNumberStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PhoneNumberStatus {
    #[allow(missing_docs)] // documentation missing in model
    AcquireFailed,
    #[allow(missing_docs)] // documentation missing in model
    AcquireInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Assigned,
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    PortinCancelRequested,
    #[allow(missing_docs)] // documentation missing in model
    PortinInProgress,
    #[allow(missing_docs)] // documentation missing in model
    ReleaseFailed,
    #[allow(missing_docs)] // documentation missing in model
    ReleaseInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Unassigned,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PhoneNumberStatus {
    fn from(s: &str) -> Self {
        match s {
            "AcquireFailed" => PhoneNumberStatus::AcquireFailed,
            "AcquireInProgress" => PhoneNumberStatus::AcquireInProgress,
            "Assigned" => PhoneNumberStatus::Assigned,
            "Cancelled" => PhoneNumberStatus::Cancelled,
            "DeleteFailed" => PhoneNumberStatus::DeleteFailed,
            "DeleteInProgress" => PhoneNumberStatus::DeleteInProgress,
            "PortinCancelRequested" => PhoneNumberStatus::PortinCancelRequested,
            "PortinInProgress" => PhoneNumberStatus::PortinInProgress,
            "ReleaseFailed" => PhoneNumberStatus::ReleaseFailed,
            "ReleaseInProgress" => PhoneNumberStatus::ReleaseInProgress,
            "Unassigned" => PhoneNumberStatus::Unassigned,
            other => {
                PhoneNumberStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for PhoneNumberStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PhoneNumberStatus::from(s))
    }
}
impl PhoneNumberStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PhoneNumberStatus::AcquireFailed => "AcquireFailed",
            PhoneNumberStatus::AcquireInProgress => "AcquireInProgress",
            PhoneNumberStatus::Assigned => "Assigned",
            PhoneNumberStatus::Cancelled => "Cancelled",
            PhoneNumberStatus::DeleteFailed => "DeleteFailed",
            PhoneNumberStatus::DeleteInProgress => "DeleteInProgress",
            PhoneNumberStatus::PortinCancelRequested => "PortinCancelRequested",
            PhoneNumberStatus::PortinInProgress => "PortinInProgress",
            PhoneNumberStatus::ReleaseFailed => "ReleaseFailed",
            PhoneNumberStatus::ReleaseInProgress => "ReleaseInProgress",
            PhoneNumberStatus::Unassigned => "Unassigned",
            PhoneNumberStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AcquireFailed",
            "AcquireInProgress",
            "Assigned",
            "Cancelled",
            "DeleteFailed",
            "DeleteInProgress",
            "PortinCancelRequested",
            "PortinInProgress",
            "ReleaseFailed",
            "ReleaseInProgress",
            "Unassigned",
        ]
    }
}
impl AsRef<str> for PhoneNumberStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PhoneNumberProductType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let phonenumberproducttype = unimplemented!();
/// match phonenumberproducttype {
///     PhoneNumberProductType::SipMediaApplicationDialIn => { /* ... */ },
///     PhoneNumberProductType::VoiceConnector => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `phonenumberproducttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PhoneNumberProductType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PhoneNumberProductType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PhoneNumberProductType::NewFeature` is defined.
/// Specifically, when `phonenumberproducttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PhoneNumberProductType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PhoneNumberProductType {
    #[allow(missing_docs)] // documentation missing in model
    SipMediaApplicationDialIn,
    #[allow(missing_docs)] // documentation missing in model
    VoiceConnector,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PhoneNumberProductType {
    fn from(s: &str) -> Self {
        match s {
            "SipMediaApplicationDialIn" => PhoneNumberProductType::SipMediaApplicationDialIn,
            "VoiceConnector" => PhoneNumberProductType::VoiceConnector,
            other => {
                PhoneNumberProductType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for PhoneNumberProductType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PhoneNumberProductType::from(s))
    }
}
impl PhoneNumberProductType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PhoneNumberProductType::SipMediaApplicationDialIn => "SipMediaApplicationDialIn",
            PhoneNumberProductType::VoiceConnector => "VoiceConnector",
            PhoneNumberProductType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SipMediaApplicationDialIn", "VoiceConnector"]
    }
}
impl AsRef<str> for PhoneNumberProductType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PhoneNumberType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let phonenumbertype = unimplemented!();
/// match phonenumbertype {
///     PhoneNumberType::Local => { /* ... */ },
///     PhoneNumberType::TollFree => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `phonenumbertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PhoneNumberType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PhoneNumberType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PhoneNumberType::NewFeature` is defined.
/// Specifically, when `phonenumbertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PhoneNumberType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PhoneNumberType {
    #[allow(missing_docs)] // documentation missing in model
    Local,
    #[allow(missing_docs)] // documentation missing in model
    TollFree,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PhoneNumberType {
    fn from(s: &str) -> Self {
        match s {
            "Local" => PhoneNumberType::Local,
            "TollFree" => PhoneNumberType::TollFree,
            other => PhoneNumberType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PhoneNumberType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PhoneNumberType::from(s))
    }
}
impl PhoneNumberType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PhoneNumberType::Local => "Local",
            PhoneNumberType::TollFree => "TollFree",
            PhoneNumberType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Local", "TollFree"]
    }
}
impl AsRef<str> for PhoneNumberType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VoiceConnectorSettings {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub cdr_bucket: std::option::Option<std::string::String>,
}
impl VoiceConnectorSettings {
    #[allow(missing_docs)] // documentation missing in model
    pub fn cdr_bucket(&self) -> std::option::Option<&str> {
        self.cdr_bucket.as_deref()
    }
}
/// See [`VoiceConnectorSettings`](crate::model::VoiceConnectorSettings).
pub mod voice_connector_settings {

    /// A builder for [`VoiceConnectorSettings`](crate::model::VoiceConnectorSettings).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cdr_bucket: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn cdr_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.cdr_bucket = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_cdr_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cdr_bucket = input;
            self
        }
        /// Consumes the builder and constructs a [`VoiceConnectorSettings`](crate::model::VoiceConnectorSettings).
        pub fn build(self) -> crate::model::VoiceConnectorSettings {
            crate::model::VoiceConnectorSettings {
                cdr_bucket: self.cdr_bucket,
            }
        }
    }
}
impl VoiceConnectorSettings {
    /// Creates a new builder-style object to manufacture [`VoiceConnectorSettings`](crate::model::VoiceConnectorSettings).
    pub fn builder() -> crate::model::voice_connector_settings::Builder {
        crate::model::voice_connector_settings::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Credential {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub username: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub password: std::option::Option<std::string::String>,
}
impl Credential {
    #[allow(missing_docs)] // documentation missing in model
    pub fn username(&self) -> std::option::Option<&str> {
        self.username.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn password(&self) -> std::option::Option<&str> {
        self.password.as_deref()
    }
}
impl std::fmt::Debug for Credential {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Credential");
        formatter.field("username", &"*** Sensitive Data Redacted ***");
        formatter.field("password", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`Credential`](crate::model::Credential).
pub mod credential {

    /// A builder for [`Credential`](crate::model::Credential).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) username: std::option::Option<std::string::String>,
        pub(crate) password: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.username = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.username = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn password(mut self, input: impl Into<std::string::String>) -> Self {
            self.password = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.password = input;
            self
        }
        /// Consumes the builder and constructs a [`Credential`](crate::model::Credential).
        pub fn build(self) -> crate::model::Credential {
            crate::model::Credential {
                username: self.username,
                password: self.password,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("username", &"*** Sensitive Data Redacted ***");
            formatter.field("password", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl Credential {
    /// Creates a new builder-style object to manufacture [`Credential`](crate::model::Credential).
    pub fn builder() -> crate::model::credential::Builder {
        crate::model::credential::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Termination {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub cps_limit: std::option::Option<i32>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub default_phone_number: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub calling_regions: std::option::Option<std::vec::Vec<std::string::String>>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub cidr_allowed_list: std::option::Option<std::vec::Vec<std::string::String>>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub disabled: std::option::Option<bool>,
}
impl Termination {
    #[allow(missing_docs)] // documentation missing in model
    pub fn cps_limit(&self) -> std::option::Option<i32> {
        self.cps_limit
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn default_phone_number(&self) -> std::option::Option<&str> {
        self.default_phone_number.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn calling_regions(&self) -> std::option::Option<&[std::string::String]> {
        self.calling_regions.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn cidr_allowed_list(&self) -> std::option::Option<&[std::string::String]> {
        self.cidr_allowed_list.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn disabled(&self) -> std::option::Option<bool> {
        self.disabled
    }
}
impl std::fmt::Debug for Termination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Termination");
        formatter.field("cps_limit", &self.cps_limit);
        formatter.field("default_phone_number", &"*** Sensitive Data Redacted ***");
        formatter.field("calling_regions", &self.calling_regions);
        formatter.field("cidr_allowed_list", &self.cidr_allowed_list);
        formatter.field("disabled", &self.disabled);
        formatter.finish()
    }
}
/// See [`Termination`](crate::model::Termination).
pub mod termination {

    /// A builder for [`Termination`](crate::model::Termination).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) cps_limit: std::option::Option<i32>,
        pub(crate) default_phone_number: std::option::Option<std::string::String>,
        pub(crate) calling_regions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) cidr_allowed_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) disabled: std::option::Option<bool>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn cps_limit(mut self, input: i32) -> Self {
            self.cps_limit = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_cps_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.cps_limit = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn default_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_phone_number = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_default_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_phone_number = input;
            self
        }
        /// Appends an item to `calling_regions`.
        ///
        /// To override the contents of this collection use [`set_calling_regions`](Self::set_calling_regions).
        ///
        pub fn calling_regions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.calling_regions.unwrap_or_default();
            v.push(input.into());
            self.calling_regions = Some(v);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_calling_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.calling_regions = input;
            self
        }
        /// Appends an item to `cidr_allowed_list`.
        ///
        /// To override the contents of this collection use [`set_cidr_allowed_list`](Self::set_cidr_allowed_list).
        ///
        pub fn cidr_allowed_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.cidr_allowed_list.unwrap_or_default();
            v.push(input.into());
            self.cidr_allowed_list = Some(v);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_cidr_allowed_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.cidr_allowed_list = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn disabled(mut self, input: bool) -> Self {
            self.disabled = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_disabled(mut self, input: std::option::Option<bool>) -> Self {
            self.disabled = input;
            self
        }
        /// Consumes the builder and constructs a [`Termination`](crate::model::Termination).
        pub fn build(self) -> crate::model::Termination {
            crate::model::Termination {
                cps_limit: self.cps_limit,
                default_phone_number: self.default_phone_number,
                calling_regions: self.calling_regions,
                cidr_allowed_list: self.cidr_allowed_list,
                disabled: self.disabled,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("cps_limit", &self.cps_limit);
            formatter.field("default_phone_number", &"*** Sensitive Data Redacted ***");
            formatter.field("calling_regions", &self.calling_regions);
            formatter.field("cidr_allowed_list", &self.cidr_allowed_list);
            formatter.field("disabled", &self.disabled);
            formatter.finish()
        }
    }
}
impl Termination {
    /// Creates a new builder-style object to manufacture [`Termination`](crate::model::Termination).
    pub fn builder() -> crate::model::termination::Builder {
        crate::model::termination::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StreamingConfiguration {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub data_retention_in_hours: std::option::Option<i32>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub disabled: std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub streaming_notification_targets:
        std::option::Option<std::vec::Vec<crate::model::StreamingNotificationTarget>>,
}
impl StreamingConfiguration {
    #[allow(missing_docs)] // documentation missing in model
    pub fn data_retention_in_hours(&self) -> std::option::Option<i32> {
        self.data_retention_in_hours
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn disabled(&self) -> std::option::Option<bool> {
        self.disabled
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn streaming_notification_targets(
        &self,
    ) -> std::option::Option<&[crate::model::StreamingNotificationTarget]> {
        self.streaming_notification_targets.as_deref()
    }
}
/// See [`StreamingConfiguration`](crate::model::StreamingConfiguration).
pub mod streaming_configuration {

    /// A builder for [`StreamingConfiguration`](crate::model::StreamingConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_retention_in_hours: std::option::Option<i32>,
        pub(crate) disabled: std::option::Option<bool>,
        pub(crate) streaming_notification_targets:
            std::option::Option<std::vec::Vec<crate::model::StreamingNotificationTarget>>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn data_retention_in_hours(mut self, input: i32) -> Self {
            self.data_retention_in_hours = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_data_retention_in_hours(mut self, input: std::option::Option<i32>) -> Self {
            self.data_retention_in_hours = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn disabled(mut self, input: bool) -> Self {
            self.disabled = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_disabled(mut self, input: std::option::Option<bool>) -> Self {
            self.disabled = input;
            self
        }
        /// Appends an item to `streaming_notification_targets`.
        ///
        /// To override the contents of this collection use [`set_streaming_notification_targets`](Self::set_streaming_notification_targets).
        ///
        pub fn streaming_notification_targets(
            mut self,
            input: crate::model::StreamingNotificationTarget,
        ) -> Self {
            let mut v = self.streaming_notification_targets.unwrap_or_default();
            v.push(input);
            self.streaming_notification_targets = Some(v);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_streaming_notification_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StreamingNotificationTarget>>,
        ) -> Self {
            self.streaming_notification_targets = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamingConfiguration`](crate::model::StreamingConfiguration).
        pub fn build(self) -> crate::model::StreamingConfiguration {
            crate::model::StreamingConfiguration {
                data_retention_in_hours: self.data_retention_in_hours,
                disabled: self.disabled,
                streaming_notification_targets: self.streaming_notification_targets,
            }
        }
    }
}
impl StreamingConfiguration {
    /// Creates a new builder-style object to manufacture [`StreamingConfiguration`](crate::model::StreamingConfiguration).
    pub fn builder() -> crate::model::streaming_configuration::Builder {
        crate::model::streaming_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StreamingNotificationTarget {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub notification_target: std::option::Option<crate::model::NotificationTarget>,
}
impl StreamingNotificationTarget {
    #[allow(missing_docs)] // documentation missing in model
    pub fn notification_target(&self) -> std::option::Option<&crate::model::NotificationTarget> {
        self.notification_target.as_ref()
    }
}
/// See [`StreamingNotificationTarget`](crate::model::StreamingNotificationTarget).
pub mod streaming_notification_target {

    /// A builder for [`StreamingNotificationTarget`](crate::model::StreamingNotificationTarget).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) notification_target: std::option::Option<crate::model::NotificationTarget>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn notification_target(mut self, input: crate::model::NotificationTarget) -> Self {
            self.notification_target = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_notification_target(
            mut self,
            input: std::option::Option<crate::model::NotificationTarget>,
        ) -> Self {
            self.notification_target = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamingNotificationTarget`](crate::model::StreamingNotificationTarget).
        pub fn build(self) -> crate::model::StreamingNotificationTarget {
            crate::model::StreamingNotificationTarget {
                notification_target: self.notification_target,
            }
        }
    }
}
impl StreamingNotificationTarget {
    /// Creates a new builder-style object to manufacture [`StreamingNotificationTarget`](crate::model::StreamingNotificationTarget).
    pub fn builder() -> crate::model::streaming_notification_target::Builder {
        crate::model::streaming_notification_target::Builder::default()
    }
}

/// When writing a match expression against `NotificationTarget`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let notificationtarget = unimplemented!();
/// match notificationtarget {
///     NotificationTarget::EventBridge => { /* ... */ },
///     NotificationTarget::Sns => { /* ... */ },
///     NotificationTarget::Sqs => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `notificationtarget` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NotificationTarget::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NotificationTarget::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NotificationTarget::NewFeature` is defined.
/// Specifically, when `notificationtarget` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NotificationTarget::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotificationTarget {
    #[allow(missing_docs)] // documentation missing in model
    EventBridge,
    #[allow(missing_docs)] // documentation missing in model
    Sns,
    #[allow(missing_docs)] // documentation missing in model
    Sqs,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NotificationTarget {
    fn from(s: &str) -> Self {
        match s {
            "EventBridge" => NotificationTarget::EventBridge,
            "SNS" => NotificationTarget::Sns,
            "SQS" => NotificationTarget::Sqs,
            other => {
                NotificationTarget::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for NotificationTarget {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotificationTarget::from(s))
    }
}
impl NotificationTarget {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NotificationTarget::EventBridge => "EventBridge",
            NotificationTarget::Sns => "SNS",
            NotificationTarget::Sqs => "SQS",
            NotificationTarget::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EventBridge", "SNS", "SQS"]
    }
}
impl AsRef<str> for NotificationTarget {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Proxy {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub default_session_expiry_minutes: std::option::Option<i32>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub disabled: std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub fall_back_phone_number: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub phone_number_countries: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl Proxy {
    #[allow(missing_docs)] // documentation missing in model
    pub fn default_session_expiry_minutes(&self) -> std::option::Option<i32> {
        self.default_session_expiry_minutes
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn disabled(&self) -> std::option::Option<bool> {
        self.disabled
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn fall_back_phone_number(&self) -> std::option::Option<&str> {
        self.fall_back_phone_number.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn phone_number_countries(&self) -> std::option::Option<&[std::string::String]> {
        self.phone_number_countries.as_deref()
    }
}
impl std::fmt::Debug for Proxy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Proxy");
        formatter.field(
            "default_session_expiry_minutes",
            &self.default_session_expiry_minutes,
        );
        formatter.field("disabled", &self.disabled);
        formatter.field("fall_back_phone_number", &"*** Sensitive Data Redacted ***");
        formatter.field("phone_number_countries", &self.phone_number_countries);
        formatter.finish()
    }
}
/// See [`Proxy`](crate::model::Proxy).
pub mod proxy {

    /// A builder for [`Proxy`](crate::model::Proxy).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) default_session_expiry_minutes: std::option::Option<i32>,
        pub(crate) disabled: std::option::Option<bool>,
        pub(crate) fall_back_phone_number: std::option::Option<std::string::String>,
        pub(crate) phone_number_countries: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn default_session_expiry_minutes(mut self, input: i32) -> Self {
            self.default_session_expiry_minutes = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_default_session_expiry_minutes(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.default_session_expiry_minutes = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn disabled(mut self, input: bool) -> Self {
            self.disabled = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_disabled(mut self, input: std::option::Option<bool>) -> Self {
            self.disabled = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn fall_back_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.fall_back_phone_number = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_fall_back_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.fall_back_phone_number = input;
            self
        }
        /// Appends an item to `phone_number_countries`.
        ///
        /// To override the contents of this collection use [`set_phone_number_countries`](Self::set_phone_number_countries).
        ///
        pub fn phone_number_countries(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.phone_number_countries.unwrap_or_default();
            v.push(input.into());
            self.phone_number_countries = Some(v);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_phone_number_countries(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.phone_number_countries = input;
            self
        }
        /// Consumes the builder and constructs a [`Proxy`](crate::model::Proxy).
        pub fn build(self) -> crate::model::Proxy {
            crate::model::Proxy {
                default_session_expiry_minutes: self.default_session_expiry_minutes,
                disabled: self.disabled,
                fall_back_phone_number: self.fall_back_phone_number,
                phone_number_countries: self.phone_number_countries,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field(
                "default_session_expiry_minutes",
                &self.default_session_expiry_minutes,
            );
            formatter.field("disabled", &self.disabled);
            formatter.field("fall_back_phone_number", &"*** Sensitive Data Redacted ***");
            formatter.field("phone_number_countries", &self.phone_number_countries);
            formatter.finish()
        }
    }
}
impl Proxy {
    /// Creates a new builder-style object to manufacture [`Proxy`](crate::model::Proxy).
    pub fn builder() -> crate::model::proxy::Builder {
        crate::model::proxy::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Origination {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub routes: std::option::Option<std::vec::Vec<crate::model::OriginationRoute>>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub disabled: std::option::Option<bool>,
}
impl Origination {
    #[allow(missing_docs)] // documentation missing in model
    pub fn routes(&self) -> std::option::Option<&[crate::model::OriginationRoute]> {
        self.routes.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn disabled(&self) -> std::option::Option<bool> {
        self.disabled
    }
}
/// See [`Origination`](crate::model::Origination).
pub mod origination {

    /// A builder for [`Origination`](crate::model::Origination).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) routes: std::option::Option<std::vec::Vec<crate::model::OriginationRoute>>,
        pub(crate) disabled: std::option::Option<bool>,
    }
    impl Builder {
        /// Appends an item to `routes`.
        ///
        /// To override the contents of this collection use [`set_routes`](Self::set_routes).
        ///
        pub fn routes(mut self, input: crate::model::OriginationRoute) -> Self {
            let mut v = self.routes.unwrap_or_default();
            v.push(input);
            self.routes = Some(v);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_routes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::OriginationRoute>>,
        ) -> Self {
            self.routes = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn disabled(mut self, input: bool) -> Self {
            self.disabled = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_disabled(mut self, input: std::option::Option<bool>) -> Self {
            self.disabled = input;
            self
        }
        /// Consumes the builder and constructs a [`Origination`](crate::model::Origination).
        pub fn build(self) -> crate::model::Origination {
            crate::model::Origination {
                routes: self.routes,
                disabled: self.disabled,
            }
        }
    }
}
impl Origination {
    /// Creates a new builder-style object to manufacture [`Origination`](crate::model::Origination).
    pub fn builder() -> crate::model::origination::Builder {
        crate::model::origination::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OriginationRoute {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub host: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub port: std::option::Option<i32>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub protocol: std::option::Option<crate::model::OriginationRouteProtocol>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub priority: std::option::Option<i32>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub weight: std::option::Option<i32>,
}
impl OriginationRoute {
    #[allow(missing_docs)] // documentation missing in model
    pub fn host(&self) -> std::option::Option<&str> {
        self.host.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn port(&self) -> std::option::Option<i32> {
        self.port
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn protocol(&self) -> std::option::Option<&crate::model::OriginationRouteProtocol> {
        self.protocol.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn priority(&self) -> std::option::Option<i32> {
        self.priority
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn weight(&self) -> std::option::Option<i32> {
        self.weight
    }
}
/// See [`OriginationRoute`](crate::model::OriginationRoute).
pub mod origination_route {

    /// A builder for [`OriginationRoute`](crate::model::OriginationRoute).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) host: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) protocol: std::option::Option<crate::model::OriginationRouteProtocol>,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) weight: std::option::Option<i32>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn host(mut self, input: impl Into<std::string::String>) -> Self {
            self.host = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_host(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn protocol(mut self, input: crate::model::OriginationRouteProtocol) -> Self {
            self.protocol = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_protocol(
            mut self,
            input: std::option::Option<crate::model::OriginationRouteProtocol>,
        ) -> Self {
            self.protocol = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn weight(mut self, input: i32) -> Self {
            self.weight = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_weight(mut self, input: std::option::Option<i32>) -> Self {
            self.weight = input;
            self
        }
        /// Consumes the builder and constructs a [`OriginationRoute`](crate::model::OriginationRoute).
        pub fn build(self) -> crate::model::OriginationRoute {
            crate::model::OriginationRoute {
                host: self.host,
                port: self.port,
                protocol: self.protocol,
                priority: self.priority,
                weight: self.weight,
            }
        }
    }
}
impl OriginationRoute {
    /// Creates a new builder-style object to manufacture [`OriginationRoute`](crate::model::OriginationRoute).
    pub fn builder() -> crate::model::origination_route::Builder {
        crate::model::origination_route::Builder::default()
    }
}

/// When writing a match expression against `OriginationRouteProtocol`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let originationrouteprotocol = unimplemented!();
/// match originationrouteprotocol {
///     OriginationRouteProtocol::Tcp => { /* ... */ },
///     OriginationRouteProtocol::Udp => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `originationrouteprotocol` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OriginationRouteProtocol::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OriginationRouteProtocol::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OriginationRouteProtocol::NewFeature` is defined.
/// Specifically, when `originationrouteprotocol` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OriginationRouteProtocol::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OriginationRouteProtocol {
    #[allow(missing_docs)] // documentation missing in model
    Tcp,
    #[allow(missing_docs)] // documentation missing in model
    Udp,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OriginationRouteProtocol {
    fn from(s: &str) -> Self {
        match s {
            "TCP" => OriginationRouteProtocol::Tcp,
            "UDP" => OriginationRouteProtocol::Udp,
            other => OriginationRouteProtocol::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for OriginationRouteProtocol {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OriginationRouteProtocol::from(s))
    }
}
impl OriginationRouteProtocol {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OriginationRouteProtocol::Tcp => "TCP",
            OriginationRouteProtocol::Udp => "UDP",
            OriginationRouteProtocol::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["TCP", "UDP"]
    }
}
impl AsRef<str> for OriginationRouteProtocol {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoggingConfiguration {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub enable_sip_logs: std::option::Option<bool>,
}
impl LoggingConfiguration {
    #[allow(missing_docs)] // documentation missing in model
    pub fn enable_sip_logs(&self) -> std::option::Option<bool> {
        self.enable_sip_logs
    }
}
/// See [`LoggingConfiguration`](crate::model::LoggingConfiguration).
pub mod logging_configuration {

    /// A builder for [`LoggingConfiguration`](crate::model::LoggingConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable_sip_logs: std::option::Option<bool>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn enable_sip_logs(mut self, input: bool) -> Self {
            self.enable_sip_logs = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_enable_sip_logs(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_sip_logs = input;
            self
        }
        /// Consumes the builder and constructs a [`LoggingConfiguration`](crate::model::LoggingConfiguration).
        pub fn build(self) -> crate::model::LoggingConfiguration {
            crate::model::LoggingConfiguration {
                enable_sip_logs: self.enable_sip_logs,
            }
        }
    }
}
impl LoggingConfiguration {
    /// Creates a new builder-style object to manufacture [`LoggingConfiguration`](crate::model::LoggingConfiguration).
    pub fn builder() -> crate::model::logging_configuration::Builder {
        crate::model::logging_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EmergencyCallingConfiguration {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub dnis: std::option::Option<std::vec::Vec<crate::model::DnisEmergencyCallingConfiguration>>,
}
impl EmergencyCallingConfiguration {
    #[allow(missing_docs)] // documentation missing in model
    pub fn dnis(&self) -> std::option::Option<&[crate::model::DnisEmergencyCallingConfiguration]> {
        self.dnis.as_deref()
    }
}
/// See [`EmergencyCallingConfiguration`](crate::model::EmergencyCallingConfiguration).
pub mod emergency_calling_configuration {

    /// A builder for [`EmergencyCallingConfiguration`](crate::model::EmergencyCallingConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dnis:
            std::option::Option<std::vec::Vec<crate::model::DnisEmergencyCallingConfiguration>>,
    }
    impl Builder {
        /// Appends an item to `dnis`.
        ///
        /// To override the contents of this collection use [`set_dnis`](Self::set_dnis).
        ///
        pub fn dnis(mut self, input: crate::model::DnisEmergencyCallingConfiguration) -> Self {
            let mut v = self.dnis.unwrap_or_default();
            v.push(input);
            self.dnis = Some(v);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_dnis(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::DnisEmergencyCallingConfiguration>,
            >,
        ) -> Self {
            self.dnis = input;
            self
        }
        /// Consumes the builder and constructs a [`EmergencyCallingConfiguration`](crate::model::EmergencyCallingConfiguration).
        pub fn build(self) -> crate::model::EmergencyCallingConfiguration {
            crate::model::EmergencyCallingConfiguration { dnis: self.dnis }
        }
    }
}
impl EmergencyCallingConfiguration {
    /// Creates a new builder-style object to manufacture [`EmergencyCallingConfiguration`](crate::model::EmergencyCallingConfiguration).
    pub fn builder() -> crate::model::emergency_calling_configuration::Builder {
        crate::model::emergency_calling_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DnisEmergencyCallingConfiguration {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub emergency_phone_number: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub test_phone_number: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub calling_country: std::option::Option<std::string::String>,
}
impl DnisEmergencyCallingConfiguration {
    #[allow(missing_docs)] // documentation missing in model
    pub fn emergency_phone_number(&self) -> std::option::Option<&str> {
        self.emergency_phone_number.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn test_phone_number(&self) -> std::option::Option<&str> {
        self.test_phone_number.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn calling_country(&self) -> std::option::Option<&str> {
        self.calling_country.as_deref()
    }
}
impl std::fmt::Debug for DnisEmergencyCallingConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DnisEmergencyCallingConfiguration");
        formatter.field("emergency_phone_number", &"*** Sensitive Data Redacted ***");
        formatter.field("test_phone_number", &"*** Sensitive Data Redacted ***");
        formatter.field("calling_country", &self.calling_country);
        formatter.finish()
    }
}
/// See [`DnisEmergencyCallingConfiguration`](crate::model::DnisEmergencyCallingConfiguration).
pub mod dnis_emergency_calling_configuration {

    /// A builder for [`DnisEmergencyCallingConfiguration`](crate::model::DnisEmergencyCallingConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) emergency_phone_number: std::option::Option<std::string::String>,
        pub(crate) test_phone_number: std::option::Option<std::string::String>,
        pub(crate) calling_country: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn emergency_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.emergency_phone_number = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_emergency_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.emergency_phone_number = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn test_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.test_phone_number = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_test_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.test_phone_number = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn calling_country(mut self, input: impl Into<std::string::String>) -> Self {
            self.calling_country = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_calling_country(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.calling_country = input;
            self
        }
        /// Consumes the builder and constructs a [`DnisEmergencyCallingConfiguration`](crate::model::DnisEmergencyCallingConfiguration).
        pub fn build(self) -> crate::model::DnisEmergencyCallingConfiguration {
            crate::model::DnisEmergencyCallingConfiguration {
                emergency_phone_number: self.emergency_phone_number,
                test_phone_number: self.test_phone_number,
                calling_country: self.calling_country,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("emergency_phone_number", &"*** Sensitive Data Redacted ***");
            formatter.field("test_phone_number", &"*** Sensitive Data Redacted ***");
            formatter.field("calling_country", &self.calling_country);
            formatter.finish()
        }
    }
}
impl DnisEmergencyCallingConfiguration {
    /// Creates a new builder-style object to manufacture [`DnisEmergencyCallingConfiguration`](crate::model::DnisEmergencyCallingConfiguration).
    pub fn builder() -> crate::model::dnis_emergency_calling_configuration::Builder {
        crate::model::dnis_emergency_calling_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SipMediaApplicationLoggingConfiguration {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub enable_sip_media_application_message_logs: std::option::Option<bool>,
}
impl SipMediaApplicationLoggingConfiguration {
    #[allow(missing_docs)] // documentation missing in model
    pub fn enable_sip_media_application_message_logs(&self) -> std::option::Option<bool> {
        self.enable_sip_media_application_message_logs
    }
}
/// See [`SipMediaApplicationLoggingConfiguration`](crate::model::SipMediaApplicationLoggingConfiguration).
pub mod sip_media_application_logging_configuration {

    /// A builder for [`SipMediaApplicationLoggingConfiguration`](crate::model::SipMediaApplicationLoggingConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable_sip_media_application_message_logs: std::option::Option<bool>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn enable_sip_media_application_message_logs(mut self, input: bool) -> Self {
            self.enable_sip_media_application_message_logs = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_enable_sip_media_application_message_logs(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_sip_media_application_message_logs = input;
            self
        }
        /// Consumes the builder and constructs a [`SipMediaApplicationLoggingConfiguration`](crate::model::SipMediaApplicationLoggingConfiguration).
        pub fn build(self) -> crate::model::SipMediaApplicationLoggingConfiguration {
            crate::model::SipMediaApplicationLoggingConfiguration {
                enable_sip_media_application_message_logs: self
                    .enable_sip_media_application_message_logs,
            }
        }
    }
}
impl SipMediaApplicationLoggingConfiguration {
    /// Creates a new builder-style object to manufacture [`SipMediaApplicationLoggingConfiguration`](crate::model::SipMediaApplicationLoggingConfiguration).
    pub fn builder() -> crate::model::sip_media_application_logging_configuration::Builder {
        crate::model::sip_media_application_logging_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SipMediaApplicationAlexaSkillConfiguration {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub alexa_skill_status: std::option::Option<crate::model::AlexaSkillStatus>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub alexa_skill_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl SipMediaApplicationAlexaSkillConfiguration {
    #[allow(missing_docs)] // documentation missing in model
    pub fn alexa_skill_status(&self) -> std::option::Option<&crate::model::AlexaSkillStatus> {
        self.alexa_skill_status.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn alexa_skill_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.alexa_skill_ids.as_deref()
    }
}
/// See [`SipMediaApplicationAlexaSkillConfiguration`](crate::model::SipMediaApplicationAlexaSkillConfiguration).
pub mod sip_media_application_alexa_skill_configuration {

    /// A builder for [`SipMediaApplicationAlexaSkillConfiguration`](crate::model::SipMediaApplicationAlexaSkillConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alexa_skill_status: std::option::Option<crate::model::AlexaSkillStatus>,
        pub(crate) alexa_skill_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn alexa_skill_status(mut self, input: crate::model::AlexaSkillStatus) -> Self {
            self.alexa_skill_status = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_alexa_skill_status(
            mut self,
            input: std::option::Option<crate::model::AlexaSkillStatus>,
        ) -> Self {
            self.alexa_skill_status = input;
            self
        }
        /// Appends an item to `alexa_skill_ids`.
        ///
        /// To override the contents of this collection use [`set_alexa_skill_ids`](Self::set_alexa_skill_ids).
        ///
        pub fn alexa_skill_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.alexa_skill_ids.unwrap_or_default();
            v.push(input.into());
            self.alexa_skill_ids = Some(v);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_alexa_skill_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.alexa_skill_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`SipMediaApplicationAlexaSkillConfiguration`](crate::model::SipMediaApplicationAlexaSkillConfiguration).
        pub fn build(self) -> crate::model::SipMediaApplicationAlexaSkillConfiguration {
            crate::model::SipMediaApplicationAlexaSkillConfiguration {
                alexa_skill_status: self.alexa_skill_status,
                alexa_skill_ids: self.alexa_skill_ids,
            }
        }
    }
}
impl SipMediaApplicationAlexaSkillConfiguration {
    /// Creates a new builder-style object to manufacture [`SipMediaApplicationAlexaSkillConfiguration`](crate::model::SipMediaApplicationAlexaSkillConfiguration).
    pub fn builder() -> crate::model::sip_media_application_alexa_skill_configuration::Builder {
        crate::model::sip_media_application_alexa_skill_configuration::Builder::default()
    }
}

/// When writing a match expression against `AlexaSkillStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let alexaskillstatus = unimplemented!();
/// match alexaskillstatus {
///     AlexaSkillStatus::Active => { /* ... */ },
///     AlexaSkillStatus::Inactive => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `alexaskillstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AlexaSkillStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AlexaSkillStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AlexaSkillStatus::NewFeature` is defined.
/// Specifically, when `alexaskillstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AlexaSkillStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AlexaSkillStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Inactive,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AlexaSkillStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => AlexaSkillStatus::Active,
            "INACTIVE" => AlexaSkillStatus::Inactive,
            other => AlexaSkillStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AlexaSkillStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AlexaSkillStatus::from(s))
    }
}
impl AlexaSkillStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AlexaSkillStatus::Active => "ACTIVE",
            AlexaSkillStatus::Inactive => "INACTIVE",
            AlexaSkillStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "INACTIVE"]
    }
}
impl AsRef<str> for AlexaSkillStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PhoneNumberCountry {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub country_code: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub supported_phone_number_types:
        std::option::Option<std::vec::Vec<crate::model::PhoneNumberType>>,
}
impl PhoneNumberCountry {
    #[allow(missing_docs)] // documentation missing in model
    pub fn country_code(&self) -> std::option::Option<&str> {
        self.country_code.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn supported_phone_number_types(
        &self,
    ) -> std::option::Option<&[crate::model::PhoneNumberType]> {
        self.supported_phone_number_types.as_deref()
    }
}
/// See [`PhoneNumberCountry`](crate::model::PhoneNumberCountry).
pub mod phone_number_country {

    /// A builder for [`PhoneNumberCountry`](crate::model::PhoneNumberCountry).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) country_code: std::option::Option<std::string::String>,
        pub(crate) supported_phone_number_types:
            std::option::Option<std::vec::Vec<crate::model::PhoneNumberType>>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn country_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.country_code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_country_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.country_code = input;
            self
        }
        /// Appends an item to `supported_phone_number_types`.
        ///
        /// To override the contents of this collection use [`set_supported_phone_number_types`](Self::set_supported_phone_number_types).
        ///
        pub fn supported_phone_number_types(
            mut self,
            input: crate::model::PhoneNumberType,
        ) -> Self {
            let mut v = self.supported_phone_number_types.unwrap_or_default();
            v.push(input);
            self.supported_phone_number_types = Some(v);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_supported_phone_number_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PhoneNumberType>>,
        ) -> Self {
            self.supported_phone_number_types = input;
            self
        }
        /// Consumes the builder and constructs a [`PhoneNumberCountry`](crate::model::PhoneNumberCountry).
        pub fn build(self) -> crate::model::PhoneNumberCountry {
            crate::model::PhoneNumberCountry {
                country_code: self.country_code,
                supported_phone_number_types: self.supported_phone_number_types,
            }
        }
    }
}
impl PhoneNumberCountry {
    /// Creates a new builder-style object to manufacture [`PhoneNumberCountry`](crate::model::PhoneNumberCountry).
    pub fn builder() -> crate::model::phone_number_country::Builder {
        crate::model::phone_number_country::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PhoneNumberOrder {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub phone_number_order_id: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub product_type: std::option::Option<crate::model::PhoneNumberProductType>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::PhoneNumberOrderStatus>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub order_type: std::option::Option<crate::model::PhoneNumberOrderType>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub ordered_phone_numbers: std::option::Option<std::vec::Vec<crate::model::OrderedPhoneNumber>>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl PhoneNumberOrder {
    #[allow(missing_docs)] // documentation missing in model
    pub fn phone_number_order_id(&self) -> std::option::Option<&str> {
        self.phone_number_order_id.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn product_type(&self) -> std::option::Option<&crate::model::PhoneNumberProductType> {
        self.product_type.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn status(&self) -> std::option::Option<&crate::model::PhoneNumberOrderStatus> {
        self.status.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn order_type(&self) -> std::option::Option<&crate::model::PhoneNumberOrderType> {
        self.order_type.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn ordered_phone_numbers(
        &self,
    ) -> std::option::Option<&[crate::model::OrderedPhoneNumber]> {
        self.ordered_phone_numbers.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn created_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_timestamp.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn updated_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_timestamp.as_ref()
    }
}
/// See [`PhoneNumberOrder`](crate::model::PhoneNumberOrder).
pub mod phone_number_order {

    /// A builder for [`PhoneNumberOrder`](crate::model::PhoneNumberOrder).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number_order_id: std::option::Option<std::string::String>,
        pub(crate) product_type: std::option::Option<crate::model::PhoneNumberProductType>,
        pub(crate) status: std::option::Option<crate::model::PhoneNumberOrderStatus>,
        pub(crate) order_type: std::option::Option<crate::model::PhoneNumberOrderType>,
        pub(crate) ordered_phone_numbers:
            std::option::Option<std::vec::Vec<crate::model::OrderedPhoneNumber>>,
        pub(crate) created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn phone_number_order_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_order_id = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_phone_number_order_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_order_id = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn product_type(mut self, input: crate::model::PhoneNumberProductType) -> Self {
            self.product_type = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_product_type(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberProductType>,
        ) -> Self {
            self.product_type = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn status(mut self, input: crate::model::PhoneNumberOrderStatus) -> Self {
            self.status = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberOrderStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn order_type(mut self, input: crate::model::PhoneNumberOrderType) -> Self {
            self.order_type = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_order_type(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberOrderType>,
        ) -> Self {
            self.order_type = input;
            self
        }
        /// Appends an item to `ordered_phone_numbers`.
        ///
        /// To override the contents of this collection use [`set_ordered_phone_numbers`](Self::set_ordered_phone_numbers).
        ///
        pub fn ordered_phone_numbers(mut self, input: crate::model::OrderedPhoneNumber) -> Self {
            let mut v = self.ordered_phone_numbers.unwrap_or_default();
            v.push(input);
            self.ordered_phone_numbers = Some(v);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_ordered_phone_numbers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::OrderedPhoneNumber>>,
        ) -> Self {
            self.ordered_phone_numbers = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn created_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_timestamp = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_created_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_timestamp = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn updated_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_timestamp = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_updated_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`PhoneNumberOrder`](crate::model::PhoneNumberOrder).
        pub fn build(self) -> crate::model::PhoneNumberOrder {
            crate::model::PhoneNumberOrder {
                phone_number_order_id: self.phone_number_order_id,
                product_type: self.product_type,
                status: self.status,
                order_type: self.order_type,
                ordered_phone_numbers: self.ordered_phone_numbers,
                created_timestamp: self.created_timestamp,
                updated_timestamp: self.updated_timestamp,
            }
        }
    }
}
impl PhoneNumberOrder {
    /// Creates a new builder-style object to manufacture [`PhoneNumberOrder`](crate::model::PhoneNumberOrder).
    pub fn builder() -> crate::model::phone_number_order::Builder {
        crate::model::phone_number_order::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OrderedPhoneNumber {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub e164_phone_number: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::OrderedPhoneNumberStatus>,
}
impl OrderedPhoneNumber {
    #[allow(missing_docs)] // documentation missing in model
    pub fn e164_phone_number(&self) -> std::option::Option<&str> {
        self.e164_phone_number.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn status(&self) -> std::option::Option<&crate::model::OrderedPhoneNumberStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for OrderedPhoneNumber {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OrderedPhoneNumber");
        formatter.field("e164_phone_number", &"*** Sensitive Data Redacted ***");
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`OrderedPhoneNumber`](crate::model::OrderedPhoneNumber).
pub mod ordered_phone_number {

    /// A builder for [`OrderedPhoneNumber`](crate::model::OrderedPhoneNumber).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) e164_phone_number: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::OrderedPhoneNumberStatus>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn e164_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.e164_phone_number = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_e164_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.e164_phone_number = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn status(mut self, input: crate::model::OrderedPhoneNumberStatus) -> Self {
            self.status = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OrderedPhoneNumberStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`OrderedPhoneNumber`](crate::model::OrderedPhoneNumber).
        pub fn build(self) -> crate::model::OrderedPhoneNumber {
            crate::model::OrderedPhoneNumber {
                e164_phone_number: self.e164_phone_number,
                status: self.status,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("e164_phone_number", &"*** Sensitive Data Redacted ***");
            formatter.field("status", &self.status);
            formatter.finish()
        }
    }
}
impl OrderedPhoneNumber {
    /// Creates a new builder-style object to manufacture [`OrderedPhoneNumber`](crate::model::OrderedPhoneNumber).
    pub fn builder() -> crate::model::ordered_phone_number::Builder {
        crate::model::ordered_phone_number::Builder::default()
    }
}

/// When writing a match expression against `OrderedPhoneNumberStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let orderedphonenumberstatus = unimplemented!();
/// match orderedphonenumberstatus {
///     OrderedPhoneNumberStatus::Acquired => { /* ... */ },
///     OrderedPhoneNumberStatus::Failed => { /* ... */ },
///     OrderedPhoneNumberStatus::Processing => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `orderedphonenumberstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OrderedPhoneNumberStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OrderedPhoneNumberStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OrderedPhoneNumberStatus::NewFeature` is defined.
/// Specifically, when `orderedphonenumberstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OrderedPhoneNumberStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OrderedPhoneNumberStatus {
    #[allow(missing_docs)] // documentation missing in model
    Acquired,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Processing,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OrderedPhoneNumberStatus {
    fn from(s: &str) -> Self {
        match s {
            "Acquired" => OrderedPhoneNumberStatus::Acquired,
            "Failed" => OrderedPhoneNumberStatus::Failed,
            "Processing" => OrderedPhoneNumberStatus::Processing,
            other => OrderedPhoneNumberStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for OrderedPhoneNumberStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OrderedPhoneNumberStatus::from(s))
    }
}
impl OrderedPhoneNumberStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OrderedPhoneNumberStatus::Acquired => "Acquired",
            OrderedPhoneNumberStatus::Failed => "Failed",
            OrderedPhoneNumberStatus::Processing => "Processing",
            OrderedPhoneNumberStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Acquired", "Failed", "Processing"]
    }
}
impl AsRef<str> for OrderedPhoneNumberStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PhoneNumberOrderType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let phonenumberordertype = unimplemented!();
/// match phonenumberordertype {
///     PhoneNumberOrderType::New => { /* ... */ },
///     PhoneNumberOrderType::Porting => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `phonenumberordertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PhoneNumberOrderType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PhoneNumberOrderType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PhoneNumberOrderType::NewFeature` is defined.
/// Specifically, when `phonenumberordertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PhoneNumberOrderType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PhoneNumberOrderType {
    #[allow(missing_docs)] // documentation missing in model
    New,
    #[allow(missing_docs)] // documentation missing in model
    Porting,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PhoneNumberOrderType {
    fn from(s: &str) -> Self {
        match s {
            "New" => PhoneNumberOrderType::New,
            "Porting" => PhoneNumberOrderType::Porting,
            other => {
                PhoneNumberOrderType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for PhoneNumberOrderType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PhoneNumberOrderType::from(s))
    }
}
impl PhoneNumberOrderType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PhoneNumberOrderType::New => "New",
            PhoneNumberOrderType::Porting => "Porting",
            PhoneNumberOrderType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["New", "Porting"]
    }
}
impl AsRef<str> for PhoneNumberOrderType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PhoneNumberOrderStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let phonenumberorderstatus = unimplemented!();
/// match phonenumberorderstatus {
///     PhoneNumberOrderStatus::CancelRequested => { /* ... */ },
///     PhoneNumberOrderStatus::Cancelled => { /* ... */ },
///     PhoneNumberOrderStatus::ChangeRequested => { /* ... */ },
///     PhoneNumberOrderStatus::Exception => { /* ... */ },
///     PhoneNumberOrderStatus::Foc => { /* ... */ },
///     PhoneNumberOrderStatus::Failed => { /* ... */ },
///     PhoneNumberOrderStatus::Partial => { /* ... */ },
///     PhoneNumberOrderStatus::PendingDocuments => { /* ... */ },
///     PhoneNumberOrderStatus::Processing => { /* ... */ },
///     PhoneNumberOrderStatus::Submitted => { /* ... */ },
///     PhoneNumberOrderStatus::Successful => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `phonenumberorderstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PhoneNumberOrderStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PhoneNumberOrderStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PhoneNumberOrderStatus::NewFeature` is defined.
/// Specifically, when `phonenumberorderstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PhoneNumberOrderStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PhoneNumberOrderStatus {
    #[allow(missing_docs)] // documentation missing in model
    CancelRequested,
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    ChangeRequested,
    #[allow(missing_docs)] // documentation missing in model
    Exception,
    #[allow(missing_docs)] // documentation missing in model
    Foc,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Partial,
    #[allow(missing_docs)] // documentation missing in model
    PendingDocuments,
    #[allow(missing_docs)] // documentation missing in model
    Processing,
    #[allow(missing_docs)] // documentation missing in model
    Submitted,
    #[allow(missing_docs)] // documentation missing in model
    Successful,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PhoneNumberOrderStatus {
    fn from(s: &str) -> Self {
        match s {
            "CancelRequested" => PhoneNumberOrderStatus::CancelRequested,
            "Cancelled" => PhoneNumberOrderStatus::Cancelled,
            "ChangeRequested" => PhoneNumberOrderStatus::ChangeRequested,
            "Exception" => PhoneNumberOrderStatus::Exception,
            "FOC" => PhoneNumberOrderStatus::Foc,
            "Failed" => PhoneNumberOrderStatus::Failed,
            "Partial" => PhoneNumberOrderStatus::Partial,
            "PendingDocuments" => PhoneNumberOrderStatus::PendingDocuments,
            "Processing" => PhoneNumberOrderStatus::Processing,
            "Submitted" => PhoneNumberOrderStatus::Submitted,
            "Successful" => PhoneNumberOrderStatus::Successful,
            other => {
                PhoneNumberOrderStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for PhoneNumberOrderStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PhoneNumberOrderStatus::from(s))
    }
}
impl PhoneNumberOrderStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PhoneNumberOrderStatus::CancelRequested => "CancelRequested",
            PhoneNumberOrderStatus::Cancelled => "Cancelled",
            PhoneNumberOrderStatus::ChangeRequested => "ChangeRequested",
            PhoneNumberOrderStatus::Exception => "Exception",
            PhoneNumberOrderStatus::Foc => "FOC",
            PhoneNumberOrderStatus::Failed => "Failed",
            PhoneNumberOrderStatus::Partial => "Partial",
            PhoneNumberOrderStatus::PendingDocuments => "PendingDocuments",
            PhoneNumberOrderStatus::Processing => "Processing",
            PhoneNumberOrderStatus::Submitted => "Submitted",
            PhoneNumberOrderStatus::Successful => "Successful",
            PhoneNumberOrderStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CancelRequested",
            "Cancelled",
            "ChangeRequested",
            "Exception",
            "FOC",
            "Failed",
            "Partial",
            "PendingDocuments",
            "Processing",
            "Submitted",
            "Successful",
        ]
    }
}
impl AsRef<str> for PhoneNumberOrderStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TerminationHealth {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub timestamp: std::option::Option<aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub source: std::option::Option<std::string::String>,
}
impl TerminationHealth {
    #[allow(missing_docs)] // documentation missing in model
    pub fn timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.timestamp.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn source(&self) -> std::option::Option<&str> {
        self.source.as_deref()
    }
}
/// See [`TerminationHealth`](crate::model::TerminationHealth).
pub mod termination_health {

    /// A builder for [`TerminationHealth`](crate::model::TerminationHealth).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) source: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.timestamp = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.timestamp = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.source = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source = input;
            self
        }
        /// Consumes the builder and constructs a [`TerminationHealth`](crate::model::TerminationHealth).
        pub fn build(self) -> crate::model::TerminationHealth {
            crate::model::TerminationHealth {
                timestamp: self.timestamp,
                source: self.source,
            }
        }
    }
}
impl TerminationHealth {
    /// Creates a new builder-style object to manufacture [`TerminationHealth`](crate::model::TerminationHealth).
    pub fn builder() -> crate::model::termination_health::Builder {
        crate::model::termination_health::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PhoneNumberError {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub phone_number_id: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub error_code: std::option::Option<crate::model::ErrorCode>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl PhoneNumberError {
    #[allow(missing_docs)] // documentation missing in model
    pub fn phone_number_id(&self) -> std::option::Option<&str> {
        self.phone_number_id.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn error_code(&self) -> std::option::Option<&crate::model::ErrorCode> {
        self.error_code.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
impl std::fmt::Debug for PhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PhoneNumberError");
        formatter.field("phone_number_id", &"*** Sensitive Data Redacted ***");
        formatter.field("error_code", &self.error_code);
        formatter.field("error_message", &self.error_message);
        formatter.finish()
    }
}
/// See [`PhoneNumberError`](crate::model::PhoneNumberError).
pub mod phone_number_error {

    /// A builder for [`PhoneNumberError`](crate::model::PhoneNumberError).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) phone_number_id: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn phone_number_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_id = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_phone_number_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_id = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn error_code(mut self, input: crate::model::ErrorCode) -> Self {
            self.error_code = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::ErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`PhoneNumberError`](crate::model::PhoneNumberError).
        pub fn build(self) -> crate::model::PhoneNumberError {
            crate::model::PhoneNumberError {
                phone_number_id: self.phone_number_id,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("phone_number_id", &"*** Sensitive Data Redacted ***");
            formatter.field("error_code", &self.error_code);
            formatter.field("error_message", &self.error_message);
            formatter.finish()
        }
    }
}
impl PhoneNumberError {
    /// Creates a new builder-style object to manufacture [`PhoneNumberError`](crate::model::PhoneNumberError).
    pub fn builder() -> crate::model::phone_number_error::Builder {
        crate::model::phone_number_error::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdatePhoneNumberRequestItem {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub phone_number_id: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub product_type: std::option::Option<crate::model::PhoneNumberProductType>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub calling_name: std::option::Option<std::string::String>,
}
impl UpdatePhoneNumberRequestItem {
    #[allow(missing_docs)] // documentation missing in model
    pub fn phone_number_id(&self) -> std::option::Option<&str> {
        self.phone_number_id.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn product_type(&self) -> std::option::Option<&crate::model::PhoneNumberProductType> {
        self.product_type.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn calling_name(&self) -> std::option::Option<&str> {
        self.calling_name.as_deref()
    }
}
impl std::fmt::Debug for UpdatePhoneNumberRequestItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdatePhoneNumberRequestItem");
        formatter.field("phone_number_id", &"*** Sensitive Data Redacted ***");
        formatter.field("product_type", &self.product_type);
        formatter.field("calling_name", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`UpdatePhoneNumberRequestItem`](crate::model::UpdatePhoneNumberRequestItem).
pub mod update_phone_number_request_item {

    /// A builder for [`UpdatePhoneNumberRequestItem`](crate::model::UpdatePhoneNumberRequestItem).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) phone_number_id: std::option::Option<std::string::String>,
        pub(crate) product_type: std::option::Option<crate::model::PhoneNumberProductType>,
        pub(crate) calling_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn phone_number_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_id = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_phone_number_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_id = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn product_type(mut self, input: crate::model::PhoneNumberProductType) -> Self {
            self.product_type = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_product_type(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberProductType>,
        ) -> Self {
            self.product_type = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn calling_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.calling_name = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_calling_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.calling_name = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdatePhoneNumberRequestItem`](crate::model::UpdatePhoneNumberRequestItem).
        pub fn build(self) -> crate::model::UpdatePhoneNumberRequestItem {
            crate::model::UpdatePhoneNumberRequestItem {
                phone_number_id: self.phone_number_id,
                product_type: self.product_type,
                calling_name: self.calling_name,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("phone_number_id", &"*** Sensitive Data Redacted ***");
            formatter.field("product_type", &self.product_type);
            formatter.field("calling_name", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl UpdatePhoneNumberRequestItem {
    /// Creates a new builder-style object to manufacture [`UpdatePhoneNumberRequestItem`](crate::model::UpdatePhoneNumberRequestItem).
    pub fn builder() -> crate::model::update_phone_number_request_item::Builder {
        crate::model::update_phone_number_request_item::Builder::default()
    }
}
