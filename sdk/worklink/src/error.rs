// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateDomainError {
    pub kind: AssociateDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateDomainErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateDomainErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            AssociateDomainErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            AssociateDomainErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            AssociateDomainErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AssociateDomainErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AssociateDomainErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            AssociateDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateDomainError {
    fn code(&self) -> Option<&str> {
        AssociateDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateDomainError {
    pub fn new(kind: AssociateDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateDomainErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateDomainErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateDomainErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateDomainErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateDomainErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateDomainErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for AssociateDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateDomainErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            AssociateDomainErrorKind::InvalidRequestException(_inner) => Some(_inner),
            AssociateDomainErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            AssociateDomainErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AssociateDomainErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AssociateDomainErrorKind::UnauthorizedException(_inner) => Some(_inner),
            AssociateDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateWebsiteAuthorizationProviderError {
    pub kind: AssociateWebsiteAuthorizationProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateWebsiteAuthorizationProviderErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateWebsiteAuthorizationProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateWebsiteAuthorizationProviderErrorKind::InternalServerErrorException(
                _inner,
            ) => _inner.fmt(f),
            AssociateWebsiteAuthorizationProviderErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWebsiteAuthorizationProviderErrorKind::ResourceAlreadyExistsException(
                _inner,
            ) => _inner.fmt(f),
            AssociateWebsiteAuthorizationProviderErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWebsiteAuthorizationProviderErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWebsiteAuthorizationProviderErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWebsiteAuthorizationProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateWebsiteAuthorizationProviderError {
    fn code(&self) -> Option<&str> {
        AssociateWebsiteAuthorizationProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateWebsiteAuthorizationProviderError {
    pub fn new(
        kind: AssociateWebsiteAuthorizationProviderErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateWebsiteAuthorizationProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateWebsiteAuthorizationProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWebsiteAuthorizationProviderErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWebsiteAuthorizationProviderErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWebsiteAuthorizationProviderErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWebsiteAuthorizationProviderErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWebsiteAuthorizationProviderErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWebsiteAuthorizationProviderErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for AssociateWebsiteAuthorizationProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateWebsiteAuthorizationProviderErrorKind::InternalServerErrorException(
                _inner,
            ) => Some(_inner),
            AssociateWebsiteAuthorizationProviderErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            AssociateWebsiteAuthorizationProviderErrorKind::ResourceAlreadyExistsException(
                _inner,
            ) => Some(_inner),
            AssociateWebsiteAuthorizationProviderErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            AssociateWebsiteAuthorizationProviderErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            AssociateWebsiteAuthorizationProviderErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            AssociateWebsiteAuthorizationProviderErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateWebsiteCertificateAuthorityError {
    pub kind: AssociateWebsiteCertificateAuthorityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateWebsiteCertificateAuthorityErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateWebsiteCertificateAuthorityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateWebsiteCertificateAuthorityErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWebsiteCertificateAuthorityErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWebsiteCertificateAuthorityErrorKind::ResourceAlreadyExistsException(
                _inner,
            ) => _inner.fmt(f),
            AssociateWebsiteCertificateAuthorityErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWebsiteCertificateAuthorityErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWebsiteCertificateAuthorityErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWebsiteCertificateAuthorityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateWebsiteCertificateAuthorityError {
    fn code(&self) -> Option<&str> {
        AssociateWebsiteCertificateAuthorityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateWebsiteCertificateAuthorityError {
    pub fn new(
        kind: AssociateWebsiteCertificateAuthorityErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateWebsiteCertificateAuthorityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateWebsiteCertificateAuthorityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWebsiteCertificateAuthorityErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWebsiteCertificateAuthorityErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWebsiteCertificateAuthorityErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWebsiteCertificateAuthorityErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWebsiteCertificateAuthorityErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWebsiteCertificateAuthorityErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for AssociateWebsiteCertificateAuthorityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateWebsiteCertificateAuthorityErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            AssociateWebsiteCertificateAuthorityErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            AssociateWebsiteCertificateAuthorityErrorKind::ResourceAlreadyExistsException(
                _inner,
            ) => Some(_inner),
            AssociateWebsiteCertificateAuthorityErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            AssociateWebsiteCertificateAuthorityErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            AssociateWebsiteCertificateAuthorityErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            AssociateWebsiteCertificateAuthorityErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateFleetError {
    pub kind: CreateFleetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFleetErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateFleetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateFleetErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateFleetErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            CreateFleetErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateFleetErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateFleetErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateFleetErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateFleetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateFleetError {
    fn code(&self) -> Option<&str> {
        CreateFleetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFleetError {
    pub fn new(kind: CreateFleetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateFleetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateFleetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, CreateFleetErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFleetErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, CreateFleetErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for CreateFleetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateFleetErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateFleetErrorKind::InvalidRequestException(_inner) => Some(_inner),
            CreateFleetErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateFleetErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateFleetErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateFleetErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateFleetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFleetError {
    pub kind: DeleteFleetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFleetErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFleetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFleetErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteFleetErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DeleteFleetErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteFleetErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteFleetErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteFleetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFleetError {
    fn code(&self) -> Option<&str> {
        DeleteFleetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFleetError {
    pub fn new(kind: DeleteFleetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFleetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFleetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFleetErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteFleetErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFleetErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFleetErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DeleteFleetErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for DeleteFleetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFleetErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteFleetErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DeleteFleetErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteFleetErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteFleetErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteFleetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAuditStreamConfigurationError {
    pub kind: DescribeAuditStreamConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAuditStreamConfigurationErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAuditStreamConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAuditStreamConfigurationErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAuditStreamConfigurationErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAuditStreamConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAuditStreamConfigurationErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAuditStreamConfigurationErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAuditStreamConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAuditStreamConfigurationError {
    fn code(&self) -> Option<&str> {
        DescribeAuditStreamConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAuditStreamConfigurationError {
    pub fn new(kind: DescribeAuditStreamConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAuditStreamConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAuditStreamConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditStreamConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditStreamConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditStreamConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditStreamConfigurationErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAuditStreamConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeAuditStreamConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAuditStreamConfigurationErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            DescribeAuditStreamConfigurationErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DescribeAuditStreamConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeAuditStreamConfigurationErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            DescribeAuditStreamConfigurationErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            DescribeAuditStreamConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCompanyNetworkConfigurationError {
    pub kind: DescribeCompanyNetworkConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCompanyNetworkConfigurationErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCompanyNetworkConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCompanyNetworkConfigurationErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCompanyNetworkConfigurationErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCompanyNetworkConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCompanyNetworkConfigurationErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCompanyNetworkConfigurationErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCompanyNetworkConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCompanyNetworkConfigurationError {
    fn code(&self) -> Option<&str> {
        DescribeCompanyNetworkConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCompanyNetworkConfigurationError {
    pub fn new(
        kind: DescribeCompanyNetworkConfigurationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCompanyNetworkConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCompanyNetworkConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCompanyNetworkConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCompanyNetworkConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCompanyNetworkConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCompanyNetworkConfigurationErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCompanyNetworkConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeCompanyNetworkConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCompanyNetworkConfigurationErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            DescribeCompanyNetworkConfigurationErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DescribeCompanyNetworkConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeCompanyNetworkConfigurationErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            DescribeCompanyNetworkConfigurationErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            DescribeCompanyNetworkConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDeviceError {
    pub kind: DescribeDeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDeviceErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDeviceErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeDeviceErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeDeviceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeDeviceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeDeviceErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeDeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDeviceError {
    fn code(&self) -> Option<&str> {
        DescribeDeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDeviceError {
    pub fn new(kind: DescribeDeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDeviceErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDeviceErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDeviceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDeviceErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDeviceErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeDeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDeviceErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeDeviceErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeDeviceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeDeviceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeDeviceErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeDeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDevicePolicyConfigurationError {
    pub kind: DescribeDevicePolicyConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDevicePolicyConfigurationErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDevicePolicyConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDevicePolicyConfigurationErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDevicePolicyConfigurationErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDevicePolicyConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDevicePolicyConfigurationErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDevicePolicyConfigurationErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDevicePolicyConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDevicePolicyConfigurationError {
    fn code(&self) -> Option<&str> {
        DescribeDevicePolicyConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDevicePolicyConfigurationError {
    pub fn new(
        kind: DescribeDevicePolicyConfigurationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDevicePolicyConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDevicePolicyConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDevicePolicyConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDevicePolicyConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDevicePolicyConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDevicePolicyConfigurationErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDevicePolicyConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeDevicePolicyConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDevicePolicyConfigurationErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            DescribeDevicePolicyConfigurationErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DescribeDevicePolicyConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeDevicePolicyConfigurationErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            DescribeDevicePolicyConfigurationErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            DescribeDevicePolicyConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDomainError {
    pub kind: DescribeDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDomainErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDomainErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeDomainErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeDomainErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeDomainErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeDomainErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDomainError {
    fn code(&self) -> Option<&str> {
        DescribeDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDomainError {
    pub fn new(kind: DescribeDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDomainErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDomainErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDomainErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDomainErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDomainErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDomainErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeDomainErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeDomainErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeDomainErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeDomainErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeFleetMetadataError {
    pub kind: DescribeFleetMetadataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeFleetMetadataErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeFleetMetadataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeFleetMetadataErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeFleetMetadataErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DescribeFleetMetadataErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeFleetMetadataErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeFleetMetadataErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeFleetMetadataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeFleetMetadataError {
    fn code(&self) -> Option<&str> {
        DescribeFleetMetadataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeFleetMetadataError {
    pub fn new(kind: DescribeFleetMetadataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeFleetMetadataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeFleetMetadataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetMetadataErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetMetadataErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetMetadataErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetMetadataErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFleetMetadataErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeFleetMetadataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeFleetMetadataErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeFleetMetadataErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DescribeFleetMetadataErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeFleetMetadataErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeFleetMetadataErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeFleetMetadataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeIdentityProviderConfigurationError {
    pub kind: DescribeIdentityProviderConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeIdentityProviderConfigurationErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeIdentityProviderConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeIdentityProviderConfigurationErrorKind::InternalServerErrorException(
                _inner,
            ) => _inner.fmt(f),
            DescribeIdentityProviderConfigurationErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeIdentityProviderConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeIdentityProviderConfigurationErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            DescribeIdentityProviderConfigurationErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            DescribeIdentityProviderConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeIdentityProviderConfigurationError {
    fn code(&self) -> Option<&str> {
        DescribeIdentityProviderConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeIdentityProviderConfigurationError {
    pub fn new(
        kind: DescribeIdentityProviderConfigurationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeIdentityProviderConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeIdentityProviderConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIdentityProviderConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIdentityProviderConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIdentityProviderConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIdentityProviderConfigurationErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIdentityProviderConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeIdentityProviderConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeIdentityProviderConfigurationErrorKind::InternalServerErrorException(
                _inner,
            ) => Some(_inner),
            DescribeIdentityProviderConfigurationErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DescribeIdentityProviderConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeIdentityProviderConfigurationErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            DescribeIdentityProviderConfigurationErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            DescribeIdentityProviderConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeWebsiteCertificateAuthorityError {
    pub kind: DescribeWebsiteCertificateAuthorityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeWebsiteCertificateAuthorityErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeWebsiteCertificateAuthorityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeWebsiteCertificateAuthorityErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            DescribeWebsiteCertificateAuthorityErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeWebsiteCertificateAuthorityErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeWebsiteCertificateAuthorityErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            DescribeWebsiteCertificateAuthorityErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            DescribeWebsiteCertificateAuthorityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeWebsiteCertificateAuthorityError {
    fn code(&self) -> Option<&str> {
        DescribeWebsiteCertificateAuthorityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeWebsiteCertificateAuthorityError {
    pub fn new(
        kind: DescribeWebsiteCertificateAuthorityErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeWebsiteCertificateAuthorityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeWebsiteCertificateAuthorityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWebsiteCertificateAuthorityErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWebsiteCertificateAuthorityErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWebsiteCertificateAuthorityErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWebsiteCertificateAuthorityErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWebsiteCertificateAuthorityErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeWebsiteCertificateAuthorityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeWebsiteCertificateAuthorityErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            DescribeWebsiteCertificateAuthorityErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DescribeWebsiteCertificateAuthorityErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeWebsiteCertificateAuthorityErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            DescribeWebsiteCertificateAuthorityErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            DescribeWebsiteCertificateAuthorityErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateDomainError {
    pub kind: DisassociateDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateDomainErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateDomainErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DisassociateDomainErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            DisassociateDomainErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DisassociateDomainErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DisassociateDomainErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DisassociateDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateDomainError {
    fn code(&self) -> Option<&str> {
        DisassociateDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateDomainError {
    pub fn new(kind: DisassociateDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateDomainErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateDomainErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateDomainErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateDomainErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateDomainErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DisassociateDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateDomainErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DisassociateDomainErrorKind::InvalidRequestException(_inner) => Some(_inner),
            DisassociateDomainErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DisassociateDomainErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DisassociateDomainErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DisassociateDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateWebsiteAuthorizationProviderError {
    pub kind: DisassociateWebsiteAuthorizationProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateWebsiteAuthorizationProviderErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateWebsiteAuthorizationProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateWebsiteAuthorizationProviderErrorKind::InternalServerErrorException(
                _inner,
            ) => _inner.fmt(f),
            DisassociateWebsiteAuthorizationProviderErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWebsiteAuthorizationProviderErrorKind::ResourceAlreadyExistsException(
                _inner,
            ) => _inner.fmt(f),
            DisassociateWebsiteAuthorizationProviderErrorKind::ResourceNotFoundException(
                _inner,
            ) => _inner.fmt(f),
            DisassociateWebsiteAuthorizationProviderErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWebsiteAuthorizationProviderErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWebsiteAuthorizationProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateWebsiteAuthorizationProviderError {
    fn code(&self) -> Option<&str> {
        DisassociateWebsiteAuthorizationProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateWebsiteAuthorizationProviderError {
    pub fn new(
        kind: DisassociateWebsiteAuthorizationProviderErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateWebsiteAuthorizationProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateWebsiteAuthorizationProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWebsiteAuthorizationProviderErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWebsiteAuthorizationProviderErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWebsiteAuthorizationProviderErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWebsiteAuthorizationProviderErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWebsiteAuthorizationProviderErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWebsiteAuthorizationProviderErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DisassociateWebsiteAuthorizationProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateWebsiteAuthorizationProviderErrorKind::InternalServerErrorException(
                _inner,
            ) => Some(_inner),
            DisassociateWebsiteAuthorizationProviderErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DisassociateWebsiteAuthorizationProviderErrorKind::ResourceAlreadyExistsException(
                _inner,
            ) => Some(_inner),
            DisassociateWebsiteAuthorizationProviderErrorKind::ResourceNotFoundException(
                _inner,
            ) => Some(_inner),
            DisassociateWebsiteAuthorizationProviderErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            DisassociateWebsiteAuthorizationProviderErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            DisassociateWebsiteAuthorizationProviderErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateWebsiteCertificateAuthorityError {
    pub kind: DisassociateWebsiteCertificateAuthorityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateWebsiteCertificateAuthorityErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateWebsiteCertificateAuthorityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateWebsiteCertificateAuthorityErrorKind::InternalServerErrorException(
                _inner,
            ) => _inner.fmt(f),
            DisassociateWebsiteCertificateAuthorityErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWebsiteCertificateAuthorityErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWebsiteCertificateAuthorityErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWebsiteCertificateAuthorityErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWebsiteCertificateAuthorityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateWebsiteCertificateAuthorityError {
    fn code(&self) -> Option<&str> {
        DisassociateWebsiteCertificateAuthorityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateWebsiteCertificateAuthorityError {
    pub fn new(
        kind: DisassociateWebsiteCertificateAuthorityErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateWebsiteCertificateAuthorityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateWebsiteCertificateAuthorityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWebsiteCertificateAuthorityErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWebsiteCertificateAuthorityErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWebsiteCertificateAuthorityErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWebsiteCertificateAuthorityErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWebsiteCertificateAuthorityErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DisassociateWebsiteCertificateAuthorityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateWebsiteCertificateAuthorityErrorKind::InternalServerErrorException(
                _inner,
            ) => Some(_inner),
            DisassociateWebsiteCertificateAuthorityErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            DisassociateWebsiteCertificateAuthorityErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DisassociateWebsiteCertificateAuthorityErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            DisassociateWebsiteCertificateAuthorityErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            DisassociateWebsiteCertificateAuthorityErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDevicesError {
    pub kind: ListDevicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDevicesErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDevicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDevicesErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListDevicesErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListDevicesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListDevicesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListDevicesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListDevicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDevicesError {
    fn code(&self) -> Option<&str> {
        ListDevicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDevicesError {
    pub fn new(kind: ListDevicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDevicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDevicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDevicesErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, ListDevicesErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDevicesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDevicesErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, ListDevicesErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for ListDevicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDevicesErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListDevicesErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListDevicesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListDevicesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListDevicesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListDevicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDomainsError {
    pub kind: ListDomainsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDomainsErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDomainsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDomainsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListDomainsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListDomainsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListDomainsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListDomainsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListDomainsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDomainsError {
    fn code(&self) -> Option<&str> {
        ListDomainsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDomainsError {
    pub fn new(kind: ListDomainsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDomainsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDomainsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, ListDomainsErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainsErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, ListDomainsErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for ListDomainsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDomainsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListDomainsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListDomainsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListDomainsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListDomainsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListDomainsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFleetsError {
    pub kind: ListFleetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFleetsErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFleetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFleetsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListFleetsErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListFleetsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListFleetsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListFleetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFleetsError {
    fn code(&self) -> Option<&str> {
        ListFleetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFleetsError {
    pub fn new(kind: ListFleetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFleetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFleetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFleetsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, ListFleetsErrorKind::InvalidRequestException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, ListFleetsErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, ListFleetsErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for ListFleetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFleetsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListFleetsErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListFleetsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListFleetsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListFleetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    InvalidRequestException(crate::error::InvalidRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidRequestException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::InvalidRequestException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListWebsiteAuthorizationProvidersError {
    pub kind: ListWebsiteAuthorizationProvidersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListWebsiteAuthorizationProvidersErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListWebsiteAuthorizationProvidersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListWebsiteAuthorizationProvidersErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            ListWebsiteAuthorizationProvidersErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListWebsiteAuthorizationProvidersErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListWebsiteAuthorizationProvidersErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            ListWebsiteAuthorizationProvidersErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            ListWebsiteAuthorizationProvidersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListWebsiteAuthorizationProvidersError {
    fn code(&self) -> Option<&str> {
        ListWebsiteAuthorizationProvidersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListWebsiteAuthorizationProvidersError {
    pub fn new(
        kind: ListWebsiteAuthorizationProvidersErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListWebsiteAuthorizationProvidersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListWebsiteAuthorizationProvidersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWebsiteAuthorizationProvidersErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWebsiteAuthorizationProvidersErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWebsiteAuthorizationProvidersErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWebsiteAuthorizationProvidersErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWebsiteAuthorizationProvidersErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListWebsiteAuthorizationProvidersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListWebsiteAuthorizationProvidersErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            ListWebsiteAuthorizationProvidersErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            ListWebsiteAuthorizationProvidersErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListWebsiteAuthorizationProvidersErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            ListWebsiteAuthorizationProvidersErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            ListWebsiteAuthorizationProvidersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListWebsiteCertificateAuthoritiesError {
    pub kind: ListWebsiteCertificateAuthoritiesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListWebsiteCertificateAuthoritiesErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListWebsiteCertificateAuthoritiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListWebsiteCertificateAuthoritiesErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            ListWebsiteCertificateAuthoritiesErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListWebsiteCertificateAuthoritiesErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            ListWebsiteCertificateAuthoritiesErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            ListWebsiteCertificateAuthoritiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListWebsiteCertificateAuthoritiesError {
    fn code(&self) -> Option<&str> {
        ListWebsiteCertificateAuthoritiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListWebsiteCertificateAuthoritiesError {
    pub fn new(
        kind: ListWebsiteCertificateAuthoritiesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListWebsiteCertificateAuthoritiesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListWebsiteCertificateAuthoritiesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWebsiteCertificateAuthoritiesErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWebsiteCertificateAuthoritiesErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWebsiteCertificateAuthoritiesErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWebsiteCertificateAuthoritiesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListWebsiteCertificateAuthoritiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListWebsiteCertificateAuthoritiesErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            ListWebsiteCertificateAuthoritiesErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            ListWebsiteCertificateAuthoritiesErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            ListWebsiteCertificateAuthoritiesErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            ListWebsiteCertificateAuthoritiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreDomainAccessError {
    pub kind: RestoreDomainAccessErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreDomainAccessErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreDomainAccessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreDomainAccessErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            RestoreDomainAccessErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            RestoreDomainAccessErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RestoreDomainAccessErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            RestoreDomainAccessErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            RestoreDomainAccessErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestoreDomainAccessError {
    fn code(&self) -> Option<&str> {
        RestoreDomainAccessError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreDomainAccessError {
    pub fn new(kind: RestoreDomainAccessErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreDomainAccessErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreDomainAccessErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDomainAccessErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDomainAccessErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDomainAccessErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDomainAccessErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestoreDomainAccessErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for RestoreDomainAccessError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreDomainAccessErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            RestoreDomainAccessErrorKind::InvalidRequestException(_inner) => Some(_inner),
            RestoreDomainAccessErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RestoreDomainAccessErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            RestoreDomainAccessErrorKind::UnauthorizedException(_inner) => Some(_inner),
            RestoreDomainAccessErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RevokeDomainAccessError {
    pub kind: RevokeDomainAccessErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RevokeDomainAccessErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RevokeDomainAccessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RevokeDomainAccessErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            RevokeDomainAccessErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            RevokeDomainAccessErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RevokeDomainAccessErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            RevokeDomainAccessErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            RevokeDomainAccessErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RevokeDomainAccessError {
    fn code(&self) -> Option<&str> {
        RevokeDomainAccessError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RevokeDomainAccessError {
    pub fn new(kind: RevokeDomainAccessErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RevokeDomainAccessErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RevokeDomainAccessErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeDomainAccessErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeDomainAccessErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeDomainAccessErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeDomainAccessErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeDomainAccessErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for RevokeDomainAccessError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RevokeDomainAccessErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            RevokeDomainAccessErrorKind::InvalidRequestException(_inner) => Some(_inner),
            RevokeDomainAccessErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RevokeDomainAccessErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            RevokeDomainAccessErrorKind::UnauthorizedException(_inner) => Some(_inner),
            RevokeDomainAccessErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SignOutUserError {
    pub kind: SignOutUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SignOutUserErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SignOutUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SignOutUserErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            SignOutUserErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            SignOutUserErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SignOutUserErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            SignOutUserErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            SignOutUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SignOutUserError {
    fn code(&self) -> Option<&str> {
        SignOutUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SignOutUserError {
    pub fn new(kind: SignOutUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SignOutUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SignOutUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            SignOutUserErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, SignOutUserErrorKind::InvalidRequestException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SignOutUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            SignOutUserErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, SignOutUserErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for SignOutUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SignOutUserErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            SignOutUserErrorKind::InvalidRequestException(_inner) => Some(_inner),
            SignOutUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SignOutUserErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            SignOutUserErrorKind::UnauthorizedException(_inner) => Some(_inner),
            SignOutUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    InvalidRequestException(crate::error::InvalidRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InvalidRequestException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InvalidRequestException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    InvalidRequestException(crate::error::InvalidRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidRequestException(_)
        )
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAuditStreamConfigurationError {
    pub kind: UpdateAuditStreamConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAuditStreamConfigurationErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAuditStreamConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAuditStreamConfigurationErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAuditStreamConfigurationErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAuditStreamConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAuditStreamConfigurationErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAuditStreamConfigurationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateAuditStreamConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAuditStreamConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateAuditStreamConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAuditStreamConfigurationError {
    pub fn new(kind: UpdateAuditStreamConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAuditStreamConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAuditStreamConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuditStreamConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuditStreamConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuditStreamConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuditStreamConfigurationErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuditStreamConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateAuditStreamConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAuditStreamConfigurationErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            UpdateAuditStreamConfigurationErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            UpdateAuditStreamConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateAuditStreamConfigurationErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            UpdateAuditStreamConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateAuditStreamConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCompanyNetworkConfigurationError {
    pub kind: UpdateCompanyNetworkConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCompanyNetworkConfigurationErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCompanyNetworkConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCompanyNetworkConfigurationErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            UpdateCompanyNetworkConfigurationErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateCompanyNetworkConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateCompanyNetworkConfigurationErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            UpdateCompanyNetworkConfigurationErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateCompanyNetworkConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateCompanyNetworkConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateCompanyNetworkConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCompanyNetworkConfigurationError {
    pub fn new(
        kind: UpdateCompanyNetworkConfigurationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCompanyNetworkConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCompanyNetworkConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCompanyNetworkConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCompanyNetworkConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCompanyNetworkConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCompanyNetworkConfigurationErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCompanyNetworkConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateCompanyNetworkConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCompanyNetworkConfigurationErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            UpdateCompanyNetworkConfigurationErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            UpdateCompanyNetworkConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateCompanyNetworkConfigurationErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            UpdateCompanyNetworkConfigurationErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            UpdateCompanyNetworkConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDevicePolicyConfigurationError {
    pub kind: UpdateDevicePolicyConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDevicePolicyConfigurationErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDevicePolicyConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDevicePolicyConfigurationErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDevicePolicyConfigurationErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDevicePolicyConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDevicePolicyConfigurationErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDevicePolicyConfigurationErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDevicePolicyConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDevicePolicyConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateDevicePolicyConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDevicePolicyConfigurationError {
    pub fn new(kind: UpdateDevicePolicyConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDevicePolicyConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDevicePolicyConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDevicePolicyConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDevicePolicyConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDevicePolicyConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDevicePolicyConfigurationErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDevicePolicyConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateDevicePolicyConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDevicePolicyConfigurationErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            UpdateDevicePolicyConfigurationErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            UpdateDevicePolicyConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateDevicePolicyConfigurationErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            UpdateDevicePolicyConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateDevicePolicyConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDomainMetadataError {
    pub kind: UpdateDomainMetadataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDomainMetadataErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDomainMetadataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDomainMetadataErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateDomainMetadataErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateDomainMetadataErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateDomainMetadataErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateDomainMetadataErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateDomainMetadataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDomainMetadataError {
    fn code(&self) -> Option<&str> {
        UpdateDomainMetadataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDomainMetadataError {
    pub fn new(kind: UpdateDomainMetadataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDomainMetadataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDomainMetadataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainMetadataErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainMetadataErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainMetadataErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainMetadataErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainMetadataErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateDomainMetadataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDomainMetadataErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateDomainMetadataErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateDomainMetadataErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateDomainMetadataErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateDomainMetadataErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateDomainMetadataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFleetMetadataError {
    pub kind: UpdateFleetMetadataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFleetMetadataErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFleetMetadataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFleetMetadataErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateFleetMetadataErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            UpdateFleetMetadataErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateFleetMetadataErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateFleetMetadataErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateFleetMetadataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateFleetMetadataError {
    fn code(&self) -> Option<&str> {
        UpdateFleetMetadataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFleetMetadataError {
    pub fn new(kind: UpdateFleetMetadataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFleetMetadataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFleetMetadataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetadataErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetadataErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetadataErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetadataErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFleetMetadataErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateFleetMetadataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFleetMetadataErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateFleetMetadataErrorKind::InvalidRequestException(_inner) => Some(_inner),
            UpdateFleetMetadataErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateFleetMetadataErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateFleetMetadataErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateFleetMetadataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateIdentityProviderConfigurationError {
    pub kind: UpdateIdentityProviderConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateIdentityProviderConfigurationErrorKind {
    InternalServerErrorException(crate::error::InternalServerErrorException),
    InvalidRequestException(crate::error::InvalidRequestException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateIdentityProviderConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateIdentityProviderConfigurationErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            UpdateIdentityProviderConfigurationErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateIdentityProviderConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateIdentityProviderConfigurationErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            UpdateIdentityProviderConfigurationErrorKind::UnauthorizedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateIdentityProviderConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateIdentityProviderConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateIdentityProviderConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateIdentityProviderConfigurationError {
    pub fn new(
        kind: UpdateIdentityProviderConfigurationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateIdentityProviderConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateIdentityProviderConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIdentityProviderConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIdentityProviderConfigurationErrorKind::InvalidRequestException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIdentityProviderConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIdentityProviderConfigurationErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIdentityProviderConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateIdentityProviderConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateIdentityProviderConfigurationErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            UpdateIdentityProviderConfigurationErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            UpdateIdentityProviderConfigurationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateIdentityProviderConfigurationErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            UpdateIdentityProviderConfigurationErrorKind::UnauthorizedException(_inner) => {
                Some(_inner)
            }
            UpdateIdentityProviderConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// <p>You are not authorized to perform this action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnauthorizedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnauthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnauthorizedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnauthorizedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnauthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthorizedException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnauthorizedException {}
/// See [`UnauthorizedException`](crate::error::UnauthorizedException)
pub mod unauthorized_exception {
    /// A builder for [`UnauthorizedException`](crate::error::UnauthorizedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedException`](crate::error::UnauthorizedException)
        pub fn build(self) -> crate::error::UnauthorizedException {
            crate::error::UnauthorizedException {
                message: self.message,
            }
        }
    }
}
impl UnauthorizedException {
    /// Creates a new builder-style object to manufacture [`UnauthorizedException`](crate::error::UnauthorizedException)
    pub fn builder() -> crate::error::unauthorized_exception::Builder {
        crate::error::unauthorized_exception::Builder::default()
    }
}

/// <p>The number of requests exceeds the limit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyRequestsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyRequestsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyRequestsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyRequestsException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyRequestsException {}
/// See [`TooManyRequestsException`](crate::error::TooManyRequestsException)
pub mod too_many_requests_exception {
    /// A builder for [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyRequestsException`](crate::error::TooManyRequestsException)
        pub fn build(self) -> crate::error::TooManyRequestsException {
            crate::error::TooManyRequestsException {
                message: self.message,
            }
        }
    }
}
impl TooManyRequestsException {
    /// Creates a new builder-style object to manufacture [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    pub fn builder() -> crate::error::too_many_requests_exception::Builder {
        crate::error::too_many_requests_exception::Builder::default()
    }
}

/// <p>The requested resource was not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>The request is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRequestException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRequestException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRequestException {}
/// See [`InvalidRequestException`](crate::error::InvalidRequestException)
pub mod invalid_request_exception {
    /// A builder for [`InvalidRequestException`](crate::error::InvalidRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRequestException`](crate::error::InvalidRequestException)
        pub fn build(self) -> crate::error::InvalidRequestException {
            crate::error::InvalidRequestException {
                message: self.message,
            }
        }
    }
}
impl InvalidRequestException {
    /// Creates a new builder-style object to manufacture [`InvalidRequestException`](crate::error::InvalidRequestException)
    pub fn builder() -> crate::error::invalid_request_exception::Builder {
        crate::error::invalid_request_exception::Builder::default()
    }
}

/// <p>The service is temporarily unavailable.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerErrorException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerErrorException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServerErrorException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerErrorException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerErrorException {}
/// See [`InternalServerErrorException`](crate::error::InternalServerErrorException)
pub mod internal_server_error_exception {
    /// A builder for [`InternalServerErrorException`](crate::error::InternalServerErrorException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerErrorException`](crate::error::InternalServerErrorException)
        pub fn build(self) -> crate::error::InternalServerErrorException {
            crate::error::InternalServerErrorException {
                message: self.message,
            }
        }
    }
}
impl InternalServerErrorException {
    /// Creates a new builder-style object to manufacture [`InternalServerErrorException`](crate::error::InternalServerErrorException)
    pub fn builder() -> crate::error::internal_server_error_exception::Builder {
        crate::error::internal_server_error_exception::Builder::default()
    }
}

/// <p>The resource already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceAlreadyExistsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceAlreadyExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceAlreadyExistsException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceAlreadyExistsException {}
/// See [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
pub mod resource_already_exists_exception {
    /// A builder for [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
        pub fn build(self) -> crate::error::ResourceAlreadyExistsException {
            crate::error::ResourceAlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl ResourceAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
    pub fn builder() -> crate::error::resource_already_exists_exception::Builder {
        crate::error::resource_already_exists_exception::Builder::default()
    }
}
