// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `IdentityProviderType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let identityprovidertype = unimplemented!();
/// match identityprovidertype {
///     IdentityProviderType::Saml => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `identityprovidertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `IdentityProviderType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `IdentityProviderType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `IdentityProviderType::NewFeature` is defined.
/// Specifically, when `identityprovidertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `IdentityProviderType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IdentityProviderType {
    #[allow(missing_docs)] // documentation missing in model
    Saml,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for IdentityProviderType {
    fn from(s: &str) -> Self {
        match s {
            "SAML" => IdentityProviderType::Saml,
            other => {
                IdentityProviderType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for IdentityProviderType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IdentityProviderType::from(s))
    }
}
impl IdentityProviderType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            IdentityProviderType::Saml => "SAML",
            IdentityProviderType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SAML"]
    }
}
impl AsRef<str> for IdentityProviderType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The summary of the certificate authority (CA).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WebsiteCaSummary {
    /// <p>A unique identifier for the CA.</p>
    #[doc(hidden)]
    pub website_ca_id: std::option::Option<std::string::String>,
    /// <p>The time when the CA was added.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name to display.</p>
    #[doc(hidden)]
    pub display_name: std::option::Option<std::string::String>,
}
impl WebsiteCaSummary {
    /// <p>A unique identifier for the CA.</p>
    pub fn website_ca_id(&self) -> std::option::Option<&str> {
        self.website_ca_id.as_deref()
    }
    /// <p>The time when the CA was added.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The name to display.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
}
impl WebsiteCaSummary {
    /// Creates a new builder-style object to manufacture [`WebsiteCaSummary`](crate::model::WebsiteCaSummary).
    pub fn builder() -> crate::model::website_ca_summary::Builder {
        crate::model::website_ca_summary::Builder::default()
    }
}

/// See [`WebsiteCaSummary`](crate::model::WebsiteCaSummary).
pub mod website_ca_summary {

    /// A builder for [`WebsiteCaSummary`](crate::model::WebsiteCaSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) website_ca_id: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) display_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier for the CA.</p>
        pub fn website_ca_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.website_ca_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the CA.</p>
        pub fn set_website_ca_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.website_ca_id = input;
            self
        }
        /// <p>The time when the CA was added.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The time when the CA was added.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The name to display.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The name to display.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// Consumes the builder and constructs a [`WebsiteCaSummary`](crate::model::WebsiteCaSummary).
        pub fn build(self) -> crate::model::WebsiteCaSummary {
            crate::model::WebsiteCaSummary {
                website_ca_id: self.website_ca_id,
                created_time: self.created_time,
                display_name: self.display_name,
            }
        }
    }
}

/// <p>The summary of the website authorization provider.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WebsiteAuthorizationProviderSummary {
    /// <p>A unique identifier for the authorization provider.</p>
    #[doc(hidden)]
    pub authorization_provider_id: std::option::Option<std::string::String>,
    /// <p>The authorization provider type.</p>
    #[doc(hidden)]
    pub authorization_provider_type: std::option::Option<crate::model::AuthorizationProviderType>,
    /// <p>The domain name of the authorization provider. This applies only to SAML-based authorization providers.</p>
    #[doc(hidden)]
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The time of creation.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl WebsiteAuthorizationProviderSummary {
    /// <p>A unique identifier for the authorization provider.</p>
    pub fn authorization_provider_id(&self) -> std::option::Option<&str> {
        self.authorization_provider_id.as_deref()
    }
    /// <p>The authorization provider type.</p>
    pub fn authorization_provider_type(
        &self,
    ) -> std::option::Option<&crate::model::AuthorizationProviderType> {
        self.authorization_provider_type.as_ref()
    }
    /// <p>The domain name of the authorization provider. This applies only to SAML-based authorization providers.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>The time of creation.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
}
impl WebsiteAuthorizationProviderSummary {
    /// Creates a new builder-style object to manufacture [`WebsiteAuthorizationProviderSummary`](crate::model::WebsiteAuthorizationProviderSummary).
    pub fn builder() -> crate::model::website_authorization_provider_summary::Builder {
        crate::model::website_authorization_provider_summary::Builder::default()
    }
}

/// See [`WebsiteAuthorizationProviderSummary`](crate::model::WebsiteAuthorizationProviderSummary).
pub mod website_authorization_provider_summary {

    /// A builder for [`WebsiteAuthorizationProviderSummary`](crate::model::WebsiteAuthorizationProviderSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) authorization_provider_id: std::option::Option<std::string::String>,
        pub(crate) authorization_provider_type:
            std::option::Option<crate::model::AuthorizationProviderType>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>A unique identifier for the authorization provider.</p>
        pub fn authorization_provider_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.authorization_provider_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the authorization provider.</p>
        pub fn set_authorization_provider_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authorization_provider_id = input;
            self
        }
        /// <p>The authorization provider type.</p>
        pub fn authorization_provider_type(
            mut self,
            input: crate::model::AuthorizationProviderType,
        ) -> Self {
            self.authorization_provider_type = Some(input);
            self
        }
        /// <p>The authorization provider type.</p>
        pub fn set_authorization_provider_type(
            mut self,
            input: std::option::Option<crate::model::AuthorizationProviderType>,
        ) -> Self {
            self.authorization_provider_type = input;
            self
        }
        /// <p>The domain name of the authorization provider. This applies only to SAML-based authorization providers.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The domain name of the authorization provider. This applies only to SAML-based authorization providers.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The time of creation.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The time of creation.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// Consumes the builder and constructs a [`WebsiteAuthorizationProviderSummary`](crate::model::WebsiteAuthorizationProviderSummary).
        pub fn build(self) -> crate::model::WebsiteAuthorizationProviderSummary {
            crate::model::WebsiteAuthorizationProviderSummary {
                authorization_provider_id: self.authorization_provider_id,
                authorization_provider_type: self.authorization_provider_type,
                domain_name: self.domain_name,
                created_time: self.created_time,
            }
        }
    }
}

/// When writing a match expression against `AuthorizationProviderType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let authorizationprovidertype = unimplemented!();
/// match authorizationprovidertype {
///     AuthorizationProviderType::Saml => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `authorizationprovidertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AuthorizationProviderType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AuthorizationProviderType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AuthorizationProviderType::NewFeature` is defined.
/// Specifically, when `authorizationprovidertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AuthorizationProviderType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AuthorizationProviderType {
    #[allow(missing_docs)] // documentation missing in model
    Saml,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AuthorizationProviderType {
    fn from(s: &str) -> Self {
        match s {
            "SAML" => AuthorizationProviderType::Saml,
            other => AuthorizationProviderType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for AuthorizationProviderType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AuthorizationProviderType::from(s))
    }
}
impl AuthorizationProviderType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AuthorizationProviderType::Saml => "SAML",
            AuthorizationProviderType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SAML"]
    }
}
impl AsRef<str> for AuthorizationProviderType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The summary of the fleet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FleetSummary {
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    #[doc(hidden)]
    pub fleet_arn: std::option::Option<std::string::String>,
    /// <p>The time when the fleet was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time when the fleet was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name of the fleet.</p>
    #[doc(hidden)]
    pub fleet_name: std::option::Option<std::string::String>,
    /// <p>The name of the fleet to display.</p>
    #[doc(hidden)]
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The identifier used by users to sign into the Amazon WorkLink app.</p>
    #[doc(hidden)]
    pub company_code: std::option::Option<std::string::String>,
    /// <p>The status of the fleet.</p>
    #[doc(hidden)]
    pub fleet_status: std::option::Option<crate::model::FleetStatus>,
    /// <p>The tags attached to the resource. A tag is a key-value pair.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl FleetSummary {
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    pub fn fleet_arn(&self) -> std::option::Option<&str> {
        self.fleet_arn.as_deref()
    }
    /// <p>The time when the fleet was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The time when the fleet was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
    /// <p>The name of the fleet.</p>
    pub fn fleet_name(&self) -> std::option::Option<&str> {
        self.fleet_name.as_deref()
    }
    /// <p>The name of the fleet to display.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The identifier used by users to sign into the Amazon WorkLink app.</p>
    pub fn company_code(&self) -> std::option::Option<&str> {
        self.company_code.as_deref()
    }
    /// <p>The status of the fleet.</p>
    pub fn fleet_status(&self) -> std::option::Option<&crate::model::FleetStatus> {
        self.fleet_status.as_ref()
    }
    /// <p>The tags attached to the resource. A tag is a key-value pair.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl FleetSummary {
    /// Creates a new builder-style object to manufacture [`FleetSummary`](crate::model::FleetSummary).
    pub fn builder() -> crate::model::fleet_summary::Builder {
        crate::model::fleet_summary::Builder::default()
    }
}

/// See [`FleetSummary`](crate::model::FleetSummary).
pub mod fleet_summary {

    /// A builder for [`FleetSummary`](crate::model::FleetSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fleet_arn: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) fleet_name: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) company_code: std::option::Option<std::string::String>,
        pub(crate) fleet_status: std::option::Option<crate::model::FleetStatus>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
        pub fn fleet_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.fleet_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
        pub fn set_fleet_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.fleet_arn = input;
            self
        }
        /// <p>The time when the fleet was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The time when the fleet was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The time when the fleet was last updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The time when the fleet was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>The name of the fleet.</p>
        pub fn fleet_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.fleet_name = Some(input.into());
            self
        }
        /// <p>The name of the fleet.</p>
        pub fn set_fleet_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.fleet_name = input;
            self
        }
        /// <p>The name of the fleet to display.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The name of the fleet to display.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The identifier used by users to sign into the Amazon WorkLink app.</p>
        pub fn company_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.company_code = Some(input.into());
            self
        }
        /// <p>The identifier used by users to sign into the Amazon WorkLink app.</p>
        pub fn set_company_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.company_code = input;
            self
        }
        /// <p>The status of the fleet.</p>
        pub fn fleet_status(mut self, input: crate::model::FleetStatus) -> Self {
            self.fleet_status = Some(input);
            self
        }
        /// <p>The status of the fleet.</p>
        pub fn set_fleet_status(
            mut self,
            input: std::option::Option<crate::model::FleetStatus>,
        ) -> Self {
            self.fleet_status = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags attached to the resource. A tag is a key-value pair.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags attached to the resource. A tag is a key-value pair.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`FleetSummary`](crate::model::FleetSummary).
        pub fn build(self) -> crate::model::FleetSummary {
            crate::model::FleetSummary {
                fleet_arn: self.fleet_arn,
                created_time: self.created_time,
                last_updated_time: self.last_updated_time,
                fleet_name: self.fleet_name,
                display_name: self.display_name,
                company_code: self.company_code,
                fleet_status: self.fleet_status,
                tags: self.tags,
            }
        }
    }
}

/// When writing a match expression against `FleetStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let fleetstatus = unimplemented!();
/// match fleetstatus {
///     FleetStatus::Active => { /* ... */ },
///     FleetStatus::Creating => { /* ... */ },
///     FleetStatus::Deleted => { /* ... */ },
///     FleetStatus::Deleting => { /* ... */ },
///     FleetStatus::FailedToCreate => { /* ... */ },
///     FleetStatus::FailedToDelete => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `fleetstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FleetStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FleetStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FleetStatus::NewFeature` is defined.
/// Specifically, when `fleetstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FleetStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FleetStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    FailedToCreate,
    #[allow(missing_docs)] // documentation missing in model
    FailedToDelete,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FleetStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => FleetStatus::Active,
            "CREATING" => FleetStatus::Creating,
            "DELETED" => FleetStatus::Deleted,
            "DELETING" => FleetStatus::Deleting,
            "FAILED_TO_CREATE" => FleetStatus::FailedToCreate,
            "FAILED_TO_DELETE" => FleetStatus::FailedToDelete,
            other => FleetStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FleetStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FleetStatus::from(s))
    }
}
impl FleetStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FleetStatus::Active => "ACTIVE",
            FleetStatus::Creating => "CREATING",
            FleetStatus::Deleted => "DELETED",
            FleetStatus::Deleting => "DELETING",
            FleetStatus::FailedToCreate => "FAILED_TO_CREATE",
            FleetStatus::FailedToDelete => "FAILED_TO_DELETE",
            FleetStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "CREATING",
            "DELETED",
            "DELETING",
            "FAILED_TO_CREATE",
            "FAILED_TO_DELETE",
        ]
    }
}
impl AsRef<str> for FleetStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The summary of the domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DomainSummary {
    /// <p>The name of the domain.</p>
    #[doc(hidden)]
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The name to display.</p>
    #[doc(hidden)]
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The time that the domain was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the domain.</p>
    #[doc(hidden)]
    pub domain_status: std::option::Option<crate::model::DomainStatus>,
}
impl DomainSummary {
    /// <p>The name of the domain.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>The name to display.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The time that the domain was created.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The status of the domain.</p>
    pub fn domain_status(&self) -> std::option::Option<&crate::model::DomainStatus> {
        self.domain_status.as_ref()
    }
}
impl DomainSummary {
    /// Creates a new builder-style object to manufacture [`DomainSummary`](crate::model::DomainSummary).
    pub fn builder() -> crate::model::domain_summary::Builder {
        crate::model::domain_summary::Builder::default()
    }
}

/// See [`DomainSummary`](crate::model::DomainSummary).
pub mod domain_summary {

    /// A builder for [`DomainSummary`](crate::model::DomainSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) domain_status: std::option::Option<crate::model::DomainStatus>,
    }
    impl Builder {
        /// <p>The name of the domain.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The name of the domain.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The name to display.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The name to display.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The time that the domain was created.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The time that the domain was created.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The status of the domain.</p>
        pub fn domain_status(mut self, input: crate::model::DomainStatus) -> Self {
            self.domain_status = Some(input);
            self
        }
        /// <p>The status of the domain.</p>
        pub fn set_domain_status(
            mut self,
            input: std::option::Option<crate::model::DomainStatus>,
        ) -> Self {
            self.domain_status = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainSummary`](crate::model::DomainSummary).
        pub fn build(self) -> crate::model::DomainSummary {
            crate::model::DomainSummary {
                domain_name: self.domain_name,
                display_name: self.display_name,
                created_time: self.created_time,
                domain_status: self.domain_status,
            }
        }
    }
}

/// When writing a match expression against `DomainStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let domainstatus = unimplemented!();
/// match domainstatus {
///     DomainStatus::Active => { /* ... */ },
///     DomainStatus::Associating => { /* ... */ },
///     DomainStatus::Disassociated => { /* ... */ },
///     DomainStatus::Disassociating => { /* ... */ },
///     DomainStatus::FailedToAssociate => { /* ... */ },
///     DomainStatus::FailedToDisassociate => { /* ... */ },
///     DomainStatus::Inactive => { /* ... */ },
///     DomainStatus::PendingValidation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `domainstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DomainStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DomainStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DomainStatus::NewFeature` is defined.
/// Specifically, when `domainstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DomainStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DomainStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Associating,
    #[allow(missing_docs)] // documentation missing in model
    Disassociated,
    #[allow(missing_docs)] // documentation missing in model
    Disassociating,
    #[allow(missing_docs)] // documentation missing in model
    FailedToAssociate,
    #[allow(missing_docs)] // documentation missing in model
    FailedToDisassociate,
    #[allow(missing_docs)] // documentation missing in model
    Inactive,
    #[allow(missing_docs)] // documentation missing in model
    PendingValidation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DomainStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => DomainStatus::Active,
            "ASSOCIATING" => DomainStatus::Associating,
            "DISASSOCIATED" => DomainStatus::Disassociated,
            "DISASSOCIATING" => DomainStatus::Disassociating,
            "FAILED_TO_ASSOCIATE" => DomainStatus::FailedToAssociate,
            "FAILED_TO_DISASSOCIATE" => DomainStatus::FailedToDisassociate,
            "INACTIVE" => DomainStatus::Inactive,
            "PENDING_VALIDATION" => DomainStatus::PendingValidation,
            other => DomainStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DomainStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DomainStatus::from(s))
    }
}
impl DomainStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DomainStatus::Active => "ACTIVE",
            DomainStatus::Associating => "ASSOCIATING",
            DomainStatus::Disassociated => "DISASSOCIATED",
            DomainStatus::Disassociating => "DISASSOCIATING",
            DomainStatus::FailedToAssociate => "FAILED_TO_ASSOCIATE",
            DomainStatus::FailedToDisassociate => "FAILED_TO_DISASSOCIATE",
            DomainStatus::Inactive => "INACTIVE",
            DomainStatus::PendingValidation => "PENDING_VALIDATION",
            DomainStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "ASSOCIATING",
            "DISASSOCIATED",
            "DISASSOCIATING",
            "FAILED_TO_ASSOCIATE",
            "FAILED_TO_DISASSOCIATE",
            "INACTIVE",
            "PENDING_VALIDATION",
        ]
    }
}
impl AsRef<str> for DomainStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The summary of devices.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeviceSummary {
    /// <p>The ID of the device.</p>
    #[doc(hidden)]
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The status of the device.</p>
    #[doc(hidden)]
    pub device_status: std::option::Option<crate::model::DeviceStatus>,
}
impl DeviceSummary {
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The status of the device.</p>
    pub fn device_status(&self) -> std::option::Option<&crate::model::DeviceStatus> {
        self.device_status.as_ref()
    }
}
impl DeviceSummary {
    /// Creates a new builder-style object to manufacture [`DeviceSummary`](crate::model::DeviceSummary).
    pub fn builder() -> crate::model::device_summary::Builder {
        crate::model::device_summary::Builder::default()
    }
}

/// See [`DeviceSummary`](crate::model::DeviceSummary).
pub mod device_summary {

    /// A builder for [`DeviceSummary`](crate::model::DeviceSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) device_status: std::option::Option<crate::model::DeviceStatus>,
    }
    impl Builder {
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The status of the device.</p>
        pub fn device_status(mut self, input: crate::model::DeviceStatus) -> Self {
            self.device_status = Some(input);
            self
        }
        /// <p>The status of the device.</p>
        pub fn set_device_status(
            mut self,
            input: std::option::Option<crate::model::DeviceStatus>,
        ) -> Self {
            self.device_status = input;
            self
        }
        /// Consumes the builder and constructs a [`DeviceSummary`](crate::model::DeviceSummary).
        pub fn build(self) -> crate::model::DeviceSummary {
            crate::model::DeviceSummary {
                device_id: self.device_id,
                device_status: self.device_status,
            }
        }
    }
}

/// When writing a match expression against `DeviceStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let devicestatus = unimplemented!();
/// match devicestatus {
///     DeviceStatus::Active => { /* ... */ },
///     DeviceStatus::SignedOut => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `devicestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DeviceStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DeviceStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DeviceStatus::NewFeature` is defined.
/// Specifically, when `devicestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DeviceStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeviceStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    SignedOut,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DeviceStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => DeviceStatus::Active,
            "SIGNED_OUT" => DeviceStatus::SignedOut,
            other => DeviceStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DeviceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeviceStatus::from(s))
    }
}
impl DeviceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DeviceStatus::Active => "ACTIVE",
            DeviceStatus::SignedOut => "SIGNED_OUT",
            DeviceStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "SIGNED_OUT"]
    }
}
impl AsRef<str> for DeviceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
