// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The field's information of a request that resulted in an exception. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidationExceptionField {
    /// <p>The field name. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The message describing why the field failed validation. </p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ValidationExceptionField {
    /// <p>The field name. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The message describing why the field failed validation. </p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`ValidationExceptionField`](crate::model::ValidationExceptionField).
pub mod validation_exception_field {

    /// A builder for [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The field name. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The field name. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The message describing why the field failed validation. </p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message describing why the field failed validation. </p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationExceptionField`](crate::model::ValidationExceptionField).
        pub fn build(self) -> crate::model::ValidationExceptionField {
            crate::model::ValidationExceptionField {
                name: self.name,
                message: self.message,
            }
        }
    }
}
impl ValidationExceptionField {
    /// Creates a new builder-style object to manufacture [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    pub fn builder() -> crate::model::validation_exception_field::Builder {
        crate::model::validation_exception_field::Builder::default()
    }
}

/// When writing a match expression against `ValidationExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let validationexceptionreason = unimplemented!();
/// match validationexceptionreason {
///     ValidationExceptionReason::AccountsAlreadyAssociated => { /* ... */ },
///     ValidationExceptionReason::AccountsNotAssociated => { /* ... */ },
///     ValidationExceptionReason::CannotParse => { /* ... */ },
///     ValidationExceptionReason::CustomLineItemAssociationExists => { /* ... */ },
///     ValidationExceptionReason::DuplicateAccount => { /* ... */ },
///     ValidationExceptionReason::DuplicatePricingruleArns => { /* ... */ },
///     ValidationExceptionReason::FieldValidationFailed => { /* ... */ },
///     ValidationExceptionReason::IllegalAccounts => { /* ... */ },
///     ValidationExceptionReason::IllegalBillingEntity => { /* ... */ },
///     ValidationExceptionReason::IllegalBillingPeriod => { /* ... */ },
///     ValidationExceptionReason::IllegalBillingPeriodRange => { /* ... */ },
///     ValidationExceptionReason::IllegalChargeDetails => { /* ... */ },
///     ValidationExceptionReason::IllegalChildAssociateResource => { /* ... */ },
///     ValidationExceptionReason::IllegalCustomlineitem => { /* ... */ },
///     ValidationExceptionReason::IllegalCustomlineitemModification => { /* ... */ },
///     ValidationExceptionReason::IllegalCustomlineitemUpdate => { /* ... */ },
///     ValidationExceptionReason::IllegalEndedBillinggroup => { /* ... */ },
///     ValidationExceptionReason::IllegalExpression => { /* ... */ },
///     ValidationExceptionReason::IllegalModifierPercentage => { /* ... */ },
///     ValidationExceptionReason::IllegalPrimaryAccount => { /* ... */ },
///     ValidationExceptionReason::IllegalResourceArns => { /* ... */ },
///     ValidationExceptionReason::IllegalScope => { /* ... */ },
///     ValidationExceptionReason::IllegalService => { /* ... */ },
///     ValidationExceptionReason::IllegalTieringInput => { /* ... */ },
///     ValidationExceptionReason::IllegalType => { /* ... */ },
///     ValidationExceptionReason::IllegalUpdateChargeDetails => { /* ... */ },
///     ValidationExceptionReason::InvalidArn => { /* ... */ },
///     ValidationExceptionReason::InvalidBillingviewArn => { /* ... */ },
///     ValidationExceptionReason::InvalidBillingGroup => { /* ... */ },
///     ValidationExceptionReason::InvalidBillingGroupStatus => { /* ... */ },
///     ValidationExceptionReason::InvalidBillingPeriodForOperation => { /* ... */ },
///     ValidationExceptionReason::InvalidTimeRange => { /* ... */ },
///     ValidationExceptionReason::MismatchedBillinggroupArn => { /* ... */ },
///     ValidationExceptionReason::MismatchedBillingviewArn => { /* ... */ },
///     ValidationExceptionReason::MismatchedCustomlineitemArn => { /* ... */ },
///     ValidationExceptionReason::MismatchedPricingplanArn => { /* ... */ },
///     ValidationExceptionReason::MismatchedPricingruleArn => { /* ... */ },
///     ValidationExceptionReason::MissingBillinggroup => { /* ... */ },
///     ValidationExceptionReason::MissingCustomlineitem => { /* ... */ },
///     ValidationExceptionReason::MissingLinkedAccountIds => { /* ... */ },
///     ValidationExceptionReason::MissingPricingplan => { /* ... */ },
///     ValidationExceptionReason::MissingPricingPlanArn => { /* ... */ },
///     ValidationExceptionReason::MultipleLinkedAccountIds => { /* ... */ },
///     ValidationExceptionReason::MultiplePricingPlanArn => { /* ... */ },
///     ValidationExceptionReason::Other => { /* ... */ },
///     ValidationExceptionReason::PricingrulesAlreadyAssociated => { /* ... */ },
///     ValidationExceptionReason::PricingrulesNotAssociated => { /* ... */ },
///     ValidationExceptionReason::PricingrulesNotExist => { /* ... */ },
///     ValidationExceptionReason::PrimaryCannotDisassociate => { /* ... */ },
///     ValidationExceptionReason::PrimaryNotAssociated => { /* ... */ },
///     ValidationExceptionReason::TooManyAccountsInRequest => { /* ... */ },
///     ValidationExceptionReason::TooManyCustomlineitemsInRequest => { /* ... */ },
///     ValidationExceptionReason::UnknownOperation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `validationexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ValidationExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ValidationExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ValidationExceptionReason::NewFeature` is defined.
/// Specifically, when `validationexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ValidationExceptionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ValidationExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    AccountsAlreadyAssociated,
    #[allow(missing_docs)] // documentation missing in model
    AccountsNotAssociated,
    #[allow(missing_docs)] // documentation missing in model
    CannotParse,
    #[allow(missing_docs)] // documentation missing in model
    CustomLineItemAssociationExists,
    #[allow(missing_docs)] // documentation missing in model
    DuplicateAccount,
    #[allow(missing_docs)] // documentation missing in model
    DuplicatePricingruleArns,
    #[allow(missing_docs)] // documentation missing in model
    FieldValidationFailed,
    #[allow(missing_docs)] // documentation missing in model
    IllegalAccounts,
    #[allow(missing_docs)] // documentation missing in model
    IllegalBillingEntity,
    #[allow(missing_docs)] // documentation missing in model
    IllegalBillingPeriod,
    #[allow(missing_docs)] // documentation missing in model
    IllegalBillingPeriodRange,
    #[allow(missing_docs)] // documentation missing in model
    IllegalChargeDetails,
    #[allow(missing_docs)] // documentation missing in model
    IllegalChildAssociateResource,
    #[allow(missing_docs)] // documentation missing in model
    IllegalCustomlineitem,
    #[allow(missing_docs)] // documentation missing in model
    IllegalCustomlineitemModification,
    #[allow(missing_docs)] // documentation missing in model
    IllegalCustomlineitemUpdate,
    #[allow(missing_docs)] // documentation missing in model
    IllegalEndedBillinggroup,
    #[allow(missing_docs)] // documentation missing in model
    IllegalExpression,
    #[allow(missing_docs)] // documentation missing in model
    IllegalModifierPercentage,
    #[allow(missing_docs)] // documentation missing in model
    IllegalPrimaryAccount,
    #[allow(missing_docs)] // documentation missing in model
    IllegalResourceArns,
    #[allow(missing_docs)] // documentation missing in model
    IllegalScope,
    #[allow(missing_docs)] // documentation missing in model
    IllegalService,
    #[allow(missing_docs)] // documentation missing in model
    IllegalTieringInput,
    #[allow(missing_docs)] // documentation missing in model
    IllegalType,
    #[allow(missing_docs)] // documentation missing in model
    IllegalUpdateChargeDetails,
    #[allow(missing_docs)] // documentation missing in model
    InvalidArn,
    #[allow(missing_docs)] // documentation missing in model
    InvalidBillingviewArn,
    #[allow(missing_docs)] // documentation missing in model
    InvalidBillingGroup,
    #[allow(missing_docs)] // documentation missing in model
    InvalidBillingGroupStatus,
    #[allow(missing_docs)] // documentation missing in model
    InvalidBillingPeriodForOperation,
    #[allow(missing_docs)] // documentation missing in model
    InvalidTimeRange,
    #[allow(missing_docs)] // documentation missing in model
    MismatchedBillinggroupArn,
    #[allow(missing_docs)] // documentation missing in model
    MismatchedBillingviewArn,
    #[allow(missing_docs)] // documentation missing in model
    MismatchedCustomlineitemArn,
    #[allow(missing_docs)] // documentation missing in model
    MismatchedPricingplanArn,
    #[allow(missing_docs)] // documentation missing in model
    MismatchedPricingruleArn,
    #[allow(missing_docs)] // documentation missing in model
    MissingBillinggroup,
    #[allow(missing_docs)] // documentation missing in model
    MissingCustomlineitem,
    #[allow(missing_docs)] // documentation missing in model
    MissingLinkedAccountIds,
    #[allow(missing_docs)] // documentation missing in model
    MissingPricingplan,
    #[allow(missing_docs)] // documentation missing in model
    MissingPricingPlanArn,
    #[allow(missing_docs)] // documentation missing in model
    MultipleLinkedAccountIds,
    #[allow(missing_docs)] // documentation missing in model
    MultiplePricingPlanArn,
    #[allow(missing_docs)] // documentation missing in model
    Other,
    #[allow(missing_docs)] // documentation missing in model
    PricingrulesAlreadyAssociated,
    #[allow(missing_docs)] // documentation missing in model
    PricingrulesNotAssociated,
    #[allow(missing_docs)] // documentation missing in model
    PricingrulesNotExist,
    #[allow(missing_docs)] // documentation missing in model
    PrimaryCannotDisassociate,
    #[allow(missing_docs)] // documentation missing in model
    PrimaryNotAssociated,
    #[allow(missing_docs)] // documentation missing in model
    TooManyAccountsInRequest,
    #[allow(missing_docs)] // documentation missing in model
    TooManyCustomlineitemsInRequest,
    #[allow(missing_docs)] // documentation missing in model
    UnknownOperation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ValidationExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "ACCOUNTS_ALREADY_ASSOCIATED" => ValidationExceptionReason::AccountsAlreadyAssociated,
            "ACCOUNTS_NOT_ASSOCIATED" => ValidationExceptionReason::AccountsNotAssociated,
            "CANNOT_PARSE" => ValidationExceptionReason::CannotParse,
            "CUSTOM_LINE_ITEM_ASSOCIATION_EXISTS" => {
                ValidationExceptionReason::CustomLineItemAssociationExists
            }
            "DUPLICATE_ACCOUNT" => ValidationExceptionReason::DuplicateAccount,
            "DUPLICATE_PRICINGRULE_ARNS" => ValidationExceptionReason::DuplicatePricingruleArns,
            "FIELD_VALIDATION_FAILED" => ValidationExceptionReason::FieldValidationFailed,
            "ILLEGAL_ACCOUNTS" => ValidationExceptionReason::IllegalAccounts,
            "ILLEGAL_BILLING_ENTITY" => ValidationExceptionReason::IllegalBillingEntity,
            "ILLEGAL_BILLING_PERIOD" => ValidationExceptionReason::IllegalBillingPeriod,
            "ILLEGAL_BILLING_PERIOD_RANGE" => ValidationExceptionReason::IllegalBillingPeriodRange,
            "ILLEGAL_CHARGE_DETAILS" => ValidationExceptionReason::IllegalChargeDetails,
            "ILLEGAL_CHILD_ASSOCIATE_RESOURCE" => {
                ValidationExceptionReason::IllegalChildAssociateResource
            }
            "ILLEGAL_CUSTOMLINEITEM" => ValidationExceptionReason::IllegalCustomlineitem,
            "ILLEGAL_CUSTOMLINEITEM_MODIFICATION" => {
                ValidationExceptionReason::IllegalCustomlineitemModification
            }
            "ILLEGAL_CUSTOMLINEITEM_UPDATE" => {
                ValidationExceptionReason::IllegalCustomlineitemUpdate
            }
            "ILLEGAL_ENDED_BILLINGGROUP" => ValidationExceptionReason::IllegalEndedBillinggroup,
            "ILLEGAL_EXPRESSION" => ValidationExceptionReason::IllegalExpression,
            "ILLEGAL_MODIFIER_PERCENTAGE" => ValidationExceptionReason::IllegalModifierPercentage,
            "ILLEGAL_PRIMARY_ACCOUNT" => ValidationExceptionReason::IllegalPrimaryAccount,
            "ILLEGAL_RESOURCE_ARNS" => ValidationExceptionReason::IllegalResourceArns,
            "ILLEGAL_SCOPE" => ValidationExceptionReason::IllegalScope,
            "ILLEGAL_SERVICE" => ValidationExceptionReason::IllegalService,
            "ILLEGAL_TIERING_INPUT" => ValidationExceptionReason::IllegalTieringInput,
            "ILLEGAL_TYPE" => ValidationExceptionReason::IllegalType,
            "ILLEGAL_UPDATE_CHARGE_DETAILS" => {
                ValidationExceptionReason::IllegalUpdateChargeDetails
            }
            "INVALID_ARN" => ValidationExceptionReason::InvalidArn,
            "INVALID_BILLINGVIEW_ARN" => ValidationExceptionReason::InvalidBillingviewArn,
            "INVALID_BILLING_GROUP" => ValidationExceptionReason::InvalidBillingGroup,
            "INVALID_BILLING_GROUP_STATUS" => ValidationExceptionReason::InvalidBillingGroupStatus,
            "INVALID_BILLING_PERIOD_FOR_OPERATION" => {
                ValidationExceptionReason::InvalidBillingPeriodForOperation
            }
            "INVALID_TIME_RANGE" => ValidationExceptionReason::InvalidTimeRange,
            "MISMATCHED_BILLINGGROUP_ARN" => ValidationExceptionReason::MismatchedBillinggroupArn,
            "MISMATCHED_BILLINGVIEW_ARN" => ValidationExceptionReason::MismatchedBillingviewArn,
            "MISMATCHED_CUSTOMLINEITEM_ARN" => {
                ValidationExceptionReason::MismatchedCustomlineitemArn
            }
            "MISMATCHED_PRICINGPLAN_ARN" => ValidationExceptionReason::MismatchedPricingplanArn,
            "MISMATCHED_PRICINGRULE_ARN" => ValidationExceptionReason::MismatchedPricingruleArn,
            "MISSING_BILLINGGROUP" => ValidationExceptionReason::MissingBillinggroup,
            "MISSING_CUSTOMLINEITEM" => ValidationExceptionReason::MissingCustomlineitem,
            "MISSING_LINKED_ACCOUNT_IDS" => ValidationExceptionReason::MissingLinkedAccountIds,
            "MISSING_PRICINGPLAN" => ValidationExceptionReason::MissingPricingplan,
            "MISSING_PRICING_PLAN_ARN" => ValidationExceptionReason::MissingPricingPlanArn,
            "MULTIPLE_LINKED_ACCOUNT_IDS" => ValidationExceptionReason::MultipleLinkedAccountIds,
            "MULTIPLE_PRICING_PLAN_ARN" => ValidationExceptionReason::MultiplePricingPlanArn,
            "OTHER" => ValidationExceptionReason::Other,
            "PRICINGRULES_ALREADY_ASSOCIATED" => {
                ValidationExceptionReason::PricingrulesAlreadyAssociated
            }
            "PRICINGRULES_NOT_ASSOCIATED" => ValidationExceptionReason::PricingrulesNotAssociated,
            "PRICINGRULES_NOT_EXIST" => ValidationExceptionReason::PricingrulesNotExist,
            "PRIMARY_CANNOT_DISASSOCIATE" => ValidationExceptionReason::PrimaryCannotDisassociate,
            "PRIMARY_NOT_ASSOCIATED" => ValidationExceptionReason::PrimaryNotAssociated,
            "TOO_MANY_ACCOUNTS_IN_REQUEST" => ValidationExceptionReason::TooManyAccountsInRequest,
            "TOO_MANY_CUSTOMLINEITEMS_IN_REQUEST" => {
                ValidationExceptionReason::TooManyCustomlineitemsInRequest
            }
            "UNKNOWN_OPERATION" => ValidationExceptionReason::UnknownOperation,
            other => ValidationExceptionReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ValidationExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ValidationExceptionReason::from(s))
    }
}
impl ValidationExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ValidationExceptionReason::AccountsAlreadyAssociated => "ACCOUNTS_ALREADY_ASSOCIATED",
            ValidationExceptionReason::AccountsNotAssociated => "ACCOUNTS_NOT_ASSOCIATED",
            ValidationExceptionReason::CannotParse => "CANNOT_PARSE",
            ValidationExceptionReason::CustomLineItemAssociationExists => {
                "CUSTOM_LINE_ITEM_ASSOCIATION_EXISTS"
            }
            ValidationExceptionReason::DuplicateAccount => "DUPLICATE_ACCOUNT",
            ValidationExceptionReason::DuplicatePricingruleArns => "DUPLICATE_PRICINGRULE_ARNS",
            ValidationExceptionReason::FieldValidationFailed => "FIELD_VALIDATION_FAILED",
            ValidationExceptionReason::IllegalAccounts => "ILLEGAL_ACCOUNTS",
            ValidationExceptionReason::IllegalBillingEntity => "ILLEGAL_BILLING_ENTITY",
            ValidationExceptionReason::IllegalBillingPeriod => "ILLEGAL_BILLING_PERIOD",
            ValidationExceptionReason::IllegalBillingPeriodRange => "ILLEGAL_BILLING_PERIOD_RANGE",
            ValidationExceptionReason::IllegalChargeDetails => "ILLEGAL_CHARGE_DETAILS",
            ValidationExceptionReason::IllegalChildAssociateResource => {
                "ILLEGAL_CHILD_ASSOCIATE_RESOURCE"
            }
            ValidationExceptionReason::IllegalCustomlineitem => "ILLEGAL_CUSTOMLINEITEM",
            ValidationExceptionReason::IllegalCustomlineitemModification => {
                "ILLEGAL_CUSTOMLINEITEM_MODIFICATION"
            }
            ValidationExceptionReason::IllegalCustomlineitemUpdate => {
                "ILLEGAL_CUSTOMLINEITEM_UPDATE"
            }
            ValidationExceptionReason::IllegalEndedBillinggroup => "ILLEGAL_ENDED_BILLINGGROUP",
            ValidationExceptionReason::IllegalExpression => "ILLEGAL_EXPRESSION",
            ValidationExceptionReason::IllegalModifierPercentage => "ILLEGAL_MODIFIER_PERCENTAGE",
            ValidationExceptionReason::IllegalPrimaryAccount => "ILLEGAL_PRIMARY_ACCOUNT",
            ValidationExceptionReason::IllegalResourceArns => "ILLEGAL_RESOURCE_ARNS",
            ValidationExceptionReason::IllegalScope => "ILLEGAL_SCOPE",
            ValidationExceptionReason::IllegalService => "ILLEGAL_SERVICE",
            ValidationExceptionReason::IllegalTieringInput => "ILLEGAL_TIERING_INPUT",
            ValidationExceptionReason::IllegalType => "ILLEGAL_TYPE",
            ValidationExceptionReason::IllegalUpdateChargeDetails => {
                "ILLEGAL_UPDATE_CHARGE_DETAILS"
            }
            ValidationExceptionReason::InvalidArn => "INVALID_ARN",
            ValidationExceptionReason::InvalidBillingviewArn => "INVALID_BILLINGVIEW_ARN",
            ValidationExceptionReason::InvalidBillingGroup => "INVALID_BILLING_GROUP",
            ValidationExceptionReason::InvalidBillingGroupStatus => "INVALID_BILLING_GROUP_STATUS",
            ValidationExceptionReason::InvalidBillingPeriodForOperation => {
                "INVALID_BILLING_PERIOD_FOR_OPERATION"
            }
            ValidationExceptionReason::InvalidTimeRange => "INVALID_TIME_RANGE",
            ValidationExceptionReason::MismatchedBillinggroupArn => "MISMATCHED_BILLINGGROUP_ARN",
            ValidationExceptionReason::MismatchedBillingviewArn => "MISMATCHED_BILLINGVIEW_ARN",
            ValidationExceptionReason::MismatchedCustomlineitemArn => {
                "MISMATCHED_CUSTOMLINEITEM_ARN"
            }
            ValidationExceptionReason::MismatchedPricingplanArn => "MISMATCHED_PRICINGPLAN_ARN",
            ValidationExceptionReason::MismatchedPricingruleArn => "MISMATCHED_PRICINGRULE_ARN",
            ValidationExceptionReason::MissingBillinggroup => "MISSING_BILLINGGROUP",
            ValidationExceptionReason::MissingCustomlineitem => "MISSING_CUSTOMLINEITEM",
            ValidationExceptionReason::MissingLinkedAccountIds => "MISSING_LINKED_ACCOUNT_IDS",
            ValidationExceptionReason::MissingPricingplan => "MISSING_PRICINGPLAN",
            ValidationExceptionReason::MissingPricingPlanArn => "MISSING_PRICING_PLAN_ARN",
            ValidationExceptionReason::MultipleLinkedAccountIds => "MULTIPLE_LINKED_ACCOUNT_IDS",
            ValidationExceptionReason::MultiplePricingPlanArn => "MULTIPLE_PRICING_PLAN_ARN",
            ValidationExceptionReason::Other => "OTHER",
            ValidationExceptionReason::PricingrulesAlreadyAssociated => {
                "PRICINGRULES_ALREADY_ASSOCIATED"
            }
            ValidationExceptionReason::PricingrulesNotAssociated => "PRICINGRULES_NOT_ASSOCIATED",
            ValidationExceptionReason::PricingrulesNotExist => "PRICINGRULES_NOT_EXIST",
            ValidationExceptionReason::PrimaryCannotDisassociate => "PRIMARY_CANNOT_DISASSOCIATE",
            ValidationExceptionReason::PrimaryNotAssociated => "PRIMARY_NOT_ASSOCIATED",
            ValidationExceptionReason::TooManyAccountsInRequest => "TOO_MANY_ACCOUNTS_IN_REQUEST",
            ValidationExceptionReason::TooManyCustomlineitemsInRequest => {
                "TOO_MANY_CUSTOMLINEITEMS_IN_REQUEST"
            }
            ValidationExceptionReason::UnknownOperation => "UNKNOWN_OPERATION",
            ValidationExceptionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACCOUNTS_ALREADY_ASSOCIATED",
            "ACCOUNTS_NOT_ASSOCIATED",
            "CANNOT_PARSE",
            "CUSTOM_LINE_ITEM_ASSOCIATION_EXISTS",
            "DUPLICATE_ACCOUNT",
            "DUPLICATE_PRICINGRULE_ARNS",
            "FIELD_VALIDATION_FAILED",
            "ILLEGAL_ACCOUNTS",
            "ILLEGAL_BILLING_ENTITY",
            "ILLEGAL_BILLING_PERIOD",
            "ILLEGAL_BILLING_PERIOD_RANGE",
            "ILLEGAL_CHARGE_DETAILS",
            "ILLEGAL_CHILD_ASSOCIATE_RESOURCE",
            "ILLEGAL_CUSTOMLINEITEM",
            "ILLEGAL_CUSTOMLINEITEM_MODIFICATION",
            "ILLEGAL_CUSTOMLINEITEM_UPDATE",
            "ILLEGAL_ENDED_BILLINGGROUP",
            "ILLEGAL_EXPRESSION",
            "ILLEGAL_MODIFIER_PERCENTAGE",
            "ILLEGAL_PRIMARY_ACCOUNT",
            "ILLEGAL_RESOURCE_ARNS",
            "ILLEGAL_SCOPE",
            "ILLEGAL_SERVICE",
            "ILLEGAL_TIERING_INPUT",
            "ILLEGAL_TYPE",
            "ILLEGAL_UPDATE_CHARGE_DETAILS",
            "INVALID_ARN",
            "INVALID_BILLINGVIEW_ARN",
            "INVALID_BILLING_GROUP",
            "INVALID_BILLING_GROUP_STATUS",
            "INVALID_BILLING_PERIOD_FOR_OPERATION",
            "INVALID_TIME_RANGE",
            "MISMATCHED_BILLINGGROUP_ARN",
            "MISMATCHED_BILLINGVIEW_ARN",
            "MISMATCHED_CUSTOMLINEITEM_ARN",
            "MISMATCHED_PRICINGPLAN_ARN",
            "MISMATCHED_PRICINGRULE_ARN",
            "MISSING_BILLINGGROUP",
            "MISSING_CUSTOMLINEITEM",
            "MISSING_LINKED_ACCOUNT_IDS",
            "MISSING_PRICINGPLAN",
            "MISSING_PRICING_PLAN_ARN",
            "MULTIPLE_LINKED_ACCOUNT_IDS",
            "MULTIPLE_PRICING_PLAN_ARN",
            "OTHER",
            "PRICINGRULES_ALREADY_ASSOCIATED",
            "PRICINGRULES_NOT_ASSOCIATED",
            "PRICINGRULES_NOT_EXIST",
            "PRIMARY_CANNOT_DISASSOCIATE",
            "PRIMARY_NOT_ASSOCIATED",
            "TOO_MANY_ACCOUNTS_IN_REQUEST",
            "TOO_MANY_CUSTOMLINEITEMS_IN_REQUEST",
            "UNKNOWN_OPERATION",
        ]
    }
}
impl AsRef<str> for ValidationExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> A representation of a pricing rule. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PricingRuleListElement {
    /// <p> The name of a pricing rule. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> The Amazon Resource Name (ARN) used to uniquely identify a pricing rule. </p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p> The pricing rule description. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> The scope of pricing rule that indicates if it is globally applicable, or if it is service-specific. </p>
    #[doc(hidden)]
    pub scope: std::option::Option<crate::model::PricingRuleScope>,
    /// <p> The type of pricing rule. </p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::PricingRuleType>,
    /// <p> A percentage modifier applied on the public pricing rates. </p>
    #[doc(hidden)]
    pub modifier_percentage: std::option::Option<f64>,
    /// <p> If the <code>Scope</code> attribute is <code>SERVICE</code>, this attribute indicates which service the <code>PricingRule</code> is applicable for. </p>
    #[doc(hidden)]
    pub service: std::option::Option<std::string::String>,
    /// <p> The pricing plans count that this pricing rule is associated with. </p>
    #[doc(hidden)]
    pub associated_pricing_plan_count: i64,
    /// <p> The time when the pricing rule was created. </p>
    #[doc(hidden)]
    pub creation_time: i64,
    /// <p> The most recent time when the pricing rule was modified. </p>
    #[doc(hidden)]
    pub last_modified_time: i64,
    /// <p> The seller of services provided by Amazon Web Services, their affiliates, or third-party providers selling services via Amazon Web Services Marketplace. </p>
    #[doc(hidden)]
    pub billing_entity: std::option::Option<std::string::String>,
    /// <p> The set of tiering configurations for the pricing rule. </p>
    #[doc(hidden)]
    pub tiering: std::option::Option<crate::model::Tiering>,
}
impl PricingRuleListElement {
    /// <p> The name of a pricing rule. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> The Amazon Resource Name (ARN) used to uniquely identify a pricing rule. </p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p> The pricing rule description. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> The scope of pricing rule that indicates if it is globally applicable, or if it is service-specific. </p>
    pub fn scope(&self) -> std::option::Option<&crate::model::PricingRuleScope> {
        self.scope.as_ref()
    }
    /// <p> The type of pricing rule. </p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::PricingRuleType> {
        self.r#type.as_ref()
    }
    /// <p> A percentage modifier applied on the public pricing rates. </p>
    pub fn modifier_percentage(&self) -> std::option::Option<f64> {
        self.modifier_percentage
    }
    /// <p> If the <code>Scope</code> attribute is <code>SERVICE</code>, this attribute indicates which service the <code>PricingRule</code> is applicable for. </p>
    pub fn service(&self) -> std::option::Option<&str> {
        self.service.as_deref()
    }
    /// <p> The pricing plans count that this pricing rule is associated with. </p>
    pub fn associated_pricing_plan_count(&self) -> i64 {
        self.associated_pricing_plan_count
    }
    /// <p> The time when the pricing rule was created. </p>
    pub fn creation_time(&self) -> i64 {
        self.creation_time
    }
    /// <p> The most recent time when the pricing rule was modified. </p>
    pub fn last_modified_time(&self) -> i64 {
        self.last_modified_time
    }
    /// <p> The seller of services provided by Amazon Web Services, their affiliates, or third-party providers selling services via Amazon Web Services Marketplace. </p>
    pub fn billing_entity(&self) -> std::option::Option<&str> {
        self.billing_entity.as_deref()
    }
    /// <p> The set of tiering configurations for the pricing rule. </p>
    pub fn tiering(&self) -> std::option::Option<&crate::model::Tiering> {
        self.tiering.as_ref()
    }
}
impl std::fmt::Debug for PricingRuleListElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PricingRuleListElement");
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("arn", &self.arn);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("scope", &self.scope);
        formatter.field("r#type", &self.r#type);
        formatter.field("modifier_percentage", &self.modifier_percentage);
        formatter.field("service", &self.service);
        formatter.field(
            "associated_pricing_plan_count",
            &self.associated_pricing_plan_count,
        );
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("billing_entity", &self.billing_entity);
        formatter.field("tiering", &self.tiering);
        formatter.finish()
    }
}
/// See [`PricingRuleListElement`](crate::model::PricingRuleListElement).
pub mod pricing_rule_list_element {

    /// A builder for [`PricingRuleListElement`](crate::model::PricingRuleListElement).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::PricingRuleScope>,
        pub(crate) r#type: std::option::Option<crate::model::PricingRuleType>,
        pub(crate) modifier_percentage: std::option::Option<f64>,
        pub(crate) service: std::option::Option<std::string::String>,
        pub(crate) associated_pricing_plan_count: std::option::Option<i64>,
        pub(crate) creation_time: std::option::Option<i64>,
        pub(crate) last_modified_time: std::option::Option<i64>,
        pub(crate) billing_entity: std::option::Option<std::string::String>,
        pub(crate) tiering: std::option::Option<crate::model::Tiering>,
    }
    impl Builder {
        /// <p> The name of a pricing rule. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of a pricing rule. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> The Amazon Resource Name (ARN) used to uniquely identify a pricing rule. </p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) used to uniquely identify a pricing rule. </p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p> The pricing rule description. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> The pricing rule description. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p> The scope of pricing rule that indicates if it is globally applicable, or if it is service-specific. </p>
        pub fn scope(mut self, input: crate::model::PricingRuleScope) -> Self {
            self.scope = Some(input);
            self
        }
        /// <p> The scope of pricing rule that indicates if it is globally applicable, or if it is service-specific. </p>
        pub fn set_scope(
            mut self,
            input: std::option::Option<crate::model::PricingRuleScope>,
        ) -> Self {
            self.scope = input;
            self
        }
        /// <p> The type of pricing rule. </p>
        pub fn r#type(mut self, input: crate::model::PricingRuleType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p> The type of pricing rule. </p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::PricingRuleType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p> A percentage modifier applied on the public pricing rates. </p>
        pub fn modifier_percentage(mut self, input: f64) -> Self {
            self.modifier_percentage = Some(input);
            self
        }
        /// <p> A percentage modifier applied on the public pricing rates. </p>
        pub fn set_modifier_percentage(mut self, input: std::option::Option<f64>) -> Self {
            self.modifier_percentage = input;
            self
        }
        /// <p> If the <code>Scope</code> attribute is <code>SERVICE</code>, this attribute indicates which service the <code>PricingRule</code> is applicable for. </p>
        pub fn service(mut self, input: impl Into<std::string::String>) -> Self {
            self.service = Some(input.into());
            self
        }
        /// <p> If the <code>Scope</code> attribute is <code>SERVICE</code>, this attribute indicates which service the <code>PricingRule</code> is applicable for. </p>
        pub fn set_service(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service = input;
            self
        }
        /// <p> The pricing plans count that this pricing rule is associated with. </p>
        pub fn associated_pricing_plan_count(mut self, input: i64) -> Self {
            self.associated_pricing_plan_count = Some(input);
            self
        }
        /// <p> The pricing plans count that this pricing rule is associated with. </p>
        pub fn set_associated_pricing_plan_count(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.associated_pricing_plan_count = input;
            self
        }
        /// <p> The time when the pricing rule was created. </p>
        pub fn creation_time(mut self, input: i64) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p> The time when the pricing rule was created. </p>
        pub fn set_creation_time(mut self, input: std::option::Option<i64>) -> Self {
            self.creation_time = input;
            self
        }
        /// <p> The most recent time when the pricing rule was modified. </p>
        pub fn last_modified_time(mut self, input: i64) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p> The most recent time when the pricing rule was modified. </p>
        pub fn set_last_modified_time(mut self, input: std::option::Option<i64>) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p> The seller of services provided by Amazon Web Services, their affiliates, or third-party providers selling services via Amazon Web Services Marketplace. </p>
        pub fn billing_entity(mut self, input: impl Into<std::string::String>) -> Self {
            self.billing_entity = Some(input.into());
            self
        }
        /// <p> The seller of services provided by Amazon Web Services, their affiliates, or third-party providers selling services via Amazon Web Services Marketplace. </p>
        pub fn set_billing_entity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.billing_entity = input;
            self
        }
        /// <p> The set of tiering configurations for the pricing rule. </p>
        pub fn tiering(mut self, input: crate::model::Tiering) -> Self {
            self.tiering = Some(input);
            self
        }
        /// <p> The set of tiering configurations for the pricing rule. </p>
        pub fn set_tiering(mut self, input: std::option::Option<crate::model::Tiering>) -> Self {
            self.tiering = input;
            self
        }
        /// Consumes the builder and constructs a [`PricingRuleListElement`](crate::model::PricingRuleListElement).
        pub fn build(self) -> crate::model::PricingRuleListElement {
            crate::model::PricingRuleListElement {
                name: self.name,
                arn: self.arn,
                description: self.description,
                scope: self.scope,
                r#type: self.r#type,
                modifier_percentage: self.modifier_percentage,
                service: self.service,
                associated_pricing_plan_count: self
                    .associated_pricing_plan_count
                    .unwrap_or_default(),
                creation_time: self.creation_time.unwrap_or_default(),
                last_modified_time: self.last_modified_time.unwrap_or_default(),
                billing_entity: self.billing_entity,
                tiering: self.tiering,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("name", &"*** Sensitive Data Redacted ***");
            formatter.field("arn", &self.arn);
            formatter.field("description", &"*** Sensitive Data Redacted ***");
            formatter.field("scope", &self.scope);
            formatter.field("r#type", &self.r#type);
            formatter.field("modifier_percentage", &self.modifier_percentage);
            formatter.field("service", &self.service);
            formatter.field(
                "associated_pricing_plan_count",
                &self.associated_pricing_plan_count,
            );
            formatter.field("creation_time", &self.creation_time);
            formatter.field("last_modified_time", &self.last_modified_time);
            formatter.field("billing_entity", &self.billing_entity);
            formatter.field("tiering", &self.tiering);
            formatter.finish()
        }
    }
}
impl PricingRuleListElement {
    /// Creates a new builder-style object to manufacture [`PricingRuleListElement`](crate::model::PricingRuleListElement).
    pub fn builder() -> crate::model::pricing_rule_list_element::Builder {
        crate::model::pricing_rule_list_element::Builder::default()
    }
}

/// <p> The set of tiering configurations for the pricing rule. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tiering {
    /// <p> The possible Amazon Web Services Free Tier configurations. </p>
    #[doc(hidden)]
    pub free_tier: std::option::Option<crate::model::FreeTierConfig>,
}
impl Tiering {
    /// <p> The possible Amazon Web Services Free Tier configurations. </p>
    pub fn free_tier(&self) -> std::option::Option<&crate::model::FreeTierConfig> {
        self.free_tier.as_ref()
    }
}
/// See [`Tiering`](crate::model::Tiering).
pub mod tiering {

    /// A builder for [`Tiering`](crate::model::Tiering).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) free_tier: std::option::Option<crate::model::FreeTierConfig>,
    }
    impl Builder {
        /// <p> The possible Amazon Web Services Free Tier configurations. </p>
        pub fn free_tier(mut self, input: crate::model::FreeTierConfig) -> Self {
            self.free_tier = Some(input);
            self
        }
        /// <p> The possible Amazon Web Services Free Tier configurations. </p>
        pub fn set_free_tier(
            mut self,
            input: std::option::Option<crate::model::FreeTierConfig>,
        ) -> Self {
            self.free_tier = input;
            self
        }
        /// Consumes the builder and constructs a [`Tiering`](crate::model::Tiering).
        pub fn build(self) -> crate::model::Tiering {
            crate::model::Tiering {
                free_tier: self.free_tier,
            }
        }
    }
}
impl Tiering {
    /// Creates a new builder-style object to manufacture [`Tiering`](crate::model::Tiering).
    pub fn builder() -> crate::model::tiering::Builder {
        crate::model::tiering::Builder::default()
    }
}

/// <p> The possible Amazon Web Services Free Tier configurations. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FreeTierConfig {
    /// <p> Activate or deactivate Amazon Web Services Free Tier application. </p>
    #[doc(hidden)]
    pub activated: std::option::Option<bool>,
}
impl FreeTierConfig {
    /// <p> Activate or deactivate Amazon Web Services Free Tier application. </p>
    pub fn activated(&self) -> std::option::Option<bool> {
        self.activated
    }
}
/// See [`FreeTierConfig`](crate::model::FreeTierConfig).
pub mod free_tier_config {

    /// A builder for [`FreeTierConfig`](crate::model::FreeTierConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) activated: std::option::Option<bool>,
    }
    impl Builder {
        /// <p> Activate or deactivate Amazon Web Services Free Tier application. </p>
        pub fn activated(mut self, input: bool) -> Self {
            self.activated = Some(input);
            self
        }
        /// <p> Activate or deactivate Amazon Web Services Free Tier application. </p>
        pub fn set_activated(mut self, input: std::option::Option<bool>) -> Self {
            self.activated = input;
            self
        }
        /// Consumes the builder and constructs a [`FreeTierConfig`](crate::model::FreeTierConfig).
        pub fn build(self) -> crate::model::FreeTierConfig {
            crate::model::FreeTierConfig {
                activated: self.activated,
            }
        }
    }
}
impl FreeTierConfig {
    /// Creates a new builder-style object to manufacture [`FreeTierConfig`](crate::model::FreeTierConfig).
    pub fn builder() -> crate::model::free_tier_config::Builder {
        crate::model::free_tier_config::Builder::default()
    }
}

/// When writing a match expression against `PricingRuleType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let pricingruletype = unimplemented!();
/// match pricingruletype {
///     PricingRuleType::Discount => { /* ... */ },
///     PricingRuleType::Markup => { /* ... */ },
///     PricingRuleType::Tiering => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `pricingruletype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PricingRuleType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PricingRuleType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PricingRuleType::NewFeature` is defined.
/// Specifically, when `pricingruletype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PricingRuleType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PricingRuleType {
    #[allow(missing_docs)] // documentation missing in model
    Discount,
    #[allow(missing_docs)] // documentation missing in model
    Markup,
    #[allow(missing_docs)] // documentation missing in model
    Tiering,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PricingRuleType {
    fn from(s: &str) -> Self {
        match s {
            "DISCOUNT" => PricingRuleType::Discount,
            "MARKUP" => PricingRuleType::Markup,
            "TIERING" => PricingRuleType::Tiering,
            other => PricingRuleType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PricingRuleType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PricingRuleType::from(s))
    }
}
impl PricingRuleType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PricingRuleType::Discount => "DISCOUNT",
            PricingRuleType::Markup => "MARKUP",
            PricingRuleType::Tiering => "TIERING",
            PricingRuleType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISCOUNT", "MARKUP", "TIERING"]
    }
}
impl AsRef<str> for PricingRuleType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PricingRuleScope`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let pricingrulescope = unimplemented!();
/// match pricingrulescope {
///     PricingRuleScope::BillingEntity => { /* ... */ },
///     PricingRuleScope::Global => { /* ... */ },
///     PricingRuleScope::Service => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `pricingrulescope` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PricingRuleScope::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PricingRuleScope::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PricingRuleScope::NewFeature` is defined.
/// Specifically, when `pricingrulescope` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PricingRuleScope::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PricingRuleScope {
    #[allow(missing_docs)] // documentation missing in model
    BillingEntity,
    #[allow(missing_docs)] // documentation missing in model
    Global,
    #[allow(missing_docs)] // documentation missing in model
    Service,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PricingRuleScope {
    fn from(s: &str) -> Self {
        match s {
            "BILLING_ENTITY" => PricingRuleScope::BillingEntity,
            "GLOBAL" => PricingRuleScope::Global,
            "SERVICE" => PricingRuleScope::Service,
            other => PricingRuleScope::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PricingRuleScope {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PricingRuleScope::from(s))
    }
}
impl PricingRuleScope {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PricingRuleScope::BillingEntity => "BILLING_ENTITY",
            PricingRuleScope::Global => "GLOBAL",
            PricingRuleScope::Service => "SERVICE",
            PricingRuleScope::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BILLING_ENTITY", "GLOBAL", "SERVICE"]
    }
}
impl AsRef<str> for PricingRuleScope {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> The filter that specifies criteria that the pricing rules returned by the <code>ListPricingRules</code> API will adhere to. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListPricingRulesFilter {
    /// <p> A list containing the pricing rule Amazon Resource Names (ARNs) to include in the API response. </p>
    #[doc(hidden)]
    pub arns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ListPricingRulesFilter {
    /// <p> A list containing the pricing rule Amazon Resource Names (ARNs) to include in the API response. </p>
    pub fn arns(&self) -> std::option::Option<&[std::string::String]> {
        self.arns.as_deref()
    }
}
/// See [`ListPricingRulesFilter`](crate::model::ListPricingRulesFilter).
pub mod list_pricing_rules_filter {

    /// A builder for [`ListPricingRulesFilter`](crate::model::ListPricingRulesFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arns: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `arns`.
        ///
        /// To override the contents of this collection use [`set_arns`](Self::set_arns).
        ///
        /// <p> A list containing the pricing rule Amazon Resource Names (ARNs) to include in the API response. </p>
        pub fn arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.arns.unwrap_or_default();
            v.push(input.into());
            self.arns = Some(v);
            self
        }
        /// <p> A list containing the pricing rule Amazon Resource Names (ARNs) to include in the API response. </p>
        pub fn set_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.arns = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPricingRulesFilter`](crate::model::ListPricingRulesFilter).
        pub fn build(self) -> crate::model::ListPricingRulesFilter {
            crate::model::ListPricingRulesFilter { arns: self.arns }
        }
    }
}
impl ListPricingRulesFilter {
    /// Creates a new builder-style object to manufacture [`ListPricingRulesFilter`](crate::model::ListPricingRulesFilter).
    pub fn builder() -> crate::model::list_pricing_rules_filter::Builder {
        crate::model::list_pricing_rules_filter::Builder::default()
    }
}

/// When writing a match expression against `ConflictExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let conflictexceptionreason = unimplemented!();
/// match conflictexceptionreason {
///     ConflictExceptionReason::PricingPlanAttachedToBillingGroupDeleteConflict => { /* ... */ },
///     ConflictExceptionReason::PricingRuleAttachedToPricingPlanDeleteConflict => { /* ... */ },
///     ConflictExceptionReason::PricingRuleInPricingPlanConflict => { /* ... */ },
///     ConflictExceptionReason::ResourceNameConflict => { /* ... */ },
///     ConflictExceptionReason::WriteConflictRetry => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `conflictexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConflictExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConflictExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConflictExceptionReason::NewFeature` is defined.
/// Specifically, when `conflictexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConflictExceptionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConflictExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    PricingPlanAttachedToBillingGroupDeleteConflict,
    #[allow(missing_docs)] // documentation missing in model
    PricingRuleAttachedToPricingPlanDeleteConflict,
    #[allow(missing_docs)] // documentation missing in model
    PricingRuleInPricingPlanConflict,
    #[allow(missing_docs)] // documentation missing in model
    ResourceNameConflict,
    #[allow(missing_docs)] // documentation missing in model
    WriteConflictRetry,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConflictExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "PRICING_PLAN_ATTACHED_TO_BILLING_GROUP_DELETE_CONFLICT" => {
                ConflictExceptionReason::PricingPlanAttachedToBillingGroupDeleteConflict
            }
            "PRICING_RULE_ATTACHED_TO_PRICING_PLAN_DELETE_CONFLICT" => {
                ConflictExceptionReason::PricingRuleAttachedToPricingPlanDeleteConflict
            }
            "PRICING_RULE_IN_PRICING_PLAN_CONFLICT" => {
                ConflictExceptionReason::PricingRuleInPricingPlanConflict
            }
            "RESOURCE_NAME_CONFLICT" => ConflictExceptionReason::ResourceNameConflict,
            "WRITE_CONFLICT_RETRY" => ConflictExceptionReason::WriteConflictRetry,
            other => ConflictExceptionReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ConflictExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConflictExceptionReason::from(s))
    }
}
impl ConflictExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConflictExceptionReason::PricingPlanAttachedToBillingGroupDeleteConflict => {
                "PRICING_PLAN_ATTACHED_TO_BILLING_GROUP_DELETE_CONFLICT"
            }
            ConflictExceptionReason::PricingRuleAttachedToPricingPlanDeleteConflict => {
                "PRICING_RULE_ATTACHED_TO_PRICING_PLAN_DELETE_CONFLICT"
            }
            ConflictExceptionReason::PricingRuleInPricingPlanConflict => {
                "PRICING_RULE_IN_PRICING_PLAN_CONFLICT"
            }
            ConflictExceptionReason::ResourceNameConflict => "RESOURCE_NAME_CONFLICT",
            ConflictExceptionReason::WriteConflictRetry => "WRITE_CONFLICT_RETRY",
            ConflictExceptionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "PRICING_PLAN_ATTACHED_TO_BILLING_GROUP_DELETE_CONFLICT",
            "PRICING_RULE_ATTACHED_TO_PRICING_PLAN_DELETE_CONFLICT",
            "PRICING_RULE_IN_PRICING_PLAN_CONFLICT",
            "RESOURCE_NAME_CONFLICT",
            "WRITE_CONFLICT_RETRY",
        ]
    }
}
impl AsRef<str> for ConflictExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> The set of tiering configurations for the pricing rule. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateTieringInput {
    /// <p> The possible Amazon Web Services Free Tier configurations. </p>
    #[doc(hidden)]
    pub free_tier: std::option::Option<crate::model::CreateFreeTierConfig>,
}
impl CreateTieringInput {
    /// <p> The possible Amazon Web Services Free Tier configurations. </p>
    pub fn free_tier(&self) -> std::option::Option<&crate::model::CreateFreeTierConfig> {
        self.free_tier.as_ref()
    }
}
/// See [`CreateTieringInput`](crate::model::CreateTieringInput).
pub mod create_tiering_input {

    /// A builder for [`CreateTieringInput`](crate::model::CreateTieringInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) free_tier: std::option::Option<crate::model::CreateFreeTierConfig>,
    }
    impl Builder {
        /// <p> The possible Amazon Web Services Free Tier configurations. </p>
        pub fn free_tier(mut self, input: crate::model::CreateFreeTierConfig) -> Self {
            self.free_tier = Some(input);
            self
        }
        /// <p> The possible Amazon Web Services Free Tier configurations. </p>
        pub fn set_free_tier(
            mut self,
            input: std::option::Option<crate::model::CreateFreeTierConfig>,
        ) -> Self {
            self.free_tier = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateTieringInput`](crate::model::CreateTieringInput).
        pub fn build(self) -> crate::model::CreateTieringInput {
            crate::model::CreateTieringInput {
                free_tier: self.free_tier,
            }
        }
    }
}
impl CreateTieringInput {
    /// Creates a new builder-style object to manufacture [`CreateTieringInput`](crate::model::CreateTieringInput).
    pub fn builder() -> crate::model::create_tiering_input::Builder {
        crate::model::create_tiering_input::Builder::default()
    }
}

/// <p> The possible Amazon Web Services Free Tier configurations. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateFreeTierConfig {
    /// <p> Activate or deactivate Amazon Web Services Free Tier. </p>
    #[doc(hidden)]
    pub activated: std::option::Option<bool>,
}
impl CreateFreeTierConfig {
    /// <p> Activate or deactivate Amazon Web Services Free Tier. </p>
    pub fn activated(&self) -> std::option::Option<bool> {
        self.activated
    }
}
/// See [`CreateFreeTierConfig`](crate::model::CreateFreeTierConfig).
pub mod create_free_tier_config {

    /// A builder for [`CreateFreeTierConfig`](crate::model::CreateFreeTierConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) activated: std::option::Option<bool>,
    }
    impl Builder {
        /// <p> Activate or deactivate Amazon Web Services Free Tier. </p>
        pub fn activated(mut self, input: bool) -> Self {
            self.activated = Some(input);
            self
        }
        /// <p> Activate or deactivate Amazon Web Services Free Tier. </p>
        pub fn set_activated(mut self, input: std::option::Option<bool>) -> Self {
            self.activated = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateFreeTierConfig`](crate::model::CreateFreeTierConfig).
        pub fn build(self) -> crate::model::CreateFreeTierConfig {
            crate::model::CreateFreeTierConfig {
                activated: self.activated,
            }
        }
    }
}
impl CreateFreeTierConfig {
    /// Creates a new builder-style object to manufacture [`CreateFreeTierConfig`](crate::model::CreateFreeTierConfig).
    pub fn builder() -> crate::model::create_free_tier_config::Builder {
        crate::model::create_free_tier_config::Builder::default()
    }
}

/// <p> The set of tiering configurations for the pricing rule. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateTieringInput {
    /// <p> The possible Amazon Web Services Free Tier configurations. </p>
    #[doc(hidden)]
    pub free_tier: std::option::Option<crate::model::UpdateFreeTierConfig>,
}
impl UpdateTieringInput {
    /// <p> The possible Amazon Web Services Free Tier configurations. </p>
    pub fn free_tier(&self) -> std::option::Option<&crate::model::UpdateFreeTierConfig> {
        self.free_tier.as_ref()
    }
}
/// See [`UpdateTieringInput`](crate::model::UpdateTieringInput).
pub mod update_tiering_input {

    /// A builder for [`UpdateTieringInput`](crate::model::UpdateTieringInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) free_tier: std::option::Option<crate::model::UpdateFreeTierConfig>,
    }
    impl Builder {
        /// <p> The possible Amazon Web Services Free Tier configurations. </p>
        pub fn free_tier(mut self, input: crate::model::UpdateFreeTierConfig) -> Self {
            self.free_tier = Some(input);
            self
        }
        /// <p> The possible Amazon Web Services Free Tier configurations. </p>
        pub fn set_free_tier(
            mut self,
            input: std::option::Option<crate::model::UpdateFreeTierConfig>,
        ) -> Self {
            self.free_tier = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateTieringInput`](crate::model::UpdateTieringInput).
        pub fn build(self) -> crate::model::UpdateTieringInput {
            crate::model::UpdateTieringInput {
                free_tier: self.free_tier,
            }
        }
    }
}
impl UpdateTieringInput {
    /// Creates a new builder-style object to manufacture [`UpdateTieringInput`](crate::model::UpdateTieringInput).
    pub fn builder() -> crate::model::update_tiering_input::Builder {
        crate::model::update_tiering_input::Builder::default()
    }
}

/// <p> The possible Amazon Web Services Free Tier configurations. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateFreeTierConfig {
    /// <p> Activate or deactivate application of Amazon Web Services Free Tier. </p>
    #[doc(hidden)]
    pub activated: std::option::Option<bool>,
}
impl UpdateFreeTierConfig {
    /// <p> Activate or deactivate application of Amazon Web Services Free Tier. </p>
    pub fn activated(&self) -> std::option::Option<bool> {
        self.activated
    }
}
/// See [`UpdateFreeTierConfig`](crate::model::UpdateFreeTierConfig).
pub mod update_free_tier_config {

    /// A builder for [`UpdateFreeTierConfig`](crate::model::UpdateFreeTierConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) activated: std::option::Option<bool>,
    }
    impl Builder {
        /// <p> Activate or deactivate application of Amazon Web Services Free Tier. </p>
        pub fn activated(mut self, input: bool) -> Self {
            self.activated = Some(input);
            self
        }
        /// <p> Activate or deactivate application of Amazon Web Services Free Tier. </p>
        pub fn set_activated(mut self, input: std::option::Option<bool>) -> Self {
            self.activated = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateFreeTierConfig`](crate::model::UpdateFreeTierConfig).
        pub fn build(self) -> crate::model::UpdateFreeTierConfig {
            crate::model::UpdateFreeTierConfig {
                activated: self.activated,
            }
        }
    }
}
impl UpdateFreeTierConfig {
    /// Creates a new builder-style object to manufacture [`UpdateFreeTierConfig`](crate::model::UpdateFreeTierConfig).
    pub fn builder() -> crate::model::update_free_tier_config::Builder {
        crate::model::update_free_tier_config::Builder::default()
    }
}

/// <p>A representation of a pricing plan. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PricingPlanListElement {
    /// <p>The name of a pricing plan. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The pricing plan Amazon Resource Names (ARN). This can be used to uniquely identify a pricing plan. </p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The pricing plan description. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> The pricing rules count that's currently associated with this pricing plan list element. </p>
    #[doc(hidden)]
    pub size: i64,
    /// <p> The time when the pricing plan was created. </p>
    #[doc(hidden)]
    pub creation_time: i64,
    /// <p> The most recent time when the pricing plan was modified. </p>
    #[doc(hidden)]
    pub last_modified_time: i64,
}
impl PricingPlanListElement {
    /// <p>The name of a pricing plan. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The pricing plan Amazon Resource Names (ARN). This can be used to uniquely identify a pricing plan. </p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The pricing plan description. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> The pricing rules count that's currently associated with this pricing plan list element. </p>
    pub fn size(&self) -> i64 {
        self.size
    }
    /// <p> The time when the pricing plan was created. </p>
    pub fn creation_time(&self) -> i64 {
        self.creation_time
    }
    /// <p> The most recent time when the pricing plan was modified. </p>
    pub fn last_modified_time(&self) -> i64 {
        self.last_modified_time
    }
}
impl std::fmt::Debug for PricingPlanListElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PricingPlanListElement");
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("arn", &self.arn);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("size", &self.size);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`PricingPlanListElement`](crate::model::PricingPlanListElement).
pub mod pricing_plan_list_element {

    /// A builder for [`PricingPlanListElement`](crate::model::PricingPlanListElement).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) size: std::option::Option<i64>,
        pub(crate) creation_time: std::option::Option<i64>,
        pub(crate) last_modified_time: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of a pricing plan. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a pricing plan. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The pricing plan Amazon Resource Names (ARN). This can be used to uniquely identify a pricing plan. </p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The pricing plan Amazon Resource Names (ARN). This can be used to uniquely identify a pricing plan. </p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The pricing plan description. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The pricing plan description. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p> The pricing rules count that's currently associated with this pricing plan list element. </p>
        pub fn size(mut self, input: i64) -> Self {
            self.size = Some(input);
            self
        }
        /// <p> The pricing rules count that's currently associated with this pricing plan list element. </p>
        pub fn set_size(mut self, input: std::option::Option<i64>) -> Self {
            self.size = input;
            self
        }
        /// <p> The time when the pricing plan was created. </p>
        pub fn creation_time(mut self, input: i64) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p> The time when the pricing plan was created. </p>
        pub fn set_creation_time(mut self, input: std::option::Option<i64>) -> Self {
            self.creation_time = input;
            self
        }
        /// <p> The most recent time when the pricing plan was modified. </p>
        pub fn last_modified_time(mut self, input: i64) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p> The most recent time when the pricing plan was modified. </p>
        pub fn set_last_modified_time(mut self, input: std::option::Option<i64>) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`PricingPlanListElement`](crate::model::PricingPlanListElement).
        pub fn build(self) -> crate::model::PricingPlanListElement {
            crate::model::PricingPlanListElement {
                name: self.name,
                arn: self.arn,
                description: self.description,
                size: self.size.unwrap_or_default(),
                creation_time: self.creation_time.unwrap_or_default(),
                last_modified_time: self.last_modified_time.unwrap_or_default(),
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("name", &"*** Sensitive Data Redacted ***");
            formatter.field("arn", &self.arn);
            formatter.field("description", &"*** Sensitive Data Redacted ***");
            formatter.field("size", &self.size);
            formatter.field("creation_time", &self.creation_time);
            formatter.field("last_modified_time", &self.last_modified_time);
            formatter.finish()
        }
    }
}
impl PricingPlanListElement {
    /// Creates a new builder-style object to manufacture [`PricingPlanListElement`](crate::model::PricingPlanListElement).
    pub fn builder() -> crate::model::pricing_plan_list_element::Builder {
        crate::model::pricing_plan_list_element::Builder::default()
    }
}

/// <p>The filter that specifies the Amazon Resource Names (ARNs) of pricing plans, to retrieve pricing plan information. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListPricingPlansFilter {
    /// <p>A list of pricing plan Amazon Resource Names (ARNs) to retrieve information. </p>
    #[doc(hidden)]
    pub arns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ListPricingPlansFilter {
    /// <p>A list of pricing plan Amazon Resource Names (ARNs) to retrieve information. </p>
    pub fn arns(&self) -> std::option::Option<&[std::string::String]> {
        self.arns.as_deref()
    }
}
/// See [`ListPricingPlansFilter`](crate::model::ListPricingPlansFilter).
pub mod list_pricing_plans_filter {

    /// A builder for [`ListPricingPlansFilter`](crate::model::ListPricingPlansFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arns: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `arns`.
        ///
        /// To override the contents of this collection use [`set_arns`](Self::set_arns).
        ///
        /// <p>A list of pricing plan Amazon Resource Names (ARNs) to retrieve information. </p>
        pub fn arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.arns.unwrap_or_default();
            v.push(input.into());
            self.arns = Some(v);
            self
        }
        /// <p>A list of pricing plan Amazon Resource Names (ARNs) to retrieve information. </p>
        pub fn set_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.arns = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPricingPlansFilter`](crate::model::ListPricingPlansFilter).
        pub fn build(self) -> crate::model::ListPricingPlansFilter {
            crate::model::ListPricingPlansFilter { arns: self.arns }
        }
    }
}
impl ListPricingPlansFilter {
    /// Creates a new builder-style object to manufacture [`ListPricingPlansFilter`](crate::model::ListPricingPlansFilter).
    pub fn builder() -> crate::model::list_pricing_plans_filter::Builder {
        crate::model::list_pricing_plans_filter::Builder::default()
    }
}

/// <p> A representation of a resource association for a custom line item. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListResourcesAssociatedToCustomLineItemResponseElement {
    /// <p> The ARN of the associated resource. </p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p> The type of relationship between the custom line item and the associated resource. </p>
    #[doc(hidden)]
    pub relationship: std::option::Option<crate::model::CustomLineItemRelationship>,
    /// <p>The end billing period of the associated resource.</p>
    #[doc(hidden)]
    pub end_billing_period: std::option::Option<std::string::String>,
}
impl ListResourcesAssociatedToCustomLineItemResponseElement {
    /// <p> The ARN of the associated resource. </p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p> The type of relationship between the custom line item and the associated resource. </p>
    pub fn relationship(&self) -> std::option::Option<&crate::model::CustomLineItemRelationship> {
        self.relationship.as_ref()
    }
    /// <p>The end billing period of the associated resource.</p>
    pub fn end_billing_period(&self) -> std::option::Option<&str> {
        self.end_billing_period.as_deref()
    }
}
/// See [`ListResourcesAssociatedToCustomLineItemResponseElement`](crate::model::ListResourcesAssociatedToCustomLineItemResponseElement).
pub mod list_resources_associated_to_custom_line_item_response_element {

    /// A builder for [`ListResourcesAssociatedToCustomLineItemResponseElement`](crate::model::ListResourcesAssociatedToCustomLineItemResponseElement).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) relationship: std::option::Option<crate::model::CustomLineItemRelationship>,
        pub(crate) end_billing_period: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The ARN of the associated resource. </p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p> The ARN of the associated resource. </p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p> The type of relationship between the custom line item and the associated resource. </p>
        pub fn relationship(mut self, input: crate::model::CustomLineItemRelationship) -> Self {
            self.relationship = Some(input);
            self
        }
        /// <p> The type of relationship between the custom line item and the associated resource. </p>
        pub fn set_relationship(
            mut self,
            input: std::option::Option<crate::model::CustomLineItemRelationship>,
        ) -> Self {
            self.relationship = input;
            self
        }
        /// <p>The end billing period of the associated resource.</p>
        pub fn end_billing_period(mut self, input: impl Into<std::string::String>) -> Self {
            self.end_billing_period = Some(input.into());
            self
        }
        /// <p>The end billing period of the associated resource.</p>
        pub fn set_end_billing_period(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.end_billing_period = input;
            self
        }
        /// Consumes the builder and constructs a [`ListResourcesAssociatedToCustomLineItemResponseElement`](crate::model::ListResourcesAssociatedToCustomLineItemResponseElement).
        pub fn build(self) -> crate::model::ListResourcesAssociatedToCustomLineItemResponseElement {
            crate::model::ListResourcesAssociatedToCustomLineItemResponseElement {
                arn: self.arn,
                relationship: self.relationship,
                end_billing_period: self.end_billing_period,
            }
        }
    }
}
impl ListResourcesAssociatedToCustomLineItemResponseElement {
    /// Creates a new builder-style object to manufacture [`ListResourcesAssociatedToCustomLineItemResponseElement`](crate::model::ListResourcesAssociatedToCustomLineItemResponseElement).
    pub fn builder(
    ) -> crate::model::list_resources_associated_to_custom_line_item_response_element::Builder {
        crate::model::list_resources_associated_to_custom_line_item_response_element::Builder::default()
    }
}

/// When writing a match expression against `CustomLineItemRelationship`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let customlineitemrelationship = unimplemented!();
/// match customlineitemrelationship {
///     CustomLineItemRelationship::Child => { /* ... */ },
///     CustomLineItemRelationship::Parent => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `customlineitemrelationship` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CustomLineItemRelationship::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CustomLineItemRelationship::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CustomLineItemRelationship::NewFeature` is defined.
/// Specifically, when `customlineitemrelationship` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CustomLineItemRelationship::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CustomLineItemRelationship {
    #[allow(missing_docs)] // documentation missing in model
    Child,
    #[allow(missing_docs)] // documentation missing in model
    Parent,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CustomLineItemRelationship {
    fn from(s: &str) -> Self {
        match s {
            "CHILD" => CustomLineItemRelationship::Child,
            "PARENT" => CustomLineItemRelationship::Parent,
            other => CustomLineItemRelationship::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for CustomLineItemRelationship {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CustomLineItemRelationship::from(s))
    }
}
impl CustomLineItemRelationship {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CustomLineItemRelationship::Child => "CHILD",
            CustomLineItemRelationship::Parent => "PARENT",
            CustomLineItemRelationship::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CHILD", "PARENT"]
    }
}
impl AsRef<str> for CustomLineItemRelationship {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> A filter that specifies the type of resource associations that should be retrieved for a custom line item. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListResourcesAssociatedToCustomLineItemFilter {
    /// <p> The type of relationship between the custom line item and the associated resource. </p>
    #[doc(hidden)]
    pub relationship: std::option::Option<crate::model::CustomLineItemRelationship>,
}
impl ListResourcesAssociatedToCustomLineItemFilter {
    /// <p> The type of relationship between the custom line item and the associated resource. </p>
    pub fn relationship(&self) -> std::option::Option<&crate::model::CustomLineItemRelationship> {
        self.relationship.as_ref()
    }
}
/// See [`ListResourcesAssociatedToCustomLineItemFilter`](crate::model::ListResourcesAssociatedToCustomLineItemFilter).
pub mod list_resources_associated_to_custom_line_item_filter {

    /// A builder for [`ListResourcesAssociatedToCustomLineItemFilter`](crate::model::ListResourcesAssociatedToCustomLineItemFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relationship: std::option::Option<crate::model::CustomLineItemRelationship>,
    }
    impl Builder {
        /// <p> The type of relationship between the custom line item and the associated resource. </p>
        pub fn relationship(mut self, input: crate::model::CustomLineItemRelationship) -> Self {
            self.relationship = Some(input);
            self
        }
        /// <p> The type of relationship between the custom line item and the associated resource. </p>
        pub fn set_relationship(
            mut self,
            input: std::option::Option<crate::model::CustomLineItemRelationship>,
        ) -> Self {
            self.relationship = input;
            self
        }
        /// Consumes the builder and constructs a [`ListResourcesAssociatedToCustomLineItemFilter`](crate::model::ListResourcesAssociatedToCustomLineItemFilter).
        pub fn build(self) -> crate::model::ListResourcesAssociatedToCustomLineItemFilter {
            crate::model::ListResourcesAssociatedToCustomLineItemFilter {
                relationship: self.relationship,
            }
        }
    }
}
impl ListResourcesAssociatedToCustomLineItemFilter {
    /// Creates a new builder-style object to manufacture [`ListResourcesAssociatedToCustomLineItemFilter`](crate::model::ListResourcesAssociatedToCustomLineItemFilter).
    pub fn builder() -> crate::model::list_resources_associated_to_custom_line_item_filter::Builder
    {
        crate::model::list_resources_associated_to_custom_line_item_filter::Builder::default()
    }
}

/// <p>A representation of a custom line item version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomLineItemVersionListElement {
    /// <p>The name of the custom line item.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> A representation of the charge details of a custom line item. </p>
    #[doc(hidden)]
    pub charge_details: std::option::Option<crate::model::ListCustomLineItemChargeDetails>,
    /// <p>The charge value currency of the custom line item.</p>
    #[doc(hidden)]
    pub currency_code: std::option::Option<crate::model::CurrencyCode>,
    /// <p>The description of the custom line item.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The product code that’s associated with the custom line item.</p>
    #[doc(hidden)]
    pub product_code: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the billing group that the custom line item applies to.</p>
    #[doc(hidden)]
    pub billing_group_arn: std::option::Option<std::string::String>,
    /// <p>The time when the custom line item version was created.</p>
    #[doc(hidden)]
    pub creation_time: i64,
    /// <p>The most recent time that the custom line item version was modified.</p>
    #[doc(hidden)]
    pub last_modified_time: i64,
    /// <p>The number of resources that are associated with the custom line item.</p>
    #[doc(hidden)]
    pub association_size: i64,
    /// <p>The start billing period of the custom line item version.</p>
    #[doc(hidden)]
    pub start_billing_period: std::option::Option<std::string::String>,
    /// <p>The end billing period of the custom line item version.</p>
    #[doc(hidden)]
    pub end_billing_period: std::option::Option<std::string::String>,
}
impl CustomLineItemVersionListElement {
    /// <p>The name of the custom line item.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> A representation of the charge details of a custom line item. </p>
    pub fn charge_details(
        &self,
    ) -> std::option::Option<&crate::model::ListCustomLineItemChargeDetails> {
        self.charge_details.as_ref()
    }
    /// <p>The charge value currency of the custom line item.</p>
    pub fn currency_code(&self) -> std::option::Option<&crate::model::CurrencyCode> {
        self.currency_code.as_ref()
    }
    /// <p>The description of the custom line item.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The product code that’s associated with the custom line item.</p>
    pub fn product_code(&self) -> std::option::Option<&str> {
        self.product_code.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the billing group that the custom line item applies to.</p>
    pub fn billing_group_arn(&self) -> std::option::Option<&str> {
        self.billing_group_arn.as_deref()
    }
    /// <p>The time when the custom line item version was created.</p>
    pub fn creation_time(&self) -> i64 {
        self.creation_time
    }
    /// <p>The most recent time that the custom line item version was modified.</p>
    pub fn last_modified_time(&self) -> i64 {
        self.last_modified_time
    }
    /// <p>The number of resources that are associated with the custom line item.</p>
    pub fn association_size(&self) -> i64 {
        self.association_size
    }
    /// <p>The start billing period of the custom line item version.</p>
    pub fn start_billing_period(&self) -> std::option::Option<&str> {
        self.start_billing_period.as_deref()
    }
    /// <p>The end billing period of the custom line item version.</p>
    pub fn end_billing_period(&self) -> std::option::Option<&str> {
        self.end_billing_period.as_deref()
    }
}
impl std::fmt::Debug for CustomLineItemVersionListElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomLineItemVersionListElement");
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("charge_details", &self.charge_details);
        formatter.field("currency_code", &self.currency_code);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("product_code", &self.product_code);
        formatter.field("billing_group_arn", &self.billing_group_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("association_size", &self.association_size);
        formatter.field("start_billing_period", &self.start_billing_period);
        formatter.field("end_billing_period", &self.end_billing_period);
        formatter.finish()
    }
}
/// See [`CustomLineItemVersionListElement`](crate::model::CustomLineItemVersionListElement).
pub mod custom_line_item_version_list_element {

    /// A builder for [`CustomLineItemVersionListElement`](crate::model::CustomLineItemVersionListElement).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) charge_details:
            std::option::Option<crate::model::ListCustomLineItemChargeDetails>,
        pub(crate) currency_code: std::option::Option<crate::model::CurrencyCode>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) product_code: std::option::Option<std::string::String>,
        pub(crate) billing_group_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<i64>,
        pub(crate) last_modified_time: std::option::Option<i64>,
        pub(crate) association_size: std::option::Option<i64>,
        pub(crate) start_billing_period: std::option::Option<std::string::String>,
        pub(crate) end_billing_period: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the custom line item.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the custom line item.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> A representation of the charge details of a custom line item. </p>
        pub fn charge_details(
            mut self,
            input: crate::model::ListCustomLineItemChargeDetails,
        ) -> Self {
            self.charge_details = Some(input);
            self
        }
        /// <p> A representation of the charge details of a custom line item. </p>
        pub fn set_charge_details(
            mut self,
            input: std::option::Option<crate::model::ListCustomLineItemChargeDetails>,
        ) -> Self {
            self.charge_details = input;
            self
        }
        /// <p>The charge value currency of the custom line item.</p>
        pub fn currency_code(mut self, input: crate::model::CurrencyCode) -> Self {
            self.currency_code = Some(input);
            self
        }
        /// <p>The charge value currency of the custom line item.</p>
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<crate::model::CurrencyCode>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// <p>The description of the custom line item.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the custom line item.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The product code that’s associated with the custom line item.</p>
        pub fn product_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_code = Some(input.into());
            self
        }
        /// <p>The product code that’s associated with the custom line item.</p>
        pub fn set_product_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_code = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the billing group that the custom line item applies to.</p>
        pub fn billing_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.billing_group_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the billing group that the custom line item applies to.</p>
        pub fn set_billing_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.billing_group_arn = input;
            self
        }
        /// <p>The time when the custom line item version was created.</p>
        pub fn creation_time(mut self, input: i64) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time when the custom line item version was created.</p>
        pub fn set_creation_time(mut self, input: std::option::Option<i64>) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The most recent time that the custom line item version was modified.</p>
        pub fn last_modified_time(mut self, input: i64) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The most recent time that the custom line item version was modified.</p>
        pub fn set_last_modified_time(mut self, input: std::option::Option<i64>) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The number of resources that are associated with the custom line item.</p>
        pub fn association_size(mut self, input: i64) -> Self {
            self.association_size = Some(input);
            self
        }
        /// <p>The number of resources that are associated with the custom line item.</p>
        pub fn set_association_size(mut self, input: std::option::Option<i64>) -> Self {
            self.association_size = input;
            self
        }
        /// <p>The start billing period of the custom line item version.</p>
        pub fn start_billing_period(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_billing_period = Some(input.into());
            self
        }
        /// <p>The start billing period of the custom line item version.</p>
        pub fn set_start_billing_period(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.start_billing_period = input;
            self
        }
        /// <p>The end billing period of the custom line item version.</p>
        pub fn end_billing_period(mut self, input: impl Into<std::string::String>) -> Self {
            self.end_billing_period = Some(input.into());
            self
        }
        /// <p>The end billing period of the custom line item version.</p>
        pub fn set_end_billing_period(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.end_billing_period = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomLineItemVersionListElement`](crate::model::CustomLineItemVersionListElement).
        pub fn build(self) -> crate::model::CustomLineItemVersionListElement {
            crate::model::CustomLineItemVersionListElement {
                name: self.name,
                charge_details: self.charge_details,
                currency_code: self.currency_code,
                description: self.description,
                product_code: self.product_code,
                billing_group_arn: self.billing_group_arn,
                creation_time: self.creation_time.unwrap_or_default(),
                last_modified_time: self.last_modified_time.unwrap_or_default(),
                association_size: self.association_size.unwrap_or_default(),
                start_billing_period: self.start_billing_period,
                end_billing_period: self.end_billing_period,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("name", &"*** Sensitive Data Redacted ***");
            formatter.field("charge_details", &self.charge_details);
            formatter.field("currency_code", &self.currency_code);
            formatter.field("description", &"*** Sensitive Data Redacted ***");
            formatter.field("product_code", &self.product_code);
            formatter.field("billing_group_arn", &self.billing_group_arn);
            formatter.field("creation_time", &self.creation_time);
            formatter.field("last_modified_time", &self.last_modified_time);
            formatter.field("association_size", &self.association_size);
            formatter.field("start_billing_period", &self.start_billing_period);
            formatter.field("end_billing_period", &self.end_billing_period);
            formatter.finish()
        }
    }
}
impl CustomLineItemVersionListElement {
    /// Creates a new builder-style object to manufacture [`CustomLineItemVersionListElement`](crate::model::CustomLineItemVersionListElement).
    pub fn builder() -> crate::model::custom_line_item_version_list_element::Builder {
        crate::model::custom_line_item_version_list_element::Builder::default()
    }
}

/// When writing a match expression against `CurrencyCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let currencycode = unimplemented!();
/// match currencycode {
///     CurrencyCode::Cny => { /* ... */ },
///     CurrencyCode::Usd => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `currencycode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CurrencyCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CurrencyCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CurrencyCode::NewFeature` is defined.
/// Specifically, when `currencycode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CurrencyCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CurrencyCode {
    #[allow(missing_docs)] // documentation missing in model
    Cny,
    #[allow(missing_docs)] // documentation missing in model
    Usd,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CurrencyCode {
    fn from(s: &str) -> Self {
        match s {
            "CNY" => CurrencyCode::Cny,
            "USD" => CurrencyCode::Usd,
            other => CurrencyCode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for CurrencyCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CurrencyCode::from(s))
    }
}
impl CurrencyCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CurrencyCode::Cny => "CNY",
            CurrencyCode::Usd => "USD",
            CurrencyCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CNY", "USD"]
    }
}
impl AsRef<str> for CurrencyCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> A representation of the charge details of a custom line item. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListCustomLineItemChargeDetails {
    /// <p> A <code>ListCustomLineItemFlatChargeDetails</code> that describes the charge details of a flat custom line item. </p>
    #[doc(hidden)]
    pub flat: std::option::Option<crate::model::ListCustomLineItemFlatChargeDetails>,
    /// <p> A <code>ListCustomLineItemPercentageChargeDetails</code> that describes the charge details of a percentage custom line item. </p>
    #[doc(hidden)]
    pub percentage: std::option::Option<crate::model::ListCustomLineItemPercentageChargeDetails>,
    /// <p> The type of the custom line item that indicates whether the charge is a <code>fee</code> or <code>credit</code>. </p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::CustomLineItemType>,
}
impl ListCustomLineItemChargeDetails {
    /// <p> A <code>ListCustomLineItemFlatChargeDetails</code> that describes the charge details of a flat custom line item. </p>
    pub fn flat(&self) -> std::option::Option<&crate::model::ListCustomLineItemFlatChargeDetails> {
        self.flat.as_ref()
    }
    /// <p> A <code>ListCustomLineItemPercentageChargeDetails</code> that describes the charge details of a percentage custom line item. </p>
    pub fn percentage(
        &self,
    ) -> std::option::Option<&crate::model::ListCustomLineItemPercentageChargeDetails> {
        self.percentage.as_ref()
    }
    /// <p> The type of the custom line item that indicates whether the charge is a <code>fee</code> or <code>credit</code>. </p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::CustomLineItemType> {
        self.r#type.as_ref()
    }
}
/// See [`ListCustomLineItemChargeDetails`](crate::model::ListCustomLineItemChargeDetails).
pub mod list_custom_line_item_charge_details {

    /// A builder for [`ListCustomLineItemChargeDetails`](crate::model::ListCustomLineItemChargeDetails).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) flat: std::option::Option<crate::model::ListCustomLineItemFlatChargeDetails>,
        pub(crate) percentage:
            std::option::Option<crate::model::ListCustomLineItemPercentageChargeDetails>,
        pub(crate) r#type: std::option::Option<crate::model::CustomLineItemType>,
    }
    impl Builder {
        /// <p> A <code>ListCustomLineItemFlatChargeDetails</code> that describes the charge details of a flat custom line item. </p>
        pub fn flat(mut self, input: crate::model::ListCustomLineItemFlatChargeDetails) -> Self {
            self.flat = Some(input);
            self
        }
        /// <p> A <code>ListCustomLineItemFlatChargeDetails</code> that describes the charge details of a flat custom line item. </p>
        pub fn set_flat(
            mut self,
            input: std::option::Option<crate::model::ListCustomLineItemFlatChargeDetails>,
        ) -> Self {
            self.flat = input;
            self
        }
        /// <p> A <code>ListCustomLineItemPercentageChargeDetails</code> that describes the charge details of a percentage custom line item. </p>
        pub fn percentage(
            mut self,
            input: crate::model::ListCustomLineItemPercentageChargeDetails,
        ) -> Self {
            self.percentage = Some(input);
            self
        }
        /// <p> A <code>ListCustomLineItemPercentageChargeDetails</code> that describes the charge details of a percentage custom line item. </p>
        pub fn set_percentage(
            mut self,
            input: std::option::Option<crate::model::ListCustomLineItemPercentageChargeDetails>,
        ) -> Self {
            self.percentage = input;
            self
        }
        /// <p> The type of the custom line item that indicates whether the charge is a <code>fee</code> or <code>credit</code>. </p>
        pub fn r#type(mut self, input: crate::model::CustomLineItemType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p> The type of the custom line item that indicates whether the charge is a <code>fee</code> or <code>credit</code>. </p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::CustomLineItemType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCustomLineItemChargeDetails`](crate::model::ListCustomLineItemChargeDetails).
        pub fn build(self) -> crate::model::ListCustomLineItemChargeDetails {
            crate::model::ListCustomLineItemChargeDetails {
                flat: self.flat,
                percentage: self.percentage,
                r#type: self.r#type,
            }
        }
    }
}
impl ListCustomLineItemChargeDetails {
    /// Creates a new builder-style object to manufacture [`ListCustomLineItemChargeDetails`](crate::model::ListCustomLineItemChargeDetails).
    pub fn builder() -> crate::model::list_custom_line_item_charge_details::Builder {
        crate::model::list_custom_line_item_charge_details::Builder::default()
    }
}

/// When writing a match expression against `CustomLineItemType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let customlineitemtype = unimplemented!();
/// match customlineitemtype {
///     CustomLineItemType::Credit => { /* ... */ },
///     CustomLineItemType::Fee => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `customlineitemtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CustomLineItemType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CustomLineItemType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CustomLineItemType::NewFeature` is defined.
/// Specifically, when `customlineitemtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CustomLineItemType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CustomLineItemType {
    #[allow(missing_docs)] // documentation missing in model
    Credit,
    #[allow(missing_docs)] // documentation missing in model
    Fee,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CustomLineItemType {
    fn from(s: &str) -> Self {
        match s {
            "CREDIT" => CustomLineItemType::Credit,
            "FEE" => CustomLineItemType::Fee,
            other => {
                CustomLineItemType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for CustomLineItemType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CustomLineItemType::from(s))
    }
}
impl CustomLineItemType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CustomLineItemType::Credit => "CREDIT",
            CustomLineItemType::Fee => "FEE",
            CustomLineItemType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CREDIT", "FEE"]
    }
}
impl AsRef<str> for CustomLineItemType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> A representation of the charge details that are associated with a percentage custom line item. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListCustomLineItemPercentageChargeDetails {
    /// <p> The custom line item's percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value. </p>
    #[doc(hidden)]
    pub percentage_value: std::option::Option<f64>,
}
impl ListCustomLineItemPercentageChargeDetails {
    /// <p> The custom line item's percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value. </p>
    pub fn percentage_value(&self) -> std::option::Option<f64> {
        self.percentage_value
    }
}
/// See [`ListCustomLineItemPercentageChargeDetails`](crate::model::ListCustomLineItemPercentageChargeDetails).
pub mod list_custom_line_item_percentage_charge_details {

    /// A builder for [`ListCustomLineItemPercentageChargeDetails`](crate::model::ListCustomLineItemPercentageChargeDetails).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) percentage_value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p> The custom line item's percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value. </p>
        pub fn percentage_value(mut self, input: f64) -> Self {
            self.percentage_value = Some(input);
            self
        }
        /// <p> The custom line item's percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value. </p>
        pub fn set_percentage_value(mut self, input: std::option::Option<f64>) -> Self {
            self.percentage_value = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCustomLineItemPercentageChargeDetails`](crate::model::ListCustomLineItemPercentageChargeDetails).
        pub fn build(self) -> crate::model::ListCustomLineItemPercentageChargeDetails {
            crate::model::ListCustomLineItemPercentageChargeDetails {
                percentage_value: self.percentage_value,
            }
        }
    }
}
impl ListCustomLineItemPercentageChargeDetails {
    /// Creates a new builder-style object to manufacture [`ListCustomLineItemPercentageChargeDetails`](crate::model::ListCustomLineItemPercentageChargeDetails).
    pub fn builder() -> crate::model::list_custom_line_item_percentage_charge_details::Builder {
        crate::model::list_custom_line_item_percentage_charge_details::Builder::default()
    }
}

/// <p> A representation of the charge details that are associated with a flat custom line item. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListCustomLineItemFlatChargeDetails {
    /// <p> The custom line item's fixed charge value in USD. </p>
    #[doc(hidden)]
    pub charge_value: std::option::Option<f64>,
}
impl ListCustomLineItemFlatChargeDetails {
    /// <p> The custom line item's fixed charge value in USD. </p>
    pub fn charge_value(&self) -> std::option::Option<f64> {
        self.charge_value
    }
}
/// See [`ListCustomLineItemFlatChargeDetails`](crate::model::ListCustomLineItemFlatChargeDetails).
pub mod list_custom_line_item_flat_charge_details {

    /// A builder for [`ListCustomLineItemFlatChargeDetails`](crate::model::ListCustomLineItemFlatChargeDetails).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) charge_value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p> The custom line item's fixed charge value in USD. </p>
        pub fn charge_value(mut self, input: f64) -> Self {
            self.charge_value = Some(input);
            self
        }
        /// <p> The custom line item's fixed charge value in USD. </p>
        pub fn set_charge_value(mut self, input: std::option::Option<f64>) -> Self {
            self.charge_value = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCustomLineItemFlatChargeDetails`](crate::model::ListCustomLineItemFlatChargeDetails).
        pub fn build(self) -> crate::model::ListCustomLineItemFlatChargeDetails {
            crate::model::ListCustomLineItemFlatChargeDetails {
                charge_value: self.charge_value,
            }
        }
    }
}
impl ListCustomLineItemFlatChargeDetails {
    /// Creates a new builder-style object to manufacture [`ListCustomLineItemFlatChargeDetails`](crate::model::ListCustomLineItemFlatChargeDetails).
    pub fn builder() -> crate::model::list_custom_line_item_flat_charge_details::Builder {
        crate::model::list_custom_line_item_flat_charge_details::Builder::default()
    }
}

/// <p>A filter that specifies the billing period range where the custom line item versions reside.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListCustomLineItemVersionsFilter {
    /// <p>The billing period range in which the custom line item version is applied.</p>
    #[doc(hidden)]
    pub billing_period_range:
        std::option::Option<crate::model::ListCustomLineItemVersionsBillingPeriodRangeFilter>,
}
impl ListCustomLineItemVersionsFilter {
    /// <p>The billing period range in which the custom line item version is applied.</p>
    pub fn billing_period_range(
        &self,
    ) -> std::option::Option<&crate::model::ListCustomLineItemVersionsBillingPeriodRangeFilter>
    {
        self.billing_period_range.as_ref()
    }
}
/// See [`ListCustomLineItemVersionsFilter`](crate::model::ListCustomLineItemVersionsFilter).
pub mod list_custom_line_item_versions_filter {

    /// A builder for [`ListCustomLineItemVersionsFilter`](crate::model::ListCustomLineItemVersionsFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) billing_period_range:
            std::option::Option<crate::model::ListCustomLineItemVersionsBillingPeriodRangeFilter>,
    }
    impl Builder {
        /// <p>The billing period range in which the custom line item version is applied.</p>
        pub fn billing_period_range(
            mut self,
            input: crate::model::ListCustomLineItemVersionsBillingPeriodRangeFilter,
        ) -> Self {
            self.billing_period_range = Some(input);
            self
        }
        /// <p>The billing period range in which the custom line item version is applied.</p>
        pub fn set_billing_period_range(
            mut self,
            input: std::option::Option<
                crate::model::ListCustomLineItemVersionsBillingPeriodRangeFilter,
            >,
        ) -> Self {
            self.billing_period_range = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCustomLineItemVersionsFilter`](crate::model::ListCustomLineItemVersionsFilter).
        pub fn build(self) -> crate::model::ListCustomLineItemVersionsFilter {
            crate::model::ListCustomLineItemVersionsFilter {
                billing_period_range: self.billing_period_range,
            }
        }
    }
}
impl ListCustomLineItemVersionsFilter {
    /// Creates a new builder-style object to manufacture [`ListCustomLineItemVersionsFilter`](crate::model::ListCustomLineItemVersionsFilter).
    pub fn builder() -> crate::model::list_custom_line_item_versions_filter::Builder {
        crate::model::list_custom_line_item_versions_filter::Builder::default()
    }
}

/// <p>A billing period filter that specifies the custom line item versions to retrieve.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListCustomLineItemVersionsBillingPeriodRangeFilter {
    /// <p>The inclusive start billing period that defines a billing period range where a custom line item version is applied.</p>
    #[doc(hidden)]
    pub start_billing_period: std::option::Option<std::string::String>,
    /// <p>The exclusive end billing period that defines a billing period range where a custom line item version is applied.</p>
    #[doc(hidden)]
    pub end_billing_period: std::option::Option<std::string::String>,
}
impl ListCustomLineItemVersionsBillingPeriodRangeFilter {
    /// <p>The inclusive start billing period that defines a billing period range where a custom line item version is applied.</p>
    pub fn start_billing_period(&self) -> std::option::Option<&str> {
        self.start_billing_period.as_deref()
    }
    /// <p>The exclusive end billing period that defines a billing period range where a custom line item version is applied.</p>
    pub fn end_billing_period(&self) -> std::option::Option<&str> {
        self.end_billing_period.as_deref()
    }
}
/// See [`ListCustomLineItemVersionsBillingPeriodRangeFilter`](crate::model::ListCustomLineItemVersionsBillingPeriodRangeFilter).
pub mod list_custom_line_item_versions_billing_period_range_filter {

    /// A builder for [`ListCustomLineItemVersionsBillingPeriodRangeFilter`](crate::model::ListCustomLineItemVersionsBillingPeriodRangeFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_billing_period: std::option::Option<std::string::String>,
        pub(crate) end_billing_period: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The inclusive start billing period that defines a billing period range where a custom line item version is applied.</p>
        pub fn start_billing_period(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_billing_period = Some(input.into());
            self
        }
        /// <p>The inclusive start billing period that defines a billing period range where a custom line item version is applied.</p>
        pub fn set_start_billing_period(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.start_billing_period = input;
            self
        }
        /// <p>The exclusive end billing period that defines a billing period range where a custom line item version is applied.</p>
        pub fn end_billing_period(mut self, input: impl Into<std::string::String>) -> Self {
            self.end_billing_period = Some(input.into());
            self
        }
        /// <p>The exclusive end billing period that defines a billing period range where a custom line item version is applied.</p>
        pub fn set_end_billing_period(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.end_billing_period = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCustomLineItemVersionsBillingPeriodRangeFilter`](crate::model::ListCustomLineItemVersionsBillingPeriodRangeFilter).
        pub fn build(self) -> crate::model::ListCustomLineItemVersionsBillingPeriodRangeFilter {
            crate::model::ListCustomLineItemVersionsBillingPeriodRangeFilter {
                start_billing_period: self.start_billing_period,
                end_billing_period: self.end_billing_period,
            }
        }
    }
}
impl ListCustomLineItemVersionsBillingPeriodRangeFilter {
    /// Creates a new builder-style object to manufacture [`ListCustomLineItemVersionsBillingPeriodRangeFilter`](crate::model::ListCustomLineItemVersionsBillingPeriodRangeFilter).
    pub fn builder(
    ) -> crate::model::list_custom_line_item_versions_billing_period_range_filter::Builder {
        crate::model::list_custom_line_item_versions_billing_period_range_filter::Builder::default()
    }
}

/// <p> A resource disassociation result for a percentage custom line item. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateResourceResponseElement {
    /// <p> The resource ARN that was disassociated from the custom line item. </p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p> An <code>AssociateResourceError</code> that's shown if the resource disassociation fails. </p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::AssociateResourceError>,
}
impl DisassociateResourceResponseElement {
    /// <p> The resource ARN that was disassociated from the custom line item. </p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p> An <code>AssociateResourceError</code> that's shown if the resource disassociation fails. </p>
    pub fn error(&self) -> std::option::Option<&crate::model::AssociateResourceError> {
        self.error.as_ref()
    }
}
/// See [`DisassociateResourceResponseElement`](crate::model::DisassociateResourceResponseElement).
pub mod disassociate_resource_response_element {

    /// A builder for [`DisassociateResourceResponseElement`](crate::model::DisassociateResourceResponseElement).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) error: std::option::Option<crate::model::AssociateResourceError>,
    }
    impl Builder {
        /// <p> The resource ARN that was disassociated from the custom line item. </p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p> The resource ARN that was disassociated from the custom line item. </p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p> An <code>AssociateResourceError</code> that's shown if the resource disassociation fails. </p>
        pub fn error(mut self, input: crate::model::AssociateResourceError) -> Self {
            self.error = Some(input);
            self
        }
        /// <p> An <code>AssociateResourceError</code> that's shown if the resource disassociation fails. </p>
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::AssociateResourceError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateResourceResponseElement`](crate::model::DisassociateResourceResponseElement).
        pub fn build(self) -> crate::model::DisassociateResourceResponseElement {
            crate::model::DisassociateResourceResponseElement {
                arn: self.arn,
                error: self.error,
            }
        }
    }
}
impl DisassociateResourceResponseElement {
    /// Creates a new builder-style object to manufacture [`DisassociateResourceResponseElement`](crate::model::DisassociateResourceResponseElement).
    pub fn builder() -> crate::model::disassociate_resource_response_element::Builder {
        crate::model::disassociate_resource_response_element::Builder::default()
    }
}

/// <p> A representation of a resource association error. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateResourceError {
    /// <p> The reason why the resource association failed. </p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p> A static error code that's used to classify the type of failure. </p>
    #[doc(hidden)]
    pub reason: std::option::Option<crate::model::AssociateResourceErrorReason>,
}
impl AssociateResourceError {
    /// <p> The reason why the resource association failed. </p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p> A static error code that's used to classify the type of failure. </p>
    pub fn reason(&self) -> std::option::Option<&crate::model::AssociateResourceErrorReason> {
        self.reason.as_ref()
    }
}
/// See [`AssociateResourceError`](crate::model::AssociateResourceError).
pub mod associate_resource_error {

    /// A builder for [`AssociateResourceError`](crate::model::AssociateResourceError).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<crate::model::AssociateResourceErrorReason>,
    }
    impl Builder {
        /// <p> The reason why the resource association failed. </p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p> The reason why the resource association failed. </p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p> A static error code that's used to classify the type of failure. </p>
        pub fn reason(mut self, input: crate::model::AssociateResourceErrorReason) -> Self {
            self.reason = Some(input);
            self
        }
        /// <p> A static error code that's used to classify the type of failure. </p>
        pub fn set_reason(
            mut self,
            input: std::option::Option<crate::model::AssociateResourceErrorReason>,
        ) -> Self {
            self.reason = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateResourceError`](crate::model::AssociateResourceError).
        pub fn build(self) -> crate::model::AssociateResourceError {
            crate::model::AssociateResourceError {
                message: self.message,
                reason: self.reason,
            }
        }
    }
}
impl AssociateResourceError {
    /// Creates a new builder-style object to manufacture [`AssociateResourceError`](crate::model::AssociateResourceError).
    pub fn builder() -> crate::model::associate_resource_error::Builder {
        crate::model::associate_resource_error::Builder::default()
    }
}

/// When writing a match expression against `AssociateResourceErrorReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let associateresourceerrorreason = unimplemented!();
/// match associateresourceerrorreason {
///     AssociateResourceErrorReason::IllegalCustomlineitem => { /* ... */ },
///     AssociateResourceErrorReason::InternalServerException => { /* ... */ },
///     AssociateResourceErrorReason::InvalidArn => { /* ... */ },
///     AssociateResourceErrorReason::InvalidBillingPeriodRange => { /* ... */ },
///     AssociateResourceErrorReason::ServiceLimitExceeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `associateresourceerrorreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AssociateResourceErrorReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AssociateResourceErrorReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AssociateResourceErrorReason::NewFeature` is defined.
/// Specifically, when `associateresourceerrorreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AssociateResourceErrorReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssociateResourceErrorReason {
    #[allow(missing_docs)] // documentation missing in model
    IllegalCustomlineitem,
    #[allow(missing_docs)] // documentation missing in model
    InternalServerException,
    #[allow(missing_docs)] // documentation missing in model
    InvalidArn,
    #[allow(missing_docs)] // documentation missing in model
    InvalidBillingPeriodRange,
    #[allow(missing_docs)] // documentation missing in model
    ServiceLimitExceeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AssociateResourceErrorReason {
    fn from(s: &str) -> Self {
        match s {
            "ILLEGAL_CUSTOMLINEITEM" => AssociateResourceErrorReason::IllegalCustomlineitem,
            "INTERNAL_SERVER_EXCEPTION" => AssociateResourceErrorReason::InternalServerException,
            "INVALID_ARN" => AssociateResourceErrorReason::InvalidArn,
            "INVALID_BILLING_PERIOD_RANGE" => {
                AssociateResourceErrorReason::InvalidBillingPeriodRange
            }
            "SERVICE_LIMIT_EXCEEDED" => AssociateResourceErrorReason::ServiceLimitExceeded,
            other => AssociateResourceErrorReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for AssociateResourceErrorReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssociateResourceErrorReason::from(s))
    }
}
impl AssociateResourceErrorReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AssociateResourceErrorReason::IllegalCustomlineitem => "ILLEGAL_CUSTOMLINEITEM",
            AssociateResourceErrorReason::InternalServerException => "INTERNAL_SERVER_EXCEPTION",
            AssociateResourceErrorReason::InvalidArn => "INVALID_ARN",
            AssociateResourceErrorReason::InvalidBillingPeriodRange => {
                "INVALID_BILLING_PERIOD_RANGE"
            }
            AssociateResourceErrorReason::ServiceLimitExceeded => "SERVICE_LIMIT_EXCEEDED",
            AssociateResourceErrorReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ILLEGAL_CUSTOMLINEITEM",
            "INTERNAL_SERVER_EXCEPTION",
            "INVALID_ARN",
            "INVALID_BILLING_PERIOD_RANGE",
            "SERVICE_LIMIT_EXCEEDED",
        ]
    }
}
impl AsRef<str> for AssociateResourceErrorReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> The billing period range in which the custom line item request will be applied. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomLineItemBillingPeriodRange {
    /// <p> The inclusive start billing period that defines a billing period range where a custom line is applied. </p>
    #[doc(hidden)]
    pub inclusive_start_billing_period: std::option::Option<std::string::String>,
    /// <p> The inclusive end billing period that defines a billing period range where a custom line is applied. </p>
    #[doc(hidden)]
    pub exclusive_end_billing_period: std::option::Option<std::string::String>,
}
impl CustomLineItemBillingPeriodRange {
    /// <p> The inclusive start billing period that defines a billing period range where a custom line is applied. </p>
    pub fn inclusive_start_billing_period(&self) -> std::option::Option<&str> {
        self.inclusive_start_billing_period.as_deref()
    }
    /// <p> The inclusive end billing period that defines a billing period range where a custom line is applied. </p>
    pub fn exclusive_end_billing_period(&self) -> std::option::Option<&str> {
        self.exclusive_end_billing_period.as_deref()
    }
}
/// See [`CustomLineItemBillingPeriodRange`](crate::model::CustomLineItemBillingPeriodRange).
pub mod custom_line_item_billing_period_range {

    /// A builder for [`CustomLineItemBillingPeriodRange`](crate::model::CustomLineItemBillingPeriodRange).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) inclusive_start_billing_period: std::option::Option<std::string::String>,
        pub(crate) exclusive_end_billing_period: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The inclusive start billing period that defines a billing period range where a custom line is applied. </p>
        pub fn inclusive_start_billing_period(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inclusive_start_billing_period = Some(input.into());
            self
        }
        /// <p> The inclusive start billing period that defines a billing period range where a custom line is applied. </p>
        pub fn set_inclusive_start_billing_period(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inclusive_start_billing_period = input;
            self
        }
        /// <p> The inclusive end billing period that defines a billing period range where a custom line is applied. </p>
        pub fn exclusive_end_billing_period(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.exclusive_end_billing_period = Some(input.into());
            self
        }
        /// <p> The inclusive end billing period that defines a billing period range where a custom line is applied. </p>
        pub fn set_exclusive_end_billing_period(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.exclusive_end_billing_period = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomLineItemBillingPeriodRange`](crate::model::CustomLineItemBillingPeriodRange).
        pub fn build(self) -> crate::model::CustomLineItemBillingPeriodRange {
            crate::model::CustomLineItemBillingPeriodRange {
                inclusive_start_billing_period: self.inclusive_start_billing_period,
                exclusive_end_billing_period: self.exclusive_end_billing_period,
            }
        }
    }
}
impl CustomLineItemBillingPeriodRange {
    /// Creates a new builder-style object to manufacture [`CustomLineItemBillingPeriodRange`](crate::model::CustomLineItemBillingPeriodRange).
    pub fn builder() -> crate::model::custom_line_item_billing_period_range::Builder {
        crate::model::custom_line_item_billing_period_range::Builder::default()
    }
}

/// <p> A resource association result for a percentage custom line item. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateResourceResponseElement {
    /// <p> The resource ARN that was associated to the custom line item. </p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p> An <code>AssociateResourceError</code> that will populate if the resource association fails. </p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::AssociateResourceError>,
}
impl AssociateResourceResponseElement {
    /// <p> The resource ARN that was associated to the custom line item. </p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p> An <code>AssociateResourceError</code> that will populate if the resource association fails. </p>
    pub fn error(&self) -> std::option::Option<&crate::model::AssociateResourceError> {
        self.error.as_ref()
    }
}
/// See [`AssociateResourceResponseElement`](crate::model::AssociateResourceResponseElement).
pub mod associate_resource_response_element {

    /// A builder for [`AssociateResourceResponseElement`](crate::model::AssociateResourceResponseElement).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) error: std::option::Option<crate::model::AssociateResourceError>,
    }
    impl Builder {
        /// <p> The resource ARN that was associated to the custom line item. </p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p> The resource ARN that was associated to the custom line item. </p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p> An <code>AssociateResourceError</code> that will populate if the resource association fails. </p>
        pub fn error(mut self, input: crate::model::AssociateResourceError) -> Self {
            self.error = Some(input);
            self
        }
        /// <p> An <code>AssociateResourceError</code> that will populate if the resource association fails. </p>
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::AssociateResourceError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateResourceResponseElement`](crate::model::AssociateResourceResponseElement).
        pub fn build(self) -> crate::model::AssociateResourceResponseElement {
            crate::model::AssociateResourceResponseElement {
                arn: self.arn,
                error: self.error,
            }
        }
    }
}
impl AssociateResourceResponseElement {
    /// Creates a new builder-style object to manufacture [`AssociateResourceResponseElement`](crate::model::AssociateResourceResponseElement).
    pub fn builder() -> crate::model::associate_resource_response_element::Builder {
        crate::model::associate_resource_response_element::Builder::default()
    }
}

/// <p> A representation of a custom line item. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomLineItemListElement {
    /// <p> The Amazon Resource Names (ARNs) for custom line items. </p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p> The custom line item's name. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> A <code>ListCustomLineItemChargeDetails</code> that describes the charge details of a custom line item. </p>
    #[doc(hidden)]
    pub charge_details: std::option::Option<crate::model::ListCustomLineItemChargeDetails>,
    /// <p> The custom line item's charge value currency. Only one of the valid values can be used. </p>
    #[doc(hidden)]
    pub currency_code: std::option::Option<crate::model::CurrencyCode>,
    /// <p> The custom line item's description. This is shown on the Bills page in association with the charge value. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> The product code that's associated with the custom line item. </p>
    #[doc(hidden)]
    pub product_code: std::option::Option<std::string::String>,
    /// <p> The Amazon Resource Name (ARN) that references the billing group where the custom line item applies to. </p>
    #[doc(hidden)]
    pub billing_group_arn: std::option::Option<std::string::String>,
    /// <p> The time created. </p>
    #[doc(hidden)]
    pub creation_time: i64,
    /// <p> The most recent time when the custom line item was modified. </p>
    #[doc(hidden)]
    pub last_modified_time: i64,
    /// <p> The number of resources that are associated to the custom line item. </p>
    #[doc(hidden)]
    pub association_size: i64,
}
impl CustomLineItemListElement {
    /// <p> The Amazon Resource Names (ARNs) for custom line items. </p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p> The custom line item's name. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> A <code>ListCustomLineItemChargeDetails</code> that describes the charge details of a custom line item. </p>
    pub fn charge_details(
        &self,
    ) -> std::option::Option<&crate::model::ListCustomLineItemChargeDetails> {
        self.charge_details.as_ref()
    }
    /// <p> The custom line item's charge value currency. Only one of the valid values can be used. </p>
    pub fn currency_code(&self) -> std::option::Option<&crate::model::CurrencyCode> {
        self.currency_code.as_ref()
    }
    /// <p> The custom line item's description. This is shown on the Bills page in association with the charge value. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> The product code that's associated with the custom line item. </p>
    pub fn product_code(&self) -> std::option::Option<&str> {
        self.product_code.as_deref()
    }
    /// <p> The Amazon Resource Name (ARN) that references the billing group where the custom line item applies to. </p>
    pub fn billing_group_arn(&self) -> std::option::Option<&str> {
        self.billing_group_arn.as_deref()
    }
    /// <p> The time created. </p>
    pub fn creation_time(&self) -> i64 {
        self.creation_time
    }
    /// <p> The most recent time when the custom line item was modified. </p>
    pub fn last_modified_time(&self) -> i64 {
        self.last_modified_time
    }
    /// <p> The number of resources that are associated to the custom line item. </p>
    pub fn association_size(&self) -> i64 {
        self.association_size
    }
}
impl std::fmt::Debug for CustomLineItemListElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomLineItemListElement");
        formatter.field("arn", &self.arn);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("charge_details", &self.charge_details);
        formatter.field("currency_code", &self.currency_code);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("product_code", &self.product_code);
        formatter.field("billing_group_arn", &self.billing_group_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("association_size", &self.association_size);
        formatter.finish()
    }
}
/// See [`CustomLineItemListElement`](crate::model::CustomLineItemListElement).
pub mod custom_line_item_list_element {

    /// A builder for [`CustomLineItemListElement`](crate::model::CustomLineItemListElement).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) charge_details:
            std::option::Option<crate::model::ListCustomLineItemChargeDetails>,
        pub(crate) currency_code: std::option::Option<crate::model::CurrencyCode>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) product_code: std::option::Option<std::string::String>,
        pub(crate) billing_group_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<i64>,
        pub(crate) last_modified_time: std::option::Option<i64>,
        pub(crate) association_size: std::option::Option<i64>,
    }
    impl Builder {
        /// <p> The Amazon Resource Names (ARNs) for custom line items. </p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Names (ARNs) for custom line items. </p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p> The custom line item's name. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The custom line item's name. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> A <code>ListCustomLineItemChargeDetails</code> that describes the charge details of a custom line item. </p>
        pub fn charge_details(
            mut self,
            input: crate::model::ListCustomLineItemChargeDetails,
        ) -> Self {
            self.charge_details = Some(input);
            self
        }
        /// <p> A <code>ListCustomLineItemChargeDetails</code> that describes the charge details of a custom line item. </p>
        pub fn set_charge_details(
            mut self,
            input: std::option::Option<crate::model::ListCustomLineItemChargeDetails>,
        ) -> Self {
            self.charge_details = input;
            self
        }
        /// <p> The custom line item's charge value currency. Only one of the valid values can be used. </p>
        pub fn currency_code(mut self, input: crate::model::CurrencyCode) -> Self {
            self.currency_code = Some(input);
            self
        }
        /// <p> The custom line item's charge value currency. Only one of the valid values can be used. </p>
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<crate::model::CurrencyCode>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// <p> The custom line item's description. This is shown on the Bills page in association with the charge value. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> The custom line item's description. This is shown on the Bills page in association with the charge value. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p> The product code that's associated with the custom line item. </p>
        pub fn product_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_code = Some(input.into());
            self
        }
        /// <p> The product code that's associated with the custom line item. </p>
        pub fn set_product_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_code = input;
            self
        }
        /// <p> The Amazon Resource Name (ARN) that references the billing group where the custom line item applies to. </p>
        pub fn billing_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.billing_group_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) that references the billing group where the custom line item applies to. </p>
        pub fn set_billing_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.billing_group_arn = input;
            self
        }
        /// <p> The time created. </p>
        pub fn creation_time(mut self, input: i64) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p> The time created. </p>
        pub fn set_creation_time(mut self, input: std::option::Option<i64>) -> Self {
            self.creation_time = input;
            self
        }
        /// <p> The most recent time when the custom line item was modified. </p>
        pub fn last_modified_time(mut self, input: i64) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p> The most recent time when the custom line item was modified. </p>
        pub fn set_last_modified_time(mut self, input: std::option::Option<i64>) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p> The number of resources that are associated to the custom line item. </p>
        pub fn association_size(mut self, input: i64) -> Self {
            self.association_size = Some(input);
            self
        }
        /// <p> The number of resources that are associated to the custom line item. </p>
        pub fn set_association_size(mut self, input: std::option::Option<i64>) -> Self {
            self.association_size = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomLineItemListElement`](crate::model::CustomLineItemListElement).
        pub fn build(self) -> crate::model::CustomLineItemListElement {
            crate::model::CustomLineItemListElement {
                arn: self.arn,
                name: self.name,
                charge_details: self.charge_details,
                currency_code: self.currency_code,
                description: self.description,
                product_code: self.product_code,
                billing_group_arn: self.billing_group_arn,
                creation_time: self.creation_time.unwrap_or_default(),
                last_modified_time: self.last_modified_time.unwrap_or_default(),
                association_size: self.association_size.unwrap_or_default(),
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("arn", &self.arn);
            formatter.field("name", &"*** Sensitive Data Redacted ***");
            formatter.field("charge_details", &self.charge_details);
            formatter.field("currency_code", &self.currency_code);
            formatter.field("description", &"*** Sensitive Data Redacted ***");
            formatter.field("product_code", &self.product_code);
            formatter.field("billing_group_arn", &self.billing_group_arn);
            formatter.field("creation_time", &self.creation_time);
            formatter.field("last_modified_time", &self.last_modified_time);
            formatter.field("association_size", &self.association_size);
            formatter.finish()
        }
    }
}
impl CustomLineItemListElement {
    /// Creates a new builder-style object to manufacture [`CustomLineItemListElement`](crate::model::CustomLineItemListElement).
    pub fn builder() -> crate::model::custom_line_item_list_element::Builder {
        crate::model::custom_line_item_list_element::Builder::default()
    }
}

/// <p> A filter that specifies the custom line items and billing groups to retrieve FFLI information. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListCustomLineItemsFilter {
    /// <p> A list of custom line items to retrieve information. </p>
    #[doc(hidden)]
    pub names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> The billing group Amazon Resource Names (ARNs) to retrieve information. </p>
    #[doc(hidden)]
    pub billing_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> A list of custom line item ARNs to retrieve information. </p>
    #[doc(hidden)]
    pub arns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ListCustomLineItemsFilter {
    /// <p> A list of custom line items to retrieve information. </p>
    pub fn names(&self) -> std::option::Option<&[std::string::String]> {
        self.names.as_deref()
    }
    /// <p> The billing group Amazon Resource Names (ARNs) to retrieve information. </p>
    pub fn billing_groups(&self) -> std::option::Option<&[std::string::String]> {
        self.billing_groups.as_deref()
    }
    /// <p> A list of custom line item ARNs to retrieve information. </p>
    pub fn arns(&self) -> std::option::Option<&[std::string::String]> {
        self.arns.as_deref()
    }
}
/// See [`ListCustomLineItemsFilter`](crate::model::ListCustomLineItemsFilter).
pub mod list_custom_line_items_filter {

    /// A builder for [`ListCustomLineItemsFilter`](crate::model::ListCustomLineItemsFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) billing_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) arns: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `names`.
        ///
        /// To override the contents of this collection use [`set_names`](Self::set_names).
        ///
        /// <p> A list of custom line items to retrieve information. </p>
        pub fn names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.names.unwrap_or_default();
            v.push(input.into());
            self.names = Some(v);
            self
        }
        /// <p> A list of custom line items to retrieve information. </p>
        pub fn set_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.names = input;
            self
        }
        /// Appends an item to `billing_groups`.
        ///
        /// To override the contents of this collection use [`set_billing_groups`](Self::set_billing_groups).
        ///
        /// <p> The billing group Amazon Resource Names (ARNs) to retrieve information. </p>
        pub fn billing_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.billing_groups.unwrap_or_default();
            v.push(input.into());
            self.billing_groups = Some(v);
            self
        }
        /// <p> The billing group Amazon Resource Names (ARNs) to retrieve information. </p>
        pub fn set_billing_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.billing_groups = input;
            self
        }
        /// Appends an item to `arns`.
        ///
        /// To override the contents of this collection use [`set_arns`](Self::set_arns).
        ///
        /// <p> A list of custom line item ARNs to retrieve information. </p>
        pub fn arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.arns.unwrap_or_default();
            v.push(input.into());
            self.arns = Some(v);
            self
        }
        /// <p> A list of custom line item ARNs to retrieve information. </p>
        pub fn set_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.arns = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCustomLineItemsFilter`](crate::model::ListCustomLineItemsFilter).
        pub fn build(self) -> crate::model::ListCustomLineItemsFilter {
            crate::model::ListCustomLineItemsFilter {
                names: self.names,
                billing_groups: self.billing_groups,
                arns: self.arns,
            }
        }
    }
}
impl ListCustomLineItemsFilter {
    /// Creates a new builder-style object to manufacture [`ListCustomLineItemsFilter`](crate::model::ListCustomLineItemsFilter).
    pub fn builder() -> crate::model::list_custom_line_items_filter::Builder {
        crate::model::list_custom_line_items_filter::Builder::default()
    }
}

/// <p> The charge details of a custom line item. It should contain only one of <code>Flat</code> or <code>Percentage</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomLineItemChargeDetails {
    /// <p> A <code>CustomLineItemFlatChargeDetails</code> that describes the charge details of a flat custom line item. </p>
    #[doc(hidden)]
    pub flat: std::option::Option<crate::model::CustomLineItemFlatChargeDetails>,
    /// <p> A <code>CustomLineItemPercentageChargeDetails</code> that describes the charge details of a percentage custom line item. </p>
    #[doc(hidden)]
    pub percentage: std::option::Option<crate::model::CustomLineItemPercentageChargeDetails>,
    /// <p> The type of the custom line item that indicates whether the charge is a fee or credit. </p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::CustomLineItemType>,
}
impl CustomLineItemChargeDetails {
    /// <p> A <code>CustomLineItemFlatChargeDetails</code> that describes the charge details of a flat custom line item. </p>
    pub fn flat(&self) -> std::option::Option<&crate::model::CustomLineItemFlatChargeDetails> {
        self.flat.as_ref()
    }
    /// <p> A <code>CustomLineItemPercentageChargeDetails</code> that describes the charge details of a percentage custom line item. </p>
    pub fn percentage(
        &self,
    ) -> std::option::Option<&crate::model::CustomLineItemPercentageChargeDetails> {
        self.percentage.as_ref()
    }
    /// <p> The type of the custom line item that indicates whether the charge is a fee or credit. </p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::CustomLineItemType> {
        self.r#type.as_ref()
    }
}
/// See [`CustomLineItemChargeDetails`](crate::model::CustomLineItemChargeDetails).
pub mod custom_line_item_charge_details {

    /// A builder for [`CustomLineItemChargeDetails`](crate::model::CustomLineItemChargeDetails).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) flat: std::option::Option<crate::model::CustomLineItemFlatChargeDetails>,
        pub(crate) percentage:
            std::option::Option<crate::model::CustomLineItemPercentageChargeDetails>,
        pub(crate) r#type: std::option::Option<crate::model::CustomLineItemType>,
    }
    impl Builder {
        /// <p> A <code>CustomLineItemFlatChargeDetails</code> that describes the charge details of a flat custom line item. </p>
        pub fn flat(mut self, input: crate::model::CustomLineItemFlatChargeDetails) -> Self {
            self.flat = Some(input);
            self
        }
        /// <p> A <code>CustomLineItemFlatChargeDetails</code> that describes the charge details of a flat custom line item. </p>
        pub fn set_flat(
            mut self,
            input: std::option::Option<crate::model::CustomLineItemFlatChargeDetails>,
        ) -> Self {
            self.flat = input;
            self
        }
        /// <p> A <code>CustomLineItemPercentageChargeDetails</code> that describes the charge details of a percentage custom line item. </p>
        pub fn percentage(
            mut self,
            input: crate::model::CustomLineItemPercentageChargeDetails,
        ) -> Self {
            self.percentage = Some(input);
            self
        }
        /// <p> A <code>CustomLineItemPercentageChargeDetails</code> that describes the charge details of a percentage custom line item. </p>
        pub fn set_percentage(
            mut self,
            input: std::option::Option<crate::model::CustomLineItemPercentageChargeDetails>,
        ) -> Self {
            self.percentage = input;
            self
        }
        /// <p> The type of the custom line item that indicates whether the charge is a fee or credit. </p>
        pub fn r#type(mut self, input: crate::model::CustomLineItemType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p> The type of the custom line item that indicates whether the charge is a fee or credit. </p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::CustomLineItemType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomLineItemChargeDetails`](crate::model::CustomLineItemChargeDetails).
        pub fn build(self) -> crate::model::CustomLineItemChargeDetails {
            crate::model::CustomLineItemChargeDetails {
                flat: self.flat,
                percentage: self.percentage,
                r#type: self.r#type,
            }
        }
    }
}
impl CustomLineItemChargeDetails {
    /// Creates a new builder-style object to manufacture [`CustomLineItemChargeDetails`](crate::model::CustomLineItemChargeDetails).
    pub fn builder() -> crate::model::custom_line_item_charge_details::Builder {
        crate::model::custom_line_item_charge_details::Builder::default()
    }
}

/// <p> A representation of the charge details that are associated with a percentage custom line item. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomLineItemPercentageChargeDetails {
    /// <p> The custom line item's percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value. </p>
    #[doc(hidden)]
    pub percentage_value: std::option::Option<f64>,
    /// <p> A list of resource ARNs to associate to the percentage custom line item. </p>
    #[doc(hidden)]
    pub associated_values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CustomLineItemPercentageChargeDetails {
    /// <p> The custom line item's percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value. </p>
    pub fn percentage_value(&self) -> std::option::Option<f64> {
        self.percentage_value
    }
    /// <p> A list of resource ARNs to associate to the percentage custom line item. </p>
    pub fn associated_values(&self) -> std::option::Option<&[std::string::String]> {
        self.associated_values.as_deref()
    }
}
/// See [`CustomLineItemPercentageChargeDetails`](crate::model::CustomLineItemPercentageChargeDetails).
pub mod custom_line_item_percentage_charge_details {

    /// A builder for [`CustomLineItemPercentageChargeDetails`](crate::model::CustomLineItemPercentageChargeDetails).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) percentage_value: std::option::Option<f64>,
        pub(crate) associated_values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p> The custom line item's percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value. </p>
        pub fn percentage_value(mut self, input: f64) -> Self {
            self.percentage_value = Some(input);
            self
        }
        /// <p> The custom line item's percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value. </p>
        pub fn set_percentage_value(mut self, input: std::option::Option<f64>) -> Self {
            self.percentage_value = input;
            self
        }
        /// Appends an item to `associated_values`.
        ///
        /// To override the contents of this collection use [`set_associated_values`](Self::set_associated_values).
        ///
        /// <p> A list of resource ARNs to associate to the percentage custom line item. </p>
        pub fn associated_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.associated_values.unwrap_or_default();
            v.push(input.into());
            self.associated_values = Some(v);
            self
        }
        /// <p> A list of resource ARNs to associate to the percentage custom line item. </p>
        pub fn set_associated_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.associated_values = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomLineItemPercentageChargeDetails`](crate::model::CustomLineItemPercentageChargeDetails).
        pub fn build(self) -> crate::model::CustomLineItemPercentageChargeDetails {
            crate::model::CustomLineItemPercentageChargeDetails {
                percentage_value: self.percentage_value,
                associated_values: self.associated_values,
            }
        }
    }
}
impl CustomLineItemPercentageChargeDetails {
    /// Creates a new builder-style object to manufacture [`CustomLineItemPercentageChargeDetails`](crate::model::CustomLineItemPercentageChargeDetails).
    pub fn builder() -> crate::model::custom_line_item_percentage_charge_details::Builder {
        crate::model::custom_line_item_percentage_charge_details::Builder::default()
    }
}

/// <p> A representation of the charge details that are associated with a flat custom line item. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomLineItemFlatChargeDetails {
    /// <p> The custom line item's fixed charge value in USD. </p>
    #[doc(hidden)]
    pub charge_value: std::option::Option<f64>,
}
impl CustomLineItemFlatChargeDetails {
    /// <p> The custom line item's fixed charge value in USD. </p>
    pub fn charge_value(&self) -> std::option::Option<f64> {
        self.charge_value
    }
}
/// See [`CustomLineItemFlatChargeDetails`](crate::model::CustomLineItemFlatChargeDetails).
pub mod custom_line_item_flat_charge_details {

    /// A builder for [`CustomLineItemFlatChargeDetails`](crate::model::CustomLineItemFlatChargeDetails).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) charge_value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p> The custom line item's fixed charge value in USD. </p>
        pub fn charge_value(mut self, input: f64) -> Self {
            self.charge_value = Some(input);
            self
        }
        /// <p> The custom line item's fixed charge value in USD. </p>
        pub fn set_charge_value(mut self, input: std::option::Option<f64>) -> Self {
            self.charge_value = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomLineItemFlatChargeDetails`](crate::model::CustomLineItemFlatChargeDetails).
        pub fn build(self) -> crate::model::CustomLineItemFlatChargeDetails {
            crate::model::CustomLineItemFlatChargeDetails {
                charge_value: self.charge_value,
            }
        }
    }
}
impl CustomLineItemFlatChargeDetails {
    /// Creates a new builder-style object to manufacture [`CustomLineItemFlatChargeDetails`](crate::model::CustomLineItemFlatChargeDetails).
    pub fn builder() -> crate::model::custom_line_item_flat_charge_details::Builder {
        crate::model::custom_line_item_flat_charge_details::Builder::default()
    }
}

/// <p> A representation of the new charge details of a custom line item. This should contain only one of <code>Flat</code> or <code>Percentage</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateCustomLineItemChargeDetails {
    /// <p> An <code>UpdateCustomLineItemFlatChargeDetails</code> that describes the new charge details of a flat custom line item. </p>
    #[doc(hidden)]
    pub flat: std::option::Option<crate::model::UpdateCustomLineItemFlatChargeDetails>,
    /// <p> An <code>UpdateCustomLineItemPercentageChargeDetails</code> that describes the new charge details of a percentage custom line item. </p>
    #[doc(hidden)]
    pub percentage: std::option::Option<crate::model::UpdateCustomLineItemPercentageChargeDetails>,
}
impl UpdateCustomLineItemChargeDetails {
    /// <p> An <code>UpdateCustomLineItemFlatChargeDetails</code> that describes the new charge details of a flat custom line item. </p>
    pub fn flat(
        &self,
    ) -> std::option::Option<&crate::model::UpdateCustomLineItemFlatChargeDetails> {
        self.flat.as_ref()
    }
    /// <p> An <code>UpdateCustomLineItemPercentageChargeDetails</code> that describes the new charge details of a percentage custom line item. </p>
    pub fn percentage(
        &self,
    ) -> std::option::Option<&crate::model::UpdateCustomLineItemPercentageChargeDetails> {
        self.percentage.as_ref()
    }
}
/// See [`UpdateCustomLineItemChargeDetails`](crate::model::UpdateCustomLineItemChargeDetails).
pub mod update_custom_line_item_charge_details {

    /// A builder for [`UpdateCustomLineItemChargeDetails`](crate::model::UpdateCustomLineItemChargeDetails).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) flat: std::option::Option<crate::model::UpdateCustomLineItemFlatChargeDetails>,
        pub(crate) percentage:
            std::option::Option<crate::model::UpdateCustomLineItemPercentageChargeDetails>,
    }
    impl Builder {
        /// <p> An <code>UpdateCustomLineItemFlatChargeDetails</code> that describes the new charge details of a flat custom line item. </p>
        pub fn flat(mut self, input: crate::model::UpdateCustomLineItemFlatChargeDetails) -> Self {
            self.flat = Some(input);
            self
        }
        /// <p> An <code>UpdateCustomLineItemFlatChargeDetails</code> that describes the new charge details of a flat custom line item. </p>
        pub fn set_flat(
            mut self,
            input: std::option::Option<crate::model::UpdateCustomLineItemFlatChargeDetails>,
        ) -> Self {
            self.flat = input;
            self
        }
        /// <p> An <code>UpdateCustomLineItemPercentageChargeDetails</code> that describes the new charge details of a percentage custom line item. </p>
        pub fn percentage(
            mut self,
            input: crate::model::UpdateCustomLineItemPercentageChargeDetails,
        ) -> Self {
            self.percentage = Some(input);
            self
        }
        /// <p> An <code>UpdateCustomLineItemPercentageChargeDetails</code> that describes the new charge details of a percentage custom line item. </p>
        pub fn set_percentage(
            mut self,
            input: std::option::Option<crate::model::UpdateCustomLineItemPercentageChargeDetails>,
        ) -> Self {
            self.percentage = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateCustomLineItemChargeDetails`](crate::model::UpdateCustomLineItemChargeDetails).
        pub fn build(self) -> crate::model::UpdateCustomLineItemChargeDetails {
            crate::model::UpdateCustomLineItemChargeDetails {
                flat: self.flat,
                percentage: self.percentage,
            }
        }
    }
}
impl UpdateCustomLineItemChargeDetails {
    /// Creates a new builder-style object to manufacture [`UpdateCustomLineItemChargeDetails`](crate::model::UpdateCustomLineItemChargeDetails).
    pub fn builder() -> crate::model::update_custom_line_item_charge_details::Builder {
        crate::model::update_custom_line_item_charge_details::Builder::default()
    }
}

/// <p> A representation of the new charge details that are associated with a percentage custom line item. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateCustomLineItemPercentageChargeDetails {
    /// <p> The custom line item's new percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value. </p>
    #[doc(hidden)]
    pub percentage_value: std::option::Option<f64>,
}
impl UpdateCustomLineItemPercentageChargeDetails {
    /// <p> The custom line item's new percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value. </p>
    pub fn percentage_value(&self) -> std::option::Option<f64> {
        self.percentage_value
    }
}
/// See [`UpdateCustomLineItemPercentageChargeDetails`](crate::model::UpdateCustomLineItemPercentageChargeDetails).
pub mod update_custom_line_item_percentage_charge_details {

    /// A builder for [`UpdateCustomLineItemPercentageChargeDetails`](crate::model::UpdateCustomLineItemPercentageChargeDetails).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) percentage_value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p> The custom line item's new percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value. </p>
        pub fn percentage_value(mut self, input: f64) -> Self {
            self.percentage_value = Some(input);
            self
        }
        /// <p> The custom line item's new percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value. </p>
        pub fn set_percentage_value(mut self, input: std::option::Option<f64>) -> Self {
            self.percentage_value = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateCustomLineItemPercentageChargeDetails`](crate::model::UpdateCustomLineItemPercentageChargeDetails).
        pub fn build(self) -> crate::model::UpdateCustomLineItemPercentageChargeDetails {
            crate::model::UpdateCustomLineItemPercentageChargeDetails {
                percentage_value: self.percentage_value,
            }
        }
    }
}
impl UpdateCustomLineItemPercentageChargeDetails {
    /// Creates a new builder-style object to manufacture [`UpdateCustomLineItemPercentageChargeDetails`](crate::model::UpdateCustomLineItemPercentageChargeDetails).
    pub fn builder() -> crate::model::update_custom_line_item_percentage_charge_details::Builder {
        crate::model::update_custom_line_item_percentage_charge_details::Builder::default()
    }
}

/// <p> A representation of the new charge details that are associated with a flat custom line item. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateCustomLineItemFlatChargeDetails {
    /// <p> The custom line item's new fixed charge value in USD. </p>
    #[doc(hidden)]
    pub charge_value: std::option::Option<f64>,
}
impl UpdateCustomLineItemFlatChargeDetails {
    /// <p> The custom line item's new fixed charge value in USD. </p>
    pub fn charge_value(&self) -> std::option::Option<f64> {
        self.charge_value
    }
}
/// See [`UpdateCustomLineItemFlatChargeDetails`](crate::model::UpdateCustomLineItemFlatChargeDetails).
pub mod update_custom_line_item_flat_charge_details {

    /// A builder for [`UpdateCustomLineItemFlatChargeDetails`](crate::model::UpdateCustomLineItemFlatChargeDetails).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) charge_value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p> The custom line item's new fixed charge value in USD. </p>
        pub fn charge_value(mut self, input: f64) -> Self {
            self.charge_value = Some(input);
            self
        }
        /// <p> The custom line item's new fixed charge value in USD. </p>
        pub fn set_charge_value(mut self, input: std::option::Option<f64>) -> Self {
            self.charge_value = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateCustomLineItemFlatChargeDetails`](crate::model::UpdateCustomLineItemFlatChargeDetails).
        pub fn build(self) -> crate::model::UpdateCustomLineItemFlatChargeDetails {
            crate::model::UpdateCustomLineItemFlatChargeDetails {
                charge_value: self.charge_value,
            }
        }
    }
}
impl UpdateCustomLineItemFlatChargeDetails {
    /// Creates a new builder-style object to manufacture [`UpdateCustomLineItemFlatChargeDetails`](crate::model::UpdateCustomLineItemFlatChargeDetails).
    pub fn builder() -> crate::model::update_custom_line_item_flat_charge_details::Builder {
        crate::model::update_custom_line_item_flat_charge_details::Builder::default()
    }
}

/// <p>A representation of a billing group. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BillingGroupListElement {
    /// <p>The name of the billing group. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Number (ARN) that can be used to uniquely identify the billing group. </p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The description of the billing group. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The account ID that serves as the main account in a billing group. </p>
    #[doc(hidden)]
    pub primary_account_id: std::option::Option<std::string::String>,
    /// <p> The preferences and settings that will be used to compute the Amazon Web Services charges for a billing group. </p>
    #[doc(hidden)]
    pub computation_preference: std::option::Option<crate::model::ComputationPreference>,
    /// <p>The number of accounts in the particular billing group. </p>
    #[doc(hidden)]
    pub size: i64,
    /// <p> The time when the billing group was created. </p>
    #[doc(hidden)]
    pub creation_time: i64,
    /// <p> The most recent time when the billing group was modified. </p>
    #[doc(hidden)]
    pub last_modified_time: i64,
    /// <p>The billing group status. Only one of the valid values can be used. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::BillingGroupStatus>,
    /// <p>The reason why the billing group is in its current status. </p>
    #[doc(hidden)]
    pub status_reason: std::option::Option<std::string::String>,
}
impl BillingGroupListElement {
    /// <p>The name of the billing group. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Number (ARN) that can be used to uniquely identify the billing group. </p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The description of the billing group. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The account ID that serves as the main account in a billing group. </p>
    pub fn primary_account_id(&self) -> std::option::Option<&str> {
        self.primary_account_id.as_deref()
    }
    /// <p> The preferences and settings that will be used to compute the Amazon Web Services charges for a billing group. </p>
    pub fn computation_preference(
        &self,
    ) -> std::option::Option<&crate::model::ComputationPreference> {
        self.computation_preference.as_ref()
    }
    /// <p>The number of accounts in the particular billing group. </p>
    pub fn size(&self) -> i64 {
        self.size
    }
    /// <p> The time when the billing group was created. </p>
    pub fn creation_time(&self) -> i64 {
        self.creation_time
    }
    /// <p> The most recent time when the billing group was modified. </p>
    pub fn last_modified_time(&self) -> i64 {
        self.last_modified_time
    }
    /// <p>The billing group status. Only one of the valid values can be used. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::BillingGroupStatus> {
        self.status.as_ref()
    }
    /// <p>The reason why the billing group is in its current status. </p>
    pub fn status_reason(&self) -> std::option::Option<&str> {
        self.status_reason.as_deref()
    }
}
impl std::fmt::Debug for BillingGroupListElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BillingGroupListElement");
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("arn", &self.arn);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("primary_account_id", &self.primary_account_id);
        formatter.field("computation_preference", &self.computation_preference);
        formatter.field("size", &self.size);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("status", &self.status);
        formatter.field("status_reason", &self.status_reason);
        formatter.finish()
    }
}
/// See [`BillingGroupListElement`](crate::model::BillingGroupListElement).
pub mod billing_group_list_element {

    /// A builder for [`BillingGroupListElement`](crate::model::BillingGroupListElement).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) primary_account_id: std::option::Option<std::string::String>,
        pub(crate) computation_preference: std::option::Option<crate::model::ComputationPreference>,
        pub(crate) size: std::option::Option<i64>,
        pub(crate) creation_time: std::option::Option<i64>,
        pub(crate) last_modified_time: std::option::Option<i64>,
        pub(crate) status: std::option::Option<crate::model::BillingGroupStatus>,
        pub(crate) status_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the billing group. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the billing group. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Number (ARN) that can be used to uniquely identify the billing group. </p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Number (ARN) that can be used to uniquely identify the billing group. </p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The description of the billing group. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the billing group. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The account ID that serves as the main account in a billing group. </p>
        pub fn primary_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.primary_account_id = Some(input.into());
            self
        }
        /// <p>The account ID that serves as the main account in a billing group. </p>
        pub fn set_primary_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.primary_account_id = input;
            self
        }
        /// <p> The preferences and settings that will be used to compute the Amazon Web Services charges for a billing group. </p>
        pub fn computation_preference(
            mut self,
            input: crate::model::ComputationPreference,
        ) -> Self {
            self.computation_preference = Some(input);
            self
        }
        /// <p> The preferences and settings that will be used to compute the Amazon Web Services charges for a billing group. </p>
        pub fn set_computation_preference(
            mut self,
            input: std::option::Option<crate::model::ComputationPreference>,
        ) -> Self {
            self.computation_preference = input;
            self
        }
        /// <p>The number of accounts in the particular billing group. </p>
        pub fn size(mut self, input: i64) -> Self {
            self.size = Some(input);
            self
        }
        /// <p>The number of accounts in the particular billing group. </p>
        pub fn set_size(mut self, input: std::option::Option<i64>) -> Self {
            self.size = input;
            self
        }
        /// <p> The time when the billing group was created. </p>
        pub fn creation_time(mut self, input: i64) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p> The time when the billing group was created. </p>
        pub fn set_creation_time(mut self, input: std::option::Option<i64>) -> Self {
            self.creation_time = input;
            self
        }
        /// <p> The most recent time when the billing group was modified. </p>
        pub fn last_modified_time(mut self, input: i64) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p> The most recent time when the billing group was modified. </p>
        pub fn set_last_modified_time(mut self, input: std::option::Option<i64>) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The billing group status. Only one of the valid values can be used. </p>
        pub fn status(mut self, input: crate::model::BillingGroupStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The billing group status. Only one of the valid values can be used. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::BillingGroupStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The reason why the billing group is in its current status. </p>
        pub fn status_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_reason = Some(input.into());
            self
        }
        /// <p>The reason why the billing group is in its current status. </p>
        pub fn set_status_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`BillingGroupListElement`](crate::model::BillingGroupListElement).
        pub fn build(self) -> crate::model::BillingGroupListElement {
            crate::model::BillingGroupListElement {
                name: self.name,
                arn: self.arn,
                description: self.description,
                primary_account_id: self.primary_account_id,
                computation_preference: self.computation_preference,
                size: self.size.unwrap_or_default(),
                creation_time: self.creation_time.unwrap_or_default(),
                last_modified_time: self.last_modified_time.unwrap_or_default(),
                status: self.status,
                status_reason: self.status_reason,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("name", &"*** Sensitive Data Redacted ***");
            formatter.field("arn", &self.arn);
            formatter.field("description", &"*** Sensitive Data Redacted ***");
            formatter.field("primary_account_id", &self.primary_account_id);
            formatter.field("computation_preference", &self.computation_preference);
            formatter.field("size", &self.size);
            formatter.field("creation_time", &self.creation_time);
            formatter.field("last_modified_time", &self.last_modified_time);
            formatter.field("status", &self.status);
            formatter.field("status_reason", &self.status_reason);
            formatter.finish()
        }
    }
}
impl BillingGroupListElement {
    /// Creates a new builder-style object to manufacture [`BillingGroupListElement`](crate::model::BillingGroupListElement).
    pub fn builder() -> crate::model::billing_group_list_element::Builder {
        crate::model::billing_group_list_element::Builder::default()
    }
}

/// When writing a match expression against `BillingGroupStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let billinggroupstatus = unimplemented!();
/// match billinggroupstatus {
///     BillingGroupStatus::Active => { /* ... */ },
///     BillingGroupStatus::PrimaryAccountMissing => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `billinggroupstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BillingGroupStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BillingGroupStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BillingGroupStatus::NewFeature` is defined.
/// Specifically, when `billinggroupstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BillingGroupStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BillingGroupStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    PrimaryAccountMissing,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BillingGroupStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => BillingGroupStatus::Active,
            "PRIMARY_ACCOUNT_MISSING" => BillingGroupStatus::PrimaryAccountMissing,
            other => {
                BillingGroupStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for BillingGroupStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BillingGroupStatus::from(s))
    }
}
impl BillingGroupStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BillingGroupStatus::Active => "ACTIVE",
            BillingGroupStatus::PrimaryAccountMissing => "PRIMARY_ACCOUNT_MISSING",
            BillingGroupStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "PRIMARY_ACCOUNT_MISSING"]
    }
}
impl AsRef<str> for BillingGroupStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> The preferences and settings that will be used to compute the Amazon Web Services charges for a billing group. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComputationPreference {
    /// <p> The Amazon Resource Name (ARN) of the pricing plan that's used to compute the Amazon Web Services charges for a billing group. </p>
    #[doc(hidden)]
    pub pricing_plan_arn: std::option::Option<std::string::String>,
}
impl ComputationPreference {
    /// <p> The Amazon Resource Name (ARN) of the pricing plan that's used to compute the Amazon Web Services charges for a billing group. </p>
    pub fn pricing_plan_arn(&self) -> std::option::Option<&str> {
        self.pricing_plan_arn.as_deref()
    }
}
/// See [`ComputationPreference`](crate::model::ComputationPreference).
pub mod computation_preference {

    /// A builder for [`ComputationPreference`](crate::model::ComputationPreference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pricing_plan_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The Amazon Resource Name (ARN) of the pricing plan that's used to compute the Amazon Web Services charges for a billing group. </p>
        pub fn pricing_plan_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.pricing_plan_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the pricing plan that's used to compute the Amazon Web Services charges for a billing group. </p>
        pub fn set_pricing_plan_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pricing_plan_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ComputationPreference`](crate::model::ComputationPreference).
        pub fn build(self) -> crate::model::ComputationPreference {
            crate::model::ComputationPreference {
                pricing_plan_arn: self.pricing_plan_arn,
            }
        }
    }
}
impl ComputationPreference {
    /// Creates a new builder-style object to manufacture [`ComputationPreference`](crate::model::ComputationPreference).
    pub fn builder() -> crate::model::computation_preference::Builder {
        crate::model::computation_preference::Builder::default()
    }
}

/// <p>The filter that specifies the billing groups and pricing plans to retrieve billing group information. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListBillingGroupsFilter {
    /// <p>The list of billing group Amazon Resource Names (ARNs) to retrieve information. </p>
    #[doc(hidden)]
    pub arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The pricing plan Amazon Resource Names (ARNs) to retrieve information. </p>
    #[doc(hidden)]
    pub pricing_plan: std::option::Option<std::string::String>,
}
impl ListBillingGroupsFilter {
    /// <p>The list of billing group Amazon Resource Names (ARNs) to retrieve information. </p>
    pub fn arns(&self) -> std::option::Option<&[std::string::String]> {
        self.arns.as_deref()
    }
    /// <p>The pricing plan Amazon Resource Names (ARNs) to retrieve information. </p>
    pub fn pricing_plan(&self) -> std::option::Option<&str> {
        self.pricing_plan.as_deref()
    }
}
/// See [`ListBillingGroupsFilter`](crate::model::ListBillingGroupsFilter).
pub mod list_billing_groups_filter {

    /// A builder for [`ListBillingGroupsFilter`](crate::model::ListBillingGroupsFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) pricing_plan: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `arns`.
        ///
        /// To override the contents of this collection use [`set_arns`](Self::set_arns).
        ///
        /// <p>The list of billing group Amazon Resource Names (ARNs) to retrieve information. </p>
        pub fn arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.arns.unwrap_or_default();
            v.push(input.into());
            self.arns = Some(v);
            self
        }
        /// <p>The list of billing group Amazon Resource Names (ARNs) to retrieve information. </p>
        pub fn set_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.arns = input;
            self
        }
        /// <p>The pricing plan Amazon Resource Names (ARNs) to retrieve information. </p>
        pub fn pricing_plan(mut self, input: impl Into<std::string::String>) -> Self {
            self.pricing_plan = Some(input.into());
            self
        }
        /// <p>The pricing plan Amazon Resource Names (ARNs) to retrieve information. </p>
        pub fn set_pricing_plan(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pricing_plan = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBillingGroupsFilter`](crate::model::ListBillingGroupsFilter).
        pub fn build(self) -> crate::model::ListBillingGroupsFilter {
            crate::model::ListBillingGroupsFilter {
                arns: self.arns,
                pricing_plan: self.pricing_plan,
            }
        }
    }
}
impl ListBillingGroupsFilter {
    /// Creates a new builder-style object to manufacture [`ListBillingGroupsFilter`](crate::model::ListBillingGroupsFilter).
    pub fn builder() -> crate::model::list_billing_groups_filter::Builder {
        crate::model::list_billing_groups_filter::Builder::default()
    }
}

/// <p> The set of accounts that will be under the billing group. The set of accounts resemble the linked accounts in a consolidated family. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccountGrouping {
    /// <p> The account IDs that make up the billing group. Account IDs must be a part of the consolidated billing family, and not associated with another billing group. </p>
    #[doc(hidden)]
    pub linked_account_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AccountGrouping {
    /// <p> The account IDs that make up the billing group. Account IDs must be a part of the consolidated billing family, and not associated with another billing group. </p>
    pub fn linked_account_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.linked_account_ids.as_deref()
    }
}
/// See [`AccountGrouping`](crate::model::AccountGrouping).
pub mod account_grouping {

    /// A builder for [`AccountGrouping`](crate::model::AccountGrouping).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) linked_account_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `linked_account_ids`.
        ///
        /// To override the contents of this collection use [`set_linked_account_ids`](Self::set_linked_account_ids).
        ///
        /// <p> The account IDs that make up the billing group. Account IDs must be a part of the consolidated billing family, and not associated with another billing group. </p>
        pub fn linked_account_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.linked_account_ids.unwrap_or_default();
            v.push(input.into());
            self.linked_account_ids = Some(v);
            self
        }
        /// <p> The account IDs that make up the billing group. Account IDs must be a part of the consolidated billing family, and not associated with another billing group. </p>
        pub fn set_linked_account_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.linked_account_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountGrouping`](crate::model::AccountGrouping).
        pub fn build(self) -> crate::model::AccountGrouping {
            crate::model::AccountGrouping {
                linked_account_ids: self.linked_account_ids,
            }
        }
    }
}
impl AccountGrouping {
    /// Creates a new builder-style object to manufacture [`AccountGrouping`](crate::model::AccountGrouping).
    pub fn builder() -> crate::model::account_grouping::Builder {
        crate::model::account_grouping::Builder::default()
    }
}

/// <p>A summary report of actual Amazon Web Services charges and calculated Amazon Web Services charges, based on the associated pricing plan of a billing group. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BillingGroupCostReportElement {
    /// <p>The Amazon Resource Name (ARN) of a billing group. </p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The actual Amazon Web Services charges for the billing group. </p>
    #[doc(hidden)]
    pub aws_cost: std::option::Option<std::string::String>,
    /// <p>The hypothetical Amazon Web Services charges based on the associated pricing plan of a billing group. </p>
    #[doc(hidden)]
    pub proforma_cost: std::option::Option<std::string::String>,
    /// <p> The billing group margin. </p>
    #[doc(hidden)]
    pub margin: std::option::Option<std::string::String>,
    /// <p> The percentage of billing group margin. </p>
    #[doc(hidden)]
    pub margin_percentage: std::option::Option<std::string::String>,
    /// <p>The displayed currency. </p>
    #[doc(hidden)]
    pub currency: std::option::Option<std::string::String>,
}
impl BillingGroupCostReportElement {
    /// <p>The Amazon Resource Name (ARN) of a billing group. </p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The actual Amazon Web Services charges for the billing group. </p>
    pub fn aws_cost(&self) -> std::option::Option<&str> {
        self.aws_cost.as_deref()
    }
    /// <p>The hypothetical Amazon Web Services charges based on the associated pricing plan of a billing group. </p>
    pub fn proforma_cost(&self) -> std::option::Option<&str> {
        self.proforma_cost.as_deref()
    }
    /// <p> The billing group margin. </p>
    pub fn margin(&self) -> std::option::Option<&str> {
        self.margin.as_deref()
    }
    /// <p> The percentage of billing group margin. </p>
    pub fn margin_percentage(&self) -> std::option::Option<&str> {
        self.margin_percentage.as_deref()
    }
    /// <p>The displayed currency. </p>
    pub fn currency(&self) -> std::option::Option<&str> {
        self.currency.as_deref()
    }
}
/// See [`BillingGroupCostReportElement`](crate::model::BillingGroupCostReportElement).
pub mod billing_group_cost_report_element {

    /// A builder for [`BillingGroupCostReportElement`](crate::model::BillingGroupCostReportElement).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) aws_cost: std::option::Option<std::string::String>,
        pub(crate) proforma_cost: std::option::Option<std::string::String>,
        pub(crate) margin: std::option::Option<std::string::String>,
        pub(crate) margin_percentage: std::option::Option<std::string::String>,
        pub(crate) currency: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of a billing group. </p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a billing group. </p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The actual Amazon Web Services charges for the billing group. </p>
        pub fn aws_cost(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_cost = Some(input.into());
            self
        }
        /// <p>The actual Amazon Web Services charges for the billing group. </p>
        pub fn set_aws_cost(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_cost = input;
            self
        }
        /// <p>The hypothetical Amazon Web Services charges based on the associated pricing plan of a billing group. </p>
        pub fn proforma_cost(mut self, input: impl Into<std::string::String>) -> Self {
            self.proforma_cost = Some(input.into());
            self
        }
        /// <p>The hypothetical Amazon Web Services charges based on the associated pricing plan of a billing group. </p>
        pub fn set_proforma_cost(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.proforma_cost = input;
            self
        }
        /// <p> The billing group margin. </p>
        pub fn margin(mut self, input: impl Into<std::string::String>) -> Self {
            self.margin = Some(input.into());
            self
        }
        /// <p> The billing group margin. </p>
        pub fn set_margin(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.margin = input;
            self
        }
        /// <p> The percentage of billing group margin. </p>
        pub fn margin_percentage(mut self, input: impl Into<std::string::String>) -> Self {
            self.margin_percentage = Some(input.into());
            self
        }
        /// <p> The percentage of billing group margin. </p>
        pub fn set_margin_percentage(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.margin_percentage = input;
            self
        }
        /// <p>The displayed currency. </p>
        pub fn currency(mut self, input: impl Into<std::string::String>) -> Self {
            self.currency = Some(input.into());
            self
        }
        /// <p>The displayed currency. </p>
        pub fn set_currency(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.currency = input;
            self
        }
        /// Consumes the builder and constructs a [`BillingGroupCostReportElement`](crate::model::BillingGroupCostReportElement).
        pub fn build(self) -> crate::model::BillingGroupCostReportElement {
            crate::model::BillingGroupCostReportElement {
                arn: self.arn,
                aws_cost: self.aws_cost,
                proforma_cost: self.proforma_cost,
                margin: self.margin,
                margin_percentage: self.margin_percentage,
                currency: self.currency,
            }
        }
    }
}
impl BillingGroupCostReportElement {
    /// Creates a new builder-style object to manufacture [`BillingGroupCostReportElement`](crate::model::BillingGroupCostReportElement).
    pub fn builder() -> crate::model::billing_group_cost_report_element::Builder {
        crate::model::billing_group_cost_report_element::Builder::default()
    }
}

/// <p>The filter used to retrieve specific <code>BillingGroupCostReportElements</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListBillingGroupCostReportsFilter {
    /// <p>The list of Amazon Resource Names (ARNs) used to filter billing groups to retrieve reports. </p>
    #[doc(hidden)]
    pub billing_group_arns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ListBillingGroupCostReportsFilter {
    /// <p>The list of Amazon Resource Names (ARNs) used to filter billing groups to retrieve reports. </p>
    pub fn billing_group_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.billing_group_arns.as_deref()
    }
}
/// See [`ListBillingGroupCostReportsFilter`](crate::model::ListBillingGroupCostReportsFilter).
pub mod list_billing_group_cost_reports_filter {

    /// A builder for [`ListBillingGroupCostReportsFilter`](crate::model::ListBillingGroupCostReportsFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) billing_group_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `billing_group_arns`.
        ///
        /// To override the contents of this collection use [`set_billing_group_arns`](Self::set_billing_group_arns).
        ///
        /// <p>The list of Amazon Resource Names (ARNs) used to filter billing groups to retrieve reports. </p>
        pub fn billing_group_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.billing_group_arns.unwrap_or_default();
            v.push(input.into());
            self.billing_group_arns = Some(v);
            self
        }
        /// <p>The list of Amazon Resource Names (ARNs) used to filter billing groups to retrieve reports. </p>
        pub fn set_billing_group_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.billing_group_arns = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBillingGroupCostReportsFilter`](crate::model::ListBillingGroupCostReportsFilter).
        pub fn build(self) -> crate::model::ListBillingGroupCostReportsFilter {
            crate::model::ListBillingGroupCostReportsFilter {
                billing_group_arns: self.billing_group_arns,
            }
        }
    }
}
impl ListBillingGroupCostReportsFilter {
    /// Creates a new builder-style object to manufacture [`ListBillingGroupCostReportsFilter`](crate::model::ListBillingGroupCostReportsFilter).
    pub fn builder() -> crate::model::list_billing_group_cost_reports_filter::Builder {
        crate::model::list_billing_group_cost_reports_filter::Builder::default()
    }
}

/// <p> A representation of a linked account. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccountAssociationsListElement {
    /// <p> The associating array of account IDs. </p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p> The Billing Group Arn that the linked account is associated to. </p>
    #[doc(hidden)]
    pub billing_group_arn: std::option::Option<std::string::String>,
    /// <p> The Amazon Web Services account name. </p>
    #[doc(hidden)]
    pub account_name: std::option::Option<std::string::String>,
    /// <p> The Amazon Web Services account email. </p>
    #[doc(hidden)]
    pub account_email: std::option::Option<std::string::String>,
}
impl AccountAssociationsListElement {
    /// <p> The associating array of account IDs. </p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p> The Billing Group Arn that the linked account is associated to. </p>
    pub fn billing_group_arn(&self) -> std::option::Option<&str> {
        self.billing_group_arn.as_deref()
    }
    /// <p> The Amazon Web Services account name. </p>
    pub fn account_name(&self) -> std::option::Option<&str> {
        self.account_name.as_deref()
    }
    /// <p> The Amazon Web Services account email. </p>
    pub fn account_email(&self) -> std::option::Option<&str> {
        self.account_email.as_deref()
    }
}
impl std::fmt::Debug for AccountAssociationsListElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccountAssociationsListElement");
        formatter.field("account_id", &self.account_id);
        formatter.field("billing_group_arn", &self.billing_group_arn);
        formatter.field("account_name", &"*** Sensitive Data Redacted ***");
        formatter.field("account_email", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`AccountAssociationsListElement`](crate::model::AccountAssociationsListElement).
pub mod account_associations_list_element {

    /// A builder for [`AccountAssociationsListElement`](crate::model::AccountAssociationsListElement).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) billing_group_arn: std::option::Option<std::string::String>,
        pub(crate) account_name: std::option::Option<std::string::String>,
        pub(crate) account_email: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The associating array of account IDs. </p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p> The associating array of account IDs. </p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p> The Billing Group Arn that the linked account is associated to. </p>
        pub fn billing_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.billing_group_arn = Some(input.into());
            self
        }
        /// <p> The Billing Group Arn that the linked account is associated to. </p>
        pub fn set_billing_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.billing_group_arn = input;
            self
        }
        /// <p> The Amazon Web Services account name. </p>
        pub fn account_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_name = Some(input.into());
            self
        }
        /// <p> The Amazon Web Services account name. </p>
        pub fn set_account_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_name = input;
            self
        }
        /// <p> The Amazon Web Services account email. </p>
        pub fn account_email(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_email = Some(input.into());
            self
        }
        /// <p> The Amazon Web Services account email. </p>
        pub fn set_account_email(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.account_email = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountAssociationsListElement`](crate::model::AccountAssociationsListElement).
        pub fn build(self) -> crate::model::AccountAssociationsListElement {
            crate::model::AccountAssociationsListElement {
                account_id: self.account_id,
                billing_group_arn: self.billing_group_arn,
                account_name: self.account_name,
                account_email: self.account_email,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("account_id", &self.account_id);
            formatter.field("billing_group_arn", &self.billing_group_arn);
            formatter.field("account_name", &"*** Sensitive Data Redacted ***");
            formatter.field("account_email", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl AccountAssociationsListElement {
    /// Creates a new builder-style object to manufacture [`AccountAssociationsListElement`](crate::model::AccountAssociationsListElement).
    pub fn builder() -> crate::model::account_associations_list_element::Builder {
        crate::model::account_associations_list_element::Builder::default()
    }
}

/// <p>The filter on the account ID of the linked account, or any of the following:</p>
/// <p> <code>MONITORED</code>: linked accounts that are associated to billing groups.</p>
/// <p> <code>UNMONITORED</code>: linked accounts that are not associated to billing groups.</p>
/// <p> <code>Billing Group Arn</code>: linked accounts that are associated to the provided Billing Group Arn. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAccountAssociationsFilter {
    /// <p> <code>MONITORED</code>: linked accounts that are associated to billing groups.</p>
    /// <p> <code>UNMONITORED</code>: linked accounts that are not associated to billing groups.</p>
    /// <p> <code>Billing Group Arn</code>: linked accounts that are associated to the provided Billing Group Arn. </p>
    #[doc(hidden)]
    pub association: std::option::Option<std::string::String>,
    /// <p> The Amazon Web Services account ID to filter on. </p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
}
impl ListAccountAssociationsFilter {
    /// <p> <code>MONITORED</code>: linked accounts that are associated to billing groups.</p>
    /// <p> <code>UNMONITORED</code>: linked accounts that are not associated to billing groups.</p>
    /// <p> <code>Billing Group Arn</code>: linked accounts that are associated to the provided Billing Group Arn. </p>
    pub fn association(&self) -> std::option::Option<&str> {
        self.association.as_deref()
    }
    /// <p> The Amazon Web Services account ID to filter on. </p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
}
/// See [`ListAccountAssociationsFilter`](crate::model::ListAccountAssociationsFilter).
pub mod list_account_associations_filter {

    /// A builder for [`ListAccountAssociationsFilter`](crate::model::ListAccountAssociationsFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> <code>MONITORED</code>: linked accounts that are associated to billing groups.</p>
        /// <p> <code>UNMONITORED</code>: linked accounts that are not associated to billing groups.</p>
        /// <p> <code>Billing Group Arn</code>: linked accounts that are associated to the provided Billing Group Arn. </p>
        pub fn association(mut self, input: impl Into<std::string::String>) -> Self {
            self.association = Some(input.into());
            self
        }
        /// <p> <code>MONITORED</code>: linked accounts that are associated to billing groups.</p>
        /// <p> <code>UNMONITORED</code>: linked accounts that are not associated to billing groups.</p>
        /// <p> <code>Billing Group Arn</code>: linked accounts that are associated to the provided Billing Group Arn. </p>
        pub fn set_association(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.association = input;
            self
        }
        /// <p> The Amazon Web Services account ID to filter on. </p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p> The Amazon Web Services account ID to filter on. </p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAccountAssociationsFilter`](crate::model::ListAccountAssociationsFilter).
        pub fn build(self) -> crate::model::ListAccountAssociationsFilter {
            crate::model::ListAccountAssociationsFilter {
                association: self.association,
                account_id: self.account_id,
            }
        }
    }
}
impl ListAccountAssociationsFilter {
    /// Creates a new builder-style object to manufacture [`ListAccountAssociationsFilter`](crate::model::ListAccountAssociationsFilter).
    pub fn builder() -> crate::model::list_account_associations_filter::Builder {
        crate::model::list_account_associations_filter::Builder::default()
    }
}
