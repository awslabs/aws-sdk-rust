// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Checks the availability of one or more image layers within a repository in a public
/// registry. When an image is pushed to a repository, each image layer is checked to verify if
/// it has been uploaded before. If it has been uploaded, then the image layer is
/// skipped.</p>
/// <note>
/// <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchCheckLayerAvailability {
    _private: (),
}
impl BatchCheckLayerAvailability {
    /// Creates a new builder-style object to manufacture [`BatchCheckLayerAvailabilityInput`](crate::input::BatchCheckLayerAvailabilityInput)
    pub fn builder() -> crate::input::batch_check_layer_availability_input::Builder {
        crate::input::batch_check_layer_availability_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchCheckLayerAvailability {
    type Output = std::result::Result<
        crate::output::BatchCheckLayerAvailabilityOutput,
        crate::error::BatchCheckLayerAvailabilityError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_check_layer_availability_error(response)
        } else {
            crate::operation_deser::parse_batch_check_layer_availability_response(response)
        }
    }
}

/// <p>Deletes a list of specified images within a repository in a public registry. Images are
/// specified with either an <code>imageTag</code> or <code>imageDigest</code>.</p>
/// <p>You can remove a tag from an image by specifying the image's tag in your request. When
/// you remove the last tag from an image, the image is deleted from your repository.</p>
/// <p>You can completely delete an image (and all of its tags) by specifying the image's
/// digest in your request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDeleteImage {
    _private: (),
}
impl BatchDeleteImage {
    /// Creates a new builder-style object to manufacture [`BatchDeleteImageInput`](crate::input::BatchDeleteImageInput)
    pub fn builder() -> crate::input::batch_delete_image_input::Builder {
        crate::input::batch_delete_image_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDeleteImage {
    type Output = std::result::Result<
        crate::output::BatchDeleteImageOutput,
        crate::error::BatchDeleteImageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_delete_image_error(response)
        } else {
            crate::operation_deser::parse_batch_delete_image_response(response)
        }
    }
}

/// <p>Informs Amazon ECR that the image layer upload has completed for a specified public registry,
/// repository name, and upload ID. You can optionally provide a <code>sha256</code> digest of
/// the image layer for data validation purposes.</p>
/// <p>When an image is pushed, the CompleteLayerUpload API is called once per each new image
/// layer to verify that the upload has completed.</p>
/// <note>
/// <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CompleteLayerUpload {
    _private: (),
}
impl CompleteLayerUpload {
    /// Creates a new builder-style object to manufacture [`CompleteLayerUploadInput`](crate::input::CompleteLayerUploadInput)
    pub fn builder() -> crate::input::complete_layer_upload_input::Builder {
        crate::input::complete_layer_upload_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CompleteLayerUpload {
    type Output = std::result::Result<
        crate::output::CompleteLayerUploadOutput,
        crate::error::CompleteLayerUploadError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_complete_layer_upload_error(response)
        } else {
            crate::operation_deser::parse_complete_layer_upload_response(response)
        }
    }
}

/// <p>Creates a repository in a public registry. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/Repositories.html">Amazon ECR
/// repositories</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateRepository {
    _private: (),
}
impl CreateRepository {
    /// Creates a new builder-style object to manufacture [`CreateRepositoryInput`](crate::input::CreateRepositoryInput)
    pub fn builder() -> crate::input::create_repository_input::Builder {
        crate::input::create_repository_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateRepository {
    type Output = std::result::Result<
        crate::output::CreateRepositoryOutput,
        crate::error::CreateRepositoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_repository_error(response)
        } else {
            crate::operation_deser::parse_create_repository_response(response)
        }
    }
}

/// <p>Deletes a repository in a public registry. If the repository contains images, you must
/// either delete all images in the repository or use the <code>force</code> option which
/// deletes all images on your behalf before deleting the repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRepository {
    _private: (),
}
impl DeleteRepository {
    /// Creates a new builder-style object to manufacture [`DeleteRepositoryInput`](crate::input::DeleteRepositoryInput)
    pub fn builder() -> crate::input::delete_repository_input::Builder {
        crate::input::delete_repository_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRepository {
    type Output = std::result::Result<
        crate::output::DeleteRepositoryOutput,
        crate::error::DeleteRepositoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_repository_error(response)
        } else {
            crate::operation_deser::parse_delete_repository_response(response)
        }
    }
}

/// <p>Deletes the repository policy associated with the specified repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRepositoryPolicy {
    _private: (),
}
impl DeleteRepositoryPolicy {
    /// Creates a new builder-style object to manufacture [`DeleteRepositoryPolicyInput`](crate::input::DeleteRepositoryPolicyInput)
    pub fn builder() -> crate::input::delete_repository_policy_input::Builder {
        crate::input::delete_repository_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRepositoryPolicy {
    type Output = std::result::Result<
        crate::output::DeleteRepositoryPolicyOutput,
        crate::error::DeleteRepositoryPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_repository_policy_error(response)
        } else {
            crate::operation_deser::parse_delete_repository_policy_response(response)
        }
    }
}

/// <p>Returns metadata about the images in a repository in a public registry.</p>
/// <note>
/// <p>Beginning with Docker version 1.9, the Docker client compresses image layers before
/// pushing them to a V2 Docker registry. The output of the <code>docker images</code>
/// command shows the uncompressed image size, so it may return a larger image size than the
/// image sizes returned by <a>DescribeImages</a>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeImages {
    _private: (),
}
impl DescribeImages {
    /// Creates a new builder-style object to manufacture [`DescribeImagesInput`](crate::input::DescribeImagesInput)
    pub fn builder() -> crate::input::describe_images_input::Builder {
        crate::input::describe_images_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeImages {
    type Output =
        std::result::Result<crate::output::DescribeImagesOutput, crate::error::DescribeImagesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_images_error(response)
        } else {
            crate::operation_deser::parse_describe_images_response(response)
        }
    }
}

/// <p>Returns the image tag details for a repository in a public registry.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeImageTags {
    _private: (),
}
impl DescribeImageTags {
    /// Creates a new builder-style object to manufacture [`DescribeImageTagsInput`](crate::input::DescribeImageTagsInput)
    pub fn builder() -> crate::input::describe_image_tags_input::Builder {
        crate::input::describe_image_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeImageTags {
    type Output = std::result::Result<
        crate::output::DescribeImageTagsOutput,
        crate::error::DescribeImageTagsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_image_tags_error(response)
        } else {
            crate::operation_deser::parse_describe_image_tags_response(response)
        }
    }
}

/// <p>Returns details for a public registry.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeRegistries {
    _private: (),
}
impl DescribeRegistries {
    /// Creates a new builder-style object to manufacture [`DescribeRegistriesInput`](crate::input::DescribeRegistriesInput)
    pub fn builder() -> crate::input::describe_registries_input::Builder {
        crate::input::describe_registries_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeRegistries {
    type Output = std::result::Result<
        crate::output::DescribeRegistriesOutput,
        crate::error::DescribeRegistriesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_registries_error(response)
        } else {
            crate::operation_deser::parse_describe_registries_response(response)
        }
    }
}

/// <p>Describes repositories in a public registry.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeRepositories {
    _private: (),
}
impl DescribeRepositories {
    /// Creates a new builder-style object to manufacture [`DescribeRepositoriesInput`](crate::input::DescribeRepositoriesInput)
    pub fn builder() -> crate::input::describe_repositories_input::Builder {
        crate::input::describe_repositories_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeRepositories {
    type Output = std::result::Result<
        crate::output::DescribeRepositoriesOutput,
        crate::error::DescribeRepositoriesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_repositories_error(response)
        } else {
            crate::operation_deser::parse_describe_repositories_response(response)
        }
    }
}

/// <p>Retrieves an authorization token. An authorization token represents your IAM
/// authentication credentials and can be used to access any Amazon ECR registry that your IAM
/// principal has access to. The authorization token is valid for 12 hours. This API requires
/// the <code>ecr-public:GetAuthorizationToken</code> and
/// <code>sts:GetServiceBearerToken</code> permissions.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetAuthorizationToken {
    _private: (),
}
impl GetAuthorizationToken {
    /// Creates a new builder-style object to manufacture [`GetAuthorizationTokenInput`](crate::input::GetAuthorizationTokenInput)
    pub fn builder() -> crate::input::get_authorization_token_input::Builder {
        crate::input::get_authorization_token_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetAuthorizationToken {
    type Output = std::result::Result<
        crate::output::GetAuthorizationTokenOutput,
        crate::error::GetAuthorizationTokenError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_authorization_token_error(response)
        } else {
            crate::operation_deser::parse_get_authorization_token_response(response)
        }
    }
}

/// <p>Retrieves catalog metadata for a public registry.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRegistryCatalogData {
    _private: (),
}
impl GetRegistryCatalogData {
    /// Creates a new builder-style object to manufacture [`GetRegistryCatalogDataInput`](crate::input::GetRegistryCatalogDataInput)
    pub fn builder() -> crate::input::get_registry_catalog_data_input::Builder {
        crate::input::get_registry_catalog_data_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRegistryCatalogData {
    type Output = std::result::Result<
        crate::output::GetRegistryCatalogDataOutput,
        crate::error::GetRegistryCatalogDataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_registry_catalog_data_error(response)
        } else {
            crate::operation_deser::parse_get_registry_catalog_data_response(response)
        }
    }
}

/// <p>Retrieve catalog metadata for a repository in a public registry. This metadata is
/// displayed publicly in the Amazon ECR Public Gallery.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRepositoryCatalogData {
    _private: (),
}
impl GetRepositoryCatalogData {
    /// Creates a new builder-style object to manufacture [`GetRepositoryCatalogDataInput`](crate::input::GetRepositoryCatalogDataInput)
    pub fn builder() -> crate::input::get_repository_catalog_data_input::Builder {
        crate::input::get_repository_catalog_data_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRepositoryCatalogData {
    type Output = std::result::Result<
        crate::output::GetRepositoryCatalogDataOutput,
        crate::error::GetRepositoryCatalogDataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_repository_catalog_data_error(response)
        } else {
            crate::operation_deser::parse_get_repository_catalog_data_response(response)
        }
    }
}

/// <p>Retrieves the repository policy for the specified repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRepositoryPolicy {
    _private: (),
}
impl GetRepositoryPolicy {
    /// Creates a new builder-style object to manufacture [`GetRepositoryPolicyInput`](crate::input::GetRepositoryPolicyInput)
    pub fn builder() -> crate::input::get_repository_policy_input::Builder {
        crate::input::get_repository_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRepositoryPolicy {
    type Output = std::result::Result<
        crate::output::GetRepositoryPolicyOutput,
        crate::error::GetRepositoryPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_repository_policy_error(response)
        } else {
            crate::operation_deser::parse_get_repository_policy_response(response)
        }
    }
}

/// <p>Notifies Amazon ECR that you intend to upload an image layer.</p>
/// <p>When an image is pushed, the InitiateLayerUpload API is called once per image layer that
/// has not already been uploaded. Whether or not an image layer has been uploaded is
/// determined by the BatchCheckLayerAvailability API action.</p>
/// <note>
/// <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct InitiateLayerUpload {
    _private: (),
}
impl InitiateLayerUpload {
    /// Creates a new builder-style object to manufacture [`InitiateLayerUploadInput`](crate::input::InitiateLayerUploadInput)
    pub fn builder() -> crate::input::initiate_layer_upload_input::Builder {
        crate::input::initiate_layer_upload_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for InitiateLayerUpload {
    type Output = std::result::Result<
        crate::output::InitiateLayerUploadOutput,
        crate::error::InitiateLayerUploadError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_initiate_layer_upload_error(response)
        } else {
            crate::operation_deser::parse_initiate_layer_upload_response(response)
        }
    }
}

/// <p>List the tags for an Amazon ECR Public resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Creates or updates the image manifest and tags associated with an image.</p>
/// <p>When an image is pushed and all new image layers have been uploaded, the PutImage API is
/// called once to create or update the image manifest and the tags associated with the
/// image.</p>
/// <note>
/// <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutImage {
    _private: (),
}
impl PutImage {
    /// Creates a new builder-style object to manufacture [`PutImageInput`](crate::input::PutImageInput)
    pub fn builder() -> crate::input::put_image_input::Builder {
        crate::input::put_image_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutImage {
    type Output = std::result::Result<crate::output::PutImageOutput, crate::error::PutImageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_image_error(response)
        } else {
            crate::operation_deser::parse_put_image_response(response)
        }
    }
}

/// <p>Create or updates the catalog data for a public registry.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutRegistryCatalogData {
    _private: (),
}
impl PutRegistryCatalogData {
    /// Creates a new builder-style object to manufacture [`PutRegistryCatalogDataInput`](crate::input::PutRegistryCatalogDataInput)
    pub fn builder() -> crate::input::put_registry_catalog_data_input::Builder {
        crate::input::put_registry_catalog_data_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutRegistryCatalogData {
    type Output = std::result::Result<
        crate::output::PutRegistryCatalogDataOutput,
        crate::error::PutRegistryCatalogDataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_registry_catalog_data_error(response)
        } else {
            crate::operation_deser::parse_put_registry_catalog_data_response(response)
        }
    }
}

/// <p>Creates or updates the catalog data for a repository in a public registry.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutRepositoryCatalogData {
    _private: (),
}
impl PutRepositoryCatalogData {
    /// Creates a new builder-style object to manufacture [`PutRepositoryCatalogDataInput`](crate::input::PutRepositoryCatalogDataInput)
    pub fn builder() -> crate::input::put_repository_catalog_data_input::Builder {
        crate::input::put_repository_catalog_data_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutRepositoryCatalogData {
    type Output = std::result::Result<
        crate::output::PutRepositoryCatalogDataOutput,
        crate::error::PutRepositoryCatalogDataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_repository_catalog_data_error(response)
        } else {
            crate::operation_deser::parse_put_repository_catalog_data_response(response)
        }
    }
}

/// <p>Applies a repository policy to the specified public repository to control access
/// permissions. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policies.html">Amazon ECR Repository
/// Policies</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetRepositoryPolicy {
    _private: (),
}
impl SetRepositoryPolicy {
    /// Creates a new builder-style object to manufacture [`SetRepositoryPolicyInput`](crate::input::SetRepositoryPolicyInput)
    pub fn builder() -> crate::input::set_repository_policy_input::Builder {
        crate::input::set_repository_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetRepositoryPolicy {
    type Output = std::result::Result<
        crate::output::SetRepositoryPolicyOutput,
        crate::error::SetRepositoryPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_set_repository_policy_error(response)
        } else {
            crate::operation_deser::parse_set_repository_policy_response(response)
        }
    }
}

/// <p>Associates the specified tags to a resource with the specified <code>resourceArn</code>.
/// If existing tags on a resource are not specified in the request parameters, they are not
/// changed. When a resource is deleted, the tags associated with that resource are deleted as
/// well.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Deletes specified tags from a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Uploads an image layer part to Amazon ECR.</p>
/// <p>When an image is pushed, each new image layer is uploaded in parts. The maximum size of
/// each image layer part can be 20971520 bytes (or about 20MB). The UploadLayerPart API is
/// called once per each new image layer part.</p>
/// <note>
/// <p>This operation is used by the Amazon ECR proxy and is not generally used by customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UploadLayerPart {
    _private: (),
}
impl UploadLayerPart {
    /// Creates a new builder-style object to manufacture [`UploadLayerPartInput`](crate::input::UploadLayerPartInput)
    pub fn builder() -> crate::input::upload_layer_part_input::Builder {
        crate::input::upload_layer_part_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UploadLayerPart {
    type Output = std::result::Result<
        crate::output::UploadLayerPartOutput,
        crate::error::UploadLayerPartError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_upload_layer_part_error(response)
        } else {
            crate::operation_deser::parse_upload_layer_part_response(response)
        }
    }
}
