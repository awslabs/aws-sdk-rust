// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `ConnectorType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let connectortype = unimplemented!();
/// match connectortype {
///     ConnectorType::Amplitude => { /* ... */ },
///     ConnectorType::Customconnector => { /* ... */ },
///     ConnectorType::Customerprofiles => { /* ... */ },
///     ConnectorType::Datadog => { /* ... */ },
///     ConnectorType::Dynatrace => { /* ... */ },
///     ConnectorType::Eventbridge => { /* ... */ },
///     ConnectorType::Googleanalytics => { /* ... */ },
///     ConnectorType::Honeycode => { /* ... */ },
///     ConnectorType::Infornexus => { /* ... */ },
///     ConnectorType::Lookoutmetrics => { /* ... */ },
///     ConnectorType::Marketo => { /* ... */ },
///     ConnectorType::Pardot => { /* ... */ },
///     ConnectorType::Redshift => { /* ... */ },
///     ConnectorType::S3 => { /* ... */ },
///     ConnectorType::Sapodata => { /* ... */ },
///     ConnectorType::Salesforce => { /* ... */ },
///     ConnectorType::Servicenow => { /* ... */ },
///     ConnectorType::Singular => { /* ... */ },
///     ConnectorType::Slack => { /* ... */ },
///     ConnectorType::Snowflake => { /* ... */ },
///     ConnectorType::Trendmicro => { /* ... */ },
///     ConnectorType::Upsolver => { /* ... */ },
///     ConnectorType::Veeva => { /* ... */ },
///     ConnectorType::Zendesk => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `connectortype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConnectorType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConnectorType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConnectorType::NewFeature` is defined.
/// Specifically, when `connectortype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConnectorType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConnectorType {
    #[allow(missing_docs)] // documentation missing in model
    Amplitude,
    #[allow(missing_docs)] // documentation missing in model
    Customconnector,
    #[allow(missing_docs)] // documentation missing in model
    Customerprofiles,
    #[allow(missing_docs)] // documentation missing in model
    Datadog,
    #[allow(missing_docs)] // documentation missing in model
    Dynatrace,
    #[allow(missing_docs)] // documentation missing in model
    Eventbridge,
    #[allow(missing_docs)] // documentation missing in model
    Googleanalytics,
    #[allow(missing_docs)] // documentation missing in model
    Honeycode,
    #[allow(missing_docs)] // documentation missing in model
    Infornexus,
    #[allow(missing_docs)] // documentation missing in model
    Lookoutmetrics,
    #[allow(missing_docs)] // documentation missing in model
    Marketo,
    #[allow(missing_docs)] // documentation missing in model
    Pardot,
    #[allow(missing_docs)] // documentation missing in model
    Redshift,
    #[allow(missing_docs)] // documentation missing in model
    S3,
    #[allow(missing_docs)] // documentation missing in model
    Sapodata,
    #[allow(missing_docs)] // documentation missing in model
    Salesforce,
    #[allow(missing_docs)] // documentation missing in model
    Servicenow,
    #[allow(missing_docs)] // documentation missing in model
    Singular,
    #[allow(missing_docs)] // documentation missing in model
    Slack,
    #[allow(missing_docs)] // documentation missing in model
    Snowflake,
    #[allow(missing_docs)] // documentation missing in model
    Trendmicro,
    #[allow(missing_docs)] // documentation missing in model
    Upsolver,
    #[allow(missing_docs)] // documentation missing in model
    Veeva,
    #[allow(missing_docs)] // documentation missing in model
    Zendesk,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::primitives::UnknownVariantValue),
}
impl std::convert::From<&str> for ConnectorType {
    fn from(s: &str) -> Self {
        match s {
            "Amplitude" => ConnectorType::Amplitude,
            "CustomConnector" => ConnectorType::Customconnector,
            "CustomerProfiles" => ConnectorType::Customerprofiles,
            "Datadog" => ConnectorType::Datadog,
            "Dynatrace" => ConnectorType::Dynatrace,
            "EventBridge" => ConnectorType::Eventbridge,
            "Googleanalytics" => ConnectorType::Googleanalytics,
            "Honeycode" => ConnectorType::Honeycode,
            "Infornexus" => ConnectorType::Infornexus,
            "LookoutMetrics" => ConnectorType::Lookoutmetrics,
            "Marketo" => ConnectorType::Marketo,
            "Pardot" => ConnectorType::Pardot,
            "Redshift" => ConnectorType::Redshift,
            "S3" => ConnectorType::S3,
            "SAPOData" => ConnectorType::Sapodata,
            "Salesforce" => ConnectorType::Salesforce,
            "Servicenow" => ConnectorType::Servicenow,
            "Singular" => ConnectorType::Singular,
            "Slack" => ConnectorType::Slack,
            "Snowflake" => ConnectorType::Snowflake,
            "Trendmicro" => ConnectorType::Trendmicro,
            "Upsolver" => ConnectorType::Upsolver,
            "Veeva" => ConnectorType::Veeva,
            "Zendesk" => ConnectorType::Zendesk,
            other => {
                ConnectorType::Unknown(crate::primitives::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ConnectorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConnectorType::from(s))
    }
}
impl ConnectorType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConnectorType::Amplitude => "Amplitude",
            ConnectorType::Customconnector => "CustomConnector",
            ConnectorType::Customerprofiles => "CustomerProfiles",
            ConnectorType::Datadog => "Datadog",
            ConnectorType::Dynatrace => "Dynatrace",
            ConnectorType::Eventbridge => "EventBridge",
            ConnectorType::Googleanalytics => "Googleanalytics",
            ConnectorType::Honeycode => "Honeycode",
            ConnectorType::Infornexus => "Infornexus",
            ConnectorType::Lookoutmetrics => "LookoutMetrics",
            ConnectorType::Marketo => "Marketo",
            ConnectorType::Pardot => "Pardot",
            ConnectorType::Redshift => "Redshift",
            ConnectorType::S3 => "S3",
            ConnectorType::Sapodata => "SAPOData",
            ConnectorType::Salesforce => "Salesforce",
            ConnectorType::Servicenow => "Servicenow",
            ConnectorType::Singular => "Singular",
            ConnectorType::Slack => "Slack",
            ConnectorType::Snowflake => "Snowflake",
            ConnectorType::Trendmicro => "Trendmicro",
            ConnectorType::Upsolver => "Upsolver",
            ConnectorType::Veeva => "Veeva",
            ConnectorType::Zendesk => "Zendesk",
            ConnectorType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Amplitude",
            "CustomConnector",
            "CustomerProfiles",
            "Datadog",
            "Dynatrace",
            "EventBridge",
            "Googleanalytics",
            "Honeycode",
            "Infornexus",
            "LookoutMetrics",
            "Marketo",
            "Pardot",
            "Redshift",
            "S3",
            "SAPOData",
            "Salesforce",
            "Servicenow",
            "Singular",
            "Slack",
            "Snowflake",
            "Trendmicro",
            "Upsolver",
            "Veeva",
            "Zendesk",
        ]
    }
}
impl AsRef<str> for ConnectorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
