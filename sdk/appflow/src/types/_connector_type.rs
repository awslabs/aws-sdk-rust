// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `ConnectorType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let connectortype = unimplemented!();
/// match connectortype {
///     ConnectorType::Amplitude => { /* ... */ },
///     ConnectorType::Customconnector => { /* ... */ },
///     ConnectorType::Customerprofiles => { /* ... */ },
///     ConnectorType::Datadog => { /* ... */ },
///     ConnectorType::Dynatrace => { /* ... */ },
///     ConnectorType::Eventbridge => { /* ... */ },
///     ConnectorType::Googleanalytics => { /* ... */ },
///     ConnectorType::Honeycode => { /* ... */ },
///     ConnectorType::Infornexus => { /* ... */ },
///     ConnectorType::Lookoutmetrics => { /* ... */ },
///     ConnectorType::Marketo => { /* ... */ },
///     ConnectorType::Pardot => { /* ... */ },
///     ConnectorType::Redshift => { /* ... */ },
///     ConnectorType::S3 => { /* ... */ },
///     ConnectorType::Sapodata => { /* ... */ },
///     ConnectorType::Salesforce => { /* ... */ },
///     ConnectorType::Servicenow => { /* ... */ },
///     ConnectorType::Singular => { /* ... */ },
///     ConnectorType::Slack => { /* ... */ },
///     ConnectorType::Snowflake => { /* ... */ },
///     ConnectorType::Trendmicro => { /* ... */ },
///     ConnectorType::Upsolver => { /* ... */ },
///     ConnectorType::Veeva => { /* ... */ },
///     ConnectorType::Zendesk => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `connectortype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConnectorType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConnectorType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConnectorType::NewFeature` is defined.
/// Specifically, when `connectortype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConnectorType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ConnectorType {
    #[allow(missing_docs)] // documentation missing in model
    Amplitude,
    #[allow(missing_docs)] // documentation missing in model
    Customconnector,
    #[allow(missing_docs)] // documentation missing in model
    Customerprofiles,
    #[allow(missing_docs)] // documentation missing in model
    Datadog,
    #[allow(missing_docs)] // documentation missing in model
    Dynatrace,
    #[allow(missing_docs)] // documentation missing in model
    Eventbridge,
    #[allow(missing_docs)] // documentation missing in model
    Googleanalytics,
    #[allow(missing_docs)] // documentation missing in model
    Honeycode,
    #[allow(missing_docs)] // documentation missing in model
    Infornexus,
    #[allow(missing_docs)] // documentation missing in model
    Lookoutmetrics,
    #[allow(missing_docs)] // documentation missing in model
    Marketo,
    #[allow(missing_docs)] // documentation missing in model
    Pardot,
    #[allow(missing_docs)] // documentation missing in model
    Redshift,
    #[allow(missing_docs)] // documentation missing in model
    S3,
    #[allow(missing_docs)] // documentation missing in model
    Sapodata,
    #[allow(missing_docs)] // documentation missing in model
    Salesforce,
    #[allow(missing_docs)] // documentation missing in model
    Servicenow,
    #[allow(missing_docs)] // documentation missing in model
    Singular,
    #[allow(missing_docs)] // documentation missing in model
    Slack,
    #[allow(missing_docs)] // documentation missing in model
    Snowflake,
    #[allow(missing_docs)] // documentation missing in model
    Trendmicro,
    #[allow(missing_docs)] // documentation missing in model
    Upsolver,
    #[allow(missing_docs)] // documentation missing in model
    Veeva,
    #[allow(missing_docs)] // documentation missing in model
    Zendesk,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::primitives::UnknownVariantValue)
}
impl std::convert::From<&str> for ConnectorType {
                fn from(s: &str) -> Self {
                    match s {
                        "Amplitude" => ConnectorType::Amplitude,
"CustomConnector" => ConnectorType::Customconnector,
"CustomerProfiles" => ConnectorType::Customerprofiles,
"Datadog" => ConnectorType::Datadog,
"Dynatrace" => ConnectorType::Dynatrace,
"EventBridge" => ConnectorType::Eventbridge,
"Googleanalytics" => ConnectorType::Googleanalytics,
"Honeycode" => ConnectorType::Honeycode,
"Infornexus" => ConnectorType::Infornexus,
"LookoutMetrics" => ConnectorType::Lookoutmetrics,
"Marketo" => ConnectorType::Marketo,
"Pardot" => ConnectorType::Pardot,
"Redshift" => ConnectorType::Redshift,
"S3" => ConnectorType::S3,
"SAPOData" => ConnectorType::Sapodata,
"Salesforce" => ConnectorType::Salesforce,
"Servicenow" => ConnectorType::Servicenow,
"Singular" => ConnectorType::Singular,
"Slack" => ConnectorType::Slack,
"Snowflake" => ConnectorType::Snowflake,
"Trendmicro" => ConnectorType::Trendmicro,
"Upsolver" => ConnectorType::Upsolver,
"Veeva" => ConnectorType::Veeva,
"Zendesk" => ConnectorType::Zendesk,
other => ConnectorType::Unknown(crate::primitives::UnknownVariantValue(other.to_owned()))
                    }
                }
            }
impl std::str::FromStr for ConnectorType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ConnectorType::from(s))
                }
            }
impl ConnectorType {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    ConnectorType::Amplitude => "Amplitude",
    ConnectorType::Customconnector => "CustomConnector",
    ConnectorType::Customerprofiles => "CustomerProfiles",
    ConnectorType::Datadog => "Datadog",
    ConnectorType::Dynatrace => "Dynatrace",
    ConnectorType::Eventbridge => "EventBridge",
    ConnectorType::Googleanalytics => "Googleanalytics",
    ConnectorType::Honeycode => "Honeycode",
    ConnectorType::Infornexus => "Infornexus",
    ConnectorType::Lookoutmetrics => "LookoutMetrics",
    ConnectorType::Marketo => "Marketo",
    ConnectorType::Pardot => "Pardot",
    ConnectorType::Redshift => "Redshift",
    ConnectorType::S3 => "S3",
    ConnectorType::Sapodata => "SAPOData",
    ConnectorType::Salesforce => "Salesforce",
    ConnectorType::Servicenow => "Servicenow",
    ConnectorType::Singular => "Singular",
    ConnectorType::Slack => "Slack",
    ConnectorType::Snowflake => "Snowflake",
    ConnectorType::Trendmicro => "Trendmicro",
    ConnectorType::Upsolver => "Upsolver",
    ConnectorType::Veeva => "Veeva",
    ConnectorType::Zendesk => "Zendesk",
    ConnectorType::Unknown(value) => value.as_str()
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["Amplitude", "CustomConnector", "CustomerProfiles", "Datadog", "Dynatrace", "EventBridge", "Googleanalytics", "Honeycode", "Infornexus", "LookoutMetrics", "Marketo", "Pardot", "Redshift", "S3", "SAPOData", "Salesforce", "Servicenow", "Singular", "Slack", "Snowflake", "Trendmicro", "Upsolver", "Veeva", "Zendesk"]
                }
            }
impl AsRef<str> for ConnectorType {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }

