// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p> Creates a new connector profile associated with your Amazon Web Services account. There is a soft quota
/// of 100 connector profiles per Amazon Web Services account. If you need more connector profiles than this quota
/// allows, you can submit a request to the Amazon AppFlow team through the Amazon AppFlow support
/// channel. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateConnectorProfile {
    _private: (),
}
impl CreateConnectorProfile {
    /// Creates a new builder-style object to manufacture [`CreateConnectorProfileInput`](crate::input::CreateConnectorProfileInput)
    pub fn builder() -> crate::input::create_connector_profile_input::Builder {
        crate::input::create_connector_profile_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateConnectorProfile {
    type Output = std::result::Result<
        crate::output::CreateConnectorProfileOutput,
        crate::error::CreateConnectorProfileError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_connector_profile_error(response)
        } else {
            crate::operation_deser::parse_create_connector_profile_response(response)
        }
    }
}

/// <p> Enables your application to create a new flow using Amazon AppFlow. You must create a
/// connector profile before calling this API. Please note that the Request Syntax below shows
/// syntax for multiple destinations, however, you can only transfer data to one item in this list
/// at a time. Amazon AppFlow does not currently support flows to multiple destinations at once. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateFlow {
    _private: (),
}
impl CreateFlow {
    /// Creates a new builder-style object to manufacture [`CreateFlowInput`](crate::input::CreateFlowInput)
    pub fn builder() -> crate::input::create_flow_input::Builder {
        crate::input::create_flow_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateFlow {
    type Output =
        std::result::Result<crate::output::CreateFlowOutput, crate::error::CreateFlowError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_flow_error(response)
        } else {
            crate::operation_deser::parse_create_flow_response(response)
        }
    }
}

/// <p> Enables you to delete an existing connector profile. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteConnectorProfile {
    _private: (),
}
impl DeleteConnectorProfile {
    /// Creates a new builder-style object to manufacture [`DeleteConnectorProfileInput`](crate::input::DeleteConnectorProfileInput)
    pub fn builder() -> crate::input::delete_connector_profile_input::Builder {
        crate::input::delete_connector_profile_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteConnectorProfile {
    type Output = std::result::Result<
        crate::output::DeleteConnectorProfileOutput,
        crate::error::DeleteConnectorProfileError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_connector_profile_error(response)
        } else {
            crate::operation_deser::parse_delete_connector_profile_response(response)
        }
    }
}

/// <p> Enables your application to delete an existing flow. Before deleting the flow, Amazon
/// AppFlow validates the request by checking the flow configuration and status. You can delete
/// flows one at a time. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFlow {
    _private: (),
}
impl DeleteFlow {
    /// Creates a new builder-style object to manufacture [`DeleteFlowInput`](crate::input::DeleteFlowInput)
    pub fn builder() -> crate::input::delete_flow_input::Builder {
        crate::input::delete_flow_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFlow {
    type Output =
        std::result::Result<crate::output::DeleteFlowOutput, crate::error::DeleteFlowError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_flow_error(response)
        } else {
            crate::operation_deser::parse_delete_flow_response(response)
        }
    }
}

/// <p> Provides details regarding the entity used with the connector, with a description of the
/// data model for each entity. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeConnectorEntity {
    _private: (),
}
impl DescribeConnectorEntity {
    /// Creates a new builder-style object to manufacture [`DescribeConnectorEntityInput`](crate::input::DescribeConnectorEntityInput)
    pub fn builder() -> crate::input::describe_connector_entity_input::Builder {
        crate::input::describe_connector_entity_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeConnectorEntity {
    type Output = std::result::Result<
        crate::output::DescribeConnectorEntityOutput,
        crate::error::DescribeConnectorEntityError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_connector_entity_error(response)
        } else {
            crate::operation_deser::parse_describe_connector_entity_response(response)
        }
    }
}

/// <p> Returns a list of <code>connector-profile</code> details matching the provided
/// <code>connector-profile</code> names and <code>connector-types</code>. Both input lists are
/// optional, and you can use them to filter the result. </p>
/// <p>If no names or <code>connector-types</code> are provided, returns all connector profiles
/// in a paginated form. If there is no match, this operation returns an empty list.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeConnectorProfiles {
    _private: (),
}
impl DescribeConnectorProfiles {
    /// Creates a new builder-style object to manufacture [`DescribeConnectorProfilesInput`](crate::input::DescribeConnectorProfilesInput)
    pub fn builder() -> crate::input::describe_connector_profiles_input::Builder {
        crate::input::describe_connector_profiles_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeConnectorProfiles {
    type Output = std::result::Result<
        crate::output::DescribeConnectorProfilesOutput,
        crate::error::DescribeConnectorProfilesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_connector_profiles_error(response)
        } else {
            crate::operation_deser::parse_describe_connector_profiles_response(response)
        }
    }
}

/// <p> Describes the connectors vended by Amazon AppFlow for specified connector types. If you
/// don't specify a connector type, this operation describes all connectors vended by Amazon
/// AppFlow. If there are more connectors than can be returned in one page, the response contains
/// a <code>nextToken</code> object, which can be be passed in to the next call to the
/// <code>DescribeConnectors</code> API operation to retrieve the next page. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeConnectors {
    _private: (),
}
impl DescribeConnectors {
    /// Creates a new builder-style object to manufacture [`DescribeConnectorsInput`](crate::input::DescribeConnectorsInput)
    pub fn builder() -> crate::input::describe_connectors_input::Builder {
        crate::input::describe_connectors_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeConnectors {
    type Output = std::result::Result<
        crate::output::DescribeConnectorsOutput,
        crate::error::DescribeConnectorsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_connectors_error(response)
        } else {
            crate::operation_deser::parse_describe_connectors_response(response)
        }
    }
}

/// <p> Provides a description of the specified flow. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeFlow {
    _private: (),
}
impl DescribeFlow {
    /// Creates a new builder-style object to manufacture [`DescribeFlowInput`](crate::input::DescribeFlowInput)
    pub fn builder() -> crate::input::describe_flow_input::Builder {
        crate::input::describe_flow_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeFlow {
    type Output =
        std::result::Result<crate::output::DescribeFlowOutput, crate::error::DescribeFlowError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_flow_error(response)
        } else {
            crate::operation_deser::parse_describe_flow_response(response)
        }
    }
}

/// <p> Fetches the execution history of the flow. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeFlowExecutionRecords {
    _private: (),
}
impl DescribeFlowExecutionRecords {
    /// Creates a new builder-style object to manufacture [`DescribeFlowExecutionRecordsInput`](crate::input::DescribeFlowExecutionRecordsInput)
    pub fn builder() -> crate::input::describe_flow_execution_records_input::Builder {
        crate::input::describe_flow_execution_records_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeFlowExecutionRecords {
    type Output = std::result::Result<
        crate::output::DescribeFlowExecutionRecordsOutput,
        crate::error::DescribeFlowExecutionRecordsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_flow_execution_records_error(response)
        } else {
            crate::operation_deser::parse_describe_flow_execution_records_response(response)
        }
    }
}

/// <p> Returns the list of available connector entities supported by Amazon AppFlow. For
/// example, you can query Salesforce for <i>Account</i> and
/// <i>Opportunity</i> entities, or query ServiceNow for the
/// <i>Incident</i> entity. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListConnectorEntities {
    _private: (),
}
impl ListConnectorEntities {
    /// Creates a new builder-style object to manufacture [`ListConnectorEntitiesInput`](crate::input::ListConnectorEntitiesInput)
    pub fn builder() -> crate::input::list_connector_entities_input::Builder {
        crate::input::list_connector_entities_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListConnectorEntities {
    type Output = std::result::Result<
        crate::output::ListConnectorEntitiesOutput,
        crate::error::ListConnectorEntitiesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_connector_entities_error(response)
        } else {
            crate::operation_deser::parse_list_connector_entities_response(response)
        }
    }
}

/// <p> Lists all of the flows associated with your account. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFlows {
    _private: (),
}
impl ListFlows {
    /// Creates a new builder-style object to manufacture [`ListFlowsInput`](crate::input::ListFlowsInput)
    pub fn builder() -> crate::input::list_flows_input::Builder {
        crate::input::list_flows_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFlows {
    type Output = std::result::Result<crate::output::ListFlowsOutput, crate::error::ListFlowsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_flows_error(response)
        } else {
            crate::operation_deser::parse_list_flows_response(response)
        }
    }
}

/// <p> Retrieves the tags that are associated with a specified flow. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p> Activates an existing flow. For on-demand flows, this operation runs the flow
/// immediately. For schedule and event-triggered flows, this operation activates the flow. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartFlow {
    _private: (),
}
impl StartFlow {
    /// Creates a new builder-style object to manufacture [`StartFlowInput`](crate::input::StartFlowInput)
    pub fn builder() -> crate::input::start_flow_input::Builder {
        crate::input::start_flow_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartFlow {
    type Output = std::result::Result<crate::output::StartFlowOutput, crate::error::StartFlowError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_flow_error(response)
        } else {
            crate::operation_deser::parse_start_flow_response(response)
        }
    }
}

/// <p> Deactivates the existing flow. For on-demand flows, this operation returns an
/// <code>unsupportedOperationException</code> error message. For schedule and event-triggered
/// flows, this operation deactivates the flow. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopFlow {
    _private: (),
}
impl StopFlow {
    /// Creates a new builder-style object to manufacture [`StopFlowInput`](crate::input::StopFlowInput)
    pub fn builder() -> crate::input::stop_flow_input::Builder {
        crate::input::stop_flow_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopFlow {
    type Output = std::result::Result<crate::output::StopFlowOutput, crate::error::StopFlowError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_flow_error(response)
        } else {
            crate::operation_deser::parse_stop_flow_response(response)
        }
    }
}

/// <p> Applies a tag to the specified flow. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p> Removes a tag from the specified flow. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p> Updates a given connector profile associated with your account. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateConnectorProfile {
    _private: (),
}
impl UpdateConnectorProfile {
    /// Creates a new builder-style object to manufacture [`UpdateConnectorProfileInput`](crate::input::UpdateConnectorProfileInput)
    pub fn builder() -> crate::input::update_connector_profile_input::Builder {
        crate::input::update_connector_profile_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateConnectorProfile {
    type Output = std::result::Result<
        crate::output::UpdateConnectorProfileOutput,
        crate::error::UpdateConnectorProfileError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_connector_profile_error(response)
        } else {
            crate::operation_deser::parse_update_connector_profile_response(response)
        }
    }
}

/// <p> Updates an existing flow. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateFlow {
    _private: (),
}
impl UpdateFlow {
    /// Creates a new builder-style object to manufacture [`UpdateFlowInput`](crate::input::UpdateFlowInput)
    pub fn builder() -> crate::input::update_flow_input::Builder {
        crate::input::update_flow_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateFlow {
    type Output =
        std::result::Result<crate::output::UpdateFlowOutput, crate::error::UpdateFlowError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_flow_error(response)
        } else {
            crate::operation_deser::parse_update_flow_response(response)
        }
    }
}
