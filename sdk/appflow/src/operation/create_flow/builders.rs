// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_flow::_create_flow_output::CreateFlowOutputBuilder;

pub use crate::operation::create_flow::_create_flow_input::CreateFlowInputBuilder;

impl CreateFlowInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_flow::CreateFlowOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_flow::CreateFlowError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_flow();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateFlow`.
///
/// <p> Enables your application to create a new flow using Amazon AppFlow. You must create a connector profile before calling this API. Please note that the Request Syntax below shows syntax for multiple destinations, however, you can only transfer data to one item in this list at a time. Amazon AppFlow does not currently support flows to multiple destinations at once. </p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateFlowFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_flow::builders::CreateFlowInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_flow::CreateFlowOutput,
        crate::operation::create_flow::CreateFlowError,
    > for CreateFlowFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_flow::CreateFlowOutput,
            crate::operation::create_flow::CreateFlowError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateFlowFluentBuilder {
    /// Creates a new `CreateFlow`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateFlow as a reference.
    pub fn as_input(&self) -> &crate::operation::create_flow::builders::CreateFlowInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_flow::CreateFlowOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_flow::CreateFlowError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_flow::CreateFlow::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_flow::CreateFlow::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_flow::CreateFlowOutput,
        crate::operation::create_flow::CreateFlowError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p> The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only. </p>
    pub fn flow_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.flow_name(input.into());
        self
    }
    /// <p> The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only. </p>
    pub fn set_flow_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_flow_name(input);
        self
    }
    /// <p> The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only. </p>
    pub fn get_flow_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_flow_name()
    }
    /// <p> A description of the flow you want to create. </p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.description(input.into());
        self
    }
    /// <p> A description of the flow you want to create. </p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_description(input);
        self
    }
    /// <p> A description of the flow you want to create. </p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_description()
    }
    /// <p> The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key. </p>
    pub fn kms_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.kms_arn(input.into());
        self
    }
    /// <p> The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key. </p>
    pub fn set_kms_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_kms_arn(input);
        self
    }
    /// <p> The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key. </p>
    pub fn get_kms_arn(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_kms_arn()
    }
    /// <p> The trigger settings that determine how and when the flow runs. </p>
    pub fn trigger_config(mut self, input: crate::types::TriggerConfig) -> Self {
        self.inner = self.inner.trigger_config(input);
        self
    }
    /// <p> The trigger settings that determine how and when the flow runs. </p>
    pub fn set_trigger_config(mut self, input: ::std::option::Option<crate::types::TriggerConfig>) -> Self {
        self.inner = self.inner.set_trigger_config(input);
        self
    }
    /// <p> The trigger settings that determine how and when the flow runs. </p>
    pub fn get_trigger_config(&self) -> &::std::option::Option<crate::types::TriggerConfig> {
        self.inner.get_trigger_config()
    }
    /// <p> The configuration that controls how Amazon AppFlow retrieves data from the source connector. </p>
    pub fn source_flow_config(mut self, input: crate::types::SourceFlowConfig) -> Self {
        self.inner = self.inner.source_flow_config(input);
        self
    }
    /// <p> The configuration that controls how Amazon AppFlow retrieves data from the source connector. </p>
    pub fn set_source_flow_config(mut self, input: ::std::option::Option<crate::types::SourceFlowConfig>) -> Self {
        self.inner = self.inner.set_source_flow_config(input);
        self
    }
    /// <p> The configuration that controls how Amazon AppFlow retrieves data from the source connector. </p>
    pub fn get_source_flow_config(&self) -> &::std::option::Option<crate::types::SourceFlowConfig> {
        self.inner.get_source_flow_config()
    }
    /// Appends an item to `destinationFlowConfigList`.
    ///
    /// To override the contents of this collection use [`set_destination_flow_config_list`](Self::set_destination_flow_config_list).
    ///
    /// <p> The configuration that controls how Amazon AppFlow places data in the destination connector. </p>
    pub fn destination_flow_config_list(mut self, input: crate::types::DestinationFlowConfig) -> Self {
        self.inner = self.inner.destination_flow_config_list(input);
        self
    }
    /// <p> The configuration that controls how Amazon AppFlow places data in the destination connector. </p>
    pub fn set_destination_flow_config_list(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::DestinationFlowConfig>>) -> Self {
        self.inner = self.inner.set_destination_flow_config_list(input);
        self
    }
    /// <p> The configuration that controls how Amazon AppFlow places data in the destination connector. </p>
    pub fn get_destination_flow_config_list(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::DestinationFlowConfig>> {
        self.inner.get_destination_flow_config_list()
    }
    /// Appends an item to `tasks`.
    ///
    /// To override the contents of this collection use [`set_tasks`](Self::set_tasks).
    ///
    /// <p> A list of tasks that Amazon AppFlow performs while transferring the data in the flow run. </p>
    pub fn tasks(mut self, input: crate::types::Task) -> Self {
        self.inner = self.inner.tasks(input);
        self
    }
    /// <p> A list of tasks that Amazon AppFlow performs while transferring the data in the flow run. </p>
    pub fn set_tasks(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Task>>) -> Self {
        self.inner = self.inner.set_tasks(input);
        self
    }
    /// <p> A list of tasks that Amazon AppFlow performs while transferring the data in the flow run. </p>
    pub fn get_tasks(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Task>> {
        self.inner.get_tasks()
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p> The tags used to organize, track, or control access for your flow. </p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.tags(k.into(), v.into());
        self
    }
    /// <p> The tags used to organize, track, or control access for your flow. </p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.inner = self.inner.set_tags(input);
        self
    }
    /// <p> The tags used to organize, track, or control access for your flow. </p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.inner.get_tags()
    }
    /// <p>Specifies the configuration that Amazon AppFlow uses when it catalogs the data that's transferred by the associated flow. When Amazon AppFlow catalogs the data from a flow, it stores metadata in a data catalog.</p>
    pub fn metadata_catalog_config(mut self, input: crate::types::MetadataCatalogConfig) -> Self {
        self.inner = self.inner.metadata_catalog_config(input);
        self
    }
    /// <p>Specifies the configuration that Amazon AppFlow uses when it catalogs the data that's transferred by the associated flow. When Amazon AppFlow catalogs the data from a flow, it stores metadata in a data catalog.</p>
    pub fn set_metadata_catalog_config(mut self, input: ::std::option::Option<crate::types::MetadataCatalogConfig>) -> Self {
        self.inner = self.inner.set_metadata_catalog_config(input);
        self
    }
    /// <p>Specifies the configuration that Amazon AppFlow uses when it catalogs the data that's transferred by the associated flow. When Amazon AppFlow catalogs the data from a flow, it stores metadata in a data catalog.</p>
    pub fn get_metadata_catalog_config(&self) -> &::std::option::Option<crate::types::MetadataCatalogConfig> {
        self.inner.get_metadata_catalog_config()
    }
    /// <p>The <code>clientToken</code> parameter is an idempotency token. It ensures that your <code>CreateFlow</code> request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same <code>clientToken</code> parameter value.</p>
    /// <p>If you omit a <code>clientToken</code> value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases.</p>
    /// <p>If you specify input parameters that differ from your first request, an error occurs. If you use a different value for <code>clientToken</code>, Amazon AppFlow considers it a new call to <code>CreateFlow</code>. The token is active for 8 hours.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.client_token(input.into());
        self
    }
    /// <p>The <code>clientToken</code> parameter is an idempotency token. It ensures that your <code>CreateFlow</code> request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same <code>clientToken</code> parameter value.</p>
    /// <p>If you omit a <code>clientToken</code> value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases.</p>
    /// <p>If you specify input parameters that differ from your first request, an error occurs. If you use a different value for <code>clientToken</code>, Amazon AppFlow considers it a new call to <code>CreateFlow</code>. The token is active for 8 hours.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_client_token(input);
        self
    }
    /// <p>The <code>clientToken</code> parameter is an idempotency token. It ensures that your <code>CreateFlow</code> request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same <code>clientToken</code> parameter value.</p>
    /// <p>If you omit a <code>clientToken</code> value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases.</p>
    /// <p>If you specify input parameters that differ from your first request, an error occurs. If you use a different value for <code>clientToken</code>, Amazon AppFlow considers it a new call to <code>CreateFlow</code>. The token is active for 8 hours.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_client_token()
    }
}
