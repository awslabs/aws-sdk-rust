// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`DescribeReportCreationInput`](crate::input::DescribeReportCreationInput)
pub mod describe_report_creation_input {
    /// A builder for [`DescribeReportCreationInput`](crate::input::DescribeReportCreationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DescribeReportCreationInput`](crate::input::DescribeReportCreationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeReportCreationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeReportCreationInput {})
        }
    }
}
#[doc(hidden)]
pub type DescribeReportCreationInputOperationOutputAlias = crate::operation::DescribeReportCreation;
#[doc(hidden)]
pub type DescribeReportCreationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeReportCreationInput {
    /// Consumes the builder and constructs an Operation<[`DescribeReportCreation`](crate::operation::DescribeReportCreation)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeReportCreation,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_describe_report_creation(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeReportCreation::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeReportCreation",
                "resourcegroupstaggingapi",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "ResourceGroupsTaggingAPI_20170126.DescribeReportCreation",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeReportCreationInput`](crate::input::DescribeReportCreationInput)
    pub fn builder() -> crate::input::describe_report_creation_input::Builder {
        crate::input::describe_report_creation_input::Builder::default()
    }
}

/// See [`GetComplianceSummaryInput`](crate::input::GetComplianceSummaryInput)
pub mod get_compliance_summary_input {
    /// A builder for [`GetComplianceSummaryInput`](crate::input::GetComplianceSummaryInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_id_filters: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) region_filters: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) resource_type_filters: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tag_key_filters: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) group_by: std::option::Option<std::vec::Vec<crate::model::GroupByAttribute>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) pagination_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn target_id_filters(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_id_filters.unwrap_or_default();
            v.push(input.into());
            self.target_id_filters = Some(v);
            self
        }
        pub fn set_target_id_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_id_filters = input;
            self
        }
        pub fn region_filters(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.region_filters.unwrap_or_default();
            v.push(input.into());
            self.region_filters = Some(v);
            self
        }
        pub fn set_region_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.region_filters = input;
            self
        }
        pub fn resource_type_filters(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.resource_type_filters.unwrap_or_default();
            v.push(input.into());
            self.resource_type_filters = Some(v);
            self
        }
        pub fn set_resource_type_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.resource_type_filters = input;
            self
        }
        pub fn tag_key_filters(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_key_filters.unwrap_or_default();
            v.push(input.into());
            self.tag_key_filters = Some(v);
            self
        }
        pub fn set_tag_key_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_key_filters = input;
            self
        }
        pub fn group_by(mut self, input: impl Into<crate::model::GroupByAttribute>) -> Self {
            let mut v = self.group_by.unwrap_or_default();
            v.push(input.into());
            self.group_by = Some(v);
            self
        }
        pub fn set_group_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupByAttribute>>,
        ) -> Self {
            self.group_by = input;
            self
        }
        /// <p>Specifies the maximum number of results to be returned in each page. A
        /// query can return fewer than this maximum, even if there are more results still to return. You
        /// should always check the <code>PaginationToken</code> response value to see if there are more
        /// results. You can specify a minimum of 1 and a maximum value of 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Specifies a <code>PaginationToken</code> response value from a
        /// previous request to indicate that you want the next page of results. Leave this parameter empty
        /// in your initial request.</p>
        pub fn pagination_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.pagination_token = Some(input.into());
            self
        }
        pub fn set_pagination_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pagination_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetComplianceSummaryInput`](crate::input::GetComplianceSummaryInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetComplianceSummaryInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetComplianceSummaryInput {
                target_id_filters: self.target_id_filters,
                region_filters: self.region_filters,
                resource_type_filters: self.resource_type_filters,
                tag_key_filters: self.tag_key_filters,
                group_by: self.group_by,
                max_results: self.max_results,
                pagination_token: self.pagination_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetComplianceSummaryInputOperationOutputAlias = crate::operation::GetComplianceSummary;
#[doc(hidden)]
pub type GetComplianceSummaryInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetComplianceSummaryInput {
    /// Consumes the builder and constructs an Operation<[`GetComplianceSummary`](crate::operation::GetComplianceSummary)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetComplianceSummary,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_compliance_summary(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetComplianceSummary::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetComplianceSummary",
                "resourcegroupstaggingapi",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "ResourceGroupsTaggingAPI_20170126.GetComplianceSummary",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetComplianceSummaryInput`](crate::input::GetComplianceSummaryInput)
    pub fn builder() -> crate::input::get_compliance_summary_input::Builder {
        crate::input::get_compliance_summary_input::Builder::default()
    }
}

/// See [`GetResourcesInput`](crate::input::GetResourcesInput)
pub mod get_resources_input {
    /// A builder for [`GetResourcesInput`](crate::input::GetResourcesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pagination_token: std::option::Option<std::string::String>,
        pub(crate) tag_filters: std::option::Option<std::vec::Vec<crate::model::TagFilter>>,
        pub(crate) resources_per_page: std::option::Option<i32>,
        pub(crate) tags_per_page: std::option::Option<i32>,
        pub(crate) resource_type_filters: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) include_compliance_details: std::option::Option<bool>,
        pub(crate) exclude_compliant_resources: std::option::Option<bool>,
        pub(crate) resource_arn_list: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Specifies a <code>PaginationToken</code> response value from a
        /// previous request to indicate that you want the next page of results. Leave this parameter empty
        /// in your initial request.</p>
        pub fn pagination_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.pagination_token = Some(input.into());
            self
        }
        pub fn set_pagination_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pagination_token = input;
            self
        }
        pub fn tag_filters(mut self, input: impl Into<crate::model::TagFilter>) -> Self {
            let mut v = self.tag_filters.unwrap_or_default();
            v.push(input.into());
            self.tag_filters = Some(v);
            self
        }
        pub fn set_tag_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagFilter>>,
        ) -> Self {
            self.tag_filters = input;
            self
        }
        /// <p>Specifies the maximum number of results to be returned in each page. A
        /// query can return fewer than this maximum, even if there are more results still to return. You
        /// should always check the <code>PaginationToken</code> response value to see if there are more
        /// results. You can specify a minimum of 1 and a maximum value of 100.</p>
        pub fn resources_per_page(mut self, input: i32) -> Self {
            self.resources_per_page = Some(input);
            self
        }
        pub fn set_resources_per_page(mut self, input: std::option::Option<i32>) -> Self {
            self.resources_per_page = input;
            self
        }
        /// <p>AWS recommends using <code>ResourcesPerPage</code> instead of this parameter.</p>
        /// <p>A limit that restricts the number of tags (key and value pairs) returned by
        /// <code>GetResources</code> in paginated output. A resource with no tags is counted as
        /// having one tag (one key and value pair).</p>
        /// <p>
        /// <code>GetResources</code> does not split a resource and its associated tags across
        /// pages. If the specified <code>TagsPerPage</code> would cause such a break, a
        /// <code>PaginationToken</code> is returned in place of the affected resource and its
        /// tags. Use that token in another request to get the remaining data. For example, if you
        /// specify a <code>TagsPerPage</code> of <code>100</code> and the account has 22 resources
        /// with 10 tags each (meaning that each resource has 10 key and value pairs), the output
        /// will consist of three pages. The first page displays the first 10 resources, each with
        /// its 10 tags. The second page displays the next 10 resources, each with its 10 tags. The
        /// third page displays the remaining 2 resources, each with its 10 tags.</p>
        /// <p>You can set <code>TagsPerPage</code> to a minimum of 100 items up to a maximum of 500
        /// items.</p>
        pub fn tags_per_page(mut self, input: i32) -> Self {
            self.tags_per_page = Some(input);
            self
        }
        pub fn set_tags_per_page(mut self, input: std::option::Option<i32>) -> Self {
            self.tags_per_page = input;
            self
        }
        pub fn resource_type_filters(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.resource_type_filters.unwrap_or_default();
            v.push(input.into());
            self.resource_type_filters = Some(v);
            self
        }
        pub fn set_resource_type_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.resource_type_filters = input;
            self
        }
        /// <p>Specifies whether to include details regarding the compliance with the effective tag
        /// policy. Set this to <code>true</code> to determine whether resources are compliant with
        /// the tag policy and to get details.</p>
        pub fn include_compliance_details(mut self, input: bool) -> Self {
            self.include_compliance_details = Some(input);
            self
        }
        pub fn set_include_compliance_details(mut self, input: std::option::Option<bool>) -> Self {
            self.include_compliance_details = input;
            self
        }
        /// <p>Specifies whether to exclude resources that are compliant with the tag policy. Set
        /// this to <code>true</code> if you are interested in retrieving information on
        /// noncompliant resources only.</p>
        /// <p>You can use this parameter only if the <code>IncludeComplianceDetails</code> parameter
        /// is also set to <code>true</code>.</p>
        pub fn exclude_compliant_resources(mut self, input: bool) -> Self {
            self.exclude_compliant_resources = Some(input);
            self
        }
        pub fn set_exclude_compliant_resources(mut self, input: std::option::Option<bool>) -> Self {
            self.exclude_compliant_resources = input;
            self
        }
        pub fn resource_arn_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.resource_arn_list.unwrap_or_default();
            v.push(input.into());
            self.resource_arn_list = Some(v);
            self
        }
        pub fn set_resource_arn_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.resource_arn_list = input;
            self
        }
        /// Consumes the builder and constructs a [`GetResourcesInput`](crate::input::GetResourcesInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetResourcesInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetResourcesInput {
                pagination_token: self.pagination_token,
                tag_filters: self.tag_filters,
                resources_per_page: self.resources_per_page,
                tags_per_page: self.tags_per_page,
                resource_type_filters: self.resource_type_filters,
                include_compliance_details: self.include_compliance_details,
                exclude_compliant_resources: self.exclude_compliant_resources,
                resource_arn_list: self.resource_arn_list,
            })
        }
    }
}
#[doc(hidden)]
pub type GetResourcesInputOperationOutputAlias = crate::operation::GetResources;
#[doc(hidden)]
pub type GetResourcesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetResourcesInput {
    /// Consumes the builder and constructs an Operation<[`GetResources`](crate::operation::GetResources)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetResources,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_get_resources(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetResources::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetResources",
                "resourcegroupstaggingapi",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "ResourceGroupsTaggingAPI_20170126.GetResources",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetResourcesInput`](crate::input::GetResourcesInput)
    pub fn builder() -> crate::input::get_resources_input::Builder {
        crate::input::get_resources_input::Builder::default()
    }
}

/// See [`GetTagKeysInput`](crate::input::GetTagKeysInput)
pub mod get_tag_keys_input {
    /// A builder for [`GetTagKeysInput`](crate::input::GetTagKeysInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pagination_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies a <code>PaginationToken</code> response value from a
        /// previous request to indicate that you want the next page of results. Leave this parameter empty
        /// in your initial request.</p>
        pub fn pagination_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.pagination_token = Some(input.into());
            self
        }
        pub fn set_pagination_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pagination_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetTagKeysInput`](crate::input::GetTagKeysInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetTagKeysInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetTagKeysInput {
                pagination_token: self.pagination_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetTagKeysInputOperationOutputAlias = crate::operation::GetTagKeys;
#[doc(hidden)]
pub type GetTagKeysInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetTagKeysInput {
    /// Consumes the builder and constructs an Operation<[`GetTagKeys`](crate::operation::GetTagKeys)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetTagKeys,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_get_tag_keys(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetTagKeys::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetTagKeys",
                "resourcegroupstaggingapi",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "ResourceGroupsTaggingAPI_20170126.GetTagKeys",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetTagKeysInput`](crate::input::GetTagKeysInput)
    pub fn builder() -> crate::input::get_tag_keys_input::Builder {
        crate::input::get_tag_keys_input::Builder::default()
    }
}

/// See [`GetTagValuesInput`](crate::input::GetTagValuesInput)
pub mod get_tag_values_input {
    /// A builder for [`GetTagValuesInput`](crate::input::GetTagValuesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pagination_token: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies a <code>PaginationToken</code> response value from a
        /// previous request to indicate that you want the next page of results. Leave this parameter empty
        /// in your initial request.</p>
        pub fn pagination_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.pagination_token = Some(input.into());
            self
        }
        pub fn set_pagination_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pagination_token = input;
            self
        }
        /// <p>Specifies the tag key for which you want to list all existing values that are
        /// currently used in the specified AWS Region for the calling AWS account.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// Consumes the builder and constructs a [`GetTagValuesInput`](crate::input::GetTagValuesInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetTagValuesInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetTagValuesInput {
                pagination_token: self.pagination_token,
                key: self.key,
            })
        }
    }
}
#[doc(hidden)]
pub type GetTagValuesInputOperationOutputAlias = crate::operation::GetTagValues;
#[doc(hidden)]
pub type GetTagValuesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetTagValuesInput {
    /// Consumes the builder and constructs an Operation<[`GetTagValues`](crate::operation::GetTagValues)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetTagValues,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_get_tag_values(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetTagValues::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetTagValues",
                "resourcegroupstaggingapi",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "ResourceGroupsTaggingAPI_20170126.GetTagValues",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetTagValuesInput`](crate::input::GetTagValuesInput)
    pub fn builder() -> crate::input::get_tag_values_input::Builder {
        crate::input::get_tag_values_input::Builder::default()
    }
}

/// See [`StartReportCreationInput`](crate::input::StartReportCreationInput)
pub mod start_report_creation_input {
    /// A builder for [`StartReportCreationInput`](crate::input::StartReportCreationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket where the report will be stored; for example:</p>
        /// <p>
        /// <code>awsexamplebucket</code>
        /// </p>
        /// <p>For more information on S3 bucket requirements, including an example bucket policy,
        /// see the example S3 bucket policy on this page.</p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(input.into());
            self
        }
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = input;
            self
        }
        /// Consumes the builder and constructs a [`StartReportCreationInput`](crate::input::StartReportCreationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartReportCreationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartReportCreationInput {
                s3_bucket: self.s3_bucket,
            })
        }
    }
}
#[doc(hidden)]
pub type StartReportCreationInputOperationOutputAlias = crate::operation::StartReportCreation;
#[doc(hidden)]
pub type StartReportCreationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartReportCreationInput {
    /// Consumes the builder and constructs an Operation<[`StartReportCreation`](crate::operation::StartReportCreation)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::StartReportCreation,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_start_report_creation(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::StartReportCreation::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "StartReportCreation",
                "resourcegroupstaggingapi",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "ResourceGroupsTaggingAPI_20170126.StartReportCreation",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartReportCreationInput`](crate::input::StartReportCreationInput)
    pub fn builder() -> crate::input::start_report_creation_input::Builder {
        crate::input::start_report_creation_input::Builder::default()
    }
}

/// See [`TagResourcesInput`](crate::input::TagResourcesInput)
pub mod tag_resources_input {
    /// A builder for [`TagResourcesInput`](crate::input::TagResourcesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        pub fn resource_arn_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.resource_arn_list.unwrap_or_default();
            v.push(input.into());
            self.resource_arn_list = Some(v);
            self
        }
        pub fn set_resource_arn_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.resource_arn_list = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourcesInput`](crate::input::TagResourcesInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::TagResourcesInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::TagResourcesInput {
                resource_arn_list: self.resource_arn_list,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagResourcesInputOperationOutputAlias = crate::operation::TagResources;
#[doc(hidden)]
pub type TagResourcesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagResourcesInput {
    /// Consumes the builder and constructs an Operation<[`TagResources`](crate::operation::TagResources)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::TagResources,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_tag_resources(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::TagResources::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "TagResources",
                "resourcegroupstaggingapi",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "ResourceGroupsTaggingAPI_20170126.TagResources",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagResourcesInput`](crate::input::TagResourcesInput)
    pub fn builder() -> crate::input::tag_resources_input::Builder {
        crate::input::tag_resources_input::Builder::default()
    }
}

/// See [`UntagResourcesInput`](crate::input::UntagResourcesInput)
pub mod untag_resources_input {
    /// A builder for [`UntagResourcesInput`](crate::input::UntagResourcesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        pub fn resource_arn_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.resource_arn_list.unwrap_or_default();
            v.push(input.into());
            self.resource_arn_list = Some(v);
            self
        }
        pub fn set_resource_arn_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.resource_arn_list = input;
            self
        }
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourcesInput`](crate::input::UntagResourcesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UntagResourcesInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UntagResourcesInput {
                resource_arn_list: self.resource_arn_list,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagResourcesInputOperationOutputAlias = crate::operation::UntagResources;
#[doc(hidden)]
pub type UntagResourcesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagResourcesInput {
    /// Consumes the builder and constructs an Operation<[`UntagResources`](crate::operation::UntagResources)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UntagResources,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_untag_resources(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UntagResources::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UntagResources",
                "resourcegroupstaggingapi",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "content-type",
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            "x-amz-target",
            "ResourceGroupsTaggingAPI_20170126.UntagResources",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagResourcesInput`](crate::input::UntagResourcesInput)
    pub fn builder() -> crate::input::untag_resources_input::Builder {
        crate::input::untag_resources_input::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourcesInput {
    /// <p>Specifies a list of ARNs of the resources that you want to remove tags from.</p>
    /// <p>An ARN (Amazon Resource Name) uniquely identifies a resource. For more information,
    /// see <a href="http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon
    /// Resource Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS
    /// General Reference</i>.</p>
    pub resource_arn_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies a list of tag keys that you want to remove from the specified
    /// resources.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UntagResourcesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourcesInput");
        formatter.field("resource_arn_list", &self.resource_arn_list);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourcesInput {
    /// <p>Specifies the list of ARNs of the resources that you want to apply tags to.</p>
    /// <p>An ARN (Amazon Resource Name) uniquely identifies a resource. For more information,
    /// see <a href="http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon
    /// Resource Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS
    /// General Reference</i>.</p>
    pub resource_arn_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies a list of tags that you want to add to the specified resources. A tag
    /// consists of a key and a value that you define.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for TagResourcesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourcesInput");
        formatter.field("resource_arn_list", &self.resource_arn_list);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartReportCreationInput {
    /// <p>The name of the Amazon S3 bucket where the report will be stored; for example:</p>
    /// <p>
    /// <code>awsexamplebucket</code>
    /// </p>
    /// <p>For more information on S3 bucket requirements, including an example bucket policy,
    /// see the example S3 bucket policy on this page.</p>
    pub s3_bucket: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartReportCreationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartReportCreationInput");
        formatter.field("s3_bucket", &self.s3_bucket);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetTagValuesInput {
    /// <p>Specifies a <code>PaginationToken</code> response value from a
    /// previous request to indicate that you want the next page of results. Leave this parameter empty
    /// in your initial request.</p>
    pub pagination_token: std::option::Option<std::string::String>,
    /// <p>Specifies the tag key for which you want to list all existing values that are
    /// currently used in the specified AWS Region for the calling AWS account.</p>
    pub key: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetTagValuesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetTagValuesInput");
        formatter.field("pagination_token", &self.pagination_token);
        formatter.field("key", &self.key);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetTagKeysInput {
    /// <p>Specifies a <code>PaginationToken</code> response value from a
    /// previous request to indicate that you want the next page of results. Leave this parameter empty
    /// in your initial request.</p>
    pub pagination_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetTagKeysInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetTagKeysInput");
        formatter.field("pagination_token", &self.pagination_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetResourcesInput {
    /// <p>Specifies a <code>PaginationToken</code> response value from a
    /// previous request to indicate that you want the next page of results. Leave this parameter empty
    /// in your initial request.</p>
    pub pagination_token: std::option::Option<std::string::String>,
    /// <p>Specifies a list of TagFilters (keys and values) to restrict the output to only those
    /// resources that have the specified tag and, if included, the specified value. Each
    /// <code>TagFilter</code> must contain a key with values optional. A request can
    /// include up to 50 keys, and each key can include up to 20 values. </p>
    /// <p>Note the following when deciding how to use TagFilters:</p>
    /// <ul>
    /// <li>
    /// <p>If you <i>don't</i> specify a <code>TagFilter</code>, the
    /// response includes all resources that are currently tagged or ever had a tag.
    /// Resources that currently don't have tags are shown with an empty tag set, like
    /// this: <code>"Tags": []</code>.</p>
    /// </li>
    /// <li>
    /// <p>If you specify more than one filter in a single request, the response returns
    /// only those resources that satisfy all filters.</p>
    /// </li>
    /// <li>
    /// <p>If you specify a filter that contains more than one value for a key, the
    /// response returns resources that match any of the specified values for that
    /// key.</p>
    /// </li>
    /// <li>
    /// <p>If you don't specify any values for a key, the response returns resources that
    /// are tagged with that key and any or no value.</p>
    /// <p>For example, for the following filters: <code>filter1= {keyA,{value1}}</code>,
    /// <code>filter2={keyB,{value2,value3,value4}}</code>, <code>filter3=
    /// {keyC}</code>:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>GetResources({filter1})</code> returns resources tagged with
    /// <code>key1=value1</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GetResources({filter2})</code> returns resources tagged with
    /// <code>key2=value2</code> or <code>key2=value3</code> or
    /// <code>key2=value4</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GetResources({filter3})</code> returns resources tagged with any
    /// tag with the key <code>key3</code>, and with any or no value</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GetResources({filter1,filter2,filter3})</code> returns resources
    /// tagged with <code>(key1=value1) and (key2=value2 or key2=value3 or
    /// key2=value4) and (key3, any or no value)</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// </ul>
    pub tag_filters: std::option::Option<std::vec::Vec<crate::model::TagFilter>>,
    /// <p>Specifies the maximum number of results to be returned in each page. A
    /// query can return fewer than this maximum, even if there are more results still to return. You
    /// should always check the <code>PaginationToken</code> response value to see if there are more
    /// results. You can specify a minimum of 1 and a maximum value of 100.</p>
    pub resources_per_page: std::option::Option<i32>,
    /// <p>AWS recommends using <code>ResourcesPerPage</code> instead of this parameter.</p>
    /// <p>A limit that restricts the number of tags (key and value pairs) returned by
    /// <code>GetResources</code> in paginated output. A resource with no tags is counted as
    /// having one tag (one key and value pair).</p>
    /// <p>
    /// <code>GetResources</code> does not split a resource and its associated tags across
    /// pages. If the specified <code>TagsPerPage</code> would cause such a break, a
    /// <code>PaginationToken</code> is returned in place of the affected resource and its
    /// tags. Use that token in another request to get the remaining data. For example, if you
    /// specify a <code>TagsPerPage</code> of <code>100</code> and the account has 22 resources
    /// with 10 tags each (meaning that each resource has 10 key and value pairs), the output
    /// will consist of three pages. The first page displays the first 10 resources, each with
    /// its 10 tags. The second page displays the next 10 resources, each with its 10 tags. The
    /// third page displays the remaining 2 resources, each with its 10 tags.</p>
    /// <p>You can set <code>TagsPerPage</code> to a minimum of 100 items up to a maximum of 500
    /// items.</p>
    pub tags_per_page: std::option::Option<i32>,
    /// <p>Specifies the resource types that you want included in the response. The format of
    /// each resource type is <code>service[:resourceType]</code>. For example, specifying a
    /// resource type of <code>ec2</code> returns all Amazon EC2 resources (which includes EC2
    /// instances). Specifying a resource type of <code>ec2:instance</code> returns only EC2
    /// instances. </p>
    /// <p>The string for each service name and resource type is the same as that embedded in a
    /// resource's Amazon Resource Name (ARN). Consult the <i>AWS General
    /// Reference</i> for the following:</p>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and
    /// AWS Service Namespaces</a>.</p>
    /// <p>You can specify multiple resource types by using an array. The array can include up to
    /// 100 items. Note that the length constraint requirement applies to each resource type
    /// filter. </p>
    pub resource_type_filters: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies whether to include details regarding the compliance with the effective tag
    /// policy. Set this to <code>true</code> to determine whether resources are compliant with
    /// the tag policy and to get details.</p>
    pub include_compliance_details: std::option::Option<bool>,
    /// <p>Specifies whether to exclude resources that are compliant with the tag policy. Set
    /// this to <code>true</code> if you are interested in retrieving information on
    /// noncompliant resources only.</p>
    /// <p>You can use this parameter only if the <code>IncludeComplianceDetails</code> parameter
    /// is also set to <code>true</code>.</p>
    pub exclude_compliant_resources: std::option::Option<bool>,
    /// <p>Specifies a list of ARNs of resources for which you want to retrieve tag data. You
    /// can't specify both this parameter and any of the pagination parameters
    /// (<code>ResourcesPerPage</code>, <code>TagsPerPage</code>,
    /// <code>PaginationToken</code>) in the same request. If you specify both, you get an
    /// <code>Invalid Parameter</code> exception.</p>
    /// <p>If a resource specified by this parameter doesn't exist, it doesn't generate an error;
    /// it simply isn't included in the response.</p>
    /// <p>An ARN (Amazon Resource Name) uniquely identifies a resource. For more information,
    /// see <a href="http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon
    /// Resource Names (ARNs) and AWS Service Namespaces</a> in the <i>AWS
    /// General Reference</i>.</p>
    pub resource_arn_list: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for GetResourcesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetResourcesInput");
        formatter.field("pagination_token", &self.pagination_token);
        formatter.field("tag_filters", &self.tag_filters);
        formatter.field("resources_per_page", &self.resources_per_page);
        formatter.field("tags_per_page", &self.tags_per_page);
        formatter.field("resource_type_filters", &self.resource_type_filters);
        formatter.field(
            "include_compliance_details",
            &self.include_compliance_details,
        );
        formatter.field(
            "exclude_compliant_resources",
            &self.exclude_compliant_resources,
        );
        formatter.field("resource_arn_list", &self.resource_arn_list);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetComplianceSummaryInput {
    /// <p>Specifies target identifiers (usually, specific account IDs) to limit the output by.
    /// If you use this parameter, the count of returned noncompliant resources includes only
    /// resources with the specified target IDs.</p>
    pub target_id_filters: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies a list of AWS Regions to limit the output by. If you use this parameter,
    /// the count of returned noncompliant resources includes only resources in the specified
    /// Regions.</p>
    pub region_filters: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies that you want the response to include information for only resources of the
    /// specified types. The format of each resource type is
    /// <code>service[:resourceType]</code>. For example, specifying a resource type of
    /// <code>ec2</code> returns all Amazon EC2 resources (which includes EC2 instances).
    /// Specifying a resource type of <code>ec2:instance</code> returns only EC2 instances. </p>
    /// <p>The string for each service name and resource type is the same as that embedded in a
    /// resource's Amazon Resource Name (ARN). Consult the <i>AWS General
    /// Reference</i> for the following:</p>
    /// <ul>
    /// <li>
    /// <p>For a list of service name strings, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces">AWS Service Namespaces</a>.</p>
    /// </li>
    /// <li>
    /// <p>For resource type strings, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arns-syntax">Example
    /// ARNs</a>.</p>
    /// </li>
    /// <li>
    /// <p>For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names
    /// (ARNs) and AWS Service Namespaces</a>.</p>
    /// </li>
    /// </ul>
    /// <p>You can specify multiple resource types by using a comma separated array. The array
    /// can include up to 100 items. Note that the length constraint requirement applies to each
    /// resource type filter. </p>
    pub resource_type_filters: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies that you want the response to include information for only resources that
    /// have tags with the specified tag keys. If you use this parameter, the count of returned
    /// noncompliant resources includes only resources that have the specified tag keys.</p>
    pub tag_key_filters: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies a list of attributes to group the counts of noncompliant resources by. If
    /// supplied, the counts are sorted by those attributes.</p>
    pub group_by: std::option::Option<std::vec::Vec<crate::model::GroupByAttribute>>,
    /// <p>Specifies the maximum number of results to be returned in each page. A
    /// query can return fewer than this maximum, even if there are more results still to return. You
    /// should always check the <code>PaginationToken</code> response value to see if there are more
    /// results. You can specify a minimum of 1 and a maximum value of 100.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>Specifies a <code>PaginationToken</code> response value from a
    /// previous request to indicate that you want the next page of results. Leave this parameter empty
    /// in your initial request.</p>
    pub pagination_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetComplianceSummaryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetComplianceSummaryInput");
        formatter.field("target_id_filters", &self.target_id_filters);
        formatter.field("region_filters", &self.region_filters);
        formatter.field("resource_type_filters", &self.resource_type_filters);
        formatter.field("tag_key_filters", &self.tag_key_filters);
        formatter.field("group_by", &self.group_by);
        formatter.field("max_results", &self.max_results);
        formatter.field("pagination_token", &self.pagination_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeReportCreationInput {}
impl std::fmt::Debug for DescribeReportCreationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeReportCreationInput");
        formatter.finish()
    }
}
