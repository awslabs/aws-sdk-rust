// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Represents a complete policy resource within the AgentCore Policy system. Policies are ARN-able resources that contain Cedar policy statements and associated metadata for controlling agent behavior and access decisions. Each policy belongs to a policy engine and defines fine-grained authorization rules that are evaluated in real-time as agents interact with tools through Gateway. Policies use the Cedar policy language to specify who (principals based on OAuth claims like username, role, or scope) can perform what actions (tool calls) on which resources (Gateways), with optional conditions for attribute-based access control. Multiple policies can apply to a single request, with Cedar's forbid-wins semantics ensuring that security restrictions are never accidentally overridden.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct Policy {
    /// <p>The unique identifier for the policy. This system-generated identifier consists of the user name plus a 10-character generated suffix and serves as the primary key for policy operations.</p>
    pub policy_id: ::std::string::String,
    /// <p>The customer-assigned immutable name for the policy. This human-readable identifier must be unique within the account and cannot exceed 48 characters.</p>
    pub name: ::std::string::String,
    /// <p>The identifier of the policy engine that manages this policy. This establishes the policy engine context for policy evaluation and management.</p>
    pub policy_engine_id: ::std::string::String,
    /// <p>The Cedar policy statement that defines the access control rules. This contains the actual policy logic used for agent behavior control and access decisions.</p>
    pub definition: ::std::option::Option<crate::types::PolicyDefinition>,
    /// <p>A human-readable description of the policy's purpose and functionality. Limited to 4,096 characters, this helps administrators understand and manage the policy.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The timestamp when the policy was originally created. This is automatically set by the service and used for auditing and lifecycle management.</p>
    pub created_at: ::aws_smithy_types::DateTime,
    /// <p>The timestamp when the policy was last modified. This tracks the most recent changes to the policy configuration or metadata.</p>
    pub updated_at: ::aws_smithy_types::DateTime,
    /// <p>The Amazon Resource Name (ARN) of the policy. This globally unique identifier can be used for cross-service references and IAM policy statements.</p>
    pub policy_arn: ::std::string::String,
    /// <p>The current status of the policy.</p>
    pub status: crate::types::PolicyStatus,
    /// <p>Additional information about the policy status. This provides details about any failures or the current state of the policy lifecycle.</p>
    pub status_reasons: ::std::vec::Vec<::std::string::String>,
}
impl Policy {
    /// <p>The unique identifier for the policy. This system-generated identifier consists of the user name plus a 10-character generated suffix and serves as the primary key for policy operations.</p>
    pub fn policy_id(&self) -> &str {
        use std::ops::Deref;
        self.policy_id.deref()
    }
    /// <p>The customer-assigned immutable name for the policy. This human-readable identifier must be unique within the account and cannot exceed 48 characters.</p>
    pub fn name(&self) -> &str {
        use std::ops::Deref;
        self.name.deref()
    }
    /// <p>The identifier of the policy engine that manages this policy. This establishes the policy engine context for policy evaluation and management.</p>
    pub fn policy_engine_id(&self) -> &str {
        use std::ops::Deref;
        self.policy_engine_id.deref()
    }
    /// <p>The Cedar policy statement that defines the access control rules. This contains the actual policy logic used for agent behavior control and access decisions.</p>
    pub fn definition(&self) -> ::std::option::Option<&crate::types::PolicyDefinition> {
        self.definition.as_ref()
    }
    /// <p>A human-readable description of the policy's purpose and functionality. Limited to 4,096 characters, this helps administrators understand and manage the policy.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The timestamp when the policy was originally created. This is automatically set by the service and used for auditing and lifecycle management.</p>
    pub fn created_at(&self) -> &::aws_smithy_types::DateTime {
        &self.created_at
    }
    /// <p>The timestamp when the policy was last modified. This tracks the most recent changes to the policy configuration or metadata.</p>
    pub fn updated_at(&self) -> &::aws_smithy_types::DateTime {
        &self.updated_at
    }
    /// <p>The Amazon Resource Name (ARN) of the policy. This globally unique identifier can be used for cross-service references and IAM policy statements.</p>
    pub fn policy_arn(&self) -> &str {
        use std::ops::Deref;
        self.policy_arn.deref()
    }
    /// <p>The current status of the policy.</p>
    pub fn status(&self) -> &crate::types::PolicyStatus {
        &self.status
    }
    /// <p>Additional information about the policy status. This provides details about any failures or the current state of the policy lifecycle.</p>
    pub fn status_reasons(&self) -> &[::std::string::String] {
        use std::ops::Deref;
        self.status_reasons.deref()
    }
}
impl ::std::fmt::Debug for Policy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("Policy");
        formatter.field("policy_id", &self.policy_id);
        formatter.field("name", &self.name);
        formatter.field("policy_engine_id", &self.policy_engine_id);
        formatter.field("definition", &self.definition);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("created_at", &self.created_at);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("policy_arn", &self.policy_arn);
        formatter.field("status", &self.status);
        formatter.field("status_reasons", &self.status_reasons);
        formatter.finish()
    }
}
impl Policy {
    /// Creates a new builder-style object to manufacture [`Policy`](crate::types::Policy).
    pub fn builder() -> crate::types::builders::PolicyBuilder {
        crate::types::builders::PolicyBuilder::default()
    }
}

/// A builder for [`Policy`](crate::types::Policy).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct PolicyBuilder {
    pub(crate) policy_id: ::std::option::Option<::std::string::String>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) policy_engine_id: ::std::option::Option<::std::string::String>,
    pub(crate) definition: ::std::option::Option<crate::types::PolicyDefinition>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) updated_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) policy_arn: ::std::option::Option<::std::string::String>,
    pub(crate) status: ::std::option::Option<crate::types::PolicyStatus>,
    pub(crate) status_reasons: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}
impl PolicyBuilder {
    /// <p>The unique identifier for the policy. This system-generated identifier consists of the user name plus a 10-character generated suffix and serves as the primary key for policy operations.</p>
    /// This field is required.
    pub fn policy_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.policy_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier for the policy. This system-generated identifier consists of the user name plus a 10-character generated suffix and serves as the primary key for policy operations.</p>
    pub fn set_policy_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.policy_id = input;
        self
    }
    /// <p>The unique identifier for the policy. This system-generated identifier consists of the user name plus a 10-character generated suffix and serves as the primary key for policy operations.</p>
    pub fn get_policy_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.policy_id
    }
    /// <p>The customer-assigned immutable name for the policy. This human-readable identifier must be unique within the account and cannot exceed 48 characters.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The customer-assigned immutable name for the policy. This human-readable identifier must be unique within the account and cannot exceed 48 characters.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The customer-assigned immutable name for the policy. This human-readable identifier must be unique within the account and cannot exceed 48 characters.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The identifier of the policy engine that manages this policy. This establishes the policy engine context for policy evaluation and management.</p>
    /// This field is required.
    pub fn policy_engine_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.policy_engine_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier of the policy engine that manages this policy. This establishes the policy engine context for policy evaluation and management.</p>
    pub fn set_policy_engine_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.policy_engine_id = input;
        self
    }
    /// <p>The identifier of the policy engine that manages this policy. This establishes the policy engine context for policy evaluation and management.</p>
    pub fn get_policy_engine_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.policy_engine_id
    }
    /// <p>The Cedar policy statement that defines the access control rules. This contains the actual policy logic used for agent behavior control and access decisions.</p>
    /// This field is required.
    pub fn definition(mut self, input: crate::types::PolicyDefinition) -> Self {
        self.definition = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Cedar policy statement that defines the access control rules. This contains the actual policy logic used for agent behavior control and access decisions.</p>
    pub fn set_definition(mut self, input: ::std::option::Option<crate::types::PolicyDefinition>) -> Self {
        self.definition = input;
        self
    }
    /// <p>The Cedar policy statement that defines the access control rules. This contains the actual policy logic used for agent behavior control and access decisions.</p>
    pub fn get_definition(&self) -> &::std::option::Option<crate::types::PolicyDefinition> {
        &self.definition
    }
    /// <p>A human-readable description of the policy's purpose and functionality. Limited to 4,096 characters, this helps administrators understand and manage the policy.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A human-readable description of the policy's purpose and functionality. Limited to 4,096 characters, this helps administrators understand and manage the policy.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>A human-readable description of the policy's purpose and functionality. Limited to 4,096 characters, this helps administrators understand and manage the policy.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The timestamp when the policy was originally created. This is automatically set by the service and used for auditing and lifecycle management.</p>
    /// This field is required.
    pub fn created_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.created_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp when the policy was originally created. This is automatically set by the service and used for auditing and lifecycle management.</p>
    pub fn set_created_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.created_at = input;
        self
    }
    /// <p>The timestamp when the policy was originally created. This is automatically set by the service and used for auditing and lifecycle management.</p>
    pub fn get_created_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.created_at
    }
    /// <p>The timestamp when the policy was last modified. This tracks the most recent changes to the policy configuration or metadata.</p>
    /// This field is required.
    pub fn updated_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.updated_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp when the policy was last modified. This tracks the most recent changes to the policy configuration or metadata.</p>
    pub fn set_updated_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.updated_at = input;
        self
    }
    /// <p>The timestamp when the policy was last modified. This tracks the most recent changes to the policy configuration or metadata.</p>
    pub fn get_updated_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.updated_at
    }
    /// <p>The Amazon Resource Name (ARN) of the policy. This globally unique identifier can be used for cross-service references and IAM policy statements.</p>
    /// This field is required.
    pub fn policy_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.policy_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the policy. This globally unique identifier can be used for cross-service references and IAM policy statements.</p>
    pub fn set_policy_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.policy_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the policy. This globally unique identifier can be used for cross-service references and IAM policy statements.</p>
    pub fn get_policy_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.policy_arn
    }
    /// <p>The current status of the policy.</p>
    /// This field is required.
    pub fn status(mut self, input: crate::types::PolicyStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The current status of the policy.</p>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::PolicyStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The current status of the policy.</p>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::PolicyStatus> {
        &self.status
    }
    /// Appends an item to `status_reasons`.
    ///
    /// To override the contents of this collection use [`set_status_reasons`](Self::set_status_reasons).
    ///
    /// <p>Additional information about the policy status. This provides details about any failures or the current state of the policy lifecycle.</p>
    pub fn status_reasons(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.status_reasons.unwrap_or_default();
        v.push(input.into());
        self.status_reasons = ::std::option::Option::Some(v);
        self
    }
    /// <p>Additional information about the policy status. This provides details about any failures or the current state of the policy lifecycle.</p>
    pub fn set_status_reasons(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.status_reasons = input;
        self
    }
    /// <p>Additional information about the policy status. This provides details about any failures or the current state of the policy lifecycle.</p>
    pub fn get_status_reasons(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.status_reasons
    }
    /// Consumes the builder and constructs a [`Policy`](crate::types::Policy).
    /// This method will fail if any of the following fields are not set:
    /// - [`policy_id`](crate::types::builders::PolicyBuilder::policy_id)
    /// - [`name`](crate::types::builders::PolicyBuilder::name)
    /// - [`policy_engine_id`](crate::types::builders::PolicyBuilder::policy_engine_id)
    /// - [`created_at`](crate::types::builders::PolicyBuilder::created_at)
    /// - [`updated_at`](crate::types::builders::PolicyBuilder::updated_at)
    /// - [`policy_arn`](crate::types::builders::PolicyBuilder::policy_arn)
    /// - [`status`](crate::types::builders::PolicyBuilder::status)
    /// - [`status_reasons`](crate::types::builders::PolicyBuilder::status_reasons)
    pub fn build(self) -> ::std::result::Result<crate::types::Policy, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::Policy {
            policy_id: self.policy_id.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "policy_id",
                    "policy_id was not specified but it is required when building Policy",
                )
            })?,
            name: self.name.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "name",
                    "name was not specified but it is required when building Policy",
                )
            })?,
            policy_engine_id: self.policy_engine_id.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "policy_engine_id",
                    "policy_engine_id was not specified but it is required when building Policy",
                )
            })?,
            definition: self.definition,
            description: self.description,
            created_at: self.created_at.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "created_at",
                    "created_at was not specified but it is required when building Policy",
                )
            })?,
            updated_at: self.updated_at.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "updated_at",
                    "updated_at was not specified but it is required when building Policy",
                )
            })?,
            policy_arn: self.policy_arn.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "policy_arn",
                    "policy_arn was not specified but it is required when building Policy",
                )
            })?,
            status: self.status.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "status",
                    "status was not specified but it is required when building Policy",
                )
            })?,
            status_reasons: self.status_reasons.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "status_reasons",
                    "status_reasons was not specified but it is required when building Policy",
                )
            })?,
        })
    }
}
impl ::std::fmt::Debug for PolicyBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("PolicyBuilder");
        formatter.field("policy_id", &self.policy_id);
        formatter.field("name", &self.name);
        formatter.field("policy_engine_id", &self.policy_engine_id);
        formatter.field("definition", &self.definition);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("created_at", &self.created_at);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("policy_arn", &self.policy_arn);
        formatter.field("status", &self.status);
        formatter.field("status_reasons", &self.status_reasons);
        formatter.finish()
    }
}
