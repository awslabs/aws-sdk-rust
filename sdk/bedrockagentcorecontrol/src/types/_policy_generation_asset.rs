// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Represents a generated policy asset from the AI-powered policy generation process within the AgentCore Policy system. Each asset contains a Cedar policy statement generated from natural language input, along with associated metadata and analysis findings to help users evaluate and select the most appropriate policy option.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct PolicyGenerationAsset {
    /// <p>The unique identifier for this generated policy asset within the policy generation request. This ID can be used to reference specific generated policy options when creating actual policies from the generation results.</p>
    pub policy_generation_asset_id: ::std::string::String,
    /// <p>Represents the definition structure for policies within the AgentCore Policy system. This structure encapsulates different policy formats and languages that can be used to define access control rules.</p>
    pub definition: ::std::option::Option<crate::types::PolicyDefinition>,
    /// <p>The portion of the original natural language input that this generated policy asset addresses. This helps users understand which part of their policy description was translated into this specific Cedar policy statement, enabling better policy selection and refinement. When a single natural language input describes multiple authorization requirements, the generation process creates separate policy assets for each requirement, with each asset's rawTextFragment showing which requirement it addresses. Use this mapping to verify that all parts of your natural language input were correctly translated into Cedar policies.</p>
    pub raw_text_fragment: ::std::string::String,
    /// <p>Analysis findings and insights related to this specific generated policy asset. These findings may include validation results, potential issues, or recommendations for improvement to help users evaluate the quality and appropriateness of the generated policy.</p>
    pub findings: ::std::vec::Vec<crate::types::Finding>,
}
impl PolicyGenerationAsset {
    /// <p>The unique identifier for this generated policy asset within the policy generation request. This ID can be used to reference specific generated policy options when creating actual policies from the generation results.</p>
    pub fn policy_generation_asset_id(&self) -> &str {
        use std::ops::Deref;
        self.policy_generation_asset_id.deref()
    }
    /// <p>Represents the definition structure for policies within the AgentCore Policy system. This structure encapsulates different policy formats and languages that can be used to define access control rules.</p>
    pub fn definition(&self) -> ::std::option::Option<&crate::types::PolicyDefinition> {
        self.definition.as_ref()
    }
    /// <p>The portion of the original natural language input that this generated policy asset addresses. This helps users understand which part of their policy description was translated into this specific Cedar policy statement, enabling better policy selection and refinement. When a single natural language input describes multiple authorization requirements, the generation process creates separate policy assets for each requirement, with each asset's rawTextFragment showing which requirement it addresses. Use this mapping to verify that all parts of your natural language input were correctly translated into Cedar policies.</p>
    pub fn raw_text_fragment(&self) -> &str {
        use std::ops::Deref;
        self.raw_text_fragment.deref()
    }
    /// <p>Analysis findings and insights related to this specific generated policy asset. These findings may include validation results, potential issues, or recommendations for improvement to help users evaluate the quality and appropriateness of the generated policy.</p>
    pub fn findings(&self) -> &[crate::types::Finding] {
        use std::ops::Deref;
        self.findings.deref()
    }
}
impl PolicyGenerationAsset {
    /// Creates a new builder-style object to manufacture [`PolicyGenerationAsset`](crate::types::PolicyGenerationAsset).
    pub fn builder() -> crate::types::builders::PolicyGenerationAssetBuilder {
        crate::types::builders::PolicyGenerationAssetBuilder::default()
    }
}

/// A builder for [`PolicyGenerationAsset`](crate::types::PolicyGenerationAsset).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct PolicyGenerationAssetBuilder {
    pub(crate) policy_generation_asset_id: ::std::option::Option<::std::string::String>,
    pub(crate) definition: ::std::option::Option<crate::types::PolicyDefinition>,
    pub(crate) raw_text_fragment: ::std::option::Option<::std::string::String>,
    pub(crate) findings: ::std::option::Option<::std::vec::Vec<crate::types::Finding>>,
}
impl PolicyGenerationAssetBuilder {
    /// <p>The unique identifier for this generated policy asset within the policy generation request. This ID can be used to reference specific generated policy options when creating actual policies from the generation results.</p>
    /// This field is required.
    pub fn policy_generation_asset_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.policy_generation_asset_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier for this generated policy asset within the policy generation request. This ID can be used to reference specific generated policy options when creating actual policies from the generation results.</p>
    pub fn set_policy_generation_asset_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.policy_generation_asset_id = input;
        self
    }
    /// <p>The unique identifier for this generated policy asset within the policy generation request. This ID can be used to reference specific generated policy options when creating actual policies from the generation results.</p>
    pub fn get_policy_generation_asset_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.policy_generation_asset_id
    }
    /// <p>Represents the definition structure for policies within the AgentCore Policy system. This structure encapsulates different policy formats and languages that can be used to define access control rules.</p>
    pub fn definition(mut self, input: crate::types::PolicyDefinition) -> Self {
        self.definition = ::std::option::Option::Some(input);
        self
    }
    /// <p>Represents the definition structure for policies within the AgentCore Policy system. This structure encapsulates different policy formats and languages that can be used to define access control rules.</p>
    pub fn set_definition(mut self, input: ::std::option::Option<crate::types::PolicyDefinition>) -> Self {
        self.definition = input;
        self
    }
    /// <p>Represents the definition structure for policies within the AgentCore Policy system. This structure encapsulates different policy formats and languages that can be used to define access control rules.</p>
    pub fn get_definition(&self) -> &::std::option::Option<crate::types::PolicyDefinition> {
        &self.definition
    }
    /// <p>The portion of the original natural language input that this generated policy asset addresses. This helps users understand which part of their policy description was translated into this specific Cedar policy statement, enabling better policy selection and refinement. When a single natural language input describes multiple authorization requirements, the generation process creates separate policy assets for each requirement, with each asset's rawTextFragment showing which requirement it addresses. Use this mapping to verify that all parts of your natural language input were correctly translated into Cedar policies.</p>
    /// This field is required.
    pub fn raw_text_fragment(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.raw_text_fragment = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The portion of the original natural language input that this generated policy asset addresses. This helps users understand which part of their policy description was translated into this specific Cedar policy statement, enabling better policy selection and refinement. When a single natural language input describes multiple authorization requirements, the generation process creates separate policy assets for each requirement, with each asset's rawTextFragment showing which requirement it addresses. Use this mapping to verify that all parts of your natural language input were correctly translated into Cedar policies.</p>
    pub fn set_raw_text_fragment(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.raw_text_fragment = input;
        self
    }
    /// <p>The portion of the original natural language input that this generated policy asset addresses. This helps users understand which part of their policy description was translated into this specific Cedar policy statement, enabling better policy selection and refinement. When a single natural language input describes multiple authorization requirements, the generation process creates separate policy assets for each requirement, with each asset's rawTextFragment showing which requirement it addresses. Use this mapping to verify that all parts of your natural language input were correctly translated into Cedar policies.</p>
    pub fn get_raw_text_fragment(&self) -> &::std::option::Option<::std::string::String> {
        &self.raw_text_fragment
    }
    /// Appends an item to `findings`.
    ///
    /// To override the contents of this collection use [`set_findings`](Self::set_findings).
    ///
    /// <p>Analysis findings and insights related to this specific generated policy asset. These findings may include validation results, potential issues, or recommendations for improvement to help users evaluate the quality and appropriateness of the generated policy.</p>
    pub fn findings(mut self, input: crate::types::Finding) -> Self {
        let mut v = self.findings.unwrap_or_default();
        v.push(input);
        self.findings = ::std::option::Option::Some(v);
        self
    }
    /// <p>Analysis findings and insights related to this specific generated policy asset. These findings may include validation results, potential issues, or recommendations for improvement to help users evaluate the quality and appropriateness of the generated policy.</p>
    pub fn set_findings(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Finding>>) -> Self {
        self.findings = input;
        self
    }
    /// <p>Analysis findings and insights related to this specific generated policy asset. These findings may include validation results, potential issues, or recommendations for improvement to help users evaluate the quality and appropriateness of the generated policy.</p>
    pub fn get_findings(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Finding>> {
        &self.findings
    }
    /// Consumes the builder and constructs a [`PolicyGenerationAsset`](crate::types::PolicyGenerationAsset).
    /// This method will fail if any of the following fields are not set:
    /// - [`policy_generation_asset_id`](crate::types::builders::PolicyGenerationAssetBuilder::policy_generation_asset_id)
    /// - [`raw_text_fragment`](crate::types::builders::PolicyGenerationAssetBuilder::raw_text_fragment)
    /// - [`findings`](crate::types::builders::PolicyGenerationAssetBuilder::findings)
    pub fn build(self) -> ::std::result::Result<crate::types::PolicyGenerationAsset, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::PolicyGenerationAsset {
            policy_generation_asset_id: self.policy_generation_asset_id.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "policy_generation_asset_id",
                    "policy_generation_asset_id was not specified but it is required when building PolicyGenerationAsset",
                )
            })?,
            definition: self.definition,
            raw_text_fragment: self.raw_text_fragment.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "raw_text_fragment",
                    "raw_text_fragment was not specified but it is required when building PolicyGenerationAsset",
                )
            })?,
            findings: self.findings.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "findings",
                    "findings was not specified but it is required when building PolicyGenerationAsset",
                )
            })?,
        })
    }
}
