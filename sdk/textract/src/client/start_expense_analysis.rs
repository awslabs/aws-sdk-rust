// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
impl super::Client {
    /// Constructs a fluent builder for the [`StartExpenseAnalysis`](crate::operation::start_expense_analysis::builders::StartExpenseAnalysisFluentBuilder) operation.
    ///
    /// - The fluent builder is configurable:
    ///   - [`document_location(DocumentLocation)`](crate::operation::start_expense_analysis::builders::StartExpenseAnalysisFluentBuilder::document_location) / [`set_document_location(Option<DocumentLocation>)`](crate::operation::start_expense_analysis::builders::StartExpenseAnalysisFluentBuilder::set_document_location): <p>The location of the document to be processed.</p>
    ///   - [`client_request_token(impl Into<String>)`](crate::operation::start_expense_analysis::builders::StartExpenseAnalysisFluentBuilder::client_request_token) / [`set_client_request_token(Option<String>)`](crate::operation::start_expense_analysis::builders::StartExpenseAnalysisFluentBuilder::set_client_request_token): <p>The idempotent token that's used to identify the start request. If you use the same token with multiple <code>StartDocumentTextDetection</code> requests, the same <code>JobId</code> is returned. Use <code>ClientRequestToken</code> to prevent the same job from being accidentally started more than once. For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/api-async.html">Calling Amazon Textract Asynchronous Operations</a> </p>
    ///   - [`job_tag(impl Into<String>)`](crate::operation::start_expense_analysis::builders::StartExpenseAnalysisFluentBuilder::job_tag) / [`set_job_tag(Option<String>)`](crate::operation::start_expense_analysis::builders::StartExpenseAnalysisFluentBuilder::set_job_tag): <p>An identifier you specify that's included in the completion notification published to the Amazon SNS topic. For example, you can use <code>JobTag</code> to identify the type of document that the completion notification corresponds to (such as a tax form or a receipt).</p>
    ///   - [`notification_channel(NotificationChannel)`](crate::operation::start_expense_analysis::builders::StartExpenseAnalysisFluentBuilder::notification_channel) / [`set_notification_channel(Option<NotificationChannel>)`](crate::operation::start_expense_analysis::builders::StartExpenseAnalysisFluentBuilder::set_notification_channel): <p>The Amazon SNS topic ARN that you want Amazon Textract to publish the completion status of the operation to. </p>
    ///   - [`output_config(OutputConfig)`](crate::operation::start_expense_analysis::builders::StartExpenseAnalysisFluentBuilder::output_config) / [`set_output_config(Option<OutputConfig>)`](crate::operation::start_expense_analysis::builders::StartExpenseAnalysisFluentBuilder::set_output_config): <p>Sets if the output will go to a customer defined bucket. By default, Amazon Textract will save the results internally to be accessed by the <code>GetExpenseAnalysis</code> operation.</p>
    ///   - [`kms_key_id(impl Into<String>)`](crate::operation::start_expense_analysis::builders::StartExpenseAnalysisFluentBuilder::kms_key_id) / [`set_kms_key_id(Option<String>)`](crate::operation::start_expense_analysis::builders::StartExpenseAnalysisFluentBuilder::set_kms_key_id): <p>The KMS key used to encrypt the inference results. This can be in either Key ID or Key Alias format. When a KMS key is provided, the KMS key will be used for server-side encryption of the objects in the customer bucket. When this parameter is not enabled, the result will be encrypted server side,using SSE-S3.</p>
    /// - On success, responds with [`StartExpenseAnalysisOutput`](crate::operation::start_expense_analysis::StartExpenseAnalysisOutput) with field(s):
    ///   - [`job_id(Option<String>)`](crate::operation::start_expense_analysis::StartExpenseAnalysisOutput::job_id): <p>A unique identifier for the text detection job. The <code>JobId</code> is returned from <code>StartExpenseAnalysis</code>. A <code>JobId</code> value is only valid for 7 days.</p>
    /// - On failure, responds with [`SdkError<StartExpenseAnalysisError>`](crate::operation::start_expense_analysis::StartExpenseAnalysisError)
    pub fn start_expense_analysis(
        &self,
    ) -> crate::operation::start_expense_analysis::builders::StartExpenseAnalysisFluentBuilder {
        crate::operation::start_expense_analysis::builders::StartExpenseAnalysisFluentBuilder::new(
            self.handle.clone(),
        )
    }
}
