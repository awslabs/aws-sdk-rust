// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Analyzes an input document for relationships between detected items.  </p>
/// <p>The types of information returned are as follows: </p>
/// <ul>
/// <li>
/// <p>Form data (key-value pairs). The related information is returned in two <a>Block</a> objects, each of type <code>KEY_VALUE_SET</code>: a KEY
/// <code>Block</code> object and a VALUE <code>Block</code> object. For example,
/// <i>Name: Ana Silva Carolina</i> contains a key and value.
/// <i>Name:</i> is the key. <i>Ana Silva Carolina</i> is
/// the value.</p>
/// </li>
/// <li>
/// <p>Table and table cell data. A TABLE <code>Block</code> object contains information about a detected table. A CELL
/// <code>Block</code> object is returned for each cell in a table.</p>
/// </li>
/// <li>
/// <p>Lines and words of text. A LINE <code>Block</code> object contains one or more WORD <code>Block</code> objects.
/// All lines and words that are detected in the document are returned (including text that doesn't have a
/// relationship with the value of <code>FeatureTypes</code>). </p>
/// </li>
/// </ul>
/// <p>Selection elements such as check boxes and option buttons (radio buttons) can be detected in form data and in tables.
/// A SELECTION_ELEMENT <code>Block</code> object contains information about a selection element,
/// including the selection status.</p>
/// <p>You can choose which type of analysis to perform by specifying the <code>FeatureTypes</code> list.
/// </p>
/// <p>The output is returned in a list of <code>Block</code> objects.</p>
/// <p>
/// <code>AnalyzeDocument</code> is a synchronous operation. To analyze documents
/// asynchronously, use <a>StartDocumentAnalysis</a>.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works-analyzing.html">Document Text Analysis</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AnalyzeDocument {
    _private: (),
}
impl AnalyzeDocument {
    /// Creates a new builder-style object to manufacture [`AnalyzeDocumentInput`](crate::input::AnalyzeDocumentInput)
    pub fn builder() -> crate::input::analyze_document_input::Builder {
        crate::input::analyze_document_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AnalyzeDocument {
    type Output = std::result::Result<
        crate::output::AnalyzeDocumentOutput,
        crate::error::AnalyzeDocumentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_analyze_document_error(response)
        } else {
            crate::operation_deser::parse_analyze_document_response(response)
        }
    }
}

/// <p>Analyzes an input document for financially related relationships between text.</p>
/// <p>Information is returned as <code>ExpenseDocuments</code> and seperated as follows.</p>
/// <ul>
/// <li>
/// <p>
/// <code>LineItemGroups</code>- A data set containing <code>LineItems</code> which
/// store information about the lines of text, such as an item purchased and its price on a receipt.</p>
/// </li>
/// <li>
/// <p>
/// <code>SummaryFields</code>- Contains all other information a receipt, such as header information
/// or the vendors name.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AnalyzeExpense {
    _private: (),
}
impl AnalyzeExpense {
    /// Creates a new builder-style object to manufacture [`AnalyzeExpenseInput`](crate::input::AnalyzeExpenseInput)
    pub fn builder() -> crate::input::analyze_expense_input::Builder {
        crate::input::analyze_expense_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AnalyzeExpense {
    type Output =
        std::result::Result<crate::output::AnalyzeExpenseOutput, crate::error::AnalyzeExpenseError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_analyze_expense_error(response)
        } else {
            crate::operation_deser::parse_analyze_expense_response(response)
        }
    }
}

/// <p>Detects text in the input document. Amazon Textract can detect lines of text and the
/// words that make up a line of text. The input document must be an image in JPEG or PNG
/// format. <code>DetectDocumentText</code> returns the detected text in an array of <a>Block</a> objects. </p>
/// <p>Each document page has as an associated <code>Block</code> of type PAGE. Each PAGE <code>Block</code> object
/// is the parent of LINE <code>Block</code> objects that represent the lines of detected text on a page. A LINE <code>Block</code> object is
/// a parent for each word that makes up the line. Words are represented by <code>Block</code> objects of type WORD.</p>
/// <p>
/// <code>DetectDocumentText</code> is a synchronous operation. To analyze documents
/// asynchronously, use <a>StartDocumentTextDetection</a>.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works-detecting.html">Document Text Detection</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetectDocumentText {
    _private: (),
}
impl DetectDocumentText {
    /// Creates a new builder-style object to manufacture [`DetectDocumentTextInput`](crate::input::DetectDocumentTextInput)
    pub fn builder() -> crate::input::detect_document_text_input::Builder {
        crate::input::detect_document_text_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetectDocumentText {
    type Output = std::result::Result<
        crate::output::DetectDocumentTextOutput,
        crate::error::DetectDocumentTextError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_detect_document_text_error(response)
        } else {
            crate::operation_deser::parse_detect_document_text_response(response)
        }
    }
}

/// <p>Gets the results for an Amazon Textract asynchronous operation that analyzes text in a document.</p>
/// <p>You start asynchronous text analysis by calling <a>StartDocumentAnalysis</a>, which returns a job identifier
/// (<code>JobId</code>). When the text analysis operation finishes, Amazon Textract publishes a
/// completion status to the Amazon Simple Notification Service (Amazon SNS) topic that's registered in the initial call to
/// <code>StartDocumentAnalysis</code>. To get the results of the text-detection operation,
/// first check that the status value published to the Amazon SNS topic is <code>SUCCEEDED</code>.
/// If so, call <code>GetDocumentAnalysis</code>, and pass the job identifier
/// (<code>JobId</code>) from the initial call to <code>StartDocumentAnalysis</code>.</p>
/// <p>
/// <code>GetDocumentAnalysis</code> returns an array of <a>Block</a> objects. The following
/// types of information are returned: </p>
/// <ul>
/// <li>
/// <p>Form data (key-value pairs). The related information is returned in two <a>Block</a> objects, each of type <code>KEY_VALUE_SET</code>: a KEY
/// <code>Block</code> object and a VALUE <code>Block</code> object. For example,
/// <i>Name: Ana Silva Carolina</i> contains a key and value.
/// <i>Name:</i> is the key. <i>Ana Silva Carolina</i> is
/// the value.</p>
/// </li>
/// <li>
/// <p>Table and table cell data. A TABLE <code>Block</code> object contains information about a detected table. A CELL
/// <code>Block</code> object is returned for each cell in a table.</p>
/// </li>
/// <li>
/// <p>Lines and words of text. A LINE <code>Block</code> object contains one or more WORD <code>Block</code> objects.
/// All lines and words that are detected in the document are returned (including text that doesn't have a
/// relationship with the value of the <code>StartDocumentAnalysis</code>
/// <code>FeatureTypes</code> input parameter). </p>
/// </li>
/// </ul>
/// <p>Selection elements such as check boxes and option buttons (radio buttons) can be detected in form data and in tables.
/// A SELECTION_ELEMENT <code>Block</code> object contains information about a selection element,
/// including the selection status.</p>
/// <p>Use the <code>MaxResults</code> parameter to limit the number of blocks that are
/// returned. If there are more results than specified in <code>MaxResults</code>, the value of
/// <code>NextToken</code> in the operation response contains a pagination token for getting
/// the next set of results. To get the next page of results, call
/// <code>GetDocumentAnalysis</code>, and populate the <code>NextToken</code> request
/// parameter with the token value that's returned from the previous call to
/// <code>GetDocumentAnalysis</code>.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works-analyzing.html">Document Text Analysis</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDocumentAnalysis {
    _private: (),
}
impl GetDocumentAnalysis {
    /// Creates a new builder-style object to manufacture [`GetDocumentAnalysisInput`](crate::input::GetDocumentAnalysisInput)
    pub fn builder() -> crate::input::get_document_analysis_input::Builder {
        crate::input::get_document_analysis_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDocumentAnalysis {
    type Output = std::result::Result<
        crate::output::GetDocumentAnalysisOutput,
        crate::error::GetDocumentAnalysisError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_document_analysis_error(response)
        } else {
            crate::operation_deser::parse_get_document_analysis_response(response)
        }
    }
}

/// <p>Gets the results for an Amazon Textract asynchronous operation that detects text in a document.
/// Amazon Textract can detect lines of text and the words that make up a line of text.</p>
/// <p>You start asynchronous text detection by calling <a>StartDocumentTextDetection</a>, which returns a job identifier
/// (<code>JobId</code>). When the text detection operation finishes, Amazon Textract publishes a
/// completion status to the Amazon Simple Notification Service (Amazon SNS) topic that's registered in the initial call to
/// <code>StartDocumentTextDetection</code>. To get the results of the text-detection
/// operation, first check that the status value published to the Amazon SNS topic is
/// <code>SUCCEEDED</code>. If so, call <code>GetDocumentTextDetection</code>, and pass the
/// job identifier (<code>JobId</code>) from the initial call to
/// <code>StartDocumentTextDetection</code>.</p>
/// <p>
/// <code>GetDocumentTextDetection</code> returns an array of <a>Block</a>
/// objects. </p>
/// <p>Each document page has as an associated <code>Block</code> of type PAGE. Each PAGE <code>Block</code> object
/// is the parent of LINE <code>Block</code> objects that represent the lines of detected text on a page. A LINE <code>Block</code> object is
/// a parent for each word that makes up the line. Words are represented by <code>Block</code> objects of type WORD.</p>
/// <p>Use the MaxResults parameter to limit the number of blocks that are returned. If there
/// are more results than specified in <code>MaxResults</code>, the value of
/// <code>NextToken</code> in the operation response contains a pagination token for getting
/// the next set of results. To get the next page of results, call
/// <code>GetDocumentTextDetection</code>, and populate the <code>NextToken</code> request
/// parameter with the token value that's returned from the previous call to
/// <code>GetDocumentTextDetection</code>.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works-detecting.html">Document Text Detection</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDocumentTextDetection {
    _private: (),
}
impl GetDocumentTextDetection {
    /// Creates a new builder-style object to manufacture [`GetDocumentTextDetectionInput`](crate::input::GetDocumentTextDetectionInput)
    pub fn builder() -> crate::input::get_document_text_detection_input::Builder {
        crate::input::get_document_text_detection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDocumentTextDetection {
    type Output = std::result::Result<
        crate::output::GetDocumentTextDetectionOutput,
        crate::error::GetDocumentTextDetectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_document_text_detection_error(response)
        } else {
            crate::operation_deser::parse_get_document_text_detection_response(response)
        }
    }
}

/// <p>Starts the asynchronous analysis of an input document for relationships between detected
/// items such as key-value pairs, tables, and selection elements.</p>
/// <p>
/// <code>StartDocumentAnalysis</code> can analyze text in documents that are in JPEG, PNG, and PDF format. The
/// documents are stored in an Amazon S3 bucket. Use <a>DocumentLocation</a> to specify the bucket name and file name
/// of the document.
/// </p>
/// <p>
/// <code>StartDocumentAnalysis</code> returns a job identifier
/// (<code>JobId</code>) that you use to get the results of the operation. When text
/// analysis is finished, Amazon Textract publishes a completion status to the Amazon Simple Notification Service (Amazon SNS)
/// topic that you specify in <code>NotificationChannel</code>. To get the results of the text
/// analysis operation, first check that the status value published to the Amazon SNS topic is
/// <code>SUCCEEDED</code>. If so, call <a>GetDocumentAnalysis</a>, and pass
/// the job identifier (<code>JobId</code>) from the initial call to
/// <code>StartDocumentAnalysis</code>.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works-analyzing.html">Document Text Analysis</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartDocumentAnalysis {
    _private: (),
}
impl StartDocumentAnalysis {
    /// Creates a new builder-style object to manufacture [`StartDocumentAnalysisInput`](crate::input::StartDocumentAnalysisInput)
    pub fn builder() -> crate::input::start_document_analysis_input::Builder {
        crate::input::start_document_analysis_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartDocumentAnalysis {
    type Output = std::result::Result<
        crate::output::StartDocumentAnalysisOutput,
        crate::error::StartDocumentAnalysisError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_document_analysis_error(response)
        } else {
            crate::operation_deser::parse_start_document_analysis_response(response)
        }
    }
}

/// <p>Starts the asynchronous detection of text in a document. Amazon Textract can detect lines of
/// text and the words that make up a line of text.</p>
/// <p>
/// <code>StartDocumentTextDetection</code> can analyze text in documents that are in JPEG, PNG, and PDF format. The
/// documents are stored in an Amazon S3 bucket. Use <a>DocumentLocation</a> to specify the bucket name and file name
/// of the document.
/// </p>
/// <p>
/// <code>StartTextDetection</code> returns a job identifier
/// (<code>JobId</code>) that you use to get the results of the operation. When text
/// detection is finished, Amazon Textract publishes a completion status to the Amazon Simple Notification Service (Amazon SNS)
/// topic that you specify in <code>NotificationChannel</code>. To get the results of the text
/// detection operation, first check that the status value published to the Amazon SNS topic is
/// <code>SUCCEEDED</code>. If so, call <a>GetDocumentTextDetection</a>, and
/// pass the job identifier (<code>JobId</code>) from the initial call to
/// <code>StartDocumentTextDetection</code>.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/how-it-works-detecting.html">Document Text Detection</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartDocumentTextDetection {
    _private: (),
}
impl StartDocumentTextDetection {
    /// Creates a new builder-style object to manufacture [`StartDocumentTextDetectionInput`](crate::input::StartDocumentTextDetectionInput)
    pub fn builder() -> crate::input::start_document_text_detection_input::Builder {
        crate::input::start_document_text_detection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartDocumentTextDetection {
    type Output = std::result::Result<
        crate::output::StartDocumentTextDetectionOutput,
        crate::error::StartDocumentTextDetectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_document_text_detection_error(response)
        } else {
            crate::operation_deser::parse_start_document_text_detection_response(response)
        }
    }
}
