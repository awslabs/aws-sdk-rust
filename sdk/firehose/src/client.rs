// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn create_delivery_stream(&self) -> fluent_builders::CreateDeliveryStream<C> {
        fluent_builders::CreateDeliveryStream::new(self.handle.clone())
    }
    pub fn delete_delivery_stream(&self) -> fluent_builders::DeleteDeliveryStream<C> {
        fluent_builders::DeleteDeliveryStream::new(self.handle.clone())
    }
    pub fn describe_delivery_stream(&self) -> fluent_builders::DescribeDeliveryStream<C> {
        fluent_builders::DescribeDeliveryStream::new(self.handle.clone())
    }
    pub fn list_delivery_streams(&self) -> fluent_builders::ListDeliveryStreams<C> {
        fluent_builders::ListDeliveryStreams::new(self.handle.clone())
    }
    pub fn list_tags_for_delivery_stream(&self) -> fluent_builders::ListTagsForDeliveryStream<C> {
        fluent_builders::ListTagsForDeliveryStream::new(self.handle.clone())
    }
    pub fn put_record(&self) -> fluent_builders::PutRecord<C> {
        fluent_builders::PutRecord::new(self.handle.clone())
    }
    pub fn put_record_batch(&self) -> fluent_builders::PutRecordBatch<C> {
        fluent_builders::PutRecordBatch::new(self.handle.clone())
    }
    pub fn start_delivery_stream_encryption(
        &self,
    ) -> fluent_builders::StartDeliveryStreamEncryption<C> {
        fluent_builders::StartDeliveryStreamEncryption::new(self.handle.clone())
    }
    pub fn stop_delivery_stream_encryption(
        &self,
    ) -> fluent_builders::StopDeliveryStreamEncryption<C> {
        fluent_builders::StopDeliveryStreamEncryption::new(self.handle.clone())
    }
    pub fn tag_delivery_stream(&self) -> fluent_builders::TagDeliveryStream<C> {
        fluent_builders::TagDeliveryStream::new(self.handle.clone())
    }
    pub fn untag_delivery_stream(&self) -> fluent_builders::UntagDeliveryStream<C> {
        fluent_builders::UntagDeliveryStream::new(self.handle.clone())
    }
    pub fn update_destination(&self) -> fluent_builders::UpdateDestination<C> {
        fluent_builders::UpdateDestination::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CreateDeliveryStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_delivery_stream_input::Builder,
    }
    impl<C> CreateDeliveryStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDeliveryStreamOutput,
            smithy_http::result::SdkError<crate::error::CreateDeliveryStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream. This name must be unique per AWS account in the same
        /// AWS Region. If the delivery streams are in different accounts or different Regions, you can
        /// have multiple delivery streams with the same name.</p>
        pub fn delivery_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(input);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// <p>The delivery stream type. This parameter can be one of the following
        /// values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DirectPut</code>: Provider applications access the delivery stream
        /// directly.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>KinesisStreamAsSource</code>: The delivery stream uses a Kinesis data
        /// stream as a source.</p>
        /// </li>
        /// </ul>
        pub fn delivery_stream_type(mut self, input: crate::model::DeliveryStreamType) -> Self {
            self.inner = self.inner.delivery_stream_type(input);
            self
        }
        pub fn set_delivery_stream_type(
            mut self,
            input: std::option::Option<crate::model::DeliveryStreamType>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_type(input);
            self
        }
        /// <p>When a Kinesis data stream is used as the source for the delivery stream, a <a>KinesisStreamSourceConfiguration</a> containing the Kinesis data stream Amazon
        /// Resource Name (ARN) and the role ARN for the source stream.</p>
        pub fn kinesis_stream_source_configuration(
            mut self,
            input: crate::model::KinesisStreamSourceConfiguration,
        ) -> Self {
            self.inner = self.inner.kinesis_stream_source_configuration(input);
            self
        }
        pub fn set_kinesis_stream_source_configuration(
            mut self,
            input: std::option::Option<crate::model::KinesisStreamSourceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_kinesis_stream_source_configuration(input);
            self
        }
        /// <p>Used to specify the type and Amazon Resource Name (ARN) of the KMS key needed for
        /// Server-Side Encryption (SSE).</p>
        pub fn delivery_stream_encryption_configuration_input(
            mut self,
            input: crate::model::DeliveryStreamEncryptionConfigurationInput,
        ) -> Self {
            self.inner = self
                .inner
                .delivery_stream_encryption_configuration_input(input);
            self
        }
        pub fn set_delivery_stream_encryption_configuration_input(
            mut self,
            input: std::option::Option<crate::model::DeliveryStreamEncryptionConfigurationInput>,
        ) -> Self {
            self.inner = self
                .inner
                .set_delivery_stream_encryption_configuration_input(input);
            self
        }
        /// <p>[Deprecated]
        /// The destination in Amazon S3. You can specify only one destination.</p>
        pub fn s3_destination_configuration(
            mut self,
            input: crate::model::S3DestinationConfiguration,
        ) -> Self {
            self.inner = self.inner.s3_destination_configuration(input);
            self
        }
        pub fn set_s3_destination_configuration(
            mut self,
            input: std::option::Option<crate::model::S3DestinationConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_s3_destination_configuration(input);
            self
        }
        /// <p>The destination in Amazon S3. You can specify only one destination.</p>
        pub fn extended_s3_destination_configuration(
            mut self,
            input: crate::model::ExtendedS3DestinationConfiguration,
        ) -> Self {
            self.inner = self.inner.extended_s3_destination_configuration(input);
            self
        }
        pub fn set_extended_s3_destination_configuration(
            mut self,
            input: std::option::Option<crate::model::ExtendedS3DestinationConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_extended_s3_destination_configuration(input);
            self
        }
        /// <p>The destination in Amazon Redshift. You can specify only one destination.</p>
        pub fn redshift_destination_configuration(
            mut self,
            input: crate::model::RedshiftDestinationConfiguration,
        ) -> Self {
            self.inner = self.inner.redshift_destination_configuration(input);
            self
        }
        pub fn set_redshift_destination_configuration(
            mut self,
            input: std::option::Option<crate::model::RedshiftDestinationConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_redshift_destination_configuration(input);
            self
        }
        /// <p>The destination in Amazon ES. You can specify only one destination.</p>
        pub fn elasticsearch_destination_configuration(
            mut self,
            input: crate::model::ElasticsearchDestinationConfiguration,
        ) -> Self {
            self.inner = self.inner.elasticsearch_destination_configuration(input);
            self
        }
        pub fn set_elasticsearch_destination_configuration(
            mut self,
            input: std::option::Option<crate::model::ElasticsearchDestinationConfiguration>,
        ) -> Self {
            self.inner = self
                .inner
                .set_elasticsearch_destination_configuration(input);
            self
        }
        /// <p>The destination in Splunk. You can specify only one destination.</p>
        pub fn splunk_destination_configuration(
            mut self,
            input: crate::model::SplunkDestinationConfiguration,
        ) -> Self {
            self.inner = self.inner.splunk_destination_configuration(input);
            self
        }
        pub fn set_splunk_destination_configuration(
            mut self,
            input: std::option::Option<crate::model::SplunkDestinationConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_splunk_destination_configuration(input);
            self
        }
        /// <p>Enables configuring Kinesis Firehose to deliver data to any HTTP endpoint destination.
        /// You can specify only one destination.</p>
        pub fn http_endpoint_destination_configuration(
            mut self,
            input: crate::model::HttpEndpointDestinationConfiguration,
        ) -> Self {
            self.inner = self.inner.http_endpoint_destination_configuration(input);
            self
        }
        pub fn set_http_endpoint_destination_configuration(
            mut self,
            input: std::option::Option<crate::model::HttpEndpointDestinationConfiguration>,
        ) -> Self {
            self.inner = self
                .inner
                .set_http_endpoint_destination_configuration(input);
            self
        }
        /// <p>A set of tags to assign to the delivery stream. A tag is a key-value pair that you can
        /// define and assign to AWS resources. Tags are metadata. For example, you can add friendly
        /// names and descriptions or other types of information that can help you distinguish the
        /// delivery stream. For more information about tags, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation Tags</a> in the AWS Billing and Cost Management User
        /// Guide.</p>
        /// <p>You can specify up to 50 tags when creating a delivery stream.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDeliveryStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_delivery_stream_input::Builder,
    }
    impl<C> DeleteDeliveryStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDeliveryStreamOutput,
            smithy_http::result::SdkError<crate::error::DeleteDeliveryStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream.</p>
        pub fn delivery_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(input);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// <p>Set this to true if you want to delete the delivery stream even if Kinesis Data Firehose
        /// is unable to retire the grant for the CMK. Kinesis Data Firehose might be unable to retire
        /// the grant due to a customer error, such as when the CMK or the grant are in an invalid
        /// state. If you force deletion, you can then use the <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_RevokeGrant.html">RevokeGrant</a> operation to revoke the grant you gave to Kinesis Data Firehose. If
        /// a failure to retire the grant happens due to an AWS KMS issue, Kinesis Data Firehose keeps
        /// retrying the delete operation.</p>
        /// <p>The default value is false.</p>
        pub fn allow_force_delete(mut self, input: bool) -> Self {
            self.inner = self.inner.allow_force_delete(input);
            self
        }
        pub fn set_allow_force_delete(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_allow_force_delete(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeDeliveryStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_delivery_stream_input::Builder,
    }
    impl<C> DescribeDeliveryStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeDeliveryStreamOutput,
            smithy_http::result::SdkError<crate::error::DescribeDeliveryStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream.</p>
        pub fn delivery_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(input);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// <p>The limit on the number of destinations to return. You can have one destination per
        /// delivery stream.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>The ID of the destination to start returning the destination information. Kinesis
        /// Data Firehose supports one destination per delivery stream.</p>
        pub fn exclusive_start_destination_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.exclusive_start_destination_id(input);
            self
        }
        pub fn set_exclusive_start_destination_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_exclusive_start_destination_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDeliveryStreams<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_delivery_streams_input::Builder,
    }
    impl<C> ListDeliveryStreams<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDeliveryStreamsOutput,
            smithy_http::result::SdkError<crate::error::ListDeliveryStreamsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of delivery streams to list. The default value is 10.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>The delivery stream type. This can be one of the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DirectPut</code>: Provider applications access the delivery stream
        /// directly.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>KinesisStreamAsSource</code>: The delivery stream uses a Kinesis data
        /// stream as a source.</p>
        /// </li>
        /// </ul>
        /// <p>This parameter is optional. If this parameter is omitted, delivery streams of all
        /// types are returned.</p>
        pub fn delivery_stream_type(mut self, input: crate::model::DeliveryStreamType) -> Self {
            self.inner = self.inner.delivery_stream_type(input);
            self
        }
        pub fn set_delivery_stream_type(
            mut self,
            input: std::option::Option<crate::model::DeliveryStreamType>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_type(input);
            self
        }
        /// <p>The list of delivery streams returned by this call to
        /// <code>ListDeliveryStreams</code> will start with the delivery stream whose name comes
        /// alphabetically immediately after the name you specify in
        /// <code>ExclusiveStartDeliveryStreamName</code>.</p>
        pub fn exclusive_start_delivery_stream_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.exclusive_start_delivery_stream_name(input);
            self
        }
        pub fn set_exclusive_start_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_exclusive_start_delivery_stream_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForDeliveryStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_delivery_stream_input::Builder,
    }
    impl<C> ListTagsForDeliveryStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForDeliveryStreamOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForDeliveryStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream whose tags you want to list.</p>
        pub fn delivery_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(input);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// <p>The key to use as the starting point for the list of tags. If you set this parameter,
        /// <code>ListTagsForDeliveryStream</code> gets all tags that occur after
        /// <code>ExclusiveStartTagKey</code>.</p>
        pub fn exclusive_start_tag_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.exclusive_start_tag_key(input);
            self
        }
        pub fn set_exclusive_start_tag_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_exclusive_start_tag_key(input);
            self
        }
        /// <p>The number of tags to return. If this number is less than the total number of tags
        /// associated with the delivery stream, <code>HasMoreTags</code> is set to <code>true</code>
        /// in the response. To list additional tags, set <code>ExclusiveStartTagKey</code> to the last
        /// key in the response. </p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutRecord<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_record_input::Builder,
    }
    impl<C> PutRecord<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutRecordOutput,
            smithy_http::result::SdkError<crate::error::PutRecordError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream.</p>
        pub fn delivery_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(input);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// <p>The record.</p>
        pub fn record(mut self, input: crate::model::Record) -> Self {
            self.inner = self.inner.record(input);
            self
        }
        pub fn set_record(mut self, input: std::option::Option<crate::model::Record>) -> Self {
            self.inner = self.inner.set_record(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutRecordBatch<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_record_batch_input::Builder,
    }
    impl<C> PutRecordBatch<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutRecordBatchOutput,
            smithy_http::result::SdkError<crate::error::PutRecordBatchError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream.</p>
        pub fn delivery_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(input);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// <p>One or more records.</p>
        pub fn records(mut self, inp: impl Into<crate::model::Record>) -> Self {
            self.inner = self.inner.records(inp);
            self
        }
        pub fn set_records(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Record>>,
        ) -> Self {
            self.inner = self.inner.set_records(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartDeliveryStreamEncryption<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_delivery_stream_encryption_input::Builder,
    }
    impl<C> StartDeliveryStreamEncryption<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartDeliveryStreamEncryptionOutput,
            smithy_http::result::SdkError<crate::error::StartDeliveryStreamEncryptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream for which you want to enable server-side encryption
        /// (SSE).</p>
        pub fn delivery_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(input);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// <p>Used to specify the type and Amazon Resource Name (ARN) of the KMS key needed for
        /// Server-Side Encryption (SSE).</p>
        pub fn delivery_stream_encryption_configuration_input(
            mut self,
            input: crate::model::DeliveryStreamEncryptionConfigurationInput,
        ) -> Self {
            self.inner = self
                .inner
                .delivery_stream_encryption_configuration_input(input);
            self
        }
        pub fn set_delivery_stream_encryption_configuration_input(
            mut self,
            input: std::option::Option<crate::model::DeliveryStreamEncryptionConfigurationInput>,
        ) -> Self {
            self.inner = self
                .inner
                .set_delivery_stream_encryption_configuration_input(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopDeliveryStreamEncryption<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_delivery_stream_encryption_input::Builder,
    }
    impl<C> StopDeliveryStreamEncryption<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopDeliveryStreamEncryptionOutput,
            smithy_http::result::SdkError<crate::error::StopDeliveryStreamEncryptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream for which you want to disable server-side encryption
        /// (SSE).</p>
        pub fn delivery_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(input);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagDeliveryStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_delivery_stream_input::Builder,
    }
    impl<C> TagDeliveryStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagDeliveryStreamOutput,
            smithy_http::result::SdkError<crate::error::TagDeliveryStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream to which you want to add the tags.</p>
        pub fn delivery_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(input);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// <p>A set of key-value pairs to use to create the tags.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagDeliveryStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_delivery_stream_input::Builder,
    }
    impl<C> UntagDeliveryStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagDeliveryStreamOutput,
            smithy_http::result::SdkError<crate::error::UntagDeliveryStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream.</p>
        pub fn delivery_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(input);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// <p>A list of tag keys. Each corresponding tag is removed from the delivery
        /// stream.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDestination<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_destination_input::Builder,
    }
    impl<C> UpdateDestination<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDestinationOutput,
            smithy_http::result::SdkError<crate::error::UpdateDestinationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream.</p>
        pub fn delivery_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(input);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// <p>Obtain this value from the <code>VersionId</code> result of <a>DeliveryStreamDescription</a>. This value is required, and helps the service
        /// perform conditional operations. For example, if there is an interleaving update and this
        /// value is null, then the update destination fails. After the update is successful, the
        /// <code>VersionId</code> value is updated. The service then performs a merge of the old
        /// configuration with the new configuration.</p>
        pub fn current_delivery_stream_version_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.current_delivery_stream_version_id(input);
            self
        }
        pub fn set_current_delivery_stream_version_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_current_delivery_stream_version_id(input);
            self
        }
        /// <p>The ID of the destination.</p>
        pub fn destination_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_id(input);
            self
        }
        pub fn set_destination_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_id(input);
            self
        }
        /// <p>[Deprecated] Describes an update for a destination in Amazon S3.</p>
        pub fn s3_destination_update(mut self, input: crate::model::S3DestinationUpdate) -> Self {
            self.inner = self.inner.s3_destination_update(input);
            self
        }
        pub fn set_s3_destination_update(
            mut self,
            input: std::option::Option<crate::model::S3DestinationUpdate>,
        ) -> Self {
            self.inner = self.inner.set_s3_destination_update(input);
            self
        }
        /// <p>Describes an update for a destination in Amazon S3.</p>
        pub fn extended_s3_destination_update(
            mut self,
            input: crate::model::ExtendedS3DestinationUpdate,
        ) -> Self {
            self.inner = self.inner.extended_s3_destination_update(input);
            self
        }
        pub fn set_extended_s3_destination_update(
            mut self,
            input: std::option::Option<crate::model::ExtendedS3DestinationUpdate>,
        ) -> Self {
            self.inner = self.inner.set_extended_s3_destination_update(input);
            self
        }
        /// <p>Describes an update for a destination in Amazon Redshift.</p>
        pub fn redshift_destination_update(
            mut self,
            input: crate::model::RedshiftDestinationUpdate,
        ) -> Self {
            self.inner = self.inner.redshift_destination_update(input);
            self
        }
        pub fn set_redshift_destination_update(
            mut self,
            input: std::option::Option<crate::model::RedshiftDestinationUpdate>,
        ) -> Self {
            self.inner = self.inner.set_redshift_destination_update(input);
            self
        }
        /// <p>Describes an update for a destination in Amazon ES.</p>
        pub fn elasticsearch_destination_update(
            mut self,
            input: crate::model::ElasticsearchDestinationUpdate,
        ) -> Self {
            self.inner = self.inner.elasticsearch_destination_update(input);
            self
        }
        pub fn set_elasticsearch_destination_update(
            mut self,
            input: std::option::Option<crate::model::ElasticsearchDestinationUpdate>,
        ) -> Self {
            self.inner = self.inner.set_elasticsearch_destination_update(input);
            self
        }
        /// <p>Describes an update for a destination in Splunk.</p>
        pub fn splunk_destination_update(
            mut self,
            input: crate::model::SplunkDestinationUpdate,
        ) -> Self {
            self.inner = self.inner.splunk_destination_update(input);
            self
        }
        pub fn set_splunk_destination_update(
            mut self,
            input: std::option::Option<crate::model::SplunkDestinationUpdate>,
        ) -> Self {
            self.inner = self.inner.set_splunk_destination_update(input);
            self
        }
        /// <p>Describes an update to the specified HTTP endpoint destination.</p>
        pub fn http_endpoint_destination_update(
            mut self,
            input: crate::model::HttpEndpointDestinationUpdate,
        ) -> Self {
            self.inner = self.inner.http_endpoint_destination_update(input);
            self
        }
        pub fn set_http_endpoint_destination_update(
            mut self,
            input: std::option::Option<crate::model::HttpEndpointDestinationUpdate>,
        ) -> Self {
            self.inner = self.inner.set_http_endpoint_destination_update(input);
            self
        }
    }
}
