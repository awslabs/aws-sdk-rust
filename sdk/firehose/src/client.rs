// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    client: smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `Firehose_20150804`.
///
/// This client allows ergonomic access to a `Firehose_20150804`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use smithy_client::Builder;

impl<C, M, R> From<smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    pub fn with_config(client: smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: smithy_client::bounds::SmithyConnector,
    M: smithy_client::bounds::SmithyMiddleware<C>,
    R: smithy_client::retry::NewRequestPolicy,
{
    pub fn create_delivery_stream(&self) -> fluent_builders::CreateDeliveryStream<C, M, R> {
        fluent_builders::CreateDeliveryStream::new(self.handle.clone())
    }
    pub fn delete_delivery_stream(&self) -> fluent_builders::DeleteDeliveryStream<C, M, R> {
        fluent_builders::DeleteDeliveryStream::new(self.handle.clone())
    }
    pub fn describe_delivery_stream(&self) -> fluent_builders::DescribeDeliveryStream<C, M, R> {
        fluent_builders::DescribeDeliveryStream::new(self.handle.clone())
    }
    pub fn list_delivery_streams(&self) -> fluent_builders::ListDeliveryStreams<C, M, R> {
        fluent_builders::ListDeliveryStreams::new(self.handle.clone())
    }
    pub fn list_tags_for_delivery_stream(
        &self,
    ) -> fluent_builders::ListTagsForDeliveryStream<C, M, R> {
        fluent_builders::ListTagsForDeliveryStream::new(self.handle.clone())
    }
    pub fn put_record(&self) -> fluent_builders::PutRecord<C, M, R> {
        fluent_builders::PutRecord::new(self.handle.clone())
    }
    pub fn put_record_batch(&self) -> fluent_builders::PutRecordBatch<C, M, R> {
        fluent_builders::PutRecordBatch::new(self.handle.clone())
    }
    pub fn start_delivery_stream_encryption(
        &self,
    ) -> fluent_builders::StartDeliveryStreamEncryption<C, M, R> {
        fluent_builders::StartDeliveryStreamEncryption::new(self.handle.clone())
    }
    pub fn stop_delivery_stream_encryption(
        &self,
    ) -> fluent_builders::StopDeliveryStreamEncryption<C, M, R> {
        fluent_builders::StopDeliveryStreamEncryption::new(self.handle.clone())
    }
    pub fn tag_delivery_stream(&self) -> fluent_builders::TagDeliveryStream<C, M, R> {
        fluent_builders::TagDeliveryStream::new(self.handle.clone())
    }
    pub fn untag_delivery_stream(&self) -> fluent_builders::UntagDeliveryStream<C, M, R> {
        fluent_builders::UntagDeliveryStream::new(self.handle.clone())
    }
    pub fn update_destination(&self) -> fluent_builders::UpdateDestination<C, M, R> {
        fluent_builders::UpdateDestination::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CreateDeliveryStream<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_delivery_stream_input::Builder,
    }
    impl<C, M, R> CreateDeliveryStream<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDeliveryStreamOutput,
            smithy_http::result::SdkError<crate::error::CreateDeliveryStreamError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateDeliveryStreamInputOperationOutputAlias,
                crate::output::CreateDeliveryStreamOutput,
                crate::error::CreateDeliveryStreamError,
                crate::input::CreateDeliveryStreamInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream. This name must be unique per AWS account in the same
        /// AWS Region. If the delivery streams are in different accounts or different Regions, you can
        /// have multiple delivery streams with the same name.</p>
        pub fn delivery_stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(inp);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// <p>The delivery stream type. This parameter can be one of the following
        /// values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DirectPut</code>: Provider applications access the delivery stream
        /// directly.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>KinesisStreamAsSource</code>: The delivery stream uses a Kinesis data
        /// stream as a source.</p>
        /// </li>
        /// </ul>
        pub fn delivery_stream_type(mut self, inp: crate::model::DeliveryStreamType) -> Self {
            self.inner = self.inner.delivery_stream_type(inp);
            self
        }
        pub fn set_delivery_stream_type(
            mut self,
            input: std::option::Option<crate::model::DeliveryStreamType>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_type(input);
            self
        }
        /// <p>When a Kinesis data stream is used as the source for the delivery stream, a <a>KinesisStreamSourceConfiguration</a> containing the Kinesis data stream Amazon
        /// Resource Name (ARN) and the role ARN for the source stream.</p>
        pub fn kinesis_stream_source_configuration(
            mut self,
            inp: crate::model::KinesisStreamSourceConfiguration,
        ) -> Self {
            self.inner = self.inner.kinesis_stream_source_configuration(inp);
            self
        }
        pub fn set_kinesis_stream_source_configuration(
            mut self,
            input: std::option::Option<crate::model::KinesisStreamSourceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_kinesis_stream_source_configuration(input);
            self
        }
        /// <p>Used to specify the type and Amazon Resource Name (ARN) of the KMS key needed for
        /// Server-Side Encryption (SSE).</p>
        pub fn delivery_stream_encryption_configuration_input(
            mut self,
            inp: crate::model::DeliveryStreamEncryptionConfigurationInput,
        ) -> Self {
            self.inner = self
                .inner
                .delivery_stream_encryption_configuration_input(inp);
            self
        }
        pub fn set_delivery_stream_encryption_configuration_input(
            mut self,
            input: std::option::Option<crate::model::DeliveryStreamEncryptionConfigurationInput>,
        ) -> Self {
            self.inner = self
                .inner
                .set_delivery_stream_encryption_configuration_input(input);
            self
        }
        /// <p>[Deprecated]
        /// The destination in Amazon S3. You can specify only one destination.</p>
        pub fn s3_destination_configuration(
            mut self,
            inp: crate::model::S3DestinationConfiguration,
        ) -> Self {
            self.inner = self.inner.s3_destination_configuration(inp);
            self
        }
        pub fn set_s3_destination_configuration(
            mut self,
            input: std::option::Option<crate::model::S3DestinationConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_s3_destination_configuration(input);
            self
        }
        /// <p>The destination in Amazon S3. You can specify only one destination.</p>
        pub fn extended_s3_destination_configuration(
            mut self,
            inp: crate::model::ExtendedS3DestinationConfiguration,
        ) -> Self {
            self.inner = self.inner.extended_s3_destination_configuration(inp);
            self
        }
        pub fn set_extended_s3_destination_configuration(
            mut self,
            input: std::option::Option<crate::model::ExtendedS3DestinationConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_extended_s3_destination_configuration(input);
            self
        }
        /// <p>The destination in Amazon Redshift. You can specify only one destination.</p>
        pub fn redshift_destination_configuration(
            mut self,
            inp: crate::model::RedshiftDestinationConfiguration,
        ) -> Self {
            self.inner = self.inner.redshift_destination_configuration(inp);
            self
        }
        pub fn set_redshift_destination_configuration(
            mut self,
            input: std::option::Option<crate::model::RedshiftDestinationConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_redshift_destination_configuration(input);
            self
        }
        /// <p>The destination in Amazon ES. You can specify only one destination.</p>
        pub fn elasticsearch_destination_configuration(
            mut self,
            inp: crate::model::ElasticsearchDestinationConfiguration,
        ) -> Self {
            self.inner = self.inner.elasticsearch_destination_configuration(inp);
            self
        }
        pub fn set_elasticsearch_destination_configuration(
            mut self,
            input: std::option::Option<crate::model::ElasticsearchDestinationConfiguration>,
        ) -> Self {
            self.inner = self
                .inner
                .set_elasticsearch_destination_configuration(input);
            self
        }
        pub fn amazonopensearchservice_destination_configuration(
            mut self,
            inp: crate::model::AmazonopensearchserviceDestinationConfiguration,
        ) -> Self {
            self.inner = self
                .inner
                .amazonopensearchservice_destination_configuration(inp);
            self
        }
        pub fn set_amazonopensearchservice_destination_configuration(
            mut self,
            input: std::option::Option<
                crate::model::AmazonopensearchserviceDestinationConfiguration,
            >,
        ) -> Self {
            self.inner = self
                .inner
                .set_amazonopensearchservice_destination_configuration(input);
            self
        }
        /// <p>The destination in Splunk. You can specify only one destination.</p>
        pub fn splunk_destination_configuration(
            mut self,
            inp: crate::model::SplunkDestinationConfiguration,
        ) -> Self {
            self.inner = self.inner.splunk_destination_configuration(inp);
            self
        }
        pub fn set_splunk_destination_configuration(
            mut self,
            input: std::option::Option<crate::model::SplunkDestinationConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_splunk_destination_configuration(input);
            self
        }
        /// <p>Enables configuring Kinesis Firehose to deliver data to any HTTP endpoint destination.
        /// You can specify only one destination.</p>
        pub fn http_endpoint_destination_configuration(
            mut self,
            inp: crate::model::HttpEndpointDestinationConfiguration,
        ) -> Self {
            self.inner = self.inner.http_endpoint_destination_configuration(inp);
            self
        }
        pub fn set_http_endpoint_destination_configuration(
            mut self,
            input: std::option::Option<crate::model::HttpEndpointDestinationConfiguration>,
        ) -> Self {
            self.inner = self
                .inner
                .set_http_endpoint_destination_configuration(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>A set of tags to assign to the delivery stream. A tag is a key-value pair that you can
        /// define and assign to AWS resources. Tags are metadata. For example, you can add friendly
        /// names and descriptions or other types of information that can help you distinguish the
        /// delivery stream. For more information about tags, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation
        /// Tags</a> in the AWS Billing and Cost Management User Guide.</p>
        /// <p>You can specify up to 50 tags when creating a delivery stream.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDeliveryStream<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_delivery_stream_input::Builder,
    }
    impl<C, M, R> DeleteDeliveryStream<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDeliveryStreamOutput,
            smithy_http::result::SdkError<crate::error::DeleteDeliveryStreamError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteDeliveryStreamInputOperationOutputAlias,
                crate::output::DeleteDeliveryStreamOutput,
                crate::error::DeleteDeliveryStreamError,
                crate::input::DeleteDeliveryStreamInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream.</p>
        pub fn delivery_stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(inp);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// <p>Set this to true if you want to delete the delivery stream even if Kinesis Data Firehose
        /// is unable to retire the grant for the CMK. Kinesis Data Firehose might be unable to retire
        /// the grant due to a customer error, such as when the CMK or the grant are in an invalid
        /// state. If you force deletion, you can then use the <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_RevokeGrant.html">RevokeGrant</a> operation to
        /// revoke the grant you gave to Kinesis Data Firehose. If a failure to retire the grant
        /// happens due to an AWS KMS issue, Kinesis Data Firehose keeps retrying the delete
        /// operation.</p>
        /// <p>The default value is false.</p>
        pub fn allow_force_delete(mut self, inp: bool) -> Self {
            self.inner = self.inner.allow_force_delete(inp);
            self
        }
        pub fn set_allow_force_delete(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_allow_force_delete(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeDeliveryStream<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_delivery_stream_input::Builder,
    }
    impl<C, M, R> DescribeDeliveryStream<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeDeliveryStreamOutput,
            smithy_http::result::SdkError<crate::error::DescribeDeliveryStreamError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeDeliveryStreamInputOperationOutputAlias,
                crate::output::DescribeDeliveryStreamOutput,
                crate::error::DescribeDeliveryStreamError,
                crate::input::DescribeDeliveryStreamInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream.</p>
        pub fn delivery_stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(inp);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// <p>The limit on the number of destinations to return. You can have one destination per
        /// delivery stream.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>The ID of the destination to start returning the destination information. Kinesis
        /// Data Firehose supports one destination per delivery stream.</p>
        pub fn exclusive_start_destination_id(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.exclusive_start_destination_id(inp);
            self
        }
        pub fn set_exclusive_start_destination_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_exclusive_start_destination_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDeliveryStreams<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_delivery_streams_input::Builder,
    }
    impl<C, M, R> ListDeliveryStreams<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDeliveryStreamsOutput,
            smithy_http::result::SdkError<crate::error::ListDeliveryStreamsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListDeliveryStreamsInputOperationOutputAlias,
                crate::output::ListDeliveryStreamsOutput,
                crate::error::ListDeliveryStreamsError,
                crate::input::ListDeliveryStreamsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of delivery streams to list. The default value is 10.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>The delivery stream type. This can be one of the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DirectPut</code>: Provider applications access the delivery stream
        /// directly.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>KinesisStreamAsSource</code>: The delivery stream uses a Kinesis data
        /// stream as a source.</p>
        /// </li>
        /// </ul>
        /// <p>This parameter is optional. If this parameter is omitted, delivery streams of all
        /// types are returned.</p>
        pub fn delivery_stream_type(mut self, inp: crate::model::DeliveryStreamType) -> Self {
            self.inner = self.inner.delivery_stream_type(inp);
            self
        }
        pub fn set_delivery_stream_type(
            mut self,
            input: std::option::Option<crate::model::DeliveryStreamType>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_type(input);
            self
        }
        /// <p>The list of delivery streams returned by this call to
        /// <code>ListDeliveryStreams</code> will start with the delivery stream whose name comes
        /// alphabetically immediately after the name you specify in
        /// <code>ExclusiveStartDeliveryStreamName</code>.</p>
        pub fn exclusive_start_delivery_stream_name(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.exclusive_start_delivery_stream_name(inp);
            self
        }
        pub fn set_exclusive_start_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_exclusive_start_delivery_stream_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForDeliveryStream<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_tags_for_delivery_stream_input::Builder,
    }
    impl<C, M, R> ListTagsForDeliveryStream<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForDeliveryStreamOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForDeliveryStreamError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListTagsForDeliveryStreamInputOperationOutputAlias,
                crate::output::ListTagsForDeliveryStreamOutput,
                crate::error::ListTagsForDeliveryStreamError,
                crate::input::ListTagsForDeliveryStreamInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream whose tags you want to list.</p>
        pub fn delivery_stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(inp);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// <p>The key to use as the starting point for the list of tags. If you set this parameter,
        /// <code>ListTagsForDeliveryStream</code> gets all tags that occur after
        /// <code>ExclusiveStartTagKey</code>.</p>
        pub fn exclusive_start_tag_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.exclusive_start_tag_key(inp);
            self
        }
        pub fn set_exclusive_start_tag_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_exclusive_start_tag_key(input);
            self
        }
        /// <p>The number of tags to return. If this number is less than the total number of tags
        /// associated with the delivery stream, <code>HasMoreTags</code> is set to <code>true</code>
        /// in the response. To list additional tags, set <code>ExclusiveStartTagKey</code> to the last
        /// key in the response. </p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutRecord<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::put_record_input::Builder,
    }
    impl<C, M, R> PutRecord<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutRecordOutput,
            smithy_http::result::SdkError<crate::error::PutRecordError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PutRecordInputOperationOutputAlias,
                crate::output::PutRecordOutput,
                crate::error::PutRecordError,
                crate::input::PutRecordInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream.</p>
        pub fn delivery_stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(inp);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// <p>The record.</p>
        pub fn record(mut self, inp: crate::model::Record) -> Self {
            self.inner = self.inner.record(inp);
            self
        }
        pub fn set_record(mut self, input: std::option::Option<crate::model::Record>) -> Self {
            self.inner = self.inner.set_record(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutRecordBatch<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::put_record_batch_input::Builder,
    }
    impl<C, M, R> PutRecordBatch<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutRecordBatchOutput,
            smithy_http::result::SdkError<crate::error::PutRecordBatchError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PutRecordBatchInputOperationOutputAlias,
                crate::output::PutRecordBatchOutput,
                crate::error::PutRecordBatchError,
                crate::input::PutRecordBatchInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream.</p>
        pub fn delivery_stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(inp);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// Appends an item to `Records`.
        ///
        /// To override the contents of this collection use [`set_records`](Self::set_records).
        /// <p>One or more records.</p>
        pub fn records(mut self, inp: impl Into<crate::model::Record>) -> Self {
            self.inner = self.inner.records(inp);
            self
        }
        pub fn set_records(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Record>>,
        ) -> Self {
            self.inner = self.inner.set_records(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartDeliveryStreamEncryption<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_delivery_stream_encryption_input::Builder,
    }
    impl<C, M, R> StartDeliveryStreamEncryption<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartDeliveryStreamEncryptionOutput,
            smithy_http::result::SdkError<crate::error::StartDeliveryStreamEncryptionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartDeliveryStreamEncryptionInputOperationOutputAlias,
                crate::output::StartDeliveryStreamEncryptionOutput,
                crate::error::StartDeliveryStreamEncryptionError,
                crate::input::StartDeliveryStreamEncryptionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream for which you want to enable server-side encryption
        /// (SSE).</p>
        pub fn delivery_stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(inp);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// <p>Used to specify the type and Amazon Resource Name (ARN) of the KMS key needed for
        /// Server-Side Encryption (SSE).</p>
        pub fn delivery_stream_encryption_configuration_input(
            mut self,
            inp: crate::model::DeliveryStreamEncryptionConfigurationInput,
        ) -> Self {
            self.inner = self
                .inner
                .delivery_stream_encryption_configuration_input(inp);
            self
        }
        pub fn set_delivery_stream_encryption_configuration_input(
            mut self,
            input: std::option::Option<crate::model::DeliveryStreamEncryptionConfigurationInput>,
        ) -> Self {
            self.inner = self
                .inner
                .set_delivery_stream_encryption_configuration_input(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopDeliveryStreamEncryption<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::stop_delivery_stream_encryption_input::Builder,
    }
    impl<C, M, R> StopDeliveryStreamEncryption<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopDeliveryStreamEncryptionOutput,
            smithy_http::result::SdkError<crate::error::StopDeliveryStreamEncryptionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StopDeliveryStreamEncryptionInputOperationOutputAlias,
                crate::output::StopDeliveryStreamEncryptionOutput,
                crate::error::StopDeliveryStreamEncryptionError,
                crate::input::StopDeliveryStreamEncryptionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream for which you want to disable server-side encryption
        /// (SSE).</p>
        pub fn delivery_stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(inp);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagDeliveryStream<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::tag_delivery_stream_input::Builder,
    }
    impl<C, M, R> TagDeliveryStream<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagDeliveryStreamOutput,
            smithy_http::result::SdkError<crate::error::TagDeliveryStreamError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::TagDeliveryStreamInputOperationOutputAlias,
                crate::output::TagDeliveryStreamOutput,
                crate::error::TagDeliveryStreamError,
                crate::input::TagDeliveryStreamInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream to which you want to add the tags.</p>
        pub fn delivery_stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(inp);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>A set of key-value pairs to use to create the tags.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagDeliveryStream<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::untag_delivery_stream_input::Builder,
    }
    impl<C, M, R> UntagDeliveryStream<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagDeliveryStreamOutput,
            smithy_http::result::SdkError<crate::error::UntagDeliveryStreamError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UntagDeliveryStreamInputOperationOutputAlias,
                crate::output::UntagDeliveryStreamOutput,
                crate::error::UntagDeliveryStreamError,
                crate::input::UntagDeliveryStreamInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream.</p>
        pub fn delivery_stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(inp);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// Appends an item to `TagKeys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        /// <p>A list of tag keys. Each corresponding tag is removed from the delivery
        /// stream.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDestination<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_destination_input::Builder,
    }
    impl<C, M, R> UpdateDestination<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDestinationOutput,
            smithy_http::result::SdkError<crate::error::UpdateDestinationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateDestinationInputOperationOutputAlias,
                crate::output::UpdateDestinationOutput,
                crate::error::UpdateDestinationError,
                crate::input::UpdateDestinationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the delivery stream.</p>
        pub fn delivery_stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delivery_stream_name(inp);
            self
        }
        pub fn set_delivery_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delivery_stream_name(input);
            self
        }
        /// <p>Obtain this value from the <code>VersionId</code> result of <a>DeliveryStreamDescription</a>. This value is required, and helps the service
        /// perform conditional operations. For example, if there is an interleaving update and this
        /// value is null, then the update destination fails. After the update is successful, the
        /// <code>VersionId</code> value is updated. The service then performs a merge of the old
        /// configuration with the new configuration.</p>
        pub fn current_delivery_stream_version_id(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.current_delivery_stream_version_id(inp);
            self
        }
        pub fn set_current_delivery_stream_version_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_current_delivery_stream_version_id(input);
            self
        }
        /// <p>The ID of the destination.</p>
        pub fn destination_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_id(inp);
            self
        }
        pub fn set_destination_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_id(input);
            self
        }
        /// <p>[Deprecated] Describes an update for a destination in Amazon S3.</p>
        pub fn s3_destination_update(mut self, inp: crate::model::S3DestinationUpdate) -> Self {
            self.inner = self.inner.s3_destination_update(inp);
            self
        }
        pub fn set_s3_destination_update(
            mut self,
            input: std::option::Option<crate::model::S3DestinationUpdate>,
        ) -> Self {
            self.inner = self.inner.set_s3_destination_update(input);
            self
        }
        /// <p>Describes an update for a destination in Amazon S3.</p>
        pub fn extended_s3_destination_update(
            mut self,
            inp: crate::model::ExtendedS3DestinationUpdate,
        ) -> Self {
            self.inner = self.inner.extended_s3_destination_update(inp);
            self
        }
        pub fn set_extended_s3_destination_update(
            mut self,
            input: std::option::Option<crate::model::ExtendedS3DestinationUpdate>,
        ) -> Self {
            self.inner = self.inner.set_extended_s3_destination_update(input);
            self
        }
        /// <p>Describes an update for a destination in Amazon Redshift.</p>
        pub fn redshift_destination_update(
            mut self,
            inp: crate::model::RedshiftDestinationUpdate,
        ) -> Self {
            self.inner = self.inner.redshift_destination_update(inp);
            self
        }
        pub fn set_redshift_destination_update(
            mut self,
            input: std::option::Option<crate::model::RedshiftDestinationUpdate>,
        ) -> Self {
            self.inner = self.inner.set_redshift_destination_update(input);
            self
        }
        /// <p>Describes an update for a destination in Amazon ES.</p>
        pub fn elasticsearch_destination_update(
            mut self,
            inp: crate::model::ElasticsearchDestinationUpdate,
        ) -> Self {
            self.inner = self.inner.elasticsearch_destination_update(inp);
            self
        }
        pub fn set_elasticsearch_destination_update(
            mut self,
            input: std::option::Option<crate::model::ElasticsearchDestinationUpdate>,
        ) -> Self {
            self.inner = self.inner.set_elasticsearch_destination_update(input);
            self
        }
        pub fn amazonopensearchservice_destination_update(
            mut self,
            inp: crate::model::AmazonopensearchserviceDestinationUpdate,
        ) -> Self {
            self.inner = self.inner.amazonopensearchservice_destination_update(inp);
            self
        }
        pub fn set_amazonopensearchservice_destination_update(
            mut self,
            input: std::option::Option<crate::model::AmazonopensearchserviceDestinationUpdate>,
        ) -> Self {
            self.inner = self
                .inner
                .set_amazonopensearchservice_destination_update(input);
            self
        }
        /// <p>Describes an update for a destination in Splunk.</p>
        pub fn splunk_destination_update(
            mut self,
            inp: crate::model::SplunkDestinationUpdate,
        ) -> Self {
            self.inner = self.inner.splunk_destination_update(inp);
            self
        }
        pub fn set_splunk_destination_update(
            mut self,
            input: std::option::Option<crate::model::SplunkDestinationUpdate>,
        ) -> Self {
            self.inner = self.inner.set_splunk_destination_update(input);
            self
        }
        /// <p>Describes an update to the specified HTTP endpoint destination.</p>
        pub fn http_endpoint_destination_update(
            mut self,
            inp: crate::model::HttpEndpointDestinationUpdate,
        ) -> Self {
            self.inner = self.inner.http_endpoint_destination_update(inp);
            self
        }
        pub fn set_http_endpoint_destination_update(
            mut self,
            input: std::option::Option<crate::model::HttpEndpointDestinationUpdate>,
        ) -> Self {
            self.inner = self.inner.set_http_endpoint_destination_update(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, smithy_client::retry::Standard> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::new(conn).with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        smithy_client::retry::Standard,
    >
{
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::https().with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
