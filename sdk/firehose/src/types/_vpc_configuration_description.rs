// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The details of the VPC of the Amazon ES destination.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VpcConfigurationDescription {
    /// <p>The IDs of the subnets that Kinesis Data Firehose uses to create ENIs in the VPC of the Amazon ES destination. Make sure that the routing tables and inbound and outbound rules allow traffic to flow from the subnets whose IDs are specified here to the subnets that have the destination Amazon ES endpoints. Kinesis Data Firehose creates at least one ENI in each of the subnets that are specified here. Do not delete or modify these ENIs.</p>
    /// <p>The number of ENIs that Kinesis Data Firehose creates in the subnets specified here scales up and down automatically based on throughput. To enable Kinesis Data Firehose to scale up the number of ENIs to match throughput, ensure that you have sufficient quota. To help you calculate the quota you need, assume that Kinesis Data Firehose can create up to three ENIs for this delivery stream for each of the subnets specified here. For more information about ENI quota, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/amazon-vpc-limits.html#vpc-limits-enis">Network Interfaces </a> in the Amazon VPC Quotas topic.</p>
    #[doc(hidden)]
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ARN of the IAM role that the delivery stream uses to create endpoints in the destination VPC. You can use your existing Kinesis Data Firehose delivery role or you can specify a new role. In either case, make sure that the role trusts the Kinesis Data Firehose service principal and that it grants the following permissions:</p>
    /// <ul>
    /// <li> <p> <code>ec2:DescribeVpcs</code> </p> </li>
    /// <li> <p> <code>ec2:DescribeVpcAttribute</code> </p> </li>
    /// <li> <p> <code>ec2:DescribeSubnets</code> </p> </li>
    /// <li> <p> <code>ec2:DescribeSecurityGroups</code> </p> </li>
    /// <li> <p> <code>ec2:DescribeNetworkInterfaces</code> </p> </li>
    /// <li> <p> <code>ec2:CreateNetworkInterface</code> </p> </li>
    /// <li> <p> <code>ec2:CreateNetworkInterfacePermission</code> </p> </li>
    /// <li> <p> <code>ec2:DeleteNetworkInterface</code> </p> </li>
    /// </ul>
    /// <p>If you revoke these permissions after you create the delivery stream, Kinesis Data Firehose can't scale out by creating more ENIs when necessary. You might therefore see a degradation in performance.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The IDs of the security groups that Kinesis Data Firehose uses when it creates ENIs in the VPC of the Amazon ES destination. You can use the same security group that the Amazon ES domain uses or different ones. If you specify different security groups, ensure that they allow outbound HTTPS traffic to the Amazon ES domain's security group. Also ensure that the Amazon ES domain's security group allows HTTPS traffic from the security groups specified here. If you use the same security group for both your delivery stream and the Amazon ES domain, make sure the security group inbound rule allows HTTPS traffic. For more information about security group rules, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html#SecurityGroupRules">Security group rules</a> in the Amazon VPC documentation.</p>
    #[doc(hidden)]
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the Amazon ES destination's VPC.</p>
    #[doc(hidden)]
    pub vpc_id: std::option::Option<std::string::String>,
}
impl VpcConfigurationDescription {
    /// <p>The IDs of the subnets that Kinesis Data Firehose uses to create ENIs in the VPC of the Amazon ES destination. Make sure that the routing tables and inbound and outbound rules allow traffic to flow from the subnets whose IDs are specified here to the subnets that have the destination Amazon ES endpoints. Kinesis Data Firehose creates at least one ENI in each of the subnets that are specified here. Do not delete or modify these ENIs.</p>
    /// <p>The number of ENIs that Kinesis Data Firehose creates in the subnets specified here scales up and down automatically based on throughput. To enable Kinesis Data Firehose to scale up the number of ENIs to match throughput, ensure that you have sufficient quota. To help you calculate the quota you need, assume that Kinesis Data Firehose can create up to three ENIs for this delivery stream for each of the subnets specified here. For more information about ENI quota, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/amazon-vpc-limits.html#vpc-limits-enis">Network Interfaces </a> in the Amazon VPC Quotas topic.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>The ARN of the IAM role that the delivery stream uses to create endpoints in the destination VPC. You can use your existing Kinesis Data Firehose delivery role or you can specify a new role. In either case, make sure that the role trusts the Kinesis Data Firehose service principal and that it grants the following permissions:</p>
    /// <ul>
    /// <li> <p> <code>ec2:DescribeVpcs</code> </p> </li>
    /// <li> <p> <code>ec2:DescribeVpcAttribute</code> </p> </li>
    /// <li> <p> <code>ec2:DescribeSubnets</code> </p> </li>
    /// <li> <p> <code>ec2:DescribeSecurityGroups</code> </p> </li>
    /// <li> <p> <code>ec2:DescribeNetworkInterfaces</code> </p> </li>
    /// <li> <p> <code>ec2:CreateNetworkInterface</code> </p> </li>
    /// <li> <p> <code>ec2:CreateNetworkInterfacePermission</code> </p> </li>
    /// <li> <p> <code>ec2:DeleteNetworkInterface</code> </p> </li>
    /// </ul>
    /// <p>If you revoke these permissions after you create the delivery stream, Kinesis Data Firehose can't scale out by creating more ENIs when necessary. You might therefore see a degradation in performance.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The IDs of the security groups that Kinesis Data Firehose uses when it creates ENIs in the VPC of the Amazon ES destination. You can use the same security group that the Amazon ES domain uses or different ones. If you specify different security groups, ensure that they allow outbound HTTPS traffic to the Amazon ES domain's security group. Also ensure that the Amazon ES domain's security group allows HTTPS traffic from the security groups specified here. If you use the same security group for both your delivery stream and the Amazon ES domain, make sure the security group inbound rule allows HTTPS traffic. For more information about security group rules, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html#SecurityGroupRules">Security group rules</a> in the Amazon VPC documentation.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
    /// <p>The ID of the Amazon ES destination's VPC.</p>
    pub fn vpc_id(&self) -> std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
}
impl VpcConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`VpcConfigurationDescription`](crate::types::VpcConfigurationDescription).
    pub fn builder() -> crate::types::builders::VpcConfigurationDescriptionBuilder {
        crate::types::builders::VpcConfigurationDescriptionBuilder::default()
    }
}

/// A builder for [`VpcConfigurationDescription`](crate::types::VpcConfigurationDescription).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct VpcConfigurationDescriptionBuilder {
    pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) role_arn: std::option::Option<std::string::String>,
    pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) vpc_id: std::option::Option<std::string::String>,
}
impl VpcConfigurationDescriptionBuilder {
    /// Appends an item to `subnet_ids`.
    ///
    /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
    ///
    /// <p>The IDs of the subnets that Kinesis Data Firehose uses to create ENIs in the VPC of the Amazon ES destination. Make sure that the routing tables and inbound and outbound rules allow traffic to flow from the subnets whose IDs are specified here to the subnets that have the destination Amazon ES endpoints. Kinesis Data Firehose creates at least one ENI in each of the subnets that are specified here. Do not delete or modify these ENIs.</p>
    /// <p>The number of ENIs that Kinesis Data Firehose creates in the subnets specified here scales up and down automatically based on throughput. To enable Kinesis Data Firehose to scale up the number of ENIs to match throughput, ensure that you have sufficient quota. To help you calculate the quota you need, assume that Kinesis Data Firehose can create up to three ENIs for this delivery stream for each of the subnets specified here. For more information about ENI quota, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/amazon-vpc-limits.html#vpc-limits-enis">Network Interfaces </a> in the Amazon VPC Quotas topic.</p>
    pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.subnet_ids.unwrap_or_default();
        v.push(input.into());
        self.subnet_ids = Some(v);
        self
    }
    /// <p>The IDs of the subnets that Kinesis Data Firehose uses to create ENIs in the VPC of the Amazon ES destination. Make sure that the routing tables and inbound and outbound rules allow traffic to flow from the subnets whose IDs are specified here to the subnets that have the destination Amazon ES endpoints. Kinesis Data Firehose creates at least one ENI in each of the subnets that are specified here. Do not delete or modify these ENIs.</p>
    /// <p>The number of ENIs that Kinesis Data Firehose creates in the subnets specified here scales up and down automatically based on throughput. To enable Kinesis Data Firehose to scale up the number of ENIs to match throughput, ensure that you have sufficient quota. To help you calculate the quota you need, assume that Kinesis Data Firehose can create up to three ENIs for this delivery stream for each of the subnets specified here. For more information about ENI quota, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/amazon-vpc-limits.html#vpc-limits-enis">Network Interfaces </a> in the Amazon VPC Quotas topic.</p>
    pub fn set_subnet_ids(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.subnet_ids = input;
        self
    }
    /// <p>The ARN of the IAM role that the delivery stream uses to create endpoints in the destination VPC. You can use your existing Kinesis Data Firehose delivery role or you can specify a new role. In either case, make sure that the role trusts the Kinesis Data Firehose service principal and that it grants the following permissions:</p>
    /// <ul>
    /// <li> <p> <code>ec2:DescribeVpcs</code> </p> </li>
    /// <li> <p> <code>ec2:DescribeVpcAttribute</code> </p> </li>
    /// <li> <p> <code>ec2:DescribeSubnets</code> </p> </li>
    /// <li> <p> <code>ec2:DescribeSecurityGroups</code> </p> </li>
    /// <li> <p> <code>ec2:DescribeNetworkInterfaces</code> </p> </li>
    /// <li> <p> <code>ec2:CreateNetworkInterface</code> </p> </li>
    /// <li> <p> <code>ec2:CreateNetworkInterfacePermission</code> </p> </li>
    /// <li> <p> <code>ec2:DeleteNetworkInterface</code> </p> </li>
    /// </ul>
    /// <p>If you revoke these permissions after you create the delivery stream, Kinesis Data Firehose can't scale out by creating more ENIs when necessary. You might therefore see a degradation in performance.</p>
    pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.role_arn = Some(input.into());
        self
    }
    /// <p>The ARN of the IAM role that the delivery stream uses to create endpoints in the destination VPC. You can use your existing Kinesis Data Firehose delivery role or you can specify a new role. In either case, make sure that the role trusts the Kinesis Data Firehose service principal and that it grants the following permissions:</p>
    /// <ul>
    /// <li> <p> <code>ec2:DescribeVpcs</code> </p> </li>
    /// <li> <p> <code>ec2:DescribeVpcAttribute</code> </p> </li>
    /// <li> <p> <code>ec2:DescribeSubnets</code> </p> </li>
    /// <li> <p> <code>ec2:DescribeSecurityGroups</code> </p> </li>
    /// <li> <p> <code>ec2:DescribeNetworkInterfaces</code> </p> </li>
    /// <li> <p> <code>ec2:CreateNetworkInterface</code> </p> </li>
    /// <li> <p> <code>ec2:CreateNetworkInterfacePermission</code> </p> </li>
    /// <li> <p> <code>ec2:DeleteNetworkInterface</code> </p> </li>
    /// </ul>
    /// <p>If you revoke these permissions after you create the delivery stream, Kinesis Data Firehose can't scale out by creating more ENIs when necessary. You might therefore see a degradation in performance.</p>
    pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.role_arn = input;
        self
    }
    /// Appends an item to `security_group_ids`.
    ///
    /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
    ///
    /// <p>The IDs of the security groups that Kinesis Data Firehose uses when it creates ENIs in the VPC of the Amazon ES destination. You can use the same security group that the Amazon ES domain uses or different ones. If you specify different security groups, ensure that they allow outbound HTTPS traffic to the Amazon ES domain's security group. Also ensure that the Amazon ES domain's security group allows HTTPS traffic from the security groups specified here. If you use the same security group for both your delivery stream and the Amazon ES domain, make sure the security group inbound rule allows HTTPS traffic. For more information about security group rules, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html#SecurityGroupRules">Security group rules</a> in the Amazon VPC documentation.</p>
    pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.security_group_ids.unwrap_or_default();
        v.push(input.into());
        self.security_group_ids = Some(v);
        self
    }
    /// <p>The IDs of the security groups that Kinesis Data Firehose uses when it creates ENIs in the VPC of the Amazon ES destination. You can use the same security group that the Amazon ES domain uses or different ones. If you specify different security groups, ensure that they allow outbound HTTPS traffic to the Amazon ES domain's security group. Also ensure that the Amazon ES domain's security group allows HTTPS traffic from the security groups specified here. If you use the same security group for both your delivery stream and the Amazon ES domain, make sure the security group inbound rule allows HTTPS traffic. For more information about security group rules, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html#SecurityGroupRules">Security group rules</a> in the Amazon VPC documentation.</p>
    pub fn set_security_group_ids(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.security_group_ids = input;
        self
    }
    /// <p>The ID of the Amazon ES destination's VPC.</p>
    pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.vpc_id = Some(input.into());
        self
    }
    /// <p>The ID of the Amazon ES destination's VPC.</p>
    pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.vpc_id = input;
        self
    }
    /// Consumes the builder and constructs a [`VpcConfigurationDescription`](crate::types::VpcConfigurationDescription).
    pub fn build(self) -> crate::types::VpcConfigurationDescription {
        crate::types::VpcConfigurationDescription {
            subnet_ids: self.subnet_ids,
            role_arn: self.role_arn,
            security_group_ids: self.security_group_ids,
            vpc_id: self.vpc_id,
        }
    }
}
