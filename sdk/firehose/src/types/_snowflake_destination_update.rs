// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Update to configuration settings</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct SnowflakeDestinationUpdate {
    /// <p>URL for accessing your Snowflake account. This URL must include your <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier">account identifier</a>. Note that the protocol (https://) and port number are optional.</p>
    pub account_url: ::std::option::Option<::std::string::String>,
    /// <p>The private key used to encrypt your Snowflake client. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    pub private_key: ::std::option::Option<::std::string::String>,
    /// <p>Passphrase to decrypt the private key when the key is encrypted. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    pub key_passphrase: ::std::option::Option<::std::string::String>,
    /// <p>User login name for the Snowflake account.</p>
    pub user: ::std::option::Option<::std::string::String>,
    /// <p>All data in Snowflake is maintained in databases.</p>
    pub database: ::std::option::Option<::std::string::String>,
    /// <p>Each database consists of one or more schemas, which are logical groupings of database objects, such as tables and views</p>
    pub schema: ::std::option::Option<::std::string::String>,
    /// <p>All data in Snowflake is stored in database tables, logically structured as collections of columns and rows.</p>
    pub table: ::std::option::Option<::std::string::String>,
    /// <p>Optionally configure a Snowflake role. Otherwise the default user role will be used.</p>
    pub snowflake_role_configuration: ::std::option::Option<crate::types::SnowflakeRoleConfiguration>,
    /// <p>JSON keys mapped to table column names or choose to split the JSON payload where content is mapped to a record content column and source metadata is mapped to a record metadata column.</p>
    pub data_loading_option: ::std::option::Option<crate::types::SnowflakeDataLoadingOption>,
    /// <p>The name of the record metadata column</p>
    pub meta_data_column_name: ::std::option::Option<::std::string::String>,
    /// <p>The name of the content metadata column</p>
    pub content_column_name: ::std::option::Option<::std::string::String>,
    /// <p>Describes the Amazon CloudWatch logging options for your delivery stream.</p>
    pub cloud_watch_logging_options: ::std::option::Option<crate::types::CloudWatchLoggingOptions>,
    /// <p>Describes a data processing configuration.</p>
    pub processing_configuration: ::std::option::Option<crate::types::ProcessingConfiguration>,
    /// <p>The Amazon Resource Name (ARN) of the Snowflake role</p>
    pub role_arn: ::std::option::Option<::std::string::String>,
    /// <p>Specify how long Firehose retries sending data to the New Relic HTTP endpoint. After sending data, Firehose first waits for an acknowledgment from the HTTP endpoint. If an error occurs or the acknowledgment doesn’t arrive within the acknowledgment timeout period, Firehose starts the retry duration counter. It keeps retrying until the retry duration expires. After that, Firehose considers it a data delivery failure and backs up the data to your Amazon S3 bucket. Every time that Firehose sends data to the HTTP endpoint (either the initial attempt or a retry), it restarts the acknowledgement timeout counter and waits for an acknowledgement from the HTTP endpoint. Even if the retry duration expires, Firehose still waits for the acknowledgment until it receives it or the acknowledgement timeout period is reached. If the acknowledgment times out, Firehose determines whether there's time left in the retry counter. If there is time left, it retries again and repeats the logic until it receives an acknowledgment or determines that the retry time has expired. If you don't want Firehose to retry sending data, set this value to 0.</p>
    pub retry_options: ::std::option::Option<crate::types::SnowflakeRetryOptions>,
    /// <p>Choose an S3 backup mode</p>
    pub s3_backup_mode: ::std::option::Option<crate::types::SnowflakeS3BackupMode>,
    /// <p>Describes an update for a destination in Amazon S3.</p>
    pub s3_update: ::std::option::Option<crate::types::S3DestinationUpdate>,
    /// <p>Describes the Secrets Manager configuration in Snowflake.</p>
    pub secrets_manager_configuration: ::std::option::Option<crate::types::SecretsManagerConfiguration>,
    /// <p>Describes the buffering to perform before delivering data to the Snowflake destination.</p>
    pub buffering_hints: ::std::option::Option<crate::types::SnowflakeBufferingHints>,
}
impl SnowflakeDestinationUpdate {
    /// <p>URL for accessing your Snowflake account. This URL must include your <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier">account identifier</a>. Note that the protocol (https://) and port number are optional.</p>
    pub fn account_url(&self) -> ::std::option::Option<&str> {
        self.account_url.as_deref()
    }
    /// <p>The private key used to encrypt your Snowflake client. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    pub fn private_key(&self) -> ::std::option::Option<&str> {
        self.private_key.as_deref()
    }
    /// <p>Passphrase to decrypt the private key when the key is encrypted. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    pub fn key_passphrase(&self) -> ::std::option::Option<&str> {
        self.key_passphrase.as_deref()
    }
    /// <p>User login name for the Snowflake account.</p>
    pub fn user(&self) -> ::std::option::Option<&str> {
        self.user.as_deref()
    }
    /// <p>All data in Snowflake is maintained in databases.</p>
    pub fn database(&self) -> ::std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>Each database consists of one or more schemas, which are logical groupings of database objects, such as tables and views</p>
    pub fn schema(&self) -> ::std::option::Option<&str> {
        self.schema.as_deref()
    }
    /// <p>All data in Snowflake is stored in database tables, logically structured as collections of columns and rows.</p>
    pub fn table(&self) -> ::std::option::Option<&str> {
        self.table.as_deref()
    }
    /// <p>Optionally configure a Snowflake role. Otherwise the default user role will be used.</p>
    pub fn snowflake_role_configuration(&self) -> ::std::option::Option<&crate::types::SnowflakeRoleConfiguration> {
        self.snowflake_role_configuration.as_ref()
    }
    /// <p>JSON keys mapped to table column names or choose to split the JSON payload where content is mapped to a record content column and source metadata is mapped to a record metadata column.</p>
    pub fn data_loading_option(&self) -> ::std::option::Option<&crate::types::SnowflakeDataLoadingOption> {
        self.data_loading_option.as_ref()
    }
    /// <p>The name of the record metadata column</p>
    pub fn meta_data_column_name(&self) -> ::std::option::Option<&str> {
        self.meta_data_column_name.as_deref()
    }
    /// <p>The name of the content metadata column</p>
    pub fn content_column_name(&self) -> ::std::option::Option<&str> {
        self.content_column_name.as_deref()
    }
    /// <p>Describes the Amazon CloudWatch logging options for your delivery stream.</p>
    pub fn cloud_watch_logging_options(&self) -> ::std::option::Option<&crate::types::CloudWatchLoggingOptions> {
        self.cloud_watch_logging_options.as_ref()
    }
    /// <p>Describes a data processing configuration.</p>
    pub fn processing_configuration(&self) -> ::std::option::Option<&crate::types::ProcessingConfiguration> {
        self.processing_configuration.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Snowflake role</p>
    pub fn role_arn(&self) -> ::std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>Specify how long Firehose retries sending data to the New Relic HTTP endpoint. After sending data, Firehose first waits for an acknowledgment from the HTTP endpoint. If an error occurs or the acknowledgment doesn’t arrive within the acknowledgment timeout period, Firehose starts the retry duration counter. It keeps retrying until the retry duration expires. After that, Firehose considers it a data delivery failure and backs up the data to your Amazon S3 bucket. Every time that Firehose sends data to the HTTP endpoint (either the initial attempt or a retry), it restarts the acknowledgement timeout counter and waits for an acknowledgement from the HTTP endpoint. Even if the retry duration expires, Firehose still waits for the acknowledgment until it receives it or the acknowledgement timeout period is reached. If the acknowledgment times out, Firehose determines whether there's time left in the retry counter. If there is time left, it retries again and repeats the logic until it receives an acknowledgment or determines that the retry time has expired. If you don't want Firehose to retry sending data, set this value to 0.</p>
    pub fn retry_options(&self) -> ::std::option::Option<&crate::types::SnowflakeRetryOptions> {
        self.retry_options.as_ref()
    }
    /// <p>Choose an S3 backup mode</p>
    pub fn s3_backup_mode(&self) -> ::std::option::Option<&crate::types::SnowflakeS3BackupMode> {
        self.s3_backup_mode.as_ref()
    }
    /// <p>Describes an update for a destination in Amazon S3.</p>
    pub fn s3_update(&self) -> ::std::option::Option<&crate::types::S3DestinationUpdate> {
        self.s3_update.as_ref()
    }
    /// <p>Describes the Secrets Manager configuration in Snowflake.</p>
    pub fn secrets_manager_configuration(&self) -> ::std::option::Option<&crate::types::SecretsManagerConfiguration> {
        self.secrets_manager_configuration.as_ref()
    }
    /// <p>Describes the buffering to perform before delivering data to the Snowflake destination.</p>
    pub fn buffering_hints(&self) -> ::std::option::Option<&crate::types::SnowflakeBufferingHints> {
        self.buffering_hints.as_ref()
    }
}
impl ::std::fmt::Debug for SnowflakeDestinationUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("SnowflakeDestinationUpdate");
        formatter.field("account_url", &"*** Sensitive Data Redacted ***");
        formatter.field("private_key", &"*** Sensitive Data Redacted ***");
        formatter.field("key_passphrase", &"*** Sensitive Data Redacted ***");
        formatter.field("user", &"*** Sensitive Data Redacted ***");
        formatter.field("database", &"*** Sensitive Data Redacted ***");
        formatter.field("schema", &"*** Sensitive Data Redacted ***");
        formatter.field("table", &"*** Sensitive Data Redacted ***");
        formatter.field("snowflake_role_configuration", &self.snowflake_role_configuration);
        formatter.field("data_loading_option", &self.data_loading_option);
        formatter.field("meta_data_column_name", &"*** Sensitive Data Redacted ***");
        formatter.field("content_column_name", &"*** Sensitive Data Redacted ***");
        formatter.field("cloud_watch_logging_options", &self.cloud_watch_logging_options);
        formatter.field("processing_configuration", &self.processing_configuration);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("retry_options", &self.retry_options);
        formatter.field("s3_backup_mode", &self.s3_backup_mode);
        formatter.field("s3_update", &self.s3_update);
        formatter.field("secrets_manager_configuration", &self.secrets_manager_configuration);
        formatter.field("buffering_hints", &self.buffering_hints);
        formatter.finish()
    }
}
impl SnowflakeDestinationUpdate {
    /// Creates a new builder-style object to manufacture [`SnowflakeDestinationUpdate`](crate::types::SnowflakeDestinationUpdate).
    pub fn builder() -> crate::types::builders::SnowflakeDestinationUpdateBuilder {
        crate::types::builders::SnowflakeDestinationUpdateBuilder::default()
    }
}

/// A builder for [`SnowflakeDestinationUpdate`](crate::types::SnowflakeDestinationUpdate).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct SnowflakeDestinationUpdateBuilder {
    pub(crate) account_url: ::std::option::Option<::std::string::String>,
    pub(crate) private_key: ::std::option::Option<::std::string::String>,
    pub(crate) key_passphrase: ::std::option::Option<::std::string::String>,
    pub(crate) user: ::std::option::Option<::std::string::String>,
    pub(crate) database: ::std::option::Option<::std::string::String>,
    pub(crate) schema: ::std::option::Option<::std::string::String>,
    pub(crate) table: ::std::option::Option<::std::string::String>,
    pub(crate) snowflake_role_configuration: ::std::option::Option<crate::types::SnowflakeRoleConfiguration>,
    pub(crate) data_loading_option: ::std::option::Option<crate::types::SnowflakeDataLoadingOption>,
    pub(crate) meta_data_column_name: ::std::option::Option<::std::string::String>,
    pub(crate) content_column_name: ::std::option::Option<::std::string::String>,
    pub(crate) cloud_watch_logging_options: ::std::option::Option<crate::types::CloudWatchLoggingOptions>,
    pub(crate) processing_configuration: ::std::option::Option<crate::types::ProcessingConfiguration>,
    pub(crate) role_arn: ::std::option::Option<::std::string::String>,
    pub(crate) retry_options: ::std::option::Option<crate::types::SnowflakeRetryOptions>,
    pub(crate) s3_backup_mode: ::std::option::Option<crate::types::SnowflakeS3BackupMode>,
    pub(crate) s3_update: ::std::option::Option<crate::types::S3DestinationUpdate>,
    pub(crate) secrets_manager_configuration: ::std::option::Option<crate::types::SecretsManagerConfiguration>,
    pub(crate) buffering_hints: ::std::option::Option<crate::types::SnowflakeBufferingHints>,
}
impl SnowflakeDestinationUpdateBuilder {
    /// <p>URL for accessing your Snowflake account. This URL must include your <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier">account identifier</a>. Note that the protocol (https://) and port number are optional.</p>
    pub fn account_url(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.account_url = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>URL for accessing your Snowflake account. This URL must include your <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier">account identifier</a>. Note that the protocol (https://) and port number are optional.</p>
    pub fn set_account_url(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.account_url = input;
        self
    }
    /// <p>URL for accessing your Snowflake account. This URL must include your <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier">account identifier</a>. Note that the protocol (https://) and port number are optional.</p>
    pub fn get_account_url(&self) -> &::std::option::Option<::std::string::String> {
        &self.account_url
    }
    /// <p>The private key used to encrypt your Snowflake client. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    pub fn private_key(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.private_key = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The private key used to encrypt your Snowflake client. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    pub fn set_private_key(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.private_key = input;
        self
    }
    /// <p>The private key used to encrypt your Snowflake client. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    pub fn get_private_key(&self) -> &::std::option::Option<::std::string::String> {
        &self.private_key
    }
    /// <p>Passphrase to decrypt the private key when the key is encrypted. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    pub fn key_passphrase(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.key_passphrase = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Passphrase to decrypt the private key when the key is encrypted. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    pub fn set_key_passphrase(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.key_passphrase = input;
        self
    }
    /// <p>Passphrase to decrypt the private key when the key is encrypted. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    pub fn get_key_passphrase(&self) -> &::std::option::Option<::std::string::String> {
        &self.key_passphrase
    }
    /// <p>User login name for the Snowflake account.</p>
    pub fn user(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.user = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>User login name for the Snowflake account.</p>
    pub fn set_user(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.user = input;
        self
    }
    /// <p>User login name for the Snowflake account.</p>
    pub fn get_user(&self) -> &::std::option::Option<::std::string::String> {
        &self.user
    }
    /// <p>All data in Snowflake is maintained in databases.</p>
    pub fn database(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.database = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>All data in Snowflake is maintained in databases.</p>
    pub fn set_database(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.database = input;
        self
    }
    /// <p>All data in Snowflake is maintained in databases.</p>
    pub fn get_database(&self) -> &::std::option::Option<::std::string::String> {
        &self.database
    }
    /// <p>Each database consists of one or more schemas, which are logical groupings of database objects, such as tables and views</p>
    pub fn schema(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.schema = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Each database consists of one or more schemas, which are logical groupings of database objects, such as tables and views</p>
    pub fn set_schema(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.schema = input;
        self
    }
    /// <p>Each database consists of one or more schemas, which are logical groupings of database objects, such as tables and views</p>
    pub fn get_schema(&self) -> &::std::option::Option<::std::string::String> {
        &self.schema
    }
    /// <p>All data in Snowflake is stored in database tables, logically structured as collections of columns and rows.</p>
    pub fn table(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.table = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>All data in Snowflake is stored in database tables, logically structured as collections of columns and rows.</p>
    pub fn set_table(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.table = input;
        self
    }
    /// <p>All data in Snowflake is stored in database tables, logically structured as collections of columns and rows.</p>
    pub fn get_table(&self) -> &::std::option::Option<::std::string::String> {
        &self.table
    }
    /// <p>Optionally configure a Snowflake role. Otherwise the default user role will be used.</p>
    pub fn snowflake_role_configuration(mut self, input: crate::types::SnowflakeRoleConfiguration) -> Self {
        self.snowflake_role_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Optionally configure a Snowflake role. Otherwise the default user role will be used.</p>
    pub fn set_snowflake_role_configuration(mut self, input: ::std::option::Option<crate::types::SnowflakeRoleConfiguration>) -> Self {
        self.snowflake_role_configuration = input;
        self
    }
    /// <p>Optionally configure a Snowflake role. Otherwise the default user role will be used.</p>
    pub fn get_snowflake_role_configuration(&self) -> &::std::option::Option<crate::types::SnowflakeRoleConfiguration> {
        &self.snowflake_role_configuration
    }
    /// <p>JSON keys mapped to table column names or choose to split the JSON payload where content is mapped to a record content column and source metadata is mapped to a record metadata column.</p>
    pub fn data_loading_option(mut self, input: crate::types::SnowflakeDataLoadingOption) -> Self {
        self.data_loading_option = ::std::option::Option::Some(input);
        self
    }
    /// <p>JSON keys mapped to table column names or choose to split the JSON payload where content is mapped to a record content column and source metadata is mapped to a record metadata column.</p>
    pub fn set_data_loading_option(mut self, input: ::std::option::Option<crate::types::SnowflakeDataLoadingOption>) -> Self {
        self.data_loading_option = input;
        self
    }
    /// <p>JSON keys mapped to table column names or choose to split the JSON payload where content is mapped to a record content column and source metadata is mapped to a record metadata column.</p>
    pub fn get_data_loading_option(&self) -> &::std::option::Option<crate::types::SnowflakeDataLoadingOption> {
        &self.data_loading_option
    }
    /// <p>The name of the record metadata column</p>
    pub fn meta_data_column_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.meta_data_column_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the record metadata column</p>
    pub fn set_meta_data_column_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.meta_data_column_name = input;
        self
    }
    /// <p>The name of the record metadata column</p>
    pub fn get_meta_data_column_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.meta_data_column_name
    }
    /// <p>The name of the content metadata column</p>
    pub fn content_column_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.content_column_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the content metadata column</p>
    pub fn set_content_column_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.content_column_name = input;
        self
    }
    /// <p>The name of the content metadata column</p>
    pub fn get_content_column_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.content_column_name
    }
    /// <p>Describes the Amazon CloudWatch logging options for your delivery stream.</p>
    pub fn cloud_watch_logging_options(mut self, input: crate::types::CloudWatchLoggingOptions) -> Self {
        self.cloud_watch_logging_options = ::std::option::Option::Some(input);
        self
    }
    /// <p>Describes the Amazon CloudWatch logging options for your delivery stream.</p>
    pub fn set_cloud_watch_logging_options(mut self, input: ::std::option::Option<crate::types::CloudWatchLoggingOptions>) -> Self {
        self.cloud_watch_logging_options = input;
        self
    }
    /// <p>Describes the Amazon CloudWatch logging options for your delivery stream.</p>
    pub fn get_cloud_watch_logging_options(&self) -> &::std::option::Option<crate::types::CloudWatchLoggingOptions> {
        &self.cloud_watch_logging_options
    }
    /// <p>Describes a data processing configuration.</p>
    pub fn processing_configuration(mut self, input: crate::types::ProcessingConfiguration) -> Self {
        self.processing_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Describes a data processing configuration.</p>
    pub fn set_processing_configuration(mut self, input: ::std::option::Option<crate::types::ProcessingConfiguration>) -> Self {
        self.processing_configuration = input;
        self
    }
    /// <p>Describes a data processing configuration.</p>
    pub fn get_processing_configuration(&self) -> &::std::option::Option<crate::types::ProcessingConfiguration> {
        &self.processing_configuration
    }
    /// <p>The Amazon Resource Name (ARN) of the Snowflake role</p>
    pub fn role_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.role_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Snowflake role</p>
    pub fn set_role_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.role_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Snowflake role</p>
    pub fn get_role_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.role_arn
    }
    /// <p>Specify how long Firehose retries sending data to the New Relic HTTP endpoint. After sending data, Firehose first waits for an acknowledgment from the HTTP endpoint. If an error occurs or the acknowledgment doesn’t arrive within the acknowledgment timeout period, Firehose starts the retry duration counter. It keeps retrying until the retry duration expires. After that, Firehose considers it a data delivery failure and backs up the data to your Amazon S3 bucket. Every time that Firehose sends data to the HTTP endpoint (either the initial attempt or a retry), it restarts the acknowledgement timeout counter and waits for an acknowledgement from the HTTP endpoint. Even if the retry duration expires, Firehose still waits for the acknowledgment until it receives it or the acknowledgement timeout period is reached. If the acknowledgment times out, Firehose determines whether there's time left in the retry counter. If there is time left, it retries again and repeats the logic until it receives an acknowledgment or determines that the retry time has expired. If you don't want Firehose to retry sending data, set this value to 0.</p>
    pub fn retry_options(mut self, input: crate::types::SnowflakeRetryOptions) -> Self {
        self.retry_options = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specify how long Firehose retries sending data to the New Relic HTTP endpoint. After sending data, Firehose first waits for an acknowledgment from the HTTP endpoint. If an error occurs or the acknowledgment doesn’t arrive within the acknowledgment timeout period, Firehose starts the retry duration counter. It keeps retrying until the retry duration expires. After that, Firehose considers it a data delivery failure and backs up the data to your Amazon S3 bucket. Every time that Firehose sends data to the HTTP endpoint (either the initial attempt or a retry), it restarts the acknowledgement timeout counter and waits for an acknowledgement from the HTTP endpoint. Even if the retry duration expires, Firehose still waits for the acknowledgment until it receives it or the acknowledgement timeout period is reached. If the acknowledgment times out, Firehose determines whether there's time left in the retry counter. If there is time left, it retries again and repeats the logic until it receives an acknowledgment or determines that the retry time has expired. If you don't want Firehose to retry sending data, set this value to 0.</p>
    pub fn set_retry_options(mut self, input: ::std::option::Option<crate::types::SnowflakeRetryOptions>) -> Self {
        self.retry_options = input;
        self
    }
    /// <p>Specify how long Firehose retries sending data to the New Relic HTTP endpoint. After sending data, Firehose first waits for an acknowledgment from the HTTP endpoint. If an error occurs or the acknowledgment doesn’t arrive within the acknowledgment timeout period, Firehose starts the retry duration counter. It keeps retrying until the retry duration expires. After that, Firehose considers it a data delivery failure and backs up the data to your Amazon S3 bucket. Every time that Firehose sends data to the HTTP endpoint (either the initial attempt or a retry), it restarts the acknowledgement timeout counter and waits for an acknowledgement from the HTTP endpoint. Even if the retry duration expires, Firehose still waits for the acknowledgment until it receives it or the acknowledgement timeout period is reached. If the acknowledgment times out, Firehose determines whether there's time left in the retry counter. If there is time left, it retries again and repeats the logic until it receives an acknowledgment or determines that the retry time has expired. If you don't want Firehose to retry sending data, set this value to 0.</p>
    pub fn get_retry_options(&self) -> &::std::option::Option<crate::types::SnowflakeRetryOptions> {
        &self.retry_options
    }
    /// <p>Choose an S3 backup mode</p>
    pub fn s3_backup_mode(mut self, input: crate::types::SnowflakeS3BackupMode) -> Self {
        self.s3_backup_mode = ::std::option::Option::Some(input);
        self
    }
    /// <p>Choose an S3 backup mode</p>
    pub fn set_s3_backup_mode(mut self, input: ::std::option::Option<crate::types::SnowflakeS3BackupMode>) -> Self {
        self.s3_backup_mode = input;
        self
    }
    /// <p>Choose an S3 backup mode</p>
    pub fn get_s3_backup_mode(&self) -> &::std::option::Option<crate::types::SnowflakeS3BackupMode> {
        &self.s3_backup_mode
    }
    /// <p>Describes an update for a destination in Amazon S3.</p>
    pub fn s3_update(mut self, input: crate::types::S3DestinationUpdate) -> Self {
        self.s3_update = ::std::option::Option::Some(input);
        self
    }
    /// <p>Describes an update for a destination in Amazon S3.</p>
    pub fn set_s3_update(mut self, input: ::std::option::Option<crate::types::S3DestinationUpdate>) -> Self {
        self.s3_update = input;
        self
    }
    /// <p>Describes an update for a destination in Amazon S3.</p>
    pub fn get_s3_update(&self) -> &::std::option::Option<crate::types::S3DestinationUpdate> {
        &self.s3_update
    }
    /// <p>Describes the Secrets Manager configuration in Snowflake.</p>
    pub fn secrets_manager_configuration(mut self, input: crate::types::SecretsManagerConfiguration) -> Self {
        self.secrets_manager_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Describes the Secrets Manager configuration in Snowflake.</p>
    pub fn set_secrets_manager_configuration(mut self, input: ::std::option::Option<crate::types::SecretsManagerConfiguration>) -> Self {
        self.secrets_manager_configuration = input;
        self
    }
    /// <p>Describes the Secrets Manager configuration in Snowflake.</p>
    pub fn get_secrets_manager_configuration(&self) -> &::std::option::Option<crate::types::SecretsManagerConfiguration> {
        &self.secrets_manager_configuration
    }
    /// <p>Describes the buffering to perform before delivering data to the Snowflake destination.</p>
    pub fn buffering_hints(mut self, input: crate::types::SnowflakeBufferingHints) -> Self {
        self.buffering_hints = ::std::option::Option::Some(input);
        self
    }
    /// <p>Describes the buffering to perform before delivering data to the Snowflake destination.</p>
    pub fn set_buffering_hints(mut self, input: ::std::option::Option<crate::types::SnowflakeBufferingHints>) -> Self {
        self.buffering_hints = input;
        self
    }
    /// <p>Describes the buffering to perform before delivering data to the Snowflake destination.</p>
    pub fn get_buffering_hints(&self) -> &::std::option::Option<crate::types::SnowflakeBufferingHints> {
        &self.buffering_hints
    }
    /// Consumes the builder and constructs a [`SnowflakeDestinationUpdate`](crate::types::SnowflakeDestinationUpdate).
    pub fn build(self) -> crate::types::SnowflakeDestinationUpdate {
        crate::types::SnowflakeDestinationUpdate {
            account_url: self.account_url,
            private_key: self.private_key,
            key_passphrase: self.key_passphrase,
            user: self.user,
            database: self.database,
            schema: self.schema,
            table: self.table,
            snowflake_role_configuration: self.snowflake_role_configuration,
            data_loading_option: self.data_loading_option,
            meta_data_column_name: self.meta_data_column_name,
            content_column_name: self.content_column_name,
            cloud_watch_logging_options: self.cloud_watch_logging_options,
            processing_configuration: self.processing_configuration,
            role_arn: self.role_arn,
            retry_options: self.retry_options,
            s3_backup_mode: self.s3_backup_mode,
            s3_update: self.s3_update,
            secrets_manager_configuration: self.secrets_manager_configuration,
            buffering_hints: self.buffering_hints,
        }
    }
}
impl ::std::fmt::Debug for SnowflakeDestinationUpdateBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("SnowflakeDestinationUpdateBuilder");
        formatter.field("account_url", &"*** Sensitive Data Redacted ***");
        formatter.field("private_key", &"*** Sensitive Data Redacted ***");
        formatter.field("key_passphrase", &"*** Sensitive Data Redacted ***");
        formatter.field("user", &"*** Sensitive Data Redacted ***");
        formatter.field("database", &"*** Sensitive Data Redacted ***");
        formatter.field("schema", &"*** Sensitive Data Redacted ***");
        formatter.field("table", &"*** Sensitive Data Redacted ***");
        formatter.field("snowflake_role_configuration", &self.snowflake_role_configuration);
        formatter.field("data_loading_option", &self.data_loading_option);
        formatter.field("meta_data_column_name", &"*** Sensitive Data Redacted ***");
        formatter.field("content_column_name", &"*** Sensitive Data Redacted ***");
        formatter.field("cloud_watch_logging_options", &self.cloud_watch_logging_options);
        formatter.field("processing_configuration", &self.processing_configuration);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("retry_options", &self.retry_options);
        formatter.field("s3_backup_mode", &self.s3_backup_mode);
        formatter.field("s3_update", &self.s3_update);
        formatter.field("secrets_manager_configuration", &self.secrets_manager_configuration);
        formatter.field("buffering_hints", &self.buffering_hints);
        formatter.finish()
    }
}
