// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn activate_key_signing_key(&self) -> fluent_builders::ActivateKeySigningKey<C> {
        fluent_builders::ActivateKeySigningKey::new(self.handle.clone())
    }
    pub fn associate_vpc_with_hosted_zone(&self) -> fluent_builders::AssociateVPCWithHostedZone<C> {
        fluent_builders::AssociateVPCWithHostedZone::new(self.handle.clone())
    }
    pub fn change_resource_record_sets(&self) -> fluent_builders::ChangeResourceRecordSets<C> {
        fluent_builders::ChangeResourceRecordSets::new(self.handle.clone())
    }
    pub fn change_tags_for_resource(&self) -> fluent_builders::ChangeTagsForResource<C> {
        fluent_builders::ChangeTagsForResource::new(self.handle.clone())
    }
    pub fn create_health_check(&self) -> fluent_builders::CreateHealthCheck<C> {
        fluent_builders::CreateHealthCheck::new(self.handle.clone())
    }
    pub fn create_hosted_zone(&self) -> fluent_builders::CreateHostedZone<C> {
        fluent_builders::CreateHostedZone::new(self.handle.clone())
    }
    pub fn create_key_signing_key(&self) -> fluent_builders::CreateKeySigningKey<C> {
        fluent_builders::CreateKeySigningKey::new(self.handle.clone())
    }
    pub fn create_query_logging_config(&self) -> fluent_builders::CreateQueryLoggingConfig<C> {
        fluent_builders::CreateQueryLoggingConfig::new(self.handle.clone())
    }
    pub fn create_reusable_delegation_set(
        &self,
    ) -> fluent_builders::CreateReusableDelegationSet<C> {
        fluent_builders::CreateReusableDelegationSet::new(self.handle.clone())
    }
    pub fn create_traffic_policy(&self) -> fluent_builders::CreateTrafficPolicy<C> {
        fluent_builders::CreateTrafficPolicy::new(self.handle.clone())
    }
    pub fn create_traffic_policy_instance(
        &self,
    ) -> fluent_builders::CreateTrafficPolicyInstance<C> {
        fluent_builders::CreateTrafficPolicyInstance::new(self.handle.clone())
    }
    pub fn create_traffic_policy_version(&self) -> fluent_builders::CreateTrafficPolicyVersion<C> {
        fluent_builders::CreateTrafficPolicyVersion::new(self.handle.clone())
    }
    pub fn create_vpc_association_authorization(
        &self,
    ) -> fluent_builders::CreateVPCAssociationAuthorization<C> {
        fluent_builders::CreateVPCAssociationAuthorization::new(self.handle.clone())
    }
    pub fn deactivate_key_signing_key(&self) -> fluent_builders::DeactivateKeySigningKey<C> {
        fluent_builders::DeactivateKeySigningKey::new(self.handle.clone())
    }
    pub fn delete_health_check(&self) -> fluent_builders::DeleteHealthCheck<C> {
        fluent_builders::DeleteHealthCheck::new(self.handle.clone())
    }
    pub fn delete_hosted_zone(&self) -> fluent_builders::DeleteHostedZone<C> {
        fluent_builders::DeleteHostedZone::new(self.handle.clone())
    }
    pub fn delete_key_signing_key(&self) -> fluent_builders::DeleteKeySigningKey<C> {
        fluent_builders::DeleteKeySigningKey::new(self.handle.clone())
    }
    pub fn delete_query_logging_config(&self) -> fluent_builders::DeleteQueryLoggingConfig<C> {
        fluent_builders::DeleteQueryLoggingConfig::new(self.handle.clone())
    }
    pub fn delete_reusable_delegation_set(
        &self,
    ) -> fluent_builders::DeleteReusableDelegationSet<C> {
        fluent_builders::DeleteReusableDelegationSet::new(self.handle.clone())
    }
    pub fn delete_traffic_policy(&self) -> fluent_builders::DeleteTrafficPolicy<C> {
        fluent_builders::DeleteTrafficPolicy::new(self.handle.clone())
    }
    pub fn delete_traffic_policy_instance(
        &self,
    ) -> fluent_builders::DeleteTrafficPolicyInstance<C> {
        fluent_builders::DeleteTrafficPolicyInstance::new(self.handle.clone())
    }
    pub fn delete_vpc_association_authorization(
        &self,
    ) -> fluent_builders::DeleteVPCAssociationAuthorization<C> {
        fluent_builders::DeleteVPCAssociationAuthorization::new(self.handle.clone())
    }
    pub fn disable_hosted_zone_dnssec(&self) -> fluent_builders::DisableHostedZoneDNSSEC<C> {
        fluent_builders::DisableHostedZoneDNSSEC::new(self.handle.clone())
    }
    pub fn disassociate_vpc_from_hosted_zone(
        &self,
    ) -> fluent_builders::DisassociateVPCFromHostedZone<C> {
        fluent_builders::DisassociateVPCFromHostedZone::new(self.handle.clone())
    }
    pub fn enable_hosted_zone_dnssec(&self) -> fluent_builders::EnableHostedZoneDNSSEC<C> {
        fluent_builders::EnableHostedZoneDNSSEC::new(self.handle.clone())
    }
    pub fn get_account_limit(&self) -> fluent_builders::GetAccountLimit<C> {
        fluent_builders::GetAccountLimit::new(self.handle.clone())
    }
    pub fn get_change(&self) -> fluent_builders::GetChange<C> {
        fluent_builders::GetChange::new(self.handle.clone())
    }
    pub fn get_checker_ip_ranges(&self) -> fluent_builders::GetCheckerIpRanges<C> {
        fluent_builders::GetCheckerIpRanges::new(self.handle.clone())
    }
    pub fn get_dnssec(&self) -> fluent_builders::GetDNSSEC<C> {
        fluent_builders::GetDNSSEC::new(self.handle.clone())
    }
    pub fn get_geo_location(&self) -> fluent_builders::GetGeoLocation<C> {
        fluent_builders::GetGeoLocation::new(self.handle.clone())
    }
    pub fn get_health_check(&self) -> fluent_builders::GetHealthCheck<C> {
        fluent_builders::GetHealthCheck::new(self.handle.clone())
    }
    pub fn get_health_check_count(&self) -> fluent_builders::GetHealthCheckCount<C> {
        fluent_builders::GetHealthCheckCount::new(self.handle.clone())
    }
    pub fn get_health_check_last_failure_reason(
        &self,
    ) -> fluent_builders::GetHealthCheckLastFailureReason<C> {
        fluent_builders::GetHealthCheckLastFailureReason::new(self.handle.clone())
    }
    pub fn get_health_check_status(&self) -> fluent_builders::GetHealthCheckStatus<C> {
        fluent_builders::GetHealthCheckStatus::new(self.handle.clone())
    }
    pub fn get_hosted_zone(&self) -> fluent_builders::GetHostedZone<C> {
        fluent_builders::GetHostedZone::new(self.handle.clone())
    }
    pub fn get_hosted_zone_count(&self) -> fluent_builders::GetHostedZoneCount<C> {
        fluent_builders::GetHostedZoneCount::new(self.handle.clone())
    }
    pub fn get_hosted_zone_limit(&self) -> fluent_builders::GetHostedZoneLimit<C> {
        fluent_builders::GetHostedZoneLimit::new(self.handle.clone())
    }
    pub fn get_query_logging_config(&self) -> fluent_builders::GetQueryLoggingConfig<C> {
        fluent_builders::GetQueryLoggingConfig::new(self.handle.clone())
    }
    pub fn get_reusable_delegation_set(&self) -> fluent_builders::GetReusableDelegationSet<C> {
        fluent_builders::GetReusableDelegationSet::new(self.handle.clone())
    }
    pub fn get_reusable_delegation_set_limit(
        &self,
    ) -> fluent_builders::GetReusableDelegationSetLimit<C> {
        fluent_builders::GetReusableDelegationSetLimit::new(self.handle.clone())
    }
    pub fn get_traffic_policy(&self) -> fluent_builders::GetTrafficPolicy<C> {
        fluent_builders::GetTrafficPolicy::new(self.handle.clone())
    }
    pub fn get_traffic_policy_instance(&self) -> fluent_builders::GetTrafficPolicyInstance<C> {
        fluent_builders::GetTrafficPolicyInstance::new(self.handle.clone())
    }
    pub fn get_traffic_policy_instance_count(
        &self,
    ) -> fluent_builders::GetTrafficPolicyInstanceCount<C> {
        fluent_builders::GetTrafficPolicyInstanceCount::new(self.handle.clone())
    }
    pub fn list_geo_locations(&self) -> fluent_builders::ListGeoLocations<C> {
        fluent_builders::ListGeoLocations::new(self.handle.clone())
    }
    pub fn list_health_checks(&self) -> fluent_builders::ListHealthChecks<C> {
        fluent_builders::ListHealthChecks::new(self.handle.clone())
    }
    pub fn list_hosted_zones(&self) -> fluent_builders::ListHostedZones<C> {
        fluent_builders::ListHostedZones::new(self.handle.clone())
    }
    pub fn list_hosted_zones_by_name(&self) -> fluent_builders::ListHostedZonesByName<C> {
        fluent_builders::ListHostedZonesByName::new(self.handle.clone())
    }
    pub fn list_hosted_zones_by_vpc(&self) -> fluent_builders::ListHostedZonesByVPC<C> {
        fluent_builders::ListHostedZonesByVPC::new(self.handle.clone())
    }
    pub fn list_query_logging_configs(&self) -> fluent_builders::ListQueryLoggingConfigs<C> {
        fluent_builders::ListQueryLoggingConfigs::new(self.handle.clone())
    }
    pub fn list_resource_record_sets(&self) -> fluent_builders::ListResourceRecordSets<C> {
        fluent_builders::ListResourceRecordSets::new(self.handle.clone())
    }
    pub fn list_reusable_delegation_sets(&self) -> fluent_builders::ListReusableDelegationSets<C> {
        fluent_builders::ListReusableDelegationSets::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_tags_for_resources(&self) -> fluent_builders::ListTagsForResources<C> {
        fluent_builders::ListTagsForResources::new(self.handle.clone())
    }
    pub fn list_traffic_policies(&self) -> fluent_builders::ListTrafficPolicies<C> {
        fluent_builders::ListTrafficPolicies::new(self.handle.clone())
    }
    pub fn list_traffic_policy_instances(&self) -> fluent_builders::ListTrafficPolicyInstances<C> {
        fluent_builders::ListTrafficPolicyInstances::new(self.handle.clone())
    }
    pub fn list_traffic_policy_instances_by_hosted_zone(
        &self,
    ) -> fluent_builders::ListTrafficPolicyInstancesByHostedZone<C> {
        fluent_builders::ListTrafficPolicyInstancesByHostedZone::new(self.handle.clone())
    }
    pub fn list_traffic_policy_instances_by_policy(
        &self,
    ) -> fluent_builders::ListTrafficPolicyInstancesByPolicy<C> {
        fluent_builders::ListTrafficPolicyInstancesByPolicy::new(self.handle.clone())
    }
    pub fn list_traffic_policy_versions(&self) -> fluent_builders::ListTrafficPolicyVersions<C> {
        fluent_builders::ListTrafficPolicyVersions::new(self.handle.clone())
    }
    pub fn list_vpc_association_authorizations(
        &self,
    ) -> fluent_builders::ListVPCAssociationAuthorizations<C> {
        fluent_builders::ListVPCAssociationAuthorizations::new(self.handle.clone())
    }
    pub fn test_dns_answer(&self) -> fluent_builders::TestDNSAnswer<C> {
        fluent_builders::TestDNSAnswer::new(self.handle.clone())
    }
    pub fn update_health_check(&self) -> fluent_builders::UpdateHealthCheck<C> {
        fluent_builders::UpdateHealthCheck::new(self.handle.clone())
    }
    pub fn update_hosted_zone_comment(&self) -> fluent_builders::UpdateHostedZoneComment<C> {
        fluent_builders::UpdateHostedZoneComment::new(self.handle.clone())
    }
    pub fn update_traffic_policy_comment(&self) -> fluent_builders::UpdateTrafficPolicyComment<C> {
        fluent_builders::UpdateTrafficPolicyComment::new(self.handle.clone())
    }
    pub fn update_traffic_policy_instance(
        &self,
    ) -> fluent_builders::UpdateTrafficPolicyInstance<C> {
        fluent_builders::UpdateTrafficPolicyInstance::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct ActivateKeySigningKey<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::activate_key_signing_key_input::Builder,
    }
    impl<C> ActivateKeySigningKey<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ActivateKeySigningKeyOutput,
            smithy_http::result::SdkError<crate::error::ActivateKeySigningKeyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique string used to identify a hosted zone.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
        /// <p>A string used to identify a key-signing key (KSK). <code>Name</code> can include numbers, letters,  and underscores (_). <code>Name</code> must be unique for each key-signing key in the same
        /// hosted zone.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateVPCWithHostedZone<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_vpc_with_hosted_zone_input::Builder,
    }
    impl<C> AssociateVPCWithHostedZone<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::AssociateVPCWithHostedZoneOutput,
            smithy_http::result::SdkError<crate::error::AssociateVPCWithHostedZoneError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the private hosted zone that you want to associate an Amazon VPC with.</p>
        /// <p>Note that you can't associate a VPC with a hosted zone that doesn't have an existing VPC association.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
        /// <p>A complex type that contains information about the VPC that you want to associate with a private hosted zone.</p>
        pub fn vpc(mut self, inp: crate::model::VPC) -> Self {
            self.inner = self.inner.vpc(inp);
            self
        }
        pub fn set_vpc(mut self, inp: std::option::Option<crate::model::VPC>) -> Self {
            self.inner = self.inner.set_vpc(inp);
            self
        }
        /// <p>
        /// <i>Optional:</i> A comment about the association request.</p>
        pub fn comment(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.comment(inp);
            self
        }
        pub fn set_comment(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_comment(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ChangeResourceRecordSets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::change_resource_record_sets_input::Builder,
    }
    impl<C> ChangeResourceRecordSets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ChangeResourceRecordSetsOutput,
            smithy_http::result::SdkError<crate::error::ChangeResourceRecordSetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the hosted zone that contains the resource record sets that you want to change.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
        /// <p>A complex type that contains an optional comment and the <code>Changes</code> element.</p>
        pub fn change_batch(mut self, inp: crate::model::ChangeBatch) -> Self {
            self.inner = self.inner.change_batch(inp);
            self
        }
        pub fn set_change_batch(
            mut self,
            inp: std::option::Option<crate::model::ChangeBatch>,
        ) -> Self {
            self.inner = self.inner.set_change_batch(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ChangeTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::change_tags_for_resource_input::Builder,
    }
    impl<C> ChangeTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ChangeTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ChangeTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The type of the resource.</p>
        /// <ul>
        /// <li>
        /// <p>The resource type for health checks is <code>healthcheck</code>.</p>
        /// </li>
        /// <li>
        /// <p>The resource type for hosted zones is <code>hostedzone</code>.</p>
        /// </li>
        /// </ul>
        pub fn resource_type(mut self, inp: crate::model::TagResourceType) -> Self {
            self.inner = self.inner.resource_type(inp);
            self
        }
        pub fn set_resource_type(mut self, inp: crate::model::TagResourceType) -> Self {
            self.inner = self.inner.set_resource_type(inp);
            self
        }
        /// <p>The ID of the resource for which you want to add, change, or delete tags.</p>
        pub fn resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(inp);
            self
        }
        pub fn set_resource_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_resource_id(inp);
            self
        }
        /// <p>A complex type that contains a list of the tags that you want to add to the specified health check or hosted zone and/or the tags
        /// that you want to edit <code>Value</code> for.</p>
        /// <p>You can add a maximum of 10 tags to a health check or a hosted zone.</p>
        pub fn add_tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.add_tags(inp);
            self
        }
        pub fn set_add_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_add_tags(inp);
            self
        }
        /// <p>A complex type that contains a list of the tags that you want to delete from the specified health check or hosted zone.
        /// You can specify up to 10 keys.</p>
        pub fn remove_tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.remove_tag_keys(inp);
            self
        }
        pub fn set_remove_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_remove_tag_keys(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateHealthCheck<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_health_check_input::Builder,
    }
    impl<C> CreateHealthCheck<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateHealthCheckOutput,
            smithy_http::result::SdkError<crate::error::CreateHealthCheckError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique string that identifies the request and that allows you to retry a failed <code>CreateHealthCheck</code> request
        /// without the risk of creating two identical health checks:</p>
        /// <ul>
        /// <li>
        /// <p>If you send a <code>CreateHealthCheck</code> request with the same <code>CallerReference</code> and settings
        /// as a previous request, and if the health check doesn't exist, Amazon Route 53 creates the health check. If the health check does exist,
        /// Route 53 returns the settings for the existing health check.</p>
        /// </li>
        /// <li>
        /// <p>If you send a <code>CreateHealthCheck</code> request with the same <code>CallerReference</code> as a deleted health check,
        /// regardless of the settings, Route 53 returns a <code>HealthCheckAlreadyExists</code> error.</p>
        /// </li>
        /// <li>
        /// <p>If you send a <code>CreateHealthCheck</code> request with the same <code>CallerReference</code> as an existing health check
        /// but with different settings, Route 53 returns a <code>HealthCheckAlreadyExists</code> error.</p>
        /// </li>
        /// <li>
        /// <p>If you send a <code>CreateHealthCheck</code> request with a unique <code>CallerReference</code> but settings identical to
        /// an existing health check, Route 53 creates the health check.</p>
        /// </li>
        /// </ul>
        pub fn caller_reference(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.caller_reference(inp);
            self
        }
        pub fn set_caller_reference(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_caller_reference(inp);
            self
        }
        /// <p>A complex type that contains settings for a new health check.</p>
        pub fn health_check_config(mut self, inp: crate::model::HealthCheckConfig) -> Self {
            self.inner = self.inner.health_check_config(inp);
            self
        }
        pub fn set_health_check_config(
            mut self,
            inp: std::option::Option<crate::model::HealthCheckConfig>,
        ) -> Self {
            self.inner = self.inner.set_health_check_config(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateHostedZone<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_hosted_zone_input::Builder,
    }
    impl<C> CreateHostedZone<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateHostedZoneOutput,
            smithy_http::result::SdkError<crate::error::CreateHostedZoneError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain. Specify a fully qualified domain name, for example, <i>www.example.com</i>.
        /// The trailing dot is optional; Amazon Route 53 assumes that the domain name is fully qualified. This means that Route 53 treats
        /// <i>www.example.com</i> (without a trailing dot) and <i>www.example.com.</i> (with a trailing dot) as identical.</p>
        /// <p>If you're creating a public hosted zone, this is the name you have registered with your DNS registrar. If your domain name
        /// is registered with a registrar other than Route 53, change the name servers for your domain to the set of <code>NameServers</code> that
        /// <code>CreateHostedZone</code> returns in <code>DelegationSet</code>.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>(Private hosted zones only) A complex type that contains information about the Amazon VPC that you're associating with this hosted zone.</p>
        /// <p>You can specify only one Amazon VPC when you create a private hosted zone. To associate additional Amazon VPCs with the hosted zone,
        /// use <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_AssociateVPCWithHostedZone.html">AssociateVPCWithHostedZone</a>
        /// after you create a hosted zone.</p>
        pub fn vpc(mut self, inp: crate::model::VPC) -> Self {
            self.inner = self.inner.vpc(inp);
            self
        }
        pub fn set_vpc(mut self, inp: std::option::Option<crate::model::VPC>) -> Self {
            self.inner = self.inner.set_vpc(inp);
            self
        }
        /// <p>A unique string that identifies the request and that allows failed <code>CreateHostedZone</code> requests to be retried without
        /// the risk of executing the operation twice. You must use a unique <code>CallerReference</code> string every time you submit a
        /// <code>CreateHostedZone</code> request. <code>CallerReference</code> can be any unique string, for example, a date/time stamp.</p>
        pub fn caller_reference(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.caller_reference(inp);
            self
        }
        pub fn set_caller_reference(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_caller_reference(inp);
            self
        }
        /// <p>(Optional) A complex type that contains the following optional values:</p>
        /// <ul>
        /// <li>
        /// <p>For public and private hosted zones, an optional comment</p>
        /// </li>
        /// <li>
        /// <p>For private hosted zones, an optional <code>PrivateZone</code> element</p>
        /// </li>
        /// </ul>
        /// <p>If you don't specify a comment or the <code>PrivateZone</code> element, omit <code>HostedZoneConfig</code> and
        /// the other elements.</p>
        pub fn hosted_zone_config(mut self, inp: crate::model::HostedZoneConfig) -> Self {
            self.inner = self.inner.hosted_zone_config(inp);
            self
        }
        pub fn set_hosted_zone_config(
            mut self,
            inp: std::option::Option<crate::model::HostedZoneConfig>,
        ) -> Self {
            self.inner = self.inner.set_hosted_zone_config(inp);
            self
        }
        /// <p>If you want to associate a reusable delegation set with this hosted zone, the ID that Amazon Route 53 assigned to the reusable delegation set
        /// when you created it. For more information about reusable delegation sets, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateReusableDelegationSet.html">CreateReusableDelegationSet</a>.</p>
        pub fn delegation_set_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delegation_set_id(inp);
            self
        }
        pub fn set_delegation_set_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delegation_set_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateKeySigningKey<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_key_signing_key_input::Builder,
    }
    impl<C> CreateKeySigningKey<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateKeySigningKeyOutput,
            smithy_http::result::SdkError<crate::error::CreateKeySigningKeyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique string that identifies the request.</p>
        pub fn caller_reference(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.caller_reference(inp);
            self
        }
        pub fn set_caller_reference(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_caller_reference(inp);
            self
        }
        /// <p>The unique string (ID) used to identify a hosted zone.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
        /// <p>The Amazon resource name (ARN) for a customer managed customer master key (CMK) in AWS Key Management Service (AWS KMS).
        /// The <code>KeyManagementServiceArn</code> must be unique for each key-signing key (KSK) in a single hosted zone.
        /// To see an example of <code>KeyManagementServiceArn</code> that grants the correct permissions for DNSSEC,
        /// scroll down to <b>Example</b>. </p>
        /// <p>You must configure the customer managed CMK as follows:</p>
        /// <dl>
        /// <dt>Status</dt>
        /// <dd>
        /// <p>Enabled</p>
        /// </dd>
        /// <dt>Key spec</dt>
        /// <dd>
        /// <p>ECC_NIST_P256</p>
        /// </dd>
        /// <dt>Key usage</dt>
        /// <dd>
        /// <p>Sign and verify</p>
        /// </dd>
        /// <dt>Key policy</dt>
        /// <dd>
        /// <p>The key policy must give permission for the following actions:</p>
        /// <ul>
        /// <li>
        /// <p>DescribeKey</p>
        /// </li>
        /// <li>
        /// <p>GetPublicKey</p>
        /// </li>
        /// <li>
        /// <p>Sign</p>
        /// </li>
        /// </ul>
        /// <p>The key policy must also include the Amazon Route 53 service in the principal for your account.
        /// Specify the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>"Service": "dnssec.route53.aws.amazonaws.com"</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </dd>
        /// </dl>
        /// <p>For more information about working with a customer managed CMK in AWS KMS, see
        /// <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html">AWS Key Management Service concepts</a>.</p>
        pub fn key_management_service_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_management_service_arn(inp);
            self
        }
        pub fn set_key_management_service_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_key_management_service_arn(inp);
            self
        }
        /// <p>A string used to identify a key-signing key (KSK). <code>Name</code> can include numbers, letters,  and underscores (_). <code>Name</code> must be unique for each key-signing key in the same
        /// hosted zone.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>A string specifying the initial status of the key-signing key (KSK). You can set the value to <code>ACTIVE</code> or <code>INACTIVE</code>.</p>
        pub fn status(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.status(inp);
            self
        }
        pub fn set_status(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_status(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateQueryLoggingConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_query_logging_config_input::Builder,
    }
    impl<C> CreateQueryLoggingConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateQueryLoggingConfigOutput,
            smithy_http::result::SdkError<crate::error::CreateQueryLoggingConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the hosted zone that you want to log queries for. You can log queries only for public hosted zones.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the log group that you want to Amazon Route 53 to send query logs to. This is the format
        /// of the ARN:</p>
        /// <p>arn:aws:logs:<i>region</i>:<i>account-id</i>:log-group:<i>log_group_name</i>
        /// </p>
        /// <p>To get the ARN for a log group, you can use the CloudWatch console, the
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeLogGroups.html">DescribeLogGroups</a> API action,
        /// the <a href="https://docs.aws.amazon.com/cli/latest/reference/logs/describe-log-groups.html">describe-log-groups</a> command,
        /// or the applicable command in one of the AWS SDKs.</p>
        pub fn cloud_watch_logs_log_group_arn(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.cloud_watch_logs_log_group_arn(inp);
            self
        }
        pub fn set_cloud_watch_logs_log_group_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cloud_watch_logs_log_group_arn(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateReusableDelegationSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_reusable_delegation_set_input::Builder,
    }
    impl<C> CreateReusableDelegationSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateReusableDelegationSetOutput,
            smithy_http::result::SdkError<crate::error::CreateReusableDelegationSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique string that identifies the request, and that allows you to retry failed
        /// <code>CreateReusableDelegationSet</code> requests without the risk of executing the
        /// operation twice. You must use a unique <code>CallerReference</code> string every time you
        /// submit a <code>CreateReusableDelegationSet</code> request. <code>CallerReference</code> can be
        /// any unique string, for example a date/time stamp.</p>
        pub fn caller_reference(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.caller_reference(inp);
            self
        }
        pub fn set_caller_reference(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_caller_reference(inp);
            self
        }
        /// <p>If you want to mark the delegation set for an existing hosted zone as reusable, the ID
        /// for that hosted zone.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTrafficPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_traffic_policy_input::Builder,
    }
    impl<C> CreateTrafficPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateTrafficPolicyOutput,
            smithy_http::result::SdkError<crate::error::CreateTrafficPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the traffic policy.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>The definition of this traffic policy in JSON format. For more information, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/api-policies-traffic-policy-document-format.html">Traffic Policy Document Format</a>.</p>
        pub fn document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document(inp);
            self
        }
        pub fn set_document(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_document(inp);
            self
        }
        /// <p>(Optional) Any comments that you want to include about the traffic policy.</p>
        pub fn comment(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.comment(inp);
            self
        }
        pub fn set_comment(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_comment(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTrafficPolicyInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_traffic_policy_instance_input::Builder,
    }
    impl<C> CreateTrafficPolicyInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateTrafficPolicyInstanceOutput,
            smithy_http::result::SdkError<crate::error::CreateTrafficPolicyInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the hosted zone that you want Amazon Route 53 to create resource record sets in by using the configuration in a traffic policy.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
        /// <p>The domain name (such as example.com) or subdomain name (such as www.example.com) for which Amazon Route 53 responds to DNS queries by using
        /// the resource record sets that Route 53 creates for this traffic policy instance.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>(Optional) The TTL that you want Amazon Route 53 to assign to all of the resource record sets that it creates in the specified hosted zone.</p>
        pub fn ttl(mut self, inp: i64) -> Self {
            self.inner = self.inner.ttl(inp);
            self
        }
        pub fn set_ttl(mut self, inp: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_ttl(inp);
            self
        }
        /// <p>The ID of the traffic policy that you want to use to create resource record sets in the specified hosted zone.</p>
        pub fn traffic_policy_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.traffic_policy_id(inp);
            self
        }
        pub fn set_traffic_policy_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_policy_id(inp);
            self
        }
        /// <p>The version of the traffic policy that you want to use to create resource record sets in the specified hosted zone.</p>
        pub fn traffic_policy_version(mut self, inp: i32) -> Self {
            self.inner = self.inner.traffic_policy_version(inp);
            self
        }
        pub fn set_traffic_policy_version(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_traffic_policy_version(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTrafficPolicyVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_traffic_policy_version_input::Builder,
    }
    impl<C> CreateTrafficPolicyVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateTrafficPolicyVersionOutput,
            smithy_http::result::SdkError<crate::error::CreateTrafficPolicyVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the traffic policy for which you want to create a new version.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
        /// <p>The definition of this version of the traffic policy, in JSON format. You specified the JSON in the <code>CreateTrafficPolicyVersion</code>
        /// request. For more information about the JSON format, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateTrafficPolicy.html">CreateTrafficPolicy</a>.</p>
        pub fn document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.document(inp);
            self
        }
        pub fn set_document(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_document(inp);
            self
        }
        /// <p>The comment that you specified in the <code>CreateTrafficPolicyVersion</code> request, if any.</p>
        pub fn comment(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.comment(inp);
            self
        }
        pub fn set_comment(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_comment(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateVPCAssociationAuthorization<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_vpc_association_authorization_input::Builder,
    }
    impl<C> CreateVPCAssociationAuthorization<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateVPCAssociationAuthorizationOutput,
            smithy_http::result::SdkError<crate::error::CreateVPCAssociationAuthorizationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the private hosted zone that you want to authorize associating a VPC with.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
        /// <p>A complex type that contains the VPC ID and region for the VPC that you want to authorize associating
        /// with your hosted zone.</p>
        pub fn vpc(mut self, inp: crate::model::VPC) -> Self {
            self.inner = self.inner.vpc(inp);
            self
        }
        pub fn set_vpc(mut self, inp: std::option::Option<crate::model::VPC>) -> Self {
            self.inner = self.inner.set_vpc(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeactivateKeySigningKey<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::deactivate_key_signing_key_input::Builder,
    }
    impl<C> DeactivateKeySigningKey<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeactivateKeySigningKeyOutput,
            smithy_http::result::SdkError<crate::error::DeactivateKeySigningKeyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique string used to identify a hosted zone.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
        /// <p>A string used to identify a key-signing key (KSK).</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteHealthCheck<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_health_check_input::Builder,
    }
    impl<C> DeleteHealthCheck<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteHealthCheckOutput,
            smithy_http::result::SdkError<crate::error::DeleteHealthCheckError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the health check that you want to delete.</p>
        pub fn health_check_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.health_check_id(inp);
            self
        }
        pub fn set_health_check_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_health_check_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteHostedZone<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_hosted_zone_input::Builder,
    }
    impl<C> DeleteHostedZone<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteHostedZoneOutput,
            smithy_http::result::SdkError<crate::error::DeleteHostedZoneError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the hosted zone you want to delete.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteKeySigningKey<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_key_signing_key_input::Builder,
    }
    impl<C> DeleteKeySigningKey<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteKeySigningKeyOutput,
            smithy_http::result::SdkError<crate::error::DeleteKeySigningKeyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique string used to identify a hosted zone.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
        /// <p>A string used to identify a key-signing key (KSK).</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteQueryLoggingConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_query_logging_config_input::Builder,
    }
    impl<C> DeleteQueryLoggingConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteQueryLoggingConfigOutput,
            smithy_http::result::SdkError<crate::error::DeleteQueryLoggingConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the configuration that you want to delete. </p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteReusableDelegationSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_reusable_delegation_set_input::Builder,
    }
    impl<C> DeleteReusableDelegationSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteReusableDelegationSetOutput,
            smithy_http::result::SdkError<crate::error::DeleteReusableDelegationSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the reusable delegation set that you want to delete.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTrafficPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_traffic_policy_input::Builder,
    }
    impl<C> DeleteTrafficPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteTrafficPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteTrafficPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the traffic policy that you want to delete.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
        /// <p>The version number of the traffic policy that you want to delete.</p>
        pub fn version(mut self, inp: i32) -> Self {
            self.inner = self.inner.version(inp);
            self
        }
        pub fn set_version(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_version(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTrafficPolicyInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_traffic_policy_instance_input::Builder,
    }
    impl<C> DeleteTrafficPolicyInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteTrafficPolicyInstanceOutput,
            smithy_http::result::SdkError<crate::error::DeleteTrafficPolicyInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the traffic policy instance that you want to delete. </p>
        /// <important>
        /// <p>When you delete a traffic policy instance, Amazon Route 53 also deletes all of the resource record sets that were created when you created
        /// the traffic policy instance.</p>
        /// </important>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteVPCAssociationAuthorization<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_vpc_association_authorization_input::Builder,
    }
    impl<C> DeleteVPCAssociationAuthorization<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteVPCAssociationAuthorizationOutput,
            smithy_http::result::SdkError<crate::error::DeleteVPCAssociationAuthorizationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>When removing authorization to associate a VPC that was created by one AWS account with a hosted zone
        /// that was created with a different AWS account, the ID of the hosted zone.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
        /// <p>When removing authorization to associate a VPC that was created by one AWS account with a hosted zone
        /// that was created with a different AWS account, a complex type that includes the ID and region of the VPC.</p>
        pub fn vpc(mut self, inp: crate::model::VPC) -> Self {
            self.inner = self.inner.vpc(inp);
            self
        }
        pub fn set_vpc(mut self, inp: std::option::Option<crate::model::VPC>) -> Self {
            self.inner = self.inner.set_vpc(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableHostedZoneDNSSEC<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disable_hosted_zone_dnssec_input::Builder,
    }
    impl<C> DisableHostedZoneDNSSEC<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DisableHostedZoneDNSSECOutput,
            smithy_http::result::SdkError<crate::error::DisableHostedZoneDNSSECError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique string used to identify a hosted zone.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateVPCFromHostedZone<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_vpc_from_hosted_zone_input::Builder,
    }
    impl<C> DisassociateVPCFromHostedZone<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DisassociateVPCFromHostedZoneOutput,
            smithy_http::result::SdkError<crate::error::DisassociateVPCFromHostedZoneError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the private hosted zone that you want to disassociate a VPC from.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
        /// <p>A complex type that contains information about the VPC that you're disassociating
        /// from the specified hosted zone.</p>
        pub fn vpc(mut self, inp: crate::model::VPC) -> Self {
            self.inner = self.inner.vpc(inp);
            self
        }
        pub fn set_vpc(mut self, inp: std::option::Option<crate::model::VPC>) -> Self {
            self.inner = self.inner.set_vpc(inp);
            self
        }
        /// <p>
        /// <i>Optional:</i> A comment about the disassociation request.</p>
        pub fn comment(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.comment(inp);
            self
        }
        pub fn set_comment(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_comment(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableHostedZoneDNSSEC<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enable_hosted_zone_dnssec_input::Builder,
    }
    impl<C> EnableHostedZoneDNSSEC<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::EnableHostedZoneDNSSECOutput,
            smithy_http::result::SdkError<crate::error::EnableHostedZoneDNSSECError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique string used to identify a hosted zone.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccountLimit<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_account_limit_input::Builder,
    }
    impl<C> GetAccountLimit<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetAccountLimitOutput,
            smithy_http::result::SdkError<crate::error::GetAccountLimitError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The limit that you want to get. Valid values include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>MAX_HEALTH_CHECKS_BY_OWNER</b>: The maximum number of health checks that you can create
        /// using the current account.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>MAX_HOSTED_ZONES_BY_OWNER</b>: The maximum number of hosted zones that you can create
        /// using the current account.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>MAX_REUSABLE_DELEGATION_SETS_BY_OWNER</b>: The maximum number of reusable delegation sets
        /// that you can create using the current account.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>MAX_TRAFFIC_POLICIES_BY_OWNER</b>: The maximum number of traffic policies
        /// that you can create using the current account.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>MAX_TRAFFIC_POLICY_INSTANCES_BY_OWNER</b>: The maximum number of traffic policy instances
        /// that you can create using the current account. (Traffic policy instances are referred to as traffic flow policy records in the
        /// Amazon Route 53 console.)</p>
        /// </li>
        /// </ul>
        pub fn r#type(mut self, inp: crate::model::AccountLimitType) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(mut self, inp: crate::model::AccountLimitType) -> Self {
            self.inner = self.inner.set_type(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetChange<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_change_input::Builder,
    }
    impl<C> GetChange<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetChangeOutput,
            smithy_http::result::SdkError<crate::error::GetChangeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the change batch request. The value that you specify here is the value that <code>ChangeResourceRecordSets</code>
        /// returned in the <code>Id</code> element when you submitted the request.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCheckerIpRanges<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_checker_ip_ranges_input::Builder,
    }
    impl<C> GetCheckerIpRanges<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetCheckerIpRangesOutput,
            smithy_http::result::SdkError<crate::error::GetCheckerIpRangesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDNSSEC<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_dnssec_input::Builder,
    }
    impl<C> GetDNSSEC<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetDNSSECOutput,
            smithy_http::result::SdkError<crate::error::GetDNSSECError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique string used to identify a hosted zone.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetGeoLocation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_geo_location_input::Builder,
    }
    impl<C> GetGeoLocation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetGeoLocationOutput,
            smithy_http::result::SdkError<crate::error::GetGeoLocationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>For geolocation resource record sets, a two-letter abbreviation that identifies a continent. Amazon Route 53 supports the following continent codes:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>AF</b>: Africa</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>AN</b>: Antarctica</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>AS</b>: Asia</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>EU</b>: Europe</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>OC</b>: Oceania</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>NA</b>: North America</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>SA</b>: South America</p>
        /// </li>
        /// </ul>
        pub fn continent_code(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.continent_code(inp);
            self
        }
        pub fn set_continent_code(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_continent_code(inp);
            self
        }
        /// <p>Amazon Route 53 uses the two-letter country codes that are specified in
        /// <a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2">ISO standard 3166-1 alpha-2</a>.</p>
        pub fn country_code(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.country_code(inp);
            self
        }
        pub fn set_country_code(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_country_code(inp);
            self
        }
        /// <p>The code for the subdivision, such as a particular state within the United States. For a list of US state abbreviations, see <a href="https://pe.usps.com/text/pub28/28apb.htm">Appendix B: Two–Letter State and Possession Abbreviations</a>  on the United States Postal Service website. For a list of all supported subdivision codes, use the <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ListGeoLocations.html">ListGeoLocations</a> API.</p>
        pub fn subdivision_code(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subdivision_code(inp);
            self
        }
        pub fn set_subdivision_code(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_subdivision_code(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetHealthCheck<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_health_check_input::Builder,
    }
    impl<C> GetHealthCheck<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetHealthCheckOutput,
            smithy_http::result::SdkError<crate::error::GetHealthCheckError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier that Amazon Route 53 assigned to the health check when you created it. When you add or update a resource record set,
        /// you use this value to specify which health check to use. The value can be up to 64 characters long.</p>
        pub fn health_check_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.health_check_id(inp);
            self
        }
        pub fn set_health_check_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_health_check_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetHealthCheckCount<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_health_check_count_input::Builder,
    }
    impl<C> GetHealthCheckCount<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetHealthCheckCountOutput,
            smithy_http::result::SdkError<crate::error::GetHealthCheckCountError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetHealthCheckLastFailureReason<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_health_check_last_failure_reason_input::Builder,
    }
    impl<C> GetHealthCheckLastFailureReason<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetHealthCheckLastFailureReasonOutput,
            smithy_http::result::SdkError<crate::error::GetHealthCheckLastFailureReasonError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID for the health check for which you want the last failure reason. When you created the health check,
        /// <code>CreateHealthCheck</code> returned the ID in the response, in the <code>HealthCheckId</code> element.</p>
        /// <note>
        /// <p>If you want to get the last failure reason for a calculated health check, you must use the Amazon Route 53 console or the
        /// CloudWatch console. You can't use <code>GetHealthCheckLastFailureReason</code> for a calculated health check.</p>
        /// </note>
        pub fn health_check_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.health_check_id(inp);
            self
        }
        pub fn set_health_check_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_health_check_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetHealthCheckStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_health_check_status_input::Builder,
    }
    impl<C> GetHealthCheckStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetHealthCheckStatusOutput,
            smithy_http::result::SdkError<crate::error::GetHealthCheckStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID for the health check that you want the current status for. When you created the health check,
        /// <code>CreateHealthCheck</code> returned the ID in the response, in the <code>HealthCheckId</code> element.</p>
        /// <note>
        /// <p>If you want to check the status of a calculated health check, you must use the Amazon Route 53 console or the CloudWatch console.
        /// You can't use <code>GetHealthCheckStatus</code> to get the status of a calculated health check.</p>
        /// </note>
        pub fn health_check_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.health_check_id(inp);
            self
        }
        pub fn set_health_check_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_health_check_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetHostedZone<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_hosted_zone_input::Builder,
    }
    impl<C> GetHostedZone<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetHostedZoneOutput,
            smithy_http::result::SdkError<crate::error::GetHostedZoneError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the hosted zone that you want to get information about.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetHostedZoneCount<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_hosted_zone_count_input::Builder,
    }
    impl<C> GetHostedZoneCount<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetHostedZoneCountOutput,
            smithy_http::result::SdkError<crate::error::GetHostedZoneCountError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetHostedZoneLimit<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_hosted_zone_limit_input::Builder,
    }
    impl<C> GetHostedZoneLimit<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetHostedZoneLimitOutput,
            smithy_http::result::SdkError<crate::error::GetHostedZoneLimitError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The limit that you want to get. Valid values include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>MAX_RRSETS_BY_ZONE</b>: The maximum number of records that you can create
        /// in the specified hosted zone.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>MAX_VPCS_ASSOCIATED_BY_ZONE</b>: The maximum number of Amazon VPCs that you can
        /// associate with the specified private hosted zone.</p>
        /// </li>
        /// </ul>
        pub fn r#type(mut self, inp: crate::model::HostedZoneLimitType) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(mut self, inp: crate::model::HostedZoneLimitType) -> Self {
            self.inner = self.inner.set_type(inp);
            self
        }
        /// <p>The ID of the hosted zone that you want to get a limit for.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetQueryLoggingConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_query_logging_config_input::Builder,
    }
    impl<C> GetQueryLoggingConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetQueryLoggingConfigOutput,
            smithy_http::result::SdkError<crate::error::GetQueryLoggingConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the configuration for DNS query logging that you want to get information about.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetReusableDelegationSet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_reusable_delegation_set_input::Builder,
    }
    impl<C> GetReusableDelegationSet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetReusableDelegationSetOutput,
            smithy_http::result::SdkError<crate::error::GetReusableDelegationSetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the reusable delegation set that you want to get a list of name servers for.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetReusableDelegationSetLimit<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_reusable_delegation_set_limit_input::Builder,
    }
    impl<C> GetReusableDelegationSetLimit<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetReusableDelegationSetLimitOutput,
            smithy_http::result::SdkError<crate::error::GetReusableDelegationSetLimitError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specify <code>MAX_ZONES_BY_REUSABLE_DELEGATION_SET</code> to get the maximum number of hosted zones that you can associate
        /// with the specified reusable delegation set.</p>
        pub fn r#type(mut self, inp: crate::model::ReusableDelegationSetLimitType) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(mut self, inp: crate::model::ReusableDelegationSetLimitType) -> Self {
            self.inner = self.inner.set_type(inp);
            self
        }
        /// <p>The ID of the delegation set that you want to get the limit for.</p>
        pub fn delegation_set_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delegation_set_id(inp);
            self
        }
        pub fn set_delegation_set_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_delegation_set_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTrafficPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_traffic_policy_input::Builder,
    }
    impl<C> GetTrafficPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetTrafficPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetTrafficPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the traffic policy that you want to get information about.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
        /// <p>The version number of the traffic policy that you want to get information about.</p>
        pub fn version(mut self, inp: i32) -> Self {
            self.inner = self.inner.version(inp);
            self
        }
        pub fn set_version(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_version(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTrafficPolicyInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_traffic_policy_instance_input::Builder,
    }
    impl<C> GetTrafficPolicyInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetTrafficPolicyInstanceOutput,
            smithy_http::result::SdkError<crate::error::GetTrafficPolicyInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the traffic policy instance that you want to get information about.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTrafficPolicyInstanceCount<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_traffic_policy_instance_count_input::Builder,
    }
    impl<C> GetTrafficPolicyInstanceCount<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetTrafficPolicyInstanceCountOutput,
            smithy_http::result::SdkError<crate::error::GetTrafficPolicyInstanceCountError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListGeoLocations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_geo_locations_input::Builder,
    }
    impl<C> ListGeoLocations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListGeoLocationsOutput,
            smithy_http::result::SdkError<crate::error::ListGeoLocationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The code for the continent with which you want to start listing locations that Amazon Route 53 supports for geolocation. If Route 53 has already
        /// returned a page or more of results, if <code>IsTruncated</code> is true, and if <code>NextContinentCode</code> from the previous
        /// response has a value, enter that value in <code>startcontinentcode</code> to return the next page of results.</p>
        /// <p>Include <code>startcontinentcode</code> only if you want to list continents. Don't include <code>startcontinentcode</code>
        /// when you're listing countries or countries with their subdivisions.</p>
        pub fn start_continent_code(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.start_continent_code(inp);
            self
        }
        pub fn set_start_continent_code(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_start_continent_code(inp);
            self
        }
        /// <p>The code for the country with which you want to start listing locations that Amazon Route 53 supports for geolocation. If Route 53 has already
        /// returned a page or more of results, if <code>IsTruncated</code> is <code>true</code>, and if <code>NextCountryCode</code> from the
        /// previous response has a value, enter that value in <code>startcountrycode</code> to return the next page of results.</p>
        pub fn start_country_code(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.start_country_code(inp);
            self
        }
        pub fn set_start_country_code(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_start_country_code(inp);
            self
        }
        /// <p>The code for the state of the United States with which you want to start listing locations that Amazon Route 53 supports
        /// for geolocation. If Route 53 has already returned a page or more of results, if <code>IsTruncated</code> is <code>true</code>, and if
        /// <code>NextSubdivisionCode</code> from the previous response has a value, enter that value in <code>startsubdivisioncode</code>
        /// to return the next page of results.</p>
        /// <p>To list subdivisions (U.S. states), you must include both <code>startcountrycode</code> and <code>startsubdivisioncode</code>.</p>
        pub fn start_subdivision_code(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.start_subdivision_code(inp);
            self
        }
        pub fn set_start_subdivision_code(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_start_subdivision_code(inp);
            self
        }
        /// <p>(Optional) The maximum number of geolocations to be included in the response body for this request. If more than <code>maxitems</code>
        /// geolocations remain to be listed, then the value of the <code>IsTruncated</code> element in the response is <code>true</code>.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListHealthChecks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_health_checks_input::Builder,
    }
    impl<C> ListHealthChecks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListHealthChecksOutput,
            smithy_http::result::SdkError<crate::error::ListHealthChecksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>true</code>, you have more health checks. To get another group,
        /// submit another <code>ListHealthChecks</code> request. </p>
        /// <p>For the value of <code>marker</code>, specify the value of <code>NextMarker</code> from the previous response,
        /// which is the ID of the first health check that Amazon Route 53 will return if you submit another request.</p>
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more health checks to get.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>The maximum number of health checks that you want <code>ListHealthChecks</code> to return in response to the current request.
        /// Amazon Route 53 returns a maximum of 100 items. If you set <code>MaxItems</code> to a value greater than 100, Route 53 returns only the first 100 health checks. </p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListHostedZones<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_hosted_zones_input::Builder,
    }
    impl<C> ListHostedZones<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListHostedZonesOutput,
            smithy_http::result::SdkError<crate::error::ListHostedZonesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>true</code>, you have more hosted zones.
        /// To get more hosted zones, submit another <code>ListHostedZones</code> request. </p>
        /// <p>For the value of <code>marker</code>, specify the value of <code>NextMarker</code> from the previous response,
        /// which is the ID of the first hosted zone that Amazon Route 53 will return if you submit another request.</p>
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more hosted zones to get.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>(Optional) The maximum number of hosted zones that you want Amazon Route 53 to return. If you have more than <code>maxitems</code>
        /// hosted zones, the value of <code>IsTruncated</code> in the response is <code>true</code>, and the value of <code>NextMarker</code>
        /// is the hosted zone ID of the first hosted zone that Route 53 will return if you submit another request.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
        /// <p>If you're using reusable delegation sets and you want to list all of the hosted zones that are associated
        /// with a reusable delegation set, specify the ID of that reusable delegation set. </p>
        pub fn delegation_set_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.delegation_set_id(inp);
            self
        }
        pub fn set_delegation_set_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_delegation_set_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListHostedZonesByName<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_hosted_zones_by_name_input::Builder,
    }
    impl<C> ListHostedZonesByName<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListHostedZonesByNameOutput,
            smithy_http::result::SdkError<crate::error::ListHostedZonesByNameError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>(Optional) For your first request to <code>ListHostedZonesByName</code>, include the <code>dnsname</code> parameter only if you want to
        /// specify the name of the first hosted zone in the response. If you don't include the <code>dnsname</code> parameter, Amazon Route 53 returns all of
        /// the hosted zones that were created by the current AWS account, in ASCII order. For subsequent requests, include both <code>dnsname</code> and
        /// <code>hostedzoneid</code> parameters. For <code>dnsname</code>, specify the value of <code>NextDNSName</code> from the previous response.</p>
        pub fn dns_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dns_name(inp);
            self
        }
        pub fn set_dns_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_dns_name(inp);
            self
        }
        /// <p>(Optional) For your first request to <code>ListHostedZonesByName</code>, do not include the <code>hostedzoneid</code> parameter.</p>
        /// <p>If you have more hosted zones than the value of <code>maxitems</code>, <code>ListHostedZonesByName</code> returns only the first
        /// <code>maxitems</code> hosted zones. To get the next group of <code>maxitems</code> hosted zones, submit another request to
        /// <code>ListHostedZonesByName</code> and include both <code>dnsname</code> and <code>hostedzoneid</code> parameters. For the value of
        /// <code>hostedzoneid</code>, specify the value of the <code>NextHostedZoneId</code> element from the previous response.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
        /// <p>The maximum number of hosted zones to be included in the response body for this request. If you have more than <code>maxitems</code>
        /// hosted zones, then the value of the <code>IsTruncated</code> element in the response is true, and the values of <code>NextDNSName</code> and
        /// <code>NextHostedZoneId</code> specify the first hosted zone in the next group of <code>maxitems</code> hosted zones. </p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListHostedZonesByVPC<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_hosted_zones_by_vpc_input::Builder,
    }
    impl<C> ListHostedZonesByVPC<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListHostedZonesByVPCOutput,
            smithy_http::result::SdkError<crate::error::ListHostedZonesByVPCError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Amazon VPC that you want to list hosted zones for.</p>
        pub fn vpc_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(inp);
            self
        }
        pub fn set_vpc_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(inp);
            self
        }
        /// <p>For the Amazon VPC that you specified for <code>VPCId</code>, the AWS Region that you created the VPC in. </p>
        pub fn vpc_region(mut self, inp: crate::model::VpcRegion) -> Self {
            self.inner = self.inner.vpc_region(inp);
            self
        }
        pub fn set_vpc_region(mut self, inp: std::option::Option<crate::model::VpcRegion>) -> Self {
            self.inner = self.inner.set_vpc_region(inp);
            self
        }
        /// <p>(Optional) The maximum number of hosted zones that you want Amazon Route 53 to return. If the specified VPC is associated with
        /// more than <code>MaxItems</code> hosted zones, the response includes a <code>NextToken</code> element. <code>NextToken</code> contains
        /// an encrypted token that identifies the first hosted zone that Route 53 will return if you submit another request.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
        /// <p>If the previous response included a <code>NextToken</code> element, the specified VPC is associated with more hosted zones.
        /// To get more hosted zones, submit another <code>ListHostedZonesByVPC</code> request. </p>
        /// <p>For the value of <code>NextToken</code>, specify the value of <code>NextToken</code> from the previous response.</p>
        /// <p>If the previous response didn't include a <code>NextToken</code> element, there are no more hosted zones to get.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListQueryLoggingConfigs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_query_logging_configs_input::Builder,
    }
    impl<C> ListQueryLoggingConfigs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListQueryLoggingConfigsOutput,
            smithy_http::result::SdkError<crate::error::ListQueryLoggingConfigsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>(Optional) If you want to list the query logging configuration that is associated with a hosted zone, specify the ID in
        /// <code>HostedZoneId</code>. </p>
        /// <p>If you don't specify a hosted zone ID, <code>ListQueryLoggingConfigs</code> returns all of the configurations
        /// that are associated with the current AWS account.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
        /// <p>(Optional) If the current AWS account has more than <code>MaxResults</code> query logging configurations, use <code>NextToken</code>
        /// to get the second and subsequent pages of results.</p>
        /// <p>For the first <code>ListQueryLoggingConfigs</code> request, omit this value.</p>
        /// <p>For the second and subsequent requests, get the value of <code>NextToken</code> from the previous response and specify that value
        /// for <code>NextToken</code> in the request.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>(Optional) The maximum number of query logging configurations that you want Amazon Route 53 to return in response to the current request.
        /// If the current AWS account has more than <code>MaxResults</code> configurations, use the value of
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ListQueryLoggingConfigs.html#API_ListQueryLoggingConfigs_RequestSyntax">NextToken</a>
        /// in the response to get the next page of results.</p>
        /// <p>If you don't specify a value for <code>MaxResults</code>, Route 53 returns up to 100 configurations.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListResourceRecordSets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_resource_record_sets_input::Builder,
    }
    impl<C> ListResourceRecordSets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListResourceRecordSetsOutput,
            smithy_http::result::SdkError<crate::error::ListResourceRecordSetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the hosted zone that contains the resource record sets that you want to list.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
        /// <p>The first name in the lexicographic ordering of resource record sets that you want to list.
        /// If the specified record name doesn't exist, the results begin with the first resource record set that has a name
        /// greater than the value of <code>name</code>.</p>
        pub fn start_record_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.start_record_name(inp);
            self
        }
        pub fn set_start_record_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_start_record_name(inp);
            self
        }
        /// <p>The type of resource record set to begin the record listing from.</p>
        /// <p>Valid values for basic resource record sets: <code>A</code> | <code>AAAA</code> | <code>CAA</code> | <code>CNAME</code> | <code>MX</code> |
        /// <code>NAPTR</code> | <code>NS</code> | <code>PTR</code> | <code>SOA</code> | <code>SPF</code> | <code>SRV</code> | <code>TXT</code>
        /// </p>
        /// <p>Values for weighted, latency, geolocation, and failover resource record sets: <code>A</code> | <code>AAAA</code> | <code>CAA</code> | <code>CNAME</code> |
        /// <code>MX</code> | <code>NAPTR</code> | <code>PTR</code> | <code>SPF</code> | <code>SRV</code> | <code>TXT</code>
        /// </p>
        /// <p>Values for alias resource record sets: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>API Gateway custom regional API or edge-optimized API</b>: A</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>CloudFront distribution</b>: A or AAAA</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Elastic Beanstalk environment that has a regionalized subdomain</b>: A</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Elastic Load Balancing load balancer</b>: A | AAAA</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>S3 bucket</b>: A</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>VPC interface VPC endpoint</b>: A</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Another resource record set in this hosted zone:</b> The type of the resource record set
        /// that the alias references.</p>
        /// </li>
        /// </ul>
        /// <p>Constraint: Specifying <code>type</code> without specifying <code>name</code> returns an <code>InvalidInput</code> error.</p>
        pub fn start_record_type(mut self, inp: crate::model::RrType) -> Self {
            self.inner = self.inner.start_record_type(inp);
            self
        }
        pub fn set_start_record_type(
            mut self,
            inp: std::option::Option<crate::model::RrType>,
        ) -> Self {
            self.inner = self.inner.set_start_record_type(inp);
            self
        }
        /// <p>
        /// <i>Resource record sets that have a routing policy other than simple:</i> If results were truncated for a given DNS name and type,
        /// specify the value of <code>NextRecordIdentifier</code> from the previous response to get the next resource record set that has the current
        /// DNS name and type.</p>
        pub fn start_record_identifier(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.start_record_identifier(inp);
            self
        }
        pub fn set_start_record_identifier(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_start_record_identifier(inp);
            self
        }
        /// <p>(Optional) The maximum number of resource records sets to include in the response body for this request. If the response includes
        /// more than <code>maxitems</code> resource record sets, the value of the <code>IsTruncated</code> element in the response is <code>true</code>,
        /// and the values of the <code>NextRecordName</code> and <code>NextRecordType</code> elements in the response identify the first
        /// resource record set in the next group of <code>maxitems</code> resource record sets.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListReusableDelegationSets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_reusable_delegation_sets_input::Builder,
    }
    impl<C> ListReusableDelegationSets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListReusableDelegationSetsOutput,
            smithy_http::result::SdkError<crate::error::ListReusableDelegationSetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>true</code>, you have more reusable delegation sets.
        /// To get another group, submit another <code>ListReusableDelegationSets</code> request. </p>
        /// <p>For the value of <code>marker</code>, specify the value of <code>NextMarker</code> from the previous response,
        /// which is the ID of the first reusable delegation set that Amazon Route 53 will return if you submit another request.</p>
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more reusable delegation sets to get.</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(inp);
            self
        }
        /// <p>The number of reusable delegation sets that you want Amazon Route 53 to return in the response to this request. If you specify a value
        /// greater than 100, Route 53 returns only the first 100 reusable delegation sets.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The type of the resource.</p>
        /// <ul>
        /// <li>
        /// <p>The resource type for health checks is <code>healthcheck</code>.</p>
        /// </li>
        /// <li>
        /// <p>The resource type for hosted zones is <code>hostedzone</code>.</p>
        /// </li>
        /// </ul>
        pub fn resource_type(mut self, inp: crate::model::TagResourceType) -> Self {
            self.inner = self.inner.resource_type(inp);
            self
        }
        pub fn set_resource_type(mut self, inp: crate::model::TagResourceType) -> Self {
            self.inner = self.inner.set_resource_type(inp);
            self
        }
        /// <p>The ID of the resource for which you want to retrieve tags.</p>
        pub fn resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(inp);
            self
        }
        pub fn set_resource_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_resource_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResources<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resources_input::Builder,
    }
    impl<C> ListTagsForResources<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListTagsForResourcesOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourcesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The type of the resources.</p>
        /// <ul>
        /// <li>
        /// <p>The resource type for health checks is <code>healthcheck</code>.</p>
        /// </li>
        /// <li>
        /// <p>The resource type for hosted zones is <code>hostedzone</code>.</p>
        /// </li>
        /// </ul>
        pub fn resource_type(mut self, inp: crate::model::TagResourceType) -> Self {
            self.inner = self.inner.resource_type(inp);
            self
        }
        pub fn set_resource_type(mut self, inp: crate::model::TagResourceType) -> Self {
            self.inner = self.inner.set_resource_type(inp);
            self
        }
        /// <p>A complex type that contains the ResourceId element for each resource for which you want to get a list of tags.</p>
        pub fn resource_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_ids(inp);
            self
        }
        pub fn set_resource_ids(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_resource_ids(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTrafficPolicies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_traffic_policies_input::Builder,
    }
    impl<C> ListTrafficPolicies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListTrafficPoliciesOutput,
            smithy_http::result::SdkError<crate::error::ListTrafficPoliciesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>(Conditional) For your first request to <code>ListTrafficPolicies</code>, don't include the <code>TrafficPolicyIdMarker</code> parameter.</p>
        /// <p>If you have more traffic policies than the value of <code>MaxItems</code>, <code>ListTrafficPolicies</code> returns only the first
        /// <code>MaxItems</code> traffic policies. To get the next group of policies, submit another request to <code>ListTrafficPolicies</code>.
        /// For the value of <code>TrafficPolicyIdMarker</code>, specify the value of <code>TrafficPolicyIdMarker</code> that was returned in the
        /// previous response.</p>
        pub fn traffic_policy_id_marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.traffic_policy_id_marker(inp);
            self
        }
        pub fn set_traffic_policy_id_marker(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_policy_id_marker(inp);
            self
        }
        /// <p>(Optional) The maximum number of traffic policies that you want Amazon Route 53 to return in response to this request. If you have more than
        /// <code>MaxItems</code> traffic policies, the value of <code>IsTruncated</code> in the response is <code>true</code>, and the
        /// value of <code>TrafficPolicyIdMarker</code> is the ID of the first traffic policy that Route 53 will return if you submit
        /// another request.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTrafficPolicyInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_traffic_policy_instances_input::Builder,
    }
    impl<C> ListTrafficPolicyInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListTrafficPolicyInstancesOutput,
            smithy_http::result::SdkError<crate::error::ListTrafficPolicyInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>true</code>, you have more traffic policy instances.
        /// To get more traffic policy instances, submit another <code>ListTrafficPolicyInstances</code> request. For the value of <code>HostedZoneId</code>,
        /// specify the value of <code>HostedZoneIdMarker</code> from the previous response, which is the hosted zone ID of the first traffic policy instance
        /// in the next group of traffic policy instances.</p>
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more traffic policy instances to get.</p>
        pub fn hosted_zone_id_marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id_marker(inp);
            self
        }
        pub fn set_hosted_zone_id_marker(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_hosted_zone_id_marker(inp);
            self
        }
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>true</code>, you have more traffic policy instances.
        /// To get more traffic policy instances, submit another <code>ListTrafficPolicyInstances</code> request. For the value of <code>trafficpolicyinstancename</code>,
        /// specify the value of <code>TrafficPolicyInstanceNameMarker</code> from the previous response, which is the name of the first traffic policy instance
        /// in the next group of traffic policy instances.</p>
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more traffic policy instances to get.</p>
        pub fn traffic_policy_instance_name_marker(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.traffic_policy_instance_name_marker(inp);
            self
        }
        pub fn set_traffic_policy_instance_name_marker(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_policy_instance_name_marker(inp);
            self
        }
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>true</code>, you have more traffic policy instances.
        /// To get more traffic policy instances, submit another <code>ListTrafficPolicyInstances</code> request. For the value of <code>trafficpolicyinstancetype</code>,
        /// specify the value of <code>TrafficPolicyInstanceTypeMarker</code> from the previous response, which is the type of the first traffic policy instance
        /// in the next group of traffic policy instances.</p>
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more traffic policy instances to get.</p>
        pub fn traffic_policy_instance_type_marker(mut self, inp: crate::model::RrType) -> Self {
            self.inner = self.inner.traffic_policy_instance_type_marker(inp);
            self
        }
        pub fn set_traffic_policy_instance_type_marker(
            mut self,
            inp: std::option::Option<crate::model::RrType>,
        ) -> Self {
            self.inner = self.inner.set_traffic_policy_instance_type_marker(inp);
            self
        }
        /// <p>The maximum number of traffic policy instances that you want Amazon Route 53 to return in response to a <code>ListTrafficPolicyInstances</code> request.
        /// If you have more than <code>MaxItems</code> traffic policy instances, the value of the <code>IsTruncated</code> element in the response is
        /// <code>true</code>, and the values of <code>HostedZoneIdMarker</code>, <code>TrafficPolicyInstanceNameMarker</code>, and
        /// <code>TrafficPolicyInstanceTypeMarker</code> represent the first traffic policy instance in the next group of <code>MaxItems</code>
        /// traffic policy instances.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTrafficPolicyInstancesByHostedZone<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_traffic_policy_instances_by_hosted_zone_input::Builder,
    }
    impl<C> ListTrafficPolicyInstancesByHostedZone<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListTrafficPolicyInstancesByHostedZoneOutput,
            smithy_http::result::SdkError<
                crate::error::ListTrafficPolicyInstancesByHostedZoneError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the hosted zone that you want to list traffic policy instances for.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
        /// <p>If the value of <code>IsTruncated</code> in the previous response is true, you have more traffic policy instances.
        /// To get more traffic policy instances, submit another <code>ListTrafficPolicyInstances</code> request. For the value of <code>trafficpolicyinstancename</code>,
        /// specify the value of <code>TrafficPolicyInstanceNameMarker</code> from the previous response, which is the name of the first traffic policy instance
        /// in the next group of traffic policy instances.</p>
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more traffic policy instances to get.</p>
        pub fn traffic_policy_instance_name_marker(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.traffic_policy_instance_name_marker(inp);
            self
        }
        pub fn set_traffic_policy_instance_name_marker(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_policy_instance_name_marker(inp);
            self
        }
        /// <p>If the value of <code>IsTruncated</code> in the previous response is true, you have more traffic policy instances.
        /// To get more traffic policy instances, submit another <code>ListTrafficPolicyInstances</code> request. For the value of <code>trafficpolicyinstancetype</code>,
        /// specify the value of <code>TrafficPolicyInstanceTypeMarker</code> from the previous response, which is the type of the first traffic policy instance
        /// in the next group of traffic policy instances.</p>
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more traffic policy instances to get.</p>
        pub fn traffic_policy_instance_type_marker(mut self, inp: crate::model::RrType) -> Self {
            self.inner = self.inner.traffic_policy_instance_type_marker(inp);
            self
        }
        pub fn set_traffic_policy_instance_type_marker(
            mut self,
            inp: std::option::Option<crate::model::RrType>,
        ) -> Self {
            self.inner = self.inner.set_traffic_policy_instance_type_marker(inp);
            self
        }
        /// <p>The maximum number of traffic policy instances to be included in the response body for this request. If you have more than
        /// <code>MaxItems</code> traffic policy instances, the value of the <code>IsTruncated</code> element in the response is <code>true</code>,
        /// and the values of <code>HostedZoneIdMarker</code>, <code>TrafficPolicyInstanceNameMarker</code>, and <code>TrafficPolicyInstanceTypeMarker</code>
        /// represent the first traffic policy instance that Amazon Route 53 will return if you submit another request.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTrafficPolicyInstancesByPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_traffic_policy_instances_by_policy_input::Builder,
    }
    impl<C> ListTrafficPolicyInstancesByPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListTrafficPolicyInstancesByPolicyOutput,
            smithy_http::result::SdkError<crate::error::ListTrafficPolicyInstancesByPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the traffic policy for which you want to list traffic policy instances.</p>
        pub fn traffic_policy_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.traffic_policy_id(inp);
            self
        }
        pub fn set_traffic_policy_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_policy_id(inp);
            self
        }
        /// <p>The version of the traffic policy for which you want to list traffic policy instances. The version must be associated with the
        /// traffic policy that is specified by <code>TrafficPolicyId</code>.</p>
        pub fn traffic_policy_version(mut self, inp: i32) -> Self {
            self.inner = self.inner.traffic_policy_version(inp);
            self
        }
        pub fn set_traffic_policy_version(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_traffic_policy_version(inp);
            self
        }
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>true</code>, you have more traffic policy instances.
        /// To get more traffic policy instances, submit another <code>ListTrafficPolicyInstancesByPolicy</code> request. </p>
        /// <p>For the value of <code>hostedzoneid</code>, specify the value of <code>HostedZoneIdMarker</code> from the previous response,
        /// which is the hosted zone ID of the first traffic policy instance that Amazon Route 53 will return if you submit another request.</p>
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more traffic policy instances to get.</p>
        pub fn hosted_zone_id_marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id_marker(inp);
            self
        }
        pub fn set_hosted_zone_id_marker(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_hosted_zone_id_marker(inp);
            self
        }
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>true</code>, you have more traffic policy instances.
        /// To get more traffic policy instances, submit another <code>ListTrafficPolicyInstancesByPolicy</code> request.</p>
        /// <p>For the value of <code>trafficpolicyinstancename</code>, specify the value of <code>TrafficPolicyInstanceNameMarker</code>
        /// from the previous response, which is the name of the first traffic policy instance that Amazon Route 53 will return if you submit another request.</p>
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more traffic policy instances to get.</p>
        pub fn traffic_policy_instance_name_marker(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.traffic_policy_instance_name_marker(inp);
            self
        }
        pub fn set_traffic_policy_instance_name_marker(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_policy_instance_name_marker(inp);
            self
        }
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>true</code>, you have more traffic policy instances.
        /// To get more traffic policy instances, submit another <code>ListTrafficPolicyInstancesByPolicy</code> request.</p>
        /// <p>For the value of <code>trafficpolicyinstancetype</code>, specify the value of <code>TrafficPolicyInstanceTypeMarker</code>
        /// from the previous response, which is the name of the first traffic policy instance that Amazon Route 53 will return if you submit another request.</p>
        /// <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more traffic policy instances to get.</p>
        pub fn traffic_policy_instance_type_marker(mut self, inp: crate::model::RrType) -> Self {
            self.inner = self.inner.traffic_policy_instance_type_marker(inp);
            self
        }
        pub fn set_traffic_policy_instance_type_marker(
            mut self,
            inp: std::option::Option<crate::model::RrType>,
        ) -> Self {
            self.inner = self.inner.set_traffic_policy_instance_type_marker(inp);
            self
        }
        /// <p>The maximum number of traffic policy instances to be included in the response body for this request. If you have more than
        /// <code>MaxItems</code> traffic policy instances, the value of the <code>IsTruncated</code> element in the response is <code>true</code>,
        /// and the values of <code>HostedZoneIdMarker</code>, <code>TrafficPolicyInstanceNameMarker</code>, and <code>TrafficPolicyInstanceTypeMarker</code>
        /// represent the first traffic policy instance that Amazon Route 53 will return if you submit another request.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTrafficPolicyVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_traffic_policy_versions_input::Builder,
    }
    impl<C> ListTrafficPolicyVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListTrafficPolicyVersionsOutput,
            smithy_http::result::SdkError<crate::error::ListTrafficPolicyVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specify the value of <code>Id</code> of the traffic policy for which you want to list all versions.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
        /// <p>For your first request to <code>ListTrafficPolicyVersions</code>, don't include the <code>TrafficPolicyVersionMarker</code> parameter.</p>
        /// <p>If you have more traffic policy versions than the value of <code>MaxItems</code>, <code>ListTrafficPolicyVersions</code> returns only
        /// the first group of <code>MaxItems</code> versions. To get more traffic policy versions, submit another <code>ListTrafficPolicyVersions</code>
        /// request. For the value of <code>TrafficPolicyVersionMarker</code>, specify the value of <code>TrafficPolicyVersionMarker</code> in the previous
        /// response.</p>
        pub fn traffic_policy_version_marker(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.traffic_policy_version_marker(inp);
            self
        }
        pub fn set_traffic_policy_version_marker(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_policy_version_marker(inp);
            self
        }
        /// <p>The maximum number of traffic policy versions that you want Amazon Route 53 to include in the response body for this request. If the specified
        /// traffic policy has more than <code>MaxItems</code> versions, the value of <code>IsTruncated</code> in the response is <code>true</code>,
        /// and the value of the <code>TrafficPolicyVersionMarker</code> element is the ID of the first version that Route 53 will return if you submit
        /// another request.</p>
        pub fn max_items(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_items(inp);
            self
        }
        pub fn set_max_items(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListVPCAssociationAuthorizations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_vpc_association_authorizations_input::Builder,
    }
    impl<C> ListVPCAssociationAuthorizations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListVPCAssociationAuthorizationsOutput,
            smithy_http::result::SdkError<crate::error::ListVPCAssociationAuthorizationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the hosted zone for which you want a list of VPCs that can be associated with the hosted zone.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
        /// <p>
        /// <i>Optional</i>: If a response includes a <code>NextToken</code> element, there are more VPCs
        /// that can be associated with the specified hosted zone. To get the next page of results, submit another request,
        /// and include the value of <code>NextToken</code> from the response in the <code>nexttoken</code> parameter
        /// in another <code>ListVPCAssociationAuthorizations</code> request.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>
        /// <i>Optional</i>: An integer that specifies the maximum number of VPCs that you want Amazon Route 53 to return.
        /// If you don't specify a value for <code>MaxResults</code>, Route 53 returns up to 50 VPCs per page.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TestDNSAnswer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::test_dns_answer_input::Builder,
    }
    impl<C> TestDNSAnswer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::TestDNSAnswerOutput,
            smithy_http::result::SdkError<crate::error::TestDNSAnswerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the hosted zone that you want Amazon Route 53 to simulate a query for.</p>
        pub fn hosted_zone_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hosted_zone_id(inp);
            self
        }
        pub fn set_hosted_zone_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hosted_zone_id(inp);
            self
        }
        /// <p>The name of the resource record set that you want Amazon Route 53 to simulate a query for.</p>
        pub fn record_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.record_name(inp);
            self
        }
        pub fn set_record_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_record_name(inp);
            self
        }
        /// <p>The type of the resource record set.</p>
        pub fn record_type(mut self, inp: crate::model::RrType) -> Self {
            self.inner = self.inner.record_type(inp);
            self
        }
        pub fn set_record_type(mut self, inp: std::option::Option<crate::model::RrType>) -> Self {
            self.inner = self.inner.set_record_type(inp);
            self
        }
        /// <p>If you want to simulate a request from a specific DNS resolver, specify the IP address for that resolver.
        /// If you omit this value, <code>TestDnsAnswer</code> uses the IP address of a DNS resolver in the AWS US East (N. Virginia) Region
        /// (<code>us-east-1</code>).</p>
        pub fn resolver_ip(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resolver_ip(inp);
            self
        }
        pub fn set_resolver_ip(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resolver_ip(inp);
            self
        }
        /// <p>If the resolver that you specified for resolverip supports EDNS0, specify the IPv4 or IPv6 address of a client
        /// in the applicable location, for example, <code>192.0.2.44</code> or <code>2001:db8:85a3::8a2e:370:7334</code>.</p>
        pub fn edns0_client_subnet_ip(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.edns0_client_subnet_ip(inp);
            self
        }
        pub fn set_edns0_client_subnet_ip(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_edns0_client_subnet_ip(inp);
            self
        }
        /// <p>If you specify an IP address for <code>edns0clientsubnetip</code>, you can optionally specify the number of bits of the IP address
        /// that you want the checking tool to include in the DNS query. For example, if you specify <code>192.0.2.44</code> for
        /// <code>edns0clientsubnetip</code> and <code>24</code> for <code>edns0clientsubnetmask</code>, the checking tool will simulate a request from
        /// 192.0.2.0/24. The default value is 24 bits for IPv4 addresses and 64 bits for IPv6 addresses.</p>
        /// <p>The range of valid values depends on whether <code>edns0clientsubnetip</code> is an IPv4 or an IPv6 address:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>IPv4</b>: Specify a value between 0 and 32</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>IPv6</b>: Specify a value between 0 and 128</p>
        /// </li>
        /// </ul>
        pub fn edns0_client_subnet_mask(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.edns0_client_subnet_mask(inp);
            self
        }
        pub fn set_edns0_client_subnet_mask(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_edns0_client_subnet_mask(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateHealthCheck<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_health_check_input::Builder,
    }
    impl<C> UpdateHealthCheck<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateHealthCheckOutput,
            smithy_http::result::SdkError<crate::error::UpdateHealthCheckError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID for the health check for which you want detailed information. When you created the health check,
        /// <code>CreateHealthCheck</code> returned the ID in the response, in the <code>HealthCheckId</code> element.</p>
        pub fn health_check_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.health_check_id(inp);
            self
        }
        pub fn set_health_check_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_health_check_id(inp);
            self
        }
        /// <p>A sequential counter that Amazon Route 53 sets to <code>1</code> when you create a health check and increments by 1 each time you
        /// update settings for the health check.</p>
        /// <p>We recommend that you use <code>GetHealthCheck</code> or <code>ListHealthChecks</code> to get the current value of
        /// <code>HealthCheckVersion</code> for the health check that you want to update, and that you include that value in your
        /// <code>UpdateHealthCheck</code> request. This prevents Route 53 from overwriting an intervening update:</p>
        /// <ul>
        /// <li>
        /// <p>If the value in the <code>UpdateHealthCheck</code> request matches the value of <code>HealthCheckVersion</code> in the
        /// health check, Route 53 updates the health check with the new settings.</p>
        /// </li>
        /// <li>
        /// <p>If the value of <code>HealthCheckVersion</code> in the health check is greater, the health check was changed after you
        /// got the version number. Route 53 does not update the health check, and it returns a <code>HealthCheckVersionMismatch</code> error.</p>
        /// </li>
        /// </ul>
        pub fn health_check_version(mut self, inp: i64) -> Self {
            self.inner = self.inner.health_check_version(inp);
            self
        }
        pub fn set_health_check_version(mut self, inp: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_health_check_version(inp);
            self
        }
        /// <p>The IPv4 or IPv6 IP address for the endpoint that you want Amazon Route 53 to perform health checks on. If you don't specify a value for
        /// <code>IPAddress</code>, Route 53 sends a DNS request to resolve the domain name that you specify in <code>FullyQualifiedDomainName</code>
        /// at the interval that you specify in <code>RequestInterval</code>. Using an IP address that is returned by DNS, Route 53 then
        /// checks the health of the endpoint.</p>
        /// <p>Use one of the following formats for the value of <code>IPAddress</code>: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>IPv4 address</b>: four values between 0 and 255, separated by periods (.),
        /// for example, <code>192.0.2.44</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>IPv6 address</b>: eight groups of four hexadecimal values, separated by colons (:),
        /// for example, <code>2001:0db8:85a3:0000:0000:abcd:0001:2345</code>. You can also shorten IPv6 addresses as described in RFC 5952,
        /// for example, <code>2001:db8:85a3::abcd:1:2345</code>.</p>
        /// </li>
        /// </ul>
        /// <p>If the endpoint is an EC2 instance, we recommend that you create an Elastic IP address, associate it with your EC2 instance, and
        /// specify the Elastic IP address for <code>IPAddress</code>. This ensures that the IP address of your instance never changes. For more information,
        /// see the applicable documentation:</p>
        /// <ul>
        /// <li>
        /// <p>Linux: <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html">Elastic IP Addresses (EIP)</a> in the
        /// <i>Amazon EC2 User Guide for Linux Instances</i>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Windows: <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-ip-addresses-eip.html">Elastic IP Addresses (EIP)</a> in the
        /// <i>Amazon EC2 User Guide for Windows Instances</i>
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>If a health check already has a value for <code>IPAddress</code>, you can change the value. However, you can't update an
        /// existing health check to add or remove the value of <code>IPAddress</code>. </p>
        /// </note>
        /// <p>For more information, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-FullyQualifiedDomainName">FullyQualifiedDomainName</a>.
        /// </p>
        /// <p>Constraints: Route 53 can't check the health of endpoints for which the IP address is in local, private, non-routable, or
        /// multicast ranges. For more information about IP addresses for which you can't create health checks, see the following
        /// documents:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <a href="https://tools.ietf.org/html/rfc5735">RFC 5735, Special Use IPv4 Addresses</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a href="https://tools.ietf.org/html/rfc6598">RFC 6598, IANA-Reserved IPv4 Prefix for Shared Address Space</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a href="https://tools.ietf.org/html/rfc5156">RFC 5156, Special-Use IPv6 Addresses</a>
        /// </p>
        /// </li>
        /// </ul>
        pub fn ip_address(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ip_address(inp);
            self
        }
        pub fn set_ip_address(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ip_address(inp);
            self
        }
        /// <p>The port on the endpoint that you want Amazon Route 53 to perform health checks on.</p>
        /// <note>
        /// <p>Don't specify a value for <code>Port</code> when you specify a value for <code>Type</code> of <code>CLOUDWATCH_METRIC</code> or
        /// <code>CALCULATED</code>.</p>
        /// </note>
        pub fn port(mut self, inp: i32) -> Self {
            self.inner = self.inner.port(inp);
            self
        }
        pub fn set_port(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_port(inp);
            self
        }
        /// <p>The path that you want Amazon Route 53 to request when performing health checks. The path can be any value for which your endpoint
        /// will return an HTTP status code of 2xx or 3xx when the endpoint is healthy, for example the file /docs/route53-health-check.html.
        /// You can also include query string parameters, for example, <code>/welcome.html?language=jp&login=y</code>. </p>
        /// <p>Specify this value only if you want to change it.</p>
        pub fn resource_path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_path(inp);
            self
        }
        pub fn set_resource_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_path(inp);
            self
        }
        /// <p>Amazon Route 53 behavior depends on whether you specify a value for <code>IPAddress</code>.</p>
        /// <note>
        /// <p>If a health check already has a value for <code>IPAddress</code>, you can change the value. However, you can't update an
        /// existing health check to add or remove the value of <code>IPAddress</code>. </p>
        /// </note>
        /// <p>
        /// <b>If you specify a value for</b>
        /// <code>IPAddress</code>:</p>
        /// <p>Route 53 sends health check requests to the specified IPv4 or IPv6 address and passes the value of <code>FullyQualifiedDomainName</code>
        /// in the <code>Host</code> header for all health checks except TCP health checks. This is typically the fully qualified DNS name of the endpoint
        /// on which you want Route 53 to perform health checks.</p>
        /// <p>When Route 53 checks the health of an endpoint, here is how it constructs the <code>Host</code> header:</p>
        /// <ul>
        /// <li>
        /// <p>If you specify a value of <code>80</code> for <code>Port</code> and <code>HTTP</code> or <code>HTTP_STR_MATCH</code> for
        /// <code>Type</code>, Route 53 passes the value of <code>FullyQualifiedDomainName</code> to the endpoint in the <code>Host</code> header.</p>
        /// </li>
        /// <li>
        /// <p>If you specify a value of <code>443</code> for <code>Port</code> and <code>HTTPS</code> or <code>HTTPS_STR_MATCH</code> for
        /// <code>Type</code>, Route 53 passes the value of <code>FullyQualifiedDomainName</code> to the endpoint in the <code>Host</code> header.</p>
        /// </li>
        /// <li>
        /// <p>If you specify another value for <code>Port</code> and any value except <code>TCP</code> for <code>Type</code>, Route 53 passes
        /// <i>
        /// <code>FullyQualifiedDomainName</code>:<code>Port</code>
        /// </i> to the endpoint in the <code>Host</code> header.</p>
        /// </li>
        /// </ul>
        /// <p>If you don't specify a value for <code>FullyQualifiedDomainName</code>, Route 53 substitutes the value of <code>IPAddress</code>
        /// in the <code>Host</code> header in each of the above cases.</p>
        /// <p>
        /// <b>If you don't specify a value for</b>
        /// <code>IPAddress</code>:</p>
        /// <p>If you don't specify a value for <code>IPAddress</code>, Route 53 sends a DNS request to the domain that you specify in
        /// <code>FullyQualifiedDomainName</code> at the interval you specify in <code>RequestInterval</code>. Using an IPv4 address that is
        /// returned by DNS, Route 53 then checks the health of the endpoint.</p>
        /// <note>
        /// <p>If you don't specify a value for <code>IPAddress</code>, Route 53 uses only IPv4 to send health checks to the endpoint.
        /// If there's no resource record set with a type of A for the name that you specify for <code>FullyQualifiedDomainName</code>,
        /// the health check fails with a "DNS resolution failed" error.</p>
        /// </note>
        /// <p>If you want to check the health of weighted, latency, or failover resource record sets and you choose to specify the endpoint only by
        /// <code>FullyQualifiedDomainName</code>, we recommend that you create a separate health check for each endpoint. For example, create a
        /// health check for each HTTP server that is serving content for www.example.com. For the value of <code>FullyQualifiedDomainName</code>,
        /// specify the domain name of the server (such as <code>us-east-2-www.example.com</code>), not the name of the resource record sets (www.example.com).</p>
        /// <important>
        /// <p>In this configuration, if the value of <code>FullyQualifiedDomainName</code> matches the name of the resource record sets and
        /// you then associate the health check with those resource record sets, health check results will be unpredictable.</p>
        /// </important>
        /// <p>In addition, if the value of <code>Type</code> is <code>HTTP</code>, <code>HTTPS</code>, <code>HTTP_STR_MATCH</code>, or
        /// <code>HTTPS_STR_MATCH</code>, Route 53 passes the value of <code>FullyQualifiedDomainName</code> in the <code>Host</code> header, as it does
        /// when you specify a value for <code>IPAddress</code>. If the value of <code>Type</code> is <code>TCP</code>, Route 53 doesn't pass a
        /// <code>Host</code> header.</p>
        pub fn fully_qualified_domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fully_qualified_domain_name(inp);
            self
        }
        pub fn set_fully_qualified_domain_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_fully_qualified_domain_name(inp);
            self
        }
        /// <p>If the value of <code>Type</code> is <code>HTTP_STR_MATCH</code> or <code>HTTPS_STR_MATCH</code>, the string that you want
        /// Amazon Route 53 to search for in the response body from the specified resource. If the string appears in the response body, Route 53 considers
        /// the resource healthy. (You can't change the value of <code>Type</code> when you update a health check.)</p>
        pub fn search_string(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.search_string(inp);
            self
        }
        pub fn set_search_string(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_search_string(inp);
            self
        }
        /// <p>The number of consecutive health checks that an endpoint must pass or fail for Amazon Route 53 to change the current status of the endpoint
        /// from unhealthy to healthy or vice versa. For more information, see
        /// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html">How Amazon Route 53 Determines Whether an Endpoint Is Healthy</a>
        /// in the <i>Amazon Route 53 Developer Guide</i>.</p>
        /// <p>If you don't specify a value for <code>FailureThreshold</code>, the default value is three health checks.</p>
        pub fn failure_threshold(mut self, inp: i32) -> Self {
            self.inner = self.inner.failure_threshold(inp);
            self
        }
        pub fn set_failure_threshold(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_failure_threshold(inp);
            self
        }
        /// <p>Specify whether you want Amazon Route 53 to invert the status of a health check, for example, to consider a health check unhealthy when it
        /// otherwise would be considered healthy.</p>
        pub fn inverted(mut self, inp: bool) -> Self {
            self.inner = self.inner.inverted(inp);
            self
        }
        pub fn set_inverted(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_inverted(inp);
            self
        }
        /// <p>Stops Route 53 from performing health checks. When you disable a health check, here's what happens:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Health checks that check the health of endpoints:</b>
        /// Route 53 stops submitting requests to your application, server, or other resource.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Calculated health checks:</b>
        /// Route 53 stops aggregating the status of the referenced health checks.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Health checks that monitor CloudWatch alarms:</b>
        /// Route 53 stops monitoring the corresponding CloudWatch metrics.</p>
        /// </li>
        /// </ul>
        /// <p>After you disable a health check, Route 53 considers the status of the health check to always be healthy. If you configured DNS failover,
        /// Route 53 continues to route traffic to the corresponding resources. If you want to stop routing traffic to a resource, change the value of
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-Inverted">Inverted</a>.
        /// </p>
        /// <p>Charges for a health check still apply when the health check is disabled. For more information, see
        /// <a href="http://aws.amazon.com/route53/pricing/">Amazon Route 53 Pricing</a>.</p>
        pub fn disabled(mut self, inp: bool) -> Self {
            self.inner = self.inner.disabled(inp);
            self
        }
        pub fn set_disabled(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_disabled(inp);
            self
        }
        /// <p>The number of child health checks that are associated with a <code>CALCULATED</code> health that Amazon Route 53 must consider healthy for the
        /// <code>CALCULATED</code> health check to be considered healthy. To specify the child health checks that you want to associate with a
        /// <code>CALCULATED</code> health check, use the <code>ChildHealthChecks</code> and <code>ChildHealthCheck</code> elements.</p>
        /// <p>Note the following:</p>
        /// <ul>
        /// <li>
        /// <p>If you specify a number greater than the number of child health checks, Route 53 always considers this health check to be unhealthy.</p>
        /// </li>
        /// <li>
        /// <p>If you specify <code>0</code>, Route 53 always considers this health check to be healthy.</p>
        /// </li>
        /// </ul>
        pub fn health_threshold(mut self, inp: i32) -> Self {
            self.inner = self.inner.health_threshold(inp);
            self
        }
        pub fn set_health_threshold(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_health_threshold(inp);
            self
        }
        /// <p>A complex type that contains one <code>ChildHealthCheck</code> element for each health check that you want to associate with a
        /// <code>CALCULATED</code> health check.</p>
        pub fn child_health_checks(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.child_health_checks(inp);
            self
        }
        pub fn set_child_health_checks(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_child_health_checks(inp);
            self
        }
        /// <p>Specify whether you want Amazon Route 53 to send the value of <code>FullyQualifiedDomainName</code> to the endpoint in the <code>client_hello</code>
        /// message during <code>TLS</code> negotiation. This allows the endpoint to respond to <code>HTTPS</code> health check requests with the applicable
        /// SSL/TLS certificate.</p>
        /// <p>Some endpoints require that HTTPS requests include the host name in the <code>client_hello</code> message. If you don't enable SNI,
        /// the status of the health check will be SSL alert <code>handshake_failure</code>. A health check can also have that status for other reasons.
        /// If SNI is enabled and you're still getting the error, check the SSL/TLS configuration on your endpoint and confirm that your certificate is valid.</p>
        /// <p>The SSL/TLS certificate on your endpoint includes a domain name in the <code>Common Name</code> field and possibly several more
        /// in the <code>Subject Alternative Names</code> field. One of the domain names in the certificate should match the value that you specify for
        /// <code>FullyQualifiedDomainName</code>. If the endpoint responds to the <code>client_hello</code> message with a certificate that does not
        /// include the domain name that you specified in <code>FullyQualifiedDomainName</code>, a health checker will retry the handshake. In the
        /// second attempt, the health checker will omit <code>FullyQualifiedDomainName</code> from the <code>client_hello</code> message.</p>
        pub fn enable_sni(mut self, inp: bool) -> Self {
            self.inner = self.inner.enable_sni(inp);
            self
        }
        pub fn set_enable_sni(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enable_sni(inp);
            self
        }
        /// <p>A complex type that contains one <code>Region</code> element for each region that you want Amazon Route 53 health checkers to check
        /// the specified endpoint from.</p>
        pub fn regions(mut self, inp: impl Into<crate::model::HealthCheckRegion>) -> Self {
            self.inner = self.inner.regions(inp);
            self
        }
        pub fn set_regions(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::HealthCheckRegion>>,
        ) -> Self {
            self.inner = self.inner.set_regions(inp);
            self
        }
        /// <p>A complex type that identifies the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether
        /// the specified health check is healthy.</p>
        pub fn alarm_identifier(mut self, inp: crate::model::AlarmIdentifier) -> Self {
            self.inner = self.inner.alarm_identifier(inp);
            self
        }
        pub fn set_alarm_identifier(
            mut self,
            inp: std::option::Option<crate::model::AlarmIdentifier>,
        ) -> Self {
            self.inner = self.inner.set_alarm_identifier(inp);
            self
        }
        /// <p>When CloudWatch has insufficient data about the metric to determine the alarm state, the status that you want Amazon Route 53 to assign
        /// to the health check:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Healthy</code>: Route 53 considers the health check to be healthy.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Unhealthy</code>: Route 53 considers the health check to be unhealthy.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LastKnownStatus</code>: Route 53 uses the status of the health check from the last time CloudWatch had sufficient data
        /// to determine the alarm state. For new health checks that have no last known status, the default status for the health check is healthy.</p>
        /// </li>
        /// </ul>
        pub fn insufficient_data_health_status(
            mut self,
            inp: crate::model::InsufficientDataHealthStatus,
        ) -> Self {
            self.inner = self.inner.insufficient_data_health_status(inp);
            self
        }
        pub fn set_insufficient_data_health_status(
            mut self,
            inp: std::option::Option<crate::model::InsufficientDataHealthStatus>,
        ) -> Self {
            self.inner = self.inner.set_insufficient_data_health_status(inp);
            self
        }
        /// <p>A complex type that contains one <code>ResettableElementName</code> element for each element that you want to reset to the default value.
        /// Valid values for <code>ResettableElementName</code> include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ChildHealthChecks</code>: Amazon Route 53 resets
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-ChildHealthChecks">ChildHealthChecks</a>
        /// to null.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FullyQualifiedDomainName</code>: Route 53 resets
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-FullyQualifiedDomainName">FullyQualifiedDomainName</a>.
        /// to null.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Regions</code>: Route 53 resets the
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-Regions">Regions</a>
        /// list to the default set of regions. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ResourcePath</code>: Route 53 resets
        /// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-ResourcePath">ResourcePath</a>
        /// to null.</p>
        /// </li>
        /// </ul>
        pub fn reset_elements(
            mut self,
            inp: impl Into<crate::model::ResettableElementName>,
        ) -> Self {
            self.inner = self.inner.reset_elements(inp);
            self
        }
        pub fn set_reset_elements(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ResettableElementName>>,
        ) -> Self {
            self.inner = self.inner.set_reset_elements(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateHostedZoneComment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_hosted_zone_comment_input::Builder,
    }
    impl<C> UpdateHostedZoneComment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateHostedZoneCommentOutput,
            smithy_http::result::SdkError<crate::error::UpdateHostedZoneCommentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID for the hosted zone that you want to update the comment for.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
        /// <p>The new comment for the hosted zone. If you don't specify a value for <code>Comment</code>, Amazon Route 53 deletes the existing value of the
        /// <code>Comment</code> element, if any.</p>
        pub fn comment(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.comment(inp);
            self
        }
        pub fn set_comment(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_comment(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateTrafficPolicyComment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_traffic_policy_comment_input::Builder,
    }
    impl<C> UpdateTrafficPolicyComment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateTrafficPolicyCommentOutput,
            smithy_http::result::SdkError<crate::error::UpdateTrafficPolicyCommentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The value of <code>Id</code> for the traffic policy that you want to update the comment for.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
        /// <p>The value of <code>Version</code> for the traffic policy that you want to update the comment for.</p>
        pub fn version(mut self, inp: i32) -> Self {
            self.inner = self.inner.version(inp);
            self
        }
        pub fn set_version(mut self, inp: i32) -> Self {
            self.inner = self.inner.set_version(inp);
            self
        }
        /// <p>The new comment for the specified traffic policy and version.</p>
        pub fn comment(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.comment(inp);
            self
        }
        pub fn set_comment(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_comment(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateTrafficPolicyInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_traffic_policy_instance_input::Builder,
    }
    impl<C> UpdateTrafficPolicyInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateTrafficPolicyInstanceOutput,
            smithy_http::result::SdkError<crate::error::UpdateTrafficPolicyInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the traffic policy instance that you want to update.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, inp: std::string::String) -> Self {
            self.inner = self.inner.set_id(inp);
            self
        }
        /// <p>The TTL that you want Amazon Route 53 to assign to all of the updated resource record sets.</p>
        pub fn ttl(mut self, inp: i64) -> Self {
            self.inner = self.inner.ttl(inp);
            self
        }
        pub fn set_ttl(mut self, inp: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_ttl(inp);
            self
        }
        /// <p>The ID of the traffic policy that you want Amazon Route 53 to use to update resource record sets for the specified traffic policy instance.</p>
        pub fn traffic_policy_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.traffic_policy_id(inp);
            self
        }
        pub fn set_traffic_policy_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_policy_id(inp);
            self
        }
        /// <p>The version of the traffic policy that you want Amazon Route 53 to use to update resource record sets for the specified traffic policy instance.</p>
        pub fn traffic_policy_version(mut self, inp: i32) -> Self {
            self.inner = self.inner.traffic_policy_version(inp);
            self
        }
        pub fn set_traffic_policy_version(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_traffic_policy_version(inp);
            self
        }
    }
}
