// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_activate_key_signing_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ActivateKeySigningKeyOutput,
    crate::error::ActivateKeySigningKeyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ActivateKeySigningKeyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ActivateKeySigningKeyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => {
            crate::error::ActivateKeySigningKeyError::ConcurrentModification({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_modification::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_xml_err(response.body().as_ref(), output).map_err(crate::error::ActivateKeySigningKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInput" => crate::error::ActivateKeySigningKeyError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ActivateKeySigningKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidKeySigningKeyStatus" => {
            crate::error::ActivateKeySigningKeyError::InvalidKeySigningKeyStatus({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_key_signing_key_status::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_key_signing_key_status_xml_err(response.body().as_ref(), output).map_err(crate::error::ActivateKeySigningKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidKMSArn" => crate::error::ActivateKeySigningKeyError::InvalidKmsArn({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_kms_arn::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_kms_arn_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ActivateKeySigningKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidSigningStatus" => {
            crate::error::ActivateKeySigningKeyError::InvalidSigningStatus({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_signing_status::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_signing_status_xml_err(response.body().as_ref(), output).map_err(crate::error::ActivateKeySigningKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchKeySigningKey" => {
            crate::error::ActivateKeySigningKeyError::NoSuchKeySigningKey({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_key_signing_key::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_key_signing_key_xml_err(response.body().as_ref(), output).map_err(crate::error::ActivateKeySigningKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ActivateKeySigningKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_activate_key_signing_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ActivateKeySigningKeyOutput,
    crate::error::ActivateKeySigningKeyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::activate_key_signing_key_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_activate_key_signing_key(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ActivateKeySigningKeyError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_vpc_with_hosted_zone_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateVpcWithHostedZoneOutput,
    crate::error::AssociateVPCWithHostedZoneError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateVPCWithHostedZoneError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AssociateVPCWithHostedZoneError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictingDomainExists" => {
            crate::error::AssociateVPCWithHostedZoneError::ConflictingDomainExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::conflicting_domain_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_conflicting_domain_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::AssociateVPCWithHostedZoneError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInput" => crate::error::AssociateVPCWithHostedZoneError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AssociateVPCWithHostedZoneError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidVPCId" => crate::error::AssociateVPCWithHostedZoneError::InvalidVpcId({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_vpc_id::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_id_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AssociateVPCWithHostedZoneError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitsExceeded" => crate::error::AssociateVPCWithHostedZoneError::LimitsExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limits_exceeded::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_limits_exceeded_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AssociateVPCWithHostedZoneError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHostedZone" => crate::error::AssociateVPCWithHostedZoneError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_hosted_zone::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::AssociateVPCWithHostedZoneError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotAuthorizedException" => {
            crate::error::AssociateVPCWithHostedZoneError::NotAuthorizedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_authorized_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_not_authorized_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::AssociateVPCWithHostedZoneError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PriorRequestNotComplete" => {
            crate::error::AssociateVPCWithHostedZoneError::PriorRequestNotComplete({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prior_request_not_complete::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_prior_request_not_complete_xml_err(response.body().as_ref(), output).map_err(crate::error::AssociateVPCWithHostedZoneError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PublicZoneVPCAssociation" => {
            crate::error::AssociateVPCWithHostedZoneError::PublicZoneVpcAssociation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::public_zone_vpc_association::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_public_zone_vpc_association_xml_err(response.body().as_ref(), output).map_err(crate::error::AssociateVPCWithHostedZoneError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::AssociateVPCWithHostedZoneError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_vpc_with_hosted_zone_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateVpcWithHostedZoneOutput,
    crate::error::AssociateVPCWithHostedZoneError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_vpc_with_hosted_zone_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_vpc_with_hosted_zone(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateVPCWithHostedZoneError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_change_cidr_collection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ChangeCidrCollectionOutput,
    crate::error::ChangeCidrCollectionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ChangeCidrCollectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ChangeCidrCollectionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CidrBlockInUseException" => {
            crate::error::ChangeCidrCollectionError::CidrBlockInUseException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cidr_block_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cidr_block_in_use_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ChangeCidrCollectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CidrCollectionVersionMismatchException" => {
            crate::error::ChangeCidrCollectionError::CidrCollectionVersionMismatchException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::cidr_collection_version_mismatch_exception::Builder::default(
                        );
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cidr_collection_version_mismatch_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ChangeCidrCollectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ConcurrentModification" => {
            crate::error::ChangeCidrCollectionError::ConcurrentModification({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_modification::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_xml_err(response.body().as_ref(), output).map_err(crate::error::ChangeCidrCollectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInput" => crate::error::ChangeCidrCollectionError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ChangeCidrCollectionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitsExceeded" => crate::error::ChangeCidrCollectionError::LimitsExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limits_exceeded::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_limits_exceeded_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ChangeCidrCollectionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchCidrCollectionException" => {
            crate::error::ChangeCidrCollectionError::NoSuchCidrCollectionException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_cidr_collection_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_cidr_collection_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ChangeCidrCollectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ChangeCidrCollectionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_change_cidr_collection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ChangeCidrCollectionOutput,
    crate::error::ChangeCidrCollectionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::change_cidr_collection_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_change_cidr_collection(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ChangeCidrCollectionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_change_resource_record_sets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ChangeResourceRecordSetsOutput,
    crate::error::ChangeResourceRecordSetsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ChangeResourceRecordSetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ChangeResourceRecordSetsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidChangeBatch" => crate::error::ChangeResourceRecordSetsError::InvalidChangeBatch({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_change_batch::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_invalid_change_batch_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ChangeResourceRecordSetsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInput" => crate::error::ChangeResourceRecordSetsError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ChangeResourceRecordSetsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHealthCheck" => crate::error::ChangeResourceRecordSetsError::NoSuchHealthCheck({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_health_check::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_health_check_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ChangeResourceRecordSetsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHostedZone" => crate::error::ChangeResourceRecordSetsError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_hosted_zone::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ChangeResourceRecordSetsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "PriorRequestNotComplete" => {
            crate::error::ChangeResourceRecordSetsError::PriorRequestNotComplete({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prior_request_not_complete::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_prior_request_not_complete_xml_err(response.body().as_ref(), output).map_err(crate::error::ChangeResourceRecordSetsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ChangeResourceRecordSetsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_change_resource_record_sets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ChangeResourceRecordSetsOutput,
    crate::error::ChangeResourceRecordSetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::change_resource_record_sets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_change_resource_record_sets(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ChangeResourceRecordSetsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_change_tags_for_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ChangeTagsForResourceOutput,
    crate::error::ChangeTagsForResourceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ChangeTagsForResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ChangeTagsForResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ChangeTagsForResourceError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ChangeTagsForResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHealthCheck" => crate::error::ChangeTagsForResourceError::NoSuchHealthCheck({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_health_check::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_health_check_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ChangeTagsForResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHostedZone" => crate::error::ChangeTagsForResourceError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_hosted_zone::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ChangeTagsForResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "PriorRequestNotComplete" => {
            crate::error::ChangeTagsForResourceError::PriorRequestNotComplete({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prior_request_not_complete::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_prior_request_not_complete_xml_err(response.body().as_ref(), output).map_err(crate::error::ChangeTagsForResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ThrottlingException" => crate::error::ChangeTagsForResourceError::ThrottlingException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::throttling_exception::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_throttling_exception_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ChangeTagsForResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ChangeTagsForResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_change_tags_for_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ChangeTagsForResourceOutput,
    crate::error::ChangeTagsForResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::change_tags_for_resource_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cidr_collection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCidrCollectionOutput,
    crate::error::CreateCidrCollectionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateCidrCollectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateCidrCollectionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CidrCollectionAlreadyExistsException" => {
            crate::error::CreateCidrCollectionError::CidrCollectionAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::cidr_collection_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cidr_collection_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCidrCollectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ConcurrentModification" => {
            crate::error::CreateCidrCollectionError::ConcurrentModification({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_modification::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateCidrCollectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInput" => crate::error::CreateCidrCollectionError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateCidrCollectionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitsExceeded" => crate::error::CreateCidrCollectionError::LimitsExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limits_exceeded::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_limits_exceeded_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateCidrCollectionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateCidrCollectionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cidr_collection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCidrCollectionOutput,
    crate::error::CreateCidrCollectionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_cidr_collection_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_cidr_collection(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateCidrCollectionError::unhandled)?;
        output = output.set_location(
            crate::http_serde::deser_header_create_cidr_collection_create_cidr_collection_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateCidrCollectionError::unhandled("Failed to parse Location from header `Location"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_health_check_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateHealthCheckOutput, crate::error::CreateHealthCheckError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateHealthCheckError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateHealthCheckError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "HealthCheckAlreadyExists" => {
            crate::error::CreateHealthCheckError::HealthCheckAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::health_check_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_health_check_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateHealthCheckError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInput" => crate::error::CreateHealthCheckError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateHealthCheckError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "TooManyHealthChecks" => {
            crate::error::CreateHealthCheckError::TooManyHealthChecks({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_health_checks::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_health_checks_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateHealthCheckError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateHealthCheckError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_health_check_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateHealthCheckOutput, crate::error::CreateHealthCheckError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_health_check_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_health_check(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateHealthCheckError::unhandled)?;
        output = output.set_location(
            crate::http_serde::deser_header_create_health_check_create_health_check_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateHealthCheckError::unhandled("Failed to parse Location from header `Location"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_hosted_zone_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateHostedZoneOutput, crate::error::CreateHostedZoneError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateHostedZoneError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateHostedZoneError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictingDomainExists" => {
            crate::error::CreateHostedZoneError::ConflictingDomainExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::conflicting_domain_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_conflicting_domain_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateHostedZoneError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DelegationSetNotAvailable" => {
            crate::error::CreateHostedZoneError::DelegationSetNotAvailable({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::delegation_set_not_available::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_delegation_set_not_available_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateHostedZoneError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DelegationSetNotReusable" => {
            crate::error::CreateHostedZoneError::DelegationSetNotReusable({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::delegation_set_not_reusable::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_delegation_set_not_reusable_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateHostedZoneError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "HostedZoneAlreadyExists" => {
            crate::error::CreateHostedZoneError::HostedZoneAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::hosted_zone_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_hosted_zone_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateHostedZoneError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDomainName" => crate::error::CreateHostedZoneError::InvalidDomainName({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_domain_name::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_domain_name_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateHostedZoneError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInput" => crate::error::CreateHostedZoneError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateHostedZoneError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidVPCId" => crate::error::CreateHostedZoneError::InvalidVpcId({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_vpc_id::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_id_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateHostedZoneError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchDelegationSet" => {
            crate::error::CreateHostedZoneError::NoSuchDelegationSet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_delegation_set::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_delegation_set_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateHostedZoneError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyHostedZones" => {
            crate::error::CreateHostedZoneError::TooManyHostedZones({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_hosted_zones::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_hosted_zones_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateHostedZoneError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateHostedZoneError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_hosted_zone_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateHostedZoneOutput, crate::error::CreateHostedZoneError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_hosted_zone_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_hosted_zone(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateHostedZoneError::unhandled)?;
        output = output.set_location(
            crate::http_serde::deser_header_create_hosted_zone_create_hosted_zone_output_location(
                response.headers(),
            )
            .map_err(|_| {
                crate::error::CreateHostedZoneError::unhandled(
                    "Failed to parse Location from header `Location",
                )
            })?,
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_key_signing_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateKeySigningKeyOutput,
    crate::error::CreateKeySigningKeyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateKeySigningKeyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateKeySigningKeyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => {
            crate::error::CreateKeySigningKeyError::ConcurrentModification({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_modification::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateKeySigningKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidArgument" => crate::error::CreateKeySigningKeyError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateKeySigningKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInput" => crate::error::CreateKeySigningKeyError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateKeySigningKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidKeySigningKeyName" => {
            crate::error::CreateKeySigningKeyError::InvalidKeySigningKeyName({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_key_signing_key_name::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_key_signing_key_name_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateKeySigningKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidKeySigningKeyStatus" => {
            crate::error::CreateKeySigningKeyError::InvalidKeySigningKeyStatus({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_key_signing_key_status::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_key_signing_key_status_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateKeySigningKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidKMSArn" => crate::error::CreateKeySigningKeyError::InvalidKmsArn({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_kms_arn::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_kms_arn_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateKeySigningKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidSigningStatus" => {
            crate::error::CreateKeySigningKeyError::InvalidSigningStatus({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_signing_status::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_signing_status_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateKeySigningKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "KeySigningKeyAlreadyExists" => {
            crate::error::CreateKeySigningKeyError::KeySigningKeyAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::key_signing_key_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_key_signing_key_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateKeySigningKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchHostedZone" => crate::error::CreateKeySigningKeyError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_hosted_zone::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateKeySigningKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "TooManyKeySigningKeys" => crate::error::CreateKeySigningKeyError::TooManyKeySigningKeys({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_key_signing_keys::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_too_many_key_signing_keys_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateKeySigningKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateKeySigningKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_key_signing_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateKeySigningKeyOutput,
    crate::error::CreateKeySigningKeyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_key_signing_key_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_key_signing_key(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateKeySigningKeyError::unhandled)?;
        output = output.set_location(
            crate::http_serde::deser_header_create_key_signing_key_create_key_signing_key_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateKeySigningKeyError::unhandled("Failed to parse Location from header `Location"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_query_logging_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateQueryLoggingConfigOutput,
    crate::error::CreateQueryLoggingConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateQueryLoggingConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateQueryLoggingConfigError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => {
            crate::error::CreateQueryLoggingConfigError::ConcurrentModification({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_modification::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateQueryLoggingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InsufficientCloudWatchLogsResourcePolicy" => {
            crate::error::CreateQueryLoggingConfigError::InsufficientCloudWatchLogsResourcePolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::insufficient_cloud_watch_logs_resource_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_cloud_watch_logs_resource_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateQueryLoggingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInput" => crate::error::CreateQueryLoggingConfigError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateQueryLoggingConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchCloudWatchLogsLogGroup" => {
            crate::error::CreateQueryLoggingConfigError::NoSuchCloudWatchLogsLogGroup({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_cloud_watch_logs_log_group::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_cloud_watch_logs_log_group_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateQueryLoggingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchHostedZone" => crate::error::CreateQueryLoggingConfigError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_hosted_zone::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateQueryLoggingConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "QueryLoggingConfigAlreadyExists" => {
            crate::error::CreateQueryLoggingConfigError::QueryLoggingConfigAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::query_logging_config_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_query_logging_config_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateQueryLoggingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateQueryLoggingConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_query_logging_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateQueryLoggingConfigOutput,
    crate::error::CreateQueryLoggingConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_query_logging_config_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_query_logging_config(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateQueryLoggingConfigError::unhandled)?;
        output = output.set_location(
            crate::http_serde::deser_header_create_query_logging_config_create_query_logging_config_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateQueryLoggingConfigError::unhandled("Failed to parse Location from header `Location"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_reusable_delegation_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateReusableDelegationSetOutput,
    crate::error::CreateReusableDelegationSetError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateReusableDelegationSetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateReusableDelegationSetError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DelegationSetAlreadyCreated" => {
            crate::error::CreateReusableDelegationSetError::DelegationSetAlreadyCreated({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::delegation_set_already_created::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_delegation_set_already_created_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateReusableDelegationSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DelegationSetAlreadyReusable" => {
            crate::error::CreateReusableDelegationSetError::DelegationSetAlreadyReusable({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::delegation_set_already_reusable::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_delegation_set_already_reusable_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateReusableDelegationSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DelegationSetNotAvailable" => {
            crate::error::CreateReusableDelegationSetError::DelegationSetNotAvailable({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::delegation_set_not_available::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_delegation_set_not_available_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateReusableDelegationSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "HostedZoneNotFound" => {
            crate::error::CreateReusableDelegationSetError::HostedZoneNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::hosted_zone_not_found::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_hosted_zone_not_found_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateReusableDelegationSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidArgument" => crate::error::CreateReusableDelegationSetError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateReusableDelegationSetError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInput" => crate::error::CreateReusableDelegationSetError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateReusableDelegationSetError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitsExceeded" => crate::error::CreateReusableDelegationSetError::LimitsExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limits_exceeded::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_limits_exceeded_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateReusableDelegationSetError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateReusableDelegationSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_reusable_delegation_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateReusableDelegationSetOutput,
    crate::error::CreateReusableDelegationSetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_reusable_delegation_set_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_reusable_delegation_set(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateReusableDelegationSetError::unhandled)?;
        output = output.set_location(
            crate::http_serde::deser_header_create_reusable_delegation_set_create_reusable_delegation_set_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateReusableDelegationSetError::unhandled("Failed to parse Location from header `Location"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTrafficPolicyOutput,
    crate::error::CreateTrafficPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTrafficPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateTrafficPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::CreateTrafficPolicyError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateTrafficPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidTrafficPolicyDocument" => {
            crate::error::CreateTrafficPolicyError::InvalidTrafficPolicyDocument({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_traffic_policy_document::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_traffic_policy_document_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateTrafficPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyTrafficPolicies" => {
            crate::error::CreateTrafficPolicyError::TooManyTrafficPolicies({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_traffic_policies::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_traffic_policies_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateTrafficPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TrafficPolicyAlreadyExists" => {
            crate::error::CreateTrafficPolicyError::TrafficPolicyAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::traffic_policy_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_traffic_policy_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateTrafficPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateTrafficPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTrafficPolicyOutput,
    crate::error::CreateTrafficPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_traffic_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_traffic_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateTrafficPolicyError::unhandled)?;
        output = output.set_location(
            crate::http_serde::deser_header_create_traffic_policy_create_traffic_policy_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateTrafficPolicyError::unhandled("Failed to parse Location from header `Location"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_policy_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTrafficPolicyInstanceOutput,
    crate::error::CreateTrafficPolicyInstanceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTrafficPolicyInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateTrafficPolicyInstanceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::CreateTrafficPolicyInstanceError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateTrafficPolicyInstanceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHostedZone" => crate::error::CreateTrafficPolicyInstanceError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_hosted_zone::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateTrafficPolicyInstanceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchTrafficPolicy" => {
            crate::error::CreateTrafficPolicyInstanceError::NoSuchTrafficPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_traffic_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_traffic_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateTrafficPolicyInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyTrafficPolicyInstances" => {
            crate::error::CreateTrafficPolicyInstanceError::TooManyTrafficPolicyInstances({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::too_many_traffic_policy_instances::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_traffic_policy_instances_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateTrafficPolicyInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TrafficPolicyInstanceAlreadyExists" => {
            crate::error::CreateTrafficPolicyInstanceError::TrafficPolicyInstanceAlreadyExists({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::traffic_policy_instance_already_exists::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_traffic_policy_instance_already_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateTrafficPolicyInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateTrafficPolicyInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_policy_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTrafficPolicyInstanceOutput,
    crate::error::CreateTrafficPolicyInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_traffic_policy_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_traffic_policy_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateTrafficPolicyInstanceError::unhandled)?;
        output = output.set_location(
            crate::http_serde::deser_header_create_traffic_policy_instance_create_traffic_policy_instance_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateTrafficPolicyInstanceError::unhandled("Failed to parse Location from header `Location"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_policy_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTrafficPolicyVersionOutput,
    crate::error::CreateTrafficPolicyVersionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTrafficPolicyVersionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateTrafficPolicyVersionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::CreateTrafficPolicyVersionError::ConcurrentModification({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_modification::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateTrafficPolicyVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInput" => crate::error::CreateTrafficPolicyVersionError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateTrafficPolicyVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTrafficPolicyDocument" => crate::error::CreateTrafficPolicyVersionError::InvalidTrafficPolicyDocument({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_traffic_policy_document::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_traffic_policy_document_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateTrafficPolicyVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchTrafficPolicy" => crate::error::CreateTrafficPolicyVersionError::NoSuchTrafficPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_traffic_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_traffic_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateTrafficPolicyVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyTrafficPolicyVersionsForCurrentPolicy" => crate::error::CreateTrafficPolicyVersionError::TooManyTrafficPolicyVersionsForCurrentPolicy({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_traffic_policy_versions_for_current_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_traffic_policy_versions_for_current_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateTrafficPolicyVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateTrafficPolicyVersionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_policy_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTrafficPolicyVersionOutput,
    crate::error::CreateTrafficPolicyVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_traffic_policy_version_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_traffic_policy_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateTrafficPolicyVersionError::unhandled)?;
        output = output.set_location(
            crate::http_serde::deser_header_create_traffic_policy_version_create_traffic_policy_version_output_location(response.headers())
                                    .map_err(|_|crate::error::CreateTrafficPolicyVersionError::unhandled("Failed to parse Location from header `Location"))?
        );
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_association_authorization_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVpcAssociationAuthorizationOutput,
    crate::error::CreateVPCAssociationAuthorizationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateVPCAssociationAuthorizationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateVPCAssociationAuthorizationError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::CreateVPCAssociationAuthorizationError::ConcurrentModification({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_modification::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateVPCAssociationAuthorizationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInput" => crate::error::CreateVPCAssociationAuthorizationError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateVPCAssociationAuthorizationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidVPCId" => crate::error::CreateVPCAssociationAuthorizationError::InvalidVpcId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_vpc_id::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_id_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateVPCAssociationAuthorizationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchHostedZone" => crate::error::CreateVPCAssociationAuthorizationError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_hosted_zone::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateVPCAssociationAuthorizationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TooManyVPCAssociationAuthorizations" => crate::error::CreateVPCAssociationAuthorizationError::TooManyVpcAssociationAuthorizations({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_vpc_association_authorizations::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_vpc_association_authorizations_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateVPCAssociationAuthorizationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateVPCAssociationAuthorizationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_association_authorization_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVpcAssociationAuthorizationOutput,
    crate::error::CreateVPCAssociationAuthorizationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_vpc_association_authorization_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_create_vpc_association_authorization(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateVPCAssociationAuthorizationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deactivate_key_signing_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeactivateKeySigningKeyOutput,
    crate::error::DeactivateKeySigningKeyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeactivateKeySigningKeyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeactivateKeySigningKeyError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => {
            crate::error::DeactivateKeySigningKeyError::ConcurrentModification({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_modification::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_xml_err(response.body().as_ref(), output).map_err(crate::error::DeactivateKeySigningKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInput" => crate::error::DeactivateKeySigningKeyError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeactivateKeySigningKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidKeySigningKeyStatus" => {
            crate::error::DeactivateKeySigningKeyError::InvalidKeySigningKeyStatus({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_key_signing_key_status::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_key_signing_key_status_xml_err(response.body().as_ref(), output).map_err(crate::error::DeactivateKeySigningKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidSigningStatus" => {
            crate::error::DeactivateKeySigningKeyError::InvalidSigningStatus({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_signing_status::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_signing_status_xml_err(response.body().as_ref(), output).map_err(crate::error::DeactivateKeySigningKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "KeySigningKeyInParentDSRecord" => {
            crate::error::DeactivateKeySigningKeyError::KeySigningKeyInParentDsRecord({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::key_signing_key_in_parent_ds_record::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_key_signing_key_in_parent_ds_record_xml_err(response.body().as_ref(), output).map_err(crate::error::DeactivateKeySigningKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "KeySigningKeyInUse" => {
            crate::error::DeactivateKeySigningKeyError::KeySigningKeyInUse({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::key_signing_key_in_use::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_key_signing_key_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::DeactivateKeySigningKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchKeySigningKey" => {
            crate::error::DeactivateKeySigningKeyError::NoSuchKeySigningKey({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_key_signing_key::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_key_signing_key_xml_err(response.body().as_ref(), output).map_err(crate::error::DeactivateKeySigningKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeactivateKeySigningKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deactivate_key_signing_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeactivateKeySigningKeyOutput,
    crate::error::DeactivateKeySigningKeyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deactivate_key_signing_key_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_deactivate_key_signing_key(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeactivateKeySigningKeyError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_cidr_collection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCidrCollectionOutput,
    crate::error::DeleteCidrCollectionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteCidrCollectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteCidrCollectionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CidrCollectionInUseException" => {
            crate::error::DeleteCidrCollectionError::CidrCollectionInUseException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::cidr_collection_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cidr_collection_in_use_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteCidrCollectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ConcurrentModification" => {
            crate::error::DeleteCidrCollectionError::ConcurrentModification({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_modification::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteCidrCollectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInput" => crate::error::DeleteCidrCollectionError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteCidrCollectionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchCidrCollectionException" => {
            crate::error::DeleteCidrCollectionError::NoSuchCidrCollectionException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_cidr_collection_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_cidr_collection_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteCidrCollectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteCidrCollectionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_cidr_collection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCidrCollectionOutput,
    crate::error::DeleteCidrCollectionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_cidr_collection_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_health_check_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteHealthCheckOutput, crate::error::DeleteHealthCheckError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteHealthCheckError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteHealthCheckError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "HealthCheckInUse" => crate::error::DeleteHealthCheckError::HealthCheckInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::health_check_in_use::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_health_check_in_use_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteHealthCheckError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInput" => crate::error::DeleteHealthCheckError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteHealthCheckError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHealthCheck" => crate::error::DeleteHealthCheckError::NoSuchHealthCheck({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_health_check::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_health_check_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteHealthCheckError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteHealthCheckError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_health_check_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteHealthCheckOutput, crate::error::DeleteHealthCheckError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_health_check_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_hosted_zone_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteHostedZoneOutput, crate::error::DeleteHostedZoneError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteHostedZoneError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteHostedZoneError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "HostedZoneNotEmpty" => {
            crate::error::DeleteHostedZoneError::HostedZoneNotEmpty({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::hosted_zone_not_empty::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_hosted_zone_not_empty_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteHostedZoneError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDomainName" => crate::error::DeleteHostedZoneError::InvalidDomainName({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_domain_name::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_domain_name_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteHostedZoneError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInput" => crate::error::DeleteHostedZoneError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteHostedZoneError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHostedZone" => crate::error::DeleteHostedZoneError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_hosted_zone::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteHostedZoneError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "PriorRequestNotComplete" => {
            crate::error::DeleteHostedZoneError::PriorRequestNotComplete({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prior_request_not_complete::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_prior_request_not_complete_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteHostedZoneError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteHostedZoneError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_hosted_zone_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteHostedZoneOutput, crate::error::DeleteHostedZoneError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_hosted_zone_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_hosted_zone(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteHostedZoneError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_key_signing_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteKeySigningKeyOutput,
    crate::error::DeleteKeySigningKeyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteKeySigningKeyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteKeySigningKeyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => {
            crate::error::DeleteKeySigningKeyError::ConcurrentModification({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_modification::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteKeySigningKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInput" => crate::error::DeleteKeySigningKeyError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteKeySigningKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidKeySigningKeyStatus" => {
            crate::error::DeleteKeySigningKeyError::InvalidKeySigningKeyStatus({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_key_signing_key_status::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_key_signing_key_status_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteKeySigningKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidKMSArn" => crate::error::DeleteKeySigningKeyError::InvalidKmsArn({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_kms_arn::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_kms_arn_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteKeySigningKeyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidSigningStatus" => {
            crate::error::DeleteKeySigningKeyError::InvalidSigningStatus({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_signing_status::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_signing_status_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteKeySigningKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchKeySigningKey" => {
            crate::error::DeleteKeySigningKeyError::NoSuchKeySigningKey({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_key_signing_key::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_key_signing_key_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteKeySigningKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteKeySigningKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_key_signing_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteKeySigningKeyOutput,
    crate::error::DeleteKeySigningKeyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_key_signing_key_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_key_signing_key(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteKeySigningKeyError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_query_logging_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteQueryLoggingConfigOutput,
    crate::error::DeleteQueryLoggingConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteQueryLoggingConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteQueryLoggingConfigError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => {
            crate::error::DeleteQueryLoggingConfigError::ConcurrentModification({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_modification::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteQueryLoggingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInput" => crate::error::DeleteQueryLoggingConfigError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteQueryLoggingConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchQueryLoggingConfig" => {
            crate::error::DeleteQueryLoggingConfigError::NoSuchQueryLoggingConfig({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_query_logging_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_query_logging_config_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteQueryLoggingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteQueryLoggingConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_query_logging_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteQueryLoggingConfigOutput,
    crate::error::DeleteQueryLoggingConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_query_logging_config_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_reusable_delegation_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteReusableDelegationSetOutput,
    crate::error::DeleteReusableDelegationSetError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteReusableDelegationSetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteReusableDelegationSetError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DelegationSetInUse" => {
            crate::error::DeleteReusableDelegationSetError::DelegationSetInUse({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::delegation_set_in_use::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_delegation_set_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteReusableDelegationSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DelegationSetNotReusable" => {
            crate::error::DeleteReusableDelegationSetError::DelegationSetNotReusable({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::delegation_set_not_reusable::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_delegation_set_not_reusable_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteReusableDelegationSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInput" => crate::error::DeleteReusableDelegationSetError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteReusableDelegationSetError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchDelegationSet" => {
            crate::error::DeleteReusableDelegationSetError::NoSuchDelegationSet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_delegation_set::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_delegation_set_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteReusableDelegationSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteReusableDelegationSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_reusable_delegation_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteReusableDelegationSetOutput,
    crate::error::DeleteReusableDelegationSetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_reusable_delegation_set_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTrafficPolicyOutput,
    crate::error::DeleteTrafficPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTrafficPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteTrafficPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => {
            crate::error::DeleteTrafficPolicyError::ConcurrentModification({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_modification::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteTrafficPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInput" => crate::error::DeleteTrafficPolicyError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteTrafficPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchTrafficPolicy" => {
            crate::error::DeleteTrafficPolicyError::NoSuchTrafficPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_traffic_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_traffic_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteTrafficPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TrafficPolicyInUse" => {
            crate::error::DeleteTrafficPolicyError::TrafficPolicyInUse({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::traffic_policy_in_use::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_traffic_policy_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteTrafficPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteTrafficPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTrafficPolicyOutput,
    crate::error::DeleteTrafficPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_traffic_policy_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_policy_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTrafficPolicyInstanceOutput,
    crate::error::DeleteTrafficPolicyInstanceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTrafficPolicyInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteTrafficPolicyInstanceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::DeleteTrafficPolicyInstanceError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteTrafficPolicyInstanceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchTrafficPolicyInstance" => {
            crate::error::DeleteTrafficPolicyInstanceError::NoSuchTrafficPolicyInstance({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_traffic_policy_instance::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_traffic_policy_instance_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteTrafficPolicyInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PriorRequestNotComplete" => {
            crate::error::DeleteTrafficPolicyInstanceError::PriorRequestNotComplete({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prior_request_not_complete::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_prior_request_not_complete_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteTrafficPolicyInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteTrafficPolicyInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_policy_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTrafficPolicyInstanceOutput,
    crate::error::DeleteTrafficPolicyInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_traffic_policy_instance_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_association_authorization_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVpcAssociationAuthorizationOutput,
    crate::error::DeleteVPCAssociationAuthorizationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteVPCAssociationAuthorizationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteVPCAssociationAuthorizationError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => crate::error::DeleteVPCAssociationAuthorizationError::ConcurrentModification({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_modification::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteVPCAssociationAuthorizationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidInput" => crate::error::DeleteVPCAssociationAuthorizationError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteVPCAssociationAuthorizationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidVPCId" => crate::error::DeleteVPCAssociationAuthorizationError::InvalidVpcId({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_vpc_id::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_id_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteVPCAssociationAuthorizationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NoSuchHostedZone" => crate::error::DeleteVPCAssociationAuthorizationError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_hosted_zone::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteVPCAssociationAuthorizationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "VPCAssociationAuthorizationNotFound" => crate::error::DeleteVPCAssociationAuthorizationError::VpcAssociationAuthorizationNotFound({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::vpc_association_authorization_not_found::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_vpc_association_authorization_not_found_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteVPCAssociationAuthorizationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DeleteVPCAssociationAuthorizationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_association_authorization_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVpcAssociationAuthorizationOutput,
    crate::error::DeleteVPCAssociationAuthorizationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_vpc_association_authorization_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_hosted_zone_dnssec_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableHostedZoneDnssecOutput,
    crate::error::DisableHostedZoneDNSSECError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisableHostedZoneDNSSECError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DisableHostedZoneDNSSECError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => {
            crate::error::DisableHostedZoneDNSSECError::ConcurrentModification({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_modification::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_xml_err(response.body().as_ref(), output).map_err(crate::error::DisableHostedZoneDNSSECError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DNSSECNotFound" => crate::error::DisableHostedZoneDNSSECError::DnssecNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::dnssec_not_found::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_dnssec_not_found_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DisableHostedZoneDNSSECError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidArgument" => crate::error::DisableHostedZoneDNSSECError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DisableHostedZoneDNSSECError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInput" => crate::error::DisableHostedZoneDNSSECError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DisableHostedZoneDNSSECError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidKeySigningKeyStatus" => {
            crate::error::DisableHostedZoneDNSSECError::InvalidKeySigningKeyStatus({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_key_signing_key_status::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_key_signing_key_status_xml_err(response.body().as_ref(), output).map_err(crate::error::DisableHostedZoneDNSSECError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidKMSArn" => crate::error::DisableHostedZoneDNSSECError::InvalidKmsArn({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_kms_arn::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_kms_arn_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DisableHostedZoneDNSSECError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "KeySigningKeyInParentDSRecord" => {
            crate::error::DisableHostedZoneDNSSECError::KeySigningKeyInParentDsRecord({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::key_signing_key_in_parent_ds_record::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_key_signing_key_in_parent_ds_record_xml_err(response.body().as_ref(), output).map_err(crate::error::DisableHostedZoneDNSSECError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchHostedZone" => crate::error::DisableHostedZoneDNSSECError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_hosted_zone::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DisableHostedZoneDNSSECError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DisableHostedZoneDNSSECError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_hosted_zone_dnssec_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableHostedZoneDnssecOutput,
    crate::error::DisableHostedZoneDNSSECError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_hosted_zone_dnssec_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_hosted_zone_dnssec(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DisableHostedZoneDNSSECError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_vpc_from_hosted_zone_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateVpcFromHostedZoneOutput,
    crate::error::DisassociateVPCFromHostedZoneError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisassociateVPCFromHostedZoneError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DisassociateVPCFromHostedZoneError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::DisassociateVPCFromHostedZoneError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DisassociateVPCFromHostedZoneError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidVPCId" => crate::error::DisassociateVPCFromHostedZoneError::InvalidVpcId({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_vpc_id::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_id_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DisassociateVPCFromHostedZoneError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LastVPCAssociation" => {
            crate::error::DisassociateVPCFromHostedZoneError::LastVpcAssociation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::last_vpc_association::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_last_vpc_association_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DisassociateVPCFromHostedZoneError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchHostedZone" => crate::error::DisassociateVPCFromHostedZoneError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_hosted_zone::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DisassociateVPCFromHostedZoneError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "VPCAssociationNotFound" => {
            crate::error::DisassociateVPCFromHostedZoneError::VpcAssociationNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::vpc_association_not_found::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_vpc_association_not_found_xml_err(response.body().as_ref(), output).map_err(crate::error::DisassociateVPCFromHostedZoneError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DisassociateVPCFromHostedZoneError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_vpc_from_hosted_zone_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateVpcFromHostedZoneOutput,
    crate::error::DisassociateVPCFromHostedZoneError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::disassociate_vpc_from_hosted_zone_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_disassociate_vpc_from_hosted_zone(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DisassociateVPCFromHostedZoneError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_hosted_zone_dnssec_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableHostedZoneDnssecOutput,
    crate::error::EnableHostedZoneDNSSECError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::EnableHostedZoneDNSSECError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::EnableHostedZoneDNSSECError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => {
            crate::error::EnableHostedZoneDNSSECError::ConcurrentModification({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_modification::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableHostedZoneDNSSECError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DNSSECNotFound" => crate::error::EnableHostedZoneDNSSECError::DnssecNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::dnssec_not_found::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_dnssec_not_found_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::EnableHostedZoneDNSSECError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "HostedZonePartiallyDelegated" => {
            crate::error::EnableHostedZoneDNSSECError::HostedZonePartiallyDelegated({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::hosted_zone_partially_delegated::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_hosted_zone_partially_delegated_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableHostedZoneDNSSECError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidArgument" => crate::error::EnableHostedZoneDNSSECError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::EnableHostedZoneDNSSECError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInput" => crate::error::EnableHostedZoneDNSSECError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::EnableHostedZoneDNSSECError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidKeySigningKeyStatus" => {
            crate::error::EnableHostedZoneDNSSECError::InvalidKeySigningKeyStatus({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_key_signing_key_status::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_key_signing_key_status_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableHostedZoneDNSSECError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidKMSArn" => crate::error::EnableHostedZoneDNSSECError::InvalidKmsArn({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_kms_arn::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_kms_arn_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::EnableHostedZoneDNSSECError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "KeySigningKeyWithActiveStatusNotFound" => {
            crate::error::EnableHostedZoneDNSSECError::KeySigningKeyWithActiveStatusNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::key_signing_key_with_active_status_not_found::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_key_signing_key_with_active_status_not_found_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableHostedZoneDNSSECError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchHostedZone" => crate::error::EnableHostedZoneDNSSECError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_hosted_zone::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::EnableHostedZoneDNSSECError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::EnableHostedZoneDNSSECError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_hosted_zone_dnssec_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableHostedZoneDnssecOutput,
    crate::error::EnableHostedZoneDNSSECError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_hosted_zone_dnssec_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_hosted_zone_dnssec(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::EnableHostedZoneDNSSECError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_limit_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetAccountLimitOutput, crate::error::GetAccountLimitError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetAccountLimitError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetAccountLimitError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetAccountLimitError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetAccountLimitError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetAccountLimitError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_limit_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetAccountLimitOutput, crate::error::GetAccountLimitError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_account_limit_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_account_limit(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetAccountLimitError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_change_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetChangeOutput, crate::error::GetChangeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetChangeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetChangeError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetChangeError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetChangeError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchChange" => crate::error::GetChangeError::NoSuchChange({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_change::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_change_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetChangeError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetChangeError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_change_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetChangeOutput, crate::error::GetChangeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_change_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_change(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetChangeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_checker_ip_ranges_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCheckerIpRangesOutput,
    crate::error::GetCheckerIpRangesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetCheckerIpRangesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetCheckerIpRangesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_checker_ip_ranges_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCheckerIpRangesOutput,
    crate::error::GetCheckerIpRangesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_checker_ip_ranges_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_checker_ip_ranges(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCheckerIpRangesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_dnssec_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDnssecOutput, crate::error::GetDNSSECError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetDNSSECError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDNSSECError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidArgument" => crate::error::GetDNSSECError::InvalidArgument({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_argument::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_argument_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDNSSECError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInput" => crate::error::GetDNSSECError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDNSSECError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHostedZone" => crate::error::GetDNSSECError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_hosted_zone::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDNSSECError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetDNSSECError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_dnssec_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDnssecOutput, crate::error::GetDNSSECError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_dnssec_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_dnssec(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDNSSECError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_geo_location_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGeoLocationOutput, crate::error::GetGeoLocationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetGeoLocationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetGeoLocationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetGeoLocationError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetGeoLocationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchGeoLocation" => crate::error::GetGeoLocationError::NoSuchGeoLocation({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_geo_location::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_geo_location_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetGeoLocationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetGeoLocationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_geo_location_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGeoLocationOutput, crate::error::GetGeoLocationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_geo_location_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_geo_location(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetGeoLocationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_health_check_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetHealthCheckOutput, crate::error::GetHealthCheckError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetHealthCheckError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetHealthCheckError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "IncompatibleVersion" => crate::error::GetHealthCheckError::IncompatibleVersion({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::incompatible_version::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_incompatible_version_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetHealthCheckError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInput" => crate::error::GetHealthCheckError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetHealthCheckError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHealthCheck" => crate::error::GetHealthCheckError::NoSuchHealthCheck({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_health_check::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_health_check_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetHealthCheckError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetHealthCheckError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_health_check_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetHealthCheckOutput, crate::error::GetHealthCheckError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_health_check_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_health_check(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetHealthCheckError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_health_check_count_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetHealthCheckCountOutput,
    crate::error::GetHealthCheckCountError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetHealthCheckCountError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetHealthCheckCountError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_health_check_count_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetHealthCheckCountOutput,
    crate::error::GetHealthCheckCountError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_health_check_count_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_health_check_count(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetHealthCheckCountError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_health_check_last_failure_reason_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetHealthCheckLastFailureReasonOutput,
    crate::error::GetHealthCheckLastFailureReasonError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetHealthCheckLastFailureReasonError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetHealthCheckLastFailureReasonError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetHealthCheckLastFailureReasonError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetHealthCheckLastFailureReasonError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHealthCheck" => {
            crate::error::GetHealthCheckLastFailureReasonError::NoSuchHealthCheck({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_health_check::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_no_such_health_check_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetHealthCheckLastFailureReasonError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetHealthCheckLastFailureReasonError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_health_check_last_failure_reason_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetHealthCheckLastFailureReasonOutput,
    crate::error::GetHealthCheckLastFailureReasonError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_health_check_last_failure_reason_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_get_health_check_last_failure_reason(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetHealthCheckLastFailureReasonError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_health_check_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetHealthCheckStatusOutput,
    crate::error::GetHealthCheckStatusError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetHealthCheckStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetHealthCheckStatusError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetHealthCheckStatusError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetHealthCheckStatusError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHealthCheck" => crate::error::GetHealthCheckStatusError::NoSuchHealthCheck({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_health_check::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_health_check_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetHealthCheckStatusError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetHealthCheckStatusError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_health_check_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetHealthCheckStatusOutput,
    crate::error::GetHealthCheckStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_health_check_status_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_health_check_status(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetHealthCheckStatusError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_hosted_zone_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetHostedZoneOutput, crate::error::GetHostedZoneError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetHostedZoneError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetHostedZoneError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetHostedZoneError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetHostedZoneError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHostedZone" => crate::error::GetHostedZoneError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_hosted_zone::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetHostedZoneError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetHostedZoneError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_hosted_zone_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetHostedZoneOutput, crate::error::GetHostedZoneError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_hosted_zone_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_hosted_zone(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetHostedZoneError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_hosted_zone_count_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetHostedZoneCountOutput,
    crate::error::GetHostedZoneCountError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetHostedZoneCountError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetHostedZoneCountError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetHostedZoneCountError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetHostedZoneCountError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetHostedZoneCountError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_hosted_zone_count_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetHostedZoneCountOutput,
    crate::error::GetHostedZoneCountError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_hosted_zone_count_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_hosted_zone_count(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetHostedZoneCountError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_hosted_zone_limit_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetHostedZoneLimitOutput,
    crate::error::GetHostedZoneLimitError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetHostedZoneLimitError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetHostedZoneLimitError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "HostedZoneNotPrivate" => {
            crate::error::GetHostedZoneLimitError::HostedZoneNotPrivate({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::hosted_zone_not_private::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_hosted_zone_not_private_xml_err(response.body().as_ref(), output).map_err(crate::error::GetHostedZoneLimitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInput" => crate::error::GetHostedZoneLimitError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetHostedZoneLimitError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHostedZone" => crate::error::GetHostedZoneLimitError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_hosted_zone::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetHostedZoneLimitError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetHostedZoneLimitError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_hosted_zone_limit_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetHostedZoneLimitOutput,
    crate::error::GetHostedZoneLimitError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_hosted_zone_limit_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_hosted_zone_limit(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetHostedZoneLimitError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_query_logging_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetQueryLoggingConfigOutput,
    crate::error::GetQueryLoggingConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetQueryLoggingConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetQueryLoggingConfigError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetQueryLoggingConfigError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetQueryLoggingConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchQueryLoggingConfig" => {
            crate::error::GetQueryLoggingConfigError::NoSuchQueryLoggingConfig({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_query_logging_config::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_query_logging_config_xml_err(response.body().as_ref(), output).map_err(crate::error::GetQueryLoggingConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetQueryLoggingConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_query_logging_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetQueryLoggingConfigOutput,
    crate::error::GetQueryLoggingConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_query_logging_config_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_query_logging_config(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetQueryLoggingConfigError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_reusable_delegation_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetReusableDelegationSetOutput,
    crate::error::GetReusableDelegationSetError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetReusableDelegationSetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetReusableDelegationSetError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DelegationSetNotReusable" => {
            crate::error::GetReusableDelegationSetError::DelegationSetNotReusable({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::delegation_set_not_reusable::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_delegation_set_not_reusable_xml_err(response.body().as_ref(), output).map_err(crate::error::GetReusableDelegationSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInput" => crate::error::GetReusableDelegationSetError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetReusableDelegationSetError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchDelegationSet" => {
            crate::error::GetReusableDelegationSetError::NoSuchDelegationSet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_delegation_set::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_delegation_set_xml_err(response.body().as_ref(), output).map_err(crate::error::GetReusableDelegationSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetReusableDelegationSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_reusable_delegation_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetReusableDelegationSetOutput,
    crate::error::GetReusableDelegationSetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_reusable_delegation_set_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_reusable_delegation_set(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetReusableDelegationSetError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_reusable_delegation_set_limit_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetReusableDelegationSetLimitOutput,
    crate::error::GetReusableDelegationSetLimitError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetReusableDelegationSetLimitError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetReusableDelegationSetLimitError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetReusableDelegationSetLimitError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetReusableDelegationSetLimitError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchDelegationSet" => {
            crate::error::GetReusableDelegationSetLimitError::NoSuchDelegationSet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_delegation_set::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_delegation_set_xml_err(response.body().as_ref(), output).map_err(crate::error::GetReusableDelegationSetLimitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetReusableDelegationSetLimitError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_reusable_delegation_set_limit_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetReusableDelegationSetLimitOutput,
    crate::error::GetReusableDelegationSetLimitError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_reusable_delegation_set_limit_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_get_reusable_delegation_set_limit(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetReusableDelegationSetLimitError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_traffic_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetTrafficPolicyOutput, crate::error::GetTrafficPolicyError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetTrafficPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetTrafficPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetTrafficPolicyError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetTrafficPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchTrafficPolicy" => {
            crate::error::GetTrafficPolicyError::NoSuchTrafficPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_traffic_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_traffic_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::GetTrafficPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetTrafficPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_traffic_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetTrafficPolicyOutput, crate::error::GetTrafficPolicyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_traffic_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_traffic_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetTrafficPolicyError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_traffic_policy_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTrafficPolicyInstanceOutput,
    crate::error::GetTrafficPolicyInstanceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetTrafficPolicyInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetTrafficPolicyInstanceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::GetTrafficPolicyInstanceError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetTrafficPolicyInstanceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchTrafficPolicyInstance" => {
            crate::error::GetTrafficPolicyInstanceError::NoSuchTrafficPolicyInstance({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_traffic_policy_instance::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_traffic_policy_instance_xml_err(response.body().as_ref(), output).map_err(crate::error::GetTrafficPolicyInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetTrafficPolicyInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_traffic_policy_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTrafficPolicyInstanceOutput,
    crate::error::GetTrafficPolicyInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_traffic_policy_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_traffic_policy_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetTrafficPolicyInstanceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_traffic_policy_instance_count_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTrafficPolicyInstanceCountOutput,
    crate::error::GetTrafficPolicyInstanceCountError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetTrafficPolicyInstanceCountError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetTrafficPolicyInstanceCountError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_traffic_policy_instance_count_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTrafficPolicyInstanceCountOutput,
    crate::error::GetTrafficPolicyInstanceCountError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_traffic_policy_instance_count_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_get_traffic_policy_instance_count(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetTrafficPolicyInstanceCountError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_cidr_blocks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListCidrBlocksOutput, crate::error::ListCidrBlocksError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListCidrBlocksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListCidrBlocksError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListCidrBlocksError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListCidrBlocksError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchCidrCollectionException" => {
            crate::error::ListCidrBlocksError::NoSuchCidrCollectionException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_cidr_collection_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_cidr_collection_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListCidrBlocksError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchCidrLocationException" => {
            crate::error::ListCidrBlocksError::NoSuchCidrLocationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_cidr_location_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_cidr_location_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListCidrBlocksError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListCidrBlocksError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_cidr_blocks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListCidrBlocksOutput, crate::error::ListCidrBlocksError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_cidr_blocks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_cidr_blocks(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListCidrBlocksError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_cidr_collections_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCidrCollectionsOutput,
    crate::error::ListCidrCollectionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListCidrCollectionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListCidrCollectionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListCidrCollectionsError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListCidrCollectionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListCidrCollectionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_cidr_collections_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCidrCollectionsOutput,
    crate::error::ListCidrCollectionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_cidr_collections_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_cidr_collections(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListCidrCollectionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_cidr_locations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListCidrLocationsOutput, crate::error::ListCidrLocationsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListCidrLocationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListCidrLocationsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListCidrLocationsError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListCidrLocationsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchCidrCollectionException" => {
            crate::error::ListCidrLocationsError::NoSuchCidrCollectionException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_cidr_collection_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_cidr_collection_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListCidrLocationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListCidrLocationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_cidr_locations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListCidrLocationsOutput, crate::error::ListCidrLocationsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_cidr_locations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_cidr_locations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListCidrLocationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_geo_locations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGeoLocationsOutput, crate::error::ListGeoLocationsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListGeoLocationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListGeoLocationsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListGeoLocationsError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListGeoLocationsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListGeoLocationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_geo_locations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGeoLocationsOutput, crate::error::ListGeoLocationsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_geo_locations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_geo_locations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListGeoLocationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_health_checks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListHealthChecksOutput, crate::error::ListHealthChecksError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListHealthChecksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListHealthChecksError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "IncompatibleVersion" => crate::error::ListHealthChecksError::IncompatibleVersion({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::incompatible_version::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_incompatible_version_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListHealthChecksError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInput" => crate::error::ListHealthChecksError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListHealthChecksError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListHealthChecksError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_health_checks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListHealthChecksOutput, crate::error::ListHealthChecksError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_health_checks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_health_checks(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListHealthChecksError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_hosted_zones_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListHostedZonesOutput, crate::error::ListHostedZonesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListHostedZonesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListHostedZonesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DelegationSetNotReusable" => {
            crate::error::ListHostedZonesError::DelegationSetNotReusable({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::delegation_set_not_reusable::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_delegation_set_not_reusable_xml_err(response.body().as_ref(), output).map_err(crate::error::ListHostedZonesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInput" => crate::error::ListHostedZonesError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListHostedZonesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchDelegationSet" => {
            crate::error::ListHostedZonesError::NoSuchDelegationSet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_delegation_set::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_delegation_set_xml_err(response.body().as_ref(), output).map_err(crate::error::ListHostedZonesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListHostedZonesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_hosted_zones_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListHostedZonesOutput, crate::error::ListHostedZonesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_hosted_zones_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_hosted_zones(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListHostedZonesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_hosted_zones_by_name_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListHostedZonesByNameOutput,
    crate::error::ListHostedZonesByNameError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListHostedZonesByNameError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListHostedZonesByNameError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidDomainName" => crate::error::ListHostedZonesByNameError::InvalidDomainName({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_domain_name::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_domain_name_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListHostedZonesByNameError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInput" => crate::error::ListHostedZonesByNameError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListHostedZonesByNameError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListHostedZonesByNameError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_hosted_zones_by_name_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListHostedZonesByNameOutput,
    crate::error::ListHostedZonesByNameError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_hosted_zones_by_name_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_hosted_zones_by_name(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListHostedZonesByNameError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_hosted_zones_by_vpc_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListHostedZonesByVpcOutput,
    crate::error::ListHostedZonesByVPCError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListHostedZonesByVPCError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListHostedZonesByVPCError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListHostedZonesByVPCError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListHostedZonesByVPCError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidPaginationToken" => {
            crate::error::ListHostedZonesByVPCError::InvalidPaginationToken({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pagination_token::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_pagination_token_xml_err(response.body().as_ref(), output).map_err(crate::error::ListHostedZonesByVPCError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListHostedZonesByVPCError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_hosted_zones_by_vpc_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListHostedZonesByVpcOutput,
    crate::error::ListHostedZonesByVPCError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_hosted_zones_by_vpc_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_hosted_zones_by_vpc(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListHostedZonesByVPCError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_query_logging_configs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListQueryLoggingConfigsOutput,
    crate::error::ListQueryLoggingConfigsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListQueryLoggingConfigsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListQueryLoggingConfigsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListQueryLoggingConfigsError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListQueryLoggingConfigsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidPaginationToken" => {
            crate::error::ListQueryLoggingConfigsError::InvalidPaginationToken({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pagination_token::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_pagination_token_xml_err(response.body().as_ref(), output).map_err(crate::error::ListQueryLoggingConfigsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchHostedZone" => crate::error::ListQueryLoggingConfigsError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_hosted_zone::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListQueryLoggingConfigsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListQueryLoggingConfigsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_query_logging_configs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListQueryLoggingConfigsOutput,
    crate::error::ListQueryLoggingConfigsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_query_logging_configs_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_query_logging_configs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListQueryLoggingConfigsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_record_sets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListResourceRecordSetsOutput,
    crate::error::ListResourceRecordSetsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListResourceRecordSetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListResourceRecordSetsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListResourceRecordSetsError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListResourceRecordSetsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHostedZone" => crate::error::ListResourceRecordSetsError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_hosted_zone::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListResourceRecordSetsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListResourceRecordSetsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_record_sets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListResourceRecordSetsOutput,
    crate::error::ListResourceRecordSetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_resource_record_sets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_resource_record_sets(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListResourceRecordSetsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_reusable_delegation_sets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListReusableDelegationSetsOutput,
    crate::error::ListReusableDelegationSetsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListReusableDelegationSetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListReusableDelegationSetsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListReusableDelegationSetsError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListReusableDelegationSetsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListReusableDelegationSetsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_reusable_delegation_sets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListReusableDelegationSetsOutput,
    crate::error::ListReusableDelegationSetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_reusable_delegation_sets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_reusable_delegation_sets(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListReusableDelegationSetsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTagsForResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListTagsForResourceError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHealthCheck" => crate::error::ListTagsForResourceError::NoSuchHealthCheck({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_health_check::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_health_check_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHostedZone" => crate::error::ListTagsForResourceError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_hosted_zone::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "PriorRequestNotComplete" => {
            crate::error::ListTagsForResourceError::PriorRequestNotComplete({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prior_request_not_complete::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_prior_request_not_complete_xml_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ThrottlingException" => crate::error::ListTagsForResourceError::ThrottlingException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::throttling_exception::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_throttling_exception_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListTagsForResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resource_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_tags_for_resource(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resources_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourcesOutput,
    crate::error::ListTagsForResourcesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTagsForResourcesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTagsForResourcesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListTagsForResourcesError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTagsForResourcesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHealthCheck" => crate::error::ListTagsForResourcesError::NoSuchHealthCheck({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_health_check::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_health_check_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTagsForResourcesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHostedZone" => crate::error::ListTagsForResourcesError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_hosted_zone::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTagsForResourcesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "PriorRequestNotComplete" => {
            crate::error::ListTagsForResourcesError::PriorRequestNotComplete({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prior_request_not_complete::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_prior_request_not_complete_xml_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourcesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ThrottlingException" => crate::error::ListTagsForResourcesError::ThrottlingException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::throttling_exception::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_throttling_exception_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTagsForResourcesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListTagsForResourcesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resources_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourcesOutput,
    crate::error::ListTagsForResourcesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resources_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_tags_for_resources(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTagsForResourcesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_traffic_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTrafficPoliciesOutput,
    crate::error::ListTrafficPoliciesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTrafficPoliciesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTrafficPoliciesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListTrafficPoliciesError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTrafficPoliciesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListTrafficPoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_traffic_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTrafficPoliciesOutput,
    crate::error::ListTrafficPoliciesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_traffic_policies_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_traffic_policies(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTrafficPoliciesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_traffic_policy_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTrafficPolicyInstancesOutput,
    crate::error::ListTrafficPolicyInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTrafficPolicyInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListTrafficPolicyInstancesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListTrafficPolicyInstancesError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTrafficPolicyInstancesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchTrafficPolicyInstance" => {
            crate::error::ListTrafficPolicyInstancesError::NoSuchTrafficPolicyInstance({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_traffic_policy_instance::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_traffic_policy_instance_xml_err(response.body().as_ref(), output).map_err(crate::error::ListTrafficPolicyInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListTrafficPolicyInstancesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_traffic_policy_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTrafficPolicyInstancesOutput,
    crate::error::ListTrafficPolicyInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_traffic_policy_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_traffic_policy_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTrafficPolicyInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_traffic_policy_instances_by_hosted_zone_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTrafficPolicyInstancesByHostedZoneOutput,
    crate::error::ListTrafficPolicyInstancesByHostedZoneError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTrafficPolicyInstancesByHostedZoneError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::ListTrafficPolicyInstancesByHostedZoneError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => {
            crate::error::ListTrafficPolicyInstancesByHostedZoneError::InvalidInput({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_input::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(
                        crate::error::ListTrafficPolicyInstancesByHostedZoneError::unhandled,
                    )?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchHostedZone" => {
            crate::error::ListTrafficPolicyInstancesByHostedZoneError::NoSuchHostedZone({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_hosted_zone::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::ListTrafficPolicyInstancesByHostedZoneError::unhandled,
                        )?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchTrafficPolicyInstance" => {
            crate::error::ListTrafficPolicyInstancesByHostedZoneError::NoSuchTrafficPolicyInstance(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::no_such_traffic_policy_instance::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_no_such_traffic_policy_instance_xml_err(response.body().as_ref(), output).map_err(crate::error::ListTrafficPolicyInstancesByHostedZoneError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        _ => crate::error::ListTrafficPolicyInstancesByHostedZoneError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_traffic_policy_instances_by_hosted_zone_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTrafficPolicyInstancesByHostedZoneOutput,
    crate::error::ListTrafficPolicyInstancesByHostedZoneError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_traffic_policy_instances_by_hosted_zone_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_traffic_policy_instances_by_hosted_zone(response.body().as_ref(), output).map_err(crate::error::ListTrafficPolicyInstancesByHostedZoneError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_traffic_policy_instances_by_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTrafficPolicyInstancesByPolicyOutput,
    crate::error::ListTrafficPolicyInstancesByPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTrafficPolicyInstancesByPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListTrafficPolicyInstancesByPolicyError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListTrafficPolicyInstancesByPolicyError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTrafficPolicyInstancesByPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchTrafficPolicy" => {
            crate::error::ListTrafficPolicyInstancesByPolicyError::NoSuchTrafficPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_traffic_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_traffic_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::ListTrafficPolicyInstancesByPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchTrafficPolicyInstance" => {
            crate::error::ListTrafficPolicyInstancesByPolicyError::NoSuchTrafficPolicyInstance({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_traffic_policy_instance::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_traffic_policy_instance_xml_err(response.body().as_ref(), output).map_err(crate::error::ListTrafficPolicyInstancesByPolicyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListTrafficPolicyInstancesByPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_traffic_policy_instances_by_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTrafficPolicyInstancesByPolicyOutput,
    crate::error::ListTrafficPolicyInstancesByPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_traffic_policy_instances_by_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_traffic_policy_instances_by_policy(response.body().as_ref(), output).map_err(crate::error::ListTrafficPolicyInstancesByPolicyError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_traffic_policy_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTrafficPolicyVersionsOutput,
    crate::error::ListTrafficPolicyVersionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTrafficPolicyVersionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListTrafficPolicyVersionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListTrafficPolicyVersionsError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTrafficPolicyVersionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchTrafficPolicy" => {
            crate::error::ListTrafficPolicyVersionsError::NoSuchTrafficPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_traffic_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_traffic_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::ListTrafficPolicyVersionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListTrafficPolicyVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_traffic_policy_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTrafficPolicyVersionsOutput,
    crate::error::ListTrafficPolicyVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_traffic_policy_versions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_traffic_policy_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTrafficPolicyVersionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_vpc_association_authorizations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListVpcAssociationAuthorizationsOutput,
    crate::error::ListVPCAssociationAuthorizationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListVPCAssociationAuthorizationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListVPCAssociationAuthorizationsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::ListVPCAssociationAuthorizationsError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListVPCAssociationAuthorizationsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidPaginationToken" => {
            crate::error::ListVPCAssociationAuthorizationsError::InvalidPaginationToken({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pagination_token::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_pagination_token_xml_err(response.body().as_ref(), output).map_err(crate::error::ListVPCAssociationAuthorizationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchHostedZone" => {
            crate::error::ListVPCAssociationAuthorizationsError::NoSuchHostedZone({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_hosted_zone::Builder::default();
                    let _ = response;
                    output =
                        crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::ListVPCAssociationAuthorizationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListVPCAssociationAuthorizationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_vpc_association_authorizations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListVpcAssociationAuthorizationsOutput,
    crate::error::ListVPCAssociationAuthorizationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_vpc_association_authorizations_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_list_vpc_association_authorizations(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ListVPCAssociationAuthorizationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_dns_answer_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TestDnsAnswerOutput, crate::error::TestDNSAnswerError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::TestDNSAnswerError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TestDNSAnswerError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::TestDNSAnswerError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TestDNSAnswerError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHostedZone" => crate::error::TestDNSAnswerError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_hosted_zone::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TestDNSAnswerError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::TestDNSAnswerError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_dns_answer_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TestDnsAnswerOutput, crate::error::TestDNSAnswerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::test_dns_answer_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_test_dns_answer(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::TestDNSAnswerError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_health_check_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateHealthCheckOutput, crate::error::UpdateHealthCheckError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateHealthCheckError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateHealthCheckError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "HealthCheckVersionMismatch" => {
            crate::error::UpdateHealthCheckError::HealthCheckVersionMismatch({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::health_check_version_mismatch::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_health_check_version_mismatch_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateHealthCheckError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInput" => crate::error::UpdateHealthCheckError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateHealthCheckError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHealthCheck" => crate::error::UpdateHealthCheckError::NoSuchHealthCheck({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_health_check::Builder::default();
                let _ = response;
                output =
                    crate::xml_deser::deser_structure_crate_error_no_such_health_check_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateHealthCheckError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateHealthCheckError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_health_check_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateHealthCheckOutput, crate::error::UpdateHealthCheckError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_health_check_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_update_health_check(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateHealthCheckError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_hosted_zone_comment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateHostedZoneCommentOutput,
    crate::error::UpdateHostedZoneCommentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateHostedZoneCommentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateHostedZoneCommentError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidInput" => crate::error::UpdateHostedZoneCommentError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateHostedZoneCommentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchHostedZone" => crate::error::UpdateHostedZoneCommentError::NoSuchHostedZone({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::no_such_hosted_zone::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_no_such_hosted_zone_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateHostedZoneCommentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "PriorRequestNotComplete" => {
            crate::error::UpdateHostedZoneCommentError::PriorRequestNotComplete({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prior_request_not_complete::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_prior_request_not_complete_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateHostedZoneCommentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateHostedZoneCommentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_hosted_zone_comment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateHostedZoneCommentOutput,
    crate::error::UpdateHostedZoneCommentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_hosted_zone_comment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_update_hosted_zone_comment(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateHostedZoneCommentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_traffic_policy_comment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateTrafficPolicyCommentOutput,
    crate::error::UpdateTrafficPolicyCommentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateTrafficPolicyCommentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateTrafficPolicyCommentError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentModification" => {
            crate::error::UpdateTrafficPolicyCommentError::ConcurrentModification({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_modification::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_concurrent_modification_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateTrafficPolicyCommentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidInput" => crate::error::UpdateTrafficPolicyCommentError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateTrafficPolicyCommentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchTrafficPolicy" => {
            crate::error::UpdateTrafficPolicyCommentError::NoSuchTrafficPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_traffic_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_traffic_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateTrafficPolicyCommentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateTrafficPolicyCommentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_traffic_policy_comment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateTrafficPolicyCommentOutput,
    crate::error::UpdateTrafficPolicyCommentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_traffic_policy_comment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_update_traffic_policy_comment(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateTrafficPolicyCommentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_traffic_policy_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateTrafficPolicyInstanceOutput,
    crate::error::UpdateTrafficPolicyInstanceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateTrafficPolicyInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateTrafficPolicyInstanceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictingTypes" => crate::error::UpdateTrafficPolicyInstanceError::ConflictingTypes({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflicting_types::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_conflicting_types_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateTrafficPolicyInstanceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidInput" => crate::error::UpdateTrafficPolicyInstanceError::InvalidInput({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_input::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_invalid_input_xml_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateTrafficPolicyInstanceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NoSuchTrafficPolicy" => {
            crate::error::UpdateTrafficPolicyInstanceError::NoSuchTrafficPolicy({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_such_traffic_policy::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_traffic_policy_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateTrafficPolicyInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoSuchTrafficPolicyInstance" => {
            crate::error::UpdateTrafficPolicyInstanceError::NoSuchTrafficPolicyInstance({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::no_such_traffic_policy_instance::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_no_such_traffic_policy_instance_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateTrafficPolicyInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PriorRequestNotComplete" => {
            crate::error::UpdateTrafficPolicyInstanceError::PriorRequestNotComplete({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::prior_request_not_complete::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_prior_request_not_complete_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateTrafficPolicyInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateTrafficPolicyInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_traffic_policy_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateTrafficPolicyInstanceOutput,
    crate::error::UpdateTrafficPolicyInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_traffic_policy_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_update_traffic_policy_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateTrafficPolicyInstanceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}
