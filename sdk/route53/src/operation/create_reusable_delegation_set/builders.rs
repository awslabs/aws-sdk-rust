// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_reusable_delegation_set::_create_reusable_delegation_set_output::CreateReusableDelegationSetOutputBuilder;

pub use crate::operation::create_reusable_delegation_set::_create_reusable_delegation_set_input::CreateReusableDelegationSetInputBuilder;

impl crate::operation::create_reusable_delegation_set::builders::CreateReusableDelegationSetInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_reusable_delegation_set::CreateReusableDelegationSetOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_reusable_delegation_set::CreateReusableDelegationSetError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_reusable_delegation_set();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateReusableDelegationSet`.
///
/// <p>Creates a delegation set (a group of four name servers) that can be reused by multiple hosted zones that were created by the same Amazon Web Services account.</p>
/// <p>You can also create a reusable delegation set that uses the four name servers that are associated with an existing hosted zone. Specify the hosted zone ID in the <code>CreateReusableDelegationSet</code> request.</p><note>
/// <p>You can't associate a reusable delegation set with a private hosted zone.</p>
/// </note>
/// <p>For information about using a reusable delegation set to configure white label name servers, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/white-label-name-servers.html">Configuring White Label Name Servers</a>.</p>
/// <p>The process for migrating existing hosted zones to use a reusable delegation set is comparable to the process for configuring white label name servers. You need to perform the following steps:</p>
/// <ol>
/// <li>
/// <p>Create a reusable delegation set.</p></li>
/// <li>
/// <p>Recreate hosted zones, and reduce the TTL to 60 seconds or less.</p></li>
/// <li>
/// <p>Recreate resource record sets in the new hosted zones.</p></li>
/// <li>
/// <p>Change the registrar's name servers to use the name servers for the new hosted zones.</p></li>
/// <li>
/// <p>Monitor traffic for the website or application.</p></li>
/// <li>
/// <p>Change TTLs back to their original values.</p></li>
/// </ol>
/// <p>If you want to migrate existing hosted zones to use a reusable delegation set, the existing hosted zones can't use any of the name servers that are assigned to the reusable delegation set. If one or more hosted zones do use one or more name servers that are assigned to the reusable delegation set, you can do one of the following:</p>
/// <ul>
/// <li>
/// <p>For small numbers of hosted zones—up to a few hundred—it's relatively easy to create reusable delegation sets until you get one that has four name servers that don't overlap with any of the name servers in your hosted zones.</p></li>
/// <li>
/// <p>For larger numbers of hosted zones, the easiest solution is to use more than one reusable delegation set.</p></li>
/// <li>
/// <p>For larger numbers of hosted zones, you can also migrate hosted zones that have overlapping name servers to hosted zones that don't have overlapping name servers, then migrate the hosted zones again to use the reusable delegation set.</p></li>
/// </ul>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateReusableDelegationSetFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_reusable_delegation_set::builders::CreateReusableDelegationSetInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_reusable_delegation_set::CreateReusableDelegationSetOutput,
        crate::operation::create_reusable_delegation_set::CreateReusableDelegationSetError,
    > for CreateReusableDelegationSetFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_reusable_delegation_set::CreateReusableDelegationSetOutput,
            crate::operation::create_reusable_delegation_set::CreateReusableDelegationSetError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateReusableDelegationSetFluentBuilder {
    /// Creates a new `CreateReusableDelegationSet`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateReusableDelegationSet as a reference.
    pub fn as_input(&self) -> &crate::operation::create_reusable_delegation_set::builders::CreateReusableDelegationSetInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_reusable_delegation_set::CreateReusableDelegationSetOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_reusable_delegation_set::CreateReusableDelegationSetError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_reusable_delegation_set::CreateReusableDelegationSet::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_reusable_delegation_set::CreateReusableDelegationSet::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_reusable_delegation_set::CreateReusableDelegationSetOutput,
        crate::operation::create_reusable_delegation_set::CreateReusableDelegationSetError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>A unique string that identifies the request, and that allows you to retry failed <code>CreateReusableDelegationSet</code> requests without the risk of executing the operation twice. You must use a unique <code>CallerReference</code> string every time you submit a <code>CreateReusableDelegationSet</code> request. <code>CallerReference</code> can be any unique string, for example a date/time stamp.</p>
    pub fn caller_reference(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.caller_reference(input.into());
        self
    }
    /// <p>A unique string that identifies the request, and that allows you to retry failed <code>CreateReusableDelegationSet</code> requests without the risk of executing the operation twice. You must use a unique <code>CallerReference</code> string every time you submit a <code>CreateReusableDelegationSet</code> request. <code>CallerReference</code> can be any unique string, for example a date/time stamp.</p>
    pub fn set_caller_reference(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_caller_reference(input);
        self
    }
    /// <p>A unique string that identifies the request, and that allows you to retry failed <code>CreateReusableDelegationSet</code> requests without the risk of executing the operation twice. You must use a unique <code>CallerReference</code> string every time you submit a <code>CreateReusableDelegationSet</code> request. <code>CallerReference</code> can be any unique string, for example a date/time stamp.</p>
    pub fn get_caller_reference(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_caller_reference()
    }
    /// <p>If you want to mark the delegation set for an existing hosted zone as reusable, the ID for that hosted zone.</p>
    pub fn hosted_zone_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.hosted_zone_id(input.into());
        self
    }
    /// <p>If you want to mark the delegation set for an existing hosted zone as reusable, the ID for that hosted zone.</p>
    pub fn set_hosted_zone_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_hosted_zone_id(input);
        self
    }
    /// <p>If you want to mark the delegation set for an existing hosted zone as reusable, the ID for that hosted zone.</p>
    pub fn get_hosted_zone_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_hosted_zone_id()
    }
}
