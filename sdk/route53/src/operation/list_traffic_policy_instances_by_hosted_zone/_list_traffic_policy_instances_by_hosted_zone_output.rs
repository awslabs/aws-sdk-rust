// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A complex type that contains the response information for the request.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ListTrafficPolicyInstancesByHostedZoneOutput {
    /// <p>A list that contains one <code>TrafficPolicyInstance</code> element for each traffic policy instance that matches the elements in the request.</p>
    pub traffic_policy_instances: ::std::vec::Vec<crate::types::TrafficPolicyInstance>,
    /// <p>If <code>IsTruncated</code> is <code>true</code>, <code>TrafficPolicyInstanceNameMarker</code> is the name of the first traffic policy instance in the next group of traffic policy instances.</p>
    pub traffic_policy_instance_name_marker: ::std::option::Option<::std::string::String>,
    /// <p>If <code>IsTruncated</code> is true, <code>TrafficPolicyInstanceTypeMarker</code> is the DNS type of the resource record sets that are associated with the first traffic policy instance in the next group of traffic policy instances.</p>
    pub traffic_policy_instance_type_marker: ::std::option::Option<crate::types::RrType>,
    /// <p>A flag that indicates whether there are more traffic policy instances to be listed. If the response was truncated, you can get the next group of traffic policy instances by submitting another <code>ListTrafficPolicyInstancesByHostedZone</code> request and specifying the values of <code>HostedZoneIdMarker</code>, <code>TrafficPolicyInstanceNameMarker</code>, and <code>TrafficPolicyInstanceTypeMarker</code> in the corresponding request parameters.</p>
    pub is_truncated: bool,
    /// <p>The value that you specified for the <code>MaxItems</code> parameter in the <code>ListTrafficPolicyInstancesByHostedZone</code> request that produced the current response.</p>
    pub max_items: i32,
    _request_id: Option<String>,
}
impl ListTrafficPolicyInstancesByHostedZoneOutput {
    /// <p>A list that contains one <code>TrafficPolicyInstance</code> element for each traffic policy instance that matches the elements in the request.</p>
    pub fn traffic_policy_instances(&self) -> &[crate::types::TrafficPolicyInstance] {
        use std::ops::Deref;
        self.traffic_policy_instances.deref()
    }
    /// <p>If <code>IsTruncated</code> is <code>true</code>, <code>TrafficPolicyInstanceNameMarker</code> is the name of the first traffic policy instance in the next group of traffic policy instances.</p>
    pub fn traffic_policy_instance_name_marker(&self) -> ::std::option::Option<&str> {
        self.traffic_policy_instance_name_marker.as_deref()
    }
    /// <p>If <code>IsTruncated</code> is true, <code>TrafficPolicyInstanceTypeMarker</code> is the DNS type of the resource record sets that are associated with the first traffic policy instance in the next group of traffic policy instances.</p>
    pub fn traffic_policy_instance_type_marker(&self) -> ::std::option::Option<&crate::types::RrType> {
        self.traffic_policy_instance_type_marker.as_ref()
    }
    /// <p>A flag that indicates whether there are more traffic policy instances to be listed. If the response was truncated, you can get the next group of traffic policy instances by submitting another <code>ListTrafficPolicyInstancesByHostedZone</code> request and specifying the values of <code>HostedZoneIdMarker</code>, <code>TrafficPolicyInstanceNameMarker</code>, and <code>TrafficPolicyInstanceTypeMarker</code> in the corresponding request parameters.</p>
    pub fn is_truncated(&self) -> bool {
        self.is_truncated
    }
    /// <p>The value that you specified for the <code>MaxItems</code> parameter in the <code>ListTrafficPolicyInstancesByHostedZone</code> request that produced the current response.</p>
    pub fn max_items(&self) -> i32 {
        self.max_items
    }
}
impl ::aws_types::request_id::RequestId for ListTrafficPolicyInstancesByHostedZoneOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl ListTrafficPolicyInstancesByHostedZoneOutput {
    /// Creates a new builder-style object to manufacture [`ListTrafficPolicyInstancesByHostedZoneOutput`](crate::operation::list_traffic_policy_instances_by_hosted_zone::ListTrafficPolicyInstancesByHostedZoneOutput).
    pub fn builder() -> crate::operation::list_traffic_policy_instances_by_hosted_zone::builders::ListTrafficPolicyInstancesByHostedZoneOutputBuilder
    {
        crate::operation::list_traffic_policy_instances_by_hosted_zone::builders::ListTrafficPolicyInstancesByHostedZoneOutputBuilder::default()
    }
}

/// A builder for [`ListTrafficPolicyInstancesByHostedZoneOutput`](crate::operation::list_traffic_policy_instances_by_hosted_zone::ListTrafficPolicyInstancesByHostedZoneOutput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ListTrafficPolicyInstancesByHostedZoneOutputBuilder {
    pub(crate) traffic_policy_instances: ::std::option::Option<::std::vec::Vec<crate::types::TrafficPolicyInstance>>,
    pub(crate) traffic_policy_instance_name_marker: ::std::option::Option<::std::string::String>,
    pub(crate) traffic_policy_instance_type_marker: ::std::option::Option<crate::types::RrType>,
    pub(crate) is_truncated: ::std::option::Option<bool>,
    pub(crate) max_items: ::std::option::Option<i32>,
    _request_id: Option<String>,
}
impl ListTrafficPolicyInstancesByHostedZoneOutputBuilder {
    /// Appends an item to `traffic_policy_instances`.
    ///
    /// To override the contents of this collection use [`set_traffic_policy_instances`](Self::set_traffic_policy_instances).
    ///
    /// <p>A list that contains one <code>TrafficPolicyInstance</code> element for each traffic policy instance that matches the elements in the request.</p>
    pub fn traffic_policy_instances(mut self, input: crate::types::TrafficPolicyInstance) -> Self {
        let mut v = self.traffic_policy_instances.unwrap_or_default();
        v.push(input);
        self.traffic_policy_instances = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list that contains one <code>TrafficPolicyInstance</code> element for each traffic policy instance that matches the elements in the request.</p>
    pub fn set_traffic_policy_instances(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::TrafficPolicyInstance>>) -> Self {
        self.traffic_policy_instances = input;
        self
    }
    /// <p>A list that contains one <code>TrafficPolicyInstance</code> element for each traffic policy instance that matches the elements in the request.</p>
    pub fn get_traffic_policy_instances(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::TrafficPolicyInstance>> {
        &self.traffic_policy_instances
    }
    /// <p>If <code>IsTruncated</code> is <code>true</code>, <code>TrafficPolicyInstanceNameMarker</code> is the name of the first traffic policy instance in the next group of traffic policy instances.</p>
    pub fn traffic_policy_instance_name_marker(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.traffic_policy_instance_name_marker = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>If <code>IsTruncated</code> is <code>true</code>, <code>TrafficPolicyInstanceNameMarker</code> is the name of the first traffic policy instance in the next group of traffic policy instances.</p>
    pub fn set_traffic_policy_instance_name_marker(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.traffic_policy_instance_name_marker = input;
        self
    }
    /// <p>If <code>IsTruncated</code> is <code>true</code>, <code>TrafficPolicyInstanceNameMarker</code> is the name of the first traffic policy instance in the next group of traffic policy instances.</p>
    pub fn get_traffic_policy_instance_name_marker(&self) -> &::std::option::Option<::std::string::String> {
        &self.traffic_policy_instance_name_marker
    }
    /// <p>If <code>IsTruncated</code> is true, <code>TrafficPolicyInstanceTypeMarker</code> is the DNS type of the resource record sets that are associated with the first traffic policy instance in the next group of traffic policy instances.</p>
    pub fn traffic_policy_instance_type_marker(mut self, input: crate::types::RrType) -> Self {
        self.traffic_policy_instance_type_marker = ::std::option::Option::Some(input);
        self
    }
    /// <p>If <code>IsTruncated</code> is true, <code>TrafficPolicyInstanceTypeMarker</code> is the DNS type of the resource record sets that are associated with the first traffic policy instance in the next group of traffic policy instances.</p>
    pub fn set_traffic_policy_instance_type_marker(mut self, input: ::std::option::Option<crate::types::RrType>) -> Self {
        self.traffic_policy_instance_type_marker = input;
        self
    }
    /// <p>If <code>IsTruncated</code> is true, <code>TrafficPolicyInstanceTypeMarker</code> is the DNS type of the resource record sets that are associated with the first traffic policy instance in the next group of traffic policy instances.</p>
    pub fn get_traffic_policy_instance_type_marker(&self) -> &::std::option::Option<crate::types::RrType> {
        &self.traffic_policy_instance_type_marker
    }
    /// <p>A flag that indicates whether there are more traffic policy instances to be listed. If the response was truncated, you can get the next group of traffic policy instances by submitting another <code>ListTrafficPolicyInstancesByHostedZone</code> request and specifying the values of <code>HostedZoneIdMarker</code>, <code>TrafficPolicyInstanceNameMarker</code>, and <code>TrafficPolicyInstanceTypeMarker</code> in the corresponding request parameters.</p>
    /// This field is required.
    pub fn is_truncated(mut self, input: bool) -> Self {
        self.is_truncated = ::std::option::Option::Some(input);
        self
    }
    /// <p>A flag that indicates whether there are more traffic policy instances to be listed. If the response was truncated, you can get the next group of traffic policy instances by submitting another <code>ListTrafficPolicyInstancesByHostedZone</code> request and specifying the values of <code>HostedZoneIdMarker</code>, <code>TrafficPolicyInstanceNameMarker</code>, and <code>TrafficPolicyInstanceTypeMarker</code> in the corresponding request parameters.</p>
    pub fn set_is_truncated(mut self, input: ::std::option::Option<bool>) -> Self {
        self.is_truncated = input;
        self
    }
    /// <p>A flag that indicates whether there are more traffic policy instances to be listed. If the response was truncated, you can get the next group of traffic policy instances by submitting another <code>ListTrafficPolicyInstancesByHostedZone</code> request and specifying the values of <code>HostedZoneIdMarker</code>, <code>TrafficPolicyInstanceNameMarker</code>, and <code>TrafficPolicyInstanceTypeMarker</code> in the corresponding request parameters.</p>
    pub fn get_is_truncated(&self) -> &::std::option::Option<bool> {
        &self.is_truncated
    }
    /// <p>The value that you specified for the <code>MaxItems</code> parameter in the <code>ListTrafficPolicyInstancesByHostedZone</code> request that produced the current response.</p>
    /// This field is required.
    pub fn max_items(mut self, input: i32) -> Self {
        self.max_items = ::std::option::Option::Some(input);
        self
    }
    /// <p>The value that you specified for the <code>MaxItems</code> parameter in the <code>ListTrafficPolicyInstancesByHostedZone</code> request that produced the current response.</p>
    pub fn set_max_items(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_items = input;
        self
    }
    /// <p>The value that you specified for the <code>MaxItems</code> parameter in the <code>ListTrafficPolicyInstancesByHostedZone</code> request that produced the current response.</p>
    pub fn get_max_items(&self) -> &::std::option::Option<i32> {
        &self.max_items
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`ListTrafficPolicyInstancesByHostedZoneOutput`](crate::operation::list_traffic_policy_instances_by_hosted_zone::ListTrafficPolicyInstancesByHostedZoneOutput).
    /// This method will fail if any of the following fields are not set:
    /// - [`traffic_policy_instances`](crate::operation::list_traffic_policy_instances_by_hosted_zone::builders::ListTrafficPolicyInstancesByHostedZoneOutputBuilder::traffic_policy_instances)
    /// - [`max_items`](crate::operation::list_traffic_policy_instances_by_hosted_zone::builders::ListTrafficPolicyInstancesByHostedZoneOutputBuilder::max_items)
    pub fn build(
        self,
    ) -> ::std::result::Result<
        crate::operation::list_traffic_policy_instances_by_hosted_zone::ListTrafficPolicyInstancesByHostedZoneOutput,
        ::aws_smithy_types::error::operation::BuildError,
    > {
        ::std::result::Result::Ok(
            crate::operation::list_traffic_policy_instances_by_hosted_zone::ListTrafficPolicyInstancesByHostedZoneOutput {
                traffic_policy_instances: self.traffic_policy_instances.ok_or_else(|| {
                    ::aws_smithy_types::error::operation::BuildError::missing_field(
                        "traffic_policy_instances",
                        "traffic_policy_instances was not specified but it is required when building ListTrafficPolicyInstancesByHostedZoneOutput",
                    )
                })?,
                traffic_policy_instance_name_marker: self.traffic_policy_instance_name_marker,
                traffic_policy_instance_type_marker: self.traffic_policy_instance_type_marker,
                is_truncated: self.is_truncated.unwrap_or_default(),
                max_items: self.max_items.ok_or_else(|| {
                    ::aws_smithy_types::error::operation::BuildError::missing_field(
                        "max_items",
                        "max_items was not specified but it is required when building ListTrafficPolicyInstancesByHostedZoneOutput",
                    )
                })?,
                _request_id: self._request_id,
            },
        )
    }
}
