// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

impl CreateHostedZoneInput {
    /// Consumes the builder and constructs an Operation<[`CreateHostedZone`](crate::operation::create_hosted_zone::CreateHostedZone)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::create_hosted_zone::CreateHostedZone,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::operation::create_hosted_zone::CreateHostedZoneInput,
                output: &mut String,
            ) -> std::result::Result<(), aws_smithy_http::operation::error::BuildError>
            {
                write!(output, "/2013-04-01/hostedzone").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::operation::create_hosted_zone::CreateHostedZoneInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/xml",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_hosted_zone::ser_create_hosted_zone_op_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::meta::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::create_hosted_zone::CreateHostedZone::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateHostedZone",
            "route53",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}
/// `ParseStrictResponse` impl for `CreateHostedZone`.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
#[non_exhaustive]
#[doc(hidden)]
pub struct CreateHostedZone;
impl CreateHostedZone {
    #[doc(hidden)]
    pub fn new() -> Self {
        Self
    }
}
impl aws_smithy_http::response::ParseStrictResponse for CreateHostedZone {
    type Output = std::result::Result<
        crate::operation::create_hosted_zone::CreateHostedZoneOutput,
        crate::operation::create_hosted_zone::CreateHostedZoneError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::protocol_serde::shape_create_hosted_zone::de_create_hosted_zone_http_error(
                response,
            )
        } else {
            crate::protocol_serde::shape_create_hosted_zone::de_create_hosted_zone_http_response(
                response,
            )
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateHostedZoneErrorKind = CreateHostedZoneError;
/// Error type for the `CreateHostedZoneError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateHostedZoneError {
    /// <p>The cause of this error depends on the operation that you're performing:</p>
    /// <ul>
    /// <li> <p> <b>Create a public hosted zone:</b> Two hosted zones that have the same name or that have a parent/child relationship (example.com and test.example.com) can't have any common name servers. You tried to create a hosted zone that has the same name as an existing hosted zone or that's the parent or child of an existing hosted zone, and you specified a delegation set that shares one or more name servers with the existing hosted zone. For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateReusableDelegationSet.html">CreateReusableDelegationSet</a>.</p> </li>
    /// <li> <p> <b>Create a private hosted zone:</b> A hosted zone with the specified name already exists and is already associated with the Amazon VPC that you specified.</p> </li>
    /// <li> <p> <b>Associate VPCs with a private hosted zone:</b> The VPC that you specified is already associated with another hosted zone that has the same name.</p> </li>
    /// </ul>
    ConflictingDomainExists(crate::types::error::ConflictingDomainExists),
    /// <p>You can create a hosted zone that has the same name as an existing hosted zone (example.com is common), but there is a limit to the number of hosted zones that have the same name. If you get this error, Amazon Route 53 has reached that limit. If you own the domain name and Route 53 generates this error, contact Customer Support.</p>
    DelegationSetNotAvailable(crate::types::error::DelegationSetNotAvailable),
    /// <p>A reusable delegation set with the specified ID does not exist.</p>
    DelegationSetNotReusable(crate::types::error::DelegationSetNotReusable),
    /// <p>The hosted zone you're trying to create already exists. Amazon Route 53 returns this error when a hosted zone has already been created with the specified <code>CallerReference</code>.</p>
    HostedZoneAlreadyExists(crate::types::error::HostedZoneAlreadyExists),
    /// <p>The specified domain name is not valid.</p>
    InvalidDomainName(crate::types::error::InvalidDomainName),
    /// <p>The input is not valid.</p>
    InvalidInput(crate::types::error::InvalidInput),
    /// <p>The VPC ID that you specified either isn't a valid ID or the current account is not authorized to access this VPC.</p>
    InvalidVpcId(crate::types::error::InvalidVpcId),
    /// <p>A reusable delegation set with the specified ID does not exist.</p>
    NoSuchDelegationSet(crate::types::error::NoSuchDelegationSet),
    /// <p>This operation can't be completed either because the current account has reached the limit on the number of hosted zones or because you've reached the limit on the number of hosted zones that can be associated with a reusable delegation set.</p>
    /// <p>For information about default limits, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a> in the <i>Amazon Route 53 Developer Guide</i>.</p>
    /// <p>To get the current limit on hosted zones that can be created by an account, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetAccountLimit.html">GetAccountLimit</a>.</p>
    /// <p>To get the current limit on hosted zones that can be associated with a reusable delegation set, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetReusableDelegationSetLimit.html">GetReusableDelegationSetLimit</a>.</p>
    /// <p>To request a higher limit, <a href="http://aws.amazon.com/route53-request">create a case</a> with the Amazon Web Services Support Center.</p>
    TooManyHostedZones(crate::types::error::TooManyHostedZones),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateHostedZoneError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: std::option::Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateHostedZoneError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ConflictingDomainExists(_inner) => _inner.fmt(f),
            Self::DelegationSetNotAvailable(_inner) => _inner.fmt(f),
            Self::DelegationSetNotReusable(_inner) => _inner.fmt(f),
            Self::HostedZoneAlreadyExists(_inner) => _inner.fmt(f),
            Self::InvalidDomainName(_inner) => _inner.fmt(f),
            Self::InvalidInput(_inner) => _inner.fmt(f),
            Self::InvalidVpcId(_inner) => _inner.fmt(f),
            Self::NoSuchDelegationSet(_inner) => _inner.fmt(f),
            Self::TooManyHostedZones(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateHostedZoneError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ConflictingDomainExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DelegationSetNotAvailable(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DelegationSetNotReusable(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::HostedZoneAlreadyExists(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDomainName(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidInput(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidVpcId(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoSuchDelegationSet(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyHostedZones(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId
    for crate::operation::create_hosted_zone::CreateHostedZoneError
{
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateHostedZoneError {
    fn code(&self) -> std::option::Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> std::option::Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateHostedZoneError {
    /// Creates the `CreateHostedZoneError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateHostedZoneError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ConflictingDomainExists(e) => e.meta(),
            Self::DelegationSetNotAvailable(e) => e.meta(),
            Self::DelegationSetNotReusable(e) => e.meta(),
            Self::HostedZoneAlreadyExists(e) => e.meta(),
            Self::InvalidDomainName(e) => e.meta(),
            Self::InvalidInput(e) => e.meta(),
            Self::InvalidVpcId(e) => e.meta(),
            Self::NoSuchDelegationSet(e) => e.meta(),
            Self::TooManyHostedZones(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateHostedZoneError::ConflictingDomainExists`.
    pub fn is_conflicting_domain_exists(&self) -> bool {
        matches!(self, Self::ConflictingDomainExists(_))
    }
    /// Returns `true` if the error kind is `CreateHostedZoneError::DelegationSetNotAvailable`.
    pub fn is_delegation_set_not_available(&self) -> bool {
        matches!(self, Self::DelegationSetNotAvailable(_))
    }
    /// Returns `true` if the error kind is `CreateHostedZoneError::DelegationSetNotReusable`.
    pub fn is_delegation_set_not_reusable(&self) -> bool {
        matches!(self, Self::DelegationSetNotReusable(_))
    }
    /// Returns `true` if the error kind is `CreateHostedZoneError::HostedZoneAlreadyExists`.
    pub fn is_hosted_zone_already_exists(&self) -> bool {
        matches!(self, Self::HostedZoneAlreadyExists(_))
    }
    /// Returns `true` if the error kind is `CreateHostedZoneError::InvalidDomainName`.
    pub fn is_invalid_domain_name(&self) -> bool {
        matches!(self, Self::InvalidDomainName(_))
    }
    /// Returns `true` if the error kind is `CreateHostedZoneError::InvalidInput`.
    pub fn is_invalid_input(&self) -> bool {
        matches!(self, Self::InvalidInput(_))
    }
    /// Returns `true` if the error kind is `CreateHostedZoneError::InvalidVpcId`.
    pub fn is_invalid_vpc_id(&self) -> bool {
        matches!(self, Self::InvalidVpcId(_))
    }
    /// Returns `true` if the error kind is `CreateHostedZoneError::NoSuchDelegationSet`.
    pub fn is_no_such_delegation_set(&self) -> bool {
        matches!(self, Self::NoSuchDelegationSet(_))
    }
    /// Returns `true` if the error kind is `CreateHostedZoneError::TooManyHostedZones`.
    pub fn is_too_many_hosted_zones(&self) -> bool {
        matches!(self, Self::TooManyHostedZones(_))
    }
}
impl std::error::Error for CreateHostedZoneError {
    fn source(&self) -> std::option::Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ConflictingDomainExists(_inner) => Some(_inner),
            Self::DelegationSetNotAvailable(_inner) => Some(_inner),
            Self::DelegationSetNotReusable(_inner) => Some(_inner),
            Self::HostedZoneAlreadyExists(_inner) => Some(_inner),
            Self::InvalidDomainName(_inner) => Some(_inner),
            Self::InvalidInput(_inner) => Some(_inner),
            Self::InvalidVpcId(_inner) => Some(_inner),
            Self::NoSuchDelegationSet(_inner) => Some(_inner),
            Self::TooManyHostedZones(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

pub use crate::operation::create_hosted_zone::_create_hosted_zone_output::CreateHostedZoneOutput;

pub use crate::operation::create_hosted_zone::_create_hosted_zone_input::CreateHostedZoneInput;

mod _create_hosted_zone_input;

mod _create_hosted_zone_output;

/// Builders
pub mod builders;
