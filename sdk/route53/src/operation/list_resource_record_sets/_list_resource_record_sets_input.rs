// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A request for the resource record sets that are associated with a specified hosted zone.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListResourceRecordSetsInput {
    /// <p>The ID of the hosted zone that contains the resource record sets that you want to list.</p>
    #[doc(hidden)]
    pub hosted_zone_id: std::option::Option<std::string::String>,
    /// <p>The first name in the lexicographic ordering of resource record sets that you want to list. If the specified record name doesn't exist, the results begin with the first resource record set that has a name greater than the value of <code>name</code>.</p>
    #[doc(hidden)]
    pub start_record_name: std::option::Option<std::string::String>,
    /// <p>The type of resource record set to begin the record listing from.</p>
    /// <p>Valid values for basic resource record sets: <code>A</code> | <code>AAAA</code> | <code>CAA</code> | <code>CNAME</code> | <code>MX</code> | <code>NAPTR</code> | <code>NS</code> | <code>PTR</code> | <code>SOA</code> | <code>SPF</code> | <code>SRV</code> | <code>TXT</code> </p>
    /// <p>Values for weighted, latency, geolocation, and failover resource record sets: <code>A</code> | <code>AAAA</code> | <code>CAA</code> | <code>CNAME</code> | <code>MX</code> | <code>NAPTR</code> | <code>PTR</code> | <code>SPF</code> | <code>SRV</code> | <code>TXT</code> </p>
    /// <p>Values for alias resource record sets: </p>
    /// <ul>
    /// <li> <p> <b>API Gateway custom regional API or edge-optimized API</b>: A</p> </li>
    /// <li> <p> <b>CloudFront distribution</b>: A or AAAA</p> </li>
    /// <li> <p> <b>Elastic Beanstalk environment that has a regionalized subdomain</b>: A</p> </li>
    /// <li> <p> <b>Elastic Load Balancing load balancer</b>: A | AAAA</p> </li>
    /// <li> <p> <b>S3 bucket</b>: A</p> </li>
    /// <li> <p> <b>VPC interface VPC endpoint</b>: A</p> </li>
    /// <li> <p> <b>Another resource record set in this hosted zone:</b> The type of the resource record set that the alias references.</p> </li>
    /// </ul>
    /// <p>Constraint: Specifying <code>type</code> without specifying <code>name</code> returns an <code>InvalidInput</code> error.</p>
    #[doc(hidden)]
    pub start_record_type: std::option::Option<crate::types::RrType>,
    /// <p> <i>Resource record sets that have a routing policy other than simple:</i> If results were truncated for a given DNS name and type, specify the value of <code>NextRecordIdentifier</code> from the previous response to get the next resource record set that has the current DNS name and type.</p>
    #[doc(hidden)]
    pub start_record_identifier: std::option::Option<std::string::String>,
    /// <p>(Optional) The maximum number of resource records sets to include in the response body for this request. If the response includes more than <code>maxitems</code> resource record sets, the value of the <code>IsTruncated</code> element in the response is <code>true</code>, and the values of the <code>NextRecordName</code> and <code>NextRecordType</code> elements in the response identify the first resource record set in the next group of <code>maxitems</code> resource record sets.</p>
    #[doc(hidden)]
    pub max_items: std::option::Option<i32>,
}
impl ListResourceRecordSetsInput {
    /// <p>The ID of the hosted zone that contains the resource record sets that you want to list.</p>
    pub fn hosted_zone_id(&self) -> std::option::Option<&str> {
        self.hosted_zone_id.as_deref()
    }
    /// <p>The first name in the lexicographic ordering of resource record sets that you want to list. If the specified record name doesn't exist, the results begin with the first resource record set that has a name greater than the value of <code>name</code>.</p>
    pub fn start_record_name(&self) -> std::option::Option<&str> {
        self.start_record_name.as_deref()
    }
    /// <p>The type of resource record set to begin the record listing from.</p>
    /// <p>Valid values for basic resource record sets: <code>A</code> | <code>AAAA</code> | <code>CAA</code> | <code>CNAME</code> | <code>MX</code> | <code>NAPTR</code> | <code>NS</code> | <code>PTR</code> | <code>SOA</code> | <code>SPF</code> | <code>SRV</code> | <code>TXT</code> </p>
    /// <p>Values for weighted, latency, geolocation, and failover resource record sets: <code>A</code> | <code>AAAA</code> | <code>CAA</code> | <code>CNAME</code> | <code>MX</code> | <code>NAPTR</code> | <code>PTR</code> | <code>SPF</code> | <code>SRV</code> | <code>TXT</code> </p>
    /// <p>Values for alias resource record sets: </p>
    /// <ul>
    /// <li> <p> <b>API Gateway custom regional API or edge-optimized API</b>: A</p> </li>
    /// <li> <p> <b>CloudFront distribution</b>: A or AAAA</p> </li>
    /// <li> <p> <b>Elastic Beanstalk environment that has a regionalized subdomain</b>: A</p> </li>
    /// <li> <p> <b>Elastic Load Balancing load balancer</b>: A | AAAA</p> </li>
    /// <li> <p> <b>S3 bucket</b>: A</p> </li>
    /// <li> <p> <b>VPC interface VPC endpoint</b>: A</p> </li>
    /// <li> <p> <b>Another resource record set in this hosted zone:</b> The type of the resource record set that the alias references.</p> </li>
    /// </ul>
    /// <p>Constraint: Specifying <code>type</code> without specifying <code>name</code> returns an <code>InvalidInput</code> error.</p>
    pub fn start_record_type(&self) -> std::option::Option<&crate::types::RrType> {
        self.start_record_type.as_ref()
    }
    /// <p> <i>Resource record sets that have a routing policy other than simple:</i> If results were truncated for a given DNS name and type, specify the value of <code>NextRecordIdentifier</code> from the previous response to get the next resource record set that has the current DNS name and type.</p>
    pub fn start_record_identifier(&self) -> std::option::Option<&str> {
        self.start_record_identifier.as_deref()
    }
    /// <p>(Optional) The maximum number of resource records sets to include in the response body for this request. If the response includes more than <code>maxitems</code> resource record sets, the value of the <code>IsTruncated</code> element in the response is <code>true</code>, and the values of the <code>NextRecordName</code> and <code>NextRecordType</code> elements in the response identify the first resource record set in the next group of <code>maxitems</code> resource record sets.</p>
    pub fn max_items(&self) -> std::option::Option<i32> {
        self.max_items
    }
}
impl ListResourceRecordSetsInput {
    /// Creates a new builder-style object to manufacture [`ListResourceRecordSetsInput`](crate::operation::list_resource_record_sets::ListResourceRecordSetsInput).
    pub fn builder(
    ) -> crate::operation::list_resource_record_sets::builders::ListResourceRecordSetsInputBuilder
    {
        crate::operation::list_resource_record_sets::builders::ListResourceRecordSetsInputBuilder::default()
    }
}

/// A builder for [`ListResourceRecordSetsInput`](crate::operation::list_resource_record_sets::ListResourceRecordSetsInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ListResourceRecordSetsInputBuilder {
    pub(crate) hosted_zone_id: std::option::Option<std::string::String>,
    pub(crate) start_record_name: std::option::Option<std::string::String>,
    pub(crate) start_record_type: std::option::Option<crate::types::RrType>,
    pub(crate) start_record_identifier: std::option::Option<std::string::String>,
    pub(crate) max_items: std::option::Option<i32>,
}
impl ListResourceRecordSetsInputBuilder {
    /// <p>The ID of the hosted zone that contains the resource record sets that you want to list.</p>
    pub fn hosted_zone_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.hosted_zone_id = Some(input.into());
        self
    }
    /// <p>The ID of the hosted zone that contains the resource record sets that you want to list.</p>
    pub fn set_hosted_zone_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.hosted_zone_id = input;
        self
    }
    /// <p>The first name in the lexicographic ordering of resource record sets that you want to list. If the specified record name doesn't exist, the results begin with the first resource record set that has a name greater than the value of <code>name</code>.</p>
    pub fn start_record_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.start_record_name = Some(input.into());
        self
    }
    /// <p>The first name in the lexicographic ordering of resource record sets that you want to list. If the specified record name doesn't exist, the results begin with the first resource record set that has a name greater than the value of <code>name</code>.</p>
    pub fn set_start_record_name(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.start_record_name = input;
        self
    }
    /// <p>The type of resource record set to begin the record listing from.</p>
    /// <p>Valid values for basic resource record sets: <code>A</code> | <code>AAAA</code> | <code>CAA</code> | <code>CNAME</code> | <code>MX</code> | <code>NAPTR</code> | <code>NS</code> | <code>PTR</code> | <code>SOA</code> | <code>SPF</code> | <code>SRV</code> | <code>TXT</code> </p>
    /// <p>Values for weighted, latency, geolocation, and failover resource record sets: <code>A</code> | <code>AAAA</code> | <code>CAA</code> | <code>CNAME</code> | <code>MX</code> | <code>NAPTR</code> | <code>PTR</code> | <code>SPF</code> | <code>SRV</code> | <code>TXT</code> </p>
    /// <p>Values for alias resource record sets: </p>
    /// <ul>
    /// <li> <p> <b>API Gateway custom regional API or edge-optimized API</b>: A</p> </li>
    /// <li> <p> <b>CloudFront distribution</b>: A or AAAA</p> </li>
    /// <li> <p> <b>Elastic Beanstalk environment that has a regionalized subdomain</b>: A</p> </li>
    /// <li> <p> <b>Elastic Load Balancing load balancer</b>: A | AAAA</p> </li>
    /// <li> <p> <b>S3 bucket</b>: A</p> </li>
    /// <li> <p> <b>VPC interface VPC endpoint</b>: A</p> </li>
    /// <li> <p> <b>Another resource record set in this hosted zone:</b> The type of the resource record set that the alias references.</p> </li>
    /// </ul>
    /// <p>Constraint: Specifying <code>type</code> without specifying <code>name</code> returns an <code>InvalidInput</code> error.</p>
    pub fn start_record_type(mut self, input: crate::types::RrType) -> Self {
        self.start_record_type = Some(input);
        self
    }
    /// <p>The type of resource record set to begin the record listing from.</p>
    /// <p>Valid values for basic resource record sets: <code>A</code> | <code>AAAA</code> | <code>CAA</code> | <code>CNAME</code> | <code>MX</code> | <code>NAPTR</code> | <code>NS</code> | <code>PTR</code> | <code>SOA</code> | <code>SPF</code> | <code>SRV</code> | <code>TXT</code> </p>
    /// <p>Values for weighted, latency, geolocation, and failover resource record sets: <code>A</code> | <code>AAAA</code> | <code>CAA</code> | <code>CNAME</code> | <code>MX</code> | <code>NAPTR</code> | <code>PTR</code> | <code>SPF</code> | <code>SRV</code> | <code>TXT</code> </p>
    /// <p>Values for alias resource record sets: </p>
    /// <ul>
    /// <li> <p> <b>API Gateway custom regional API or edge-optimized API</b>: A</p> </li>
    /// <li> <p> <b>CloudFront distribution</b>: A or AAAA</p> </li>
    /// <li> <p> <b>Elastic Beanstalk environment that has a regionalized subdomain</b>: A</p> </li>
    /// <li> <p> <b>Elastic Load Balancing load balancer</b>: A | AAAA</p> </li>
    /// <li> <p> <b>S3 bucket</b>: A</p> </li>
    /// <li> <p> <b>VPC interface VPC endpoint</b>: A</p> </li>
    /// <li> <p> <b>Another resource record set in this hosted zone:</b> The type of the resource record set that the alias references.</p> </li>
    /// </ul>
    /// <p>Constraint: Specifying <code>type</code> without specifying <code>name</code> returns an <code>InvalidInput</code> error.</p>
    pub fn set_start_record_type(
        mut self,
        input: std::option::Option<crate::types::RrType>,
    ) -> Self {
        self.start_record_type = input;
        self
    }
    /// <p> <i>Resource record sets that have a routing policy other than simple:</i> If results were truncated for a given DNS name and type, specify the value of <code>NextRecordIdentifier</code> from the previous response to get the next resource record set that has the current DNS name and type.</p>
    pub fn start_record_identifier(mut self, input: impl Into<std::string::String>) -> Self {
        self.start_record_identifier = Some(input.into());
        self
    }
    /// <p> <i>Resource record sets that have a routing policy other than simple:</i> If results were truncated for a given DNS name and type, specify the value of <code>NextRecordIdentifier</code> from the previous response to get the next resource record set that has the current DNS name and type.</p>
    pub fn set_start_record_identifier(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.start_record_identifier = input;
        self
    }
    /// <p>(Optional) The maximum number of resource records sets to include in the response body for this request. If the response includes more than <code>maxitems</code> resource record sets, the value of the <code>IsTruncated</code> element in the response is <code>true</code>, and the values of the <code>NextRecordName</code> and <code>NextRecordType</code> elements in the response identify the first resource record set in the next group of <code>maxitems</code> resource record sets.</p>
    pub fn max_items(mut self, input: i32) -> Self {
        self.max_items = Some(input);
        self
    }
    /// <p>(Optional) The maximum number of resource records sets to include in the response body for this request. If the response includes more than <code>maxitems</code> resource record sets, the value of the <code>IsTruncated</code> element in the response is <code>true</code>, and the values of the <code>NextRecordName</code> and <code>NextRecordType</code> elements in the response identify the first resource record set in the next group of <code>maxitems</code> resource record sets.</p>
    pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
        self.max_items = input;
        self
    }
    /// Consumes the builder and constructs a [`ListResourceRecordSetsInput`](crate::operation::list_resource_record_sets::ListResourceRecordSetsInput).
    pub fn build(
        self,
    ) -> Result<
        crate::operation::list_resource_record_sets::ListResourceRecordSetsInput,
        aws_smithy_http::operation::error::BuildError,
    > {
        Ok(
            crate::operation::list_resource_record_sets::ListResourceRecordSetsInput {
                hosted_zone_id: self.hosted_zone_id,
                start_record_name: self.start_record_name,
                start_record_type: self.start_record_type,
                start_record_identifier: self.start_record_identifier,
                max_items: self.max_items,
            },
        )
    }
}
