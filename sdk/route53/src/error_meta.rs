// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>This CIDR block is already in use.</p>
    CidrBlockInUseException(crate::error::CidrBlockInUseException),
    /// <p>A CIDR collection with this name and a different caller reference already exists in this account.</p>
    CidrCollectionAlreadyExistsException(crate::error::CidrCollectionAlreadyExistsException),
    /// <p>This CIDR collection is in use, and isn't empty.</p>
    CidrCollectionInUseException(crate::error::CidrCollectionInUseException),
    /// <p>The CIDR collection version you provided, doesn't match the one in the <code>ListCidrCollections</code> operation.</p>
    CidrCollectionVersionMismatchException(crate::error::CidrCollectionVersionMismatchException),
    /// <p>Another user submitted a request to create, update, or delete the object at the same time that you did. Retry the request. </p>
    ConcurrentModification(crate::error::ConcurrentModification),
    /// <p>The cause of this error depends on the operation that you're performing:</p>
    /// <ul>
    /// <li> <p> <b>Create a public hosted zone:</b> Two hosted zones that have the same name or that have a parent/child relationship (example.com and test.example.com) can't have any common name servers. You tried to create a hosted zone that has the same name as an existing hosted zone or that's the parent or child of an existing hosted zone, and you specified a delegation set that shares one or more name servers with the existing hosted zone. For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateReusableDelegationSet.html">CreateReusableDelegationSet</a>.</p> </li>
    /// <li> <p> <b>Create a private hosted zone:</b> A hosted zone with the specified name already exists and is already associated with the Amazon VPC that you specified.</p> </li>
    /// <li> <p> <b>Associate VPCs with a private hosted zone:</b> The VPC that you specified is already associated with another hosted zone that has the same name.</p> </li>
    /// </ul>
    ConflictingDomainExists(crate::error::ConflictingDomainExists),
    /// <p>You tried to update a traffic policy instance by using a traffic policy version that has a different DNS type than the current type for the instance. You specified the type in the JSON document in the <code>CreateTrafficPolicy</code> or <code>CreateTrafficPolicyVersion</code>request. </p>
    ConflictingTypes(crate::error::ConflictingTypes),
    /// <p>The hosted zone doesn't have any DNSSEC resources.</p>
    DnssecNotFound(crate::error::DnssecNotFound),
    /// <p>A delegation set with the same owner and caller reference combination has already been created.</p>
    DelegationSetAlreadyCreated(crate::error::DelegationSetAlreadyCreated),
    /// <p>The specified delegation set has already been marked as reusable.</p>
    DelegationSetAlreadyReusable(crate::error::DelegationSetAlreadyReusable),
    /// <p>The specified delegation contains associated hosted zones which must be deleted before the reusable delegation set can be deleted.</p>
    DelegationSetInUse(crate::error::DelegationSetInUse),
    /// <p>You can create a hosted zone that has the same name as an existing hosted zone (example.com is common), but there is a limit to the number of hosted zones that have the same name. If you get this error, Amazon Route 53 has reached that limit. If you own the domain name and Route 53 generates this error, contact Customer Support.</p>
    DelegationSetNotAvailable(crate::error::DelegationSetNotAvailable),
    /// <p>A reusable delegation set with the specified ID does not exist.</p>
    DelegationSetNotReusable(crate::error::DelegationSetNotReusable),
    /// <p> The health check you're attempting to create already exists. Amazon Route 53 returns this error when you submit a request that has the following values:</p>
    /// <ul>
    /// <li> <p>The same value for <code>CallerReference</code> as an existing health check, and one or more values that differ from the existing health check that has the same caller reference.</p> </li>
    /// <li> <p>The same value for <code>CallerReference</code> as a health check that you created and later deleted, regardless of the other settings in the request.</p> </li>
    /// </ul>
    HealthCheckAlreadyExists(crate::error::HealthCheckAlreadyExists),
    /// <p>This error code is not in use.</p>
    #[deprecated]
    HealthCheckInUse(crate::error::HealthCheckInUse),
    /// <p>The value of <code>HealthCheckVersion</code> in the request doesn't match the value of <code>HealthCheckVersion</code> in the health check.</p>
    HealthCheckVersionMismatch(crate::error::HealthCheckVersionMismatch),
    /// <p>The hosted zone you're trying to create already exists. Amazon Route 53 returns this error when a hosted zone has already been created with the specified <code>CallerReference</code>.</p>
    HostedZoneAlreadyExists(crate::error::HostedZoneAlreadyExists),
    /// <p>The hosted zone contains resource records that are not SOA or NS records.</p>
    HostedZoneNotEmpty(crate::error::HostedZoneNotEmpty),
    /// <p>The specified HostedZone can't be found.</p>
    HostedZoneNotFound(crate::error::HostedZoneNotFound),
    /// <p>The specified hosted zone is a public hosted zone, not a private hosted zone.</p>
    HostedZoneNotPrivate(crate::error::HostedZoneNotPrivate),
    /// <p>The hosted zone nameservers don't match the parent nameservers. The hosted zone and parent must have the same nameservers.</p>
    HostedZonePartiallyDelegated(crate::error::HostedZonePartiallyDelegated),
    /// <p>The resource you're trying to access is unsupported on this Amazon Route 53 endpoint.</p>
    IncompatibleVersion(crate::error::IncompatibleVersion),
    /// <p>Amazon Route 53 doesn't have the permissions required to create log streams and send query logs to log streams. Possible causes include the following:</p>
    /// <ul>
    /// <li> <p>There is no resource policy that specifies the log group ARN in the value for <code>Resource</code>.</p> </li>
    /// <li> <p>The resource policy that includes the log group ARN in the value for <code>Resource</code> doesn't have the necessary permissions.</p> </li>
    /// <li> <p>The resource policy hasn't finished propagating yet.</p> </li>
    /// <li> <p>The Key management service (KMS) key you specified doesn’t exist or it can’t be used with the log group associated with query log. Update or provide a resource policy to grant permissions for the KMS key.</p> </li>
    /// <li> <p>The Key management service (KMS) key you specified is marked as disabled for the log group associated with query log. Update or provide a resource policy to grant permissions for the KMS key.</p> </li>
    /// </ul>
    InsufficientCloudWatchLogsResourcePolicy(
        crate::error::InsufficientCloudWatchLogsResourcePolicy,
    ),
    /// <p>Parameter name is not valid.</p>
    InvalidArgument(crate::error::InvalidArgument),
    /// <p>This exception contains a list of messages that might contain one or more error messages. Each error message indicates one error in the change batch.</p>
    InvalidChangeBatch(crate::error::InvalidChangeBatch),
    /// <p>The specified domain name is not valid.</p>
    InvalidDomainName(crate::error::InvalidDomainName),
    /// <p>The input is not valid.</p>
    InvalidInput(crate::error::InvalidInput),
    /// <p>The KeyManagementServiceArn that you specified isn't valid to use with DNSSEC signing.</p>
    InvalidKmsArn(crate::error::InvalidKmsArn),
    /// <p>The key-signing key (KSK) name that you specified isn't a valid name.</p>
    InvalidKeySigningKeyName(crate::error::InvalidKeySigningKeyName),
    /// <p>The key-signing key (KSK) status isn't valid or another KSK has the status <code>INTERNAL_FAILURE</code>.</p>
    InvalidKeySigningKeyStatus(crate::error::InvalidKeySigningKeyStatus),
    /// <p>The value that you specified to get the second or subsequent page of results is invalid.</p>
    InvalidPaginationToken(crate::error::InvalidPaginationToken),
    /// <p>Your hosted zone status isn't valid for this operation. In the hosted zone, change the status to enable <code>DNSSEC</code> or disable <code>DNSSEC</code>.</p>
    InvalidSigningStatus(crate::error::InvalidSigningStatus),
    /// <p>The format of the traffic policy document that you specified in the <code>Document</code> element is not valid.</p>
    InvalidTrafficPolicyDocument(crate::error::InvalidTrafficPolicyDocument),
    /// <p>The VPC ID that you specified either isn't a valid ID or the current account is not authorized to access this VPC.</p>
    InvalidVpcId(crate::error::InvalidVpcId),
    /// <p>You've already created a key-signing key (KSK) with this name or with the same customer managed key ARN.</p>
    KeySigningKeyAlreadyExists(crate::error::KeySigningKeyAlreadyExists),
    /// <p>The key-signing key (KSK) is specified in a parent DS record.</p>
    KeySigningKeyInParentDsRecord(crate::error::KeySigningKeyInParentDsRecord),
    /// <p>The key-signing key (KSK) that you specified can't be deactivated because it's the only KSK for a currently-enabled DNSSEC. Disable DNSSEC signing, or add or enable another KSK.</p>
    KeySigningKeyInUse(crate::error::KeySigningKeyInUse),
    /// <p>A key-signing key (KSK) with <code>ACTIVE</code> status wasn't found.</p>
    KeySigningKeyWithActiveStatusNotFound(crate::error::KeySigningKeyWithActiveStatusNotFound),
    /// <p>The VPC that you're trying to disassociate from the private hosted zone is the last VPC that is associated with the hosted zone. Amazon Route 53 doesn't support disassociating the last VPC from a hosted zone.</p>
    LastVpcAssociation(crate::error::LastVpcAssociation),
    /// <p>This operation can't be completed because the current account has reached the limit on the resource you are trying to create. To request a higher limit, <a href="http://aws.amazon.com/route53-request">create a case</a> with the Amazon Web Services Support Center.</p>
    LimitsExceeded(crate::error::LimitsExceeded),
    /// <p>A change with the specified change ID does not exist.</p>
    NoSuchChange(crate::error::NoSuchChange),
    /// <p>The CIDR collection you specified, doesn't exist.</p>
    NoSuchCidrCollectionException(crate::error::NoSuchCidrCollectionException),
    /// <p>The CIDR collection location doesn't match any locations in your account.</p>
    NoSuchCidrLocationException(crate::error::NoSuchCidrLocationException),
    /// <p>There is no CloudWatch Logs log group with the specified ARN.</p>
    NoSuchCloudWatchLogsLogGroup(crate::error::NoSuchCloudWatchLogsLogGroup),
    /// <p>A reusable delegation set with the specified ID does not exist.</p>
    NoSuchDelegationSet(crate::error::NoSuchDelegationSet),
    /// <p>Amazon Route 53 doesn't support the specified geographic location. For a list of supported geolocation codes, see the <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GeoLocation.html">GeoLocation</a> data type.</p>
    NoSuchGeoLocation(crate::error::NoSuchGeoLocation),
    /// <p>No health check exists with the specified ID.</p>
    NoSuchHealthCheck(crate::error::NoSuchHealthCheck),
    /// <p>No hosted zone exists with the ID that you specified.</p>
    NoSuchHostedZone(crate::error::NoSuchHostedZone),
    /// <p>The specified key-signing key (KSK) doesn't exist.</p>
    NoSuchKeySigningKey(crate::error::NoSuchKeySigningKey),
    /// <p>There is no DNS query logging configuration with the specified ID.</p>
    NoSuchQueryLoggingConfig(crate::error::NoSuchQueryLoggingConfig),
    /// <p>No traffic policy exists with the specified ID.</p>
    NoSuchTrafficPolicy(crate::error::NoSuchTrafficPolicy),
    /// <p>No traffic policy instance exists with the specified ID.</p>
    NoSuchTrafficPolicyInstance(crate::error::NoSuchTrafficPolicyInstance),
    /// <p>Associating the specified VPC with the specified hosted zone has not been authorized.</p>
    NotAuthorizedException(crate::error::NotAuthorizedException),
    /// <p>If Amazon Route 53 can't process a request before the next request arrives, it will reject subsequent requests for the same hosted zone and return an <code>HTTP 400 error</code> (<code>Bad request</code>). If Route 53 returns this error repeatedly for the same request, we recommend that you wait, in intervals of increasing duration, before you try the request again.</p>
    PriorRequestNotComplete(crate::error::PriorRequestNotComplete),
    /// <p>You're trying to associate a VPC with a public hosted zone. Amazon Route 53 doesn't support associating a VPC with a public hosted zone.</p>
    PublicZoneVpcAssociation(crate::error::PublicZoneVpcAssociation),
    /// <p>You can create only one query logging configuration for a hosted zone, and a query logging configuration already exists for this hosted zone.</p>
    QueryLoggingConfigAlreadyExists(crate::error::QueryLoggingConfigAlreadyExists),
    /// <p>The limit on the number of requests per second was exceeded.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>This health check can't be created because the current account has reached the limit on the number of active health checks.</p>
    /// <p>For information about default limits, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a> in the <i>Amazon Route 53 Developer Guide</i>.</p>
    /// <p>For information about how to get the current limit for an account, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetAccountLimit.html">GetAccountLimit</a>. To request a higher limit, <a href="http://aws.amazon.com/route53-request">create a case</a> with the Amazon Web Services Support Center.</p>
    /// <p>You have reached the maximum number of active health checks for an Amazon Web Services account. To request a higher limit, <a href="http://aws.amazon.com/route53-request">create a case</a> with the Amazon Web Services Support Center.</p>
    TooManyHealthChecks(crate::error::TooManyHealthChecks),
    /// <p>This operation can't be completed either because the current account has reached the limit on the number of hosted zones or because you've reached the limit on the number of hosted zones that can be associated with a reusable delegation set.</p>
    /// <p>For information about default limits, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a> in the <i>Amazon Route 53 Developer Guide</i>.</p>
    /// <p>To get the current limit on hosted zones that can be created by an account, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetAccountLimit.html">GetAccountLimit</a>.</p>
    /// <p>To get the current limit on hosted zones that can be associated with a reusable delegation set, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetReusableDelegationSetLimit.html">GetReusableDelegationSetLimit</a>.</p>
    /// <p>To request a higher limit, <a href="http://aws.amazon.com/route53-request">create a case</a> with the Amazon Web Services Support Center.</p>
    TooManyHostedZones(crate::error::TooManyHostedZones),
    /// <p>You've reached the limit for the number of key-signing keys (KSKs). Remove at least one KSK, and then try again.</p>
    TooManyKeySigningKeys(crate::error::TooManyKeySigningKeys),
    /// <p>This traffic policy can't be created because the current account has reached the limit on the number of traffic policies.</p>
    /// <p>For information about default limits, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a> in the <i>Amazon Route 53 Developer Guide</i>.</p>
    /// <p>To get the current limit for an account, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetAccountLimit.html">GetAccountLimit</a>. </p>
    /// <p>To request a higher limit, <a href="http://aws.amazon.com/route53-request">create a case</a> with the Amazon Web Services Support Center.</p>
    TooManyTrafficPolicies(crate::error::TooManyTrafficPolicies),
    /// <p>This traffic policy instance can't be created because the current account has reached the limit on the number of traffic policy instances.</p>
    /// <p>For information about default limits, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a> in the <i>Amazon Route 53 Developer Guide</i>.</p>
    /// <p>For information about how to get the current limit for an account, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetAccountLimit.html">GetAccountLimit</a>.</p>
    /// <p>To request a higher limit, <a href="http://aws.amazon.com/route53-request">create a case</a> with the Amazon Web Services Support Center.</p>
    TooManyTrafficPolicyInstances(crate::error::TooManyTrafficPolicyInstances),
    /// <p>This traffic policy version can't be created because you've reached the limit of 1000 on the number of versions that you can create for the current traffic policy.</p>
    /// <p>To create more traffic policy versions, you can use <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetTrafficPolicy.html">GetTrafficPolicy</a> to get the traffic policy document for a specified traffic policy version, and then use <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateTrafficPolicy.html">CreateTrafficPolicy</a> to create a new traffic policy using the traffic policy document.</p>
    TooManyTrafficPolicyVersionsForCurrentPolicy(
        crate::error::TooManyTrafficPolicyVersionsForCurrentPolicy,
    ),
    /// <p>You've created the maximum number of authorizations that can be created for the specified hosted zone. To authorize another VPC to be associated with the hosted zone, submit a <code>DeleteVPCAssociationAuthorization</code> request to remove an existing authorization. To get a list of existing authorizations, submit a <code>ListVPCAssociationAuthorizations</code> request.</p>
    TooManyVpcAssociationAuthorizations(crate::error::TooManyVpcAssociationAuthorizations),
    /// <p>A traffic policy that has the same value for <code>Name</code> already exists.</p>
    TrafficPolicyAlreadyExists(crate::error::TrafficPolicyAlreadyExists),
    /// <p>One or more traffic policy instances were created by using the specified traffic policy.</p>
    TrafficPolicyInUse(crate::error::TrafficPolicyInUse),
    /// <p>There is already a traffic policy instance with the specified ID.</p>
    TrafficPolicyInstanceAlreadyExists(crate::error::TrafficPolicyInstanceAlreadyExists),
    /// <p>The VPC that you specified is not authorized to be associated with the hosted zone.</p>
    VpcAssociationAuthorizationNotFound(crate::error::VpcAssociationAuthorizationNotFound),
    /// <p>The specified VPC and hosted zone are not currently associated.</p>
    VpcAssociationNotFound(crate::error::VpcAssociationNotFound),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::CidrBlockInUseException(inner) => inner.fmt(f),
            Error::CidrCollectionAlreadyExistsException(inner) => inner.fmt(f),
            Error::CidrCollectionInUseException(inner) => inner.fmt(f),
            Error::CidrCollectionVersionMismatchException(inner) => inner.fmt(f),
            Error::ConcurrentModification(inner) => inner.fmt(f),
            Error::ConflictingDomainExists(inner) => inner.fmt(f),
            Error::ConflictingTypes(inner) => inner.fmt(f),
            Error::DnssecNotFound(inner) => inner.fmt(f),
            Error::DelegationSetAlreadyCreated(inner) => inner.fmt(f),
            Error::DelegationSetAlreadyReusable(inner) => inner.fmt(f),
            Error::DelegationSetInUse(inner) => inner.fmt(f),
            Error::DelegationSetNotAvailable(inner) => inner.fmt(f),
            Error::DelegationSetNotReusable(inner) => inner.fmt(f),
            Error::HealthCheckAlreadyExists(inner) => inner.fmt(f),
            Error::HealthCheckInUse(inner) => inner.fmt(f),
            Error::HealthCheckVersionMismatch(inner) => inner.fmt(f),
            Error::HostedZoneAlreadyExists(inner) => inner.fmt(f),
            Error::HostedZoneNotEmpty(inner) => inner.fmt(f),
            Error::HostedZoneNotFound(inner) => inner.fmt(f),
            Error::HostedZoneNotPrivate(inner) => inner.fmt(f),
            Error::HostedZonePartiallyDelegated(inner) => inner.fmt(f),
            Error::IncompatibleVersion(inner) => inner.fmt(f),
            Error::InsufficientCloudWatchLogsResourcePolicy(inner) => inner.fmt(f),
            Error::InvalidArgument(inner) => inner.fmt(f),
            Error::InvalidChangeBatch(inner) => inner.fmt(f),
            Error::InvalidDomainName(inner) => inner.fmt(f),
            Error::InvalidInput(inner) => inner.fmt(f),
            Error::InvalidKmsArn(inner) => inner.fmt(f),
            Error::InvalidKeySigningKeyName(inner) => inner.fmt(f),
            Error::InvalidKeySigningKeyStatus(inner) => inner.fmt(f),
            Error::InvalidPaginationToken(inner) => inner.fmt(f),
            Error::InvalidSigningStatus(inner) => inner.fmt(f),
            Error::InvalidTrafficPolicyDocument(inner) => inner.fmt(f),
            Error::InvalidVpcId(inner) => inner.fmt(f),
            Error::KeySigningKeyAlreadyExists(inner) => inner.fmt(f),
            Error::KeySigningKeyInParentDsRecord(inner) => inner.fmt(f),
            Error::KeySigningKeyInUse(inner) => inner.fmt(f),
            Error::KeySigningKeyWithActiveStatusNotFound(inner) => inner.fmt(f),
            Error::LastVpcAssociation(inner) => inner.fmt(f),
            Error::LimitsExceeded(inner) => inner.fmt(f),
            Error::NoSuchChange(inner) => inner.fmt(f),
            Error::NoSuchCidrCollectionException(inner) => inner.fmt(f),
            Error::NoSuchCidrLocationException(inner) => inner.fmt(f),
            Error::NoSuchCloudWatchLogsLogGroup(inner) => inner.fmt(f),
            Error::NoSuchDelegationSet(inner) => inner.fmt(f),
            Error::NoSuchGeoLocation(inner) => inner.fmt(f),
            Error::NoSuchHealthCheck(inner) => inner.fmt(f),
            Error::NoSuchHostedZone(inner) => inner.fmt(f),
            Error::NoSuchKeySigningKey(inner) => inner.fmt(f),
            Error::NoSuchQueryLoggingConfig(inner) => inner.fmt(f),
            Error::NoSuchTrafficPolicy(inner) => inner.fmt(f),
            Error::NoSuchTrafficPolicyInstance(inner) => inner.fmt(f),
            Error::NotAuthorizedException(inner) => inner.fmt(f),
            Error::PriorRequestNotComplete(inner) => inner.fmt(f),
            Error::PublicZoneVpcAssociation(inner) => inner.fmt(f),
            Error::QueryLoggingConfigAlreadyExists(inner) => inner.fmt(f),
            Error::ThrottlingException(inner) => inner.fmt(f),
            Error::TooManyHealthChecks(inner) => inner.fmt(f),
            Error::TooManyHostedZones(inner) => inner.fmt(f),
            Error::TooManyKeySigningKeys(inner) => inner.fmt(f),
            Error::TooManyTrafficPolicies(inner) => inner.fmt(f),
            Error::TooManyTrafficPolicyInstances(inner) => inner.fmt(f),
            Error::TooManyTrafficPolicyVersionsForCurrentPolicy(inner) => inner.fmt(f),
            Error::TooManyVpcAssociationAuthorizations(inner) => inner.fmt(f),
            Error::TrafficPolicyAlreadyExists(inner) => inner.fmt(f),
            Error::TrafficPolicyInUse(inner) => inner.fmt(f),
            Error::TrafficPolicyInstanceAlreadyExists(inner) => inner.fmt(f),
            Error::VpcAssociationAuthorizationNotFound(inner) => inner.fmt(f),
            Error::VpcAssociationNotFound(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ActivateKeySigningKeyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ActivateKeySigningKeyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ActivateKeySigningKeyError> for Error {
    fn from(err: crate::error::ActivateKeySigningKeyError) -> Self {
        match err {
            crate::error::ActivateKeySigningKeyError::ConcurrentModification(inner) => {
                Error::ConcurrentModification(inner)
            }
            crate::error::ActivateKeySigningKeyError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::ActivateKeySigningKeyError::InvalidKeySigningKeyStatus(inner) => {
                Error::InvalidKeySigningKeyStatus(inner)
            }
            crate::error::ActivateKeySigningKeyError::InvalidKmsArn(inner) => {
                Error::InvalidKmsArn(inner)
            }
            crate::error::ActivateKeySigningKeyError::InvalidSigningStatus(inner) => {
                Error::InvalidSigningStatus(inner)
            }
            crate::error::ActivateKeySigningKeyError::NoSuchKeySigningKey(inner) => {
                Error::NoSuchKeySigningKey(inner)
            }
            crate::error::ActivateKeySigningKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::AssociateVPCWithHostedZoneError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::AssociateVPCWithHostedZoneError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::AssociateVPCWithHostedZoneError> for Error {
    fn from(err: crate::error::AssociateVPCWithHostedZoneError) -> Self {
        match err {
            crate::error::AssociateVPCWithHostedZoneError::ConflictingDomainExists(inner) => {
                Error::ConflictingDomainExists(inner)
            }
            crate::error::AssociateVPCWithHostedZoneError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::AssociateVPCWithHostedZoneError::InvalidVpcId(inner) => {
                Error::InvalidVpcId(inner)
            }
            crate::error::AssociateVPCWithHostedZoneError::LimitsExceeded(inner) => {
                Error::LimitsExceeded(inner)
            }
            crate::error::AssociateVPCWithHostedZoneError::NoSuchHostedZone(inner) => {
                Error::NoSuchHostedZone(inner)
            }
            crate::error::AssociateVPCWithHostedZoneError::NotAuthorizedException(inner) => {
                Error::NotAuthorizedException(inner)
            }
            crate::error::AssociateVPCWithHostedZoneError::PriorRequestNotComplete(inner) => {
                Error::PriorRequestNotComplete(inner)
            }
            crate::error::AssociateVPCWithHostedZoneError::PublicZoneVpcAssociation(inner) => {
                Error::PublicZoneVpcAssociation(inner)
            }
            crate::error::AssociateVPCWithHostedZoneError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ChangeCidrCollectionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ChangeCidrCollectionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ChangeCidrCollectionError> for Error {
    fn from(err: crate::error::ChangeCidrCollectionError) -> Self {
        match err {
            crate::error::ChangeCidrCollectionError::CidrBlockInUseException(inner) => {
                Error::CidrBlockInUseException(inner)
            }
            crate::error::ChangeCidrCollectionError::CidrCollectionVersionMismatchException(
                inner,
            ) => Error::CidrCollectionVersionMismatchException(inner),
            crate::error::ChangeCidrCollectionError::ConcurrentModification(inner) => {
                Error::ConcurrentModification(inner)
            }
            crate::error::ChangeCidrCollectionError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::ChangeCidrCollectionError::LimitsExceeded(inner) => {
                Error::LimitsExceeded(inner)
            }
            crate::error::ChangeCidrCollectionError::NoSuchCidrCollectionException(inner) => {
                Error::NoSuchCidrCollectionException(inner)
            }
            crate::error::ChangeCidrCollectionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ChangeResourceRecordSetsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ChangeResourceRecordSetsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ChangeResourceRecordSetsError> for Error {
    fn from(err: crate::error::ChangeResourceRecordSetsError) -> Self {
        match err {
            crate::error::ChangeResourceRecordSetsError::InvalidChangeBatch(inner) => {
                Error::InvalidChangeBatch(inner)
            }
            crate::error::ChangeResourceRecordSetsError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::ChangeResourceRecordSetsError::NoSuchHealthCheck(inner) => {
                Error::NoSuchHealthCheck(inner)
            }
            crate::error::ChangeResourceRecordSetsError::NoSuchHostedZone(inner) => {
                Error::NoSuchHostedZone(inner)
            }
            crate::error::ChangeResourceRecordSetsError::PriorRequestNotComplete(inner) => {
                Error::PriorRequestNotComplete(inner)
            }
            crate::error::ChangeResourceRecordSetsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ChangeTagsForResourceError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ChangeTagsForResourceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ChangeTagsForResourceError> for Error {
    fn from(err: crate::error::ChangeTagsForResourceError) -> Self {
        match err {
            crate::error::ChangeTagsForResourceError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::ChangeTagsForResourceError::NoSuchHealthCheck(inner) => {
                Error::NoSuchHealthCheck(inner)
            }
            crate::error::ChangeTagsForResourceError::NoSuchHostedZone(inner) => {
                Error::NoSuchHostedZone(inner)
            }
            crate::error::ChangeTagsForResourceError::PriorRequestNotComplete(inner) => {
                Error::PriorRequestNotComplete(inner)
            }
            crate::error::ChangeTagsForResourceError::ThrottlingException(inner) => {
                Error::ThrottlingException(inner)
            }
            crate::error::ChangeTagsForResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateCidrCollectionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateCidrCollectionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateCidrCollectionError> for Error {
    fn from(err: crate::error::CreateCidrCollectionError) -> Self {
        match err {
            crate::error::CreateCidrCollectionError::CidrCollectionAlreadyExistsException(
                inner,
            ) => Error::CidrCollectionAlreadyExistsException(inner),
            crate::error::CreateCidrCollectionError::ConcurrentModification(inner) => {
                Error::ConcurrentModification(inner)
            }
            crate::error::CreateCidrCollectionError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::CreateCidrCollectionError::LimitsExceeded(inner) => {
                Error::LimitsExceeded(inner)
            }
            crate::error::CreateCidrCollectionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateHealthCheckError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateHealthCheckError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateHealthCheckError> for Error {
    fn from(err: crate::error::CreateHealthCheckError) -> Self {
        match err {
            crate::error::CreateHealthCheckError::HealthCheckAlreadyExists(inner) => {
                Error::HealthCheckAlreadyExists(inner)
            }
            crate::error::CreateHealthCheckError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::CreateHealthCheckError::TooManyHealthChecks(inner) => {
                Error::TooManyHealthChecks(inner)
            }
            crate::error::CreateHealthCheckError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateHostedZoneError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateHostedZoneError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateHostedZoneError> for Error {
    fn from(err: crate::error::CreateHostedZoneError) -> Self {
        match err {
            crate::error::CreateHostedZoneError::ConflictingDomainExists(inner) => {
                Error::ConflictingDomainExists(inner)
            }
            crate::error::CreateHostedZoneError::DelegationSetNotAvailable(inner) => {
                Error::DelegationSetNotAvailable(inner)
            }
            crate::error::CreateHostedZoneError::DelegationSetNotReusable(inner) => {
                Error::DelegationSetNotReusable(inner)
            }
            crate::error::CreateHostedZoneError::HostedZoneAlreadyExists(inner) => {
                Error::HostedZoneAlreadyExists(inner)
            }
            crate::error::CreateHostedZoneError::InvalidDomainName(inner) => {
                Error::InvalidDomainName(inner)
            }
            crate::error::CreateHostedZoneError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::CreateHostedZoneError::InvalidVpcId(inner) => Error::InvalidVpcId(inner),
            crate::error::CreateHostedZoneError::NoSuchDelegationSet(inner) => {
                Error::NoSuchDelegationSet(inner)
            }
            crate::error::CreateHostedZoneError::TooManyHostedZones(inner) => {
                Error::TooManyHostedZones(inner)
            }
            crate::error::CreateHostedZoneError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateKeySigningKeyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateKeySigningKeyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateKeySigningKeyError> for Error {
    fn from(err: crate::error::CreateKeySigningKeyError) -> Self {
        match err {
            crate::error::CreateKeySigningKeyError::ConcurrentModification(inner) => {
                Error::ConcurrentModification(inner)
            }
            crate::error::CreateKeySigningKeyError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::CreateKeySigningKeyError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::CreateKeySigningKeyError::InvalidKeySigningKeyName(inner) => {
                Error::InvalidKeySigningKeyName(inner)
            }
            crate::error::CreateKeySigningKeyError::InvalidKeySigningKeyStatus(inner) => {
                Error::InvalidKeySigningKeyStatus(inner)
            }
            crate::error::CreateKeySigningKeyError::InvalidKmsArn(inner) => {
                Error::InvalidKmsArn(inner)
            }
            crate::error::CreateKeySigningKeyError::InvalidSigningStatus(inner) => {
                Error::InvalidSigningStatus(inner)
            }
            crate::error::CreateKeySigningKeyError::KeySigningKeyAlreadyExists(inner) => {
                Error::KeySigningKeyAlreadyExists(inner)
            }
            crate::error::CreateKeySigningKeyError::NoSuchHostedZone(inner) => {
                Error::NoSuchHostedZone(inner)
            }
            crate::error::CreateKeySigningKeyError::TooManyKeySigningKeys(inner) => {
                Error::TooManyKeySigningKeys(inner)
            }
            crate::error::CreateKeySigningKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateQueryLoggingConfigError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateQueryLoggingConfigError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateQueryLoggingConfigError> for Error {
    fn from(err: crate::error::CreateQueryLoggingConfigError) -> Self {
        match err {
            crate::error::CreateQueryLoggingConfigError::ConcurrentModification(inner) => Error::ConcurrentModification(inner),
            crate::error::CreateQueryLoggingConfigError::InsufficientCloudWatchLogsResourcePolicy(inner) => Error::InsufficientCloudWatchLogsResourcePolicy(inner),
            crate::error::CreateQueryLoggingConfigError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::CreateQueryLoggingConfigError::NoSuchCloudWatchLogsLogGroup(inner) => Error::NoSuchCloudWatchLogsLogGroup(inner),
            crate::error::CreateQueryLoggingConfigError::NoSuchHostedZone(inner) => Error::NoSuchHostedZone(inner),
            crate::error::CreateQueryLoggingConfigError::QueryLoggingConfigAlreadyExists(inner) => Error::QueryLoggingConfigAlreadyExists(inner),
            crate::error::CreateQueryLoggingConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateReusableDelegationSetError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateReusableDelegationSetError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateReusableDelegationSetError> for Error {
    fn from(err: crate::error::CreateReusableDelegationSetError) -> Self {
        match err {
            crate::error::CreateReusableDelegationSetError::DelegationSetAlreadyCreated(inner) => {
                Error::DelegationSetAlreadyCreated(inner)
            }
            crate::error::CreateReusableDelegationSetError::DelegationSetAlreadyReusable(inner) => {
                Error::DelegationSetAlreadyReusable(inner)
            }
            crate::error::CreateReusableDelegationSetError::DelegationSetNotAvailable(inner) => {
                Error::DelegationSetNotAvailable(inner)
            }
            crate::error::CreateReusableDelegationSetError::HostedZoneNotFound(inner) => {
                Error::HostedZoneNotFound(inner)
            }
            crate::error::CreateReusableDelegationSetError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::CreateReusableDelegationSetError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::CreateReusableDelegationSetError::LimitsExceeded(inner) => {
                Error::LimitsExceeded(inner)
            }
            crate::error::CreateReusableDelegationSetError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateTrafficPolicyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateTrafficPolicyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateTrafficPolicyError> for Error {
    fn from(err: crate::error::CreateTrafficPolicyError) -> Self {
        match err {
            crate::error::CreateTrafficPolicyError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::CreateTrafficPolicyError::InvalidTrafficPolicyDocument(inner) => {
                Error::InvalidTrafficPolicyDocument(inner)
            }
            crate::error::CreateTrafficPolicyError::TooManyTrafficPolicies(inner) => {
                Error::TooManyTrafficPolicies(inner)
            }
            crate::error::CreateTrafficPolicyError::TrafficPolicyAlreadyExists(inner) => {
                Error::TrafficPolicyAlreadyExists(inner)
            }
            crate::error::CreateTrafficPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateTrafficPolicyInstanceError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateTrafficPolicyInstanceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateTrafficPolicyInstanceError> for Error {
    fn from(err: crate::error::CreateTrafficPolicyInstanceError) -> Self {
        match err {
            crate::error::CreateTrafficPolicyInstanceError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::CreateTrafficPolicyInstanceError::NoSuchHostedZone(inner) => {
                Error::NoSuchHostedZone(inner)
            }
            crate::error::CreateTrafficPolicyInstanceError::NoSuchTrafficPolicy(inner) => {
                Error::NoSuchTrafficPolicy(inner)
            }
            crate::error::CreateTrafficPolicyInstanceError::TooManyTrafficPolicyInstances(
                inner,
            ) => Error::TooManyTrafficPolicyInstances(inner),
            crate::error::CreateTrafficPolicyInstanceError::TrafficPolicyInstanceAlreadyExists(
                inner,
            ) => Error::TrafficPolicyInstanceAlreadyExists(inner),
            crate::error::CreateTrafficPolicyInstanceError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateTrafficPolicyVersionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateTrafficPolicyVersionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateTrafficPolicyVersionError> for Error {
    fn from(err: crate::error::CreateTrafficPolicyVersionError) -> Self {
        match err {
            crate::error::CreateTrafficPolicyVersionError::ConcurrentModification(inner) => Error::ConcurrentModification(inner),
            crate::error::CreateTrafficPolicyVersionError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::CreateTrafficPolicyVersionError::InvalidTrafficPolicyDocument(inner) => Error::InvalidTrafficPolicyDocument(inner),
            crate::error::CreateTrafficPolicyVersionError::NoSuchTrafficPolicy(inner) => Error::NoSuchTrafficPolicy(inner),
            crate::error::CreateTrafficPolicyVersionError::TooManyTrafficPolicyVersionsForCurrentPolicy(inner) => Error::TooManyTrafficPolicyVersionsForCurrentPolicy(inner),
            crate::error::CreateTrafficPolicyVersionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::CreateVPCAssociationAuthorizationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::CreateVPCAssociationAuthorizationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateVPCAssociationAuthorizationError> for Error {
    fn from(err: crate::error::CreateVPCAssociationAuthorizationError) -> Self {
        match err {
            crate::error::CreateVPCAssociationAuthorizationError::ConcurrentModification(inner) => Error::ConcurrentModification(inner),
            crate::error::CreateVPCAssociationAuthorizationError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::CreateVPCAssociationAuthorizationError::InvalidVpcId(inner) => Error::InvalidVpcId(inner),
            crate::error::CreateVPCAssociationAuthorizationError::NoSuchHostedZone(inner) => Error::NoSuchHostedZone(inner),
            crate::error::CreateVPCAssociationAuthorizationError::TooManyVpcAssociationAuthorizations(inner) => Error::TooManyVpcAssociationAuthorizations(inner),
            crate::error::CreateVPCAssociationAuthorizationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeactivateKeySigningKeyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeactivateKeySigningKeyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeactivateKeySigningKeyError> for Error {
    fn from(err: crate::error::DeactivateKeySigningKeyError) -> Self {
        match err {
            crate::error::DeactivateKeySigningKeyError::ConcurrentModification(inner) => {
                Error::ConcurrentModification(inner)
            }
            crate::error::DeactivateKeySigningKeyError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::DeactivateKeySigningKeyError::InvalidKeySigningKeyStatus(inner) => {
                Error::InvalidKeySigningKeyStatus(inner)
            }
            crate::error::DeactivateKeySigningKeyError::InvalidSigningStatus(inner) => {
                Error::InvalidSigningStatus(inner)
            }
            crate::error::DeactivateKeySigningKeyError::KeySigningKeyInParentDsRecord(inner) => {
                Error::KeySigningKeyInParentDsRecord(inner)
            }
            crate::error::DeactivateKeySigningKeyError::KeySigningKeyInUse(inner) => {
                Error::KeySigningKeyInUse(inner)
            }
            crate::error::DeactivateKeySigningKeyError::NoSuchKeySigningKey(inner) => {
                Error::NoSuchKeySigningKey(inner)
            }
            crate::error::DeactivateKeySigningKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteCidrCollectionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteCidrCollectionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteCidrCollectionError> for Error {
    fn from(err: crate::error::DeleteCidrCollectionError) -> Self {
        match err {
            crate::error::DeleteCidrCollectionError::CidrCollectionInUseException(inner) => {
                Error::CidrCollectionInUseException(inner)
            }
            crate::error::DeleteCidrCollectionError::ConcurrentModification(inner) => {
                Error::ConcurrentModification(inner)
            }
            crate::error::DeleteCidrCollectionError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::DeleteCidrCollectionError::NoSuchCidrCollectionException(inner) => {
                Error::NoSuchCidrCollectionException(inner)
            }
            crate::error::DeleteCidrCollectionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteHealthCheckError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteHealthCheckError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteHealthCheckError> for Error {
    fn from(err: crate::error::DeleteHealthCheckError) -> Self {
        match err {
            crate::error::DeleteHealthCheckError::HealthCheckInUse(inner) => {
                Error::HealthCheckInUse(inner)
            }
            crate::error::DeleteHealthCheckError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::DeleteHealthCheckError::NoSuchHealthCheck(inner) => {
                Error::NoSuchHealthCheck(inner)
            }
            crate::error::DeleteHealthCheckError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteHostedZoneError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteHostedZoneError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteHostedZoneError> for Error {
    fn from(err: crate::error::DeleteHostedZoneError) -> Self {
        match err {
            crate::error::DeleteHostedZoneError::HostedZoneNotEmpty(inner) => {
                Error::HostedZoneNotEmpty(inner)
            }
            crate::error::DeleteHostedZoneError::InvalidDomainName(inner) => {
                Error::InvalidDomainName(inner)
            }
            crate::error::DeleteHostedZoneError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::DeleteHostedZoneError::NoSuchHostedZone(inner) => {
                Error::NoSuchHostedZone(inner)
            }
            crate::error::DeleteHostedZoneError::PriorRequestNotComplete(inner) => {
                Error::PriorRequestNotComplete(inner)
            }
            crate::error::DeleteHostedZoneError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteKeySigningKeyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteKeySigningKeyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteKeySigningKeyError> for Error {
    fn from(err: crate::error::DeleteKeySigningKeyError) -> Self {
        match err {
            crate::error::DeleteKeySigningKeyError::ConcurrentModification(inner) => {
                Error::ConcurrentModification(inner)
            }
            crate::error::DeleteKeySigningKeyError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::DeleteKeySigningKeyError::InvalidKeySigningKeyStatus(inner) => {
                Error::InvalidKeySigningKeyStatus(inner)
            }
            crate::error::DeleteKeySigningKeyError::InvalidKmsArn(inner) => {
                Error::InvalidKmsArn(inner)
            }
            crate::error::DeleteKeySigningKeyError::InvalidSigningStatus(inner) => {
                Error::InvalidSigningStatus(inner)
            }
            crate::error::DeleteKeySigningKeyError::NoSuchKeySigningKey(inner) => {
                Error::NoSuchKeySigningKey(inner)
            }
            crate::error::DeleteKeySigningKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteQueryLoggingConfigError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteQueryLoggingConfigError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteQueryLoggingConfigError> for Error {
    fn from(err: crate::error::DeleteQueryLoggingConfigError) -> Self {
        match err {
            crate::error::DeleteQueryLoggingConfigError::ConcurrentModification(inner) => {
                Error::ConcurrentModification(inner)
            }
            crate::error::DeleteQueryLoggingConfigError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::DeleteQueryLoggingConfigError::NoSuchQueryLoggingConfig(inner) => {
                Error::NoSuchQueryLoggingConfig(inner)
            }
            crate::error::DeleteQueryLoggingConfigError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteReusableDelegationSetError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteReusableDelegationSetError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteReusableDelegationSetError> for Error {
    fn from(err: crate::error::DeleteReusableDelegationSetError) -> Self {
        match err {
            crate::error::DeleteReusableDelegationSetError::DelegationSetInUse(inner) => {
                Error::DelegationSetInUse(inner)
            }
            crate::error::DeleteReusableDelegationSetError::DelegationSetNotReusable(inner) => {
                Error::DelegationSetNotReusable(inner)
            }
            crate::error::DeleteReusableDelegationSetError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::DeleteReusableDelegationSetError::NoSuchDelegationSet(inner) => {
                Error::NoSuchDelegationSet(inner)
            }
            crate::error::DeleteReusableDelegationSetError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteTrafficPolicyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteTrafficPolicyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteTrafficPolicyError> for Error {
    fn from(err: crate::error::DeleteTrafficPolicyError) -> Self {
        match err {
            crate::error::DeleteTrafficPolicyError::ConcurrentModification(inner) => {
                Error::ConcurrentModification(inner)
            }
            crate::error::DeleteTrafficPolicyError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::DeleteTrafficPolicyError::NoSuchTrafficPolicy(inner) => {
                Error::NoSuchTrafficPolicy(inner)
            }
            crate::error::DeleteTrafficPolicyError::TrafficPolicyInUse(inner) => {
                Error::TrafficPolicyInUse(inner)
            }
            crate::error::DeleteTrafficPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteTrafficPolicyInstanceError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteTrafficPolicyInstanceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteTrafficPolicyInstanceError> for Error {
    fn from(err: crate::error::DeleteTrafficPolicyInstanceError) -> Self {
        match err {
            crate::error::DeleteTrafficPolicyInstanceError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::DeleteTrafficPolicyInstanceError::NoSuchTrafficPolicyInstance(inner) => {
                Error::NoSuchTrafficPolicyInstance(inner)
            }
            crate::error::DeleteTrafficPolicyInstanceError::PriorRequestNotComplete(inner) => {
                Error::PriorRequestNotComplete(inner)
            }
            crate::error::DeleteTrafficPolicyInstanceError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::DeleteVPCAssociationAuthorizationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DeleteVPCAssociationAuthorizationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteVPCAssociationAuthorizationError> for Error {
    fn from(err: crate::error::DeleteVPCAssociationAuthorizationError) -> Self {
        match err {
            crate::error::DeleteVPCAssociationAuthorizationError::ConcurrentModification(inner) => Error::ConcurrentModification(inner),
            crate::error::DeleteVPCAssociationAuthorizationError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::DeleteVPCAssociationAuthorizationError::InvalidVpcId(inner) => Error::InvalidVpcId(inner),
            crate::error::DeleteVPCAssociationAuthorizationError::NoSuchHostedZone(inner) => Error::NoSuchHostedZone(inner),
            crate::error::DeleteVPCAssociationAuthorizationError::VpcAssociationAuthorizationNotFound(inner) => Error::VpcAssociationAuthorizationNotFound(inner),
            crate::error::DeleteVPCAssociationAuthorizationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DisableHostedZoneDNSSECError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DisableHostedZoneDNSSECError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DisableHostedZoneDNSSECError> for Error {
    fn from(err: crate::error::DisableHostedZoneDNSSECError) -> Self {
        match err {
            crate::error::DisableHostedZoneDNSSECError::ConcurrentModification(inner) => {
                Error::ConcurrentModification(inner)
            }
            crate::error::DisableHostedZoneDNSSECError::DnssecNotFound(inner) => {
                Error::DnssecNotFound(inner)
            }
            crate::error::DisableHostedZoneDNSSECError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::DisableHostedZoneDNSSECError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::DisableHostedZoneDNSSECError::InvalidKeySigningKeyStatus(inner) => {
                Error::InvalidKeySigningKeyStatus(inner)
            }
            crate::error::DisableHostedZoneDNSSECError::InvalidKmsArn(inner) => {
                Error::InvalidKmsArn(inner)
            }
            crate::error::DisableHostedZoneDNSSECError::KeySigningKeyInParentDsRecord(inner) => {
                Error::KeySigningKeyInParentDsRecord(inner)
            }
            crate::error::DisableHostedZoneDNSSECError::NoSuchHostedZone(inner) => {
                Error::NoSuchHostedZone(inner)
            }
            crate::error::DisableHostedZoneDNSSECError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DisassociateVPCFromHostedZoneError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DisassociateVPCFromHostedZoneError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DisassociateVPCFromHostedZoneError> for Error {
    fn from(err: crate::error::DisassociateVPCFromHostedZoneError) -> Self {
        match err {
            crate::error::DisassociateVPCFromHostedZoneError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::DisassociateVPCFromHostedZoneError::InvalidVpcId(inner) => {
                Error::InvalidVpcId(inner)
            }
            crate::error::DisassociateVPCFromHostedZoneError::LastVpcAssociation(inner) => {
                Error::LastVpcAssociation(inner)
            }
            crate::error::DisassociateVPCFromHostedZoneError::NoSuchHostedZone(inner) => {
                Error::NoSuchHostedZone(inner)
            }
            crate::error::DisassociateVPCFromHostedZoneError::VpcAssociationNotFound(inner) => {
                Error::VpcAssociationNotFound(inner)
            }
            crate::error::DisassociateVPCFromHostedZoneError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::EnableHostedZoneDNSSECError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::EnableHostedZoneDNSSECError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::EnableHostedZoneDNSSECError> for Error {
    fn from(err: crate::error::EnableHostedZoneDNSSECError) -> Self {
        match err {
            crate::error::EnableHostedZoneDNSSECError::ConcurrentModification(inner) => {
                Error::ConcurrentModification(inner)
            }
            crate::error::EnableHostedZoneDNSSECError::DnssecNotFound(inner) => {
                Error::DnssecNotFound(inner)
            }
            crate::error::EnableHostedZoneDNSSECError::HostedZonePartiallyDelegated(inner) => {
                Error::HostedZonePartiallyDelegated(inner)
            }
            crate::error::EnableHostedZoneDNSSECError::InvalidArgument(inner) => {
                Error::InvalidArgument(inner)
            }
            crate::error::EnableHostedZoneDNSSECError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::EnableHostedZoneDNSSECError::InvalidKeySigningKeyStatus(inner) => {
                Error::InvalidKeySigningKeyStatus(inner)
            }
            crate::error::EnableHostedZoneDNSSECError::InvalidKmsArn(inner) => {
                Error::InvalidKmsArn(inner)
            }
            crate::error::EnableHostedZoneDNSSECError::KeySigningKeyWithActiveStatusNotFound(
                inner,
            ) => Error::KeySigningKeyWithActiveStatusNotFound(inner),
            crate::error::EnableHostedZoneDNSSECError::NoSuchHostedZone(inner) => {
                Error::NoSuchHostedZone(inner)
            }
            crate::error::EnableHostedZoneDNSSECError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetAccountLimitError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetAccountLimitError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetAccountLimitError> for Error {
    fn from(err: crate::error::GetAccountLimitError) -> Self {
        match err {
            crate::error::GetAccountLimitError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::GetAccountLimitError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetChangeError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetChangeError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetChangeError> for Error {
    fn from(err: crate::error::GetChangeError) -> Self {
        match err {
            crate::error::GetChangeError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::GetChangeError::NoSuchChange(inner) => Error::NoSuchChange(inner),
            crate::error::GetChangeError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCheckerIpRangesError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetCheckerIpRangesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetCheckerIpRangesError> for Error {
    fn from(err: crate::error::GetCheckerIpRangesError) -> Self {
        match err {
            crate::error::GetCheckerIpRangesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDNSSECError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetDNSSECError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetDNSSECError> for Error {
    fn from(err: crate::error::GetDNSSECError) -> Self {
        match err {
            crate::error::GetDNSSECError::InvalidArgument(inner) => Error::InvalidArgument(inner),
            crate::error::GetDNSSECError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::GetDNSSECError::NoSuchHostedZone(inner) => Error::NoSuchHostedZone(inner),
            crate::error::GetDNSSECError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetGeoLocationError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetGeoLocationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetGeoLocationError> for Error {
    fn from(err: crate::error::GetGeoLocationError) -> Self {
        match err {
            crate::error::GetGeoLocationError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::GetGeoLocationError::NoSuchGeoLocation(inner) => {
                Error::NoSuchGeoLocation(inner)
            }
            crate::error::GetGeoLocationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetHealthCheckError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetHealthCheckError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetHealthCheckError> for Error {
    fn from(err: crate::error::GetHealthCheckError) -> Self {
        match err {
            crate::error::GetHealthCheckError::IncompatibleVersion(inner) => {
                Error::IncompatibleVersion(inner)
            }
            crate::error::GetHealthCheckError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::GetHealthCheckError::NoSuchHealthCheck(inner) => {
                Error::NoSuchHealthCheck(inner)
            }
            crate::error::GetHealthCheckError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetHealthCheckCountError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetHealthCheckCountError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetHealthCheckCountError> for Error {
    fn from(err: crate::error::GetHealthCheckCountError) -> Self {
        match err {
            crate::error::GetHealthCheckCountError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::GetHealthCheckLastFailureReasonError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::GetHealthCheckLastFailureReasonError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetHealthCheckLastFailureReasonError> for Error {
    fn from(err: crate::error::GetHealthCheckLastFailureReasonError) -> Self {
        match err {
            crate::error::GetHealthCheckLastFailureReasonError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::GetHealthCheckLastFailureReasonError::NoSuchHealthCheck(inner) => {
                Error::NoSuchHealthCheck(inner)
            }
            crate::error::GetHealthCheckLastFailureReasonError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetHealthCheckStatusError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetHealthCheckStatusError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetHealthCheckStatusError> for Error {
    fn from(err: crate::error::GetHealthCheckStatusError) -> Self {
        match err {
            crate::error::GetHealthCheckStatusError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::GetHealthCheckStatusError::NoSuchHealthCheck(inner) => {
                Error::NoSuchHealthCheck(inner)
            }
            crate::error::GetHealthCheckStatusError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetHostedZoneError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetHostedZoneError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetHostedZoneError> for Error {
    fn from(err: crate::error::GetHostedZoneError) -> Self {
        match err {
            crate::error::GetHostedZoneError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::GetHostedZoneError::NoSuchHostedZone(inner) => {
                Error::NoSuchHostedZone(inner)
            }
            crate::error::GetHostedZoneError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetHostedZoneCountError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetHostedZoneCountError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetHostedZoneCountError> for Error {
    fn from(err: crate::error::GetHostedZoneCountError) -> Self {
        match err {
            crate::error::GetHostedZoneCountError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::GetHostedZoneCountError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetHostedZoneLimitError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetHostedZoneLimitError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetHostedZoneLimitError> for Error {
    fn from(err: crate::error::GetHostedZoneLimitError) -> Self {
        match err {
            crate::error::GetHostedZoneLimitError::HostedZoneNotPrivate(inner) => {
                Error::HostedZoneNotPrivate(inner)
            }
            crate::error::GetHostedZoneLimitError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::GetHostedZoneLimitError::NoSuchHostedZone(inner) => {
                Error::NoSuchHostedZone(inner)
            }
            crate::error::GetHostedZoneLimitError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetQueryLoggingConfigError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetQueryLoggingConfigError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetQueryLoggingConfigError> for Error {
    fn from(err: crate::error::GetQueryLoggingConfigError) -> Self {
        match err {
            crate::error::GetQueryLoggingConfigError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::GetQueryLoggingConfigError::NoSuchQueryLoggingConfig(inner) => {
                Error::NoSuchQueryLoggingConfig(inner)
            }
            crate::error::GetQueryLoggingConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetReusableDelegationSetError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetReusableDelegationSetError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetReusableDelegationSetError> for Error {
    fn from(err: crate::error::GetReusableDelegationSetError) -> Self {
        match err {
            crate::error::GetReusableDelegationSetError::DelegationSetNotReusable(inner) => {
                Error::DelegationSetNotReusable(inner)
            }
            crate::error::GetReusableDelegationSetError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::GetReusableDelegationSetError::NoSuchDelegationSet(inner) => {
                Error::NoSuchDelegationSet(inner)
            }
            crate::error::GetReusableDelegationSetError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetReusableDelegationSetLimitError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetReusableDelegationSetLimitError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetReusableDelegationSetLimitError> for Error {
    fn from(err: crate::error::GetReusableDelegationSetLimitError) -> Self {
        match err {
            crate::error::GetReusableDelegationSetLimitError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::GetReusableDelegationSetLimitError::NoSuchDelegationSet(inner) => {
                Error::NoSuchDelegationSet(inner)
            }
            crate::error::GetReusableDelegationSetLimitError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetTrafficPolicyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetTrafficPolicyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetTrafficPolicyError> for Error {
    fn from(err: crate::error::GetTrafficPolicyError) -> Self {
        match err {
            crate::error::GetTrafficPolicyError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::GetTrafficPolicyError::NoSuchTrafficPolicy(inner) => {
                Error::NoSuchTrafficPolicy(inner)
            }
            crate::error::GetTrafficPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetTrafficPolicyInstanceError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetTrafficPolicyInstanceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetTrafficPolicyInstanceError> for Error {
    fn from(err: crate::error::GetTrafficPolicyInstanceError) -> Self {
        match err {
            crate::error::GetTrafficPolicyInstanceError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::GetTrafficPolicyInstanceError::NoSuchTrafficPolicyInstance(inner) => {
                Error::NoSuchTrafficPolicyInstance(inner)
            }
            crate::error::GetTrafficPolicyInstanceError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetTrafficPolicyInstanceCountError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetTrafficPolicyInstanceCountError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetTrafficPolicyInstanceCountError> for Error {
    fn from(err: crate::error::GetTrafficPolicyInstanceCountError) -> Self {
        match err {
            crate::error::GetTrafficPolicyInstanceCountError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListCidrBlocksError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListCidrBlocksError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListCidrBlocksError> for Error {
    fn from(err: crate::error::ListCidrBlocksError) -> Self {
        match err {
            crate::error::ListCidrBlocksError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::ListCidrBlocksError::NoSuchCidrCollectionException(inner) => {
                Error::NoSuchCidrCollectionException(inner)
            }
            crate::error::ListCidrBlocksError::NoSuchCidrLocationException(inner) => {
                Error::NoSuchCidrLocationException(inner)
            }
            crate::error::ListCidrBlocksError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListCidrCollectionsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListCidrCollectionsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListCidrCollectionsError> for Error {
    fn from(err: crate::error::ListCidrCollectionsError) -> Self {
        match err {
            crate::error::ListCidrCollectionsError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::ListCidrCollectionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListCidrLocationsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListCidrLocationsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListCidrLocationsError> for Error {
    fn from(err: crate::error::ListCidrLocationsError) -> Self {
        match err {
            crate::error::ListCidrLocationsError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::ListCidrLocationsError::NoSuchCidrCollectionException(inner) => {
                Error::NoSuchCidrCollectionException(inner)
            }
            crate::error::ListCidrLocationsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListGeoLocationsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListGeoLocationsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListGeoLocationsError> for Error {
    fn from(err: crate::error::ListGeoLocationsError) -> Self {
        match err {
            crate::error::ListGeoLocationsError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::ListGeoLocationsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListHealthChecksError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListHealthChecksError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListHealthChecksError> for Error {
    fn from(err: crate::error::ListHealthChecksError) -> Self {
        match err {
            crate::error::ListHealthChecksError::IncompatibleVersion(inner) => {
                Error::IncompatibleVersion(inner)
            }
            crate::error::ListHealthChecksError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::ListHealthChecksError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListHostedZonesError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListHostedZonesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListHostedZonesError> for Error {
    fn from(err: crate::error::ListHostedZonesError) -> Self {
        match err {
            crate::error::ListHostedZonesError::DelegationSetNotReusable(inner) => {
                Error::DelegationSetNotReusable(inner)
            }
            crate::error::ListHostedZonesError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::ListHostedZonesError::NoSuchDelegationSet(inner) => {
                Error::NoSuchDelegationSet(inner)
            }
            crate::error::ListHostedZonesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListHostedZonesByNameError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListHostedZonesByNameError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListHostedZonesByNameError> for Error {
    fn from(err: crate::error::ListHostedZonesByNameError) -> Self {
        match err {
            crate::error::ListHostedZonesByNameError::InvalidDomainName(inner) => {
                Error::InvalidDomainName(inner)
            }
            crate::error::ListHostedZonesByNameError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::ListHostedZonesByNameError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListHostedZonesByVPCError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListHostedZonesByVPCError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListHostedZonesByVPCError> for Error {
    fn from(err: crate::error::ListHostedZonesByVPCError) -> Self {
        match err {
            crate::error::ListHostedZonesByVPCError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::ListHostedZonesByVPCError::InvalidPaginationToken(inner) => {
                Error::InvalidPaginationToken(inner)
            }
            crate::error::ListHostedZonesByVPCError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListQueryLoggingConfigsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListQueryLoggingConfigsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListQueryLoggingConfigsError> for Error {
    fn from(err: crate::error::ListQueryLoggingConfigsError) -> Self {
        match err {
            crate::error::ListQueryLoggingConfigsError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::ListQueryLoggingConfigsError::InvalidPaginationToken(inner) => {
                Error::InvalidPaginationToken(inner)
            }
            crate::error::ListQueryLoggingConfigsError::NoSuchHostedZone(inner) => {
                Error::NoSuchHostedZone(inner)
            }
            crate::error::ListQueryLoggingConfigsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListResourceRecordSetsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListResourceRecordSetsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListResourceRecordSetsError> for Error {
    fn from(err: crate::error::ListResourceRecordSetsError) -> Self {
        match err {
            crate::error::ListResourceRecordSetsError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::ListResourceRecordSetsError::NoSuchHostedZone(inner) => {
                Error::NoSuchHostedZone(inner)
            }
            crate::error::ListResourceRecordSetsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListReusableDelegationSetsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListReusableDelegationSetsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListReusableDelegationSetsError> for Error {
    fn from(err: crate::error::ListReusableDelegationSetsError) -> Self {
        match err {
            crate::error::ListReusableDelegationSetsError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::ListReusableDelegationSetsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListTagsForResourceError> for Error {
    fn from(err: crate::error::ListTagsForResourceError) -> Self {
        match err {
            crate::error::ListTagsForResourceError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::ListTagsForResourceError::NoSuchHealthCheck(inner) => {
                Error::NoSuchHealthCheck(inner)
            }
            crate::error::ListTagsForResourceError::NoSuchHostedZone(inner) => {
                Error::NoSuchHostedZone(inner)
            }
            crate::error::ListTagsForResourceError::PriorRequestNotComplete(inner) => {
                Error::PriorRequestNotComplete(inner)
            }
            crate::error::ListTagsForResourceError::ThrottlingException(inner) => {
                Error::ThrottlingException(inner)
            }
            crate::error::ListTagsForResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTagsForResourcesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListTagsForResourcesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListTagsForResourcesError> for Error {
    fn from(err: crate::error::ListTagsForResourcesError) -> Self {
        match err {
            crate::error::ListTagsForResourcesError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::ListTagsForResourcesError::NoSuchHealthCheck(inner) => {
                Error::NoSuchHealthCheck(inner)
            }
            crate::error::ListTagsForResourcesError::NoSuchHostedZone(inner) => {
                Error::NoSuchHostedZone(inner)
            }
            crate::error::ListTagsForResourcesError::PriorRequestNotComplete(inner) => {
                Error::PriorRequestNotComplete(inner)
            }
            crate::error::ListTagsForResourcesError::ThrottlingException(inner) => {
                Error::ThrottlingException(inner)
            }
            crate::error::ListTagsForResourcesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTrafficPoliciesError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListTrafficPoliciesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListTrafficPoliciesError> for Error {
    fn from(err: crate::error::ListTrafficPoliciesError) -> Self {
        match err {
            crate::error::ListTrafficPoliciesError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::ListTrafficPoliciesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTrafficPolicyInstancesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListTrafficPolicyInstancesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListTrafficPolicyInstancesError> for Error {
    fn from(err: crate::error::ListTrafficPolicyInstancesError) -> Self {
        match err {
            crate::error::ListTrafficPolicyInstancesError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::ListTrafficPolicyInstancesError::NoSuchTrafficPolicyInstance(inner) => {
                Error::NoSuchTrafficPolicyInstance(inner)
            }
            crate::error::ListTrafficPolicyInstancesError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::ListTrafficPolicyInstancesByHostedZoneError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::ListTrafficPolicyInstancesByHostedZoneError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListTrafficPolicyInstancesByHostedZoneError> for Error {
    fn from(err: crate::error::ListTrafficPolicyInstancesByHostedZoneError) -> Self {
        match err {
            crate::error::ListTrafficPolicyInstancesByHostedZoneError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::ListTrafficPolicyInstancesByHostedZoneError::NoSuchHostedZone(inner) => Error::NoSuchHostedZone(inner),
            crate::error::ListTrafficPolicyInstancesByHostedZoneError::NoSuchTrafficPolicyInstance(inner) => Error::NoSuchTrafficPolicyInstance(inner),
            crate::error::ListTrafficPolicyInstancesByHostedZoneError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<crate::error::ListTrafficPolicyInstancesByPolicyError, R>,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::ListTrafficPolicyInstancesByPolicyError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListTrafficPolicyInstancesByPolicyError> for Error {
    fn from(err: crate::error::ListTrafficPolicyInstancesByPolicyError) -> Self {
        match err {
            crate::error::ListTrafficPolicyInstancesByPolicyError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::ListTrafficPolicyInstancesByPolicyError::NoSuchTrafficPolicy(inner) => {
                Error::NoSuchTrafficPolicy(inner)
            }
            crate::error::ListTrafficPolicyInstancesByPolicyError::NoSuchTrafficPolicyInstance(
                inner,
            ) => Error::NoSuchTrafficPolicyInstance(inner),
            crate::error::ListTrafficPolicyInstancesByPolicyError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTrafficPolicyVersionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListTrafficPolicyVersionsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListTrafficPolicyVersionsError> for Error {
    fn from(err: crate::error::ListTrafficPolicyVersionsError) -> Self {
        match err {
            crate::error::ListTrafficPolicyVersionsError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::ListTrafficPolicyVersionsError::NoSuchTrafficPolicy(inner) => {
                Error::NoSuchTrafficPolicy(inner)
            }
            crate::error::ListTrafficPolicyVersionsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::ListVPCAssociationAuthorizationsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::ListVPCAssociationAuthorizationsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListVPCAssociationAuthorizationsError> for Error {
    fn from(err: crate::error::ListVPCAssociationAuthorizationsError) -> Self {
        match err {
            crate::error::ListVPCAssociationAuthorizationsError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::ListVPCAssociationAuthorizationsError::InvalidPaginationToken(inner) => {
                Error::InvalidPaginationToken(inner)
            }
            crate::error::ListVPCAssociationAuthorizationsError::NoSuchHostedZone(inner) => {
                Error::NoSuchHostedZone(inner)
            }
            crate::error::ListVPCAssociationAuthorizationsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::TestDNSAnswerError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::TestDNSAnswerError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::TestDNSAnswerError> for Error {
    fn from(err: crate::error::TestDNSAnswerError) -> Self {
        match err {
            crate::error::TestDNSAnswerError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::TestDNSAnswerError::NoSuchHostedZone(inner) => {
                Error::NoSuchHostedZone(inner)
            }
            crate::error::TestDNSAnswerError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateHealthCheckError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateHealthCheckError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateHealthCheckError> for Error {
    fn from(err: crate::error::UpdateHealthCheckError) -> Self {
        match err {
            crate::error::UpdateHealthCheckError::HealthCheckVersionMismatch(inner) => {
                Error::HealthCheckVersionMismatch(inner)
            }
            crate::error::UpdateHealthCheckError::InvalidInput(inner) => Error::InvalidInput(inner),
            crate::error::UpdateHealthCheckError::NoSuchHealthCheck(inner) => {
                Error::NoSuchHealthCheck(inner)
            }
            crate::error::UpdateHealthCheckError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateHostedZoneCommentError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateHostedZoneCommentError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateHostedZoneCommentError> for Error {
    fn from(err: crate::error::UpdateHostedZoneCommentError) -> Self {
        match err {
            crate::error::UpdateHostedZoneCommentError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::UpdateHostedZoneCommentError::NoSuchHostedZone(inner) => {
                Error::NoSuchHostedZone(inner)
            }
            crate::error::UpdateHostedZoneCommentError::PriorRequestNotComplete(inner) => {
                Error::PriorRequestNotComplete(inner)
            }
            crate::error::UpdateHostedZoneCommentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateTrafficPolicyCommentError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateTrafficPolicyCommentError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateTrafficPolicyCommentError> for Error {
    fn from(err: crate::error::UpdateTrafficPolicyCommentError) -> Self {
        match err {
            crate::error::UpdateTrafficPolicyCommentError::ConcurrentModification(inner) => {
                Error::ConcurrentModification(inner)
            }
            crate::error::UpdateTrafficPolicyCommentError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::UpdateTrafficPolicyCommentError::NoSuchTrafficPolicy(inner) => {
                Error::NoSuchTrafficPolicy(inner)
            }
            crate::error::UpdateTrafficPolicyCommentError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateTrafficPolicyInstanceError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateTrafficPolicyInstanceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateTrafficPolicyInstanceError> for Error {
    fn from(err: crate::error::UpdateTrafficPolicyInstanceError) -> Self {
        match err {
            crate::error::UpdateTrafficPolicyInstanceError::ConflictingTypes(inner) => {
                Error::ConflictingTypes(inner)
            }
            crate::error::UpdateTrafficPolicyInstanceError::InvalidInput(inner) => {
                Error::InvalidInput(inner)
            }
            crate::error::UpdateTrafficPolicyInstanceError::NoSuchTrafficPolicy(inner) => {
                Error::NoSuchTrafficPolicy(inner)
            }
            crate::error::UpdateTrafficPolicyInstanceError::NoSuchTrafficPolicyInstance(inner) => {
                Error::NoSuchTrafficPolicyInstance(inner)
            }
            crate::error::UpdateTrafficPolicyInstanceError::PriorRequestNotComplete(inner) => {
                Error::PriorRequestNotComplete(inner)
            }
            crate::error::UpdateTrafficPolicyInstanceError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::CidrBlockInUseException(e) => e.request_id(),
            Self::CidrCollectionAlreadyExistsException(e) => e.request_id(),
            Self::CidrCollectionInUseException(e) => e.request_id(),
            Self::CidrCollectionVersionMismatchException(e) => e.request_id(),
            Self::ConcurrentModification(e) => e.request_id(),
            Self::ConflictingDomainExists(e) => e.request_id(),
            Self::ConflictingTypes(e) => e.request_id(),
            Self::DnssecNotFound(e) => e.request_id(),
            Self::DelegationSetAlreadyCreated(e) => e.request_id(),
            Self::DelegationSetAlreadyReusable(e) => e.request_id(),
            Self::DelegationSetInUse(e) => e.request_id(),
            Self::DelegationSetNotAvailable(e) => e.request_id(),
            Self::DelegationSetNotReusable(e) => e.request_id(),
            Self::HealthCheckAlreadyExists(e) => e.request_id(),
            Self::HealthCheckInUse(e) => e.request_id(),
            Self::HealthCheckVersionMismatch(e) => e.request_id(),
            Self::HostedZoneAlreadyExists(e) => e.request_id(),
            Self::HostedZoneNotEmpty(e) => e.request_id(),
            Self::HostedZoneNotFound(e) => e.request_id(),
            Self::HostedZoneNotPrivate(e) => e.request_id(),
            Self::HostedZonePartiallyDelegated(e) => e.request_id(),
            Self::IncompatibleVersion(e) => e.request_id(),
            Self::InsufficientCloudWatchLogsResourcePolicy(e) => e.request_id(),
            Self::InvalidArgument(e) => e.request_id(),
            Self::InvalidChangeBatch(e) => e.request_id(),
            Self::InvalidDomainName(e) => e.request_id(),
            Self::InvalidInput(e) => e.request_id(),
            Self::InvalidKmsArn(e) => e.request_id(),
            Self::InvalidKeySigningKeyName(e) => e.request_id(),
            Self::InvalidKeySigningKeyStatus(e) => e.request_id(),
            Self::InvalidPaginationToken(e) => e.request_id(),
            Self::InvalidSigningStatus(e) => e.request_id(),
            Self::InvalidTrafficPolicyDocument(e) => e.request_id(),
            Self::InvalidVpcId(e) => e.request_id(),
            Self::KeySigningKeyAlreadyExists(e) => e.request_id(),
            Self::KeySigningKeyInParentDsRecord(e) => e.request_id(),
            Self::KeySigningKeyInUse(e) => e.request_id(),
            Self::KeySigningKeyWithActiveStatusNotFound(e) => e.request_id(),
            Self::LastVpcAssociation(e) => e.request_id(),
            Self::LimitsExceeded(e) => e.request_id(),
            Self::NoSuchChange(e) => e.request_id(),
            Self::NoSuchCidrCollectionException(e) => e.request_id(),
            Self::NoSuchCidrLocationException(e) => e.request_id(),
            Self::NoSuchCloudWatchLogsLogGroup(e) => e.request_id(),
            Self::NoSuchDelegationSet(e) => e.request_id(),
            Self::NoSuchGeoLocation(e) => e.request_id(),
            Self::NoSuchHealthCheck(e) => e.request_id(),
            Self::NoSuchHostedZone(e) => e.request_id(),
            Self::NoSuchKeySigningKey(e) => e.request_id(),
            Self::NoSuchQueryLoggingConfig(e) => e.request_id(),
            Self::NoSuchTrafficPolicy(e) => e.request_id(),
            Self::NoSuchTrafficPolicyInstance(e) => e.request_id(),
            Self::NotAuthorizedException(e) => e.request_id(),
            Self::PriorRequestNotComplete(e) => e.request_id(),
            Self::PublicZoneVpcAssociation(e) => e.request_id(),
            Self::QueryLoggingConfigAlreadyExists(e) => e.request_id(),
            Self::ThrottlingException(e) => e.request_id(),
            Self::TooManyHealthChecks(e) => e.request_id(),
            Self::TooManyHostedZones(e) => e.request_id(),
            Self::TooManyKeySigningKeys(e) => e.request_id(),
            Self::TooManyTrafficPolicies(e) => e.request_id(),
            Self::TooManyTrafficPolicyInstances(e) => e.request_id(),
            Self::TooManyTrafficPolicyVersionsForCurrentPolicy(e) => e.request_id(),
            Self::TooManyVpcAssociationAuthorizations(e) => e.request_id(),
            Self::TrafficPolicyAlreadyExists(e) => e.request_id(),
            Self::TrafficPolicyInUse(e) => e.request_id(),
            Self::TrafficPolicyInstanceAlreadyExists(e) => e.request_id(),
            Self::VpcAssociationAuthorizationNotFound(e) => e.request_id(),
            Self::VpcAssociationNotFound(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}
