// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Activates a key-signing key (KSK) so that it can be used for signing by DNSSEC. This operation changes the
/// KSK status to <code>ACTIVE</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ActivateKeySigningKey {
    _private: (),
}
impl ActivateKeySigningKey {
    /// Creates a new builder-style object to manufacture [`ActivateKeySigningKeyInput`](crate::input::ActivateKeySigningKeyInput)
    pub fn builder() -> crate::input::activate_key_signing_key_input::Builder {
        crate::input::activate_key_signing_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ActivateKeySigningKey {
    type Output = std::result::Result<
        crate::output::ActivateKeySigningKeyOutput,
        crate::error::ActivateKeySigningKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_activate_key_signing_key_error(response)
        } else {
            crate::operation_deser::parse_activate_key_signing_key_response(response)
        }
    }
}

/// <p>Associates an Amazon VPC with a private hosted zone. </p>
/// <important>
/// <p>To perform the association, the VPC and the private hosted zone must already exist.
/// You can't convert a public hosted zone into a private hosted zone.</p>
/// </important>
/// <note>
/// <p>If you want to associate a VPC that was created by using one Amazon Web Services account with a private hosted zone that was created
/// by using a different account, the Amazon Web Services account that created the private hosted zone must first submit a
/// <code>CreateVPCAssociationAuthorization</code> request. Then the account that created the VPC must submit an
/// <code>AssociateVPCWithHostedZone</code> request.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociateVPCWithHostedZone {
    _private: (),
}
impl AssociateVPCWithHostedZone {
    /// Creates a new builder-style object to manufacture [`AssociateVpcWithHostedZoneInput`](crate::input::AssociateVpcWithHostedZoneInput)
    pub fn builder() -> crate::input::associate_vpc_with_hosted_zone_input::Builder {
        crate::input::associate_vpc_with_hosted_zone_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociateVPCWithHostedZone {
    type Output = std::result::Result<
        crate::output::AssociateVpcWithHostedZoneOutput,
        crate::error::AssociateVPCWithHostedZoneError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_associate_vpc_with_hosted_zone_error(response)
        } else {
            crate::operation_deser::parse_associate_vpc_with_hosted_zone_response(response)
        }
    }
}

/// <p>Creates, changes, or deletes a resource record set, which contains authoritative DNS information for a specified
/// domain name or subdomain name. For example, you can use <code>ChangeResourceRecordSets</code> to create a resource record set that
/// routes traffic for test.example.com to a web server that has an IP address of 192.0.2.44.</p>
/// <p>
/// <b>Deleting Resource Record Sets</b>
/// </p>
/// <p>To delete a resource record set, you must specify all the same values that you specified when you created it.</p>
/// <p>
/// <b>Change Batches and Transactional Changes</b>
/// </p>
/// <p>The request body must include a document with a <code>ChangeResourceRecordSetsRequest</code> element.
/// The request body contains a list of change items, known as a change batch. Change batches are considered transactional changes.
/// Route 53 validates the changes in the request and then either makes all or none of the changes in the change batch request.
/// This ensures that DNS routing isn't adversely affected by partial changes to the resource record sets in a hosted zone. </p>
/// <p>For example, suppose a change batch request contains two changes: it deletes the <code>CNAME</code> resource record set for www.example.com and
/// creates an alias resource record set for www.example.com. If validation for both records succeeds, Route 53 deletes the first resource record set and
/// creates the second resource record set in a single operation. If validation for either the <code>DELETE</code> or the <code>CREATE</code> action fails,
/// then the request is canceled, and the original <code>CNAME</code> record continues to exist.</p>
/// <note>
/// <p>If you try to delete the same resource record set more than once in a single change batch, Route 53 returns an <code>InvalidChangeBatch</code> error.</p>
/// </note>
/// <p>
/// <b>Traffic Flow</b>
/// </p>
/// <p>To create resource record sets for complex routing configurations, use either the traffic flow visual editor in the
/// Route 53 console or the API actions for traffic policies and traffic policy instances. Save the configuration as a traffic policy,
/// then associate the traffic policy with one or more domain names (such as example.com) or subdomain names (such as www.example.com),
/// in the same hosted zone or in multiple hosted zones. You can roll back the updates if the new configuration isn't performing
/// as expected. For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/traffic-flow.html">Using Traffic Flow to Route DNS Traffic</a>
/// in the <i>Amazon Route 53 Developer Guide</i>.</p>
/// <p>
/// <b>Create, Delete, and Upsert</b>
/// </p>
/// <p>Use <code>ChangeResourceRecordsSetsRequest</code> to perform the following actions:</p>
/// <ul>
/// <li>
/// <p>
/// <code>CREATE</code>: Creates a resource record set that has the specified values.</p>
/// </li>
/// <li>
/// <p>
/// <code>DELETE</code>: Deletes an existing resource record set that has the specified values.</p>
/// </li>
/// <li>
/// <p>
/// <code>UPSERT</code>: If a resource record set does not already exist, Amazon Web Services creates it.
/// If a resource set does exist, Route 53 updates it with the values in the request. </p>
/// </li>
/// </ul>
/// <p>
/// <b>Syntaxes for Creating, Updating, and Deleting Resource Record Sets</b>
/// </p>
/// <p>The syntax for a request depends on the type of resource record set that you want to create, delete, or update, such as
/// weighted, alias, or failover. The XML elements in your request must appear in the order listed in the syntax. </p>
/// <p>For an example for each type of resource record set, see "Examples."</p>
/// <p>Don't refer to the syntax in the "Parameter Syntax" section, which includes all of the elements for every kind of
/// resource record set that you can create, delete, or update by using <code>ChangeResourceRecordSets</code>. </p>
/// <p>
/// <b>Change Propagation to Route 53 DNS Servers</b>
/// </p>
/// <p>When you submit a <code>ChangeResourceRecordSets</code> request, Route 53 propagates your changes to all of the
/// Route 53 authoritative DNS servers. While your changes are propagating, <code>GetChange</code> returns a status of
/// <code>PENDING</code>. When propagation is complete, <code>GetChange</code> returns a status of <code>INSYNC</code>.
/// Changes generally propagate to all Route 53 name servers within 60 seconds. For more information, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetChange.html">GetChange</a>.</p>
/// <p>
/// <b>Limits on ChangeResourceRecordSets Requests</b>
/// </p>
/// <p>For information about the limits on a <code>ChangeResourceRecordSets</code> request, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a> in the
/// <i>Amazon Route 53 Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ChangeResourceRecordSets {
    _private: (),
}
impl ChangeResourceRecordSets {
    /// Creates a new builder-style object to manufacture [`ChangeResourceRecordSetsInput`](crate::input::ChangeResourceRecordSetsInput)
    pub fn builder() -> crate::input::change_resource_record_sets_input::Builder {
        crate::input::change_resource_record_sets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ChangeResourceRecordSets {
    type Output = std::result::Result<
        crate::output::ChangeResourceRecordSetsOutput,
        crate::error::ChangeResourceRecordSetsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_change_resource_record_sets_error(response)
        } else {
            crate::operation_deser::parse_change_resource_record_sets_response(response)
        }
    }
}

/// <p>Adds, edits, or deletes tags for a health check or a hosted zone.</p>
/// <p>For information about using tags for cost allocation, see
/// <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation Tags</a>
/// in the <i>Billing and Cost Management User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ChangeTagsForResource {
    _private: (),
}
impl ChangeTagsForResource {
    /// Creates a new builder-style object to manufacture [`ChangeTagsForResourceInput`](crate::input::ChangeTagsForResourceInput)
    pub fn builder() -> crate::input::change_tags_for_resource_input::Builder {
        crate::input::change_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ChangeTagsForResource {
    type Output = std::result::Result<
        crate::output::ChangeTagsForResourceOutput,
        crate::error::ChangeTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_change_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_change_tags_for_resource_response(response)
        }
    }
}

/// <p>Creates a new health check.</p>
/// <p>For information about adding health checks to resource record sets, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ResourceRecordSet.html#Route53-Type-ResourceRecordSet-HealthCheckId">HealthCheckId</a>
/// in
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ChangeResourceRecordSets.html">ChangeResourceRecordSets</a>. </p>
/// <p>
/// <b>ELB Load Balancers</b>
/// </p>
/// <p>If you're registering EC2 instances with an Elastic Load Balancing (ELB) load balancer, do not create Amazon Route 53 health checks for the
/// EC2 instances. When you register an EC2 instance with a load balancer, you configure settings for an ELB health check, which performs a
/// similar function to a Route 53 health check.</p>
/// <p>
/// <b>Private Hosted Zones</b>
/// </p>
/// <p>You can associate health checks with failover resource record sets in a private hosted zone. Note the following:</p>
/// <ul>
/// <li>
/// <p>Route 53 health checkers are outside the VPC. To check the health of an endpoint within a VPC by IP address, you must
/// assign a public IP address to the instance in the VPC.</p>
/// </li>
/// <li>
/// <p>You can configure a health checker to check the health of an external resource that the instance relies on, such as a
/// database server.</p>
/// </li>
/// <li>
/// <p>You can create a CloudWatch metric, associate an alarm with the metric, and then create a health check that is based on the
/// state of the alarm. For example, you might create a CloudWatch metric that checks the status of the Amazon EC2 <code>StatusCheckFailed</code> metric,
/// add an alarm to the metric, and then create a health check that is based on the state of the alarm. For information about creating
/// CloudWatch metrics and alarms by using the CloudWatch console, see the
/// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateHealthCheck {
    _private: (),
}
impl CreateHealthCheck {
    /// Creates a new builder-style object to manufacture [`CreateHealthCheckInput`](crate::input::CreateHealthCheckInput)
    pub fn builder() -> crate::input::create_health_check_input::Builder {
        crate::input::create_health_check_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateHealthCheck {
    type Output = std::result::Result<
        crate::output::CreateHealthCheckOutput,
        crate::error::CreateHealthCheckError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_health_check_error(response)
        } else {
            crate::operation_deser::parse_create_health_check_response(response)
        }
    }
}

/// <p>Creates a new public or private hosted zone. You create records in a public hosted zone to define how you want to route traffic
/// on the internet for a domain, such as example.com, and its subdomains (apex.example.com, acme.example.com). You create records in a
/// private hosted zone to define how you want to route traffic for a domain and its subdomains within one or more
/// Amazon Virtual Private Clouds (Amazon VPCs). </p>
/// <important>
/// <p>You can't convert a public hosted zone to a private hosted zone or vice versa. Instead, you must create a new hosted zone
/// with the same name and create new resource record sets.</p>
/// </important>
/// <p>For more information about charges for hosted zones, see <a href="http://aws.amazon.com/route53/pricing/">Amazon Route 53 Pricing</a>.</p>
/// <p>Note the following:</p>
/// <ul>
/// <li>
/// <p>You can't create a hosted zone for a top-level domain (TLD) such as .com.</p>
/// </li>
/// <li>
/// <p>For public hosted zones, Route 53 automatically creates a default SOA record and four NS records for the zone.
/// For more information about SOA and NS records, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/SOA-NSrecords.html">NS and SOA Records that Route 53 Creates for a Hosted Zone</a> in the
/// <i>Amazon Route 53 Developer Guide</i>.</p>
/// <p>If you want to use the same name servers for multiple public hosted zones, you can optionally associate a reusable delegation set
/// with the hosted zone. See the <code>DelegationSetId</code> element.</p>
/// </li>
/// <li>
/// <p>If your domain is registered with a registrar other than Route 53, you must update the name servers with your registrar to make
/// Route 53 the DNS service for the domain. For more information, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/MigratingDNS.html">Migrating DNS Service for an Existing Domain to Amazon Route 53</a> in the
/// <i>Amazon Route 53 Developer Guide</i>. </p>
/// </li>
/// </ul>
/// <p>When you submit a <code>CreateHostedZone</code> request, the initial status of the hosted zone is <code>PENDING</code>.
/// For public hosted zones, this means that the NS and SOA records are not yet available on all Route 53 DNS servers. When the
/// NS and SOA records are available, the status of the zone changes to <code>INSYNC</code>.</p>
/// <p>The <code>CreateHostedZone</code> request requires the caller to have an <code>ec2:DescribeVpcs</code> permission.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateHostedZone {
    _private: (),
}
impl CreateHostedZone {
    /// Creates a new builder-style object to manufacture [`CreateHostedZoneInput`](crate::input::CreateHostedZoneInput)
    pub fn builder() -> crate::input::create_hosted_zone_input::Builder {
        crate::input::create_hosted_zone_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateHostedZone {
    type Output = std::result::Result<
        crate::output::CreateHostedZoneOutput,
        crate::error::CreateHostedZoneError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_hosted_zone_error(response)
        } else {
            crate::operation_deser::parse_create_hosted_zone_response(response)
        }
    }
}

/// <p>Creates a new key-signing key (KSK) associated with a hosted zone. You can only have two KSKs per hosted zone.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateKeySigningKey {
    _private: (),
}
impl CreateKeySigningKey {
    /// Creates a new builder-style object to manufacture [`CreateKeySigningKeyInput`](crate::input::CreateKeySigningKeyInput)
    pub fn builder() -> crate::input::create_key_signing_key_input::Builder {
        crate::input::create_key_signing_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateKeySigningKey {
    type Output = std::result::Result<
        crate::output::CreateKeySigningKeyOutput,
        crate::error::CreateKeySigningKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_key_signing_key_error(response)
        } else {
            crate::operation_deser::parse_create_key_signing_key_response(response)
        }
    }
}

/// <p>Creates a configuration for DNS query logging. After you create a query logging configuration, Amazon Route 53 begins to publish
/// log data to an Amazon CloudWatch Logs log group.</p>
/// <p>DNS query logs contain information about the queries that Route 53 receives for a specified public hosted zone, such as the following:</p>
/// <ul>
/// <li>
/// <p>Route 53 edge location that responded to the DNS query</p>
/// </li>
/// <li>
/// <p>Domain or subdomain that was requested</p>
/// </li>
/// <li>
/// <p>DNS record type, such as A or AAAA</p>
/// </li>
/// <li>
/// <p>DNS response code, such as <code>NoError</code> or <code>ServFail</code>
/// </p>
/// </li>
/// </ul>
/// <dl>
/// <dt>Log Group and Resource Policy</dt>
/// <dd>
/// <p>Before you create a query logging configuration, perform the following operations.</p>
/// <note>
/// <p>If you create a query logging configuration using the Route 53 console, Route 53 performs these operations automatically.</p>
/// </note>
/// <ol>
/// <li>
/// <p>Create a CloudWatch Logs log group, and make note of the ARN, which you specify when you create a
/// query logging configuration. Note the following:</p>
/// <ul>
/// <li>
/// <p>You must create the log group in the us-east-1 region.</p>
/// </li>
/// <li>
/// <p>You must use the same Amazon Web Services account to create the log group and the hosted zone that you want to
/// configure query logging for.</p>
/// </li>
/// <li>
/// <p>When you create log groups for query logging, we recommend that you use a consistent prefix, for example:</p>
/// <p>
/// <code>/aws/route53/<i>hosted zone name</i>
/// </code>
/// </p>
/// <p>In the next step, you'll create a resource policy, which controls access to one or more log groups and the associated
/// Amazon Web Services resources, such as Route 53 hosted zones. There's a limit on the number of resource policies that you can create, so
/// we recommend that you use a consistent prefix so you can use the same resource policy for all the log groups that you create
/// for query logging.</p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Create a CloudWatch Logs resource policy, and give it the permissions that Route 53 needs to create log streams and to
/// send query logs to log streams. For the value of <code>Resource</code>, specify the ARN for the log group that you created
/// in the previous step. To use the same resource policy for all the CloudWatch Logs log groups that you created for query logging configurations,
/// replace the hosted zone name with <code>*</code>, for example:</p>
/// <p>
/// <code>arn:aws:logs:us-east-1:123412341234:log-group:/aws/route53/*</code>
/// </p>
/// <note>
/// <p>You can't use the CloudWatch console to create or edit a resource policy. You must use the CloudWatch API, one of the Amazon Web Services SDKs,
/// or the CLI.</p>
/// </note>
/// </li>
/// </ol>
/// </dd>
/// <dt>Log Streams and Edge Locations</dt>
/// <dd>
/// <p>When Route 53 finishes creating the configuration for DNS query logging, it does the following:</p>
/// <ul>
/// <li>
/// <p>Creates a log stream for an edge location the first time that the edge location responds to DNS queries for the
/// specified hosted zone. That log stream is used to log all queries that Route 53 responds to for that edge location.</p>
/// </li>
/// <li>
/// <p>Begins to send query logs to the applicable log stream.</p>
/// </li>
/// </ul>
/// <p>The name of each log stream is in the following format:</p>
/// <p>
/// <code>
/// <i>hosted zone ID</i>/<i>edge location code</i>
/// </code>
/// </p>
/// <p>The edge location code is a three-letter code and an arbitrarily assigned number, for example, DFW3. The three-letter code
/// typically corresponds with the International Air Transport Association airport code for an airport near the edge location.
/// (These abbreviations might change in the future.) For a list of edge locations, see "The Route 53 Global Network" on the
/// <a href="http://aws.amazon.com/route53/details/">Route 53 Product Details</a> page.</p>
/// </dd>
/// <dt>Queries That Are Logged</dt>
/// <dd>
/// <p>Query logs contain only the queries that DNS resolvers forward to Route 53. If a DNS resolver has already cached
/// the response to a query (such as the IP address for a load balancer for example.com), the resolver will continue to return
/// the cached response. It doesn't forward another query to Route 53 until the TTL for the corresponding resource record set expires.
/// Depending on how many DNS queries are submitted for a resource record set, and depending on the TTL for that resource record set,
/// query logs might contain information about only one query out of every several thousand queries that are submitted to DNS.
/// For more information about how DNS works, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/welcome-dns-service.html">Routing Internet Traffic to Your Website or Web Application</a>
/// in the <i>Amazon Route 53 Developer Guide</i>.</p>
/// </dd>
/// <dt>Log File Format</dt>
/// <dd>
/// <p>For a list of the values in each query log and the format of each value, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/query-logs.html">Logging DNS Queries</a> in the
/// <i>Amazon Route 53 Developer Guide</i>.</p>
/// </dd>
/// <dt>Pricing</dt>
/// <dd>
/// <p>For information about charges for query logs, see
/// <a href="http://aws.amazon.com/cloudwatch/pricing/">Amazon CloudWatch Pricing</a>.</p>
/// </dd>
/// <dt>How to Stop Logging</dt>
/// <dd>
/// <p>If you want Route 53 to stop sending query logs to CloudWatch Logs, delete the query logging configuration. For more information, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_DeleteQueryLoggingConfig.html">DeleteQueryLoggingConfig</a>.</p>
/// </dd>
/// </dl>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateQueryLoggingConfig {
    _private: (),
}
impl CreateQueryLoggingConfig {
    /// Creates a new builder-style object to manufacture [`CreateQueryLoggingConfigInput`](crate::input::CreateQueryLoggingConfigInput)
    pub fn builder() -> crate::input::create_query_logging_config_input::Builder {
        crate::input::create_query_logging_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateQueryLoggingConfig {
    type Output = std::result::Result<
        crate::output::CreateQueryLoggingConfigOutput,
        crate::error::CreateQueryLoggingConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_query_logging_config_error(response)
        } else {
            crate::operation_deser::parse_create_query_logging_config_response(response)
        }
    }
}

/// <p>Creates a delegation set (a group of four name servers) that can be reused by multiple hosted zones that were created by
/// the same Amazon Web Services account. </p>
/// <p>You can also create a reusable delegation set that uses the four name servers that are associated
/// with an existing hosted zone. Specify the hosted zone ID in the <code>CreateReusableDelegationSet</code> request.</p>
/// <note>
/// <p>You can't associate a reusable delegation set with a private hosted zone.</p>
/// </note>
/// <p>For information about using a reusable delegation set to configure white label name servers, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/white-label-name-servers.html">Configuring White Label Name Servers</a>.</p>
/// <p>The process for migrating existing hosted zones to use a reusable delegation set is comparable to the process for
/// configuring white label name servers. You need to perform the following steps:</p>
/// <ol>
/// <li>
/// <p>Create a reusable delegation set.</p>
/// </li>
/// <li>
/// <p>Recreate hosted zones, and reduce the TTL to 60 seconds or less.</p>
/// </li>
/// <li>
/// <p>Recreate resource record sets in the new hosted zones.</p>
/// </li>
/// <li>
/// <p>Change the registrar's name servers to use the name servers for the new hosted zones.</p>
/// </li>
/// <li>
/// <p>Monitor traffic for the website or application.</p>
/// </li>
/// <li>
/// <p>Change TTLs back to their original values.</p>
/// </li>
/// </ol>
/// <p>If you want to migrate existing hosted zones to use a reusable delegation set, the existing hosted zones can't use
/// any of the name servers that are assigned to the reusable delegation set. If one or more hosted zones do use one or more
/// name servers that are assigned to the reusable delegation set, you can do one of the following:</p>
/// <ul>
/// <li>
/// <p>For small numbers of hosted zones—up to a few hundred—it's relatively easy to create
/// reusable delegation sets until you get one that has four name servers that don't overlap with any of the name servers
/// in your hosted zones.</p>
/// </li>
/// <li>
/// <p>For larger numbers of hosted zones, the easiest solution is to use more than one reusable delegation set.</p>
/// </li>
/// <li>
/// <p>For larger numbers of hosted zones, you can also migrate hosted zones that have overlapping name servers
/// to hosted zones that don't have overlapping name servers, then migrate the hosted zones again to use the
/// reusable delegation set.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateReusableDelegationSet {
    _private: (),
}
impl CreateReusableDelegationSet {
    /// Creates a new builder-style object to manufacture [`CreateReusableDelegationSetInput`](crate::input::CreateReusableDelegationSetInput)
    pub fn builder() -> crate::input::create_reusable_delegation_set_input::Builder {
        crate::input::create_reusable_delegation_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateReusableDelegationSet {
    type Output = std::result::Result<
        crate::output::CreateReusableDelegationSetOutput,
        crate::error::CreateReusableDelegationSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_reusable_delegation_set_error(response)
        } else {
            crate::operation_deser::parse_create_reusable_delegation_set_response(response)
        }
    }
}

/// <p>Creates a traffic policy, which you use to create multiple DNS resource record sets for one domain name (such as example.com) or
/// one subdomain name (such as www.example.com).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateTrafficPolicy {
    _private: (),
}
impl CreateTrafficPolicy {
    /// Creates a new builder-style object to manufacture [`CreateTrafficPolicyInput`](crate::input::CreateTrafficPolicyInput)
    pub fn builder() -> crate::input::create_traffic_policy_input::Builder {
        crate::input::create_traffic_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateTrafficPolicy {
    type Output = std::result::Result<
        crate::output::CreateTrafficPolicyOutput,
        crate::error::CreateTrafficPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_traffic_policy_error(response)
        } else {
            crate::operation_deser::parse_create_traffic_policy_response(response)
        }
    }
}

/// <p>Creates resource record sets in a specified hosted zone based on the settings in a specified traffic policy version.
/// In addition, <code>CreateTrafficPolicyInstance</code> associates the resource record sets with a specified domain name (such as example.com) or
/// subdomain name (such as www.example.com). Amazon Route 53 responds to DNS queries for the domain or subdomain name by using the resource record sets
/// that <code>CreateTrafficPolicyInstance</code> created.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateTrafficPolicyInstance {
    _private: (),
}
impl CreateTrafficPolicyInstance {
    /// Creates a new builder-style object to manufacture [`CreateTrafficPolicyInstanceInput`](crate::input::CreateTrafficPolicyInstanceInput)
    pub fn builder() -> crate::input::create_traffic_policy_instance_input::Builder {
        crate::input::create_traffic_policy_instance_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateTrafficPolicyInstance {
    type Output = std::result::Result<
        crate::output::CreateTrafficPolicyInstanceOutput,
        crate::error::CreateTrafficPolicyInstanceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_traffic_policy_instance_error(response)
        } else {
            crate::operation_deser::parse_create_traffic_policy_instance_response(response)
        }
    }
}

/// <p>Creates a new version of an existing traffic policy. When you create a new version of a traffic policy, you specify the ID of the
/// traffic policy that you want to update and a JSON-formatted document that describes the new version. You use traffic policies to create
/// multiple DNS resource record sets for one domain name (such as example.com) or one subdomain name (such as www.example.com). You can
/// create a maximum of 1000 versions of a traffic policy. If you reach the limit and need to create another version, you'll need to start a new
/// traffic policy.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateTrafficPolicyVersion {
    _private: (),
}
impl CreateTrafficPolicyVersion {
    /// Creates a new builder-style object to manufacture [`CreateTrafficPolicyVersionInput`](crate::input::CreateTrafficPolicyVersionInput)
    pub fn builder() -> crate::input::create_traffic_policy_version_input::Builder {
        crate::input::create_traffic_policy_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateTrafficPolicyVersion {
    type Output = std::result::Result<
        crate::output::CreateTrafficPolicyVersionOutput,
        crate::error::CreateTrafficPolicyVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_traffic_policy_version_error(response)
        } else {
            crate::operation_deser::parse_create_traffic_policy_version_response(response)
        }
    }
}

/// <p>Authorizes the Amazon Web Services account that created a specified VPC to submit an <code>AssociateVPCWithHostedZone</code>
/// request to associate the VPC with a specified hosted zone that was created by a different account.
/// To submit a <code>CreateVPCAssociationAuthorization</code> request, you must use the account that created the
/// hosted zone. After you authorize the association, use the account that created the VPC to submit an
/// <code>AssociateVPCWithHostedZone</code> request.</p>
/// <note>
/// <p>If you want to associate multiple VPCs that you created by using one account with a hosted zone
/// that you created by using a different account, you must submit one authorization request for each VPC.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateVPCAssociationAuthorization {
    _private: (),
}
impl CreateVPCAssociationAuthorization {
    /// Creates a new builder-style object to manufacture [`CreateVpcAssociationAuthorizationInput`](crate::input::CreateVpcAssociationAuthorizationInput)
    pub fn builder() -> crate::input::create_vpc_association_authorization_input::Builder {
        crate::input::create_vpc_association_authorization_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateVPCAssociationAuthorization {
    type Output = std::result::Result<
        crate::output::CreateVpcAssociationAuthorizationOutput,
        crate::error::CreateVPCAssociationAuthorizationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_vpc_association_authorization_error(response)
        } else {
            crate::operation_deser::parse_create_vpc_association_authorization_response(response)
        }
    }
}

/// <p>Deactivates a key-signing key (KSK) so that it will not be used for signing by DNSSEC. This operation changes the
/// KSK status to <code>INACTIVE</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeactivateKeySigningKey {
    _private: (),
}
impl DeactivateKeySigningKey {
    /// Creates a new builder-style object to manufacture [`DeactivateKeySigningKeyInput`](crate::input::DeactivateKeySigningKeyInput)
    pub fn builder() -> crate::input::deactivate_key_signing_key_input::Builder {
        crate::input::deactivate_key_signing_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeactivateKeySigningKey {
    type Output = std::result::Result<
        crate::output::DeactivateKeySigningKeyOutput,
        crate::error::DeactivateKeySigningKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_deactivate_key_signing_key_error(response)
        } else {
            crate::operation_deser::parse_deactivate_key_signing_key_response(response)
        }
    }
}

/// <p>Deletes a health check.</p>
/// <important>
/// <p>Amazon Route 53 does not prevent you from deleting a health check even if the health check is associated with one or more
/// resource record sets. If you delete a health check and you don't update the associated resource record sets, the future status
/// of the health check can't be predicted and may change. This will affect the routing of DNS queries for your DNS failover
/// configuration. For more information, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/health-checks-creating-deleting.html#health-checks-deleting.html">Replacing and Deleting Health Checks</a>
/// in the <i>Amazon Route 53 Developer Guide</i>.</p>
/// </important>
/// <p>If you're using Cloud Map and you configured Cloud Map to create a Route 53 health check when you register an instance,
/// you can't use the Route 53 <code>DeleteHealthCheck</code> command to delete the health check. The health check is deleted
/// automatically when you deregister the instance; there can be a delay of several hours before the health check is deleted
/// from Route 53. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteHealthCheck {
    _private: (),
}
impl DeleteHealthCheck {
    /// Creates a new builder-style object to manufacture [`DeleteHealthCheckInput`](crate::input::DeleteHealthCheckInput)
    pub fn builder() -> crate::input::delete_health_check_input::Builder {
        crate::input::delete_health_check_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteHealthCheck {
    type Output = std::result::Result<
        crate::output::DeleteHealthCheckOutput,
        crate::error::DeleteHealthCheckError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_health_check_error(response)
        } else {
            crate::operation_deser::parse_delete_health_check_response(response)
        }
    }
}

/// <p>Deletes a hosted zone.</p>
/// <p>If the hosted zone was created by another service, such as Cloud Map, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DeleteHostedZone.html#delete-public-hosted-zone-created-by-another-service">Deleting
/// Public Hosted Zones That Were Created by Another Service</a> in the <i>Amazon Route 53 Developer Guide</i> for information about how to delete it.
/// (The process is the same for public and private hosted zones that were created by another service.)</p>
/// <p>If you want to keep your domain registration but you want to stop routing internet traffic to your website or web application,
/// we recommend that you delete resource record sets in the hosted zone instead of deleting the hosted zone.</p>
/// <important>
/// <p>If you delete a hosted zone, you can't undelete it. You must create a new hosted zone and update the name servers for your
/// domain registration, which can require up to 48 hours to take effect. (If you delegated responsibility for a subdomain to a hosted zone
/// and you delete the child hosted zone, you must update the name servers in the parent hosted zone.) In addition, if you delete a hosted zone,
/// someone could hijack the domain and route traffic to their own resources using your domain name.</p>
/// </important>
/// <p>If you want to avoid the monthly charge for the hosted zone, you can transfer DNS service for the domain to a free DNS service.
/// When you transfer DNS service, you have to update the name servers for the domain registration. If the domain is registered with Route 53,
/// see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_UpdateDomainNameservers.html">UpdateDomainNameservers</a>
/// for information about how to replace Route 53 name servers with name servers for the new DNS service. If the domain is registered with
/// another registrar, use the method provided by the registrar to update name servers for the domain registration. For more information,
/// perform an internet search on "free DNS service."</p>
/// <p>You can delete a hosted zone only if it contains only the default SOA record and NS resource record sets.
/// If the hosted zone contains other resource record sets, you must delete them before you can delete the hosted zone.
/// If you try to delete a hosted zone that contains other resource record sets, the request fails, and Route 53 returns a
/// <code>HostedZoneNotEmpty</code> error. For information about deleting records from your hosted zone, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ChangeResourceRecordSets.html">ChangeResourceRecordSets</a>.</p>
/// <p>To verify that the hosted zone has been deleted, do one of the following:</p>
/// <ul>
/// <li>
/// <p>Use the <code>GetHostedZone</code> action to request information about the hosted zone.</p>
/// </li>
/// <li>
/// <p>Use the <code>ListHostedZones</code> action to get a list of the hosted zones associated with the current
/// Amazon Web Services account.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteHostedZone {
    _private: (),
}
impl DeleteHostedZone {
    /// Creates a new builder-style object to manufacture [`DeleteHostedZoneInput`](crate::input::DeleteHostedZoneInput)
    pub fn builder() -> crate::input::delete_hosted_zone_input::Builder {
        crate::input::delete_hosted_zone_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteHostedZone {
    type Output = std::result::Result<
        crate::output::DeleteHostedZoneOutput,
        crate::error::DeleteHostedZoneError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_hosted_zone_error(response)
        } else {
            crate::operation_deser::parse_delete_hosted_zone_response(response)
        }
    }
}

/// <p>Deletes a key-signing key (KSK). Before you can delete a KSK, you must deactivate it. The KSK must be
/// deactivated before you can delete it regardless of whether the hosted zone is enabled for DNSSEC signing.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteKeySigningKey {
    _private: (),
}
impl DeleteKeySigningKey {
    /// Creates a new builder-style object to manufacture [`DeleteKeySigningKeyInput`](crate::input::DeleteKeySigningKeyInput)
    pub fn builder() -> crate::input::delete_key_signing_key_input::Builder {
        crate::input::delete_key_signing_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteKeySigningKey {
    type Output = std::result::Result<
        crate::output::DeleteKeySigningKeyOutput,
        crate::error::DeleteKeySigningKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_key_signing_key_error(response)
        } else {
            crate::operation_deser::parse_delete_key_signing_key_response(response)
        }
    }
}

/// <p>Deletes a configuration for DNS query logging. If you delete a configuration, Amazon Route 53 stops sending query logs to CloudWatch Logs.
/// Route 53 doesn't delete any logs that are already in CloudWatch Logs.</p>
/// <p>For more information about DNS query logs, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateQueryLoggingConfig.html">CreateQueryLoggingConfig</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteQueryLoggingConfig {
    _private: (),
}
impl DeleteQueryLoggingConfig {
    /// Creates a new builder-style object to manufacture [`DeleteQueryLoggingConfigInput`](crate::input::DeleteQueryLoggingConfigInput)
    pub fn builder() -> crate::input::delete_query_logging_config_input::Builder {
        crate::input::delete_query_logging_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteQueryLoggingConfig {
    type Output = std::result::Result<
        crate::output::DeleteQueryLoggingConfigOutput,
        crate::error::DeleteQueryLoggingConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_query_logging_config_error(response)
        } else {
            crate::operation_deser::parse_delete_query_logging_config_response(response)
        }
    }
}

/// <p>Deletes a reusable delegation set.</p>
/// <important>
/// <p>You can delete a reusable delegation set only if it isn't associated with any hosted zones.</p>
/// </important>
/// <p>To verify that the reusable delegation set is not associated with any hosted zones, submit a
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetReusableDelegationSet.html">GetReusableDelegationSet</a>
/// request and specify the ID of the reusable delegation set that you want to delete.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteReusableDelegationSet {
    _private: (),
}
impl DeleteReusableDelegationSet {
    /// Creates a new builder-style object to manufacture [`DeleteReusableDelegationSetInput`](crate::input::DeleteReusableDelegationSetInput)
    pub fn builder() -> crate::input::delete_reusable_delegation_set_input::Builder {
        crate::input::delete_reusable_delegation_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteReusableDelegationSet {
    type Output = std::result::Result<
        crate::output::DeleteReusableDelegationSetOutput,
        crate::error::DeleteReusableDelegationSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_reusable_delegation_set_error(response)
        } else {
            crate::operation_deser::parse_delete_reusable_delegation_set_response(response)
        }
    }
}

/// <p>Deletes a traffic policy.</p>
/// <p>When you delete a traffic policy, Route 53 sets a flag on the policy to indicate that it has been deleted. However, Route 53 never fully deletes
/// the traffic policy. Note the following:</p>
/// <ul>
/// <li>
/// <p>Deleted traffic policies aren't listed if you run <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ListTrafficPolicies.html">ListTrafficPolicies</a>.</p>
/// </li>
/// <li>
/// <p>  There's no way to get a list of deleted policies.</p>
/// </li>
/// <li>
/// <p>If you retain the ID of the policy, you can get information about the policy, including the traffic policy document, by running
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetTrafficPolicy.html">GetTrafficPolicy</a>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTrafficPolicy {
    _private: (),
}
impl DeleteTrafficPolicy {
    /// Creates a new builder-style object to manufacture [`DeleteTrafficPolicyInput`](crate::input::DeleteTrafficPolicyInput)
    pub fn builder() -> crate::input::delete_traffic_policy_input::Builder {
        crate::input::delete_traffic_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTrafficPolicy {
    type Output = std::result::Result<
        crate::output::DeleteTrafficPolicyOutput,
        crate::error::DeleteTrafficPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_traffic_policy_error(response)
        } else {
            crate::operation_deser::parse_delete_traffic_policy_response(response)
        }
    }
}

/// <p>Deletes a traffic policy instance and all of the resource record sets that Amazon Route 53 created when you created the instance.</p>
/// <note>
/// <p>In the Route 53 console, traffic policy instances are known as policy records.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTrafficPolicyInstance {
    _private: (),
}
impl DeleteTrafficPolicyInstance {
    /// Creates a new builder-style object to manufacture [`DeleteTrafficPolicyInstanceInput`](crate::input::DeleteTrafficPolicyInstanceInput)
    pub fn builder() -> crate::input::delete_traffic_policy_instance_input::Builder {
        crate::input::delete_traffic_policy_instance_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTrafficPolicyInstance {
    type Output = std::result::Result<
        crate::output::DeleteTrafficPolicyInstanceOutput,
        crate::error::DeleteTrafficPolicyInstanceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_traffic_policy_instance_error(response)
        } else {
            crate::operation_deser::parse_delete_traffic_policy_instance_response(response)
        }
    }
}

/// <p>Removes authorization to submit an <code>AssociateVPCWithHostedZone</code> request to associate a specified VPC
/// with a hosted zone that was created by a different account. You must use the account that created the hosted zone
/// to submit a <code>DeleteVPCAssociationAuthorization</code> request.</p>
/// <important>
/// <p>Sending this request only prevents the Amazon Web Services account that created the VPC from associating the VPC
/// with the Amazon Route 53 hosted zone in the future. If the VPC is already associated with the hosted zone,
/// <code>DeleteVPCAssociationAuthorization</code> won't disassociate the VPC from the hosted zone.
/// If you want to delete an existing association, use <code>DisassociateVPCFromHostedZone</code>.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteVPCAssociationAuthorization {
    _private: (),
}
impl DeleteVPCAssociationAuthorization {
    /// Creates a new builder-style object to manufacture [`DeleteVpcAssociationAuthorizationInput`](crate::input::DeleteVpcAssociationAuthorizationInput)
    pub fn builder() -> crate::input::delete_vpc_association_authorization_input::Builder {
        crate::input::delete_vpc_association_authorization_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteVPCAssociationAuthorization {
    type Output = std::result::Result<
        crate::output::DeleteVpcAssociationAuthorizationOutput,
        crate::error::DeleteVPCAssociationAuthorizationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_vpc_association_authorization_error(response)
        } else {
            crate::operation_deser::parse_delete_vpc_association_authorization_response(response)
        }
    }
}

/// <p>Disables DNSSEC signing in a specific hosted zone. This action does not deactivate any key-signing keys (KSKs)
/// that are active in the hosted zone.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisableHostedZoneDNSSEC {
    _private: (),
}
impl DisableHostedZoneDNSSEC {
    /// Creates a new builder-style object to manufacture [`DisableHostedZoneDnssecInput`](crate::input::DisableHostedZoneDnssecInput)
    pub fn builder() -> crate::input::disable_hosted_zone_dnssec_input::Builder {
        crate::input::disable_hosted_zone_dnssec_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisableHostedZoneDNSSEC {
    type Output = std::result::Result<
        crate::output::DisableHostedZoneDnssecOutput,
        crate::error::DisableHostedZoneDNSSECError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disable_hosted_zone_dnssec_error(response)
        } else {
            crate::operation_deser::parse_disable_hosted_zone_dnssec_response(response)
        }
    }
}

/// <p>Disassociates an Amazon Virtual Private Cloud (Amazon VPC) from an Amazon Route 53 private hosted zone. Note the following:</p>
/// <ul>
/// <li>
/// <p>You can't disassociate the last Amazon VPC from a private hosted zone.</p>
/// </li>
/// <li>
/// <p>You can't convert a private hosted zone into a public hosted zone.</p>
/// </li>
/// <li>
/// <p>You can submit a <code>DisassociateVPCFromHostedZone</code> request using either the account
/// that created the hosted zone or the account that created the Amazon VPC.</p>
/// </li>
/// <li>
/// <p>Some services, such as Cloud Map and Amazon Elastic File System (Amazon EFS) automatically create hosted zones and associate
/// VPCs with the hosted zones. A service can create a hosted zone using your account or using its own account.
/// You can disassociate a VPC from a hosted zone only if the service created the hosted zone using your account.</p>
/// <p>When you run <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ListHostedZonesByVPC.html">DisassociateVPCFromHostedZone</a>,
/// if the hosted zone has a value for <code>OwningAccount</code>, you can use <code>DisassociateVPCFromHostedZone</code>.
/// If the hosted zone has a value for <code>OwningService</code>, you can't use <code>DisassociateVPCFromHostedZone</code>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisassociateVPCFromHostedZone {
    _private: (),
}
impl DisassociateVPCFromHostedZone {
    /// Creates a new builder-style object to manufacture [`DisassociateVpcFromHostedZoneInput`](crate::input::DisassociateVpcFromHostedZoneInput)
    pub fn builder() -> crate::input::disassociate_vpc_from_hosted_zone_input::Builder {
        crate::input::disassociate_vpc_from_hosted_zone_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisassociateVPCFromHostedZone {
    type Output = std::result::Result<
        crate::output::DisassociateVpcFromHostedZoneOutput,
        crate::error::DisassociateVPCFromHostedZoneError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disassociate_vpc_from_hosted_zone_error(response)
        } else {
            crate::operation_deser::parse_disassociate_vpc_from_hosted_zone_response(response)
        }
    }
}

/// <p>Enables DNSSEC signing in a specific hosted zone.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct EnableHostedZoneDNSSEC {
    _private: (),
}
impl EnableHostedZoneDNSSEC {
    /// Creates a new builder-style object to manufacture [`EnableHostedZoneDnssecInput`](crate::input::EnableHostedZoneDnssecInput)
    pub fn builder() -> crate::input::enable_hosted_zone_dnssec_input::Builder {
        crate::input::enable_hosted_zone_dnssec_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for EnableHostedZoneDNSSEC {
    type Output = std::result::Result<
        crate::output::EnableHostedZoneDnssecOutput,
        crate::error::EnableHostedZoneDNSSECError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_enable_hosted_zone_dnssec_error(response)
        } else {
            crate::operation_deser::parse_enable_hosted_zone_dnssec_response(response)
        }
    }
}

/// <p>Gets the specified limit for the current account, for example, the maximum number of health checks that you
/// can create using the account.</p>
/// <p>For the default limit, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a>
/// in the <i>Amazon Route 53 Developer Guide</i>. To request a higher limit,
/// <a href="https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&limitType=service-code-route53">open a case</a>.</p>
/// <note>
/// <p>You can also view account limits in Amazon Web Services Trusted Advisor. Sign in to the Amazon Web Services Management Console and open the Trusted Advisor console at
/// <a href="https://console.aws.amazon.com/trustedadvisor">https://console.aws.amazon.com/trustedadvisor/</a>. Then choose
/// <b>Service limits</b> in the navigation pane.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetAccountLimit {
    _private: (),
}
impl GetAccountLimit {
    /// Creates a new builder-style object to manufacture [`GetAccountLimitInput`](crate::input::GetAccountLimitInput)
    pub fn builder() -> crate::input::get_account_limit_input::Builder {
        crate::input::get_account_limit_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetAccountLimit {
    type Output = std::result::Result<
        crate::output::GetAccountLimitOutput,
        crate::error::GetAccountLimitError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_account_limit_error(response)
        } else {
            crate::operation_deser::parse_get_account_limit_response(response)
        }
    }
}

/// <p>Returns the current status of a change batch request. The status is one of the
/// following values:</p>
/// <ul>
/// <li>
/// <p>
/// <code>PENDING</code> indicates that the changes in this request have not propagated to all Amazon Route 53 DNS servers.
/// This is the initial status of all change batch requests.</p>
/// </li>
/// <li>
/// <p>
/// <code>INSYNC</code> indicates that the changes have propagated to all Route 53 DNS servers. </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetChange {
    _private: (),
}
impl GetChange {
    /// Creates a new builder-style object to manufacture [`GetChangeInput`](crate::input::GetChangeInput)
    pub fn builder() -> crate::input::get_change_input::Builder {
        crate::input::get_change_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetChange {
    type Output = std::result::Result<crate::output::GetChangeOutput, crate::error::GetChangeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_change_error(response)
        } else {
            crate::operation_deser::parse_get_change_response(response)
        }
    }
}

/// <p>Route 53 does not perform authorization for this API because it retrieves information that is already available to the public.</p>
/// <important>
/// <p>
/// <code>GetCheckerIpRanges</code> still works, but we recommend that you download
/// ip-ranges.json, which includes IP address ranges for all Amazon Web Services services. For more information, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/route-53-ip-addresses.html">IP Address Ranges of Amazon Route 53 Servers</a>
/// in the <i>Amazon Route 53 Developer Guide</i>.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCheckerIpRanges {
    _private: (),
}
impl GetCheckerIpRanges {
    /// Creates a new builder-style object to manufacture [`GetCheckerIpRangesInput`](crate::input::GetCheckerIpRangesInput)
    pub fn builder() -> crate::input::get_checker_ip_ranges_input::Builder {
        crate::input::get_checker_ip_ranges_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCheckerIpRanges {
    type Output = std::result::Result<
        crate::output::GetCheckerIpRangesOutput,
        crate::error::GetCheckerIpRangesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_checker_ip_ranges_error(response)
        } else {
            crate::operation_deser::parse_get_checker_ip_ranges_response(response)
        }
    }
}

/// <p>Returns information about DNSSEC for a specific hosted zone, including the key-signing keys (KSKs) in the hosted zone.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDNSSEC {
    _private: (),
}
impl GetDNSSEC {
    /// Creates a new builder-style object to manufacture [`GetDnssecInput`](crate::input::GetDnssecInput)
    pub fn builder() -> crate::input::get_dnssec_input::Builder {
        crate::input::get_dnssec_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDNSSEC {
    type Output = std::result::Result<crate::output::GetDnssecOutput, crate::error::GetDNSSECError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_dnssec_error(response)
        } else {
            crate::operation_deser::parse_get_dnssec_response(response)
        }
    }
}

/// <p>Gets information about whether a specified geographic location is supported for Amazon Route 53 geolocation
/// resource record sets.</p>
/// <p>Route 53 does not perform authorization for this API because it retrieves information that is already available to the public.</p>
/// <p>Use the following syntax to determine whether a continent is supported for geolocation:</p>
/// <p>
/// <code>GET /2013-04-01/geolocation?continentcode=<i>two-letter abbreviation for a continent</i>
/// </code>
/// </p>
/// <p>Use the following syntax to determine whether a country is supported for geolocation:</p>
/// <p>
/// <code>GET /2013-04-01/geolocation?countrycode=<i>two-character country code</i>
/// </code>
/// </p>
/// <p>Use the following syntax to determine whether a subdivision of a country is supported for geolocation:</p>
/// <p>
/// <code>GET /2013-04-01/geolocation?countrycode=<i>two-character country code</i>&subdivisioncode=<i>subdivision code</i>
/// </code>
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetGeoLocation {
    _private: (),
}
impl GetGeoLocation {
    /// Creates a new builder-style object to manufacture [`GetGeoLocationInput`](crate::input::GetGeoLocationInput)
    pub fn builder() -> crate::input::get_geo_location_input::Builder {
        crate::input::get_geo_location_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetGeoLocation {
    type Output =
        std::result::Result<crate::output::GetGeoLocationOutput, crate::error::GetGeoLocationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_geo_location_error(response)
        } else {
            crate::operation_deser::parse_get_geo_location_response(response)
        }
    }
}

/// <p>Gets information about a specified health check.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetHealthCheck {
    _private: (),
}
impl GetHealthCheck {
    /// Creates a new builder-style object to manufacture [`GetHealthCheckInput`](crate::input::GetHealthCheckInput)
    pub fn builder() -> crate::input::get_health_check_input::Builder {
        crate::input::get_health_check_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetHealthCheck {
    type Output =
        std::result::Result<crate::output::GetHealthCheckOutput, crate::error::GetHealthCheckError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_health_check_error(response)
        } else {
            crate::operation_deser::parse_get_health_check_response(response)
        }
    }
}

/// <p>Retrieves the number of health checks that are associated with the current Amazon Web Services account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetHealthCheckCount {
    _private: (),
}
impl GetHealthCheckCount {
    /// Creates a new builder-style object to manufacture [`GetHealthCheckCountInput`](crate::input::GetHealthCheckCountInput)
    pub fn builder() -> crate::input::get_health_check_count_input::Builder {
        crate::input::get_health_check_count_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetHealthCheckCount {
    type Output = std::result::Result<
        crate::output::GetHealthCheckCountOutput,
        crate::error::GetHealthCheckCountError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_health_check_count_error(response)
        } else {
            crate::operation_deser::parse_get_health_check_count_response(response)
        }
    }
}

/// <p>Gets the reason that a specified health check failed most recently.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetHealthCheckLastFailureReason {
    _private: (),
}
impl GetHealthCheckLastFailureReason {
    /// Creates a new builder-style object to manufacture [`GetHealthCheckLastFailureReasonInput`](crate::input::GetHealthCheckLastFailureReasonInput)
    pub fn builder() -> crate::input::get_health_check_last_failure_reason_input::Builder {
        crate::input::get_health_check_last_failure_reason_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetHealthCheckLastFailureReason {
    type Output = std::result::Result<
        crate::output::GetHealthCheckLastFailureReasonOutput,
        crate::error::GetHealthCheckLastFailureReasonError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_health_check_last_failure_reason_error(response)
        } else {
            crate::operation_deser::parse_get_health_check_last_failure_reason_response(response)
        }
    }
}

/// <p>Gets status of a specified health check. </p>
/// <important>
/// <p>This API is intended for use during development to diagnose behavior. It doesn’t support production use-cases with high query rates that require immediate and actionable responses.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetHealthCheckStatus {
    _private: (),
}
impl GetHealthCheckStatus {
    /// Creates a new builder-style object to manufacture [`GetHealthCheckStatusInput`](crate::input::GetHealthCheckStatusInput)
    pub fn builder() -> crate::input::get_health_check_status_input::Builder {
        crate::input::get_health_check_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetHealthCheckStatus {
    type Output = std::result::Result<
        crate::output::GetHealthCheckStatusOutput,
        crate::error::GetHealthCheckStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_health_check_status_error(response)
        } else {
            crate::operation_deser::parse_get_health_check_status_response(response)
        }
    }
}

/// <p>Gets information about a specified hosted zone including the four name servers assigned to the hosted zone.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetHostedZone {
    _private: (),
}
impl GetHostedZone {
    /// Creates a new builder-style object to manufacture [`GetHostedZoneInput`](crate::input::GetHostedZoneInput)
    pub fn builder() -> crate::input::get_hosted_zone_input::Builder {
        crate::input::get_hosted_zone_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetHostedZone {
    type Output =
        std::result::Result<crate::output::GetHostedZoneOutput, crate::error::GetHostedZoneError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_hosted_zone_error(response)
        } else {
            crate::operation_deser::parse_get_hosted_zone_response(response)
        }
    }
}

/// <p>Retrieves the number of hosted zones that are associated with the current Amazon Web Services account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetHostedZoneCount {
    _private: (),
}
impl GetHostedZoneCount {
    /// Creates a new builder-style object to manufacture [`GetHostedZoneCountInput`](crate::input::GetHostedZoneCountInput)
    pub fn builder() -> crate::input::get_hosted_zone_count_input::Builder {
        crate::input::get_hosted_zone_count_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetHostedZoneCount {
    type Output = std::result::Result<
        crate::output::GetHostedZoneCountOutput,
        crate::error::GetHostedZoneCountError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_hosted_zone_count_error(response)
        } else {
            crate::operation_deser::parse_get_hosted_zone_count_response(response)
        }
    }
}

/// <p>Gets the specified limit for a specified hosted zone, for example, the maximum number of records that you
/// can create in the hosted zone. </p>
/// <p>For the default limit, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a>
/// in the <i>Amazon Route 53 Developer Guide</i>. To request a higher limit,
/// <a href="https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&limitType=service-code-route53">open a case</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetHostedZoneLimit {
    _private: (),
}
impl GetHostedZoneLimit {
    /// Creates a new builder-style object to manufacture [`GetHostedZoneLimitInput`](crate::input::GetHostedZoneLimitInput)
    pub fn builder() -> crate::input::get_hosted_zone_limit_input::Builder {
        crate::input::get_hosted_zone_limit_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetHostedZoneLimit {
    type Output = std::result::Result<
        crate::output::GetHostedZoneLimitOutput,
        crate::error::GetHostedZoneLimitError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_hosted_zone_limit_error(response)
        } else {
            crate::operation_deser::parse_get_hosted_zone_limit_response(response)
        }
    }
}

/// <p>Gets information about a specified configuration for DNS query logging.</p>
/// <p>For more information about DNS query logs, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateQueryLoggingConfig.html">CreateQueryLoggingConfig</a>
/// and
/// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/query-logs.html">Logging DNS Queries</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetQueryLoggingConfig {
    _private: (),
}
impl GetQueryLoggingConfig {
    /// Creates a new builder-style object to manufacture [`GetQueryLoggingConfigInput`](crate::input::GetQueryLoggingConfigInput)
    pub fn builder() -> crate::input::get_query_logging_config_input::Builder {
        crate::input::get_query_logging_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetQueryLoggingConfig {
    type Output = std::result::Result<
        crate::output::GetQueryLoggingConfigOutput,
        crate::error::GetQueryLoggingConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_query_logging_config_error(response)
        } else {
            crate::operation_deser::parse_get_query_logging_config_response(response)
        }
    }
}

/// <p>Retrieves information about a specified reusable delegation set, including the four name servers that are assigned
/// to the delegation set.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetReusableDelegationSet {
    _private: (),
}
impl GetReusableDelegationSet {
    /// Creates a new builder-style object to manufacture [`GetReusableDelegationSetInput`](crate::input::GetReusableDelegationSetInput)
    pub fn builder() -> crate::input::get_reusable_delegation_set_input::Builder {
        crate::input::get_reusable_delegation_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetReusableDelegationSet {
    type Output = std::result::Result<
        crate::output::GetReusableDelegationSetOutput,
        crate::error::GetReusableDelegationSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_reusable_delegation_set_error(response)
        } else {
            crate::operation_deser::parse_get_reusable_delegation_set_response(response)
        }
    }
}

/// <p>Gets the maximum number of hosted zones that you can associate with the specified reusable delegation set.</p>
/// <p>For the default limit, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a>
/// in the <i>Amazon Route 53 Developer Guide</i>. To request a higher limit,
/// <a href="https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&limitType=service-code-route53">open a case</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetReusableDelegationSetLimit {
    _private: (),
}
impl GetReusableDelegationSetLimit {
    /// Creates a new builder-style object to manufacture [`GetReusableDelegationSetLimitInput`](crate::input::GetReusableDelegationSetLimitInput)
    pub fn builder() -> crate::input::get_reusable_delegation_set_limit_input::Builder {
        crate::input::get_reusable_delegation_set_limit_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetReusableDelegationSetLimit {
    type Output = std::result::Result<
        crate::output::GetReusableDelegationSetLimitOutput,
        crate::error::GetReusableDelegationSetLimitError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_reusable_delegation_set_limit_error(response)
        } else {
            crate::operation_deser::parse_get_reusable_delegation_set_limit_response(response)
        }
    }
}

/// <p>Gets information about a specific traffic policy version.</p>
/// <p>For information about how of deleting a traffic policy affects the response from <code>GetTrafficPolicy</code>, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_DeleteTrafficPolicy.html">DeleteTrafficPolicy</a>.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetTrafficPolicy {
    _private: (),
}
impl GetTrafficPolicy {
    /// Creates a new builder-style object to manufacture [`GetTrafficPolicyInput`](crate::input::GetTrafficPolicyInput)
    pub fn builder() -> crate::input::get_traffic_policy_input::Builder {
        crate::input::get_traffic_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetTrafficPolicy {
    type Output = std::result::Result<
        crate::output::GetTrafficPolicyOutput,
        crate::error::GetTrafficPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_traffic_policy_error(response)
        } else {
            crate::operation_deser::parse_get_traffic_policy_response(response)
        }
    }
}

/// <p>Gets information about a specified traffic policy instance.</p>
/// <note>
/// <p>After you submit a <code>CreateTrafficPolicyInstance</code> or an <code>UpdateTrafficPolicyInstance</code> request,
/// there's a brief delay while Amazon Route 53 creates the resource record sets that are specified in the traffic policy definition. For
/// more information, see the <code>State</code> response element.</p>
/// </note>
/// <note>
/// <p>In the Route 53 console, traffic policy instances are known as policy records.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetTrafficPolicyInstance {
    _private: (),
}
impl GetTrafficPolicyInstance {
    /// Creates a new builder-style object to manufacture [`GetTrafficPolicyInstanceInput`](crate::input::GetTrafficPolicyInstanceInput)
    pub fn builder() -> crate::input::get_traffic_policy_instance_input::Builder {
        crate::input::get_traffic_policy_instance_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetTrafficPolicyInstance {
    type Output = std::result::Result<
        crate::output::GetTrafficPolicyInstanceOutput,
        crate::error::GetTrafficPolicyInstanceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_traffic_policy_instance_error(response)
        } else {
            crate::operation_deser::parse_get_traffic_policy_instance_response(response)
        }
    }
}

/// <p>Gets the number of traffic policy instances that are associated with the current Amazon Web Services account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetTrafficPolicyInstanceCount {
    _private: (),
}
impl GetTrafficPolicyInstanceCount {
    /// Creates a new builder-style object to manufacture [`GetTrafficPolicyInstanceCountInput`](crate::input::GetTrafficPolicyInstanceCountInput)
    pub fn builder() -> crate::input::get_traffic_policy_instance_count_input::Builder {
        crate::input::get_traffic_policy_instance_count_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetTrafficPolicyInstanceCount {
    type Output = std::result::Result<
        crate::output::GetTrafficPolicyInstanceCountOutput,
        crate::error::GetTrafficPolicyInstanceCountError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_traffic_policy_instance_count_error(response)
        } else {
            crate::operation_deser::parse_get_traffic_policy_instance_count_response(response)
        }
    }
}

/// <p>Retrieves a list of supported geographic locations.</p>
/// <p>Countries are listed first, and continents are listed last. If Amazon Route 53 supports subdivisions for a country (for example, states or provinces),
/// the subdivisions for that country are listed in alphabetical order immediately after the corresponding country.</p>
/// <p>Route 53 does not perform authorization for this API because it retrieves information that is already available to the public.</p>
/// <p>For a list of supported geolocation codes, see the
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GeoLocation.html">GeoLocation</a> data type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListGeoLocations {
    _private: (),
}
impl ListGeoLocations {
    /// Creates a new builder-style object to manufacture [`ListGeoLocationsInput`](crate::input::ListGeoLocationsInput)
    pub fn builder() -> crate::input::list_geo_locations_input::Builder {
        crate::input::list_geo_locations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListGeoLocations {
    type Output = std::result::Result<
        crate::output::ListGeoLocationsOutput,
        crate::error::ListGeoLocationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_geo_locations_error(response)
        } else {
            crate::operation_deser::parse_list_geo_locations_response(response)
        }
    }
}

/// <p>Retrieve a list of the health checks that are associated with the current Amazon Web Services account. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListHealthChecks {
    _private: (),
}
impl ListHealthChecks {
    /// Creates a new builder-style object to manufacture [`ListHealthChecksInput`](crate::input::ListHealthChecksInput)
    pub fn builder() -> crate::input::list_health_checks_input::Builder {
        crate::input::list_health_checks_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListHealthChecks {
    type Output = std::result::Result<
        crate::output::ListHealthChecksOutput,
        crate::error::ListHealthChecksError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_health_checks_error(response)
        } else {
            crate::operation_deser::parse_list_health_checks_response(response)
        }
    }
}

/// <p>Retrieves a list of the public and private hosted zones that are associated with the current Amazon Web Services account. The response
/// includes a <code>HostedZones</code> child element for each hosted zone.</p>
/// <p>Amazon Route 53 returns a maximum of 100 items in each response. If you have a lot of hosted zones, you can use the
/// <code>maxitems</code> parameter to list them in groups of up to 100.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListHostedZones {
    _private: (),
}
impl ListHostedZones {
    /// Creates a new builder-style object to manufacture [`ListHostedZonesInput`](crate::input::ListHostedZonesInput)
    pub fn builder() -> crate::input::list_hosted_zones_input::Builder {
        crate::input::list_hosted_zones_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListHostedZones {
    type Output = std::result::Result<
        crate::output::ListHostedZonesOutput,
        crate::error::ListHostedZonesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_hosted_zones_error(response)
        } else {
            crate::operation_deser::parse_list_hosted_zones_response(response)
        }
    }
}

/// <p>Retrieves a list of your hosted zones in lexicographic order. The response includes a <code>HostedZones</code> child element
/// for each hosted zone created by the current Amazon Web Services account. </p>
/// <p>
/// <code>ListHostedZonesByName</code> sorts hosted zones by name with the labels reversed. For example:</p>
/// <p>
/// <code>com.example.www.</code>
/// </p>
/// <p>Note the trailing dot, which can change the sort order in some circumstances.</p>
/// <p>If the domain name includes escape characters or Punycode, <code>ListHostedZonesByName</code> alphabetizes the domain name
/// using the escaped or Punycoded value, which is the format that Amazon Route 53 saves in its database. For example, to create a hosted zone
/// for exämple.com, you specify ex\344mple.com for the domain name. <code>ListHostedZonesByName</code> alphabetizes it as:</p>
/// <p>
/// <code>com.ex\344mple.</code>
/// </p>
/// <p>The labels are reversed and alphabetized using the escaped value. For more information about valid domain name formats,
/// including internationalized domain names, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html">DNS Domain Name Format</a> in the
/// <i>Amazon Route 53 Developer Guide</i>.</p>
/// <p>Route 53 returns up to 100 items in each response. If you have a lot of hosted zones, use the <code>MaxItems</code> parameter to list
/// them in groups of up to 100. The response includes values that help navigate from one group of <code>MaxItems</code> hosted zones to the next:</p>
/// <ul>
/// <li>
/// <p>The <code>DNSName</code> and <code>HostedZoneId</code> elements in the response contain the values, if any, specified for the
/// <code>dnsname</code> and <code>hostedzoneid</code> parameters in the request that produced the current response.</p>
/// </li>
/// <li>
/// <p>The <code>MaxItems</code> element in the response contains the value, if any, that you specified for the <code>maxitems</code>
/// parameter in the request that produced the current response.</p>
/// </li>
/// <li>
/// <p>If the value of <code>IsTruncated</code> in the response is true, there are more hosted zones associated with the
/// current Amazon Web Services account. </p>
/// <p>If <code>IsTruncated</code> is false, this response includes the last hosted zone that is associated with the current account.
/// The <code>NextDNSName</code> element and <code>NextHostedZoneId</code> elements are omitted from the response.</p>
/// </li>
/// <li>
/// <p>The <code>NextDNSName</code> and <code>NextHostedZoneId</code> elements in the response contain the domain name and the
/// hosted zone ID of the next hosted zone that is associated with the current Amazon Web Services account. If you want to list more hosted zones,
/// make another call to <code>ListHostedZonesByName</code>, and specify the value of <code>NextDNSName</code> and
/// <code>NextHostedZoneId</code> in the <code>dnsname</code> and <code>hostedzoneid</code> parameters, respectively.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListHostedZonesByName {
    _private: (),
}
impl ListHostedZonesByName {
    /// Creates a new builder-style object to manufacture [`ListHostedZonesByNameInput`](crate::input::ListHostedZonesByNameInput)
    pub fn builder() -> crate::input::list_hosted_zones_by_name_input::Builder {
        crate::input::list_hosted_zones_by_name_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListHostedZonesByName {
    type Output = std::result::Result<
        crate::output::ListHostedZonesByNameOutput,
        crate::error::ListHostedZonesByNameError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_hosted_zones_by_name_error(response)
        } else {
            crate::operation_deser::parse_list_hosted_zones_by_name_response(response)
        }
    }
}

/// <p>Lists all the private hosted zones that a specified VPC is associated with, regardless of which Amazon Web Services account or Amazon Web Services service owns the
/// hosted zones. The <code>HostedZoneOwner</code> structure in the response contains one of the following values:</p>
/// <ul>
/// <li>
/// <p>An <code>OwningAccount</code> element, which contains the account number of either the current Amazon Web Services account or
/// another Amazon Web Services account. Some services, such as Cloud Map, create hosted zones using the current account. </p>
/// </li>
/// <li>
/// <p>An <code>OwningService</code> element, which identifies the Amazon Web Services service that created and owns the hosted zone.
/// For example, if a hosted zone was created by Amazon Elastic File System (Amazon EFS), the value of <code>Owner</code> is
/// <code>efs.amazonaws.com</code>. </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListHostedZonesByVPC {
    _private: (),
}
impl ListHostedZonesByVPC {
    /// Creates a new builder-style object to manufacture [`ListHostedZonesByVpcInput`](crate::input::ListHostedZonesByVpcInput)
    pub fn builder() -> crate::input::list_hosted_zones_by_vpc_input::Builder {
        crate::input::list_hosted_zones_by_vpc_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListHostedZonesByVPC {
    type Output = std::result::Result<
        crate::output::ListHostedZonesByVpcOutput,
        crate::error::ListHostedZonesByVPCError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_hosted_zones_by_vpc_error(response)
        } else {
            crate::operation_deser::parse_list_hosted_zones_by_vpc_response(response)
        }
    }
}

/// <p>Lists the configurations for DNS query logging that are associated with the current Amazon Web Services account or the configuration
/// that is associated with a specified hosted zone.</p>
/// <p>For more information about DNS query logs, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateQueryLoggingConfig.html">CreateQueryLoggingConfig</a>.
/// Additional information, including the format of DNS query logs, appears in
/// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/query-logs.html">Logging DNS Queries</a>
/// in the <i>Amazon Route 53 Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListQueryLoggingConfigs {
    _private: (),
}
impl ListQueryLoggingConfigs {
    /// Creates a new builder-style object to manufacture [`ListQueryLoggingConfigsInput`](crate::input::ListQueryLoggingConfigsInput)
    pub fn builder() -> crate::input::list_query_logging_configs_input::Builder {
        crate::input::list_query_logging_configs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListQueryLoggingConfigs {
    type Output = std::result::Result<
        crate::output::ListQueryLoggingConfigsOutput,
        crate::error::ListQueryLoggingConfigsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_query_logging_configs_error(response)
        } else {
            crate::operation_deser::parse_list_query_logging_configs_response(response)
        }
    }
}

/// <p>Lists the resource record sets in a specified hosted zone.</p>
/// <p>
/// <code>ListResourceRecordSets</code> returns up to 300 resource record sets at a time in ASCII order,
/// beginning at a position specified by the <code>name</code> and <code>type</code> elements.</p>
/// <p>
/// <b>Sort order</b>
/// </p>
/// <p>
/// <code>ListResourceRecordSets</code> sorts results first by DNS name with the labels reversed, for example:</p>
/// <p>
/// <code>com.example.www.</code>
/// </p>
/// <p>Note the trailing dot, which can change the sort order when the record name contains characters that appear before
/// <code>.</code> (decimal 46) in the ASCII table. These characters include the following: <code>! " # $ % & ' ( ) * + , -</code>
/// </p>
/// <p>When multiple records have the same DNS name, <code>ListResourceRecordSets</code> sorts results by the record type.</p>
/// <p>
/// <b>Specifying where to start listing records</b>
/// </p>
/// <p>You can use the name and type elements to specify the resource record set that the list begins with:</p>
/// <dl>
/// <dt>If you do not specify Name or Type</dt>
/// <dd>
/// <p>The results begin with the first resource record set that the hosted zone contains.</p>
/// </dd>
/// <dt>If you specify Name but not Type</dt>
/// <dd>
/// <p>The results begin with the first resource record set in the list whose name is greater than or equal to
/// <code>Name</code>.</p>
/// </dd>
/// <dt>If you specify Type but not Name</dt>
/// <dd>
/// <p>Amazon Route 53 returns the <code>InvalidInput</code> error.</p>
/// </dd>
/// <dt>If you specify both Name and Type</dt>
/// <dd>
/// <p>The results begin with the first resource record set in the list whose name is greater than or equal to
/// <code>Name</code>, and whose type is greater than or equal to <code>Type</code>.</p>
/// </dd>
/// </dl>
/// <p>
/// <b>Resource record sets that are PENDING</b>
/// </p>
/// <p>This action returns the most current version of the records. This includes records that are <code>PENDING</code>,
/// and that are not yet available on all Route 53 DNS servers.</p>
/// <p>
/// <b>Changing resource record sets</b>
/// </p>
/// <p>To ensure that you get an accurate listing of the resource record sets for a hosted zone at a point in time,
/// do not submit a <code>ChangeResourceRecordSets</code> request while you're paging through the results of a
/// <code>ListResourceRecordSets</code> request. If you do, some pages may display results without the latest changes
/// while other pages display results with the latest changes.</p>
/// <p>
/// <b>Displaying the next page of results</b>
/// </p>
/// <p>If a <code>ListResourceRecordSets</code> command returns more than one page of results, the value of <code>IsTruncated</code>
/// is <code>true</code>. To display the next page of results, get the values of <code>NextRecordName</code>, <code>NextRecordType</code>,
/// and <code>NextRecordIdentifier</code> (if any) from the response. Then submit another <code>ListResourceRecordSets</code> request, and
/// specify those values for <code>StartRecordName</code>, <code>StartRecordType</code>, and <code>StartRecordIdentifier</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListResourceRecordSets {
    _private: (),
}
impl ListResourceRecordSets {
    /// Creates a new builder-style object to manufacture [`ListResourceRecordSetsInput`](crate::input::ListResourceRecordSetsInput)
    pub fn builder() -> crate::input::list_resource_record_sets_input::Builder {
        crate::input::list_resource_record_sets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListResourceRecordSets {
    type Output = std::result::Result<
        crate::output::ListResourceRecordSetsOutput,
        crate::error::ListResourceRecordSetsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_resource_record_sets_error(response)
        } else {
            crate::operation_deser::parse_list_resource_record_sets_response(response)
        }
    }
}

/// <p>Retrieves a list of the reusable delegation sets that are associated with the current Amazon Web Services account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListReusableDelegationSets {
    _private: (),
}
impl ListReusableDelegationSets {
    /// Creates a new builder-style object to manufacture [`ListReusableDelegationSetsInput`](crate::input::ListReusableDelegationSetsInput)
    pub fn builder() -> crate::input::list_reusable_delegation_sets_input::Builder {
        crate::input::list_reusable_delegation_sets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListReusableDelegationSets {
    type Output = std::result::Result<
        crate::output::ListReusableDelegationSetsOutput,
        crate::error::ListReusableDelegationSetsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_reusable_delegation_sets_error(response)
        } else {
            crate::operation_deser::parse_list_reusable_delegation_sets_response(response)
        }
    }
}

/// <p>Lists tags for one health check or hosted zone. </p>
/// <p>For information about using tags for cost allocation, see
/// <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation Tags</a>
/// in the <i>Billing and Cost Management User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Lists tags for up to 10 health checks or hosted zones.</p>
/// <p>For information about using tags for cost allocation, see
/// <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation Tags</a>
/// in the <i>Billing and Cost Management User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResources {
    _private: (),
}
impl ListTagsForResources {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourcesInput`](crate::input::ListTagsForResourcesInput)
    pub fn builder() -> crate::input::list_tags_for_resources_input::Builder {
        crate::input::list_tags_for_resources_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResources {
    type Output = std::result::Result<
        crate::output::ListTagsForResourcesOutput,
        crate::error::ListTagsForResourcesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resources_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resources_response(response)
        }
    }
}

/// <p>Gets information about the latest version for every traffic policy that is associated with the current Amazon Web Services account.
/// Policies are listed in the order that they were created in. </p>
/// <p>For information about how of deleting a traffic policy affects the response from <code>ListTrafficPolicies</code>, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_DeleteTrafficPolicy.html">DeleteTrafficPolicy</a>.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTrafficPolicies {
    _private: (),
}
impl ListTrafficPolicies {
    /// Creates a new builder-style object to manufacture [`ListTrafficPoliciesInput`](crate::input::ListTrafficPoliciesInput)
    pub fn builder() -> crate::input::list_traffic_policies_input::Builder {
        crate::input::list_traffic_policies_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTrafficPolicies {
    type Output = std::result::Result<
        crate::output::ListTrafficPoliciesOutput,
        crate::error::ListTrafficPoliciesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_traffic_policies_error(response)
        } else {
            crate::operation_deser::parse_list_traffic_policies_response(response)
        }
    }
}

/// <p>Gets information about the traffic policy instances that you created by using the current Amazon Web Services account.</p>
/// <note>
/// <p>After you submit an <code>UpdateTrafficPolicyInstance</code> request, there's a brief delay while Amazon Route 53 creates the
/// resource record sets that are specified in the traffic policy definition. For more information, see the <code>State</code> response element.</p>
/// </note>
/// <p>Route 53 returns a maximum of 100 items in each response. If you have a lot of traffic policy instances, you can use the
/// <code>MaxItems</code> parameter to list them in groups of up to 100.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTrafficPolicyInstances {
    _private: (),
}
impl ListTrafficPolicyInstances {
    /// Creates a new builder-style object to manufacture [`ListTrafficPolicyInstancesInput`](crate::input::ListTrafficPolicyInstancesInput)
    pub fn builder() -> crate::input::list_traffic_policy_instances_input::Builder {
        crate::input::list_traffic_policy_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTrafficPolicyInstances {
    type Output = std::result::Result<
        crate::output::ListTrafficPolicyInstancesOutput,
        crate::error::ListTrafficPolicyInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_traffic_policy_instances_error(response)
        } else {
            crate::operation_deser::parse_list_traffic_policy_instances_response(response)
        }
    }
}

/// <p>Gets information about the traffic policy instances that you created in a specified hosted zone.</p>
/// <note>
/// <p>After you submit a <code>CreateTrafficPolicyInstance</code> or an <code>UpdateTrafficPolicyInstance</code> request, there's a
/// brief delay while Amazon Route 53 creates the resource record sets that are specified in the traffic policy definition. For more information,
/// see the <code>State</code> response element.</p>
/// </note>
/// <p>Route 53 returns a maximum of 100 items in each response. If you have a lot of traffic policy instances, you can use the
/// <code>MaxItems</code> parameter to list them in groups of up to 100.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTrafficPolicyInstancesByHostedZone {
    _private: (),
}
impl ListTrafficPolicyInstancesByHostedZone {
    /// Creates a new builder-style object to manufacture [`ListTrafficPolicyInstancesByHostedZoneInput`](crate::input::ListTrafficPolicyInstancesByHostedZoneInput)
    pub fn builder() -> crate::input::list_traffic_policy_instances_by_hosted_zone_input::Builder {
        crate::input::list_traffic_policy_instances_by_hosted_zone_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTrafficPolicyInstancesByHostedZone {
    type Output = std::result::Result<
        crate::output::ListTrafficPolicyInstancesByHostedZoneOutput,
        crate::error::ListTrafficPolicyInstancesByHostedZoneError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_traffic_policy_instances_by_hosted_zone_error(
                response,
            )
        } else {
            crate::operation_deser::parse_list_traffic_policy_instances_by_hosted_zone_response(
                response,
            )
        }
    }
}

/// <p>Gets information about the traffic policy instances that you created by using a specify traffic policy version.</p>
/// <note>
/// <p>After you submit a <code>CreateTrafficPolicyInstance</code> or an <code>UpdateTrafficPolicyInstance</code> request,
/// there's a brief delay while Amazon Route 53 creates the resource record sets that are specified in the traffic policy definition. For
/// more information, see the <code>State</code> response element.</p>
/// </note>
/// <p>Route 53 returns a maximum of 100 items in each response. If you have a lot of traffic policy instances, you can use the
/// <code>MaxItems</code> parameter to list them in groups of up to 100.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTrafficPolicyInstancesByPolicy {
    _private: (),
}
impl ListTrafficPolicyInstancesByPolicy {
    /// Creates a new builder-style object to manufacture [`ListTrafficPolicyInstancesByPolicyInput`](crate::input::ListTrafficPolicyInstancesByPolicyInput)
    pub fn builder() -> crate::input::list_traffic_policy_instances_by_policy_input::Builder {
        crate::input::list_traffic_policy_instances_by_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTrafficPolicyInstancesByPolicy {
    type Output = std::result::Result<
        crate::output::ListTrafficPolicyInstancesByPolicyOutput,
        crate::error::ListTrafficPolicyInstancesByPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_traffic_policy_instances_by_policy_error(response)
        } else {
            crate::operation_deser::parse_list_traffic_policy_instances_by_policy_response(response)
        }
    }
}

/// <p>Gets information about all of the versions for a specified traffic policy.</p>
/// <p>Traffic policy versions are listed in numerical order by <code>VersionNumber</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTrafficPolicyVersions {
    _private: (),
}
impl ListTrafficPolicyVersions {
    /// Creates a new builder-style object to manufacture [`ListTrafficPolicyVersionsInput`](crate::input::ListTrafficPolicyVersionsInput)
    pub fn builder() -> crate::input::list_traffic_policy_versions_input::Builder {
        crate::input::list_traffic_policy_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTrafficPolicyVersions {
    type Output = std::result::Result<
        crate::output::ListTrafficPolicyVersionsOutput,
        crate::error::ListTrafficPolicyVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_traffic_policy_versions_error(response)
        } else {
            crate::operation_deser::parse_list_traffic_policy_versions_response(response)
        }
    }
}

/// <p>Gets a list of the VPCs that were created by other accounts and that can be associated with a
/// specified hosted zone because you've submitted one or more <code>CreateVPCAssociationAuthorization</code> requests. </p>
/// <p>The response includes a <code>VPCs</code> element with a <code>VPC</code> child element for each VPC
/// that can be associated with the hosted zone.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListVPCAssociationAuthorizations {
    _private: (),
}
impl ListVPCAssociationAuthorizations {
    /// Creates a new builder-style object to manufacture [`ListVpcAssociationAuthorizationsInput`](crate::input::ListVpcAssociationAuthorizationsInput)
    pub fn builder() -> crate::input::list_vpc_association_authorizations_input::Builder {
        crate::input::list_vpc_association_authorizations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListVPCAssociationAuthorizations {
    type Output = std::result::Result<
        crate::output::ListVpcAssociationAuthorizationsOutput,
        crate::error::ListVPCAssociationAuthorizationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_vpc_association_authorizations_error(response)
        } else {
            crate::operation_deser::parse_list_vpc_association_authorizations_response(response)
        }
    }
}

/// <p>Gets the value that Amazon Route 53 returns in response to a DNS request for a specified record name and type. You can optionally specify
/// the IP address of a DNS resolver, an EDNS0 client subnet IP address, and a subnet mask. </p>
/// <p>This call only supports querying public hosted zones.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TestDNSAnswer {
    _private: (),
}
impl TestDNSAnswer {
    /// Creates a new builder-style object to manufacture [`TestDnsAnswerInput`](crate::input::TestDnsAnswerInput)
    pub fn builder() -> crate::input::test_dns_answer_input::Builder {
        crate::input::test_dns_answer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TestDNSAnswer {
    type Output =
        std::result::Result<crate::output::TestDnsAnswerOutput, crate::error::TestDNSAnswerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_test_dns_answer_error(response)
        } else {
            crate::operation_deser::parse_test_dns_answer_response(response)
        }
    }
}

/// <p>Updates an existing health check. Note that some values can't be updated. </p>
/// <p>For more information about updating health checks, see
/// <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/health-checks-creating-deleting.html">Creating, Updating, and Deleting Health Checks</a>
/// in the <i>Amazon Route 53 Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateHealthCheck {
    _private: (),
}
impl UpdateHealthCheck {
    /// Creates a new builder-style object to manufacture [`UpdateHealthCheckInput`](crate::input::UpdateHealthCheckInput)
    pub fn builder() -> crate::input::update_health_check_input::Builder {
        crate::input::update_health_check_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateHealthCheck {
    type Output = std::result::Result<
        crate::output::UpdateHealthCheckOutput,
        crate::error::UpdateHealthCheckError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_health_check_error(response)
        } else {
            crate::operation_deser::parse_update_health_check_response(response)
        }
    }
}

/// <p>Updates the comment for a specified hosted zone.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateHostedZoneComment {
    _private: (),
}
impl UpdateHostedZoneComment {
    /// Creates a new builder-style object to manufacture [`UpdateHostedZoneCommentInput`](crate::input::UpdateHostedZoneCommentInput)
    pub fn builder() -> crate::input::update_hosted_zone_comment_input::Builder {
        crate::input::update_hosted_zone_comment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateHostedZoneComment {
    type Output = std::result::Result<
        crate::output::UpdateHostedZoneCommentOutput,
        crate::error::UpdateHostedZoneCommentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_hosted_zone_comment_error(response)
        } else {
            crate::operation_deser::parse_update_hosted_zone_comment_response(response)
        }
    }
}

/// <p>Updates the comment for a specified traffic policy version.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateTrafficPolicyComment {
    _private: (),
}
impl UpdateTrafficPolicyComment {
    /// Creates a new builder-style object to manufacture [`UpdateTrafficPolicyCommentInput`](crate::input::UpdateTrafficPolicyCommentInput)
    pub fn builder() -> crate::input::update_traffic_policy_comment_input::Builder {
        crate::input::update_traffic_policy_comment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateTrafficPolicyComment {
    type Output = std::result::Result<
        crate::output::UpdateTrafficPolicyCommentOutput,
        crate::error::UpdateTrafficPolicyCommentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_traffic_policy_comment_error(response)
        } else {
            crate::operation_deser::parse_update_traffic_policy_comment_response(response)
        }
    }
}

/// <p>Updates the resource record sets in a specified hosted zone that were created based on the settings in a specified traffic policy version.</p>
/// <p>When you update a traffic policy instance, Amazon Route 53 continues to respond to DNS queries for the root resource record set name
/// (such as example.com) while it replaces one group of resource record sets with another. Route 53 performs the following operations:</p>
/// <ol>
/// <li>
/// <p>Route 53 creates a new group of resource record sets based on the specified traffic policy. This is true regardless of how significant
/// the differences are between the existing resource record sets and the new resource record sets. </p>
/// </li>
/// <li>
/// <p>When all of the new resource record sets have been created, Route 53 starts to respond to DNS queries for the root resource record set name
/// (such as example.com) by using the new resource record sets.</p>
/// </li>
/// <li>
/// <p>Route 53 deletes the old group of resource record sets that are associated with the root resource record set name.</p>
/// </li>
/// </ol>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateTrafficPolicyInstance {
    _private: (),
}
impl UpdateTrafficPolicyInstance {
    /// Creates a new builder-style object to manufacture [`UpdateTrafficPolicyInstanceInput`](crate::input::UpdateTrafficPolicyInstanceInput)
    pub fn builder() -> crate::input::update_traffic_policy_instance_input::Builder {
        crate::input::update_traffic_policy_instance_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateTrafficPolicyInstance {
    type Output = std::result::Result<
        crate::output::UpdateTrafficPolicyInstanceOutput,
        crate::error::UpdateTrafficPolicyInstanceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_traffic_policy_instance_error(response)
        } else {
            crate::operation_deser::parse_update_traffic_policy_instance_response(response)
        }
    }
}
