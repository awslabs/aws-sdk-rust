// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>An object containing information about the output file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExportVectorEnrichmentJobOutputConfig {
    /// <p></p>
    #[doc(hidden)]
    pub s3_data: std::option::Option<crate::model::VectorEnrichmentJobS3Data>,
}
impl ExportVectorEnrichmentJobOutputConfig {
    /// <p></p>
    pub fn s3_data(&self) -> std::option::Option<&crate::model::VectorEnrichmentJobS3Data> {
        self.s3_data.as_ref()
    }
}
/// See [`ExportVectorEnrichmentJobOutputConfig`](crate::model::ExportVectorEnrichmentJobOutputConfig).
pub mod export_vector_enrichment_job_output_config {

    /// A builder for [`ExportVectorEnrichmentJobOutputConfig`](crate::model::ExportVectorEnrichmentJobOutputConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_data: std::option::Option<crate::model::VectorEnrichmentJobS3Data>,
    }
    impl Builder {
        /// <p></p>
        pub fn s3_data(mut self, input: crate::model::VectorEnrichmentJobS3Data) -> Self {
            self.s3_data = Some(input);
            self
        }
        /// <p></p>
        pub fn set_s3_data(
            mut self,
            input: std::option::Option<crate::model::VectorEnrichmentJobS3Data>,
        ) -> Self {
            self.s3_data = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportVectorEnrichmentJobOutputConfig`](crate::model::ExportVectorEnrichmentJobOutputConfig).
        pub fn build(self) -> crate::model::ExportVectorEnrichmentJobOutputConfig {
            crate::model::ExportVectorEnrichmentJobOutputConfig {
                s3_data: self.s3_data,
            }
        }
    }
}
impl ExportVectorEnrichmentJobOutputConfig {
    /// Creates a new builder-style object to manufacture [`ExportVectorEnrichmentJobOutputConfig`](crate::model::ExportVectorEnrichmentJobOutputConfig).
    pub fn builder() -> crate::model::export_vector_enrichment_job_output_config::Builder {
        crate::model::export_vector_enrichment_job_output_config::Builder::default()
    }
}

/// <p>The Amazon S3 data for the Vector Enrichment job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VectorEnrichmentJobS3Data {
    /// <p>The URL to the Amazon S3 data for the Vector Enrichment job.</p>
    #[doc(hidden)]
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>The Amazon Key Management Service (KMS) key ID for server-side encryption.</p>
    #[doc(hidden)]
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl VectorEnrichmentJobS3Data {
    /// <p>The URL to the Amazon S3 data for the Vector Enrichment job.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p>The Amazon Key Management Service (KMS) key ID for server-side encryption.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
/// See [`VectorEnrichmentJobS3Data`](crate::model::VectorEnrichmentJobS3Data).
pub mod vector_enrichment_job_s3_data {

    /// A builder for [`VectorEnrichmentJobS3Data`](crate::model::VectorEnrichmentJobS3Data).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URL to the Amazon S3 data for the Vector Enrichment job.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>The URL to the Amazon S3 data for the Vector Enrichment job.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>The Amazon Key Management Service (KMS) key ID for server-side encryption.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Key Management Service (KMS) key ID for server-side encryption.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`VectorEnrichmentJobS3Data`](crate::model::VectorEnrichmentJobS3Data).
        pub fn build(self) -> crate::model::VectorEnrichmentJobS3Data {
            crate::model::VectorEnrichmentJobS3Data {
                s3_uri: self.s3_uri,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl VectorEnrichmentJobS3Data {
    /// Creates a new builder-style object to manufacture [`VectorEnrichmentJobS3Data`](crate::model::VectorEnrichmentJobS3Data).
    pub fn builder() -> crate::model::vector_enrichment_job_s3_data::Builder {
        crate::model::vector_enrichment_job_s3_data::Builder::default()
    }
}

/// When writing a match expression against `VectorEnrichmentJobExportStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let vectorenrichmentjobexportstatus = unimplemented!();
/// match vectorenrichmentjobexportstatus {
///     VectorEnrichmentJobExportStatus::Failed => { /* ... */ },
///     VectorEnrichmentJobExportStatus::InProgress => { /* ... */ },
///     VectorEnrichmentJobExportStatus::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `vectorenrichmentjobexportstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VectorEnrichmentJobExportStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VectorEnrichmentJobExportStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VectorEnrichmentJobExportStatus::NewFeature` is defined.
/// Specifically, when `vectorenrichmentjobexportstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VectorEnrichmentJobExportStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VectorEnrichmentJobExportStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VectorEnrichmentJobExportStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => VectorEnrichmentJobExportStatus::Failed,
            "IN_PROGRESS" => VectorEnrichmentJobExportStatus::InProgress,
            "SUCCEEDED" => VectorEnrichmentJobExportStatus::Succeeded,
            other => VectorEnrichmentJobExportStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for VectorEnrichmentJobExportStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VectorEnrichmentJobExportStatus::from(s))
    }
}
impl VectorEnrichmentJobExportStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VectorEnrichmentJobExportStatus::Failed => "FAILED",
            VectorEnrichmentJobExportStatus::InProgress => "IN_PROGRESS",
            VectorEnrichmentJobExportStatus::Succeeded => "SUCCEEDED",
            VectorEnrichmentJobExportStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "IN_PROGRESS", "SUCCEEDED"]
    }
}
impl AsRef<str> for VectorEnrichmentJobExportStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object containing information about the output file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListVectorEnrichmentJobOutputConfig {
    /// <p>The Amazon Resource Name (ARN) of the list of the Vector Enrichment jobs.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The names of the Vector Enrichment jobs in the list.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of the list of Vector Enrichment jobs.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::VectorEnrichmentJobType>,
    /// <p>The creation time.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The duration of the session, in seconds.</p>
    #[doc(hidden)]
    pub duration_in_seconds: std::option::Option<i32>,
    /// <p>The status of the Vector Enrichment jobs list. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::VectorEnrichmentJobStatus>,
    /// <p>Each tag consists of a key and a value.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ListVectorEnrichmentJobOutputConfig {
    /// <p>The Amazon Resource Name (ARN) of the list of the Vector Enrichment jobs.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The names of the Vector Enrichment jobs in the list.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of the list of Vector Enrichment jobs.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::VectorEnrichmentJobType> {
        self.r#type.as_ref()
    }
    /// <p>The creation time.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The duration of the session, in seconds.</p>
    pub fn duration_in_seconds(&self) -> std::option::Option<i32> {
        self.duration_in_seconds
    }
    /// <p>The status of the Vector Enrichment jobs list. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::VectorEnrichmentJobStatus> {
        self.status.as_ref()
    }
    /// <p>Each tag consists of a key and a value.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`ListVectorEnrichmentJobOutputConfig`](crate::model::ListVectorEnrichmentJobOutputConfig).
pub mod list_vector_enrichment_job_output_config {

    /// A builder for [`ListVectorEnrichmentJobOutputConfig`](crate::model::ListVectorEnrichmentJobOutputConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::VectorEnrichmentJobType>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) duration_in_seconds: std::option::Option<i32>,
        pub(crate) status: std::option::Option<crate::model::VectorEnrichmentJobStatus>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the list of the Vector Enrichment jobs.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the list of the Vector Enrichment jobs.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The names of the Vector Enrichment jobs in the list.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The names of the Vector Enrichment jobs in the list.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of the list of Vector Enrichment jobs.</p>
        pub fn r#type(mut self, input: crate::model::VectorEnrichmentJobType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the list of Vector Enrichment jobs.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::VectorEnrichmentJobType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The creation time.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation time.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The duration of the session, in seconds.</p>
        pub fn duration_in_seconds(mut self, input: i32) -> Self {
            self.duration_in_seconds = Some(input);
            self
        }
        /// <p>The duration of the session, in seconds.</p>
        pub fn set_duration_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.duration_in_seconds = input;
            self
        }
        /// <p>The status of the Vector Enrichment jobs list. </p>
        pub fn status(mut self, input: crate::model::VectorEnrichmentJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the Vector Enrichment jobs list. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::VectorEnrichmentJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Each tag consists of a key and a value.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>Each tag consists of a key and a value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ListVectorEnrichmentJobOutputConfig`](crate::model::ListVectorEnrichmentJobOutputConfig).
        pub fn build(self) -> crate::model::ListVectorEnrichmentJobOutputConfig {
            crate::model::ListVectorEnrichmentJobOutputConfig {
                arn: self.arn,
                name: self.name,
                r#type: self.r#type,
                creation_time: self.creation_time,
                duration_in_seconds: self.duration_in_seconds,
                status: self.status,
                tags: self.tags,
            }
        }
    }
}
impl ListVectorEnrichmentJobOutputConfig {
    /// Creates a new builder-style object to manufacture [`ListVectorEnrichmentJobOutputConfig`](crate::model::ListVectorEnrichmentJobOutputConfig).
    pub fn builder() -> crate::model::list_vector_enrichment_job_output_config::Builder {
        crate::model::list_vector_enrichment_job_output_config::Builder::default()
    }
}

/// When writing a match expression against `VectorEnrichmentJobStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let vectorenrichmentjobstatus = unimplemented!();
/// match vectorenrichmentjobstatus {
///     VectorEnrichmentJobStatus::Completed => { /* ... */ },
///     VectorEnrichmentJobStatus::Deleted => { /* ... */ },
///     VectorEnrichmentJobStatus::Deleting => { /* ... */ },
///     VectorEnrichmentJobStatus::Failed => { /* ... */ },
///     VectorEnrichmentJobStatus::Initializing => { /* ... */ },
///     VectorEnrichmentJobStatus::InProgress => { /* ... */ },
///     VectorEnrichmentJobStatus::Stopped => { /* ... */ },
///     VectorEnrichmentJobStatus::Stopping => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `vectorenrichmentjobstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VectorEnrichmentJobStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VectorEnrichmentJobStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VectorEnrichmentJobStatus::NewFeature` is defined.
/// Specifically, when `vectorenrichmentjobstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VectorEnrichmentJobStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VectorEnrichmentJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Initializing,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VectorEnrichmentJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => VectorEnrichmentJobStatus::Completed,
            "DELETED" => VectorEnrichmentJobStatus::Deleted,
            "DELETING" => VectorEnrichmentJobStatus::Deleting,
            "FAILED" => VectorEnrichmentJobStatus::Failed,
            "INITIALIZING" => VectorEnrichmentJobStatus::Initializing,
            "IN_PROGRESS" => VectorEnrichmentJobStatus::InProgress,
            "STOPPED" => VectorEnrichmentJobStatus::Stopped,
            "STOPPING" => VectorEnrichmentJobStatus::Stopping,
            other => VectorEnrichmentJobStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for VectorEnrichmentJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VectorEnrichmentJobStatus::from(s))
    }
}
impl VectorEnrichmentJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VectorEnrichmentJobStatus::Completed => "COMPLETED",
            VectorEnrichmentJobStatus::Deleted => "DELETED",
            VectorEnrichmentJobStatus::Deleting => "DELETING",
            VectorEnrichmentJobStatus::Failed => "FAILED",
            VectorEnrichmentJobStatus::Initializing => "INITIALIZING",
            VectorEnrichmentJobStatus::InProgress => "IN_PROGRESS",
            VectorEnrichmentJobStatus::Stopped => "STOPPED",
            VectorEnrichmentJobStatus::Stopping => "STOPPING",
            VectorEnrichmentJobStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "COMPLETED",
            "DELETED",
            "DELETING",
            "FAILED",
            "INITIALIZING",
            "IN_PROGRESS",
            "STOPPED",
            "STOPPING",
        ]
    }
}
impl AsRef<str> for VectorEnrichmentJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `VectorEnrichmentJobType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let vectorenrichmentjobtype = unimplemented!();
/// match vectorenrichmentjobtype {
///     VectorEnrichmentJobType::MapMatching => { /* ... */ },
///     VectorEnrichmentJobType::ReverseGeocoding => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `vectorenrichmentjobtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VectorEnrichmentJobType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VectorEnrichmentJobType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VectorEnrichmentJobType::NewFeature` is defined.
/// Specifically, when `vectorenrichmentjobtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VectorEnrichmentJobType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VectorEnrichmentJobType {
    #[allow(missing_docs)] // documentation missing in model
    MapMatching,
    #[allow(missing_docs)] // documentation missing in model
    ReverseGeocoding,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VectorEnrichmentJobType {
    fn from(s: &str) -> Self {
        match s {
            "MAP_MATCHING" => VectorEnrichmentJobType::MapMatching,
            "REVERSE_GEOCODING" => VectorEnrichmentJobType::ReverseGeocoding,
            other => VectorEnrichmentJobType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for VectorEnrichmentJobType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VectorEnrichmentJobType::from(s))
    }
}
impl VectorEnrichmentJobType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VectorEnrichmentJobType::MapMatching => "MAP_MATCHING",
            VectorEnrichmentJobType::ReverseGeocoding => "REVERSE_GEOCODING",
            VectorEnrichmentJobType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["MAP_MATCHING", "REVERSE_GEOCODING"]
    }
}
impl AsRef<str> for VectorEnrichmentJobType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SortOrder`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sortorder = unimplemented!();
/// match sortorder {
///     SortOrder::Ascending => { /* ... */ },
///     SortOrder::Descending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sortorder` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SortOrder::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SortOrder::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SortOrder::NewFeature` is defined.
/// Specifically, when `sortorder` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SortOrder::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortOrder {
    /// ASCENDING
    Ascending,
    /// DESCENDING
    Descending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SortOrder {
    fn from(s: &str) -> Self {
        match s {
            "ASCENDING" => SortOrder::Ascending,
            "DESCENDING" => SortOrder::Descending,
            other => SortOrder::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortOrder::from(s))
    }
}
impl SortOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortOrder::Ascending => "ASCENDING",
            SortOrder::Descending => "DESCENDING",
            SortOrder::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ASCENDING", "DESCENDING"]
    }
}
impl AsRef<str> for SortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>It contains configs such as ReverseGeocodingConfig and MapMatchingConfig.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum VectorEnrichmentJobConfig {
    /// <p></p>
    MapMatchingConfig(crate::model::MapMatchingConfig),
    /// <p></p>
    ReverseGeocodingConfig(crate::model::ReverseGeocodingConfig),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl VectorEnrichmentJobConfig {
    /// Tries to convert the enum instance into [`MapMatchingConfig`](crate::model::VectorEnrichmentJobConfig::MapMatchingConfig), extracting the inner [`MapMatchingConfig`](crate::model::MapMatchingConfig).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_map_matching_config(
        &self,
    ) -> std::result::Result<&crate::model::MapMatchingConfig, &Self> {
        if let VectorEnrichmentJobConfig::MapMatchingConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`MapMatchingConfig`](crate::model::VectorEnrichmentJobConfig::MapMatchingConfig).
    pub fn is_map_matching_config(&self) -> bool {
        self.as_map_matching_config().is_ok()
    }
    /// Tries to convert the enum instance into [`ReverseGeocodingConfig`](crate::model::VectorEnrichmentJobConfig::ReverseGeocodingConfig), extracting the inner [`ReverseGeocodingConfig`](crate::model::ReverseGeocodingConfig).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_reverse_geocoding_config(
        &self,
    ) -> std::result::Result<&crate::model::ReverseGeocodingConfig, &Self> {
        if let VectorEnrichmentJobConfig::ReverseGeocodingConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ReverseGeocodingConfig`](crate::model::VectorEnrichmentJobConfig::ReverseGeocodingConfig).
    pub fn is_reverse_geocoding_config(&self) -> bool {
        self.as_reverse_geocoding_config().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MapMatchingConfig {
    /// <p></p>
    #[doc(hidden)]
    pub id_attribute_name: std::option::Option<std::string::String>,
    /// <p>The name of the Y-attribute</p>
    #[doc(hidden)]
    pub y_attribute_name: std::option::Option<std::string::String>,
    /// <p>The name of the X-attribute</p>
    #[doc(hidden)]
    pub x_attribute_name: std::option::Option<std::string::String>,
    /// <p>The name of the timestamp attribute.</p>
    #[doc(hidden)]
    pub timestamp_attribute_name: std::option::Option<std::string::String>,
}
impl MapMatchingConfig {
    /// <p></p>
    pub fn id_attribute_name(&self) -> std::option::Option<&str> {
        self.id_attribute_name.as_deref()
    }
    /// <p>The name of the Y-attribute</p>
    pub fn y_attribute_name(&self) -> std::option::Option<&str> {
        self.y_attribute_name.as_deref()
    }
    /// <p>The name of the X-attribute</p>
    pub fn x_attribute_name(&self) -> std::option::Option<&str> {
        self.x_attribute_name.as_deref()
    }
    /// <p>The name of the timestamp attribute.</p>
    pub fn timestamp_attribute_name(&self) -> std::option::Option<&str> {
        self.timestamp_attribute_name.as_deref()
    }
}
/// See [`MapMatchingConfig`](crate::model::MapMatchingConfig).
pub mod map_matching_config {

    /// A builder for [`MapMatchingConfig`](crate::model::MapMatchingConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id_attribute_name: std::option::Option<std::string::String>,
        pub(crate) y_attribute_name: std::option::Option<std::string::String>,
        pub(crate) x_attribute_name: std::option::Option<std::string::String>,
        pub(crate) timestamp_attribute_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p></p>
        pub fn id_attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.id_attribute_name = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_id_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.id_attribute_name = input;
            self
        }
        /// <p>The name of the Y-attribute</p>
        pub fn y_attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.y_attribute_name = Some(input.into());
            self
        }
        /// <p>The name of the Y-attribute</p>
        pub fn set_y_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.y_attribute_name = input;
            self
        }
        /// <p>The name of the X-attribute</p>
        pub fn x_attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.x_attribute_name = Some(input.into());
            self
        }
        /// <p>The name of the X-attribute</p>
        pub fn set_x_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.x_attribute_name = input;
            self
        }
        /// <p>The name of the timestamp attribute.</p>
        pub fn timestamp_attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.timestamp_attribute_name = Some(input.into());
            self
        }
        /// <p>The name of the timestamp attribute.</p>
        pub fn set_timestamp_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.timestamp_attribute_name = input;
            self
        }
        /// Consumes the builder and constructs a [`MapMatchingConfig`](crate::model::MapMatchingConfig).
        pub fn build(self) -> crate::model::MapMatchingConfig {
            crate::model::MapMatchingConfig {
                id_attribute_name: self.id_attribute_name,
                y_attribute_name: self.y_attribute_name,
                x_attribute_name: self.x_attribute_name,
                timestamp_attribute_name: self.timestamp_attribute_name,
            }
        }
    }
}
impl MapMatchingConfig {
    /// Creates a new builder-style object to manufacture [`MapMatchingConfig`](crate::model::MapMatchingConfig).
    pub fn builder() -> crate::model::map_matching_config::Builder {
        crate::model::map_matching_config::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReverseGeocodingConfig {
    /// <p></p>
    #[doc(hidden)]
    pub y_attribute_name: std::option::Option<std::string::String>,
    /// <p></p>
    #[doc(hidden)]
    pub x_attribute_name: std::option::Option<std::string::String>,
}
impl ReverseGeocodingConfig {
    /// <p></p>
    pub fn y_attribute_name(&self) -> std::option::Option<&str> {
        self.y_attribute_name.as_deref()
    }
    /// <p></p>
    pub fn x_attribute_name(&self) -> std::option::Option<&str> {
        self.x_attribute_name.as_deref()
    }
}
/// See [`ReverseGeocodingConfig`](crate::model::ReverseGeocodingConfig).
pub mod reverse_geocoding_config {

    /// A builder for [`ReverseGeocodingConfig`](crate::model::ReverseGeocodingConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) y_attribute_name: std::option::Option<std::string::String>,
        pub(crate) x_attribute_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p></p>
        pub fn y_attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.y_attribute_name = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_y_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.y_attribute_name = input;
            self
        }
        /// <p></p>
        pub fn x_attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.x_attribute_name = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_x_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.x_attribute_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ReverseGeocodingConfig`](crate::model::ReverseGeocodingConfig).
        pub fn build(self) -> crate::model::ReverseGeocodingConfig {
            crate::model::ReverseGeocodingConfig {
                y_attribute_name: self.y_attribute_name,
                x_attribute_name: self.x_attribute_name,
            }
        }
    }
}
impl ReverseGeocodingConfig {
    /// Creates a new builder-style object to manufacture [`ReverseGeocodingConfig`](crate::model::ReverseGeocodingConfig).
    pub fn builder() -> crate::model::reverse_geocoding_config::Builder {
        crate::model::reverse_geocoding_config::Builder::default()
    }
}

/// <p>The input structure for the InputConfig in a VectorEnrichmentJob.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VectorEnrichmentJobInputConfig {
    /// <p></p>
    #[doc(hidden)]
    pub document_type: std::option::Option<crate::model::VectorEnrichmentJobDocumentType>,
    /// <p></p>
    #[doc(hidden)]
    pub data_source_config:
        std::option::Option<crate::model::VectorEnrichmentJobDataSourceConfigInput>,
}
impl VectorEnrichmentJobInputConfig {
    /// <p></p>
    pub fn document_type(
        &self,
    ) -> std::option::Option<&crate::model::VectorEnrichmentJobDocumentType> {
        self.document_type.as_ref()
    }
    /// <p></p>
    pub fn data_source_config(
        &self,
    ) -> std::option::Option<&crate::model::VectorEnrichmentJobDataSourceConfigInput> {
        self.data_source_config.as_ref()
    }
}
/// See [`VectorEnrichmentJobInputConfig`](crate::model::VectorEnrichmentJobInputConfig).
pub mod vector_enrichment_job_input_config {

    /// A builder for [`VectorEnrichmentJobInputConfig`](crate::model::VectorEnrichmentJobInputConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_type:
            std::option::Option<crate::model::VectorEnrichmentJobDocumentType>,
        pub(crate) data_source_config:
            std::option::Option<crate::model::VectorEnrichmentJobDataSourceConfigInput>,
    }
    impl Builder {
        /// <p></p>
        pub fn document_type(
            mut self,
            input: crate::model::VectorEnrichmentJobDocumentType,
        ) -> Self {
            self.document_type = Some(input);
            self
        }
        /// <p></p>
        pub fn set_document_type(
            mut self,
            input: std::option::Option<crate::model::VectorEnrichmentJobDocumentType>,
        ) -> Self {
            self.document_type = input;
            self
        }
        /// <p></p>
        pub fn data_source_config(
            mut self,
            input: crate::model::VectorEnrichmentJobDataSourceConfigInput,
        ) -> Self {
            self.data_source_config = Some(input);
            self
        }
        /// <p></p>
        pub fn set_data_source_config(
            mut self,
            input: std::option::Option<crate::model::VectorEnrichmentJobDataSourceConfigInput>,
        ) -> Self {
            self.data_source_config = input;
            self
        }
        /// Consumes the builder and constructs a [`VectorEnrichmentJobInputConfig`](crate::model::VectorEnrichmentJobInputConfig).
        pub fn build(self) -> crate::model::VectorEnrichmentJobInputConfig {
            crate::model::VectorEnrichmentJobInputConfig {
                document_type: self.document_type,
                data_source_config: self.data_source_config,
            }
        }
    }
}
impl VectorEnrichmentJobInputConfig {
    /// Creates a new builder-style object to manufacture [`VectorEnrichmentJobInputConfig`](crate::model::VectorEnrichmentJobInputConfig).
    pub fn builder() -> crate::model::vector_enrichment_job_input_config::Builder {
        crate::model::vector_enrichment_job_input_config::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum VectorEnrichmentJobDataSourceConfigInput {
    /// <p></p>
    S3Data(crate::model::VectorEnrichmentJobS3Data),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl VectorEnrichmentJobDataSourceConfigInput {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`S3Data`](crate::model::VectorEnrichmentJobDataSourceConfigInput::S3Data), extracting the inner [`VectorEnrichmentJobS3Data`](crate::model::VectorEnrichmentJobS3Data).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_s3_data(
        &self,
    ) -> std::result::Result<&crate::model::VectorEnrichmentJobS3Data, &Self> {
        if let VectorEnrichmentJobDataSourceConfigInput::S3Data(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`S3Data`](crate::model::VectorEnrichmentJobDataSourceConfigInput::S3Data).
    pub fn is_s3_data(&self) -> bool {
        self.as_s3_data().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// When writing a match expression against `VectorEnrichmentJobDocumentType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let vectorenrichmentjobdocumenttype = unimplemented!();
/// match vectorenrichmentjobdocumenttype {
///     VectorEnrichmentJobDocumentType::Csv => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `vectorenrichmentjobdocumenttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VectorEnrichmentJobDocumentType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VectorEnrichmentJobDocumentType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VectorEnrichmentJobDocumentType::NewFeature` is defined.
/// Specifically, when `vectorenrichmentjobdocumenttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VectorEnrichmentJobDocumentType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VectorEnrichmentJobDocumentType {
    #[allow(missing_docs)] // documentation missing in model
    Csv,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VectorEnrichmentJobDocumentType {
    fn from(s: &str) -> Self {
        match s {
            "CSV" => VectorEnrichmentJobDocumentType::Csv,
            other => VectorEnrichmentJobDocumentType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for VectorEnrichmentJobDocumentType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VectorEnrichmentJobDocumentType::from(s))
    }
}
impl VectorEnrichmentJobDocumentType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VectorEnrichmentJobDocumentType::Csv => "CSV",
            VectorEnrichmentJobDocumentType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CSV"]
    }
}
impl AsRef<str> for VectorEnrichmentJobDocumentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>VectorEnrichmentJob export error details in response from GetVectorEnrichmentJob.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VectorEnrichmentJobExportErrorDetails {
    /// <p></p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::VectorEnrichmentJobExportErrorType>,
    /// <p>The message providing details about the errors generated during the Vector Enrichment job.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl VectorEnrichmentJobExportErrorDetails {
    /// <p></p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::VectorEnrichmentJobExportErrorType> {
        self.r#type.as_ref()
    }
    /// <p>The message providing details about the errors generated during the Vector Enrichment job.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`VectorEnrichmentJobExportErrorDetails`](crate::model::VectorEnrichmentJobExportErrorDetails).
pub mod vector_enrichment_job_export_error_details {

    /// A builder for [`VectorEnrichmentJobExportErrorDetails`](crate::model::VectorEnrichmentJobExportErrorDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::VectorEnrichmentJobExportErrorType>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p></p>
        pub fn r#type(mut self, input: crate::model::VectorEnrichmentJobExportErrorType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p></p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::VectorEnrichmentJobExportErrorType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The message providing details about the errors generated during the Vector Enrichment job.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message providing details about the errors generated during the Vector Enrichment job.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`VectorEnrichmentJobExportErrorDetails`](crate::model::VectorEnrichmentJobExportErrorDetails).
        pub fn build(self) -> crate::model::VectorEnrichmentJobExportErrorDetails {
            crate::model::VectorEnrichmentJobExportErrorDetails {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl VectorEnrichmentJobExportErrorDetails {
    /// Creates a new builder-style object to manufacture [`VectorEnrichmentJobExportErrorDetails`](crate::model::VectorEnrichmentJobExportErrorDetails).
    pub fn builder() -> crate::model::vector_enrichment_job_export_error_details::Builder {
        crate::model::vector_enrichment_job_export_error_details::Builder::default()
    }
}

/// When writing a match expression against `VectorEnrichmentJobExportErrorType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let vectorenrichmentjobexporterrortype = unimplemented!();
/// match vectorenrichmentjobexporterrortype {
///     VectorEnrichmentJobExportErrorType::ClientError => { /* ... */ },
///     VectorEnrichmentJobExportErrorType::ServerError => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `vectorenrichmentjobexporterrortype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VectorEnrichmentJobExportErrorType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VectorEnrichmentJobExportErrorType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VectorEnrichmentJobExportErrorType::NewFeature` is defined.
/// Specifically, when `vectorenrichmentjobexporterrortype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VectorEnrichmentJobExportErrorType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VectorEnrichmentJobExportErrorType {
    #[allow(missing_docs)] // documentation missing in model
    ClientError,
    #[allow(missing_docs)] // documentation missing in model
    ServerError,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VectorEnrichmentJobExportErrorType {
    fn from(s: &str) -> Self {
        match s {
            "CLIENT_ERROR" => VectorEnrichmentJobExportErrorType::ClientError,
            "SERVER_ERROR" => VectorEnrichmentJobExportErrorType::ServerError,
            other => VectorEnrichmentJobExportErrorType::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for VectorEnrichmentJobExportErrorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VectorEnrichmentJobExportErrorType::from(s))
    }
}
impl VectorEnrichmentJobExportErrorType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VectorEnrichmentJobExportErrorType::ClientError => "CLIENT_ERROR",
            VectorEnrichmentJobExportErrorType::ServerError => "SERVER_ERROR",
            VectorEnrichmentJobExportErrorType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CLIENT_ERROR", "SERVER_ERROR"]
    }
}
impl AsRef<str> for VectorEnrichmentJobExportErrorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>VectorEnrichmentJob error details in response from GetVectorEnrichmentJob.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VectorEnrichmentJobErrorDetails {
    /// <p>The type of error generated during the Vector Enrichment job.</p>
    #[doc(hidden)]
    pub error_type: std::option::Option<crate::model::VectorEnrichmentJobErrorType>,
    /// <p>A message that you define and then is processed and rendered by the Vector Enrichment job when the error occurs.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl VectorEnrichmentJobErrorDetails {
    /// <p>The type of error generated during the Vector Enrichment job.</p>
    pub fn error_type(&self) -> std::option::Option<&crate::model::VectorEnrichmentJobErrorType> {
        self.error_type.as_ref()
    }
    /// <p>A message that you define and then is processed and rendered by the Vector Enrichment job when the error occurs.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`VectorEnrichmentJobErrorDetails`](crate::model::VectorEnrichmentJobErrorDetails).
pub mod vector_enrichment_job_error_details {

    /// A builder for [`VectorEnrichmentJobErrorDetails`](crate::model::VectorEnrichmentJobErrorDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_type: std::option::Option<crate::model::VectorEnrichmentJobErrorType>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of error generated during the Vector Enrichment job.</p>
        pub fn error_type(mut self, input: crate::model::VectorEnrichmentJobErrorType) -> Self {
            self.error_type = Some(input);
            self
        }
        /// <p>The type of error generated during the Vector Enrichment job.</p>
        pub fn set_error_type(
            mut self,
            input: std::option::Option<crate::model::VectorEnrichmentJobErrorType>,
        ) -> Self {
            self.error_type = input;
            self
        }
        /// <p>A message that you define and then is processed and rendered by the Vector Enrichment job when the error occurs.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>A message that you define and then is processed and rendered by the Vector Enrichment job when the error occurs.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`VectorEnrichmentJobErrorDetails`](crate::model::VectorEnrichmentJobErrorDetails).
        pub fn build(self) -> crate::model::VectorEnrichmentJobErrorDetails {
            crate::model::VectorEnrichmentJobErrorDetails {
                error_type: self.error_type,
                error_message: self.error_message,
            }
        }
    }
}
impl VectorEnrichmentJobErrorDetails {
    /// Creates a new builder-style object to manufacture [`VectorEnrichmentJobErrorDetails`](crate::model::VectorEnrichmentJobErrorDetails).
    pub fn builder() -> crate::model::vector_enrichment_job_error_details::Builder {
        crate::model::vector_enrichment_job_error_details::Builder::default()
    }
}

/// When writing a match expression against `VectorEnrichmentJobErrorType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let vectorenrichmentjoberrortype = unimplemented!();
/// match vectorenrichmentjoberrortype {
///     VectorEnrichmentJobErrorType::ClientError => { /* ... */ },
///     VectorEnrichmentJobErrorType::ServerError => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `vectorenrichmentjoberrortype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VectorEnrichmentJobErrorType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VectorEnrichmentJobErrorType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VectorEnrichmentJobErrorType::NewFeature` is defined.
/// Specifically, when `vectorenrichmentjoberrortype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VectorEnrichmentJobErrorType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VectorEnrichmentJobErrorType {
    /// CLIENT_ERROR
    ClientError,
    /// SERVER_ERROR
    ServerError,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VectorEnrichmentJobErrorType {
    fn from(s: &str) -> Self {
        match s {
            "CLIENT_ERROR" => VectorEnrichmentJobErrorType::ClientError,
            "SERVER_ERROR" => VectorEnrichmentJobErrorType::ServerError,
            other => VectorEnrichmentJobErrorType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for VectorEnrichmentJobErrorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VectorEnrichmentJobErrorType::from(s))
    }
}
impl VectorEnrichmentJobErrorType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VectorEnrichmentJobErrorType::ClientError => "CLIENT_ERROR",
            VectorEnrichmentJobErrorType::ServerError => "SERVER_ERROR",
            VectorEnrichmentJobErrorType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CLIENT_ERROR", "SERVER_ERROR"]
    }
}
impl AsRef<str> for VectorEnrichmentJobErrorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Structure representing the items in the response for SearchRasterDataCollection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ItemSource {
    /// <p>A unique Id for the source item.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p></p>
    #[doc(hidden)]
    pub geometry: std::option::Option<crate::model::Geometry>,
    /// <p></p>
    #[doc(hidden)]
    pub assets: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AssetValue>,
    >,
    /// <p></p>
    #[doc(hidden)]
    pub date_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p></p>
    #[doc(hidden)]
    pub properties: std::option::Option<crate::model::Properties>,
}
impl ItemSource {
    /// <p>A unique Id for the source item.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p></p>
    pub fn geometry(&self) -> std::option::Option<&crate::model::Geometry> {
        self.geometry.as_ref()
    }
    /// <p></p>
    pub fn assets(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::AssetValue>,
    > {
        self.assets.as_ref()
    }
    /// <p></p>
    pub fn date_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.date_time.as_ref()
    }
    /// <p></p>
    pub fn properties(&self) -> std::option::Option<&crate::model::Properties> {
        self.properties.as_ref()
    }
}
/// See [`ItemSource`](crate::model::ItemSource).
pub mod item_source {

    /// A builder for [`ItemSource`](crate::model::ItemSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) geometry: std::option::Option<crate::model::Geometry>,
        pub(crate) assets: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AssetValue>,
        >,
        pub(crate) date_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) properties: std::option::Option<crate::model::Properties>,
    }
    impl Builder {
        /// <p>A unique Id for the source item.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A unique Id for the source item.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p></p>
        pub fn geometry(mut self, input: crate::model::Geometry) -> Self {
            self.geometry = Some(input);
            self
        }
        /// <p></p>
        pub fn set_geometry(mut self, input: std::option::Option<crate::model::Geometry>) -> Self {
            self.geometry = input;
            self
        }
        /// Adds a key-value pair to `assets`.
        ///
        /// To override the contents of this collection use [`set_assets`](Self::set_assets).
        ///
        /// <p></p>
        pub fn assets(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::AssetValue,
        ) -> Self {
            let mut hash_map = self.assets.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.assets = Some(hash_map);
            self
        }
        /// <p></p>
        pub fn set_assets(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AssetValue>,
            >,
        ) -> Self {
            self.assets = input;
            self
        }
        /// <p></p>
        pub fn date_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.date_time = Some(input);
            self
        }
        /// <p></p>
        pub fn set_date_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.date_time = input;
            self
        }
        /// <p></p>
        pub fn properties(mut self, input: crate::model::Properties) -> Self {
            self.properties = Some(input);
            self
        }
        /// <p></p>
        pub fn set_properties(
            mut self,
            input: std::option::Option<crate::model::Properties>,
        ) -> Self {
            self.properties = input;
            self
        }
        /// Consumes the builder and constructs a [`ItemSource`](crate::model::ItemSource).
        pub fn build(self) -> crate::model::ItemSource {
            crate::model::ItemSource {
                id: self.id,
                geometry: self.geometry,
                assets: self.assets,
                date_time: self.date_time,
                properties: self.properties,
            }
        }
    }
}
impl ItemSource {
    /// Creates a new builder-style object to manufacture [`ItemSource`](crate::model::ItemSource).
    pub fn builder() -> crate::model::item_source::Builder {
        crate::model::item_source::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Properties {
    /// <p></p>
    #[doc(hidden)]
    pub eo_cloud_cover: std::option::Option<f32>,
    /// <p></p>
    #[doc(hidden)]
    pub view_off_nadir: std::option::Option<f32>,
    /// <p></p>
    #[doc(hidden)]
    pub view_sun_azimuth: std::option::Option<f32>,
    /// <p></p>
    #[doc(hidden)]
    pub view_sun_elevation: std::option::Option<f32>,
    /// <p></p>
    #[doc(hidden)]
    pub platform: std::option::Option<std::string::String>,
    /// <p></p>
    #[doc(hidden)]
    pub landsat_cloud_cover_land: std::option::Option<f32>,
}
impl Properties {
    /// <p></p>
    pub fn eo_cloud_cover(&self) -> std::option::Option<f32> {
        self.eo_cloud_cover
    }
    /// <p></p>
    pub fn view_off_nadir(&self) -> std::option::Option<f32> {
        self.view_off_nadir
    }
    /// <p></p>
    pub fn view_sun_azimuth(&self) -> std::option::Option<f32> {
        self.view_sun_azimuth
    }
    /// <p></p>
    pub fn view_sun_elevation(&self) -> std::option::Option<f32> {
        self.view_sun_elevation
    }
    /// <p></p>
    pub fn platform(&self) -> std::option::Option<&str> {
        self.platform.as_deref()
    }
    /// <p></p>
    pub fn landsat_cloud_cover_land(&self) -> std::option::Option<f32> {
        self.landsat_cloud_cover_land
    }
}
/// See [`Properties`](crate::model::Properties).
pub mod properties {

    /// A builder for [`Properties`](crate::model::Properties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) eo_cloud_cover: std::option::Option<f32>,
        pub(crate) view_off_nadir: std::option::Option<f32>,
        pub(crate) view_sun_azimuth: std::option::Option<f32>,
        pub(crate) view_sun_elevation: std::option::Option<f32>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) landsat_cloud_cover_land: std::option::Option<f32>,
    }
    impl Builder {
        /// <p></p>
        pub fn eo_cloud_cover(mut self, input: f32) -> Self {
            self.eo_cloud_cover = Some(input);
            self
        }
        /// <p></p>
        pub fn set_eo_cloud_cover(mut self, input: std::option::Option<f32>) -> Self {
            self.eo_cloud_cover = input;
            self
        }
        /// <p></p>
        pub fn view_off_nadir(mut self, input: f32) -> Self {
            self.view_off_nadir = Some(input);
            self
        }
        /// <p></p>
        pub fn set_view_off_nadir(mut self, input: std::option::Option<f32>) -> Self {
            self.view_off_nadir = input;
            self
        }
        /// <p></p>
        pub fn view_sun_azimuth(mut self, input: f32) -> Self {
            self.view_sun_azimuth = Some(input);
            self
        }
        /// <p></p>
        pub fn set_view_sun_azimuth(mut self, input: std::option::Option<f32>) -> Self {
            self.view_sun_azimuth = input;
            self
        }
        /// <p></p>
        pub fn view_sun_elevation(mut self, input: f32) -> Self {
            self.view_sun_elevation = Some(input);
            self
        }
        /// <p></p>
        pub fn set_view_sun_elevation(mut self, input: std::option::Option<f32>) -> Self {
            self.view_sun_elevation = input;
            self
        }
        /// <p></p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p></p>
        pub fn landsat_cloud_cover_land(mut self, input: f32) -> Self {
            self.landsat_cloud_cover_land = Some(input);
            self
        }
        /// <p></p>
        pub fn set_landsat_cloud_cover_land(mut self, input: std::option::Option<f32>) -> Self {
            self.landsat_cloud_cover_land = input;
            self
        }
        /// Consumes the builder and constructs a [`Properties`](crate::model::Properties).
        pub fn build(self) -> crate::model::Properties {
            crate::model::Properties {
                eo_cloud_cover: self.eo_cloud_cover,
                view_off_nadir: self.view_off_nadir,
                view_sun_azimuth: self.view_sun_azimuth,
                view_sun_elevation: self.view_sun_elevation,
                platform: self.platform,
                landsat_cloud_cover_land: self.landsat_cloud_cover_land,
            }
        }
    }
}
impl Properties {
    /// Creates a new builder-style object to manufacture [`Properties`](crate::model::Properties).
    pub fn builder() -> crate::model::properties::Builder {
        crate::model::properties::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssetValue {
    /// <p></p>
    #[doc(hidden)]
    pub href: std::option::Option<std::string::String>,
}
impl AssetValue {
    /// <p></p>
    pub fn href(&self) -> std::option::Option<&str> {
        self.href.as_deref()
    }
}
/// See [`AssetValue`](crate::model::AssetValue).
pub mod asset_value {

    /// A builder for [`AssetValue`](crate::model::AssetValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) href: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p></p>
        pub fn href(mut self, input: impl Into<std::string::String>) -> Self {
            self.href = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_href(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.href = input;
            self
        }
        /// Consumes the builder and constructs a [`AssetValue`](crate::model::AssetValue).
        pub fn build(self) -> crate::model::AssetValue {
            crate::model::AssetValue { href: self.href }
        }
    }
}
impl AssetValue {
    /// Creates a new builder-style object to manufacture [`AssetValue`](crate::model::AssetValue).
    pub fn builder() -> crate::model::asset_value::Builder {
        crate::model::asset_value::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Geometry {
    /// <p></p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p></p>
    #[doc(hidden)]
    pub coordinates: std::option::Option<std::vec::Vec<std::vec::Vec<std::vec::Vec<f64>>>>,
}
impl Geometry {
    /// <p></p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p></p>
    pub fn coordinates(&self) -> std::option::Option<&[std::vec::Vec<std::vec::Vec<f64>>]> {
        self.coordinates.as_deref()
    }
}
/// See [`Geometry`](crate::model::Geometry).
pub mod geometry {

    /// A builder for [`Geometry`](crate::model::Geometry).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) coordinates:
            std::option::Option<std::vec::Vec<std::vec::Vec<std::vec::Vec<f64>>>>,
    }
    impl Builder {
        /// <p></p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Appends an item to `coordinates`.
        ///
        /// To override the contents of this collection use [`set_coordinates`](Self::set_coordinates).
        ///
        /// <p></p>
        pub fn coordinates(mut self, input: std::vec::Vec<std::vec::Vec<f64>>) -> Self {
            let mut v = self.coordinates.unwrap_or_default();
            v.push(input);
            self.coordinates = Some(v);
            self
        }
        /// <p></p>
        pub fn set_coordinates(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<std::vec::Vec<f64>>>>,
        ) -> Self {
            self.coordinates = input;
            self
        }
        /// Consumes the builder and constructs a [`Geometry`](crate::model::Geometry).
        pub fn build(self) -> crate::model::Geometry {
            crate::model::Geometry {
                r#type: self.r#type,
                coordinates: self.coordinates,
            }
        }
    }
}
impl Geometry {
    /// Creates a new builder-style object to manufacture [`Geometry`](crate::model::Geometry).
    pub fn builder() -> crate::model::geometry::Builder {
        crate::model::geometry::Builder::default()
    }
}

/// <p>This is a RasterDataCollectionQueryInput containing AreaOfInterest, Time Range filter and Property filters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RasterDataCollectionQueryWithBandFilterInput {
    /// <p></p>
    #[doc(hidden)]
    pub time_range_filter: std::option::Option<crate::model::TimeRangeFilterInput>,
    /// <p></p>
    #[doc(hidden)]
    pub area_of_interest: std::option::Option<crate::model::AreaOfInterest>,
    /// <p></p>
    #[doc(hidden)]
    pub property_filters: std::option::Option<crate::model::PropertyFilters>,
    /// <p></p>
    #[doc(hidden)]
    pub band_filter: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl RasterDataCollectionQueryWithBandFilterInput {
    /// <p></p>
    pub fn time_range_filter(&self) -> std::option::Option<&crate::model::TimeRangeFilterInput> {
        self.time_range_filter.as_ref()
    }
    /// <p></p>
    pub fn area_of_interest(&self) -> std::option::Option<&crate::model::AreaOfInterest> {
        self.area_of_interest.as_ref()
    }
    /// <p></p>
    pub fn property_filters(&self) -> std::option::Option<&crate::model::PropertyFilters> {
        self.property_filters.as_ref()
    }
    /// <p></p>
    pub fn band_filter(&self) -> std::option::Option<&[std::string::String]> {
        self.band_filter.as_deref()
    }
}
impl std::fmt::Debug for RasterDataCollectionQueryWithBandFilterInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RasterDataCollectionQueryWithBandFilterInput");
        formatter.field("time_range_filter", &"*** Sensitive Data Redacted ***");
        formatter.field("area_of_interest", &self.area_of_interest);
        formatter.field("property_filters", &self.property_filters);
        formatter.field("band_filter", &self.band_filter);
        formatter.finish()
    }
}
/// See [`RasterDataCollectionQueryWithBandFilterInput`](crate::model::RasterDataCollectionQueryWithBandFilterInput).
pub mod raster_data_collection_query_with_band_filter_input {

    /// A builder for [`RasterDataCollectionQueryWithBandFilterInput`](crate::model::RasterDataCollectionQueryWithBandFilterInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) time_range_filter: std::option::Option<crate::model::TimeRangeFilterInput>,
        pub(crate) area_of_interest: std::option::Option<crate::model::AreaOfInterest>,
        pub(crate) property_filters: std::option::Option<crate::model::PropertyFilters>,
        pub(crate) band_filter: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p></p>
        pub fn time_range_filter(mut self, input: crate::model::TimeRangeFilterInput) -> Self {
            self.time_range_filter = Some(input);
            self
        }
        /// <p></p>
        pub fn set_time_range_filter(
            mut self,
            input: std::option::Option<crate::model::TimeRangeFilterInput>,
        ) -> Self {
            self.time_range_filter = input;
            self
        }
        /// <p></p>
        pub fn area_of_interest(mut self, input: crate::model::AreaOfInterest) -> Self {
            self.area_of_interest = Some(input);
            self
        }
        /// <p></p>
        pub fn set_area_of_interest(
            mut self,
            input: std::option::Option<crate::model::AreaOfInterest>,
        ) -> Self {
            self.area_of_interest = input;
            self
        }
        /// <p></p>
        pub fn property_filters(mut self, input: crate::model::PropertyFilters) -> Self {
            self.property_filters = Some(input);
            self
        }
        /// <p></p>
        pub fn set_property_filters(
            mut self,
            input: std::option::Option<crate::model::PropertyFilters>,
        ) -> Self {
            self.property_filters = input;
            self
        }
        /// Appends an item to `band_filter`.
        ///
        /// To override the contents of this collection use [`set_band_filter`](Self::set_band_filter).
        ///
        /// <p></p>
        pub fn band_filter(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.band_filter.unwrap_or_default();
            v.push(input.into());
            self.band_filter = Some(v);
            self
        }
        /// <p></p>
        pub fn set_band_filter(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.band_filter = input;
            self
        }
        /// Consumes the builder and constructs a [`RasterDataCollectionQueryWithBandFilterInput`](crate::model::RasterDataCollectionQueryWithBandFilterInput).
        pub fn build(self) -> crate::model::RasterDataCollectionQueryWithBandFilterInput {
            crate::model::RasterDataCollectionQueryWithBandFilterInput {
                time_range_filter: self.time_range_filter,
                area_of_interest: self.area_of_interest,
                property_filters: self.property_filters,
                band_filter: self.band_filter,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("time_range_filter", &"*** Sensitive Data Redacted ***");
            formatter.field("area_of_interest", &self.area_of_interest);
            formatter.field("property_filters", &self.property_filters);
            formatter.field("band_filter", &self.band_filter);
            formatter.finish()
        }
    }
}
impl RasterDataCollectionQueryWithBandFilterInput {
    /// Creates a new builder-style object to manufacture [`RasterDataCollectionQueryWithBandFilterInput`](crate::model::RasterDataCollectionQueryWithBandFilterInput).
    pub fn builder() -> crate::model::raster_data_collection_query_with_band_filter_input::Builder {
        crate::model::raster_data_collection_query_with_band_filter_input::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyFilters {
    /// <p></p>
    #[doc(hidden)]
    pub properties: std::option::Option<std::vec::Vec<crate::model::PropertyFilter>>,
    /// <p></p>
    #[doc(hidden)]
    pub logical_operator: std::option::Option<crate::model::LogicalOperator>,
}
impl PropertyFilters {
    /// <p></p>
    pub fn properties(&self) -> std::option::Option<&[crate::model::PropertyFilter]> {
        self.properties.as_deref()
    }
    /// <p></p>
    pub fn logical_operator(&self) -> std::option::Option<&crate::model::LogicalOperator> {
        self.logical_operator.as_ref()
    }
}
/// See [`PropertyFilters`](crate::model::PropertyFilters).
pub mod property_filters {

    /// A builder for [`PropertyFilters`](crate::model::PropertyFilters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) properties: std::option::Option<std::vec::Vec<crate::model::PropertyFilter>>,
        pub(crate) logical_operator: std::option::Option<crate::model::LogicalOperator>,
    }
    impl Builder {
        /// Appends an item to `properties`.
        ///
        /// To override the contents of this collection use [`set_properties`](Self::set_properties).
        ///
        /// <p></p>
        pub fn properties(mut self, input: crate::model::PropertyFilter) -> Self {
            let mut v = self.properties.unwrap_or_default();
            v.push(input);
            self.properties = Some(v);
            self
        }
        /// <p></p>
        pub fn set_properties(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PropertyFilter>>,
        ) -> Self {
            self.properties = input;
            self
        }
        /// <p></p>
        pub fn logical_operator(mut self, input: crate::model::LogicalOperator) -> Self {
            self.logical_operator = Some(input);
            self
        }
        /// <p></p>
        pub fn set_logical_operator(
            mut self,
            input: std::option::Option<crate::model::LogicalOperator>,
        ) -> Self {
            self.logical_operator = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyFilters`](crate::model::PropertyFilters).
        pub fn build(self) -> crate::model::PropertyFilters {
            crate::model::PropertyFilters {
                properties: self.properties,
                logical_operator: self.logical_operator,
            }
        }
    }
}
impl PropertyFilters {
    /// Creates a new builder-style object to manufacture [`PropertyFilters`](crate::model::PropertyFilters).
    pub fn builder() -> crate::model::property_filters::Builder {
        crate::model::property_filters::Builder::default()
    }
}

/// When writing a match expression against `LogicalOperator`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let logicaloperator = unimplemented!();
/// match logicaloperator {
///     LogicalOperator::And => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `logicaloperator` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LogicalOperator::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LogicalOperator::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LogicalOperator::NewFeature` is defined.
/// Specifically, when `logicaloperator` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LogicalOperator::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LogicalOperator {
    /// AND
    And,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LogicalOperator {
    fn from(s: &str) -> Self {
        match s {
            "AND" => LogicalOperator::And,
            other => LogicalOperator::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LogicalOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LogicalOperator::from(s))
    }
}
impl LogicalOperator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LogicalOperator::And => "AND",
            LogicalOperator::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AND"]
    }
}
impl AsRef<str> for LogicalOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PropertyFilter {
    /// <p></p>
    #[doc(hidden)]
    pub property: std::option::Option<crate::model::Property>,
}
impl PropertyFilter {
    /// <p></p>
    pub fn property(&self) -> std::option::Option<&crate::model::Property> {
        self.property.as_ref()
    }
}
/// See [`PropertyFilter`](crate::model::PropertyFilter).
pub mod property_filter {

    /// A builder for [`PropertyFilter`](crate::model::PropertyFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property: std::option::Option<crate::model::Property>,
    }
    impl Builder {
        /// <p></p>
        pub fn property(mut self, input: crate::model::Property) -> Self {
            self.property = Some(input);
            self
        }
        /// <p></p>
        pub fn set_property(mut self, input: std::option::Option<crate::model::Property>) -> Self {
            self.property = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyFilter`](crate::model::PropertyFilter).
        pub fn build(self) -> crate::model::PropertyFilter {
            crate::model::PropertyFilter {
                property: self.property,
            }
        }
    }
}
impl PropertyFilter {
    /// Creates a new builder-style object to manufacture [`PropertyFilter`](crate::model::PropertyFilter).
    pub fn builder() -> crate::model::property_filter::Builder {
        crate::model::property_filter::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum Property {
    /// <p></p>
    EoCloudCover(crate::model::EoCloudCoverInput),
    /// <p></p>
    LandsatCloudCoverLand(crate::model::LandsatCloudCoverLandInput),
    /// <p></p>
    Platform(crate::model::PlatformInput),
    /// <p></p>
    ViewOffNadir(crate::model::ViewOffNadirInput),
    /// <p></p>
    ViewSunAzimuth(crate::model::ViewSunAzimuthInput),
    /// <p></p>
    ViewSunElevation(crate::model::ViewSunElevationInput),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl Property {
    /// Tries to convert the enum instance into [`EoCloudCover`](crate::model::Property::EoCloudCover), extracting the inner [`EoCloudCoverInput`](crate::model::EoCloudCoverInput).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_eo_cloud_cover(
        &self,
    ) -> std::result::Result<&crate::model::EoCloudCoverInput, &Self> {
        if let Property::EoCloudCover(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`EoCloudCover`](crate::model::Property::EoCloudCover).
    pub fn is_eo_cloud_cover(&self) -> bool {
        self.as_eo_cloud_cover().is_ok()
    }
    /// Tries to convert the enum instance into [`LandsatCloudCoverLand`](crate::model::Property::LandsatCloudCoverLand), extracting the inner [`LandsatCloudCoverLandInput`](crate::model::LandsatCloudCoverLandInput).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_landsat_cloud_cover_land(
        &self,
    ) -> std::result::Result<&crate::model::LandsatCloudCoverLandInput, &Self> {
        if let Property::LandsatCloudCoverLand(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`LandsatCloudCoverLand`](crate::model::Property::LandsatCloudCoverLand).
    pub fn is_landsat_cloud_cover_land(&self) -> bool {
        self.as_landsat_cloud_cover_land().is_ok()
    }
    /// Tries to convert the enum instance into [`Platform`](crate::model::Property::Platform), extracting the inner [`PlatformInput`](crate::model::PlatformInput).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_platform(&self) -> std::result::Result<&crate::model::PlatformInput, &Self> {
        if let Property::Platform(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Platform`](crate::model::Property::Platform).
    pub fn is_platform(&self) -> bool {
        self.as_platform().is_ok()
    }
    /// Tries to convert the enum instance into [`ViewOffNadir`](crate::model::Property::ViewOffNadir), extracting the inner [`ViewOffNadirInput`](crate::model::ViewOffNadirInput).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_view_off_nadir(
        &self,
    ) -> std::result::Result<&crate::model::ViewOffNadirInput, &Self> {
        if let Property::ViewOffNadir(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ViewOffNadir`](crate::model::Property::ViewOffNadir).
    pub fn is_view_off_nadir(&self) -> bool {
        self.as_view_off_nadir().is_ok()
    }
    /// Tries to convert the enum instance into [`ViewSunAzimuth`](crate::model::Property::ViewSunAzimuth), extracting the inner [`ViewSunAzimuthInput`](crate::model::ViewSunAzimuthInput).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_view_sun_azimuth(
        &self,
    ) -> std::result::Result<&crate::model::ViewSunAzimuthInput, &Self> {
        if let Property::ViewSunAzimuth(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ViewSunAzimuth`](crate::model::Property::ViewSunAzimuth).
    pub fn is_view_sun_azimuth(&self) -> bool {
        self.as_view_sun_azimuth().is_ok()
    }
    /// Tries to convert the enum instance into [`ViewSunElevation`](crate::model::Property::ViewSunElevation), extracting the inner [`ViewSunElevationInput`](crate::model::ViewSunElevationInput).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_view_sun_elevation(
        &self,
    ) -> std::result::Result<&crate::model::ViewSunElevationInput, &Self> {
        if let Property::ViewSunElevation(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ViewSunElevation`](crate::model::Property::ViewSunElevation).
    pub fn is_view_sun_elevation(&self) -> bool {
        self.as_view_sun_elevation().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LandsatCloudCoverLandInput {
    /// <p></p>
    #[doc(hidden)]
    pub lower_bound: std::option::Option<f32>,
    /// <p></p>
    #[doc(hidden)]
    pub upper_bound: std::option::Option<f32>,
}
impl LandsatCloudCoverLandInput {
    /// <p></p>
    pub fn lower_bound(&self) -> std::option::Option<f32> {
        self.lower_bound
    }
    /// <p></p>
    pub fn upper_bound(&self) -> std::option::Option<f32> {
        self.upper_bound
    }
}
/// See [`LandsatCloudCoverLandInput`](crate::model::LandsatCloudCoverLandInput).
pub mod landsat_cloud_cover_land_input {

    /// A builder for [`LandsatCloudCoverLandInput`](crate::model::LandsatCloudCoverLandInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lower_bound: std::option::Option<f32>,
        pub(crate) upper_bound: std::option::Option<f32>,
    }
    impl Builder {
        /// <p></p>
        pub fn lower_bound(mut self, input: f32) -> Self {
            self.lower_bound = Some(input);
            self
        }
        /// <p></p>
        pub fn set_lower_bound(mut self, input: std::option::Option<f32>) -> Self {
            self.lower_bound = input;
            self
        }
        /// <p></p>
        pub fn upper_bound(mut self, input: f32) -> Self {
            self.upper_bound = Some(input);
            self
        }
        /// <p></p>
        pub fn set_upper_bound(mut self, input: std::option::Option<f32>) -> Self {
            self.upper_bound = input;
            self
        }
        /// Consumes the builder and constructs a [`LandsatCloudCoverLandInput`](crate::model::LandsatCloudCoverLandInput).
        pub fn build(self) -> crate::model::LandsatCloudCoverLandInput {
            crate::model::LandsatCloudCoverLandInput {
                lower_bound: self.lower_bound,
                upper_bound: self.upper_bound,
            }
        }
    }
}
impl LandsatCloudCoverLandInput {
    /// Creates a new builder-style object to manufacture [`LandsatCloudCoverLandInput`](crate::model::LandsatCloudCoverLandInput).
    pub fn builder() -> crate::model::landsat_cloud_cover_land_input::Builder {
        crate::model::landsat_cloud_cover_land_input::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PlatformInput {
    /// <p>The value of the platform.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p></p>
    #[doc(hidden)]
    pub comparison_operator: std::option::Option<crate::model::ComparisonOperator>,
}
impl PlatformInput {
    /// <p>The value of the platform.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p></p>
    pub fn comparison_operator(&self) -> std::option::Option<&crate::model::ComparisonOperator> {
        self.comparison_operator.as_ref()
    }
}
/// See [`PlatformInput`](crate::model::PlatformInput).
pub mod platform_input {

    /// A builder for [`PlatformInput`](crate::model::PlatformInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) comparison_operator: std::option::Option<crate::model::ComparisonOperator>,
    }
    impl Builder {
        /// <p>The value of the platform.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the platform.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p></p>
        pub fn comparison_operator(mut self, input: crate::model::ComparisonOperator) -> Self {
            self.comparison_operator = Some(input);
            self
        }
        /// <p></p>
        pub fn set_comparison_operator(
            mut self,
            input: std::option::Option<crate::model::ComparisonOperator>,
        ) -> Self {
            self.comparison_operator = input;
            self
        }
        /// Consumes the builder and constructs a [`PlatformInput`](crate::model::PlatformInput).
        pub fn build(self) -> crate::model::PlatformInput {
            crate::model::PlatformInput {
                value: self.value,
                comparison_operator: self.comparison_operator,
            }
        }
    }
}
impl PlatformInput {
    /// Creates a new builder-style object to manufacture [`PlatformInput`](crate::model::PlatformInput).
    pub fn builder() -> crate::model::platform_input::Builder {
        crate::model::platform_input::Builder::default()
    }
}

/// When writing a match expression against `ComparisonOperator`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let comparisonoperator = unimplemented!();
/// match comparisonoperator {
///     ComparisonOperator::Equals => { /* ... */ },
///     ComparisonOperator::NotEquals => { /* ... */ },
///     ComparisonOperator::StartsWith => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `comparisonoperator` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ComparisonOperator::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ComparisonOperator::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ComparisonOperator::NewFeature` is defined.
/// Specifically, when `comparisonoperator` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ComparisonOperator::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ComparisonOperator {
    /// EQUALS
    Equals,
    /// NOT_EQUALS
    NotEquals,
    /// STARTS_WITH
    StartsWith,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ComparisonOperator {
    fn from(s: &str) -> Self {
        match s {
            "EQUALS" => ComparisonOperator::Equals,
            "NOT_EQUALS" => ComparisonOperator::NotEquals,
            "STARTS_WITH" => ComparisonOperator::StartsWith,
            other => {
                ComparisonOperator::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ComparisonOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ComparisonOperator::from(s))
    }
}
impl ComparisonOperator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ComparisonOperator::Equals => "EQUALS",
            ComparisonOperator::NotEquals => "NOT_EQUALS",
            ComparisonOperator::StartsWith => "STARTS_WITH",
            ComparisonOperator::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EQUALS", "NOT_EQUALS", "STARTS_WITH"]
    }
}
impl AsRef<str> for ComparisonOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ViewSunElevationInput {
    /// <p>The lower bound to view the sun elevation.</p>
    #[doc(hidden)]
    pub lower_bound: std::option::Option<f32>,
    /// <p>The upper bound to view the sun elevation.</p>
    #[doc(hidden)]
    pub upper_bound: std::option::Option<f32>,
}
impl ViewSunElevationInput {
    /// <p>The lower bound to view the sun elevation.</p>
    pub fn lower_bound(&self) -> std::option::Option<f32> {
        self.lower_bound
    }
    /// <p>The upper bound to view the sun elevation.</p>
    pub fn upper_bound(&self) -> std::option::Option<f32> {
        self.upper_bound
    }
}
/// See [`ViewSunElevationInput`](crate::model::ViewSunElevationInput).
pub mod view_sun_elevation_input {

    /// A builder for [`ViewSunElevationInput`](crate::model::ViewSunElevationInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lower_bound: std::option::Option<f32>,
        pub(crate) upper_bound: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The lower bound to view the sun elevation.</p>
        pub fn lower_bound(mut self, input: f32) -> Self {
            self.lower_bound = Some(input);
            self
        }
        /// <p>The lower bound to view the sun elevation.</p>
        pub fn set_lower_bound(mut self, input: std::option::Option<f32>) -> Self {
            self.lower_bound = input;
            self
        }
        /// <p>The upper bound to view the sun elevation.</p>
        pub fn upper_bound(mut self, input: f32) -> Self {
            self.upper_bound = Some(input);
            self
        }
        /// <p>The upper bound to view the sun elevation.</p>
        pub fn set_upper_bound(mut self, input: std::option::Option<f32>) -> Self {
            self.upper_bound = input;
            self
        }
        /// Consumes the builder and constructs a [`ViewSunElevationInput`](crate::model::ViewSunElevationInput).
        pub fn build(self) -> crate::model::ViewSunElevationInput {
            crate::model::ViewSunElevationInput {
                lower_bound: self.lower_bound,
                upper_bound: self.upper_bound,
            }
        }
    }
}
impl ViewSunElevationInput {
    /// Creates a new builder-style object to manufacture [`ViewSunElevationInput`](crate::model::ViewSunElevationInput).
    pub fn builder() -> crate::model::view_sun_elevation_input::Builder {
        crate::model::view_sun_elevation_input::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ViewSunAzimuthInput {
    /// <p></p>
    #[doc(hidden)]
    pub lower_bound: std::option::Option<f32>,
    /// <p></p>
    #[doc(hidden)]
    pub upper_bound: std::option::Option<f32>,
}
impl ViewSunAzimuthInput {
    /// <p></p>
    pub fn lower_bound(&self) -> std::option::Option<f32> {
        self.lower_bound
    }
    /// <p></p>
    pub fn upper_bound(&self) -> std::option::Option<f32> {
        self.upper_bound
    }
}
/// See [`ViewSunAzimuthInput`](crate::model::ViewSunAzimuthInput).
pub mod view_sun_azimuth_input {

    /// A builder for [`ViewSunAzimuthInput`](crate::model::ViewSunAzimuthInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lower_bound: std::option::Option<f32>,
        pub(crate) upper_bound: std::option::Option<f32>,
    }
    impl Builder {
        /// <p></p>
        pub fn lower_bound(mut self, input: f32) -> Self {
            self.lower_bound = Some(input);
            self
        }
        /// <p></p>
        pub fn set_lower_bound(mut self, input: std::option::Option<f32>) -> Self {
            self.lower_bound = input;
            self
        }
        /// <p></p>
        pub fn upper_bound(mut self, input: f32) -> Self {
            self.upper_bound = Some(input);
            self
        }
        /// <p></p>
        pub fn set_upper_bound(mut self, input: std::option::Option<f32>) -> Self {
            self.upper_bound = input;
            self
        }
        /// Consumes the builder and constructs a [`ViewSunAzimuthInput`](crate::model::ViewSunAzimuthInput).
        pub fn build(self) -> crate::model::ViewSunAzimuthInput {
            crate::model::ViewSunAzimuthInput {
                lower_bound: self.lower_bound,
                upper_bound: self.upper_bound,
            }
        }
    }
}
impl ViewSunAzimuthInput {
    /// Creates a new builder-style object to manufacture [`ViewSunAzimuthInput`](crate::model::ViewSunAzimuthInput).
    pub fn builder() -> crate::model::view_sun_azimuth_input::Builder {
        crate::model::view_sun_azimuth_input::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ViewOffNadirInput {
    /// <p></p>
    #[doc(hidden)]
    pub lower_bound: std::option::Option<f32>,
    /// <p></p>
    #[doc(hidden)]
    pub upper_bound: std::option::Option<f32>,
}
impl ViewOffNadirInput {
    /// <p></p>
    pub fn lower_bound(&self) -> std::option::Option<f32> {
        self.lower_bound
    }
    /// <p></p>
    pub fn upper_bound(&self) -> std::option::Option<f32> {
        self.upper_bound
    }
}
/// See [`ViewOffNadirInput`](crate::model::ViewOffNadirInput).
pub mod view_off_nadir_input {

    /// A builder for [`ViewOffNadirInput`](crate::model::ViewOffNadirInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lower_bound: std::option::Option<f32>,
        pub(crate) upper_bound: std::option::Option<f32>,
    }
    impl Builder {
        /// <p></p>
        pub fn lower_bound(mut self, input: f32) -> Self {
            self.lower_bound = Some(input);
            self
        }
        /// <p></p>
        pub fn set_lower_bound(mut self, input: std::option::Option<f32>) -> Self {
            self.lower_bound = input;
            self
        }
        /// <p></p>
        pub fn upper_bound(mut self, input: f32) -> Self {
            self.upper_bound = Some(input);
            self
        }
        /// <p></p>
        pub fn set_upper_bound(mut self, input: std::option::Option<f32>) -> Self {
            self.upper_bound = input;
            self
        }
        /// Consumes the builder and constructs a [`ViewOffNadirInput`](crate::model::ViewOffNadirInput).
        pub fn build(self) -> crate::model::ViewOffNadirInput {
            crate::model::ViewOffNadirInput {
                lower_bound: self.lower_bound,
                upper_bound: self.upper_bound,
            }
        }
    }
}
impl ViewOffNadirInput {
    /// Creates a new builder-style object to manufacture [`ViewOffNadirInput`](crate::model::ViewOffNadirInput).
    pub fn builder() -> crate::model::view_off_nadir_input::Builder {
        crate::model::view_off_nadir_input::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EoCloudCoverInput {
    /// <p></p>
    #[doc(hidden)]
    pub lower_bound: std::option::Option<f32>,
    /// <p></p>
    #[doc(hidden)]
    pub upper_bound: std::option::Option<f32>,
}
impl EoCloudCoverInput {
    /// <p></p>
    pub fn lower_bound(&self) -> std::option::Option<f32> {
        self.lower_bound
    }
    /// <p></p>
    pub fn upper_bound(&self) -> std::option::Option<f32> {
        self.upper_bound
    }
}
/// See [`EoCloudCoverInput`](crate::model::EoCloudCoverInput).
pub mod eo_cloud_cover_input {

    /// A builder for [`EoCloudCoverInput`](crate::model::EoCloudCoverInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lower_bound: std::option::Option<f32>,
        pub(crate) upper_bound: std::option::Option<f32>,
    }
    impl Builder {
        /// <p></p>
        pub fn lower_bound(mut self, input: f32) -> Self {
            self.lower_bound = Some(input);
            self
        }
        /// <p></p>
        pub fn set_lower_bound(mut self, input: std::option::Option<f32>) -> Self {
            self.lower_bound = input;
            self
        }
        /// <p></p>
        pub fn upper_bound(mut self, input: f32) -> Self {
            self.upper_bound = Some(input);
            self
        }
        /// <p></p>
        pub fn set_upper_bound(mut self, input: std::option::Option<f32>) -> Self {
            self.upper_bound = input;
            self
        }
        /// Consumes the builder and constructs a [`EoCloudCoverInput`](crate::model::EoCloudCoverInput).
        pub fn build(self) -> crate::model::EoCloudCoverInput {
            crate::model::EoCloudCoverInput {
                lower_bound: self.lower_bound,
                upper_bound: self.upper_bound,
            }
        }
    }
}
impl EoCloudCoverInput {
    /// Creates a new builder-style object to manufacture [`EoCloudCoverInput`](crate::model::EoCloudCoverInput).
    pub fn builder() -> crate::model::eo_cloud_cover_input::Builder {
        crate::model::eo_cloud_cover_input::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum AreaOfInterest {
    /// <p></p>
    AreaOfInterestGeometry(crate::model::AreaOfInterestGeometry),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl AreaOfInterest {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`AreaOfInterestGeometry`](crate::model::AreaOfInterest::AreaOfInterestGeometry), extracting the inner [`AreaOfInterestGeometry`](crate::model::AreaOfInterestGeometry).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_area_of_interest_geometry(
        &self,
    ) -> std::result::Result<&crate::model::AreaOfInterestGeometry, &Self> {
        if let AreaOfInterest::AreaOfInterestGeometry(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`AreaOfInterestGeometry`](crate::model::AreaOfInterest::AreaOfInterestGeometry).
    pub fn is_area_of_interest_geometry(&self) -> bool {
        self.as_area_of_interest_geometry().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum AreaOfInterestGeometry {
    /// <p></p>
    MultiPolygonGeometry(crate::model::MultiPolygonGeometryInput),
    /// <p></p>
    PolygonGeometry(crate::model::PolygonGeometryInput),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl AreaOfInterestGeometry {
    /// Tries to convert the enum instance into [`MultiPolygonGeometry`](crate::model::AreaOfInterestGeometry::MultiPolygonGeometry), extracting the inner [`MultiPolygonGeometryInput`](crate::model::MultiPolygonGeometryInput).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_multi_polygon_geometry(
        &self,
    ) -> std::result::Result<&crate::model::MultiPolygonGeometryInput, &Self> {
        if let AreaOfInterestGeometry::MultiPolygonGeometry(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`MultiPolygonGeometry`](crate::model::AreaOfInterestGeometry::MultiPolygonGeometry).
    pub fn is_multi_polygon_geometry(&self) -> bool {
        self.as_multi_polygon_geometry().is_ok()
    }
    /// Tries to convert the enum instance into [`PolygonGeometry`](crate::model::AreaOfInterestGeometry::PolygonGeometry), extracting the inner [`PolygonGeometryInput`](crate::model::PolygonGeometryInput).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_polygon_geometry(
        &self,
    ) -> std::result::Result<&crate::model::PolygonGeometryInput, &Self> {
        if let AreaOfInterestGeometry::PolygonGeometry(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`PolygonGeometry`](crate::model::AreaOfInterestGeometry::PolygonGeometry).
    pub fn is_polygon_geometry(&self) -> bool {
        self.as_polygon_geometry().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MultiPolygonGeometryInput {
    /// <p>The coordinates of the multipolygon geometry.</p>
    #[doc(hidden)]
    pub coordinates:
        std::option::Option<std::vec::Vec<std::vec::Vec<std::vec::Vec<std::vec::Vec<f64>>>>>,
}
impl MultiPolygonGeometryInput {
    /// <p>The coordinates of the multipolygon geometry.</p>
    pub fn coordinates(
        &self,
    ) -> std::option::Option<&[std::vec::Vec<std::vec::Vec<std::vec::Vec<f64>>>]> {
        self.coordinates.as_deref()
    }
}
/// See [`MultiPolygonGeometryInput`](crate::model::MultiPolygonGeometryInput).
pub mod multi_polygon_geometry_input {

    /// A builder for [`MultiPolygonGeometryInput`](crate::model::MultiPolygonGeometryInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) coordinates:
            std::option::Option<std::vec::Vec<std::vec::Vec<std::vec::Vec<std::vec::Vec<f64>>>>>,
    }
    impl Builder {
        /// Appends an item to `coordinates`.
        ///
        /// To override the contents of this collection use [`set_coordinates`](Self::set_coordinates).
        ///
        /// <p>The coordinates of the multipolygon geometry.</p>
        pub fn coordinates(
            mut self,
            input: std::vec::Vec<std::vec::Vec<std::vec::Vec<f64>>>,
        ) -> Self {
            let mut v = self.coordinates.unwrap_or_default();
            v.push(input);
            self.coordinates = Some(v);
            self
        }
        /// <p>The coordinates of the multipolygon geometry.</p>
        pub fn set_coordinates(
            mut self,
            input: std::option::Option<
                std::vec::Vec<std::vec::Vec<std::vec::Vec<std::vec::Vec<f64>>>>,
            >,
        ) -> Self {
            self.coordinates = input;
            self
        }
        /// Consumes the builder and constructs a [`MultiPolygonGeometryInput`](crate::model::MultiPolygonGeometryInput).
        pub fn build(self) -> crate::model::MultiPolygonGeometryInput {
            crate::model::MultiPolygonGeometryInput {
                coordinates: self.coordinates,
            }
        }
    }
}
impl MultiPolygonGeometryInput {
    /// Creates a new builder-style object to manufacture [`MultiPolygonGeometryInput`](crate::model::MultiPolygonGeometryInput).
    pub fn builder() -> crate::model::multi_polygon_geometry_input::Builder {
        crate::model::multi_polygon_geometry_input::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PolygonGeometryInput {
    /// <p></p>
    #[doc(hidden)]
    pub coordinates: std::option::Option<std::vec::Vec<std::vec::Vec<std::vec::Vec<f64>>>>,
}
impl PolygonGeometryInput {
    /// <p></p>
    pub fn coordinates(&self) -> std::option::Option<&[std::vec::Vec<std::vec::Vec<f64>>]> {
        self.coordinates.as_deref()
    }
}
/// See [`PolygonGeometryInput`](crate::model::PolygonGeometryInput).
pub mod polygon_geometry_input {

    /// A builder for [`PolygonGeometryInput`](crate::model::PolygonGeometryInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) coordinates:
            std::option::Option<std::vec::Vec<std::vec::Vec<std::vec::Vec<f64>>>>,
    }
    impl Builder {
        /// Appends an item to `coordinates`.
        ///
        /// To override the contents of this collection use [`set_coordinates`](Self::set_coordinates).
        ///
        /// <p></p>
        pub fn coordinates(mut self, input: std::vec::Vec<std::vec::Vec<f64>>) -> Self {
            let mut v = self.coordinates.unwrap_or_default();
            v.push(input);
            self.coordinates = Some(v);
            self
        }
        /// <p></p>
        pub fn set_coordinates(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<std::vec::Vec<f64>>>>,
        ) -> Self {
            self.coordinates = input;
            self
        }
        /// Consumes the builder and constructs a [`PolygonGeometryInput`](crate::model::PolygonGeometryInput).
        pub fn build(self) -> crate::model::PolygonGeometryInput {
            crate::model::PolygonGeometryInput {
                coordinates: self.coordinates,
            }
        }
    }
}
impl PolygonGeometryInput {
    /// Creates a new builder-style object to manufacture [`PolygonGeometryInput`](crate::model::PolygonGeometryInput).
    pub fn builder() -> crate::model::polygon_geometry_input::Builder {
        crate::model::polygon_geometry_input::Builder::default()
    }
}

/// <p>The input for the time-range filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TimeRangeFilterInput {
    /// <p>The start time for the time-range filter.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The end time for the time-range filter.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl TimeRangeFilterInput {
    /// <p>The start time for the time-range filter.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The end time for the time-range filter.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
}
impl std::fmt::Debug for TimeRangeFilterInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TimeRangeFilterInput");
        formatter.field("start_time", &"*** Sensitive Data Redacted ***");
        formatter.field("end_time", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`TimeRangeFilterInput`](crate::model::TimeRangeFilterInput).
pub mod time_range_filter_input {

    /// A builder for [`TimeRangeFilterInput`](crate::model::TimeRangeFilterInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The start time for the time-range filter.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time for the time-range filter.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time for the time-range filter.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time for the time-range filter.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeRangeFilterInput`](crate::model::TimeRangeFilterInput).
        pub fn build(self) -> crate::model::TimeRangeFilterInput {
            crate::model::TimeRangeFilterInput {
                start_time: self.start_time,
                end_time: self.end_time,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("start_time", &"*** Sensitive Data Redacted ***");
            formatter.field("end_time", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl TimeRangeFilterInput {
    /// Creates a new builder-style object to manufacture [`TimeRangeFilterInput`](crate::model::TimeRangeFilterInput).
    pub fn builder() -> crate::model::time_range_filter_input::Builder {
        crate::model::time_range_filter_input::Builder::default()
    }
}

/// <p>Response object containing details for a specific RasterDataCollection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RasterDataCollectionMetadata {
    /// <p>The name of the raster data collection.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the raster data collection.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The type of raster data collection.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::DataCollectionType>,
    /// <p>A description of the raster data collection.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The description URL of the raster data collection.</p>
    #[doc(hidden)]
    pub description_page_url: std::option::Option<std::string::String>,
    /// <p></p>
    #[doc(hidden)]
    pub supported_filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
    /// <p>Each tag consists of a key and a value.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl RasterDataCollectionMetadata {
    /// <p>The name of the raster data collection.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the raster data collection.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The type of raster data collection.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::DataCollectionType> {
        self.r#type.as_ref()
    }
    /// <p>A description of the raster data collection.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The description URL of the raster data collection.</p>
    pub fn description_page_url(&self) -> std::option::Option<&str> {
        self.description_page_url.as_deref()
    }
    /// <p></p>
    pub fn supported_filters(&self) -> std::option::Option<&[crate::model::Filter]> {
        self.supported_filters.as_deref()
    }
    /// <p>Each tag consists of a key and a value.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`RasterDataCollectionMetadata`](crate::model::RasterDataCollectionMetadata).
pub mod raster_data_collection_metadata {

    /// A builder for [`RasterDataCollectionMetadata`](crate::model::RasterDataCollectionMetadata).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::DataCollectionType>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) description_page_url: std::option::Option<std::string::String>,
        pub(crate) supported_filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the raster data collection.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the raster data collection.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the raster data collection.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the raster data collection.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The type of raster data collection.</p>
        pub fn r#type(mut self, input: crate::model::DataCollectionType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of raster data collection.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DataCollectionType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>A description of the raster data collection.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the raster data collection.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The description URL of the raster data collection.</p>
        pub fn description_page_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.description_page_url = Some(input.into());
            self
        }
        /// <p>The description URL of the raster data collection.</p>
        pub fn set_description_page_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.description_page_url = input;
            self
        }
        /// Appends an item to `supported_filters`.
        ///
        /// To override the contents of this collection use [`set_supported_filters`](Self::set_supported_filters).
        ///
        /// <p></p>
        pub fn supported_filters(mut self, input: crate::model::Filter) -> Self {
            let mut v = self.supported_filters.unwrap_or_default();
            v.push(input);
            self.supported_filters = Some(v);
            self
        }
        /// <p></p>
        pub fn set_supported_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.supported_filters = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Each tag consists of a key and a value.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>Each tag consists of a key and a value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`RasterDataCollectionMetadata`](crate::model::RasterDataCollectionMetadata).
        pub fn build(self) -> crate::model::RasterDataCollectionMetadata {
            crate::model::RasterDataCollectionMetadata {
                name: self.name,
                arn: self.arn,
                r#type: self.r#type,
                description: self.description,
                description_page_url: self.description_page_url,
                supported_filters: self.supported_filters,
                tags: self.tags,
            }
        }
    }
}
impl RasterDataCollectionMetadata {
    /// Creates a new builder-style object to manufacture [`RasterDataCollectionMetadata`](crate::model::RasterDataCollectionMetadata).
    pub fn builder() -> crate::model::raster_data_collection_metadata::Builder {
        crate::model::raster_data_collection_metadata::Builder::default()
    }
}

/// <p>The structure representing the filters supported by a RasterDataCollection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Filter {
    /// <p>The name of the filter.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of the filter being used.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The minimum value of the filter.</p>
    #[doc(hidden)]
    pub minimum: std::option::Option<f32>,
    /// <p>The maximum value of the filter.</p>
    #[doc(hidden)]
    pub maximum: std::option::Option<f32>,
}
impl Filter {
    /// <p>The name of the filter.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of the filter being used.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The minimum value of the filter.</p>
    pub fn minimum(&self) -> std::option::Option<f32> {
        self.minimum
    }
    /// <p>The maximum value of the filter.</p>
    pub fn maximum(&self) -> std::option::Option<f32> {
        self.maximum
    }
}
/// See [`Filter`](crate::model::Filter).
pub mod filter {

    /// A builder for [`Filter`](crate::model::Filter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) minimum: std::option::Option<f32>,
        pub(crate) maximum: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The name of the filter.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the filter.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of the filter being used.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of the filter being used.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The minimum value of the filter.</p>
        pub fn minimum(mut self, input: f32) -> Self {
            self.minimum = Some(input);
            self
        }
        /// <p>The minimum value of the filter.</p>
        pub fn set_minimum(mut self, input: std::option::Option<f32>) -> Self {
            self.minimum = input;
            self
        }
        /// <p>The maximum value of the filter.</p>
        pub fn maximum(mut self, input: f32) -> Self {
            self.maximum = Some(input);
            self
        }
        /// <p>The maximum value of the filter.</p>
        pub fn set_maximum(mut self, input: std::option::Option<f32>) -> Self {
            self.maximum = input;
            self
        }
        /// Consumes the builder and constructs a [`Filter`](crate::model::Filter).
        pub fn build(self) -> crate::model::Filter {
            crate::model::Filter {
                name: self.name,
                r#type: self.r#type,
                minimum: self.minimum,
                maximum: self.maximum,
            }
        }
    }
}
impl Filter {
    /// Creates a new builder-style object to manufacture [`Filter`](crate::model::Filter).
    pub fn builder() -> crate::model::filter::Builder {
        crate::model::filter::Builder::default()
    }
}

/// When writing a match expression against `DataCollectionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datacollectiontype = unimplemented!();
/// match datacollectiontype {
///     DataCollectionType::Premium => { /* ... */ },
///     DataCollectionType::Public => { /* ... */ },
///     DataCollectionType::User => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datacollectiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataCollectionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataCollectionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataCollectionType::NewFeature` is defined.
/// Specifically, when `datacollectiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataCollectionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataCollectionType {
    /// PREMIUM
    Premium,
    /// PUBLIC
    Public,
    /// USER
    User,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataCollectionType {
    fn from(s: &str) -> Self {
        match s {
            "PREMIUM" => DataCollectionType::Premium,
            "PUBLIC" => DataCollectionType::Public,
            "USER" => DataCollectionType::User,
            other => {
                DataCollectionType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DataCollectionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataCollectionType::from(s))
    }
}
impl DataCollectionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataCollectionType::Premium => "PREMIUM",
            DataCollectionType::Public => "PUBLIC",
            DataCollectionType::User => "USER",
            DataCollectionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PREMIUM", "PUBLIC", "USER"]
    }
}
impl AsRef<str> for DataCollectionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `OutputType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let outputtype = unimplemented!();
/// match outputtype {
///     OutputType::Float32 => { /* ... */ },
///     OutputType::Float64 => { /* ... */ },
///     OutputType::Int16 => { /* ... */ },
///     OutputType::Int32 => { /* ... */ },
///     OutputType::Uint16 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `outputtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OutputType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OutputType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OutputType::NewFeature` is defined.
/// Specifically, when `outputtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OutputType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OutputType {
    /// FLOAT32
    Float32,
    /// FLOAT64
    Float64,
    /// INT16
    Int16,
    /// INT32
    Int32,
    /// UINT16
    Uint16,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OutputType {
    fn from(s: &str) -> Self {
        match s {
            "FLOAT32" => OutputType::Float32,
            "FLOAT64" => OutputType::Float64,
            "INT16" => OutputType::Int16,
            "INT32" => OutputType::Int32,
            "UINT16" => OutputType::Uint16,
            other => OutputType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for OutputType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OutputType::from(s))
    }
}
impl OutputType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OutputType::Float32 => "FLOAT32",
            OutputType::Float64 => "FLOAT64",
            OutputType::Int16 => "INT16",
            OutputType::Int32 => "INT32",
            OutputType::Uint16 => "UINT16",
            OutputType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FLOAT32", "FLOAT64", "INT16", "INT32", "UINT16"]
    }
}
impl AsRef<str> for OutputType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TargetOptions`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let targetoptions = unimplemented!();
/// match targetoptions {
///     TargetOptions::Input => { /* ... */ },
///     TargetOptions::Output => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `targetoptions` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TargetOptions::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TargetOptions::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TargetOptions::NewFeature` is defined.
/// Specifically, when `targetoptions` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TargetOptions::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetOptions {
    /// INPUT
    Input,
    /// OUTPUT
    Output,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TargetOptions {
    fn from(s: &str) -> Self {
        match s {
            "INPUT" => TargetOptions::Input,
            "OUTPUT" => TargetOptions::Output,
            other => TargetOptions::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TargetOptions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetOptions::from(s))
    }
}
impl TargetOptions {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TargetOptions::Input => "INPUT",
            TargetOptions::Output => "OUTPUT",
            TargetOptions::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INPUT", "OUTPUT"]
    }
}
impl AsRef<str> for TargetOptions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The response structure for an OutputConfig returned by an ExportEarthObservationJob.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OutputConfigInput {
    /// <p>Path to Amazon S3 storage location for the output configuration file.</p>
    #[doc(hidden)]
    pub s3_data: std::option::Option<crate::model::ExportS3DataInput>,
}
impl OutputConfigInput {
    /// <p>Path to Amazon S3 storage location for the output configuration file.</p>
    pub fn s3_data(&self) -> std::option::Option<&crate::model::ExportS3DataInput> {
        self.s3_data.as_ref()
    }
}
/// See [`OutputConfigInput`](crate::model::OutputConfigInput).
pub mod output_config_input {

    /// A builder for [`OutputConfigInput`](crate::model::OutputConfigInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_data: std::option::Option<crate::model::ExportS3DataInput>,
    }
    impl Builder {
        /// <p>Path to Amazon S3 storage location for the output configuration file.</p>
        pub fn s3_data(mut self, input: crate::model::ExportS3DataInput) -> Self {
            self.s3_data = Some(input);
            self
        }
        /// <p>Path to Amazon S3 storage location for the output configuration file.</p>
        pub fn set_s3_data(
            mut self,
            input: std::option::Option<crate::model::ExportS3DataInput>,
        ) -> Self {
            self.s3_data = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputConfigInput`](crate::model::OutputConfigInput).
        pub fn build(self) -> crate::model::OutputConfigInput {
            crate::model::OutputConfigInput {
                s3_data: self.s3_data,
            }
        }
    }
}
impl OutputConfigInput {
    /// Creates a new builder-style object to manufacture [`OutputConfigInput`](crate::model::OutputConfigInput).
    pub fn builder() -> crate::model::output_config_input::Builder {
        crate::model::output_config_input::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExportS3DataInput {
    /// <p>The URL to the Amazon S3 data input.</p>
    #[doc(hidden)]
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>The Amazon Key Management Service (KMS) key ID for server-side encryption.</p>
    #[doc(hidden)]
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl ExportS3DataInput {
    /// <p>The URL to the Amazon S3 data input.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p>The Amazon Key Management Service (KMS) key ID for server-side encryption.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
/// See [`ExportS3DataInput`](crate::model::ExportS3DataInput).
pub mod export_s3_data_input {

    /// A builder for [`ExportS3DataInput`](crate::model::ExportS3DataInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URL to the Amazon S3 data input.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>The URL to the Amazon S3 data input.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>The Amazon Key Management Service (KMS) key ID for server-side encryption.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Key Management Service (KMS) key ID for server-side encryption.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportS3DataInput`](crate::model::ExportS3DataInput).
        pub fn build(self) -> crate::model::ExportS3DataInput {
            crate::model::ExportS3DataInput {
                s3_uri: self.s3_uri,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl ExportS3DataInput {
    /// Creates a new builder-style object to manufacture [`ExportS3DataInput`](crate::model::ExportS3DataInput).
    pub fn builder() -> crate::model::export_s3_data_input::Builder {
        crate::model::export_s3_data_input::Builder::default()
    }
}

/// When writing a match expression against `EarthObservationJobExportStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let earthobservationjobexportstatus = unimplemented!();
/// match earthobservationjobexportstatus {
///     EarthObservationJobExportStatus::Failed => { /* ... */ },
///     EarthObservationJobExportStatus::InProgress => { /* ... */ },
///     EarthObservationJobExportStatus::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `earthobservationjobexportstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EarthObservationJobExportStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EarthObservationJobExportStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EarthObservationJobExportStatus::NewFeature` is defined.
/// Specifically, when `earthobservationjobexportstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EarthObservationJobExportStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EarthObservationJobExportStatus {
    /// FAILED
    Failed,
    /// IN_PROGRESS
    InProgress,
    /// SUCCEEDED
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EarthObservationJobExportStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => EarthObservationJobExportStatus::Failed,
            "IN_PROGRESS" => EarthObservationJobExportStatus::InProgress,
            "SUCCEEDED" => EarthObservationJobExportStatus::Succeeded,
            other => EarthObservationJobExportStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for EarthObservationJobExportStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EarthObservationJobExportStatus::from(s))
    }
}
impl EarthObservationJobExportStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EarthObservationJobExportStatus::Failed => "FAILED",
            EarthObservationJobExportStatus::InProgress => "IN_PROGRESS",
            EarthObservationJobExportStatus::Succeeded => "SUCCEEDED",
            EarthObservationJobExportStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "IN_PROGRESS", "SUCCEEDED"]
    }
}
impl AsRef<str> for EarthObservationJobExportStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object containing information about the output file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListEarthObservationJobOutputConfig {
    /// <p>The Amazon Resource Name (ARN) of the list of the Earth Observation jobs.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The names of the Earth Observation jobs in the list.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The creation time.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The duration of the session, in seconds.</p>
    #[doc(hidden)]
    pub duration_in_seconds: std::option::Option<i32>,
    /// <p>The status of the list of the Earth Observation jobs.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::EarthObservationJobStatus>,
    /// <p></p>
    #[doc(hidden)]
    pub operation_type: std::option::Option<std::string::String>,
    /// <p>Each tag consists of a key and a value.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ListEarthObservationJobOutputConfig {
    /// <p>The Amazon Resource Name (ARN) of the list of the Earth Observation jobs.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The names of the Earth Observation jobs in the list.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The creation time.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The duration of the session, in seconds.</p>
    pub fn duration_in_seconds(&self) -> std::option::Option<i32> {
        self.duration_in_seconds
    }
    /// <p>The status of the list of the Earth Observation jobs.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::EarthObservationJobStatus> {
        self.status.as_ref()
    }
    /// <p></p>
    pub fn operation_type(&self) -> std::option::Option<&str> {
        self.operation_type.as_deref()
    }
    /// <p>Each tag consists of a key and a value.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
/// See [`ListEarthObservationJobOutputConfig`](crate::model::ListEarthObservationJobOutputConfig).
pub mod list_earth_observation_job_output_config {

    /// A builder for [`ListEarthObservationJobOutputConfig`](crate::model::ListEarthObservationJobOutputConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) duration_in_seconds: std::option::Option<i32>,
        pub(crate) status: std::option::Option<crate::model::EarthObservationJobStatus>,
        pub(crate) operation_type: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the list of the Earth Observation jobs.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the list of the Earth Observation jobs.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The names of the Earth Observation jobs in the list.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The names of the Earth Observation jobs in the list.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The creation time.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation time.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The duration of the session, in seconds.</p>
        pub fn duration_in_seconds(mut self, input: i32) -> Self {
            self.duration_in_seconds = Some(input);
            self
        }
        /// <p>The duration of the session, in seconds.</p>
        pub fn set_duration_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.duration_in_seconds = input;
            self
        }
        /// <p>The status of the list of the Earth Observation jobs.</p>
        pub fn status(mut self, input: crate::model::EarthObservationJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the list of the Earth Observation jobs.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::EarthObservationJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p></p>
        pub fn operation_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.operation_type = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_operation_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.operation_type = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Each tag consists of a key and a value.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>Each tag consists of a key and a value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ListEarthObservationJobOutputConfig`](crate::model::ListEarthObservationJobOutputConfig).
        pub fn build(self) -> crate::model::ListEarthObservationJobOutputConfig {
            crate::model::ListEarthObservationJobOutputConfig {
                arn: self.arn,
                name: self.name,
                creation_time: self.creation_time,
                duration_in_seconds: self.duration_in_seconds,
                status: self.status,
                operation_type: self.operation_type,
                tags: self.tags,
            }
        }
    }
}
impl ListEarthObservationJobOutputConfig {
    /// Creates a new builder-style object to manufacture [`ListEarthObservationJobOutputConfig`](crate::model::ListEarthObservationJobOutputConfig).
    pub fn builder() -> crate::model::list_earth_observation_job_output_config::Builder {
        crate::model::list_earth_observation_job_output_config::Builder::default()
    }
}

/// When writing a match expression against `EarthObservationJobStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let earthobservationjobstatus = unimplemented!();
/// match earthobservationjobstatus {
///     EarthObservationJobStatus::Completed => { /* ... */ },
///     EarthObservationJobStatus::Deleted => { /* ... */ },
///     EarthObservationJobStatus::Deleting => { /* ... */ },
///     EarthObservationJobStatus::Failed => { /* ... */ },
///     EarthObservationJobStatus::Initializing => { /* ... */ },
///     EarthObservationJobStatus::InProgress => { /* ... */ },
///     EarthObservationJobStatus::Stopped => { /* ... */ },
///     EarthObservationJobStatus::Stopping => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `earthobservationjobstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EarthObservationJobStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EarthObservationJobStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EarthObservationJobStatus::NewFeature` is defined.
/// Specifically, when `earthobservationjobstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EarthObservationJobStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EarthObservationJobStatus {
    /// COMPLETED
    Completed,
    /// DELETED
    Deleted,
    /// DELETING
    Deleting,
    /// FAILED
    Failed,
    /// INITIALIZING
    Initializing,
    /// IN_PROGRESS
    InProgress,
    /// STOPPED
    Stopped,
    /// STOPPING
    Stopping,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EarthObservationJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => EarthObservationJobStatus::Completed,
            "DELETED" => EarthObservationJobStatus::Deleted,
            "DELETING" => EarthObservationJobStatus::Deleting,
            "FAILED" => EarthObservationJobStatus::Failed,
            "INITIALIZING" => EarthObservationJobStatus::Initializing,
            "IN_PROGRESS" => EarthObservationJobStatus::InProgress,
            "STOPPED" => EarthObservationJobStatus::Stopped,
            "STOPPING" => EarthObservationJobStatus::Stopping,
            other => EarthObservationJobStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for EarthObservationJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EarthObservationJobStatus::from(s))
    }
}
impl EarthObservationJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EarthObservationJobStatus::Completed => "COMPLETED",
            EarthObservationJobStatus::Deleted => "DELETED",
            EarthObservationJobStatus::Deleting => "DELETING",
            EarthObservationJobStatus::Failed => "FAILED",
            EarthObservationJobStatus::Initializing => "INITIALIZING",
            EarthObservationJobStatus::InProgress => "IN_PROGRESS",
            EarthObservationJobStatus::Stopped => "STOPPED",
            EarthObservationJobStatus::Stopping => "STOPPING",
            EarthObservationJobStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "COMPLETED",
            "DELETED",
            "DELETING",
            "FAILED",
            "INITIALIZING",
            "IN_PROGRESS",
            "STOPPED",
            "STOPPING",
        ]
    }
}
impl AsRef<str> for EarthObservationJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The input structure for the JobConfig in an EarthObservationJob.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum JobConfigInput {
    /// <p></p>
    BandMathConfig(crate::model::BandMathConfigInput),
    /// <p>An object containing information about the job configuration for cloud masking.</p>
    CloudMaskingConfig(crate::model::CloudMaskingConfigInput),
    /// <p>An object containing information about the job configuration for cloud removal.</p>
    CloudRemovalConfig(crate::model::CloudRemovalConfigInput),
    /// <p>An object containing information about the job configuration for geomosaic.</p>
    GeoMosaicConfig(crate::model::GeoMosaicConfigInput),
    /// <p>An object containing information about the job configuration for land cover segmentation.</p>
    LandCoverSegmentationConfig(crate::model::LandCoverSegmentationConfigInput),
    /// <p>An object containing information about the job configuration for resampling.</p>
    ResamplingConfig(crate::model::ResamplingConfigInput),
    /// <p></p>
    StackConfig(crate::model::StackConfigInput),
    /// <p>An object containing information about the job configuration for temporal statistics.</p>
    TemporalStatisticsConfig(crate::model::TemporalStatisticsConfigInput),
    /// <p>An object containing information about the job configuration for zonal statistics.</p>
    ZonalStatisticsConfig(crate::model::ZonalStatisticsConfigInput),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl JobConfigInput {
    /// Tries to convert the enum instance into [`BandMathConfig`](crate::model::JobConfigInput::BandMathConfig), extracting the inner [`BandMathConfigInput`](crate::model::BandMathConfigInput).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_band_math_config(
        &self,
    ) -> std::result::Result<&crate::model::BandMathConfigInput, &Self> {
        if let JobConfigInput::BandMathConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`BandMathConfig`](crate::model::JobConfigInput::BandMathConfig).
    pub fn is_band_math_config(&self) -> bool {
        self.as_band_math_config().is_ok()
    }
    /// Tries to convert the enum instance into [`CloudMaskingConfig`](crate::model::JobConfigInput::CloudMaskingConfig), extracting the inner [`CloudMaskingConfigInput`](crate::model::CloudMaskingConfigInput).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_cloud_masking_config(
        &self,
    ) -> std::result::Result<&crate::model::CloudMaskingConfigInput, &Self> {
        if let JobConfigInput::CloudMaskingConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`CloudMaskingConfig`](crate::model::JobConfigInput::CloudMaskingConfig).
    pub fn is_cloud_masking_config(&self) -> bool {
        self.as_cloud_masking_config().is_ok()
    }
    /// Tries to convert the enum instance into [`CloudRemovalConfig`](crate::model::JobConfigInput::CloudRemovalConfig), extracting the inner [`CloudRemovalConfigInput`](crate::model::CloudRemovalConfigInput).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_cloud_removal_config(
        &self,
    ) -> std::result::Result<&crate::model::CloudRemovalConfigInput, &Self> {
        if let JobConfigInput::CloudRemovalConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`CloudRemovalConfig`](crate::model::JobConfigInput::CloudRemovalConfig).
    pub fn is_cloud_removal_config(&self) -> bool {
        self.as_cloud_removal_config().is_ok()
    }
    /// Tries to convert the enum instance into [`GeoMosaicConfig`](crate::model::JobConfigInput::GeoMosaicConfig), extracting the inner [`GeoMosaicConfigInput`](crate::model::GeoMosaicConfigInput).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_geo_mosaic_config(
        &self,
    ) -> std::result::Result<&crate::model::GeoMosaicConfigInput, &Self> {
        if let JobConfigInput::GeoMosaicConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`GeoMosaicConfig`](crate::model::JobConfigInput::GeoMosaicConfig).
    pub fn is_geo_mosaic_config(&self) -> bool {
        self.as_geo_mosaic_config().is_ok()
    }
    /// Tries to convert the enum instance into [`LandCoverSegmentationConfig`](crate::model::JobConfigInput::LandCoverSegmentationConfig), extracting the inner [`LandCoverSegmentationConfigInput`](crate::model::LandCoverSegmentationConfigInput).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_land_cover_segmentation_config(
        &self,
    ) -> std::result::Result<&crate::model::LandCoverSegmentationConfigInput, &Self> {
        if let JobConfigInput::LandCoverSegmentationConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`LandCoverSegmentationConfig`](crate::model::JobConfigInput::LandCoverSegmentationConfig).
    pub fn is_land_cover_segmentation_config(&self) -> bool {
        self.as_land_cover_segmentation_config().is_ok()
    }
    /// Tries to convert the enum instance into [`ResamplingConfig`](crate::model::JobConfigInput::ResamplingConfig), extracting the inner [`ResamplingConfigInput`](crate::model::ResamplingConfigInput).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_resampling_config(
        &self,
    ) -> std::result::Result<&crate::model::ResamplingConfigInput, &Self> {
        if let JobConfigInput::ResamplingConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ResamplingConfig`](crate::model::JobConfigInput::ResamplingConfig).
    pub fn is_resampling_config(&self) -> bool {
        self.as_resampling_config().is_ok()
    }
    /// Tries to convert the enum instance into [`StackConfig`](crate::model::JobConfigInput::StackConfig), extracting the inner [`StackConfigInput`](crate::model::StackConfigInput).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_stack_config(&self) -> std::result::Result<&crate::model::StackConfigInput, &Self> {
        if let JobConfigInput::StackConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`StackConfig`](crate::model::JobConfigInput::StackConfig).
    pub fn is_stack_config(&self) -> bool {
        self.as_stack_config().is_ok()
    }
    /// Tries to convert the enum instance into [`TemporalStatisticsConfig`](crate::model::JobConfigInput::TemporalStatisticsConfig), extracting the inner [`TemporalStatisticsConfigInput`](crate::model::TemporalStatisticsConfigInput).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_temporal_statistics_config(
        &self,
    ) -> std::result::Result<&crate::model::TemporalStatisticsConfigInput, &Self> {
        if let JobConfigInput::TemporalStatisticsConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`TemporalStatisticsConfig`](crate::model::JobConfigInput::TemporalStatisticsConfig).
    pub fn is_temporal_statistics_config(&self) -> bool {
        self.as_temporal_statistics_config().is_ok()
    }
    /// Tries to convert the enum instance into [`ZonalStatisticsConfig`](crate::model::JobConfigInput::ZonalStatisticsConfig), extracting the inner [`ZonalStatisticsConfigInput`](crate::model::ZonalStatisticsConfigInput).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_zonal_statistics_config(
        &self,
    ) -> std::result::Result<&crate::model::ZonalStatisticsConfigInput, &Self> {
        if let JobConfigInput::ZonalStatisticsConfig(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ZonalStatisticsConfig`](crate::model::JobConfigInput::ZonalStatisticsConfig).
    pub fn is_zonal_statistics_config(&self) -> bool {
        self.as_zonal_statistics_config().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LandCoverSegmentationConfigInput {}
/// See [`LandCoverSegmentationConfigInput`](crate::model::LandCoverSegmentationConfigInput).
pub mod land_cover_segmentation_config_input {

    /// A builder for [`LandCoverSegmentationConfigInput`](crate::model::LandCoverSegmentationConfigInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`LandCoverSegmentationConfigInput`](crate::model::LandCoverSegmentationConfigInput).
        pub fn build(self) -> crate::model::LandCoverSegmentationConfigInput {
            crate::model::LandCoverSegmentationConfigInput {}
        }
    }
}
impl LandCoverSegmentationConfigInput {
    /// Creates a new builder-style object to manufacture [`LandCoverSegmentationConfigInput`](crate::model::LandCoverSegmentationConfigInput).
    pub fn builder() -> crate::model::land_cover_segmentation_config_input::Builder {
        crate::model::land_cover_segmentation_config_input::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CloudMaskingConfigInput {}
/// See [`CloudMaskingConfigInput`](crate::model::CloudMaskingConfigInput).
pub mod cloud_masking_config_input {

    /// A builder for [`CloudMaskingConfigInput`](crate::model::CloudMaskingConfigInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`CloudMaskingConfigInput`](crate::model::CloudMaskingConfigInput).
        pub fn build(self) -> crate::model::CloudMaskingConfigInput {
            crate::model::CloudMaskingConfigInput {}
        }
    }
}
impl CloudMaskingConfigInput {
    /// Creates a new builder-style object to manufacture [`CloudMaskingConfigInput`](crate::model::CloudMaskingConfigInput).
    pub fn builder() -> crate::model::cloud_masking_config_input::Builder {
        crate::model::cloud_masking_config_input::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StackConfigInput {
    /// <p></p>
    #[doc(hidden)]
    pub output_resolution: std::option::Option<crate::model::OutputResolutionStackInput>,
    /// <p></p>
    #[doc(hidden)]
    pub target_bands: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl StackConfigInput {
    /// <p></p>
    pub fn output_resolution(
        &self,
    ) -> std::option::Option<&crate::model::OutputResolutionStackInput> {
        self.output_resolution.as_ref()
    }
    /// <p></p>
    pub fn target_bands(&self) -> std::option::Option<&[std::string::String]> {
        self.target_bands.as_deref()
    }
}
/// See [`StackConfigInput`](crate::model::StackConfigInput).
pub mod stack_config_input {

    /// A builder for [`StackConfigInput`](crate::model::StackConfigInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_resolution: std::option::Option<crate::model::OutputResolutionStackInput>,
        pub(crate) target_bands: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p></p>
        pub fn output_resolution(
            mut self,
            input: crate::model::OutputResolutionStackInput,
        ) -> Self {
            self.output_resolution = Some(input);
            self
        }
        /// <p></p>
        pub fn set_output_resolution(
            mut self,
            input: std::option::Option<crate::model::OutputResolutionStackInput>,
        ) -> Self {
            self.output_resolution = input;
            self
        }
        /// Appends an item to `target_bands`.
        ///
        /// To override the contents of this collection use [`set_target_bands`](Self::set_target_bands).
        ///
        /// <p></p>
        pub fn target_bands(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_bands.unwrap_or_default();
            v.push(input.into());
            self.target_bands = Some(v);
            self
        }
        /// <p></p>
        pub fn set_target_bands(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_bands = input;
            self
        }
        /// Consumes the builder and constructs a [`StackConfigInput`](crate::model::StackConfigInput).
        pub fn build(self) -> crate::model::StackConfigInput {
            crate::model::StackConfigInput {
                output_resolution: self.output_resolution,
                target_bands: self.target_bands,
            }
        }
    }
}
impl StackConfigInput {
    /// Creates a new builder-style object to manufacture [`StackConfigInput`](crate::model::StackConfigInput).
    pub fn builder() -> crate::model::stack_config_input::Builder {
        crate::model::stack_config_input::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OutputResolutionStackInput {
    /// <p></p>
    #[doc(hidden)]
    pub predefined: std::option::Option<crate::model::PredefinedResolution>,
    /// <p></p>
    #[doc(hidden)]
    pub user_defined: std::option::Option<crate::model::UserDefined>,
}
impl OutputResolutionStackInput {
    /// <p></p>
    pub fn predefined(&self) -> std::option::Option<&crate::model::PredefinedResolution> {
        self.predefined.as_ref()
    }
    /// <p></p>
    pub fn user_defined(&self) -> std::option::Option<&crate::model::UserDefined> {
        self.user_defined.as_ref()
    }
}
/// See [`OutputResolutionStackInput`](crate::model::OutputResolutionStackInput).
pub mod output_resolution_stack_input {

    /// A builder for [`OutputResolutionStackInput`](crate::model::OutputResolutionStackInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) predefined: std::option::Option<crate::model::PredefinedResolution>,
        pub(crate) user_defined: std::option::Option<crate::model::UserDefined>,
    }
    impl Builder {
        /// <p></p>
        pub fn predefined(mut self, input: crate::model::PredefinedResolution) -> Self {
            self.predefined = Some(input);
            self
        }
        /// <p></p>
        pub fn set_predefined(
            mut self,
            input: std::option::Option<crate::model::PredefinedResolution>,
        ) -> Self {
            self.predefined = input;
            self
        }
        /// <p></p>
        pub fn user_defined(mut self, input: crate::model::UserDefined) -> Self {
            self.user_defined = Some(input);
            self
        }
        /// <p></p>
        pub fn set_user_defined(
            mut self,
            input: std::option::Option<crate::model::UserDefined>,
        ) -> Self {
            self.user_defined = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputResolutionStackInput`](crate::model::OutputResolutionStackInput).
        pub fn build(self) -> crate::model::OutputResolutionStackInput {
            crate::model::OutputResolutionStackInput {
                predefined: self.predefined,
                user_defined: self.user_defined,
            }
        }
    }
}
impl OutputResolutionStackInput {
    /// Creates a new builder-style object to manufacture [`OutputResolutionStackInput`](crate::model::OutputResolutionStackInput).
    pub fn builder() -> crate::model::output_resolution_stack_input::Builder {
        crate::model::output_resolution_stack_input::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserDefined {
    /// <p></p>
    #[doc(hidden)]
    pub value: std::option::Option<f32>,
    /// <p></p>
    #[doc(hidden)]
    pub unit: std::option::Option<crate::model::Unit>,
}
impl UserDefined {
    /// <p></p>
    pub fn value(&self) -> std::option::Option<f32> {
        self.value
    }
    /// <p></p>
    pub fn unit(&self) -> std::option::Option<&crate::model::Unit> {
        self.unit.as_ref()
    }
}
/// See [`UserDefined`](crate::model::UserDefined).
pub mod user_defined {

    /// A builder for [`UserDefined`](crate::model::UserDefined).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<f32>,
        pub(crate) unit: std::option::Option<crate::model::Unit>,
    }
    impl Builder {
        /// <p></p>
        pub fn value(mut self, input: f32) -> Self {
            self.value = Some(input);
            self
        }
        /// <p></p>
        pub fn set_value(mut self, input: std::option::Option<f32>) -> Self {
            self.value = input;
            self
        }
        /// <p></p>
        pub fn unit(mut self, input: crate::model::Unit) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p></p>
        pub fn set_unit(mut self, input: std::option::Option<crate::model::Unit>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`UserDefined`](crate::model::UserDefined).
        pub fn build(self) -> crate::model::UserDefined {
            crate::model::UserDefined {
                value: self.value,
                unit: self.unit,
            }
        }
    }
}
impl UserDefined {
    /// Creates a new builder-style object to manufacture [`UserDefined`](crate::model::UserDefined).
    pub fn builder() -> crate::model::user_defined::Builder {
        crate::model::user_defined::Builder::default()
    }
}

/// When writing a match expression against `Unit`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let unit = unimplemented!();
/// match unit {
///     Unit::Meters => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `unit` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Unit::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Unit::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Unit::NewFeature` is defined.
/// Specifically, when `unit` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Unit::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Unit {
    /// METERS
    Meters,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Unit {
    fn from(s: &str) -> Self {
        match s {
            "METERS" => Unit::Meters,
            other => Unit::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Unit {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Unit::from(s))
    }
}
impl Unit {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Unit::Meters => "METERS",
            Unit::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["METERS"]
    }
}
impl AsRef<str> for Unit {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PredefinedResolution`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let predefinedresolution = unimplemented!();
/// match predefinedresolution {
///     PredefinedResolution::Average => { /* ... */ },
///     PredefinedResolution::Highest => { /* ... */ },
///     PredefinedResolution::Lowest => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `predefinedresolution` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PredefinedResolution::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PredefinedResolution::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PredefinedResolution::NewFeature` is defined.
/// Specifically, when `predefinedresolution` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PredefinedResolution::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PredefinedResolution {
    /// AVERAGE
    Average,
    /// HIGHEST
    Highest,
    /// LOWEST
    Lowest,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PredefinedResolution {
    fn from(s: &str) -> Self {
        match s {
            "AVERAGE" => PredefinedResolution::Average,
            "HIGHEST" => PredefinedResolution::Highest,
            "LOWEST" => PredefinedResolution::Lowest,
            other => {
                PredefinedResolution::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for PredefinedResolution {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PredefinedResolution::from(s))
    }
}
impl PredefinedResolution {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PredefinedResolution::Average => "AVERAGE",
            PredefinedResolution::Highest => "HIGHEST",
            PredefinedResolution::Lowest => "LOWEST",
            PredefinedResolution::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AVERAGE", "HIGHEST", "LOWEST"]
    }
}
impl AsRef<str> for PredefinedResolution {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Input configuration information for the geomosaic.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GeoMosaicConfigInput {
    /// <p>The name of the algorithm being used for geomosaic.</p>
    #[doc(hidden)]
    pub algorithm_name: std::option::Option<crate::model::AlgorithmNameGeoMosaic>,
    /// <p>The target bands for geomosaic.</p>
    #[doc(hidden)]
    pub target_bands: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl GeoMosaicConfigInput {
    /// <p>The name of the algorithm being used for geomosaic.</p>
    pub fn algorithm_name(&self) -> std::option::Option<&crate::model::AlgorithmNameGeoMosaic> {
        self.algorithm_name.as_ref()
    }
    /// <p>The target bands for geomosaic.</p>
    pub fn target_bands(&self) -> std::option::Option<&[std::string::String]> {
        self.target_bands.as_deref()
    }
}
/// See [`GeoMosaicConfigInput`](crate::model::GeoMosaicConfigInput).
pub mod geo_mosaic_config_input {

    /// A builder for [`GeoMosaicConfigInput`](crate::model::GeoMosaicConfigInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) algorithm_name: std::option::Option<crate::model::AlgorithmNameGeoMosaic>,
        pub(crate) target_bands: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the algorithm being used for geomosaic.</p>
        pub fn algorithm_name(mut self, input: crate::model::AlgorithmNameGeoMosaic) -> Self {
            self.algorithm_name = Some(input);
            self
        }
        /// <p>The name of the algorithm being used for geomosaic.</p>
        pub fn set_algorithm_name(
            mut self,
            input: std::option::Option<crate::model::AlgorithmNameGeoMosaic>,
        ) -> Self {
            self.algorithm_name = input;
            self
        }
        /// Appends an item to `target_bands`.
        ///
        /// To override the contents of this collection use [`set_target_bands`](Self::set_target_bands).
        ///
        /// <p>The target bands for geomosaic.</p>
        pub fn target_bands(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_bands.unwrap_or_default();
            v.push(input.into());
            self.target_bands = Some(v);
            self
        }
        /// <p>The target bands for geomosaic.</p>
        pub fn set_target_bands(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_bands = input;
            self
        }
        /// Consumes the builder and constructs a [`GeoMosaicConfigInput`](crate::model::GeoMosaicConfigInput).
        pub fn build(self) -> crate::model::GeoMosaicConfigInput {
            crate::model::GeoMosaicConfigInput {
                algorithm_name: self.algorithm_name,
                target_bands: self.target_bands,
            }
        }
    }
}
impl GeoMosaicConfigInput {
    /// Creates a new builder-style object to manufacture [`GeoMosaicConfigInput`](crate::model::GeoMosaicConfigInput).
    pub fn builder() -> crate::model::geo_mosaic_config_input::Builder {
        crate::model::geo_mosaic_config_input::Builder::default()
    }
}

/// When writing a match expression against `AlgorithmNameGeoMosaic`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let algorithmnamegeomosaic = unimplemented!();
/// match algorithmnamegeomosaic {
///     AlgorithmNameGeoMosaic::Average => { /* ... */ },
///     AlgorithmNameGeoMosaic::Bilinear => { /* ... */ },
///     AlgorithmNameGeoMosaic::Cubic => { /* ... */ },
///     AlgorithmNameGeoMosaic::Cubicspline => { /* ... */ },
///     AlgorithmNameGeoMosaic::Lanczos => { /* ... */ },
///     AlgorithmNameGeoMosaic::Max => { /* ... */ },
///     AlgorithmNameGeoMosaic::Med => { /* ... */ },
///     AlgorithmNameGeoMosaic::Min => { /* ... */ },
///     AlgorithmNameGeoMosaic::Mode => { /* ... */ },
///     AlgorithmNameGeoMosaic::Near => { /* ... */ },
///     AlgorithmNameGeoMosaic::Q1 => { /* ... */ },
///     AlgorithmNameGeoMosaic::Q3 => { /* ... */ },
///     AlgorithmNameGeoMosaic::Rms => { /* ... */ },
///     AlgorithmNameGeoMosaic::Sum => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `algorithmnamegeomosaic` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AlgorithmNameGeoMosaic::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AlgorithmNameGeoMosaic::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AlgorithmNameGeoMosaic::NewFeature` is defined.
/// Specifically, when `algorithmnamegeomosaic` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AlgorithmNameGeoMosaic::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AlgorithmNameGeoMosaic {
    /// AVERAGE
    Average,
    /// BILINEAR
    Bilinear,
    /// CUBIC
    Cubic,
    /// CUBICSPLINE
    Cubicspline,
    /// LANCZOS
    Lanczos,
    /// MAX
    Max,
    /// MED
    Med,
    /// MIN
    Min,
    /// MODE
    Mode,
    /// NEAR
    Near,
    /// Q1
    Q1,
    /// Q3
    Q3,
    /// RMS
    Rms,
    /// SUM
    Sum,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AlgorithmNameGeoMosaic {
    fn from(s: &str) -> Self {
        match s {
            "AVERAGE" => AlgorithmNameGeoMosaic::Average,
            "BILINEAR" => AlgorithmNameGeoMosaic::Bilinear,
            "CUBIC" => AlgorithmNameGeoMosaic::Cubic,
            "CUBICSPLINE" => AlgorithmNameGeoMosaic::Cubicspline,
            "LANCZOS" => AlgorithmNameGeoMosaic::Lanczos,
            "MAX" => AlgorithmNameGeoMosaic::Max,
            "MED" => AlgorithmNameGeoMosaic::Med,
            "MIN" => AlgorithmNameGeoMosaic::Min,
            "MODE" => AlgorithmNameGeoMosaic::Mode,
            "NEAR" => AlgorithmNameGeoMosaic::Near,
            "Q1" => AlgorithmNameGeoMosaic::Q1,
            "Q3" => AlgorithmNameGeoMosaic::Q3,
            "RMS" => AlgorithmNameGeoMosaic::Rms,
            "SUM" => AlgorithmNameGeoMosaic::Sum,
            other => {
                AlgorithmNameGeoMosaic::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for AlgorithmNameGeoMosaic {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AlgorithmNameGeoMosaic::from(s))
    }
}
impl AlgorithmNameGeoMosaic {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AlgorithmNameGeoMosaic::Average => "AVERAGE",
            AlgorithmNameGeoMosaic::Bilinear => "BILINEAR",
            AlgorithmNameGeoMosaic::Cubic => "CUBIC",
            AlgorithmNameGeoMosaic::Cubicspline => "CUBICSPLINE",
            AlgorithmNameGeoMosaic::Lanczos => "LANCZOS",
            AlgorithmNameGeoMosaic::Max => "MAX",
            AlgorithmNameGeoMosaic::Med => "MED",
            AlgorithmNameGeoMosaic::Min => "MIN",
            AlgorithmNameGeoMosaic::Mode => "MODE",
            AlgorithmNameGeoMosaic::Near => "NEAR",
            AlgorithmNameGeoMosaic::Q1 => "Q1",
            AlgorithmNameGeoMosaic::Q3 => "Q3",
            AlgorithmNameGeoMosaic::Rms => "RMS",
            AlgorithmNameGeoMosaic::Sum => "SUM",
            AlgorithmNameGeoMosaic::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVERAGE",
            "BILINEAR",
            "CUBIC",
            "CUBICSPLINE",
            "LANCZOS",
            "MAX",
            "MED",
            "MIN",
            "MODE",
            "NEAR",
            "Q1",
            "Q3",
            "RMS",
            "SUM",
        ]
    }
}
impl AsRef<str> for AlgorithmNameGeoMosaic {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ZonalStatisticsConfigInput {
    /// <p></p>
    #[doc(hidden)]
    pub zone_s3_path: std::option::Option<std::string::String>,
    /// <p></p>
    #[doc(hidden)]
    pub statistics: std::option::Option<std::vec::Vec<crate::model::ZonalStatistics>>,
    /// <p></p>
    #[doc(hidden)]
    pub target_bands: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ZonalStatisticsConfigInput {
    /// <p></p>
    pub fn zone_s3_path(&self) -> std::option::Option<&str> {
        self.zone_s3_path.as_deref()
    }
    /// <p></p>
    pub fn statistics(&self) -> std::option::Option<&[crate::model::ZonalStatistics]> {
        self.statistics.as_deref()
    }
    /// <p></p>
    pub fn target_bands(&self) -> std::option::Option<&[std::string::String]> {
        self.target_bands.as_deref()
    }
}
/// See [`ZonalStatisticsConfigInput`](crate::model::ZonalStatisticsConfigInput).
pub mod zonal_statistics_config_input {

    /// A builder for [`ZonalStatisticsConfigInput`](crate::model::ZonalStatisticsConfigInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) zone_s3_path: std::option::Option<std::string::String>,
        pub(crate) statistics: std::option::Option<std::vec::Vec<crate::model::ZonalStatistics>>,
        pub(crate) target_bands: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p></p>
        pub fn zone_s3_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.zone_s3_path = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_zone_s3_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.zone_s3_path = input;
            self
        }
        /// Appends an item to `statistics`.
        ///
        /// To override the contents of this collection use [`set_statistics`](Self::set_statistics).
        ///
        /// <p></p>
        pub fn statistics(mut self, input: crate::model::ZonalStatistics) -> Self {
            let mut v = self.statistics.unwrap_or_default();
            v.push(input);
            self.statistics = Some(v);
            self
        }
        /// <p></p>
        pub fn set_statistics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ZonalStatistics>>,
        ) -> Self {
            self.statistics = input;
            self
        }
        /// Appends an item to `target_bands`.
        ///
        /// To override the contents of this collection use [`set_target_bands`](Self::set_target_bands).
        ///
        /// <p></p>
        pub fn target_bands(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_bands.unwrap_or_default();
            v.push(input.into());
            self.target_bands = Some(v);
            self
        }
        /// <p></p>
        pub fn set_target_bands(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_bands = input;
            self
        }
        /// Consumes the builder and constructs a [`ZonalStatisticsConfigInput`](crate::model::ZonalStatisticsConfigInput).
        pub fn build(self) -> crate::model::ZonalStatisticsConfigInput {
            crate::model::ZonalStatisticsConfigInput {
                zone_s3_path: self.zone_s3_path,
                statistics: self.statistics,
                target_bands: self.target_bands,
            }
        }
    }
}
impl ZonalStatisticsConfigInput {
    /// Creates a new builder-style object to manufacture [`ZonalStatisticsConfigInput`](crate::model::ZonalStatisticsConfigInput).
    pub fn builder() -> crate::model::zonal_statistics_config_input::Builder {
        crate::model::zonal_statistics_config_input::Builder::default()
    }
}

/// When writing a match expression against `ZonalStatistics`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let zonalstatistics = unimplemented!();
/// match zonalstatistics {
///     ZonalStatistics::Max => { /* ... */ },
///     ZonalStatistics::Mean => { /* ... */ },
///     ZonalStatistics::Median => { /* ... */ },
///     ZonalStatistics::Min => { /* ... */ },
///     ZonalStatistics::StandardDeviation => { /* ... */ },
///     ZonalStatistics::Sum => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `zonalstatistics` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ZonalStatistics::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ZonalStatistics::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ZonalStatistics::NewFeature` is defined.
/// Specifically, when `zonalstatistics` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ZonalStatistics::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ZonalStatistics {
    /// MAX
    Max,
    /// MEAN
    Mean,
    /// MEDIAN
    Median,
    /// MIN
    Min,
    /// STANDARD_DEVIATION
    StandardDeviation,
    /// SUM
    Sum,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ZonalStatistics {
    fn from(s: &str) -> Self {
        match s {
            "MAX" => ZonalStatistics::Max,
            "MEAN" => ZonalStatistics::Mean,
            "MEDIAN" => ZonalStatistics::Median,
            "MIN" => ZonalStatistics::Min,
            "STANDARD_DEVIATION" => ZonalStatistics::StandardDeviation,
            "SUM" => ZonalStatistics::Sum,
            other => ZonalStatistics::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ZonalStatistics {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ZonalStatistics::from(s))
    }
}
impl ZonalStatistics {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ZonalStatistics::Max => "MAX",
            ZonalStatistics::Mean => "MEAN",
            ZonalStatistics::Median => "MEDIAN",
            ZonalStatistics::Min => "MIN",
            ZonalStatistics::StandardDeviation => "STANDARD_DEVIATION",
            ZonalStatistics::Sum => "SUM",
            ZonalStatistics::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["MAX", "MEAN", "MEDIAN", "MIN", "STANDARD_DEVIATION", "SUM"]
    }
}
impl AsRef<str> for ZonalStatistics {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CloudRemovalConfigInput {
    /// <p>The name of the algorithm used for cloud removal.</p>
    #[doc(hidden)]
    pub algorithm_name: std::option::Option<crate::model::AlgorithmNameCloudRemoval>,
    /// <p>The interpolation value you provide for cloud removal.</p>
    #[doc(hidden)]
    pub interpolation_value: std::option::Option<std::string::String>,
    /// <p></p>
    #[doc(hidden)]
    pub target_bands: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CloudRemovalConfigInput {
    /// <p>The name of the algorithm used for cloud removal.</p>
    pub fn algorithm_name(&self) -> std::option::Option<&crate::model::AlgorithmNameCloudRemoval> {
        self.algorithm_name.as_ref()
    }
    /// <p>The interpolation value you provide for cloud removal.</p>
    pub fn interpolation_value(&self) -> std::option::Option<&str> {
        self.interpolation_value.as_deref()
    }
    /// <p></p>
    pub fn target_bands(&self) -> std::option::Option<&[std::string::String]> {
        self.target_bands.as_deref()
    }
}
/// See [`CloudRemovalConfigInput`](crate::model::CloudRemovalConfigInput).
pub mod cloud_removal_config_input {

    /// A builder for [`CloudRemovalConfigInput`](crate::model::CloudRemovalConfigInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) algorithm_name: std::option::Option<crate::model::AlgorithmNameCloudRemoval>,
        pub(crate) interpolation_value: std::option::Option<std::string::String>,
        pub(crate) target_bands: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the algorithm used for cloud removal.</p>
        pub fn algorithm_name(mut self, input: crate::model::AlgorithmNameCloudRemoval) -> Self {
            self.algorithm_name = Some(input);
            self
        }
        /// <p>The name of the algorithm used for cloud removal.</p>
        pub fn set_algorithm_name(
            mut self,
            input: std::option::Option<crate::model::AlgorithmNameCloudRemoval>,
        ) -> Self {
            self.algorithm_name = input;
            self
        }
        /// <p>The interpolation value you provide for cloud removal.</p>
        pub fn interpolation_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.interpolation_value = Some(input.into());
            self
        }
        /// <p>The interpolation value you provide for cloud removal.</p>
        pub fn set_interpolation_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.interpolation_value = input;
            self
        }
        /// Appends an item to `target_bands`.
        ///
        /// To override the contents of this collection use [`set_target_bands`](Self::set_target_bands).
        ///
        /// <p></p>
        pub fn target_bands(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_bands.unwrap_or_default();
            v.push(input.into());
            self.target_bands = Some(v);
            self
        }
        /// <p></p>
        pub fn set_target_bands(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_bands = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudRemovalConfigInput`](crate::model::CloudRemovalConfigInput).
        pub fn build(self) -> crate::model::CloudRemovalConfigInput {
            crate::model::CloudRemovalConfigInput {
                algorithm_name: self.algorithm_name,
                interpolation_value: self.interpolation_value,
                target_bands: self.target_bands,
            }
        }
    }
}
impl CloudRemovalConfigInput {
    /// Creates a new builder-style object to manufacture [`CloudRemovalConfigInput`](crate::model::CloudRemovalConfigInput).
    pub fn builder() -> crate::model::cloud_removal_config_input::Builder {
        crate::model::cloud_removal_config_input::Builder::default()
    }
}

/// When writing a match expression against `AlgorithmNameCloudRemoval`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let algorithmnamecloudremoval = unimplemented!();
/// match algorithmnamecloudremoval {
///     AlgorithmNameCloudRemoval::Interpolation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `algorithmnamecloudremoval` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AlgorithmNameCloudRemoval::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AlgorithmNameCloudRemoval::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AlgorithmNameCloudRemoval::NewFeature` is defined.
/// Specifically, when `algorithmnamecloudremoval` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AlgorithmNameCloudRemoval::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AlgorithmNameCloudRemoval {
    /// INTERPOLATION
    Interpolation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AlgorithmNameCloudRemoval {
    fn from(s: &str) -> Self {
        match s {
            "INTERPOLATION" => AlgorithmNameCloudRemoval::Interpolation,
            other => AlgorithmNameCloudRemoval::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for AlgorithmNameCloudRemoval {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AlgorithmNameCloudRemoval::from(s))
    }
}
impl AlgorithmNameCloudRemoval {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AlgorithmNameCloudRemoval::Interpolation => "INTERPOLATION",
            AlgorithmNameCloudRemoval::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INTERPOLATION"]
    }
}
impl AsRef<str> for AlgorithmNameCloudRemoval {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TemporalStatisticsConfigInput {
    /// <p></p>
    #[doc(hidden)]
    pub group_by: std::option::Option<crate::model::GroupBy>,
    /// <p></p>
    #[doc(hidden)]
    pub statistics: std::option::Option<std::vec::Vec<crate::model::TemporalStatistics>>,
    /// <p></p>
    #[doc(hidden)]
    pub target_bands: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl TemporalStatisticsConfigInput {
    /// <p></p>
    pub fn group_by(&self) -> std::option::Option<&crate::model::GroupBy> {
        self.group_by.as_ref()
    }
    /// <p></p>
    pub fn statistics(&self) -> std::option::Option<&[crate::model::TemporalStatistics]> {
        self.statistics.as_deref()
    }
    /// <p></p>
    pub fn target_bands(&self) -> std::option::Option<&[std::string::String]> {
        self.target_bands.as_deref()
    }
}
/// See [`TemporalStatisticsConfigInput`](crate::model::TemporalStatisticsConfigInput).
pub mod temporal_statistics_config_input {

    /// A builder for [`TemporalStatisticsConfigInput`](crate::model::TemporalStatisticsConfigInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_by: std::option::Option<crate::model::GroupBy>,
        pub(crate) statistics: std::option::Option<std::vec::Vec<crate::model::TemporalStatistics>>,
        pub(crate) target_bands: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p></p>
        pub fn group_by(mut self, input: crate::model::GroupBy) -> Self {
            self.group_by = Some(input);
            self
        }
        /// <p></p>
        pub fn set_group_by(mut self, input: std::option::Option<crate::model::GroupBy>) -> Self {
            self.group_by = input;
            self
        }
        /// Appends an item to `statistics`.
        ///
        /// To override the contents of this collection use [`set_statistics`](Self::set_statistics).
        ///
        /// <p></p>
        pub fn statistics(mut self, input: crate::model::TemporalStatistics) -> Self {
            let mut v = self.statistics.unwrap_or_default();
            v.push(input);
            self.statistics = Some(v);
            self
        }
        /// <p></p>
        pub fn set_statistics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TemporalStatistics>>,
        ) -> Self {
            self.statistics = input;
            self
        }
        /// Appends an item to `target_bands`.
        ///
        /// To override the contents of this collection use [`set_target_bands`](Self::set_target_bands).
        ///
        /// <p></p>
        pub fn target_bands(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_bands.unwrap_or_default();
            v.push(input.into());
            self.target_bands = Some(v);
            self
        }
        /// <p></p>
        pub fn set_target_bands(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_bands = input;
            self
        }
        /// Consumes the builder and constructs a [`TemporalStatisticsConfigInput`](crate::model::TemporalStatisticsConfigInput).
        pub fn build(self) -> crate::model::TemporalStatisticsConfigInput {
            crate::model::TemporalStatisticsConfigInput {
                group_by: self.group_by,
                statistics: self.statistics,
                target_bands: self.target_bands,
            }
        }
    }
}
impl TemporalStatisticsConfigInput {
    /// Creates a new builder-style object to manufacture [`TemporalStatisticsConfigInput`](crate::model::TemporalStatisticsConfigInput).
    pub fn builder() -> crate::model::temporal_statistics_config_input::Builder {
        crate::model::temporal_statistics_config_input::Builder::default()
    }
}

/// When writing a match expression against `TemporalStatistics`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let temporalstatistics = unimplemented!();
/// match temporalstatistics {
///     TemporalStatistics::Mean => { /* ... */ },
///     TemporalStatistics::Median => { /* ... */ },
///     TemporalStatistics::StandardDeviation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `temporalstatistics` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TemporalStatistics::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TemporalStatistics::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TemporalStatistics::NewFeature` is defined.
/// Specifically, when `temporalstatistics` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TemporalStatistics::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TemporalStatistics {
    /// MEAN
    Mean,
    /// MEDIAN
    Median,
    /// STANDARD_DEVIATION
    StandardDeviation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TemporalStatistics {
    fn from(s: &str) -> Self {
        match s {
            "MEAN" => TemporalStatistics::Mean,
            "MEDIAN" => TemporalStatistics::Median,
            "STANDARD_DEVIATION" => TemporalStatistics::StandardDeviation,
            other => {
                TemporalStatistics::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TemporalStatistics {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TemporalStatistics::from(s))
    }
}
impl TemporalStatistics {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TemporalStatistics::Mean => "MEAN",
            TemporalStatistics::Median => "MEDIAN",
            TemporalStatistics::StandardDeviation => "STANDARD_DEVIATION",
            TemporalStatistics::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["MEAN", "MEDIAN", "STANDARD_DEVIATION"]
    }
}
impl AsRef<str> for TemporalStatistics {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `GroupBy`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let groupby = unimplemented!();
/// match groupby {
///     GroupBy::All => { /* ... */ },
///     GroupBy::Yearly => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `groupby` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `GroupBy::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `GroupBy::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `GroupBy::NewFeature` is defined.
/// Specifically, when `groupby` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `GroupBy::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GroupBy {
    /// ALL
    All,
    /// YEARLY
    Yearly,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for GroupBy {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => GroupBy::All,
            "YEARLY" => GroupBy::Yearly,
            other => GroupBy::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for GroupBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(GroupBy::from(s))
    }
}
impl GroupBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            GroupBy::All => "ALL",
            GroupBy::Yearly => "YEARLY",
            GroupBy::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL", "YEARLY"]
    }
}
impl AsRef<str> for GroupBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResamplingConfigInput {
    /// <p></p>
    #[doc(hidden)]
    pub output_resolution: std::option::Option<crate::model::OutputResolutionResamplingInput>,
    /// <p>The name of the algorithm used for resampling.</p>
    #[doc(hidden)]
    pub algorithm_name: std::option::Option<crate::model::AlgorithmNameResampling>,
    /// <p></p>
    #[doc(hidden)]
    pub target_bands: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ResamplingConfigInput {
    /// <p></p>
    pub fn output_resolution(
        &self,
    ) -> std::option::Option<&crate::model::OutputResolutionResamplingInput> {
        self.output_resolution.as_ref()
    }
    /// <p>The name of the algorithm used for resampling.</p>
    pub fn algorithm_name(&self) -> std::option::Option<&crate::model::AlgorithmNameResampling> {
        self.algorithm_name.as_ref()
    }
    /// <p></p>
    pub fn target_bands(&self) -> std::option::Option<&[std::string::String]> {
        self.target_bands.as_deref()
    }
}
/// See [`ResamplingConfigInput`](crate::model::ResamplingConfigInput).
pub mod resampling_config_input {

    /// A builder for [`ResamplingConfigInput`](crate::model::ResamplingConfigInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_resolution:
            std::option::Option<crate::model::OutputResolutionResamplingInput>,
        pub(crate) algorithm_name: std::option::Option<crate::model::AlgorithmNameResampling>,
        pub(crate) target_bands: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p></p>
        pub fn output_resolution(
            mut self,
            input: crate::model::OutputResolutionResamplingInput,
        ) -> Self {
            self.output_resolution = Some(input);
            self
        }
        /// <p></p>
        pub fn set_output_resolution(
            mut self,
            input: std::option::Option<crate::model::OutputResolutionResamplingInput>,
        ) -> Self {
            self.output_resolution = input;
            self
        }
        /// <p>The name of the algorithm used for resampling.</p>
        pub fn algorithm_name(mut self, input: crate::model::AlgorithmNameResampling) -> Self {
            self.algorithm_name = Some(input);
            self
        }
        /// <p>The name of the algorithm used for resampling.</p>
        pub fn set_algorithm_name(
            mut self,
            input: std::option::Option<crate::model::AlgorithmNameResampling>,
        ) -> Self {
            self.algorithm_name = input;
            self
        }
        /// Appends an item to `target_bands`.
        ///
        /// To override the contents of this collection use [`set_target_bands`](Self::set_target_bands).
        ///
        /// <p></p>
        pub fn target_bands(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_bands.unwrap_or_default();
            v.push(input.into());
            self.target_bands = Some(v);
            self
        }
        /// <p></p>
        pub fn set_target_bands(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_bands = input;
            self
        }
        /// Consumes the builder and constructs a [`ResamplingConfigInput`](crate::model::ResamplingConfigInput).
        pub fn build(self) -> crate::model::ResamplingConfigInput {
            crate::model::ResamplingConfigInput {
                output_resolution: self.output_resolution,
                algorithm_name: self.algorithm_name,
                target_bands: self.target_bands,
            }
        }
    }
}
impl ResamplingConfigInput {
    /// Creates a new builder-style object to manufacture [`ResamplingConfigInput`](crate::model::ResamplingConfigInput).
    pub fn builder() -> crate::model::resampling_config_input::Builder {
        crate::model::resampling_config_input::Builder::default()
    }
}

/// When writing a match expression against `AlgorithmNameResampling`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let algorithmnameresampling = unimplemented!();
/// match algorithmnameresampling {
///     AlgorithmNameResampling::Average => { /* ... */ },
///     AlgorithmNameResampling::Bilinear => { /* ... */ },
///     AlgorithmNameResampling::Cubic => { /* ... */ },
///     AlgorithmNameResampling::Cubicspline => { /* ... */ },
///     AlgorithmNameResampling::Lanczos => { /* ... */ },
///     AlgorithmNameResampling::Max => { /* ... */ },
///     AlgorithmNameResampling::Med => { /* ... */ },
///     AlgorithmNameResampling::Min => { /* ... */ },
///     AlgorithmNameResampling::Mode => { /* ... */ },
///     AlgorithmNameResampling::Near => { /* ... */ },
///     AlgorithmNameResampling::Q1 => { /* ... */ },
///     AlgorithmNameResampling::Q3 => { /* ... */ },
///     AlgorithmNameResampling::Rms => { /* ... */ },
///     AlgorithmNameResampling::Sum => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `algorithmnameresampling` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AlgorithmNameResampling::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AlgorithmNameResampling::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AlgorithmNameResampling::NewFeature` is defined.
/// Specifically, when `algorithmnameresampling` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AlgorithmNameResampling::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AlgorithmNameResampling {
    /// AVERAGE
    Average,
    /// BILINEAR
    Bilinear,
    /// CUBIC
    Cubic,
    /// CUBICSPLINE
    Cubicspline,
    /// LANCZOS
    Lanczos,
    /// MAX
    Max,
    /// MED
    Med,
    /// MIN
    Min,
    /// MODE
    Mode,
    /// NEAR
    Near,
    /// Q1
    Q1,
    /// Q3
    Q3,
    /// RMS
    Rms,
    /// SUM
    Sum,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AlgorithmNameResampling {
    fn from(s: &str) -> Self {
        match s {
            "AVERAGE" => AlgorithmNameResampling::Average,
            "BILINEAR" => AlgorithmNameResampling::Bilinear,
            "CUBIC" => AlgorithmNameResampling::Cubic,
            "CUBICSPLINE" => AlgorithmNameResampling::Cubicspline,
            "LANCZOS" => AlgorithmNameResampling::Lanczos,
            "MAX" => AlgorithmNameResampling::Max,
            "MED" => AlgorithmNameResampling::Med,
            "MIN" => AlgorithmNameResampling::Min,
            "MODE" => AlgorithmNameResampling::Mode,
            "NEAR" => AlgorithmNameResampling::Near,
            "Q1" => AlgorithmNameResampling::Q1,
            "Q3" => AlgorithmNameResampling::Q3,
            "RMS" => AlgorithmNameResampling::Rms,
            "SUM" => AlgorithmNameResampling::Sum,
            other => AlgorithmNameResampling::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for AlgorithmNameResampling {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AlgorithmNameResampling::from(s))
    }
}
impl AlgorithmNameResampling {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AlgorithmNameResampling::Average => "AVERAGE",
            AlgorithmNameResampling::Bilinear => "BILINEAR",
            AlgorithmNameResampling::Cubic => "CUBIC",
            AlgorithmNameResampling::Cubicspline => "CUBICSPLINE",
            AlgorithmNameResampling::Lanczos => "LANCZOS",
            AlgorithmNameResampling::Max => "MAX",
            AlgorithmNameResampling::Med => "MED",
            AlgorithmNameResampling::Min => "MIN",
            AlgorithmNameResampling::Mode => "MODE",
            AlgorithmNameResampling::Near => "NEAR",
            AlgorithmNameResampling::Q1 => "Q1",
            AlgorithmNameResampling::Q3 => "Q3",
            AlgorithmNameResampling::Rms => "RMS",
            AlgorithmNameResampling::Sum => "SUM",
            AlgorithmNameResampling::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVERAGE",
            "BILINEAR",
            "CUBIC",
            "CUBICSPLINE",
            "LANCZOS",
            "MAX",
            "MED",
            "MIN",
            "MODE",
            "NEAR",
            "Q1",
            "Q3",
            "RMS",
            "SUM",
        ]
    }
}
impl AsRef<str> for AlgorithmNameResampling {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OutputResolutionResamplingInput {
    /// <p></p>
    #[doc(hidden)]
    pub user_defined: std::option::Option<crate::model::UserDefined>,
}
impl OutputResolutionResamplingInput {
    /// <p></p>
    pub fn user_defined(&self) -> std::option::Option<&crate::model::UserDefined> {
        self.user_defined.as_ref()
    }
}
/// See [`OutputResolutionResamplingInput`](crate::model::OutputResolutionResamplingInput).
pub mod output_resolution_resampling_input {

    /// A builder for [`OutputResolutionResamplingInput`](crate::model::OutputResolutionResamplingInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_defined: std::option::Option<crate::model::UserDefined>,
    }
    impl Builder {
        /// <p></p>
        pub fn user_defined(mut self, input: crate::model::UserDefined) -> Self {
            self.user_defined = Some(input);
            self
        }
        /// <p></p>
        pub fn set_user_defined(
            mut self,
            input: std::option::Option<crate::model::UserDefined>,
        ) -> Self {
            self.user_defined = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputResolutionResamplingInput`](crate::model::OutputResolutionResamplingInput).
        pub fn build(self) -> crate::model::OutputResolutionResamplingInput {
            crate::model::OutputResolutionResamplingInput {
                user_defined: self.user_defined,
            }
        }
    }
}
impl OutputResolutionResamplingInput {
    /// Creates a new builder-style object to manufacture [`OutputResolutionResamplingInput`](crate::model::OutputResolutionResamplingInput).
    pub fn builder() -> crate::model::output_resolution_resampling_input::Builder {
        crate::model::output_resolution_resampling_input::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BandMathConfigInput {
    /// <p></p>
    #[doc(hidden)]
    pub predefined_indices: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p></p>
    #[doc(hidden)]
    pub custom_indices: std::option::Option<crate::model::CustomIndicesInput>,
}
impl BandMathConfigInput {
    /// <p></p>
    pub fn predefined_indices(&self) -> std::option::Option<&[std::string::String]> {
        self.predefined_indices.as_deref()
    }
    /// <p></p>
    pub fn custom_indices(&self) -> std::option::Option<&crate::model::CustomIndicesInput> {
        self.custom_indices.as_ref()
    }
}
/// See [`BandMathConfigInput`](crate::model::BandMathConfigInput).
pub mod band_math_config_input {

    /// A builder for [`BandMathConfigInput`](crate::model::BandMathConfigInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) predefined_indices: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) custom_indices: std::option::Option<crate::model::CustomIndicesInput>,
    }
    impl Builder {
        /// Appends an item to `predefined_indices`.
        ///
        /// To override the contents of this collection use [`set_predefined_indices`](Self::set_predefined_indices).
        ///
        /// <p></p>
        pub fn predefined_indices(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.predefined_indices.unwrap_or_default();
            v.push(input.into());
            self.predefined_indices = Some(v);
            self
        }
        /// <p></p>
        pub fn set_predefined_indices(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.predefined_indices = input;
            self
        }
        /// <p></p>
        pub fn custom_indices(mut self, input: crate::model::CustomIndicesInput) -> Self {
            self.custom_indices = Some(input);
            self
        }
        /// <p></p>
        pub fn set_custom_indices(
            mut self,
            input: std::option::Option<crate::model::CustomIndicesInput>,
        ) -> Self {
            self.custom_indices = input;
            self
        }
        /// Consumes the builder and constructs a [`BandMathConfigInput`](crate::model::BandMathConfigInput).
        pub fn build(self) -> crate::model::BandMathConfigInput {
            crate::model::BandMathConfigInput {
                predefined_indices: self.predefined_indices,
                custom_indices: self.custom_indices,
            }
        }
    }
}
impl BandMathConfigInput {
    /// Creates a new builder-style object to manufacture [`BandMathConfigInput`](crate::model::BandMathConfigInput).
    pub fn builder() -> crate::model::band_math_config_input::Builder {
        crate::model::band_math_config_input::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomIndicesInput {
    /// <p></p>
    #[doc(hidden)]
    pub operations: std::option::Option<std::vec::Vec<crate::model::Operation>>,
}
impl CustomIndicesInput {
    /// <p></p>
    pub fn operations(&self) -> std::option::Option<&[crate::model::Operation]> {
        self.operations.as_deref()
    }
}
/// See [`CustomIndicesInput`](crate::model::CustomIndicesInput).
pub mod custom_indices_input {

    /// A builder for [`CustomIndicesInput`](crate::model::CustomIndicesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) operations: std::option::Option<std::vec::Vec<crate::model::Operation>>,
    }
    impl Builder {
        /// Appends an item to `operations`.
        ///
        /// To override the contents of this collection use [`set_operations`](Self::set_operations).
        ///
        /// <p></p>
        pub fn operations(mut self, input: crate::model::Operation) -> Self {
            let mut v = self.operations.unwrap_or_default();
            v.push(input);
            self.operations = Some(v);
            self
        }
        /// <p></p>
        pub fn set_operations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Operation>>,
        ) -> Self {
            self.operations = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomIndicesInput`](crate::model::CustomIndicesInput).
        pub fn build(self) -> crate::model::CustomIndicesInput {
            crate::model::CustomIndicesInput {
                operations: self.operations,
            }
        }
    }
}
impl CustomIndicesInput {
    /// Creates a new builder-style object to manufacture [`CustomIndicesInput`](crate::model::CustomIndicesInput).
    pub fn builder() -> crate::model::custom_indices_input::Builder {
        crate::model::custom_indices_input::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Operation {
    /// <p>The name of the operation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p></p>
    #[doc(hidden)]
    pub equation: std::option::Option<std::string::String>,
    /// <p>The type of the operation.</p>
    #[doc(hidden)]
    pub output_type: std::option::Option<crate::model::OutputType>,
}
impl Operation {
    /// <p>The name of the operation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p></p>
    pub fn equation(&self) -> std::option::Option<&str> {
        self.equation.as_deref()
    }
    /// <p>The type of the operation.</p>
    pub fn output_type(&self) -> std::option::Option<&crate::model::OutputType> {
        self.output_type.as_ref()
    }
}
/// See [`Operation`](crate::model::Operation).
pub mod operation {

    /// A builder for [`Operation`](crate::model::Operation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) equation: std::option::Option<std::string::String>,
        pub(crate) output_type: std::option::Option<crate::model::OutputType>,
    }
    impl Builder {
        /// <p>The name of the operation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the operation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p></p>
        pub fn equation(mut self, input: impl Into<std::string::String>) -> Self {
            self.equation = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_equation(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.equation = input;
            self
        }
        /// <p>The type of the operation.</p>
        pub fn output_type(mut self, input: crate::model::OutputType) -> Self {
            self.output_type = Some(input);
            self
        }
        /// <p>The type of the operation.</p>
        pub fn set_output_type(
            mut self,
            input: std::option::Option<crate::model::OutputType>,
        ) -> Self {
            self.output_type = input;
            self
        }
        /// Consumes the builder and constructs a [`Operation`](crate::model::Operation).
        pub fn build(self) -> crate::model::Operation {
            crate::model::Operation {
                name: self.name,
                equation: self.equation,
                output_type: self.output_type,
            }
        }
    }
}
impl Operation {
    /// Creates a new builder-style object to manufacture [`Operation`](crate::model::Operation).
    pub fn builder() -> crate::model::operation::Builder {
        crate::model::operation::Builder::default()
    }
}

/// <p>The InputConfig for an EarthObservationJob response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InputConfigOutput {
    /// <p>The Amazon Resource Name (ARN) of the previous Earth Observation job.</p>
    #[doc(hidden)]
    pub previous_earth_observation_job_arn: std::option::Option<std::string::String>,
    /// <p>The location of the input data.</p>
    #[doc(hidden)]
    pub data_source_config: std::option::Option<crate::model::EojDataSourceConfigInput>,
    /// <p></p>
    #[doc(hidden)]
    pub raster_data_collection_query:
        std::option::Option<crate::model::RasterDataCollectionQueryOutput>,
}
impl InputConfigOutput {
    /// <p>The Amazon Resource Name (ARN) of the previous Earth Observation job.</p>
    pub fn previous_earth_observation_job_arn(&self) -> std::option::Option<&str> {
        self.previous_earth_observation_job_arn.as_deref()
    }
    /// <p>The location of the input data.</p>
    pub fn data_source_config(
        &self,
    ) -> std::option::Option<&crate::model::EojDataSourceConfigInput> {
        self.data_source_config.as_ref()
    }
    /// <p></p>
    pub fn raster_data_collection_query(
        &self,
    ) -> std::option::Option<&crate::model::RasterDataCollectionQueryOutput> {
        self.raster_data_collection_query.as_ref()
    }
}
/// See [`InputConfigOutput`](crate::model::InputConfigOutput).
pub mod input_config_output {

    /// A builder for [`InputConfigOutput`](crate::model::InputConfigOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) previous_earth_observation_job_arn: std::option::Option<std::string::String>,
        pub(crate) data_source_config: std::option::Option<crate::model::EojDataSourceConfigInput>,
        pub(crate) raster_data_collection_query:
            std::option::Option<crate::model::RasterDataCollectionQueryOutput>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the previous Earth Observation job.</p>
        pub fn previous_earth_observation_job_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.previous_earth_observation_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the previous Earth Observation job.</p>
        pub fn set_previous_earth_observation_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.previous_earth_observation_job_arn = input;
            self
        }
        /// <p>The location of the input data.</p>
        pub fn data_source_config(mut self, input: crate::model::EojDataSourceConfigInput) -> Self {
            self.data_source_config = Some(input);
            self
        }
        /// <p>The location of the input data.</p>
        pub fn set_data_source_config(
            mut self,
            input: std::option::Option<crate::model::EojDataSourceConfigInput>,
        ) -> Self {
            self.data_source_config = input;
            self
        }
        /// <p></p>
        pub fn raster_data_collection_query(
            mut self,
            input: crate::model::RasterDataCollectionQueryOutput,
        ) -> Self {
            self.raster_data_collection_query = Some(input);
            self
        }
        /// <p></p>
        pub fn set_raster_data_collection_query(
            mut self,
            input: std::option::Option<crate::model::RasterDataCollectionQueryOutput>,
        ) -> Self {
            self.raster_data_collection_query = input;
            self
        }
        /// Consumes the builder and constructs a [`InputConfigOutput`](crate::model::InputConfigOutput).
        pub fn build(self) -> crate::model::InputConfigOutput {
            crate::model::InputConfigOutput {
                previous_earth_observation_job_arn: self.previous_earth_observation_job_arn,
                data_source_config: self.data_source_config,
                raster_data_collection_query: self.raster_data_collection_query,
            }
        }
    }
}
impl InputConfigOutput {
    /// Creates a new builder-style object to manufacture [`InputConfigOutput`](crate::model::InputConfigOutput).
    pub fn builder() -> crate::model::input_config_output::Builder {
        crate::model::input_config_output::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RasterDataCollectionQueryOutput {
    /// <p></p>
    #[doc(hidden)]
    pub raster_data_collection_arn: std::option::Option<std::string::String>,
    /// <p>The name of the raster data collection.</p>
    #[doc(hidden)]
    pub raster_data_collection_name: std::option::Option<std::string::String>,
    /// <p></p>
    #[doc(hidden)]
    pub time_range_filter: std::option::Option<crate::model::TimeRangeFilterInput>,
    /// <p></p>
    #[doc(hidden)]
    pub area_of_interest: std::option::Option<crate::model::AreaOfInterest>,
    /// <p></p>
    #[doc(hidden)]
    pub property_filters: std::option::Option<crate::model::PropertyFilters>,
}
impl RasterDataCollectionQueryOutput {
    /// <p></p>
    pub fn raster_data_collection_arn(&self) -> std::option::Option<&str> {
        self.raster_data_collection_arn.as_deref()
    }
    /// <p>The name of the raster data collection.</p>
    pub fn raster_data_collection_name(&self) -> std::option::Option<&str> {
        self.raster_data_collection_name.as_deref()
    }
    /// <p></p>
    pub fn time_range_filter(&self) -> std::option::Option<&crate::model::TimeRangeFilterInput> {
        self.time_range_filter.as_ref()
    }
    /// <p></p>
    pub fn area_of_interest(&self) -> std::option::Option<&crate::model::AreaOfInterest> {
        self.area_of_interest.as_ref()
    }
    /// <p></p>
    pub fn property_filters(&self) -> std::option::Option<&crate::model::PropertyFilters> {
        self.property_filters.as_ref()
    }
}
impl std::fmt::Debug for RasterDataCollectionQueryOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RasterDataCollectionQueryOutput");
        formatter.field(
            "raster_data_collection_arn",
            &self.raster_data_collection_arn,
        );
        formatter.field(
            "raster_data_collection_name",
            &self.raster_data_collection_name,
        );
        formatter.field("time_range_filter", &"*** Sensitive Data Redacted ***");
        formatter.field("area_of_interest", &self.area_of_interest);
        formatter.field("property_filters", &self.property_filters);
        formatter.finish()
    }
}
/// See [`RasterDataCollectionQueryOutput`](crate::model::RasterDataCollectionQueryOutput).
pub mod raster_data_collection_query_output {

    /// A builder for [`RasterDataCollectionQueryOutput`](crate::model::RasterDataCollectionQueryOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) raster_data_collection_arn: std::option::Option<std::string::String>,
        pub(crate) raster_data_collection_name: std::option::Option<std::string::String>,
        pub(crate) time_range_filter: std::option::Option<crate::model::TimeRangeFilterInput>,
        pub(crate) area_of_interest: std::option::Option<crate::model::AreaOfInterest>,
        pub(crate) property_filters: std::option::Option<crate::model::PropertyFilters>,
    }
    impl Builder {
        /// <p></p>
        pub fn raster_data_collection_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.raster_data_collection_arn = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_raster_data_collection_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.raster_data_collection_arn = input;
            self
        }
        /// <p>The name of the raster data collection.</p>
        pub fn raster_data_collection_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.raster_data_collection_name = Some(input.into());
            self
        }
        /// <p>The name of the raster data collection.</p>
        pub fn set_raster_data_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.raster_data_collection_name = input;
            self
        }
        /// <p></p>
        pub fn time_range_filter(mut self, input: crate::model::TimeRangeFilterInput) -> Self {
            self.time_range_filter = Some(input);
            self
        }
        /// <p></p>
        pub fn set_time_range_filter(
            mut self,
            input: std::option::Option<crate::model::TimeRangeFilterInput>,
        ) -> Self {
            self.time_range_filter = input;
            self
        }
        /// <p></p>
        pub fn area_of_interest(mut self, input: crate::model::AreaOfInterest) -> Self {
            self.area_of_interest = Some(input);
            self
        }
        /// <p></p>
        pub fn set_area_of_interest(
            mut self,
            input: std::option::Option<crate::model::AreaOfInterest>,
        ) -> Self {
            self.area_of_interest = input;
            self
        }
        /// <p></p>
        pub fn property_filters(mut self, input: crate::model::PropertyFilters) -> Self {
            self.property_filters = Some(input);
            self
        }
        /// <p></p>
        pub fn set_property_filters(
            mut self,
            input: std::option::Option<crate::model::PropertyFilters>,
        ) -> Self {
            self.property_filters = input;
            self
        }
        /// Consumes the builder and constructs a [`RasterDataCollectionQueryOutput`](crate::model::RasterDataCollectionQueryOutput).
        pub fn build(self) -> crate::model::RasterDataCollectionQueryOutput {
            crate::model::RasterDataCollectionQueryOutput {
                raster_data_collection_arn: self.raster_data_collection_arn,
                raster_data_collection_name: self.raster_data_collection_name,
                time_range_filter: self.time_range_filter,
                area_of_interest: self.area_of_interest,
                property_filters: self.property_filters,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field(
                "raster_data_collection_arn",
                &self.raster_data_collection_arn,
            );
            formatter.field(
                "raster_data_collection_name",
                &self.raster_data_collection_name,
            );
            formatter.field("time_range_filter", &"*** Sensitive Data Redacted ***");
            formatter.field("area_of_interest", &self.area_of_interest);
            formatter.field("property_filters", &self.property_filters);
            formatter.finish()
        }
    }
}
impl RasterDataCollectionQueryOutput {
    /// Creates a new builder-style object to manufacture [`RasterDataCollectionQueryOutput`](crate::model::RasterDataCollectionQueryOutput).
    pub fn builder() -> crate::model::raster_data_collection_query_output::Builder {
        crate::model::raster_data_collection_query_output::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum EojDataSourceConfigInput {
    /// <p></p>
    S3Data(crate::model::S3DataInput),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl EojDataSourceConfigInput {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`S3Data`](crate::model::EojDataSourceConfigInput::S3Data), extracting the inner [`S3DataInput`](crate::model::S3DataInput).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_s3_data(&self) -> std::result::Result<&crate::model::S3DataInput, &Self> {
        if let EojDataSourceConfigInput::S3Data(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`S3Data`](crate::model::EojDataSourceConfigInput::S3Data).
    pub fn is_s3_data(&self) -> bool {
        self.as_s3_data().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Path to Amazon S3 storage location for input data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3DataInput {
    /// <p>The URL to the Amazon S3 input.</p>
    #[doc(hidden)]
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p></p>
    #[doc(hidden)]
    pub metadata_provider: std::option::Option<crate::model::MetadataProvider>,
    /// <p>The Amazon Key Management Service (KMS) key ID for server-side encryption.</p>
    #[doc(hidden)]
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl S3DataInput {
    /// <p>The URL to the Amazon S3 input.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p></p>
    pub fn metadata_provider(&self) -> std::option::Option<&crate::model::MetadataProvider> {
        self.metadata_provider.as_ref()
    }
    /// <p>The Amazon Key Management Service (KMS) key ID for server-side encryption.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
/// See [`S3DataInput`](crate::model::S3DataInput).
pub mod s3_data_input {

    /// A builder for [`S3DataInput`](crate::model::S3DataInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) metadata_provider: std::option::Option<crate::model::MetadataProvider>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URL to the Amazon S3 input.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>The URL to the Amazon S3 input.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p></p>
        pub fn metadata_provider(mut self, input: crate::model::MetadataProvider) -> Self {
            self.metadata_provider = Some(input);
            self
        }
        /// <p></p>
        pub fn set_metadata_provider(
            mut self,
            input: std::option::Option<crate::model::MetadataProvider>,
        ) -> Self {
            self.metadata_provider = input;
            self
        }
        /// <p>The Amazon Key Management Service (KMS) key ID for server-side encryption.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Key Management Service (KMS) key ID for server-side encryption.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`S3DataInput`](crate::model::S3DataInput).
        pub fn build(self) -> crate::model::S3DataInput {
            crate::model::S3DataInput {
                s3_uri: self.s3_uri,
                metadata_provider: self.metadata_provider,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl S3DataInput {
    /// Creates a new builder-style object to manufacture [`S3DataInput`](crate::model::S3DataInput).
    pub fn builder() -> crate::model::s3_data_input::Builder {
        crate::model::s3_data_input::Builder::default()
    }
}

/// When writing a match expression against `MetadataProvider`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let metadataprovider = unimplemented!();
/// match metadataprovider {
///     MetadataProvider::PlanetOrder => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `metadataprovider` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MetadataProvider::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MetadataProvider::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MetadataProvider::NewFeature` is defined.
/// Specifically, when `metadataprovider` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MetadataProvider::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MetadataProvider {
    /// PLANET_ORDER
    PlanetOrder,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MetadataProvider {
    fn from(s: &str) -> Self {
        match s {
            "PLANET_ORDER" => MetadataProvider::PlanetOrder,
            other => MetadataProvider::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for MetadataProvider {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MetadataProvider::from(s))
    }
}
impl MetadataProvider {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MetadataProvider::PlanetOrder => "PLANET_ORDER",
            MetadataProvider::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PLANET_ORDER"]
    }
}
impl AsRef<str> for MetadataProvider {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Input configuration information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InputConfigInput {
    /// <p>The Amazon Resource Name (ARN) of the previous Earth Observation job.</p>
    #[doc(hidden)]
    pub previous_earth_observation_job_arn: std::option::Option<std::string::String>,
    /// <p>The location of the input data.&gt;</p>
    #[doc(hidden)]
    pub data_source_config: std::option::Option<crate::model::EojDataSourceConfigInput>,
    /// <p></p>
    #[doc(hidden)]
    pub raster_data_collection_query:
        std::option::Option<crate::model::RasterDataCollectionQueryInput>,
}
impl InputConfigInput {
    /// <p>The Amazon Resource Name (ARN) of the previous Earth Observation job.</p>
    pub fn previous_earth_observation_job_arn(&self) -> std::option::Option<&str> {
        self.previous_earth_observation_job_arn.as_deref()
    }
    /// <p>The location of the input data.&gt;</p>
    pub fn data_source_config(
        &self,
    ) -> std::option::Option<&crate::model::EojDataSourceConfigInput> {
        self.data_source_config.as_ref()
    }
    /// <p></p>
    pub fn raster_data_collection_query(
        &self,
    ) -> std::option::Option<&crate::model::RasterDataCollectionQueryInput> {
        self.raster_data_collection_query.as_ref()
    }
}
/// See [`InputConfigInput`](crate::model::InputConfigInput).
pub mod input_config_input {

    /// A builder for [`InputConfigInput`](crate::model::InputConfigInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) previous_earth_observation_job_arn: std::option::Option<std::string::String>,
        pub(crate) data_source_config: std::option::Option<crate::model::EojDataSourceConfigInput>,
        pub(crate) raster_data_collection_query:
            std::option::Option<crate::model::RasterDataCollectionQueryInput>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the previous Earth Observation job.</p>
        pub fn previous_earth_observation_job_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.previous_earth_observation_job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the previous Earth Observation job.</p>
        pub fn set_previous_earth_observation_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.previous_earth_observation_job_arn = input;
            self
        }
        /// <p>The location of the input data.&gt;</p>
        pub fn data_source_config(mut self, input: crate::model::EojDataSourceConfigInput) -> Self {
            self.data_source_config = Some(input);
            self
        }
        /// <p>The location of the input data.&gt;</p>
        pub fn set_data_source_config(
            mut self,
            input: std::option::Option<crate::model::EojDataSourceConfigInput>,
        ) -> Self {
            self.data_source_config = input;
            self
        }
        /// <p></p>
        pub fn raster_data_collection_query(
            mut self,
            input: crate::model::RasterDataCollectionQueryInput,
        ) -> Self {
            self.raster_data_collection_query = Some(input);
            self
        }
        /// <p></p>
        pub fn set_raster_data_collection_query(
            mut self,
            input: std::option::Option<crate::model::RasterDataCollectionQueryInput>,
        ) -> Self {
            self.raster_data_collection_query = input;
            self
        }
        /// Consumes the builder and constructs a [`InputConfigInput`](crate::model::InputConfigInput).
        pub fn build(self) -> crate::model::InputConfigInput {
            crate::model::InputConfigInput {
                previous_earth_observation_job_arn: self.previous_earth_observation_job_arn,
                data_source_config: self.data_source_config,
                raster_data_collection_query: self.raster_data_collection_query,
            }
        }
    }
}
impl InputConfigInput {
    /// Creates a new builder-style object to manufacture [`InputConfigInput`](crate::model::InputConfigInput).
    pub fn builder() -> crate::model::input_config_input::Builder {
        crate::model::input_config_input::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RasterDataCollectionQueryInput {
    /// <p>The Amazon Resource Name (ARN) of the raster data collection.</p>
    #[doc(hidden)]
    pub raster_data_collection_arn: std::option::Option<std::string::String>,
    /// <p></p>
    #[doc(hidden)]
    pub time_range_filter: std::option::Option<crate::model::TimeRangeFilterInput>,
    /// <p>The area of interest being queried for the raster data collection.</p>
    #[doc(hidden)]
    pub area_of_interest: std::option::Option<crate::model::AreaOfInterest>,
    /// <p></p>
    #[doc(hidden)]
    pub property_filters: std::option::Option<crate::model::PropertyFilters>,
}
impl RasterDataCollectionQueryInput {
    /// <p>The Amazon Resource Name (ARN) of the raster data collection.</p>
    pub fn raster_data_collection_arn(&self) -> std::option::Option<&str> {
        self.raster_data_collection_arn.as_deref()
    }
    /// <p></p>
    pub fn time_range_filter(&self) -> std::option::Option<&crate::model::TimeRangeFilterInput> {
        self.time_range_filter.as_ref()
    }
    /// <p>The area of interest being queried for the raster data collection.</p>
    pub fn area_of_interest(&self) -> std::option::Option<&crate::model::AreaOfInterest> {
        self.area_of_interest.as_ref()
    }
    /// <p></p>
    pub fn property_filters(&self) -> std::option::Option<&crate::model::PropertyFilters> {
        self.property_filters.as_ref()
    }
}
impl std::fmt::Debug for RasterDataCollectionQueryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RasterDataCollectionQueryInput");
        formatter.field(
            "raster_data_collection_arn",
            &self.raster_data_collection_arn,
        );
        formatter.field("time_range_filter", &"*** Sensitive Data Redacted ***");
        formatter.field("area_of_interest", &self.area_of_interest);
        formatter.field("property_filters", &self.property_filters);
        formatter.finish()
    }
}
/// See [`RasterDataCollectionQueryInput`](crate::model::RasterDataCollectionQueryInput).
pub mod raster_data_collection_query_input {

    /// A builder for [`RasterDataCollectionQueryInput`](crate::model::RasterDataCollectionQueryInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) raster_data_collection_arn: std::option::Option<std::string::String>,
        pub(crate) time_range_filter: std::option::Option<crate::model::TimeRangeFilterInput>,
        pub(crate) area_of_interest: std::option::Option<crate::model::AreaOfInterest>,
        pub(crate) property_filters: std::option::Option<crate::model::PropertyFilters>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the raster data collection.</p>
        pub fn raster_data_collection_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.raster_data_collection_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the raster data collection.</p>
        pub fn set_raster_data_collection_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.raster_data_collection_arn = input;
            self
        }
        /// <p></p>
        pub fn time_range_filter(mut self, input: crate::model::TimeRangeFilterInput) -> Self {
            self.time_range_filter = Some(input);
            self
        }
        /// <p></p>
        pub fn set_time_range_filter(
            mut self,
            input: std::option::Option<crate::model::TimeRangeFilterInput>,
        ) -> Self {
            self.time_range_filter = input;
            self
        }
        /// <p>The area of interest being queried for the raster data collection.</p>
        pub fn area_of_interest(mut self, input: crate::model::AreaOfInterest) -> Self {
            self.area_of_interest = Some(input);
            self
        }
        /// <p>The area of interest being queried for the raster data collection.</p>
        pub fn set_area_of_interest(
            mut self,
            input: std::option::Option<crate::model::AreaOfInterest>,
        ) -> Self {
            self.area_of_interest = input;
            self
        }
        /// <p></p>
        pub fn property_filters(mut self, input: crate::model::PropertyFilters) -> Self {
            self.property_filters = Some(input);
            self
        }
        /// <p></p>
        pub fn set_property_filters(
            mut self,
            input: std::option::Option<crate::model::PropertyFilters>,
        ) -> Self {
            self.property_filters = input;
            self
        }
        /// Consumes the builder and constructs a [`RasterDataCollectionQueryInput`](crate::model::RasterDataCollectionQueryInput).
        pub fn build(self) -> crate::model::RasterDataCollectionQueryInput {
            crate::model::RasterDataCollectionQueryInput {
                raster_data_collection_arn: self.raster_data_collection_arn,
                time_range_filter: self.time_range_filter,
                area_of_interest: self.area_of_interest,
                property_filters: self.property_filters,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field(
                "raster_data_collection_arn",
                &self.raster_data_collection_arn,
            );
            formatter.field("time_range_filter", &"*** Sensitive Data Redacted ***");
            formatter.field("area_of_interest", &self.area_of_interest);
            formatter.field("property_filters", &self.property_filters);
            formatter.finish()
        }
    }
}
impl RasterDataCollectionQueryInput {
    /// Creates a new builder-style object to manufacture [`RasterDataCollectionQueryInput`](crate::model::RasterDataCollectionQueryInput).
    pub fn builder() -> crate::model::raster_data_collection_query_input::Builder {
        crate::model::raster_data_collection_query_input::Builder::default()
    }
}

/// <p>The structure for returning the export error details in a GetEarthObservationJob.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExportErrorDetails {
    /// <p></p>
    #[doc(hidden)]
    pub export_results: std::option::Option<crate::model::ExportErrorDetailsOutput>,
    /// <p></p>
    #[doc(hidden)]
    pub export_source_images: std::option::Option<crate::model::ExportErrorDetailsOutput>,
}
impl ExportErrorDetails {
    /// <p></p>
    pub fn export_results(&self) -> std::option::Option<&crate::model::ExportErrorDetailsOutput> {
        self.export_results.as_ref()
    }
    /// <p></p>
    pub fn export_source_images(
        &self,
    ) -> std::option::Option<&crate::model::ExportErrorDetailsOutput> {
        self.export_source_images.as_ref()
    }
}
/// See [`ExportErrorDetails`](crate::model::ExportErrorDetails).
pub mod export_error_details {

    /// A builder for [`ExportErrorDetails`](crate::model::ExportErrorDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) export_results: std::option::Option<crate::model::ExportErrorDetailsOutput>,
        pub(crate) export_source_images:
            std::option::Option<crate::model::ExportErrorDetailsOutput>,
    }
    impl Builder {
        /// <p></p>
        pub fn export_results(mut self, input: crate::model::ExportErrorDetailsOutput) -> Self {
            self.export_results = Some(input);
            self
        }
        /// <p></p>
        pub fn set_export_results(
            mut self,
            input: std::option::Option<crate::model::ExportErrorDetailsOutput>,
        ) -> Self {
            self.export_results = input;
            self
        }
        /// <p></p>
        pub fn export_source_images(
            mut self,
            input: crate::model::ExportErrorDetailsOutput,
        ) -> Self {
            self.export_source_images = Some(input);
            self
        }
        /// <p></p>
        pub fn set_export_source_images(
            mut self,
            input: std::option::Option<crate::model::ExportErrorDetailsOutput>,
        ) -> Self {
            self.export_source_images = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportErrorDetails`](crate::model::ExportErrorDetails).
        pub fn build(self) -> crate::model::ExportErrorDetails {
            crate::model::ExportErrorDetails {
                export_results: self.export_results,
                export_source_images: self.export_source_images,
            }
        }
    }
}
impl ExportErrorDetails {
    /// Creates a new builder-style object to manufacture [`ExportErrorDetails`](crate::model::ExportErrorDetails).
    pub fn builder() -> crate::model::export_error_details::Builder {
        crate::model::export_error_details::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExportErrorDetailsOutput {
    /// <p></p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ExportErrorType>,
    /// <p></p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ExportErrorDetailsOutput {
    /// <p></p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ExportErrorType> {
        self.r#type.as_ref()
    }
    /// <p></p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`ExportErrorDetailsOutput`](crate::model::ExportErrorDetailsOutput).
pub mod export_error_details_output {

    /// A builder for [`ExportErrorDetailsOutput`](crate::model::ExportErrorDetailsOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::ExportErrorType>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p></p>
        pub fn r#type(mut self, input: crate::model::ExportErrorType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p></p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ExportErrorType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p></p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportErrorDetailsOutput`](crate::model::ExportErrorDetailsOutput).
        pub fn build(self) -> crate::model::ExportErrorDetailsOutput {
            crate::model::ExportErrorDetailsOutput {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl ExportErrorDetailsOutput {
    /// Creates a new builder-style object to manufacture [`ExportErrorDetailsOutput`](crate::model::ExportErrorDetailsOutput).
    pub fn builder() -> crate::model::export_error_details_output::Builder {
        crate::model::export_error_details_output::Builder::default()
    }
}

/// When writing a match expression against `ExportErrorType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let exporterrortype = unimplemented!();
/// match exporterrortype {
///     ExportErrorType::ClientError => { /* ... */ },
///     ExportErrorType::ServerError => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `exporterrortype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ExportErrorType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ExportErrorType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ExportErrorType::NewFeature` is defined.
/// Specifically, when `exporterrortype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ExportErrorType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExportErrorType {
    /// CLIENT_ERROR
    ClientError,
    /// SERVER_ERROR
    ServerError,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ExportErrorType {
    fn from(s: &str) -> Self {
        match s {
            "CLIENT_ERROR" => ExportErrorType::ClientError,
            "SERVER_ERROR" => ExportErrorType::ServerError,
            other => ExportErrorType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ExportErrorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ExportErrorType::from(s))
    }
}
impl ExportErrorType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExportErrorType::ClientError => "CLIENT_ERROR",
            ExportErrorType::ServerError => "SERVER_ERROR",
            ExportErrorType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CLIENT_ERROR", "SERVER_ERROR"]
    }
}
impl AsRef<str> for ExportErrorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The structure representing the errors in an EarthObservationJob.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EarthObservationJobErrorDetails {
    /// <p></p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::EarthObservationJobErrorType>,
    /// <p></p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl EarthObservationJobErrorDetails {
    /// <p></p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::EarthObservationJobErrorType> {
        self.r#type.as_ref()
    }
    /// <p></p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`EarthObservationJobErrorDetails`](crate::model::EarthObservationJobErrorDetails).
pub mod earth_observation_job_error_details {

    /// A builder for [`EarthObservationJobErrorDetails`](crate::model::EarthObservationJobErrorDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::EarthObservationJobErrorType>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p></p>
        pub fn r#type(mut self, input: crate::model::EarthObservationJobErrorType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p></p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::EarthObservationJobErrorType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p></p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EarthObservationJobErrorDetails`](crate::model::EarthObservationJobErrorDetails).
        pub fn build(self) -> crate::model::EarthObservationJobErrorDetails {
            crate::model::EarthObservationJobErrorDetails {
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl EarthObservationJobErrorDetails {
    /// Creates a new builder-style object to manufacture [`EarthObservationJobErrorDetails`](crate::model::EarthObservationJobErrorDetails).
    pub fn builder() -> crate::model::earth_observation_job_error_details::Builder {
        crate::model::earth_observation_job_error_details::Builder::default()
    }
}

/// When writing a match expression against `EarthObservationJobErrorType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let earthobservationjoberrortype = unimplemented!();
/// match earthobservationjoberrortype {
///     EarthObservationJobErrorType::ClientError => { /* ... */ },
///     EarthObservationJobErrorType::ServerError => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `earthobservationjoberrortype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EarthObservationJobErrorType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EarthObservationJobErrorType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EarthObservationJobErrorType::NewFeature` is defined.
/// Specifically, when `earthobservationjoberrortype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EarthObservationJobErrorType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EarthObservationJobErrorType {
    /// CLIENT_ERROR
    ClientError,
    /// SERVER_ERROR
    ServerError,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EarthObservationJobErrorType {
    fn from(s: &str) -> Self {
        match s {
            "CLIENT_ERROR" => EarthObservationJobErrorType::ClientError,
            "SERVER_ERROR" => EarthObservationJobErrorType::ServerError,
            other => EarthObservationJobErrorType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for EarthObservationJobErrorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EarthObservationJobErrorType::from(s))
    }
}
impl EarthObservationJobErrorType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EarthObservationJobErrorType::ClientError => "CLIENT_ERROR",
            EarthObservationJobErrorType::ServerError => "SERVER_ERROR",
            EarthObservationJobErrorType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CLIENT_ERROR", "SERVER_ERROR"]
    }
}
impl AsRef<str> for EarthObservationJobErrorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A single EarthObservationJob output band.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OutputBand {
    /// <p>The name of the band.</p>
    #[doc(hidden)]
    pub band_name: std::option::Option<std::string::String>,
    /// <p>The datatype of the output band.</p>
    #[doc(hidden)]
    pub output_data_type: std::option::Option<crate::model::OutputType>,
}
impl OutputBand {
    /// <p>The name of the band.</p>
    pub fn band_name(&self) -> std::option::Option<&str> {
        self.band_name.as_deref()
    }
    /// <p>The datatype of the output band.</p>
    pub fn output_data_type(&self) -> std::option::Option<&crate::model::OutputType> {
        self.output_data_type.as_ref()
    }
}
/// See [`OutputBand`](crate::model::OutputBand).
pub mod output_band {

    /// A builder for [`OutputBand`](crate::model::OutputBand).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) band_name: std::option::Option<std::string::String>,
        pub(crate) output_data_type: std::option::Option<crate::model::OutputType>,
    }
    impl Builder {
        /// <p>The name of the band.</p>
        pub fn band_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.band_name = Some(input.into());
            self
        }
        /// <p>The name of the band.</p>
        pub fn set_band_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.band_name = input;
            self
        }
        /// <p>The datatype of the output band.</p>
        pub fn output_data_type(mut self, input: crate::model::OutputType) -> Self {
            self.output_data_type = Some(input);
            self
        }
        /// <p>The datatype of the output band.</p>
        pub fn set_output_data_type(
            mut self,
            input: std::option::Option<crate::model::OutputType>,
        ) -> Self {
            self.output_data_type = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputBand`](crate::model::OutputBand).
        pub fn build(self) -> crate::model::OutputBand {
            crate::model::OutputBand {
                band_name: self.band_name,
                output_data_type: self.output_data_type,
            }
        }
    }
}
impl OutputBand {
    /// Creates a new builder-style object to manufacture [`OutputBand`](crate::model::OutputBand).
    pub fn builder() -> crate::model::output_band::Builder {
        crate::model::output_band::Builder::default()
    }
}
