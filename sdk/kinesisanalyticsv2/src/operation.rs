// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Adds an Amazon CloudWatch log stream to monitor application configuration errors.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddApplicationCloudWatchLoggingOption {
    _private: (),
}
impl AddApplicationCloudWatchLoggingOption {
    /// Creates a new builder-style object to manufacture [`AddApplicationCloudWatchLoggingOptionInput`](crate::input::AddApplicationCloudWatchLoggingOptionInput)
    pub fn builder() -> crate::input::add_application_cloud_watch_logging_option_input::Builder {
        crate::input::add_application_cloud_watch_logging_option_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddApplicationCloudWatchLoggingOption {
    type Output = std::result::Result<
        crate::output::AddApplicationCloudWatchLoggingOptionOutput,
        crate::error::AddApplicationCloudWatchLoggingOptionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_add_application_cloud_watch_logging_option_error(response)
        } else {
            crate::operation_deser::parse_add_application_cloud_watch_logging_option_response(
                response,
            )
        }
    }
}

/// <p>
/// Adds a streaming source to your SQL-based Kinesis Data Analytics application.
/// </p>
/// <p>You can add a streaming source when you create an application, or you can use this
/// operation to add a streaming source after you create an application. For more information, see
/// <a>CreateApplication</a>.</p>
/// <p>Any configuration update, including adding a streaming source using this operation,  
/// results in a new version of the application. You can use the <a>DescribeApplication</a> operation  
/// to find the current application version.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddApplicationInput {
    _private: (),
}
impl AddApplicationInput {
    /// Creates a new builder-style object to manufacture [`AddApplicationInputInput`](crate::input::AddApplicationInputInput)
    pub fn builder() -> crate::input::add_application_input_input::Builder {
        crate::input::add_application_input_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddApplicationInput {
    type Output = std::result::Result<
        crate::output::AddApplicationInputOutput,
        crate::error::AddApplicationInputError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_add_application_input_error(response)
        } else {
            crate::operation_deser::parse_add_application_input_response(response)
        }
    }
}

/// <p>Adds an <a>InputProcessingConfiguration</a> to a SQL-based Kinesis Data Analytics application. An input processor pre-processes records
/// on the input stream before the
/// application's SQL code executes. Currently, the only input processor available is <a href="https://docs.aws.amazon.com/lambda/">AWS Lambda</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddApplicationInputProcessingConfiguration {
    _private: (),
}
impl AddApplicationInputProcessingConfiguration {
    /// Creates a new builder-style object to manufacture [`AddApplicationInputProcessingConfigurationInput`](crate::input::AddApplicationInputProcessingConfigurationInput)
    pub fn builder() -> crate::input::add_application_input_processing_configuration_input::Builder
    {
        crate::input::add_application_input_processing_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddApplicationInputProcessingConfiguration {
    type Output = std::result::Result<
        crate::output::AddApplicationInputProcessingConfigurationOutput,
        crate::error::AddApplicationInputProcessingConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_add_application_input_processing_configuration_error(
                response,
            )
        } else {
            crate::operation_deser::parse_add_application_input_processing_configuration_response(
                response,
            )
        }
    }
}

/// <p>Adds an external destination to your SQL-based Kinesis Data Analytics application.</p>
/// <p>If you want Kinesis Data Analytics to deliver data from an in-application stream within
/// your application to an external destination (such as an Kinesis data stream, a Kinesis Data
/// Firehose delivery stream, or an AWS Lambda function), you add the relevant configuration to
/// your application using this operation. You can configure one or more outputs for your
/// application. Each output configuration maps an in-application stream and an external
/// destination.</p>
/// <p> You can use one of the output configurations to deliver data from your
/// in-application error stream to an external destination so that you can analyze the
/// errors.  </p>
/// <p> Any configuration update, including adding a streaming source using this
/// operation, results in a new version of the application. You can use the <a>DescribeApplication</a> operation to find the current application
/// version.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddApplicationOutput {
    _private: (),
}
impl AddApplicationOutput {
    /// Creates a new builder-style object to manufacture [`AddApplicationOutputInput`](crate::input::AddApplicationOutputInput)
    pub fn builder() -> crate::input::add_application_output_input::Builder {
        crate::input::add_application_output_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddApplicationOutput {
    type Output = std::result::Result<
        crate::output::AddApplicationOutputOutput,
        crate::error::AddApplicationOutputError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_add_application_output_error(response)
        } else {
            crate::operation_deser::parse_add_application_output_response(response)
        }
    }
}

/// <p>Adds a reference data source to an existing SQL-based Kinesis Data Analytics application.</p>
/// <p>Kinesis Data Analytics reads reference data (that is, an Amazon S3 object) and creates an
/// in-application table within your application. In the request, you provide the source (S3
/// bucket name and object key name), name of the in-application table to create, and the
/// necessary mapping information that describes how data in an Amazon S3 object maps to columns
/// in the resulting in-application table.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddApplicationReferenceDataSource {
    _private: (),
}
impl AddApplicationReferenceDataSource {
    /// Creates a new builder-style object to manufacture [`AddApplicationReferenceDataSourceInput`](crate::input::AddApplicationReferenceDataSourceInput)
    pub fn builder() -> crate::input::add_application_reference_data_source_input::Builder {
        crate::input::add_application_reference_data_source_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddApplicationReferenceDataSource {
    type Output = std::result::Result<
        crate::output::AddApplicationReferenceDataSourceOutput,
        crate::error::AddApplicationReferenceDataSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_add_application_reference_data_source_error(response)
        } else {
            crate::operation_deser::parse_add_application_reference_data_source_response(response)
        }
    }
}

/// <p>Adds a Virtual Private Cloud (VPC) configuration to the application. Applications can use VPCs to store
/// and access resources securely.</p>
/// <p>Note the following about VPC configurations for Kinesis Data Analytics applications:</p>
/// <ul>
/// <li>
/// <p>VPC configurations are not supported for SQL applications.</p>
/// </li>
/// <li>
/// <p>When a VPC is added to a Kinesis Data Analytics application, the application can no longer be accessed from the
/// Internet directly. To enable Internet access to the application, add an Internet gateway to your VPC.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddApplicationVpcConfiguration {
    _private: (),
}
impl AddApplicationVpcConfiguration {
    /// Creates a new builder-style object to manufacture [`AddApplicationVpcConfigurationInput`](crate::input::AddApplicationVpcConfigurationInput)
    pub fn builder() -> crate::input::add_application_vpc_configuration_input::Builder {
        crate::input::add_application_vpc_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddApplicationVpcConfiguration {
    type Output = std::result::Result<
        crate::output::AddApplicationVpcConfigurationOutput,
        crate::error::AddApplicationVpcConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_add_application_vpc_configuration_error(response)
        } else {
            crate::operation_deser::parse_add_application_vpc_configuration_response(response)
        }
    }
}

/// <p>Creates a Kinesis Data Analytics application. For information about creating a
/// Kinesis Data Analytics application, see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/java/getting-started.html">Creating an
/// Application</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateApplication {
    _private: (),
}
impl CreateApplication {
    /// Creates a new builder-style object to manufacture [`CreateApplicationInput`](crate::input::CreateApplicationInput)
    pub fn builder() -> crate::input::create_application_input::Builder {
        crate::input::create_application_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateApplication {
    type Output = std::result::Result<
        crate::output::CreateApplicationOutput,
        crate::error::CreateApplicationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_application_error(response)
        } else {
            crate::operation_deser::parse_create_application_response(response)
        }
    }
}

/// <p>Creates and returns a URL that you can use to connect to
/// an application's extension. Currently, the only
/// available extension is the Apache Flink dashboard.</p>
/// <p>The IAM role or user used to call this API defines the permissions to access the
/// extension. After the presigned URL is created, no additional permission is required to access
/// this URL. IAM authorization policies for this API are also enforced for every HTTP request
/// that attempts to connect to the extension. </p>
/// <p>You    control the amount of time that the URL will be valid using the <code>SessionExpirationDurationInSeconds</code>
/// parameter. If you do not provide this parameter, the returned URL is valid for twelve hours.</p>
/// <note>
/// <p>The URL that you get from a call to CreateApplicationPresignedUrl must be used within 3 minutes
/// to be valid.
/// If you first try to use the URL after the 3-minute limit expires, the service returns an HTTP 403 Forbidden error.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateApplicationPresignedUrl {
    _private: (),
}
impl CreateApplicationPresignedUrl {
    /// Creates a new builder-style object to manufacture [`CreateApplicationPresignedUrlInput`](crate::input::CreateApplicationPresignedUrlInput)
    pub fn builder() -> crate::input::create_application_presigned_url_input::Builder {
        crate::input::create_application_presigned_url_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateApplicationPresignedUrl {
    type Output = std::result::Result<
        crate::output::CreateApplicationPresignedUrlOutput,
        crate::error::CreateApplicationPresignedUrlError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_application_presigned_url_error(response)
        } else {
            crate::operation_deser::parse_create_application_presigned_url_response(response)
        }
    }
}

/// <p>Creates a snapshot of the application's state data.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateApplicationSnapshot {
    _private: (),
}
impl CreateApplicationSnapshot {
    /// Creates a new builder-style object to manufacture [`CreateApplicationSnapshotInput`](crate::input::CreateApplicationSnapshotInput)
    pub fn builder() -> crate::input::create_application_snapshot_input::Builder {
        crate::input::create_application_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateApplicationSnapshot {
    type Output = std::result::Result<
        crate::output::CreateApplicationSnapshotOutput,
        crate::error::CreateApplicationSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_application_snapshot_error(response)
        } else {
            crate::operation_deser::parse_create_application_snapshot_response(response)
        }
    }
}

/// <p>Deletes the specified application. Kinesis Data Analytics halts application execution and deletes the application.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteApplication {
    _private: (),
}
impl DeleteApplication {
    /// Creates a new builder-style object to manufacture [`DeleteApplicationInput`](crate::input::DeleteApplicationInput)
    pub fn builder() -> crate::input::delete_application_input::Builder {
        crate::input::delete_application_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteApplication {
    type Output = std::result::Result<
        crate::output::DeleteApplicationOutput,
        crate::error::DeleteApplicationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_application_error(response)
        } else {
            crate::operation_deser::parse_delete_application_response(response)
        }
    }
}

/// <p>Deletes an Amazon CloudWatch log stream from an Kinesis Data Analytics application. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteApplicationCloudWatchLoggingOption {
    _private: (),
}
impl DeleteApplicationCloudWatchLoggingOption {
    /// Creates a new builder-style object to manufacture [`DeleteApplicationCloudWatchLoggingOptionInput`](crate::input::DeleteApplicationCloudWatchLoggingOptionInput)
    pub fn builder() -> crate::input::delete_application_cloud_watch_logging_option_input::Builder {
        crate::input::delete_application_cloud_watch_logging_option_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteApplicationCloudWatchLoggingOption {
    type Output = std::result::Result<
        crate::output::DeleteApplicationCloudWatchLoggingOptionOutput,
        crate::error::DeleteApplicationCloudWatchLoggingOptionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_application_cloud_watch_logging_option_error(
                response,
            )
        } else {
            crate::operation_deser::parse_delete_application_cloud_watch_logging_option_response(
                response,
            )
        }
    }
}

/// <p>Deletes an <a>InputProcessingConfiguration</a> from an input.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteApplicationInputProcessingConfiguration {
    _private: (),
}
impl DeleteApplicationInputProcessingConfiguration {
    /// Creates a new builder-style object to manufacture [`DeleteApplicationInputProcessingConfigurationInput`](crate::input::DeleteApplicationInputProcessingConfigurationInput)
    pub fn builder(
    ) -> crate::input::delete_application_input_processing_configuration_input::Builder {
        crate::input::delete_application_input_processing_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteApplicationInputProcessingConfiguration {
    type Output = std::result::Result<
        crate::output::DeleteApplicationInputProcessingConfigurationOutput,
        crate::error::DeleteApplicationInputProcessingConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_application_input_processing_configuration_error(
                response,
            )
        } else {
            crate::operation_deser::parse_delete_application_input_processing_configuration_response(
                response,
            )
        }
    }
}

/// <p>Deletes the output destination configuration from your SQL-based Kinesis Data Analytics application's configuration.
/// Kinesis Data Analytics will no longer write data from
/// the corresponding in-application stream to the external output destination.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteApplicationOutput {
    _private: (),
}
impl DeleteApplicationOutput {
    /// Creates a new builder-style object to manufacture [`DeleteApplicationOutputInput`](crate::input::DeleteApplicationOutputInput)
    pub fn builder() -> crate::input::delete_application_output_input::Builder {
        crate::input::delete_application_output_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteApplicationOutput {
    type Output = std::result::Result<
        crate::output::DeleteApplicationOutputOutput,
        crate::error::DeleteApplicationOutputError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_application_output_error(response)
        } else {
            crate::operation_deser::parse_delete_application_output_response(response)
        }
    }
}

/// <p>Deletes a reference data source configuration from the specified SQL-based Kinesis Data Analytics application's configuration.</p>
/// <p>If the application is running, Kinesis Data Analytics immediately removes the in-application table
/// that you created using the <a>AddApplicationReferenceDataSource</a> operation.  </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteApplicationReferenceDataSource {
    _private: (),
}
impl DeleteApplicationReferenceDataSource {
    /// Creates a new builder-style object to manufacture [`DeleteApplicationReferenceDataSourceInput`](crate::input::DeleteApplicationReferenceDataSourceInput)
    pub fn builder() -> crate::input::delete_application_reference_data_source_input::Builder {
        crate::input::delete_application_reference_data_source_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteApplicationReferenceDataSource {
    type Output = std::result::Result<
        crate::output::DeleteApplicationReferenceDataSourceOutput,
        crate::error::DeleteApplicationReferenceDataSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_application_reference_data_source_error(response)
        } else {
            crate::operation_deser::parse_delete_application_reference_data_source_response(
                response,
            )
        }
    }
}

/// <p>Deletes a snapshot of application state.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteApplicationSnapshot {
    _private: (),
}
impl DeleteApplicationSnapshot {
    /// Creates a new builder-style object to manufacture [`DeleteApplicationSnapshotInput`](crate::input::DeleteApplicationSnapshotInput)
    pub fn builder() -> crate::input::delete_application_snapshot_input::Builder {
        crate::input::delete_application_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteApplicationSnapshot {
    type Output = std::result::Result<
        crate::output::DeleteApplicationSnapshotOutput,
        crate::error::DeleteApplicationSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_application_snapshot_error(response)
        } else {
            crate::operation_deser::parse_delete_application_snapshot_response(response)
        }
    }
}

/// <p>Removes a VPC configuration from a Kinesis Data Analytics application.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteApplicationVpcConfiguration {
    _private: (),
}
impl DeleteApplicationVpcConfiguration {
    /// Creates a new builder-style object to manufacture [`DeleteApplicationVpcConfigurationInput`](crate::input::DeleteApplicationVpcConfigurationInput)
    pub fn builder() -> crate::input::delete_application_vpc_configuration_input::Builder {
        crate::input::delete_application_vpc_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteApplicationVpcConfiguration {
    type Output = std::result::Result<
        crate::output::DeleteApplicationVpcConfigurationOutput,
        crate::error::DeleteApplicationVpcConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_application_vpc_configuration_error(response)
        } else {
            crate::operation_deser::parse_delete_application_vpc_configuration_response(response)
        }
    }
}

/// <p>Returns information about a specific Kinesis Data Analytics application.</p>
/// <p>If you want to retrieve a list of all applications in your account,
/// use the <a>ListApplications</a> operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeApplication {
    _private: (),
}
impl DescribeApplication {
    /// Creates a new builder-style object to manufacture [`DescribeApplicationInput`](crate::input::DescribeApplicationInput)
    pub fn builder() -> crate::input::describe_application_input::Builder {
        crate::input::describe_application_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeApplication {
    type Output = std::result::Result<
        crate::output::DescribeApplicationOutput,
        crate::error::DescribeApplicationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_application_error(response)
        } else {
            crate::operation_deser::parse_describe_application_response(response)
        }
    }
}

/// <p>Returns information about a snapshot of application state data.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeApplicationSnapshot {
    _private: (),
}
impl DescribeApplicationSnapshot {
    /// Creates a new builder-style object to manufacture [`DescribeApplicationSnapshotInput`](crate::input::DescribeApplicationSnapshotInput)
    pub fn builder() -> crate::input::describe_application_snapshot_input::Builder {
        crate::input::describe_application_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeApplicationSnapshot {
    type Output = std::result::Result<
        crate::output::DescribeApplicationSnapshotOutput,
        crate::error::DescribeApplicationSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_application_snapshot_error(response)
        } else {
            crate::operation_deser::parse_describe_application_snapshot_response(response)
        }
    }
}

/// <p>Provides a detailed description of a specified version of the application. To see a list of all the versions of an application, invoke the <a>ListApplicationVersions</a> operation.</p>
/// <note>
/// <p>This operation is supported only for Amazon Kinesis Data Analytics for Apache Flink.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeApplicationVersion {
    _private: (),
}
impl DescribeApplicationVersion {
    /// Creates a new builder-style object to manufacture [`DescribeApplicationVersionInput`](crate::input::DescribeApplicationVersionInput)
    pub fn builder() -> crate::input::describe_application_version_input::Builder {
        crate::input::describe_application_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeApplicationVersion {
    type Output = std::result::Result<
        crate::output::DescribeApplicationVersionOutput,
        crate::error::DescribeApplicationVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_application_version_error(response)
        } else {
            crate::operation_deser::parse_describe_application_version_response(response)
        }
    }
}

/// <p>Infers a schema for a SQL-based Kinesis Data Analytics application by evaluating
/// sample records on the specified streaming source (Kinesis data stream or Kinesis Data Firehose
/// delivery stream) or Amazon S3 object. In the response, the operation returns the inferred
/// schema and also the sample records that the operation used to infer the schema.</p>
/// <p> You can use the inferred schema when configuring a streaming source for your application.
/// When you create an application using the Kinesis Data Analytics console, the console uses this
/// operation to infer a schema and show it in the console user interface. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DiscoverInputSchema {
    _private: (),
}
impl DiscoverInputSchema {
    /// Creates a new builder-style object to manufacture [`DiscoverInputSchemaInput`](crate::input::DiscoverInputSchemaInput)
    pub fn builder() -> crate::input::discover_input_schema_input::Builder {
        crate::input::discover_input_schema_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DiscoverInputSchema {
    type Output = std::result::Result<
        crate::output::DiscoverInputSchemaOutput,
        crate::error::DiscoverInputSchemaError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_discover_input_schema_error(response)
        } else {
            crate::operation_deser::parse_discover_input_schema_response(response)
        }
    }
}

/// <p>Returns a list of Kinesis Data Analytics applications in your account. For each
/// application, the response includes the application name, Amazon Resource Name (ARN), and
/// status. </p>
/// <p>If you want detailed information about a specific application, use
/// <a>DescribeApplication</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListApplications {
    _private: (),
}
impl ListApplications {
    /// Creates a new builder-style object to manufacture [`ListApplicationsInput`](crate::input::ListApplicationsInput)
    pub fn builder() -> crate::input::list_applications_input::Builder {
        crate::input::list_applications_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListApplications {
    type Output = std::result::Result<
        crate::output::ListApplicationsOutput,
        crate::error::ListApplicationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_applications_error(response)
        } else {
            crate::operation_deser::parse_list_applications_response(response)
        }
    }
}

/// <p>Lists information about the current application snapshots.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListApplicationSnapshots {
    _private: (),
}
impl ListApplicationSnapshots {
    /// Creates a new builder-style object to manufacture [`ListApplicationSnapshotsInput`](crate::input::ListApplicationSnapshotsInput)
    pub fn builder() -> crate::input::list_application_snapshots_input::Builder {
        crate::input::list_application_snapshots_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListApplicationSnapshots {
    type Output = std::result::Result<
        crate::output::ListApplicationSnapshotsOutput,
        crate::error::ListApplicationSnapshotsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_application_snapshots_error(response)
        } else {
            crate::operation_deser::parse_list_application_snapshots_response(response)
        }
    }
}

/// <p>Lists all the versions for the specified application, including versions that were rolled back. The response also includes a summary of the configuration
/// associated with each version.</p>
/// <p>To get the complete description of a specific application version, invoke the <a>DescribeApplicationVersion</a> operation.</p>
/// <note>
/// <p>This operation is supported only for Amazon Kinesis Data Analytics for Apache Flink.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListApplicationVersions {
    _private: (),
}
impl ListApplicationVersions {
    /// Creates a new builder-style object to manufacture [`ListApplicationVersionsInput`](crate::input::ListApplicationVersionsInput)
    pub fn builder() -> crate::input::list_application_versions_input::Builder {
        crate::input::list_application_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListApplicationVersions {
    type Output = std::result::Result<
        crate::output::ListApplicationVersionsOutput,
        crate::error::ListApplicationVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_application_versions_error(response)
        } else {
            crate::operation_deser::parse_list_application_versions_response(response)
        }
    }
}

/// <p>Retrieves the list of key-value tags assigned to the application. For more information, see
/// <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/java/how-tagging.html">Using Tagging</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Reverts the application to the previous running version. You can
/// roll back an application if you suspect it is stuck in a transient status. </p>
/// <p>You can roll back an application only if it is in the <code>UPDATING</code>
/// or <code>AUTOSCALING</code> status.</p>
/// <p>When you rollback an application, it loads state data from the last successful snapshot.
/// If the application has no snapshots, Kinesis Data Analytics rejects the rollback request.</p>
/// <p>This action is not supported for Kinesis Data Analytics for SQL applications.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RollbackApplication {
    _private: (),
}
impl RollbackApplication {
    /// Creates a new builder-style object to manufacture [`RollbackApplicationInput`](crate::input::RollbackApplicationInput)
    pub fn builder() -> crate::input::rollback_application_input::Builder {
        crate::input::rollback_application_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RollbackApplication {
    type Output = std::result::Result<
        crate::output::RollbackApplicationOutput,
        crate::error::RollbackApplicationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_rollback_application_error(response)
        } else {
            crate::operation_deser::parse_rollback_application_response(response)
        }
    }
}

/// <p>Starts the specified Kinesis Data Analytics application. After creating an application, you must exclusively call this operation to
/// start your application.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartApplication {
    _private: (),
}
impl StartApplication {
    /// Creates a new builder-style object to manufacture [`StartApplicationInput`](crate::input::StartApplicationInput)
    pub fn builder() -> crate::input::start_application_input::Builder {
        crate::input::start_application_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartApplication {
    type Output = std::result::Result<
        crate::output::StartApplicationOutput,
        crate::error::StartApplicationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_application_error(response)
        } else {
            crate::operation_deser::parse_start_application_response(response)
        }
    }
}

/// <p>Stops the application from processing data. You can stop
/// an application only if it is in the running status, unless you set the <code>Force</code>
/// parameter to <code>true</code>.</p>
/// <p>You can use the <a>DescribeApplication</a> operation to find the application status.
/// </p>
/// <p>Kinesis Data Analytics takes a snapshot when the application is stopped, unless <code>Force</code> is set
/// to <code>true</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopApplication {
    _private: (),
}
impl StopApplication {
    /// Creates a new builder-style object to manufacture [`StopApplicationInput`](crate::input::StopApplicationInput)
    pub fn builder() -> crate::input::stop_application_input::Builder {
        crate::input::stop_application_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopApplication {
    type Output = std::result::Result<
        crate::output::StopApplicationOutput,
        crate::error::StopApplicationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_application_error(response)
        } else {
            crate::operation_deser::parse_stop_application_response(response)
        }
    }
}

/// <p>Adds one or more key-value tags to a Kinesis Data Analytics application. Note that the maximum number of application
/// tags includes system tags. The maximum number of user-defined application tags is 50.
/// For more information, see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/java/how-tagging.html">Using Tagging</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes one or more tags from a Kinesis Data Analytics application. For more information, see
/// <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/java/how-tagging.html">Using Tagging</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates an existing Kinesis Data Analytics application. Using this operation, you
/// can update application code, input configuration, and output configuration. </p>
/// <p>Kinesis Data Analytics updates the <code>ApplicationVersionId</code> each time you update
/// your application. </p>
/// <note>
/// <p>You cannot update the <code>RuntimeEnvironment</code> of an existing application. If you
/// need to update an application's <code>RuntimeEnvironment</code>, you must delete the application
/// and create it again.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateApplication {
    _private: (),
}
impl UpdateApplication {
    /// Creates a new builder-style object to manufacture [`UpdateApplicationInput`](crate::input::UpdateApplicationInput)
    pub fn builder() -> crate::input::update_application_input::Builder {
        crate::input::update_application_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateApplication {
    type Output = std::result::Result<
        crate::output::UpdateApplicationOutput,
        crate::error::UpdateApplicationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_application_error(response)
        } else {
            crate::operation_deser::parse_update_application_response(response)
        }
    }
}

/// <p>Updates the maintenance configuration of the Kinesis Data Analytics application. </p>
/// <p>You can invoke this operation on an application that is in one of the two following
/// states: <code>READY</code> or <code>RUNNING</code>. If you invoke it when the application is
/// in a state other than these two states, it throws a <code>ResourceInUseException</code>. The
/// service makes use of the updated configuration the next time it schedules maintenance for the
/// application. If you invoke this operation after the service schedules maintenance, the service
/// will apply the configuration update the next time it schedules maintenance for the
/// application. This means that you might not see the maintenance configuration update applied to
/// the maintenance process that follows a successful invocation of this operation, but to the
/// following maintenance process instead.</p>
/// <p>To see the current maintenance configuration of your application, invoke the
/// <a>DescribeApplication</a> operation.</p>
/// <p>For information about application maintenance, see <a href="https://docs.aws.amazon.com/kinesisanalytics/latest/java/maintenance.html">Kinesis Data Analytics for Apache Flink Maintenance</a>.</p>
/// <note>
/// <p>This operation is supported only for Amazon Kinesis Data Analytics for Apache Flink.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateApplicationMaintenanceConfiguration {
    _private: (),
}
impl UpdateApplicationMaintenanceConfiguration {
    /// Creates a new builder-style object to manufacture [`UpdateApplicationMaintenanceConfigurationInput`](crate::input::UpdateApplicationMaintenanceConfigurationInput)
    pub fn builder() -> crate::input::update_application_maintenance_configuration_input::Builder {
        crate::input::update_application_maintenance_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateApplicationMaintenanceConfiguration {
    type Output = std::result::Result<
        crate::output::UpdateApplicationMaintenanceConfigurationOutput,
        crate::error::UpdateApplicationMaintenanceConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_application_maintenance_configuration_error(
                response,
            )
        } else {
            crate::operation_deser::parse_update_application_maintenance_configuration_response(
                response,
            )
        }
    }
}
